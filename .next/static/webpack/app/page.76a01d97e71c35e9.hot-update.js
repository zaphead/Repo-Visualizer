"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/page",{

/***/ "(app-pages-browser)/./lib/browser-scan.ts":
/*!*****************************!*\
  !*** ./lib/browser-scan.ts ***!
  \*****************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   scanDirectoryHandle: function() { return /* binding */ scanDirectoryHandle; }\n/* harmony export */ });\n/* harmony import */ var ignore__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ignore */ \"(app-pages-browser)/./node_modules/ignore/index.js\");\n/* harmony import */ var ignore__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(ignore__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _babel_parser__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @babel/parser */ \"(app-pages-browser)/./node_modules/@babel/parser/lib/index.js\");\n/* harmony import */ var _babel_traverse__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @babel/traverse */ \"(app-pages-browser)/./node_modules/@babel/traverse/lib/index.js\");\n\n\n\nconst ALWAYS_IGNORE = [\n    \".git/\",\n    \"node_modules/\",\n    \".next/\",\n    \"dist/\",\n    \"build/\",\n    \"out/\",\n    \"coverage/\",\n    \".turbo/\",\n    \".cache/\",\n    \".DS_Store\"\n];\nconst SCRIPT_EXTENSIONS = new Set([\n    \".js\",\n    \".jsx\",\n    \".ts\",\n    \".tsx\",\n    \".mjs\",\n    \".cjs\"\n]);\nconst STYLE_EXTENSIONS = new Set([\n    \".css\",\n    \".scss\",\n    \".sass\"\n]);\nconst SUPPORTED_EXTENSIONS = new Set([\n    ...SCRIPT_EXTENSIONS,\n    ...STYLE_EXTENSIONS\n]);\nconst IMPORT_EXTENSIONS = [\n    \".ts\",\n    \".tsx\",\n    \".js\",\n    \".jsx\",\n    \".mjs\",\n    \".cjs\",\n    \".css\",\n    \".scss\",\n    \".sass\"\n];\nconst ROUTE_REGEX = {\n    app: /(^|\\/)app\\/(.*\\/)?(page|route)\\.(t|j)sx?$/,\n    pages: /(^|\\/)pages\\/.+\\.(t|j)sx?$/\n};\nconst posixJoin = function() {\n    for(var _len = arguments.length, parts = new Array(_len), _key = 0; _key < _len; _key++){\n        parts[_key] = arguments[_key];\n    }\n    return parts.filter(Boolean).join(\"/\").replace(/\\/+/g, \"/\");\n};\nconst posixDirname = (value)=>{\n    const idx = value.lastIndexOf(\"/\");\n    return idx === -1 ? \"\" : value.slice(0, idx);\n};\nconst posixBasename = (value)=>{\n    const idx = value.lastIndexOf(\"/\");\n    return idx === -1 ? value : value.slice(idx + 1);\n};\nconst posixExtname = (value)=>{\n    const base = posixBasename(value);\n    const idx = base.lastIndexOf(\".\");\n    return idx === -1 ? \"\" : base.slice(idx);\n};\nconst normalizePosixPath = (value)=>{\n    const parts = value.split(\"/\");\n    const stack = [];\n    let escapedRoot = false;\n    for (const part of parts){\n        if (!part || part === \".\") continue;\n        if (part === \"..\") {\n            if (stack.length) {\n                stack.pop();\n            } else {\n                escapedRoot = true;\n            }\n            continue;\n        }\n        stack.push(part);\n    }\n    return {\n        path: stack.join(\"/\"),\n        escapedRoot\n    };\n};\nconst normalizeGitignorePattern = (dirRel, rawPattern)=>{\n    let pattern = rawPattern.trim();\n    if (!pattern || pattern.startsWith(\"#\")) return null;\n    const negated = pattern.startsWith(\"!\");\n    if (negated) pattern = pattern.slice(1);\n    if (!pattern) return null;\n    const anchored = pattern.startsWith(\"/\");\n    if (anchored) pattern = pattern.slice(1);\n    const hasSlash = pattern.includes(\"/\");\n    const endsWithSlash = pattern.endsWith(\"/\");\n    const base = dirRel ? dirRel : \"\";\n    let prefixed = pattern;\n    if (base) {\n        if (anchored || hasSlash) {\n            prefixed = posixJoin(base, pattern);\n        } else {\n            prefixed = posixJoin(base, \"**\", pattern);\n        }\n    } else if (!anchored && !hasSlash) {\n        prefixed = posixJoin(\"**\", pattern);\n    }\n    if (endsWithSlash && !prefixed.endsWith(\"/\")) {\n        prefixed += \"/\";\n    }\n    return negated ? \"!\".concat(prefixed) : prefixed;\n};\nconst nodeTypeFromPath = (relPath)=>{\n    if (relPath === \"__external__\") return \"external\";\n    if (ROUTE_REGEX.app.test(relPath) || ROUTE_REGEX.pages.test(relPath)) {\n        if (relPath.includes(\"/pages/\") || relPath.startsWith(\"pages/\")) {\n            const basename = posixBasename(relPath);\n            if (basename.startsWith(\"_\")) return \"module\";\n        }\n        return \"route\";\n    }\n    if (STYLE_EXTENSIONS.has(posixExtname(relPath))) return \"style\";\n    return \"module\";\n};\nconst extractDependencies = (filePath, code)=>{\n    const dependencies = [];\n    if (SCRIPT_EXTENSIONS.has(posixExtname(filePath))) {\n        let ast = null;\n        try {\n            ast = (0,_babel_parser__WEBPACK_IMPORTED_MODULE_1__.parse)(code, {\n                sourceType: \"unambiguous\",\n                plugins: [\n                    \"jsx\",\n                    \"typescript\",\n                    \"dynamicImport\",\n                    \"decorators-legacy\",\n                    \"classProperties\",\n                    \"classPrivateProperties\",\n                    \"importAssertions\",\n                    \"topLevelAwait\"\n                ]\n            });\n        } catch (e) {\n            return dependencies;\n        }\n        (0,_babel_traverse__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(ast, {\n            ImportDeclaration (pathNode) {\n                const value = pathNode.node.source.value;\n                const imports = [];\n                pathNode.node.specifiers.forEach((specifier)=>{\n                    if (specifier.type === \"ImportDefaultSpecifier\") {\n                        imports.push({\n                            kind: \"default\",\n                            imported: \"default\",\n                            local: specifier.local.name\n                        });\n                    } else if (specifier.type === \"ImportSpecifier\") {\n                        const importedName = specifier.imported.type === \"Identifier\" ? specifier.imported.name : specifier.imported.value;\n                        imports.push({\n                            kind: \"named\",\n                            imported: importedName,\n                            local: specifier.local.name\n                        });\n                    } else if (specifier.type === \"ImportNamespaceSpecifier\") {\n                        imports.push({\n                            kind: \"namespace\",\n                            imported: \"*\",\n                            local: specifier.local.name\n                        });\n                    }\n                });\n                var _pathNode_node_start, _pathNode_node_end;\n                dependencies.push({\n                    specifier: value,\n                    type: \"static\",\n                    statement: code.slice((_pathNode_node_start = pathNode.node.start) !== null && _pathNode_node_start !== void 0 ? _pathNode_node_start : 0, (_pathNode_node_end = pathNode.node.end) !== null && _pathNode_node_end !== void 0 ? _pathNode_node_end : 0),\n                    loc: pathNode.node.loc ? {\n                        line: pathNode.node.loc.start.line,\n                        column: pathNode.node.loc.start.column\n                    } : undefined,\n                    imports: imports.length ? imports : undefined\n                });\n            },\n            ExportAllDeclaration (pathNode) {\n                if (!pathNode.node.source) return;\n                const value = pathNode.node.source.value;\n                var _pathNode_node_start, _pathNode_node_end;\n                dependencies.push({\n                    specifier: value,\n                    type: \"static\",\n                    statement: code.slice((_pathNode_node_start = pathNode.node.start) !== null && _pathNode_node_start !== void 0 ? _pathNode_node_start : 0, (_pathNode_node_end = pathNode.node.end) !== null && _pathNode_node_end !== void 0 ? _pathNode_node_end : 0),\n                    loc: pathNode.node.loc ? {\n                        line: pathNode.node.loc.start.line,\n                        column: pathNode.node.loc.start.column\n                    } : undefined\n                });\n            },\n            ExportNamedDeclaration (pathNode) {\n                if (!pathNode.node.source) return;\n                const value = pathNode.node.source.value;\n                var _pathNode_node_start, _pathNode_node_end;\n                dependencies.push({\n                    specifier: value,\n                    type: \"static\",\n                    statement: code.slice((_pathNode_node_start = pathNode.node.start) !== null && _pathNode_node_start !== void 0 ? _pathNode_node_start : 0, (_pathNode_node_end = pathNode.node.end) !== null && _pathNode_node_end !== void 0 ? _pathNode_node_end : 0),\n                    loc: pathNode.node.loc ? {\n                        line: pathNode.node.loc.start.line,\n                        column: pathNode.node.loc.start.column\n                    } : undefined\n                });\n            },\n            CallExpression (pathNode) {\n                const callee = pathNode.node.callee;\n                if (callee.type === \"Import\") {\n                    const arg = pathNode.node.arguments[0];\n                    if (arg && arg.type === \"StringLiteral\") {\n                        var _pathNode_node_start, _pathNode_node_end;\n                        dependencies.push({\n                            specifier: arg.value,\n                            type: \"dynamic\",\n                            statement: code.slice((_pathNode_node_start = pathNode.node.start) !== null && _pathNode_node_start !== void 0 ? _pathNode_node_start : 0, (_pathNode_node_end = pathNode.node.end) !== null && _pathNode_node_end !== void 0 ? _pathNode_node_end : 0),\n                            loc: pathNode.node.loc ? {\n                                line: pathNode.node.loc.start.line,\n                                column: pathNode.node.loc.start.column\n                            } : undefined\n                        });\n                    }\n                }\n                if (callee.type === \"Identifier\" && callee.name === \"require\") {\n                    const arg = pathNode.node.arguments[0];\n                    if (arg && arg.type === \"StringLiteral\") {\n                        var _pathNode_node_start1, _pathNode_node_end1;\n                        dependencies.push({\n                            specifier: arg.value,\n                            type: \"static\",\n                            statement: code.slice((_pathNode_node_start1 = pathNode.node.start) !== null && _pathNode_node_start1 !== void 0 ? _pathNode_node_start1 : 0, (_pathNode_node_end1 = pathNode.node.end) !== null && _pathNode_node_end1 !== void 0 ? _pathNode_node_end1 : 0),\n                            loc: pathNode.node.loc ? {\n                                line: pathNode.node.loc.start.line,\n                                column: pathNode.node.loc.start.column\n                            } : undefined\n                        });\n                    }\n                }\n            }\n        });\n    }\n    if (STYLE_EXTENSIONS.has(posixExtname(filePath))) {\n        const regex = /@import\\s+(?:url\\()?['\"]([^'\"]+)['\"]/g;\n        let match;\n        while(match = regex.exec(code)){\n            dependencies.push({\n                specifier: match[1],\n                type: \"style\",\n                statement: match[0]\n            });\n        }\n    }\n    return dependencies;\n};\nconst resolveWithExtensions = (basePath, fileSet, dirSet)=>{\n    if (!basePath) return null;\n    if (fileSet.has(basePath)) return basePath;\n    if (dirSet.has(basePath)) {\n        for (const ext of IMPORT_EXTENSIONS){\n            const indexPath = posixJoin(basePath, \"index\".concat(ext));\n            if (fileSet.has(indexPath)) return indexPath;\n        }\n    }\n    if (!posixExtname(basePath)) {\n        for (const ext of IMPORT_EXTENSIONS){\n            const filePath = \"\".concat(basePath).concat(ext);\n            if (fileSet.has(filePath)) return filePath;\n        }\n    }\n    return null;\n};\nconst resolveImport = (fromFile, specifier, fileSet, dirSet)=>{\n    if (!specifier || specifier.startsWith(\"http\")) return null;\n    const cleanSpecifier = specifier.split(\"?\")[0].split(\"#\")[0];\n    let targetPath = null;\n    let escapedRoot = false;\n    if (cleanSpecifier.startsWith(\"@/\")) {\n        const normalized = normalizePosixPath(cleanSpecifier.slice(2));\n        targetPath = normalized.path;\n        escapedRoot = normalized.escapedRoot;\n    } else if (cleanSpecifier.startsWith(\"/\")) {\n        const normalized = normalizePosixPath(cleanSpecifier.slice(1));\n        targetPath = normalized.path;\n        escapedRoot = normalized.escapedRoot;\n    } else if (cleanSpecifier.startsWith(\".\")) {\n        const fromDir = posixDirname(fromFile);\n        const normalized = normalizePosixPath(posixJoin(fromDir, cleanSpecifier));\n        targetPath = normalized.path;\n        escapedRoot = normalized.escapedRoot;\n    } else {\n        return {\n            external: true,\n            resolved: null\n        };\n    }\n    if (!targetPath || escapedRoot) {\n        return {\n            external: true,\n            resolved: null\n        };\n    }\n    const resolved = resolveWithExtensions(targetPath, fileSet, dirSet);\n    if (!resolved) return {\n        external: true,\n        resolved: null\n    };\n    return {\n        external: false,\n        resolved\n    };\n};\nconst hashId = (value)=>{\n    let h1 = 0xdeadbeef ^ value.length;\n    let h2 = 0x41c6ce57 ^ value.length;\n    for(let i = 0; i < value.length; i += 1){\n        const ch = value.charCodeAt(i);\n        h1 = Math.imul(h1 ^ ch, 2654435761);\n        h2 = Math.imul(h2 ^ ch, 1597334677);\n    }\n    h1 = Math.imul(h1 ^ h1 >>> 16, 2246822507);\n    h2 = Math.imul(h2 ^ h2 >>> 16, 2246822507);\n    return \"\".concat((h1 >>> 0).toString(16)).concat((h2 >>> 0).toString(16));\n};\nconst scanDirectoryHandle = async (options)=>{\n    const { rootHandle, maxFiles, includeExternal } = options;\n    const rootLabel = rootHandle.name || \"Selected folder\";\n    const nodes = new Map();\n    const edges = [];\n    const edgeKeys = new Set();\n    const ignoredNodes = [];\n    const fileHandles = new Map();\n    const dirSet = new Set([\n        \"\"\n    ]);\n    let totalFiles = 0;\n    let ignoredCount = 0;\n    let externalCount = 0;\n    const walk = async (dirHandle, relDir, patterns)=>{\n        dirSet.add(relDir);\n        const gitignoreHandle = await dirHandle.getFileHandle(\".gitignore\").catch(()=>null);\n        let combinedPatterns = patterns;\n        if (gitignoreHandle) {\n            const gitignoreFile = await gitignoreHandle.getFile().catch(()=>null);\n            const gitignoreContent = await (gitignoreFile === null || gitignoreFile === void 0 ? void 0 : gitignoreFile.text());\n            if (gitignoreContent) {\n                const extraPatterns = gitignoreContent.split(/\\r?\\n/).map((line)=>normalizeGitignorePattern(relDir, line)).filter((value)=>Boolean(value));\n                combinedPatterns = patterns.concat(extraPatterns);\n            }\n        }\n        const ig = ignore__WEBPACK_IMPORTED_MODULE_0___default()().add(combinedPatterns);\n        for await (const [name, handle] of dirHandle.entries()){\n            const relPath = relDir ? \"\".concat(relDir, \"/\").concat(name) : name;\n            if (!relPath) continue;\n            if (ig.ignores(relPath)) {\n                ignoredCount += 1;\n                if (handle.kind === \"file\" && SUPPORTED_EXTENSIONS.has(posixExtname(relPath))) {\n                    ignoredNodes.push({\n                        id: relPath,\n                        path: relPath,\n                        label: posixBasename(relPath),\n                        type: nodeTypeFromPath(relPath),\n                        ignored: true\n                    });\n                }\n                continue;\n            }\n            if (handle.kind === \"directory\") {\n                await walk(handle, relPath, combinedPatterns);\n                continue;\n            }\n            totalFiles += 1;\n            if (totalFiles > maxFiles) {\n                throw new Error(\"File limit exceeded (\".concat(maxFiles, \"). Adjust the max files setting to continue.\"));\n            }\n            if (!SUPPORTED_EXTENSIONS.has(posixExtname(relPath))) continue;\n            nodes.set(relPath, {\n                id: relPath,\n                path: relPath,\n                label: posixBasename(relPath),\n                type: nodeTypeFromPath(relPath)\n            });\n            fileHandles.set(relPath, handle);\n        }\n    };\n    await walk(rootHandle, \"\", ALWAYS_IGNORE);\n    for (const ignoredNode of ignoredNodes){\n        nodes.set(ignoredNode.id, ignoredNode);\n    }\n    const fileSet = new Set(fileHandles.keys());\n    for (const [relPath, handle] of fileHandles.entries()){\n        const file = await handle.getFile().catch(()=>null);\n        const code = await (file === null || file === void 0 ? void 0 : file.text());\n        if (!code) continue;\n        const dependencies = extractDependencies(relPath, code);\n        for (const dep of dependencies){\n            var _dep_statement;\n            const resolved = resolveImport(relPath, dep.specifier, fileSet, dirSet);\n            if (!resolved) continue;\n            if (resolved.external) {\n                externalCount += 1;\n                if (!includeExternal) continue;\n                if (!nodes.has(\"__external__\")) {\n                    nodes.set(\"__external__\", {\n                        id: \"__external__\",\n                        path: \"__external__\",\n                        label: \"External\",\n                        type: \"external\"\n                    });\n                }\n                const edgeKey = \"\".concat(relPath, \"|__external__|external|\").concat(dep.specifier);\n                if (edgeKeys.has(edgeKey)) continue;\n                edgeKeys.add(edgeKey);\n                edges.push({\n                    id: hashId(edgeKey),\n                    source: relPath,\n                    target: \"__external__\",\n                    type: \"external\",\n                    statement: dep.statement,\n                    loc: dep.loc\n                });\n                continue;\n            }\n            if (!resolved.resolved) continue;\n            const targetRel = resolved.resolved;\n            if (!nodes.has(targetRel)) {\n                nodes.set(targetRel, {\n                    id: targetRel,\n                    path: targetRel,\n                    label: posixBasename(targetRel),\n                    type: nodeTypeFromPath(targetRel)\n                });\n            }\n            const targetExt = posixExtname(targetRel);\n            const edgeType = STYLE_EXTENSIONS.has(targetExt) ? \"style\" : dep.type;\n            var _dep_statement1;\n            const edgeKey = \"\".concat(relPath, \"|\").concat(targetRel, \"|\").concat(edgeType, \"|\").concat((_dep_statement1 = dep.statement) !== null && _dep_statement1 !== void 0 ? _dep_statement1 : \"\");\n            if (edgeKeys.has(edgeKey)) continue;\n            edgeKeys.add(edgeKey);\n            edges.push({\n                id: hashId(edgeKey),\n                source: relPath,\n                target: targetRel,\n                type: edgeType,\n                statement: (_dep_statement = dep.statement) === null || _dep_statement === void 0 ? void 0 : _dep_statement.slice(0, 200),\n                loc: dep.loc\n            });\n        }\n    }\n    return {\n        root: rootLabel,\n        nodes: Array.from(nodes.values()),\n        edges,\n        totalFiles,\n        ignoredCount,\n        externalCount\n    };\n};\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL2xpYi9icm93c2VyLXNjYW4udHMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7QUFBNEI7QUFDVTtBQUNDO0FBSXZDLE1BQU1HLGdCQUFnQjtJQUNwQjtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtDQUNEO0FBRUQsTUFBTUMsb0JBQW9CLElBQUlDLElBQUk7SUFDaEM7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0NBQ0Q7QUFDRCxNQUFNQyxtQkFBbUIsSUFBSUQsSUFBSTtJQUFDO0lBQVE7SUFBUztDQUFRO0FBQzNELE1BQU1FLHVCQUF1QixJQUFJRixJQUFJO09BQ2hDRDtPQUNBRTtDQUNKO0FBRUQsTUFBTUUsb0JBQW9CO0lBQ3hCO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtDQUNEO0FBRUQsTUFBTUMsY0FBYztJQUNsQkMsS0FBSztJQUNMQyxPQUFPO0FBQ1Q7QUErQkEsTUFBTUMsWUFBWTtxQ0FBSUM7UUFBQUE7O1dBQ3BCQSxNQUNHQyxNQUFNLENBQUNDLFNBQ1BDLElBQUksQ0FBQyxLQUNMQyxPQUFPLENBQUMsUUFBUTs7QUFFckIsTUFBTUMsZUFBZSxDQUFDQztJQUNwQixNQUFNQyxNQUFNRCxNQUFNRSxXQUFXLENBQUM7SUFDOUIsT0FBT0QsUUFBUSxDQUFDLElBQUksS0FBS0QsTUFBTUcsS0FBSyxDQUFDLEdBQUdGO0FBQzFDO0FBRUEsTUFBTUcsZ0JBQWdCLENBQUNKO0lBQ3JCLE1BQU1DLE1BQU1ELE1BQU1FLFdBQVcsQ0FBQztJQUM5QixPQUFPRCxRQUFRLENBQUMsSUFBSUQsUUFBUUEsTUFBTUcsS0FBSyxDQUFDRixNQUFNO0FBQ2hEO0FBRUEsTUFBTUksZUFBZSxDQUFDTDtJQUNwQixNQUFNTSxPQUFPRixjQUFjSjtJQUMzQixNQUFNQyxNQUFNSyxLQUFLSixXQUFXLENBQUM7SUFDN0IsT0FBT0QsUUFBUSxDQUFDLElBQUksS0FBS0ssS0FBS0gsS0FBSyxDQUFDRjtBQUN0QztBQUVBLE1BQU1NLHFCQUFxQixDQUFDUDtJQUMxQixNQUFNTixRQUFRTSxNQUFNUSxLQUFLLENBQUM7SUFDMUIsTUFBTUMsUUFBa0IsRUFBRTtJQUMxQixJQUFJQyxjQUFjO0lBRWxCLEtBQUssTUFBTUMsUUFBUWpCLE1BQU87UUFDeEIsSUFBSSxDQUFDaUIsUUFBUUEsU0FBUyxLQUFLO1FBQzNCLElBQUlBLFNBQVMsTUFBTTtZQUNqQixJQUFJRixNQUFNRyxNQUFNLEVBQUU7Z0JBQ2hCSCxNQUFNSSxHQUFHO1lBQ1gsT0FBTztnQkFDTEgsY0FBYztZQUNoQjtZQUNBO1FBQ0Y7UUFDQUQsTUFBTUssSUFBSSxDQUFDSDtJQUNiO0lBRUEsT0FBTztRQUFFSSxNQUFNTixNQUFNWixJQUFJLENBQUM7UUFBTWE7SUFBWTtBQUM5QztBQUVBLE1BQU1NLDRCQUE0QixDQUFDQyxRQUFnQkM7SUFDakQsSUFBSUMsVUFBVUQsV0FBV0UsSUFBSTtJQUM3QixJQUFJLENBQUNELFdBQVdBLFFBQVFFLFVBQVUsQ0FBQyxNQUFNLE9BQU87SUFDaEQsTUFBTUMsVUFBVUgsUUFBUUUsVUFBVSxDQUFDO0lBQ25DLElBQUlDLFNBQVNILFVBQVVBLFFBQVFoQixLQUFLLENBQUM7SUFDckMsSUFBSSxDQUFDZ0IsU0FBUyxPQUFPO0lBRXJCLE1BQU1JLFdBQVdKLFFBQVFFLFVBQVUsQ0FBQztJQUNwQyxJQUFJRSxVQUFVSixVQUFVQSxRQUFRaEIsS0FBSyxDQUFDO0lBRXRDLE1BQU1xQixXQUFXTCxRQUFRTSxRQUFRLENBQUM7SUFDbEMsTUFBTUMsZ0JBQWdCUCxRQUFRUSxRQUFRLENBQUM7SUFFdkMsTUFBTXJCLE9BQU9XLFNBQVNBLFNBQVM7SUFFL0IsSUFBSVcsV0FBV1Q7SUFFZixJQUFJYixNQUFNO1FBQ1IsSUFBSWlCLFlBQVlDLFVBQVU7WUFDeEJJLFdBQVduQyxVQUFVYSxNQUFNYTtRQUM3QixPQUFPO1lBQ0xTLFdBQVduQyxVQUFVYSxNQUFNLE1BQU1hO1FBQ25DO0lBQ0YsT0FBTyxJQUFJLENBQUNJLFlBQVksQ0FBQ0MsVUFBVTtRQUNqQ0ksV0FBV25DLFVBQVUsTUFBTTBCO0lBQzdCO0lBRUEsSUFBSU8saUJBQWlCLENBQUNFLFNBQVNELFFBQVEsQ0FBQyxNQUFNO1FBQzVDQyxZQUFZO0lBQ2Q7SUFFQSxPQUFPTixVQUFVLElBQWEsT0FBVE0sWUFBYUE7QUFDcEM7QUFFQSxNQUFNQyxtQkFBbUIsQ0FBQ0M7SUFDeEIsSUFBSUEsWUFBWSxnQkFBZ0IsT0FBTztJQUN2QyxJQUFJeEMsWUFBWUMsR0FBRyxDQUFDd0MsSUFBSSxDQUFDRCxZQUFZeEMsWUFBWUUsS0FBSyxDQUFDdUMsSUFBSSxDQUFDRCxVQUFVO1FBQ3BFLElBQUlBLFFBQVFMLFFBQVEsQ0FBQyxjQUFjSyxRQUFRVCxVQUFVLENBQUMsV0FBVztZQUMvRCxNQUFNVyxXQUFXNUIsY0FBYzBCO1lBQy9CLElBQUlFLFNBQVNYLFVBQVUsQ0FBQyxNQUFNLE9BQU87UUFDdkM7UUFDQSxPQUFPO0lBQ1Q7SUFDQSxJQUFJbEMsaUJBQWlCOEMsR0FBRyxDQUFDNUIsYUFBYXlCLFdBQVcsT0FBTztJQUN4RCxPQUFPO0FBQ1Q7QUFFQSxNQUFNSSxzQkFBc0IsQ0FBQ0MsVUFBa0JDO0lBQzdDLE1BQU1DLGVBQTZCLEVBQUU7SUFFckMsSUFBSXBELGtCQUFrQmdELEdBQUcsQ0FBQzVCLGFBQWE4QixZQUFZO1FBQ2pELElBQUlHLE1BQW1CO1FBQ3ZCLElBQUk7WUFDRkEsTUFBTXhELG9EQUFLQSxDQUFDc0QsTUFBTTtnQkFDaEJHLFlBQVk7Z0JBQ1pDLFNBQVM7b0JBQ1A7b0JBQ0E7b0JBQ0E7b0JBQ0E7b0JBQ0E7b0JBQ0E7b0JBQ0E7b0JBQ0E7aUJBQ0Q7WUFDSDtRQUNGLEVBQUUsVUFBTTtZQUNOLE9BQU9IO1FBQ1Q7UUFFQXRELDJEQUFRQSxDQUFDdUQsS0FBSztZQUNaRyxtQkFBa0JDLFFBQVE7Z0JBQ3hCLE1BQU0xQyxRQUFRMEMsU0FBU0MsSUFBSSxDQUFDQyxNQUFNLENBQUM1QyxLQUFLO2dCQUN4QyxNQUFNNkMsVUFBMkIsRUFBRTtnQkFDbkNILFNBQVNDLElBQUksQ0FBQ0csVUFBVSxDQUFDQyxPQUFPLENBQUMsQ0FBQ0M7b0JBQ2hDLElBQUlBLFVBQVVDLElBQUksS0FBSywwQkFBMEI7d0JBQy9DSixRQUFRL0IsSUFBSSxDQUFDOzRCQUNYb0MsTUFBTTs0QkFDTkMsVUFBVTs0QkFDVkMsT0FBT0osVUFBVUksS0FBSyxDQUFDQyxJQUFJO3dCQUM3QjtvQkFDRixPQUFPLElBQUlMLFVBQVVDLElBQUksS0FBSyxtQkFBbUI7d0JBQy9DLE1BQU1LLGVBQ0pOLFVBQVVHLFFBQVEsQ0FBQ0YsSUFBSSxLQUFLLGVBQ3hCRCxVQUFVRyxRQUFRLENBQUNFLElBQUksR0FDdkJMLFVBQVVHLFFBQVEsQ0FBQ25ELEtBQUs7d0JBQzlCNkMsUUFBUS9CLElBQUksQ0FBQzs0QkFDWG9DLE1BQU07NEJBQ05DLFVBQVVHOzRCQUNWRixPQUFPSixVQUFVSSxLQUFLLENBQUNDLElBQUk7d0JBQzdCO29CQUNGLE9BQU8sSUFBSUwsVUFBVUMsSUFBSSxLQUFLLDRCQUE0Qjt3QkFDeERKLFFBQVEvQixJQUFJLENBQUM7NEJBQ1hvQyxNQUFNOzRCQUNOQyxVQUFVOzRCQUNWQyxPQUFPSixVQUFVSSxLQUFLLENBQUNDLElBQUk7d0JBQzdCO29CQUNGO2dCQUNGO29CQUl3Qlgsc0JBQTBCQTtnQkFIbERMLGFBQWF2QixJQUFJLENBQUM7b0JBQ2hCa0MsV0FBV2hEO29CQUNYaUQsTUFBTTtvQkFDTk0sV0FBV25CLEtBQUtqQyxLQUFLLENBQUN1QyxDQUFBQSx1QkFBQUEsU0FBU0MsSUFBSSxDQUFDYSxLQUFLLGNBQW5CZCxrQ0FBQUEsdUJBQXVCLEdBQUdBLENBQUFBLHFCQUFBQSxTQUFTQyxJQUFJLENBQUNjLEdBQUcsY0FBakJmLGdDQUFBQSxxQkFBcUI7b0JBQ3JFZ0IsS0FBS2hCLFNBQVNDLElBQUksQ0FBQ2UsR0FBRyxHQUNsQjt3QkFBRUMsTUFBTWpCLFNBQVNDLElBQUksQ0FBQ2UsR0FBRyxDQUFDRixLQUFLLENBQUNHLElBQUk7d0JBQUVDLFFBQVFsQixTQUFTQyxJQUFJLENBQUNlLEdBQUcsQ0FBQ0YsS0FBSyxDQUFDSSxNQUFNO29CQUFDLElBQzdFQztvQkFDSmhCLFNBQVNBLFFBQVFqQyxNQUFNLEdBQUdpQyxVQUFVZ0I7Z0JBQ3RDO1lBQ0Y7WUFDQUMsc0JBQXFCcEIsUUFBUTtnQkFDM0IsSUFBSSxDQUFDQSxTQUFTQyxJQUFJLENBQUNDLE1BQU0sRUFBRTtnQkFDM0IsTUFBTTVDLFFBQVEwQyxTQUFTQyxJQUFJLENBQUNDLE1BQU0sQ0FBQzVDLEtBQUs7b0JBSWhCMEMsc0JBQTBCQTtnQkFIbERMLGFBQWF2QixJQUFJLENBQUM7b0JBQ2hCa0MsV0FBV2hEO29CQUNYaUQsTUFBTTtvQkFDTk0sV0FBV25CLEtBQUtqQyxLQUFLLENBQUN1QyxDQUFBQSx1QkFBQUEsU0FBU0MsSUFBSSxDQUFDYSxLQUFLLGNBQW5CZCxrQ0FBQUEsdUJBQXVCLEdBQUdBLENBQUFBLHFCQUFBQSxTQUFTQyxJQUFJLENBQUNjLEdBQUcsY0FBakJmLGdDQUFBQSxxQkFBcUI7b0JBQ3JFZ0IsS0FBS2hCLFNBQVNDLElBQUksQ0FBQ2UsR0FBRyxHQUNsQjt3QkFBRUMsTUFBTWpCLFNBQVNDLElBQUksQ0FBQ2UsR0FBRyxDQUFDRixLQUFLLENBQUNHLElBQUk7d0JBQUVDLFFBQVFsQixTQUFTQyxJQUFJLENBQUNlLEdBQUcsQ0FBQ0YsS0FBSyxDQUFDSSxNQUFNO29CQUFDLElBQzdFQztnQkFDTjtZQUNGO1lBQ0FFLHdCQUF1QnJCLFFBQVE7Z0JBQzdCLElBQUksQ0FBQ0EsU0FBU0MsSUFBSSxDQUFDQyxNQUFNLEVBQUU7Z0JBQzNCLE1BQU01QyxRQUFRMEMsU0FBU0MsSUFBSSxDQUFDQyxNQUFNLENBQUM1QyxLQUFLO29CQUloQjBDLHNCQUEwQkE7Z0JBSGxETCxhQUFhdkIsSUFBSSxDQUFDO29CQUNoQmtDLFdBQVdoRDtvQkFDWGlELE1BQU07b0JBQ05NLFdBQVduQixLQUFLakMsS0FBSyxDQUFDdUMsQ0FBQUEsdUJBQUFBLFNBQVNDLElBQUksQ0FBQ2EsS0FBSyxjQUFuQmQsa0NBQUFBLHVCQUF1QixHQUFHQSxDQUFBQSxxQkFBQUEsU0FBU0MsSUFBSSxDQUFDYyxHQUFHLGNBQWpCZixnQ0FBQUEscUJBQXFCO29CQUNyRWdCLEtBQUtoQixTQUFTQyxJQUFJLENBQUNlLEdBQUcsR0FDbEI7d0JBQUVDLE1BQU1qQixTQUFTQyxJQUFJLENBQUNlLEdBQUcsQ0FBQ0YsS0FBSyxDQUFDRyxJQUFJO3dCQUFFQyxRQUFRbEIsU0FBU0MsSUFBSSxDQUFDZSxHQUFHLENBQUNGLEtBQUssQ0FBQ0ksTUFBTTtvQkFBQyxJQUM3RUM7Z0JBQ047WUFDRjtZQUNBRyxnQkFBZXRCLFFBQVE7Z0JBQ3JCLE1BQU11QixTQUFTdkIsU0FBU0MsSUFBSSxDQUFDc0IsTUFBTTtnQkFDbkMsSUFBSUEsT0FBT2hCLElBQUksS0FBSyxVQUFVO29CQUM1QixNQUFNaUIsTUFBTXhCLFNBQVNDLElBQUksQ0FBQ3dCLFNBQVMsQ0FBQyxFQUFFO29CQUN0QyxJQUFJRCxPQUFPQSxJQUFJakIsSUFBSSxLQUFLLGlCQUFpQjs0QkFJZlAsc0JBQTBCQTt3QkFIbERMLGFBQWF2QixJQUFJLENBQUM7NEJBQ2hCa0MsV0FBV2tCLElBQUlsRSxLQUFLOzRCQUNwQmlELE1BQU07NEJBQ05NLFdBQVduQixLQUFLakMsS0FBSyxDQUFDdUMsQ0FBQUEsdUJBQUFBLFNBQVNDLElBQUksQ0FBQ2EsS0FBSyxjQUFuQmQsa0NBQUFBLHVCQUF1QixHQUFHQSxDQUFBQSxxQkFBQUEsU0FBU0MsSUFBSSxDQUFDYyxHQUFHLGNBQWpCZixnQ0FBQUEscUJBQXFCOzRCQUNyRWdCLEtBQUtoQixTQUFTQyxJQUFJLENBQUNlLEdBQUcsR0FDbEI7Z0NBQUVDLE1BQU1qQixTQUFTQyxJQUFJLENBQUNlLEdBQUcsQ0FBQ0YsS0FBSyxDQUFDRyxJQUFJO2dDQUFFQyxRQUFRbEIsU0FBU0MsSUFBSSxDQUFDZSxHQUFHLENBQUNGLEtBQUssQ0FBQ0ksTUFBTTs0QkFBQyxJQUM3RUM7d0JBQ047b0JBQ0Y7Z0JBQ0Y7Z0JBRUEsSUFBSUksT0FBT2hCLElBQUksS0FBSyxnQkFBZ0JnQixPQUFPWixJQUFJLEtBQUssV0FBVztvQkFDN0QsTUFBTWEsTUFBTXhCLFNBQVNDLElBQUksQ0FBQ3dCLFNBQVMsQ0FBQyxFQUFFO29CQUN0QyxJQUFJRCxPQUFPQSxJQUFJakIsSUFBSSxLQUFLLGlCQUFpQjs0QkFJZlAsdUJBQTBCQTt3QkFIbERMLGFBQWF2QixJQUFJLENBQUM7NEJBQ2hCa0MsV0FBV2tCLElBQUlsRSxLQUFLOzRCQUNwQmlELE1BQU07NEJBQ05NLFdBQVduQixLQUFLakMsS0FBSyxDQUFDdUMsQ0FBQUEsd0JBQUFBLFNBQVNDLElBQUksQ0FBQ2EsS0FBSyxjQUFuQmQsbUNBQUFBLHdCQUF1QixHQUFHQSxDQUFBQSxzQkFBQUEsU0FBU0MsSUFBSSxDQUFDYyxHQUFHLGNBQWpCZixpQ0FBQUEsc0JBQXFCOzRCQUNyRWdCLEtBQUtoQixTQUFTQyxJQUFJLENBQUNlLEdBQUcsR0FDbEI7Z0NBQUVDLE1BQU1qQixTQUFTQyxJQUFJLENBQUNlLEdBQUcsQ0FBQ0YsS0FBSyxDQUFDRyxJQUFJO2dDQUFFQyxRQUFRbEIsU0FBU0MsSUFBSSxDQUFDZSxHQUFHLENBQUNGLEtBQUssQ0FBQ0ksTUFBTTs0QkFBQyxJQUM3RUM7d0JBQ047b0JBQ0Y7Z0JBQ0Y7WUFDRjtRQUNGO0lBQ0Y7SUFFQSxJQUFJMUUsaUJBQWlCOEMsR0FBRyxDQUFDNUIsYUFBYThCLFlBQVk7UUFDaEQsTUFBTWlDLFFBQVE7UUFDZCxJQUFJQztRQUNKLE1BQVFBLFFBQVFELE1BQU1FLElBQUksQ0FBQ2xDLE1BQVE7WUFDakNDLGFBQWF2QixJQUFJLENBQUM7Z0JBQ2hCa0MsV0FBV3FCLEtBQUssQ0FBQyxFQUFFO2dCQUNuQnBCLE1BQU07Z0JBQ05NLFdBQVdjLEtBQUssQ0FBQyxFQUFFO1lBQ3JCO1FBQ0Y7SUFDRjtJQUVBLE9BQU9oQztBQUNUO0FBRUEsTUFBTWtDLHdCQUF3QixDQUM1QkMsVUFDQUMsU0FDQUM7SUFFQSxJQUFJLENBQUNGLFVBQVUsT0FBTztJQUN0QixJQUFJQyxRQUFReEMsR0FBRyxDQUFDdUMsV0FBVyxPQUFPQTtJQUVsQyxJQUFJRSxPQUFPekMsR0FBRyxDQUFDdUMsV0FBVztRQUN4QixLQUFLLE1BQU1HLE9BQU90RixrQkFBbUI7WUFDbkMsTUFBTXVGLFlBQVluRixVQUFVK0UsVUFBVSxRQUFZLE9BQUpHO1lBQzlDLElBQUlGLFFBQVF4QyxHQUFHLENBQUMyQyxZQUFZLE9BQU9BO1FBQ3JDO0lBQ0Y7SUFFQSxJQUFJLENBQUN2RSxhQUFhbUUsV0FBVztRQUMzQixLQUFLLE1BQU1HLE9BQU90RixrQkFBbUI7WUFDbkMsTUFBTThDLFdBQVcsR0FBY3dDLE9BQVhILFVBQWUsT0FBSkc7WUFDL0IsSUFBSUYsUUFBUXhDLEdBQUcsQ0FBQ0UsV0FBVyxPQUFPQTtRQUNwQztJQUNGO0lBRUEsT0FBTztBQUNUO0FBRUEsTUFBTTBDLGdCQUFnQixDQUNwQkMsVUFDQTlCLFdBQ0F5QixTQUNBQztJQUVBLElBQUksQ0FBQzFCLGFBQWFBLFVBQVUzQixVQUFVLENBQUMsU0FBUyxPQUFPO0lBRXZELE1BQU0wRCxpQkFBaUIvQixVQUFVeEMsS0FBSyxDQUFDLElBQUksQ0FBQyxFQUFFLENBQUNBLEtBQUssQ0FBQyxJQUFJLENBQUMsRUFBRTtJQUM1RCxJQUFJd0UsYUFBNEI7SUFDaEMsSUFBSXRFLGNBQWM7SUFFbEIsSUFBSXFFLGVBQWUxRCxVQUFVLENBQUMsT0FBTztRQUNuQyxNQUFNNEQsYUFBYTFFLG1CQUFtQndFLGVBQWU1RSxLQUFLLENBQUM7UUFDM0Q2RSxhQUFhQyxXQUFXbEUsSUFBSTtRQUM1QkwsY0FBY3VFLFdBQVd2RSxXQUFXO0lBQ3RDLE9BQU8sSUFBSXFFLGVBQWUxRCxVQUFVLENBQUMsTUFBTTtRQUN6QyxNQUFNNEQsYUFBYTFFLG1CQUFtQndFLGVBQWU1RSxLQUFLLENBQUM7UUFDM0Q2RSxhQUFhQyxXQUFXbEUsSUFBSTtRQUM1QkwsY0FBY3VFLFdBQVd2RSxXQUFXO0lBQ3RDLE9BQU8sSUFBSXFFLGVBQWUxRCxVQUFVLENBQUMsTUFBTTtRQUN6QyxNQUFNNkQsVUFBVW5GLGFBQWErRTtRQUM3QixNQUFNRyxhQUFhMUUsbUJBQW1CZCxVQUFVeUYsU0FBU0g7UUFDekRDLGFBQWFDLFdBQVdsRSxJQUFJO1FBQzVCTCxjQUFjdUUsV0FBV3ZFLFdBQVc7SUFDdEMsT0FBTztRQUNMLE9BQU87WUFBRXlFLFVBQVU7WUFBTUMsVUFBVTtRQUFLO0lBQzFDO0lBRUEsSUFBSSxDQUFDSixjQUFjdEUsYUFBYTtRQUM5QixPQUFPO1lBQUV5RSxVQUFVO1lBQU1DLFVBQVU7UUFBSztJQUMxQztJQUVBLE1BQU1BLFdBQVdiLHNCQUFzQlMsWUFBWVAsU0FBU0M7SUFDNUQsSUFBSSxDQUFDVSxVQUFVLE9BQU87UUFBRUQsVUFBVTtRQUFNQyxVQUFVO0lBQUs7SUFFdkQsT0FBTztRQUFFRCxVQUFVO1FBQU9DO0lBQVM7QUFDckM7QUFFQSxNQUFNQyxTQUFTLENBQUNyRjtJQUNkLElBQUlzRixLQUFLLGFBQWF0RixNQUFNWSxNQUFNO0lBQ2xDLElBQUkyRSxLQUFLLGFBQWF2RixNQUFNWSxNQUFNO0lBQ2xDLElBQUssSUFBSTRFLElBQUksR0FBR0EsSUFBSXhGLE1BQU1ZLE1BQU0sRUFBRTRFLEtBQUssRUFBRztRQUN4QyxNQUFNQyxLQUFLekYsTUFBTTBGLFVBQVUsQ0FBQ0Y7UUFDNUJGLEtBQUtLLEtBQUtDLElBQUksQ0FBQ04sS0FBS0csSUFBSTtRQUN4QkYsS0FBS0ksS0FBS0MsSUFBSSxDQUFDTCxLQUFLRSxJQUFJO0lBQzFCO0lBQ0FILEtBQUtLLEtBQUtDLElBQUksQ0FBQ04sS0FBTUEsT0FBTyxJQUFLO0lBQ2pDQyxLQUFLSSxLQUFLQyxJQUFJLENBQUNMLEtBQU1BLE9BQU8sSUFBSztJQUNqQyxPQUFPLEdBQTZCLE9BQTFCLENBQUNELE9BQU8sR0FBR08sUUFBUSxDQUFDLEtBQThCLE9BQXhCLENBQUNOLE9BQU8sR0FBR00sUUFBUSxDQUFDO0FBQzFEO0FBRU8sTUFBTUMsc0JBQXNCLE9BQ2pDQztJQUVBLE1BQU0sRUFBRUMsVUFBVSxFQUFFQyxRQUFRLEVBQUVDLGVBQWUsRUFBRSxHQUFHSDtJQUNsRCxNQUFNSSxZQUFZSCxXQUFXM0MsSUFBSSxJQUFJO0lBRXJDLE1BQU0rQyxRQUFRLElBQUlDO0lBQ2xCLE1BQU1DLFFBQXFCLEVBQUU7SUFDN0IsTUFBTUMsV0FBVyxJQUFJckg7SUFDckIsTUFBTXNILGVBQTRCLEVBQUU7SUFDcEMsTUFBTUMsY0FBYyxJQUFJSjtJQUN4QixNQUFNM0IsU0FBUyxJQUFJeEYsSUFBWTtRQUFDO0tBQUc7SUFFbkMsSUFBSXdILGFBQWE7SUFDakIsSUFBSUMsZUFBZTtJQUNuQixJQUFJQyxnQkFBZ0I7SUFFcEIsTUFBTUMsT0FBTyxPQUNYQyxXQUNBQyxRQUNBQztRQUVBdEMsT0FBT3VDLEdBQUcsQ0FBQ0Y7UUFFWCxNQUFNRyxrQkFBa0IsTUFBTUosVUFDM0JLLGFBQWEsQ0FBQyxjQUNkQyxLQUFLLENBQUMsSUFBTTtRQUNmLElBQUlDLG1CQUFtQkw7UUFFdkIsSUFBSUUsaUJBQWlCO1lBQ25CLE1BQU1JLGdCQUFnQixNQUFNSixnQkFBZ0JLLE9BQU8sR0FBR0gsS0FBSyxDQUFDLElBQU07WUFDbEUsTUFBTUksbUJBQW1CLE9BQU1GLDBCQUFBQSxvQ0FBQUEsY0FBZUcsSUFBSTtZQUNsRCxJQUFJRCxrQkFBa0I7Z0JBQ3BCLE1BQU1FLGdCQUFnQkYsaUJBQ25CaEgsS0FBSyxDQUFDLFNBQ05tSCxHQUFHLENBQUMsQ0FBQ2hFLE9BQVMzQywwQkFBMEIrRixRQUFRcEQsT0FDaERoRSxNQUFNLENBQUMsQ0FBQ0ssUUFBMkJKLFFBQVFJO2dCQUM5Q3FILG1CQUFtQkwsU0FBU1ksTUFBTSxDQUFDRjtZQUNyQztRQUNGO1FBRUEsTUFBTUcsS0FBS2hKLDZDQUFNQSxHQUFHb0ksR0FBRyxDQUFDSTtRQUV4QixXQUFXLE1BQU0sQ0FBQ2hFLE1BQU15RSxPQUFPLElBQUloQixVQUFVaUIsT0FBTyxHQUFJO1lBQ3RELE1BQU1qRyxVQUFVaUYsU0FBUyxHQUFhMUQsT0FBVjBELFFBQU8sS0FBUSxPQUFMMUQsUUFBU0E7WUFDL0MsSUFBSSxDQUFDdkIsU0FBUztZQUVkLElBQUkrRixHQUFHRyxPQUFPLENBQUNsRyxVQUFVO2dCQUN2QjZFLGdCQUFnQjtnQkFDaEIsSUFBSW1CLE9BQU81RSxJQUFJLEtBQUssVUFBVTlELHFCQUFxQjZDLEdBQUcsQ0FBQzVCLGFBQWF5QixXQUFXO29CQUM3RTBFLGFBQWExRixJQUFJLENBQUM7d0JBQ2hCbUgsSUFBSW5HO3dCQUNKZixNQUFNZTt3QkFDTm9HLE9BQU85SCxjQUFjMEI7d0JBQ3JCbUIsTUFBTXBCLGlCQUFpQkM7d0JBQ3ZCcUcsU0FBUztvQkFDWDtnQkFDRjtnQkFDQTtZQUNGO1lBRUEsSUFBSUwsT0FBTzVFLElBQUksS0FBSyxhQUFhO2dCQUMvQixNQUFNMkQsS0FBS2lCLFFBQVFoRyxTQUFTdUY7Z0JBQzVCO1lBQ0Y7WUFFQVgsY0FBYztZQUNkLElBQUlBLGFBQWFULFVBQVU7Z0JBQ3pCLE1BQU0sSUFBSW1DLE1BQ1Isd0JBQWlDLE9BQVRuQyxVQUFTO1lBRXJDO1lBRUEsSUFBSSxDQUFDN0cscUJBQXFCNkMsR0FBRyxDQUFDNUIsYUFBYXlCLFdBQVc7WUFFdERzRSxNQUFNaUMsR0FBRyxDQUFDdkcsU0FBUztnQkFDakJtRyxJQUFJbkc7Z0JBQ0pmLE1BQU1lO2dCQUNOb0csT0FBTzlILGNBQWMwQjtnQkFDckJtQixNQUFNcEIsaUJBQWlCQztZQUN6QjtZQUVBMkUsWUFBWTRCLEdBQUcsQ0FBQ3ZHLFNBQVNnRztRQUMzQjtJQUNGO0lBRUEsTUFBTWpCLEtBQUtiLFlBQVksSUFBSWhIO0lBRTNCLEtBQUssTUFBTXNKLGVBQWU5QixhQUFjO1FBQ3RDSixNQUFNaUMsR0FBRyxDQUFDQyxZQUFZTCxFQUFFLEVBQUVLO0lBQzVCO0lBRUEsTUFBTTdELFVBQVUsSUFBSXZGLElBQUl1SCxZQUFZOEIsSUFBSTtJQUV4QyxLQUFLLE1BQU0sQ0FBQ3pHLFNBQVNnRyxPQUFPLElBQUlyQixZQUFZc0IsT0FBTyxHQUFJO1FBQ3JELE1BQU1TLE9BQU8sTUFBTVYsT0FBT1AsT0FBTyxHQUFHSCxLQUFLLENBQUMsSUFBTTtRQUNoRCxNQUFNaEYsT0FBTyxPQUFNb0csaUJBQUFBLDJCQUFBQSxLQUFNZixJQUFJO1FBQzdCLElBQUksQ0FBQ3JGLE1BQU07UUFFWCxNQUFNQyxlQUFlSCxvQkFBb0JKLFNBQVNNO1FBRWxELEtBQUssTUFBTXFHLE9BQU9wRyxhQUFjO2dCQXVEakJvRztZQXREYixNQUFNckQsV0FBV1AsY0FBYy9DLFNBQVMyRyxJQUFJekYsU0FBUyxFQUFFeUIsU0FBU0M7WUFDaEUsSUFBSSxDQUFDVSxVQUFVO1lBRWYsSUFBSUEsU0FBU0QsUUFBUSxFQUFFO2dCQUNyQnlCLGlCQUFpQjtnQkFDakIsSUFBSSxDQUFDVixpQkFBaUI7Z0JBRXRCLElBQUksQ0FBQ0UsTUFBTW5FLEdBQUcsQ0FBQyxpQkFBaUI7b0JBQzlCbUUsTUFBTWlDLEdBQUcsQ0FBQyxnQkFBZ0I7d0JBQ3hCSixJQUFJO3dCQUNKbEgsTUFBTTt3QkFDTm1ILE9BQU87d0JBQ1BqRixNQUFNO29CQUNSO2dCQUNGO2dCQUVBLE1BQU15RixVQUFVLEdBQW9DRCxPQUFqQzNHLFNBQVEsMkJBQXVDLE9BQWQyRyxJQUFJekYsU0FBUztnQkFDakUsSUFBSXVELFNBQVN0RSxHQUFHLENBQUN5RyxVQUFVO2dCQUMzQm5DLFNBQVNVLEdBQUcsQ0FBQ3lCO2dCQUNicEMsTUFBTXhGLElBQUksQ0FBQztvQkFDVG1ILElBQUk1QyxPQUFPcUQ7b0JBQ1g5RixRQUFRZDtvQkFDUjZHLFFBQVE7b0JBQ1IxRixNQUFNO29CQUNOTSxXQUFXa0YsSUFBSWxGLFNBQVM7b0JBQ3hCRyxLQUFLK0UsSUFBSS9FLEdBQUc7Z0JBQ2Q7Z0JBQ0E7WUFDRjtZQUVBLElBQUksQ0FBQzBCLFNBQVNBLFFBQVEsRUFBRTtZQUV4QixNQUFNd0QsWUFBWXhELFNBQVNBLFFBQVE7WUFDbkMsSUFBSSxDQUFDZ0IsTUFBTW5FLEdBQUcsQ0FBQzJHLFlBQVk7Z0JBQ3pCeEMsTUFBTWlDLEdBQUcsQ0FBQ08sV0FBVztvQkFDbkJYLElBQUlXO29CQUNKN0gsTUFBTTZIO29CQUNOVixPQUFPOUgsY0FBY3dJO29CQUNyQjNGLE1BQU1wQixpQkFBaUIrRztnQkFDekI7WUFDRjtZQUVBLE1BQU1DLFlBQVl4SSxhQUFhdUk7WUFDL0IsTUFBTUUsV0FBcUIzSixpQkFBaUI4QyxHQUFHLENBQUM0RyxhQUFhLFVBQVVKLElBQUl4RixJQUFJO2dCQUV4QndGO1lBQXZELE1BQU1DLFVBQVUsR0FBY0UsT0FBWDlHLFNBQVEsS0FBZ0JnSCxPQUFiRixXQUFVLEtBQWVILE9BQVpLLFVBQVMsS0FBdUIsT0FBcEJMLENBQUFBLGtCQUFBQSxJQUFJbEYsU0FBUyxjQUFia0YsNkJBQUFBLGtCQUFpQjtZQUN4RSxJQUFJbEMsU0FBU3RFLEdBQUcsQ0FBQ3lHLFVBQVU7WUFDM0JuQyxTQUFTVSxHQUFHLENBQUN5QjtZQUVicEMsTUFBTXhGLElBQUksQ0FBQztnQkFDVG1ILElBQUk1QyxPQUFPcUQ7Z0JBQ1g5RixRQUFRZDtnQkFDUjZHLFFBQVFDO2dCQUNSM0YsTUFBTTZGO2dCQUNOdkYsU0FBUyxHQUFFa0YsaUJBQUFBLElBQUlsRixTQUFTLGNBQWJrRixxQ0FBQUEsZUFBZXRJLEtBQUssQ0FBQyxHQUFHO2dCQUNuQ3VELEtBQUsrRSxJQUFJL0UsR0FBRztZQUNkO1FBQ0Y7SUFDRjtJQUVBLE9BQU87UUFDTHFGLE1BQU01QztRQUNOQyxPQUFPNEMsTUFBTUMsSUFBSSxDQUFDN0MsTUFBTThDLE1BQU07UUFDOUI1QztRQUNBSTtRQUNBQztRQUNBQztJQUNGO0FBQ0YsRUFBRSIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9saWIvYnJvd3Nlci1zY2FuLnRzPzMwMGYiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IGlnbm9yZSBmcm9tICdpZ25vcmUnO1xuaW1wb3J0IHsgcGFyc2UgfSBmcm9tICdAYmFiZWwvcGFyc2VyJztcbmltcG9ydCB0cmF2ZXJzZSBmcm9tICdAYmFiZWwvdHJhdmVyc2UnO1xuaW1wb3J0IHR5cGUgeyBGaWxlIH0gZnJvbSAnQGJhYmVsL3R5cGVzJztcbmltcG9ydCB0eXBlIHsgRWRnZVR5cGUsIEdyYXBoRGF0YSwgR3JhcGhFZGdlLCBHcmFwaE5vZGUgfSBmcm9tICcuL3R5cGVzJztcblxuY29uc3QgQUxXQVlTX0lHTk9SRSA9IFtcbiAgJy5naXQvJyxcbiAgJ25vZGVfbW9kdWxlcy8nLFxuICAnLm5leHQvJyxcbiAgJ2Rpc3QvJyxcbiAgJ2J1aWxkLycsXG4gICdvdXQvJyxcbiAgJ2NvdmVyYWdlLycsXG4gICcudHVyYm8vJyxcbiAgJy5jYWNoZS8nLFxuICAnLkRTX1N0b3JlJ1xuXTtcblxuY29uc3QgU0NSSVBUX0VYVEVOU0lPTlMgPSBuZXcgU2V0KFtcbiAgJy5qcycsXG4gICcuanN4JyxcbiAgJy50cycsXG4gICcudHN4JyxcbiAgJy5tanMnLFxuICAnLmNqcydcbl0pO1xuY29uc3QgU1RZTEVfRVhURU5TSU9OUyA9IG5ldyBTZXQoWycuY3NzJywgJy5zY3NzJywgJy5zYXNzJ10pO1xuY29uc3QgU1VQUE9SVEVEX0VYVEVOU0lPTlMgPSBuZXcgU2V0KFtcbiAgLi4uU0NSSVBUX0VYVEVOU0lPTlMsXG4gIC4uLlNUWUxFX0VYVEVOU0lPTlNcbl0pO1xuXG5jb25zdCBJTVBPUlRfRVhURU5TSU9OUyA9IFtcbiAgJy50cycsXG4gICcudHN4JyxcbiAgJy5qcycsXG4gICcuanN4JyxcbiAgJy5tanMnLFxuICAnLmNqcycsXG4gICcuY3NzJyxcbiAgJy5zY3NzJyxcbiAgJy5zYXNzJ1xuXTtcblxuY29uc3QgUk9VVEVfUkVHRVggPSB7XG4gIGFwcDogLyhefFxcLylhcHBcXC8oLipcXC8pPyhwYWdlfHJvdXRlKVxcLih0fGopc3g/JC8sXG4gIHBhZ2VzOiAvKF58XFwvKXBhZ2VzXFwvLitcXC4odHxqKXN4PyQvXG59O1xuXG50eXBlIERlcGVuZGVuY3kgPSB7XG4gIHNwZWNpZmllcjogc3RyaW5nO1xuICB0eXBlOiBFZGdlVHlwZTtcbiAgc3RhdGVtZW50Pzogc3RyaW5nO1xuICBsb2M/OiB7IGxpbmU6IG51bWJlcjsgY29sdW1uOiBudW1iZXIgfTtcbiAgaW1wb3J0cz86IEltcG9ydEJpbmRpbmdbXTtcbn07XG5cbnR5cGUgQnJvd3NlclNjYW5PcHRpb25zID0ge1xuICByb290SGFuZGxlOiBGaWxlU3lzdGVtRGlyZWN0b3J5SGFuZGxlO1xuICBtYXhGaWxlczogbnVtYmVyO1xuICBpbmNsdWRlRXh0ZXJuYWw6IGJvb2xlYW47XG4gIGdyYW51bGFyaXR5PzogU2NhbkdyYW51bGFyaXR5O1xufTtcblxudHlwZSBTY2FuR3JhbnVsYXJpdHkgPSAnZmlsZScgfCAnc3ltYm9sJztcblxudHlwZSBJbXBvcnRCaW5kaW5nID0ge1xuICBraW5kOiAnZGVmYXVsdCcgfCAnbmFtZWQnIHwgJ25hbWVzcGFjZSc7XG4gIGltcG9ydGVkOiBzdHJpbmc7XG4gIGxvY2FsOiBzdHJpbmc7XG59O1xuXG50eXBlIFN5bWJvbEluZm8gPSB7XG4gIG5hbWU6IHN0cmluZztcbiAga2luZDogc3RyaW5nO1xuICBkaXNwbGF5TmFtZT86IHN0cmluZztcbn07XG5cbmNvbnN0IHBvc2l4Sm9pbiA9ICguLi5wYXJ0czogc3RyaW5nW10pID0+XG4gIHBhcnRzXG4gICAgLmZpbHRlcihCb29sZWFuKVxuICAgIC5qb2luKCcvJylcbiAgICAucmVwbGFjZSgvXFwvKy9nLCAnLycpO1xuXG5jb25zdCBwb3NpeERpcm5hbWUgPSAodmFsdWU6IHN0cmluZykgPT4ge1xuICBjb25zdCBpZHggPSB2YWx1ZS5sYXN0SW5kZXhPZignLycpO1xuICByZXR1cm4gaWR4ID09PSAtMSA/ICcnIDogdmFsdWUuc2xpY2UoMCwgaWR4KTtcbn07XG5cbmNvbnN0IHBvc2l4QmFzZW5hbWUgPSAodmFsdWU6IHN0cmluZykgPT4ge1xuICBjb25zdCBpZHggPSB2YWx1ZS5sYXN0SW5kZXhPZignLycpO1xuICByZXR1cm4gaWR4ID09PSAtMSA/IHZhbHVlIDogdmFsdWUuc2xpY2UoaWR4ICsgMSk7XG59O1xuXG5jb25zdCBwb3NpeEV4dG5hbWUgPSAodmFsdWU6IHN0cmluZykgPT4ge1xuICBjb25zdCBiYXNlID0gcG9zaXhCYXNlbmFtZSh2YWx1ZSk7XG4gIGNvbnN0IGlkeCA9IGJhc2UubGFzdEluZGV4T2YoJy4nKTtcbiAgcmV0dXJuIGlkeCA9PT0gLTEgPyAnJyA6IGJhc2Uuc2xpY2UoaWR4KTtcbn07XG5cbmNvbnN0IG5vcm1hbGl6ZVBvc2l4UGF0aCA9ICh2YWx1ZTogc3RyaW5nKSA9PiB7XG4gIGNvbnN0IHBhcnRzID0gdmFsdWUuc3BsaXQoJy8nKTtcbiAgY29uc3Qgc3RhY2s6IHN0cmluZ1tdID0gW107XG4gIGxldCBlc2NhcGVkUm9vdCA9IGZhbHNlO1xuXG4gIGZvciAoY29uc3QgcGFydCBvZiBwYXJ0cykge1xuICAgIGlmICghcGFydCB8fCBwYXJ0ID09PSAnLicpIGNvbnRpbnVlO1xuICAgIGlmIChwYXJ0ID09PSAnLi4nKSB7XG4gICAgICBpZiAoc3RhY2subGVuZ3RoKSB7XG4gICAgICAgIHN0YWNrLnBvcCgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZXNjYXBlZFJvb3QgPSB0cnVlO1xuICAgICAgfVxuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIHN0YWNrLnB1c2gocGFydCk7XG4gIH1cblxuICByZXR1cm4geyBwYXRoOiBzdGFjay5qb2luKCcvJyksIGVzY2FwZWRSb290IH07XG59O1xuXG5jb25zdCBub3JtYWxpemVHaXRpZ25vcmVQYXR0ZXJuID0gKGRpclJlbDogc3RyaW5nLCByYXdQYXR0ZXJuOiBzdHJpbmcpID0+IHtcbiAgbGV0IHBhdHRlcm4gPSByYXdQYXR0ZXJuLnRyaW0oKTtcbiAgaWYgKCFwYXR0ZXJuIHx8IHBhdHRlcm4uc3RhcnRzV2l0aCgnIycpKSByZXR1cm4gbnVsbDtcbiAgY29uc3QgbmVnYXRlZCA9IHBhdHRlcm4uc3RhcnRzV2l0aCgnIScpO1xuICBpZiAobmVnYXRlZCkgcGF0dGVybiA9IHBhdHRlcm4uc2xpY2UoMSk7XG4gIGlmICghcGF0dGVybikgcmV0dXJuIG51bGw7XG5cbiAgY29uc3QgYW5jaG9yZWQgPSBwYXR0ZXJuLnN0YXJ0c1dpdGgoJy8nKTtcbiAgaWYgKGFuY2hvcmVkKSBwYXR0ZXJuID0gcGF0dGVybi5zbGljZSgxKTtcblxuICBjb25zdCBoYXNTbGFzaCA9IHBhdHRlcm4uaW5jbHVkZXMoJy8nKTtcbiAgY29uc3QgZW5kc1dpdGhTbGFzaCA9IHBhdHRlcm4uZW5kc1dpdGgoJy8nKTtcblxuICBjb25zdCBiYXNlID0gZGlyUmVsID8gZGlyUmVsIDogJyc7XG5cbiAgbGV0IHByZWZpeGVkID0gcGF0dGVybjtcblxuICBpZiAoYmFzZSkge1xuICAgIGlmIChhbmNob3JlZCB8fCBoYXNTbGFzaCkge1xuICAgICAgcHJlZml4ZWQgPSBwb3NpeEpvaW4oYmFzZSwgcGF0dGVybik7XG4gICAgfSBlbHNlIHtcbiAgICAgIHByZWZpeGVkID0gcG9zaXhKb2luKGJhc2UsICcqKicsIHBhdHRlcm4pO1xuICAgIH1cbiAgfSBlbHNlIGlmICghYW5jaG9yZWQgJiYgIWhhc1NsYXNoKSB7XG4gICAgcHJlZml4ZWQgPSBwb3NpeEpvaW4oJyoqJywgcGF0dGVybik7XG4gIH1cblxuICBpZiAoZW5kc1dpdGhTbGFzaCAmJiAhcHJlZml4ZWQuZW5kc1dpdGgoJy8nKSkge1xuICAgIHByZWZpeGVkICs9ICcvJztcbiAgfVxuXG4gIHJldHVybiBuZWdhdGVkID8gYCEke3ByZWZpeGVkfWAgOiBwcmVmaXhlZDtcbn07XG5cbmNvbnN0IG5vZGVUeXBlRnJvbVBhdGggPSAocmVsUGF0aDogc3RyaW5nKSA9PiB7XG4gIGlmIChyZWxQYXRoID09PSAnX19leHRlcm5hbF9fJykgcmV0dXJuICdleHRlcm5hbCc7XG4gIGlmIChST1VURV9SRUdFWC5hcHAudGVzdChyZWxQYXRoKSB8fCBST1VURV9SRUdFWC5wYWdlcy50ZXN0KHJlbFBhdGgpKSB7XG4gICAgaWYgKHJlbFBhdGguaW5jbHVkZXMoJy9wYWdlcy8nKSB8fCByZWxQYXRoLnN0YXJ0c1dpdGgoJ3BhZ2VzLycpKSB7XG4gICAgICBjb25zdCBiYXNlbmFtZSA9IHBvc2l4QmFzZW5hbWUocmVsUGF0aCk7XG4gICAgICBpZiAoYmFzZW5hbWUuc3RhcnRzV2l0aCgnXycpKSByZXR1cm4gJ21vZHVsZSc7XG4gICAgfVxuICAgIHJldHVybiAncm91dGUnO1xuICB9XG4gIGlmIChTVFlMRV9FWFRFTlNJT05TLmhhcyhwb3NpeEV4dG5hbWUocmVsUGF0aCkpKSByZXR1cm4gJ3N0eWxlJztcbiAgcmV0dXJuICdtb2R1bGUnO1xufTtcblxuY29uc3QgZXh0cmFjdERlcGVuZGVuY2llcyA9IChmaWxlUGF0aDogc3RyaW5nLCBjb2RlOiBzdHJpbmcpOiBEZXBlbmRlbmN5W10gPT4ge1xuICBjb25zdCBkZXBlbmRlbmNpZXM6IERlcGVuZGVuY3lbXSA9IFtdO1xuXG4gIGlmIChTQ1JJUFRfRVhURU5TSU9OUy5oYXMocG9zaXhFeHRuYW1lKGZpbGVQYXRoKSkpIHtcbiAgICBsZXQgYXN0OiBGaWxlIHwgbnVsbCA9IG51bGw7XG4gICAgdHJ5IHtcbiAgICAgIGFzdCA9IHBhcnNlKGNvZGUsIHtcbiAgICAgICAgc291cmNlVHlwZTogJ3VuYW1iaWd1b3VzJyxcbiAgICAgICAgcGx1Z2luczogW1xuICAgICAgICAgICdqc3gnLFxuICAgICAgICAgICd0eXBlc2NyaXB0JyxcbiAgICAgICAgICAnZHluYW1pY0ltcG9ydCcsXG4gICAgICAgICAgJ2RlY29yYXRvcnMtbGVnYWN5JyxcbiAgICAgICAgICAnY2xhc3NQcm9wZXJ0aWVzJyxcbiAgICAgICAgICAnY2xhc3NQcml2YXRlUHJvcGVydGllcycsXG4gICAgICAgICAgJ2ltcG9ydEFzc2VydGlvbnMnLFxuICAgICAgICAgICd0b3BMZXZlbEF3YWl0J1xuICAgICAgICBdXG4gICAgICB9KTtcbiAgICB9IGNhdGNoIHtcbiAgICAgIHJldHVybiBkZXBlbmRlbmNpZXM7XG4gICAgfVxuXG4gICAgdHJhdmVyc2UoYXN0LCB7XG4gICAgICBJbXBvcnREZWNsYXJhdGlvbihwYXRoTm9kZSkge1xuICAgICAgICBjb25zdCB2YWx1ZSA9IHBhdGhOb2RlLm5vZGUuc291cmNlLnZhbHVlO1xuICAgICAgICBjb25zdCBpbXBvcnRzOiBJbXBvcnRCaW5kaW5nW10gPSBbXTtcbiAgICAgICAgcGF0aE5vZGUubm9kZS5zcGVjaWZpZXJzLmZvckVhY2goKHNwZWNpZmllcikgPT4ge1xuICAgICAgICAgIGlmIChzcGVjaWZpZXIudHlwZSA9PT0gJ0ltcG9ydERlZmF1bHRTcGVjaWZpZXInKSB7XG4gICAgICAgICAgICBpbXBvcnRzLnB1c2goe1xuICAgICAgICAgICAgICBraW5kOiAnZGVmYXVsdCcsXG4gICAgICAgICAgICAgIGltcG9ydGVkOiAnZGVmYXVsdCcsXG4gICAgICAgICAgICAgIGxvY2FsOiBzcGVjaWZpZXIubG9jYWwubmFtZVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfSBlbHNlIGlmIChzcGVjaWZpZXIudHlwZSA9PT0gJ0ltcG9ydFNwZWNpZmllcicpIHtcbiAgICAgICAgICAgIGNvbnN0IGltcG9ydGVkTmFtZSA9XG4gICAgICAgICAgICAgIHNwZWNpZmllci5pbXBvcnRlZC50eXBlID09PSAnSWRlbnRpZmllcidcbiAgICAgICAgICAgICAgICA/IHNwZWNpZmllci5pbXBvcnRlZC5uYW1lXG4gICAgICAgICAgICAgICAgOiBzcGVjaWZpZXIuaW1wb3J0ZWQudmFsdWU7XG4gICAgICAgICAgICBpbXBvcnRzLnB1c2goe1xuICAgICAgICAgICAgICBraW5kOiAnbmFtZWQnLFxuICAgICAgICAgICAgICBpbXBvcnRlZDogaW1wb3J0ZWROYW1lLFxuICAgICAgICAgICAgICBsb2NhbDogc3BlY2lmaWVyLmxvY2FsLm5hbWVcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH0gZWxzZSBpZiAoc3BlY2lmaWVyLnR5cGUgPT09ICdJbXBvcnROYW1lc3BhY2VTcGVjaWZpZXInKSB7XG4gICAgICAgICAgICBpbXBvcnRzLnB1c2goe1xuICAgICAgICAgICAgICBraW5kOiAnbmFtZXNwYWNlJyxcbiAgICAgICAgICAgICAgaW1wb3J0ZWQ6ICcqJyxcbiAgICAgICAgICAgICAgbG9jYWw6IHNwZWNpZmllci5sb2NhbC5uYW1lXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBkZXBlbmRlbmNpZXMucHVzaCh7XG4gICAgICAgICAgc3BlY2lmaWVyOiB2YWx1ZSxcbiAgICAgICAgICB0eXBlOiAnc3RhdGljJyxcbiAgICAgICAgICBzdGF0ZW1lbnQ6IGNvZGUuc2xpY2UocGF0aE5vZGUubm9kZS5zdGFydCA/PyAwLCBwYXRoTm9kZS5ub2RlLmVuZCA/PyAwKSxcbiAgICAgICAgICBsb2M6IHBhdGhOb2RlLm5vZGUubG9jXG4gICAgICAgICAgICA/IHsgbGluZTogcGF0aE5vZGUubm9kZS5sb2Muc3RhcnQubGluZSwgY29sdW1uOiBwYXRoTm9kZS5ub2RlLmxvYy5zdGFydC5jb2x1bW4gfVxuICAgICAgICAgICAgOiB1bmRlZmluZWQsXG4gICAgICAgICAgaW1wb3J0czogaW1wb3J0cy5sZW5ndGggPyBpbXBvcnRzIDogdW5kZWZpbmVkXG4gICAgICAgIH0pO1xuICAgICAgfSxcbiAgICAgIEV4cG9ydEFsbERlY2xhcmF0aW9uKHBhdGhOb2RlKSB7XG4gICAgICAgIGlmICghcGF0aE5vZGUubm9kZS5zb3VyY2UpIHJldHVybjtcbiAgICAgICAgY29uc3QgdmFsdWUgPSBwYXRoTm9kZS5ub2RlLnNvdXJjZS52YWx1ZTtcbiAgICAgICAgZGVwZW5kZW5jaWVzLnB1c2goe1xuICAgICAgICAgIHNwZWNpZmllcjogdmFsdWUsXG4gICAgICAgICAgdHlwZTogJ3N0YXRpYycsXG4gICAgICAgICAgc3RhdGVtZW50OiBjb2RlLnNsaWNlKHBhdGhOb2RlLm5vZGUuc3RhcnQgPz8gMCwgcGF0aE5vZGUubm9kZS5lbmQgPz8gMCksXG4gICAgICAgICAgbG9jOiBwYXRoTm9kZS5ub2RlLmxvY1xuICAgICAgICAgICAgPyB7IGxpbmU6IHBhdGhOb2RlLm5vZGUubG9jLnN0YXJ0LmxpbmUsIGNvbHVtbjogcGF0aE5vZGUubm9kZS5sb2Muc3RhcnQuY29sdW1uIH1cbiAgICAgICAgICAgIDogdW5kZWZpbmVkXG4gICAgICAgIH0pO1xuICAgICAgfSxcbiAgICAgIEV4cG9ydE5hbWVkRGVjbGFyYXRpb24ocGF0aE5vZGUpIHtcbiAgICAgICAgaWYgKCFwYXRoTm9kZS5ub2RlLnNvdXJjZSkgcmV0dXJuO1xuICAgICAgICBjb25zdCB2YWx1ZSA9IHBhdGhOb2RlLm5vZGUuc291cmNlLnZhbHVlO1xuICAgICAgICBkZXBlbmRlbmNpZXMucHVzaCh7XG4gICAgICAgICAgc3BlY2lmaWVyOiB2YWx1ZSxcbiAgICAgICAgICB0eXBlOiAnc3RhdGljJyxcbiAgICAgICAgICBzdGF0ZW1lbnQ6IGNvZGUuc2xpY2UocGF0aE5vZGUubm9kZS5zdGFydCA/PyAwLCBwYXRoTm9kZS5ub2RlLmVuZCA/PyAwKSxcbiAgICAgICAgICBsb2M6IHBhdGhOb2RlLm5vZGUubG9jXG4gICAgICAgICAgICA/IHsgbGluZTogcGF0aE5vZGUubm9kZS5sb2Muc3RhcnQubGluZSwgY29sdW1uOiBwYXRoTm9kZS5ub2RlLmxvYy5zdGFydC5jb2x1bW4gfVxuICAgICAgICAgICAgOiB1bmRlZmluZWRcbiAgICAgICAgfSk7XG4gICAgICB9LFxuICAgICAgQ2FsbEV4cHJlc3Npb24ocGF0aE5vZGUpIHtcbiAgICAgICAgY29uc3QgY2FsbGVlID0gcGF0aE5vZGUubm9kZS5jYWxsZWU7XG4gICAgICAgIGlmIChjYWxsZWUudHlwZSA9PT0gJ0ltcG9ydCcpIHtcbiAgICAgICAgICBjb25zdCBhcmcgPSBwYXRoTm9kZS5ub2RlLmFyZ3VtZW50c1swXTtcbiAgICAgICAgICBpZiAoYXJnICYmIGFyZy50eXBlID09PSAnU3RyaW5nTGl0ZXJhbCcpIHtcbiAgICAgICAgICAgIGRlcGVuZGVuY2llcy5wdXNoKHtcbiAgICAgICAgICAgICAgc3BlY2lmaWVyOiBhcmcudmFsdWUsXG4gICAgICAgICAgICAgIHR5cGU6ICdkeW5hbWljJyxcbiAgICAgICAgICAgICAgc3RhdGVtZW50OiBjb2RlLnNsaWNlKHBhdGhOb2RlLm5vZGUuc3RhcnQgPz8gMCwgcGF0aE5vZGUubm9kZS5lbmQgPz8gMCksXG4gICAgICAgICAgICAgIGxvYzogcGF0aE5vZGUubm9kZS5sb2NcbiAgICAgICAgICAgICAgICA/IHsgbGluZTogcGF0aE5vZGUubm9kZS5sb2Muc3RhcnQubGluZSwgY29sdW1uOiBwYXRoTm9kZS5ub2RlLmxvYy5zdGFydC5jb2x1bW4gfVxuICAgICAgICAgICAgICAgIDogdW5kZWZpbmVkXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoY2FsbGVlLnR5cGUgPT09ICdJZGVudGlmaWVyJyAmJiBjYWxsZWUubmFtZSA9PT0gJ3JlcXVpcmUnKSB7XG4gICAgICAgICAgY29uc3QgYXJnID0gcGF0aE5vZGUubm9kZS5hcmd1bWVudHNbMF07XG4gICAgICAgICAgaWYgKGFyZyAmJiBhcmcudHlwZSA9PT0gJ1N0cmluZ0xpdGVyYWwnKSB7XG4gICAgICAgICAgICBkZXBlbmRlbmNpZXMucHVzaCh7XG4gICAgICAgICAgICAgIHNwZWNpZmllcjogYXJnLnZhbHVlLFxuICAgICAgICAgICAgICB0eXBlOiAnc3RhdGljJyxcbiAgICAgICAgICAgICAgc3RhdGVtZW50OiBjb2RlLnNsaWNlKHBhdGhOb2RlLm5vZGUuc3RhcnQgPz8gMCwgcGF0aE5vZGUubm9kZS5lbmQgPz8gMCksXG4gICAgICAgICAgICAgIGxvYzogcGF0aE5vZGUubm9kZS5sb2NcbiAgICAgICAgICAgICAgICA/IHsgbGluZTogcGF0aE5vZGUubm9kZS5sb2Muc3RhcnQubGluZSwgY29sdW1uOiBwYXRoTm9kZS5ub2RlLmxvYy5zdGFydC5jb2x1bW4gfVxuICAgICAgICAgICAgICAgIDogdW5kZWZpbmVkXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIGlmIChTVFlMRV9FWFRFTlNJT05TLmhhcyhwb3NpeEV4dG5hbWUoZmlsZVBhdGgpKSkge1xuICAgIGNvbnN0IHJlZ2V4ID0gL0BpbXBvcnRcXHMrKD86dXJsXFwoKT9bJ1wiXShbXidcIl0rKVsnXCJdL2c7XG4gICAgbGV0IG1hdGNoOiBSZWdFeHBFeGVjQXJyYXkgfCBudWxsO1xuICAgIHdoaWxlICgobWF0Y2ggPSByZWdleC5leGVjKGNvZGUpKSkge1xuICAgICAgZGVwZW5kZW5jaWVzLnB1c2goe1xuICAgICAgICBzcGVjaWZpZXI6IG1hdGNoWzFdLFxuICAgICAgICB0eXBlOiAnc3R5bGUnLFxuICAgICAgICBzdGF0ZW1lbnQ6IG1hdGNoWzBdXG4gICAgICB9KTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZGVwZW5kZW5jaWVzO1xufTtcblxuY29uc3QgcmVzb2x2ZVdpdGhFeHRlbnNpb25zID0gKFxuICBiYXNlUGF0aDogc3RyaW5nIHwgbnVsbCxcbiAgZmlsZVNldDogU2V0PHN0cmluZz4sXG4gIGRpclNldDogU2V0PHN0cmluZz5cbikgPT4ge1xuICBpZiAoIWJhc2VQYXRoKSByZXR1cm4gbnVsbDtcbiAgaWYgKGZpbGVTZXQuaGFzKGJhc2VQYXRoKSkgcmV0dXJuIGJhc2VQYXRoO1xuXG4gIGlmIChkaXJTZXQuaGFzKGJhc2VQYXRoKSkge1xuICAgIGZvciAoY29uc3QgZXh0IG9mIElNUE9SVF9FWFRFTlNJT05TKSB7XG4gICAgICBjb25zdCBpbmRleFBhdGggPSBwb3NpeEpvaW4oYmFzZVBhdGgsIGBpbmRleCR7ZXh0fWApO1xuICAgICAgaWYgKGZpbGVTZXQuaGFzKGluZGV4UGF0aCkpIHJldHVybiBpbmRleFBhdGg7XG4gICAgfVxuICB9XG5cbiAgaWYgKCFwb3NpeEV4dG5hbWUoYmFzZVBhdGgpKSB7XG4gICAgZm9yIChjb25zdCBleHQgb2YgSU1QT1JUX0VYVEVOU0lPTlMpIHtcbiAgICAgIGNvbnN0IGZpbGVQYXRoID0gYCR7YmFzZVBhdGh9JHtleHR9YDtcbiAgICAgIGlmIChmaWxlU2V0LmhhcyhmaWxlUGF0aCkpIHJldHVybiBmaWxlUGF0aDtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gbnVsbDtcbn07XG5cbmNvbnN0IHJlc29sdmVJbXBvcnQgPSAoXG4gIGZyb21GaWxlOiBzdHJpbmcsXG4gIHNwZWNpZmllcjogc3RyaW5nLFxuICBmaWxlU2V0OiBTZXQ8c3RyaW5nPixcbiAgZGlyU2V0OiBTZXQ8c3RyaW5nPlxuKSA9PiB7XG4gIGlmICghc3BlY2lmaWVyIHx8IHNwZWNpZmllci5zdGFydHNXaXRoKCdodHRwJykpIHJldHVybiBudWxsO1xuXG4gIGNvbnN0IGNsZWFuU3BlY2lmaWVyID0gc3BlY2lmaWVyLnNwbGl0KCc/JylbMF0uc3BsaXQoJyMnKVswXTtcbiAgbGV0IHRhcmdldFBhdGg6IHN0cmluZyB8IG51bGwgPSBudWxsO1xuICBsZXQgZXNjYXBlZFJvb3QgPSBmYWxzZTtcblxuICBpZiAoY2xlYW5TcGVjaWZpZXIuc3RhcnRzV2l0aCgnQC8nKSkge1xuICAgIGNvbnN0IG5vcm1hbGl6ZWQgPSBub3JtYWxpemVQb3NpeFBhdGgoY2xlYW5TcGVjaWZpZXIuc2xpY2UoMikpO1xuICAgIHRhcmdldFBhdGggPSBub3JtYWxpemVkLnBhdGg7XG4gICAgZXNjYXBlZFJvb3QgPSBub3JtYWxpemVkLmVzY2FwZWRSb290O1xuICB9IGVsc2UgaWYgKGNsZWFuU3BlY2lmaWVyLnN0YXJ0c1dpdGgoJy8nKSkge1xuICAgIGNvbnN0IG5vcm1hbGl6ZWQgPSBub3JtYWxpemVQb3NpeFBhdGgoY2xlYW5TcGVjaWZpZXIuc2xpY2UoMSkpO1xuICAgIHRhcmdldFBhdGggPSBub3JtYWxpemVkLnBhdGg7XG4gICAgZXNjYXBlZFJvb3QgPSBub3JtYWxpemVkLmVzY2FwZWRSb290O1xuICB9IGVsc2UgaWYgKGNsZWFuU3BlY2lmaWVyLnN0YXJ0c1dpdGgoJy4nKSkge1xuICAgIGNvbnN0IGZyb21EaXIgPSBwb3NpeERpcm5hbWUoZnJvbUZpbGUpO1xuICAgIGNvbnN0IG5vcm1hbGl6ZWQgPSBub3JtYWxpemVQb3NpeFBhdGgocG9zaXhKb2luKGZyb21EaXIsIGNsZWFuU3BlY2lmaWVyKSk7XG4gICAgdGFyZ2V0UGF0aCA9IG5vcm1hbGl6ZWQucGF0aDtcbiAgICBlc2NhcGVkUm9vdCA9IG5vcm1hbGl6ZWQuZXNjYXBlZFJvb3Q7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIHsgZXh0ZXJuYWw6IHRydWUsIHJlc29sdmVkOiBudWxsIH07XG4gIH1cblxuICBpZiAoIXRhcmdldFBhdGggfHwgZXNjYXBlZFJvb3QpIHtcbiAgICByZXR1cm4geyBleHRlcm5hbDogdHJ1ZSwgcmVzb2x2ZWQ6IG51bGwgfTtcbiAgfVxuXG4gIGNvbnN0IHJlc29sdmVkID0gcmVzb2x2ZVdpdGhFeHRlbnNpb25zKHRhcmdldFBhdGgsIGZpbGVTZXQsIGRpclNldCk7XG4gIGlmICghcmVzb2x2ZWQpIHJldHVybiB7IGV4dGVybmFsOiB0cnVlLCByZXNvbHZlZDogbnVsbCB9O1xuXG4gIHJldHVybiB7IGV4dGVybmFsOiBmYWxzZSwgcmVzb2x2ZWQgfTtcbn07XG5cbmNvbnN0IGhhc2hJZCA9ICh2YWx1ZTogc3RyaW5nKSA9PiB7XG4gIGxldCBoMSA9IDB4ZGVhZGJlZWYgXiB2YWx1ZS5sZW5ndGg7XG4gIGxldCBoMiA9IDB4NDFjNmNlNTcgXiB2YWx1ZS5sZW5ndGg7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgdmFsdWUubGVuZ3RoOyBpICs9IDEpIHtcbiAgICBjb25zdCBjaCA9IHZhbHVlLmNoYXJDb2RlQXQoaSk7XG4gICAgaDEgPSBNYXRoLmltdWwoaDEgXiBjaCwgMjY1NDQzNTc2MSk7XG4gICAgaDIgPSBNYXRoLmltdWwoaDIgXiBjaCwgMTU5NzMzNDY3Nyk7XG4gIH1cbiAgaDEgPSBNYXRoLmltdWwoaDEgXiAoaDEgPj4+IDE2KSwgMjI0NjgyMjUwNyk7XG4gIGgyID0gTWF0aC5pbXVsKGgyIF4gKGgyID4+PiAxNiksIDIyNDY4MjI1MDcpO1xuICByZXR1cm4gYCR7KGgxID4+PiAwKS50b1N0cmluZygxNil9JHsoaDIgPj4+IDApLnRvU3RyaW5nKDE2KX1gO1xufTtcblxuZXhwb3J0IGNvbnN0IHNjYW5EaXJlY3RvcnlIYW5kbGUgPSBhc3luYyAoXG4gIG9wdGlvbnM6IEJyb3dzZXJTY2FuT3B0aW9uc1xuKTogUHJvbWlzZTxHcmFwaERhdGE+ID0+IHtcbiAgY29uc3QgeyByb290SGFuZGxlLCBtYXhGaWxlcywgaW5jbHVkZUV4dGVybmFsIH0gPSBvcHRpb25zO1xuICBjb25zdCByb290TGFiZWwgPSByb290SGFuZGxlLm5hbWUgfHwgJ1NlbGVjdGVkIGZvbGRlcic7XG5cbiAgY29uc3Qgbm9kZXMgPSBuZXcgTWFwPHN0cmluZywgR3JhcGhOb2RlPigpO1xuICBjb25zdCBlZGdlczogR3JhcGhFZGdlW10gPSBbXTtcbiAgY29uc3QgZWRnZUtleXMgPSBuZXcgU2V0PHN0cmluZz4oKTtcbiAgY29uc3QgaWdub3JlZE5vZGVzOiBHcmFwaE5vZGVbXSA9IFtdO1xuICBjb25zdCBmaWxlSGFuZGxlcyA9IG5ldyBNYXA8c3RyaW5nLCBGaWxlU3lzdGVtRmlsZUhhbmRsZT4oKTtcbiAgY29uc3QgZGlyU2V0ID0gbmV3IFNldDxzdHJpbmc+KFsnJ10pO1xuXG4gIGxldCB0b3RhbEZpbGVzID0gMDtcbiAgbGV0IGlnbm9yZWRDb3VudCA9IDA7XG4gIGxldCBleHRlcm5hbENvdW50ID0gMDtcblxuICBjb25zdCB3YWxrID0gYXN5bmMgKFxuICAgIGRpckhhbmRsZTogRmlsZVN5c3RlbURpcmVjdG9yeUhhbmRsZSxcbiAgICByZWxEaXI6IHN0cmluZyxcbiAgICBwYXR0ZXJuczogc3RyaW5nW11cbiAgKSA9PiB7XG4gICAgZGlyU2V0LmFkZChyZWxEaXIpO1xuXG4gICAgY29uc3QgZ2l0aWdub3JlSGFuZGxlID0gYXdhaXQgZGlySGFuZGxlXG4gICAgICAuZ2V0RmlsZUhhbmRsZSgnLmdpdGlnbm9yZScpXG4gICAgICAuY2F0Y2goKCkgPT4gbnVsbCk7XG4gICAgbGV0IGNvbWJpbmVkUGF0dGVybnMgPSBwYXR0ZXJucztcblxuICAgIGlmIChnaXRpZ25vcmVIYW5kbGUpIHtcbiAgICAgIGNvbnN0IGdpdGlnbm9yZUZpbGUgPSBhd2FpdCBnaXRpZ25vcmVIYW5kbGUuZ2V0RmlsZSgpLmNhdGNoKCgpID0+IG51bGwpO1xuICAgICAgY29uc3QgZ2l0aWdub3JlQ29udGVudCA9IGF3YWl0IGdpdGlnbm9yZUZpbGU/LnRleHQoKTtcbiAgICAgIGlmIChnaXRpZ25vcmVDb250ZW50KSB7XG4gICAgICAgIGNvbnN0IGV4dHJhUGF0dGVybnMgPSBnaXRpZ25vcmVDb250ZW50XG4gICAgICAgICAgLnNwbGl0KC9cXHI/XFxuLylcbiAgICAgICAgICAubWFwKChsaW5lKSA9PiBub3JtYWxpemVHaXRpZ25vcmVQYXR0ZXJuKHJlbERpciwgbGluZSkpXG4gICAgICAgICAgLmZpbHRlcigodmFsdWUpOiB2YWx1ZSBpcyBzdHJpbmcgPT4gQm9vbGVhbih2YWx1ZSkpO1xuICAgICAgICBjb21iaW5lZFBhdHRlcm5zID0gcGF0dGVybnMuY29uY2F0KGV4dHJhUGF0dGVybnMpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGNvbnN0IGlnID0gaWdub3JlKCkuYWRkKGNvbWJpbmVkUGF0dGVybnMpO1xuXG4gICAgZm9yIGF3YWl0IChjb25zdCBbbmFtZSwgaGFuZGxlXSBvZiBkaXJIYW5kbGUuZW50cmllcygpKSB7XG4gICAgICBjb25zdCByZWxQYXRoID0gcmVsRGlyID8gYCR7cmVsRGlyfS8ke25hbWV9YCA6IG5hbWU7XG4gICAgICBpZiAoIXJlbFBhdGgpIGNvbnRpbnVlO1xuXG4gICAgICBpZiAoaWcuaWdub3JlcyhyZWxQYXRoKSkge1xuICAgICAgICBpZ25vcmVkQ291bnQgKz0gMTtcbiAgICAgICAgaWYgKGhhbmRsZS5raW5kID09PSAnZmlsZScgJiYgU1VQUE9SVEVEX0VYVEVOU0lPTlMuaGFzKHBvc2l4RXh0bmFtZShyZWxQYXRoKSkpIHtcbiAgICAgICAgICBpZ25vcmVkTm9kZXMucHVzaCh7XG4gICAgICAgICAgICBpZDogcmVsUGF0aCxcbiAgICAgICAgICAgIHBhdGg6IHJlbFBhdGgsXG4gICAgICAgICAgICBsYWJlbDogcG9zaXhCYXNlbmFtZShyZWxQYXRoKSxcbiAgICAgICAgICAgIHR5cGU6IG5vZGVUeXBlRnJvbVBhdGgocmVsUGF0aCksXG4gICAgICAgICAgICBpZ25vcmVkOiB0cnVlXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIGlmIChoYW5kbGUua2luZCA9PT0gJ2RpcmVjdG9yeScpIHtcbiAgICAgICAgYXdhaXQgd2FsayhoYW5kbGUsIHJlbFBhdGgsIGNvbWJpbmVkUGF0dGVybnMpO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgdG90YWxGaWxlcyArPSAxO1xuICAgICAgaWYgKHRvdGFsRmlsZXMgPiBtYXhGaWxlcykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgYEZpbGUgbGltaXQgZXhjZWVkZWQgKCR7bWF4RmlsZXN9KS4gQWRqdXN0IHRoZSBtYXggZmlsZXMgc2V0dGluZyB0byBjb250aW51ZS5gXG4gICAgICAgICk7XG4gICAgICB9XG5cbiAgICAgIGlmICghU1VQUE9SVEVEX0VYVEVOU0lPTlMuaGFzKHBvc2l4RXh0bmFtZShyZWxQYXRoKSkpIGNvbnRpbnVlO1xuXG4gICAgICBub2Rlcy5zZXQocmVsUGF0aCwge1xuICAgICAgICBpZDogcmVsUGF0aCxcbiAgICAgICAgcGF0aDogcmVsUGF0aCxcbiAgICAgICAgbGFiZWw6IHBvc2l4QmFzZW5hbWUocmVsUGF0aCksXG4gICAgICAgIHR5cGU6IG5vZGVUeXBlRnJvbVBhdGgocmVsUGF0aClcbiAgICAgIH0pO1xuXG4gICAgICBmaWxlSGFuZGxlcy5zZXQocmVsUGF0aCwgaGFuZGxlKTtcbiAgICB9XG4gIH07XG5cbiAgYXdhaXQgd2Fsayhyb290SGFuZGxlLCAnJywgQUxXQVlTX0lHTk9SRSk7XG5cbiAgZm9yIChjb25zdCBpZ25vcmVkTm9kZSBvZiBpZ25vcmVkTm9kZXMpIHtcbiAgICBub2Rlcy5zZXQoaWdub3JlZE5vZGUuaWQsIGlnbm9yZWROb2RlKTtcbiAgfVxuXG4gIGNvbnN0IGZpbGVTZXQgPSBuZXcgU2V0KGZpbGVIYW5kbGVzLmtleXMoKSk7XG5cbiAgZm9yIChjb25zdCBbcmVsUGF0aCwgaGFuZGxlXSBvZiBmaWxlSGFuZGxlcy5lbnRyaWVzKCkpIHtcbiAgICBjb25zdCBmaWxlID0gYXdhaXQgaGFuZGxlLmdldEZpbGUoKS5jYXRjaCgoKSA9PiBudWxsKTtcbiAgICBjb25zdCBjb2RlID0gYXdhaXQgZmlsZT8udGV4dCgpO1xuICAgIGlmICghY29kZSkgY29udGludWU7XG5cbiAgICBjb25zdCBkZXBlbmRlbmNpZXMgPSBleHRyYWN0RGVwZW5kZW5jaWVzKHJlbFBhdGgsIGNvZGUpO1xuXG4gICAgZm9yIChjb25zdCBkZXAgb2YgZGVwZW5kZW5jaWVzKSB7XG4gICAgICBjb25zdCByZXNvbHZlZCA9IHJlc29sdmVJbXBvcnQocmVsUGF0aCwgZGVwLnNwZWNpZmllciwgZmlsZVNldCwgZGlyU2V0KTtcbiAgICAgIGlmICghcmVzb2x2ZWQpIGNvbnRpbnVlO1xuXG4gICAgICBpZiAocmVzb2x2ZWQuZXh0ZXJuYWwpIHtcbiAgICAgICAgZXh0ZXJuYWxDb3VudCArPSAxO1xuICAgICAgICBpZiAoIWluY2x1ZGVFeHRlcm5hbCkgY29udGludWU7XG5cbiAgICAgICAgaWYgKCFub2Rlcy5oYXMoJ19fZXh0ZXJuYWxfXycpKSB7XG4gICAgICAgICAgbm9kZXMuc2V0KCdfX2V4dGVybmFsX18nLCB7XG4gICAgICAgICAgICBpZDogJ19fZXh0ZXJuYWxfXycsXG4gICAgICAgICAgICBwYXRoOiAnX19leHRlcm5hbF9fJyxcbiAgICAgICAgICAgIGxhYmVsOiAnRXh0ZXJuYWwnLFxuICAgICAgICAgICAgdHlwZTogJ2V4dGVybmFsJ1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgZWRnZUtleSA9IGAke3JlbFBhdGh9fF9fZXh0ZXJuYWxfX3xleHRlcm5hbHwke2RlcC5zcGVjaWZpZXJ9YDtcbiAgICAgICAgaWYgKGVkZ2VLZXlzLmhhcyhlZGdlS2V5KSkgY29udGludWU7XG4gICAgICAgIGVkZ2VLZXlzLmFkZChlZGdlS2V5KTtcbiAgICAgICAgZWRnZXMucHVzaCh7XG4gICAgICAgICAgaWQ6IGhhc2hJZChlZGdlS2V5KSxcbiAgICAgICAgICBzb3VyY2U6IHJlbFBhdGgsXG4gICAgICAgICAgdGFyZ2V0OiAnX19leHRlcm5hbF9fJyxcbiAgICAgICAgICB0eXBlOiAnZXh0ZXJuYWwnLFxuICAgICAgICAgIHN0YXRlbWVudDogZGVwLnN0YXRlbWVudCxcbiAgICAgICAgICBsb2M6IGRlcC5sb2NcbiAgICAgICAgfSk7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICBpZiAoIXJlc29sdmVkLnJlc29sdmVkKSBjb250aW51ZTtcblxuICAgICAgY29uc3QgdGFyZ2V0UmVsID0gcmVzb2x2ZWQucmVzb2x2ZWQ7XG4gICAgICBpZiAoIW5vZGVzLmhhcyh0YXJnZXRSZWwpKSB7XG4gICAgICAgIG5vZGVzLnNldCh0YXJnZXRSZWwsIHtcbiAgICAgICAgICBpZDogdGFyZ2V0UmVsLFxuICAgICAgICAgIHBhdGg6IHRhcmdldFJlbCxcbiAgICAgICAgICBsYWJlbDogcG9zaXhCYXNlbmFtZSh0YXJnZXRSZWwpLFxuICAgICAgICAgIHR5cGU6IG5vZGVUeXBlRnJvbVBhdGgodGFyZ2V0UmVsKVxuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgY29uc3QgdGFyZ2V0RXh0ID0gcG9zaXhFeHRuYW1lKHRhcmdldFJlbCk7XG4gICAgICBjb25zdCBlZGdlVHlwZTogRWRnZVR5cGUgPSBTVFlMRV9FWFRFTlNJT05TLmhhcyh0YXJnZXRFeHQpID8gJ3N0eWxlJyA6IGRlcC50eXBlO1xuXG4gICAgICBjb25zdCBlZGdlS2V5ID0gYCR7cmVsUGF0aH18JHt0YXJnZXRSZWx9fCR7ZWRnZVR5cGV9fCR7ZGVwLnN0YXRlbWVudCA/PyAnJ31gO1xuICAgICAgaWYgKGVkZ2VLZXlzLmhhcyhlZGdlS2V5KSkgY29udGludWU7XG4gICAgICBlZGdlS2V5cy5hZGQoZWRnZUtleSk7XG5cbiAgICAgIGVkZ2VzLnB1c2goe1xuICAgICAgICBpZDogaGFzaElkKGVkZ2VLZXkpLFxuICAgICAgICBzb3VyY2U6IHJlbFBhdGgsXG4gICAgICAgIHRhcmdldDogdGFyZ2V0UmVsLFxuICAgICAgICB0eXBlOiBlZGdlVHlwZSxcbiAgICAgICAgc3RhdGVtZW50OiBkZXAuc3RhdGVtZW50Py5zbGljZSgwLCAyMDApLFxuICAgICAgICBsb2M6IGRlcC5sb2NcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB7XG4gICAgcm9vdDogcm9vdExhYmVsLFxuICAgIG5vZGVzOiBBcnJheS5mcm9tKG5vZGVzLnZhbHVlcygpKSxcbiAgICBlZGdlcyxcbiAgICB0b3RhbEZpbGVzLFxuICAgIGlnbm9yZWRDb3VudCxcbiAgICBleHRlcm5hbENvdW50XG4gIH07XG59O1xuIl0sIm5hbWVzIjpbImlnbm9yZSIsInBhcnNlIiwidHJhdmVyc2UiLCJBTFdBWVNfSUdOT1JFIiwiU0NSSVBUX0VYVEVOU0lPTlMiLCJTZXQiLCJTVFlMRV9FWFRFTlNJT05TIiwiU1VQUE9SVEVEX0VYVEVOU0lPTlMiLCJJTVBPUlRfRVhURU5TSU9OUyIsIlJPVVRFX1JFR0VYIiwiYXBwIiwicGFnZXMiLCJwb3NpeEpvaW4iLCJwYXJ0cyIsImZpbHRlciIsIkJvb2xlYW4iLCJqb2luIiwicmVwbGFjZSIsInBvc2l4RGlybmFtZSIsInZhbHVlIiwiaWR4IiwibGFzdEluZGV4T2YiLCJzbGljZSIsInBvc2l4QmFzZW5hbWUiLCJwb3NpeEV4dG5hbWUiLCJiYXNlIiwibm9ybWFsaXplUG9zaXhQYXRoIiwic3BsaXQiLCJzdGFjayIsImVzY2FwZWRSb290IiwicGFydCIsImxlbmd0aCIsInBvcCIsInB1c2giLCJwYXRoIiwibm9ybWFsaXplR2l0aWdub3JlUGF0dGVybiIsImRpclJlbCIsInJhd1BhdHRlcm4iLCJwYXR0ZXJuIiwidHJpbSIsInN0YXJ0c1dpdGgiLCJuZWdhdGVkIiwiYW5jaG9yZWQiLCJoYXNTbGFzaCIsImluY2x1ZGVzIiwiZW5kc1dpdGhTbGFzaCIsImVuZHNXaXRoIiwicHJlZml4ZWQiLCJub2RlVHlwZUZyb21QYXRoIiwicmVsUGF0aCIsInRlc3QiLCJiYXNlbmFtZSIsImhhcyIsImV4dHJhY3REZXBlbmRlbmNpZXMiLCJmaWxlUGF0aCIsImNvZGUiLCJkZXBlbmRlbmNpZXMiLCJhc3QiLCJzb3VyY2VUeXBlIiwicGx1Z2lucyIsIkltcG9ydERlY2xhcmF0aW9uIiwicGF0aE5vZGUiLCJub2RlIiwic291cmNlIiwiaW1wb3J0cyIsInNwZWNpZmllcnMiLCJmb3JFYWNoIiwic3BlY2lmaWVyIiwidHlwZSIsImtpbmQiLCJpbXBvcnRlZCIsImxvY2FsIiwibmFtZSIsImltcG9ydGVkTmFtZSIsInN0YXRlbWVudCIsInN0YXJ0IiwiZW5kIiwibG9jIiwibGluZSIsImNvbHVtbiIsInVuZGVmaW5lZCIsIkV4cG9ydEFsbERlY2xhcmF0aW9uIiwiRXhwb3J0TmFtZWREZWNsYXJhdGlvbiIsIkNhbGxFeHByZXNzaW9uIiwiY2FsbGVlIiwiYXJnIiwiYXJndW1lbnRzIiwicmVnZXgiLCJtYXRjaCIsImV4ZWMiLCJyZXNvbHZlV2l0aEV4dGVuc2lvbnMiLCJiYXNlUGF0aCIsImZpbGVTZXQiLCJkaXJTZXQiLCJleHQiLCJpbmRleFBhdGgiLCJyZXNvbHZlSW1wb3J0IiwiZnJvbUZpbGUiLCJjbGVhblNwZWNpZmllciIsInRhcmdldFBhdGgiLCJub3JtYWxpemVkIiwiZnJvbURpciIsImV4dGVybmFsIiwicmVzb2x2ZWQiLCJoYXNoSWQiLCJoMSIsImgyIiwiaSIsImNoIiwiY2hhckNvZGVBdCIsIk1hdGgiLCJpbXVsIiwidG9TdHJpbmciLCJzY2FuRGlyZWN0b3J5SGFuZGxlIiwib3B0aW9ucyIsInJvb3RIYW5kbGUiLCJtYXhGaWxlcyIsImluY2x1ZGVFeHRlcm5hbCIsInJvb3RMYWJlbCIsIm5vZGVzIiwiTWFwIiwiZWRnZXMiLCJlZGdlS2V5cyIsImlnbm9yZWROb2RlcyIsImZpbGVIYW5kbGVzIiwidG90YWxGaWxlcyIsImlnbm9yZWRDb3VudCIsImV4dGVybmFsQ291bnQiLCJ3YWxrIiwiZGlySGFuZGxlIiwicmVsRGlyIiwicGF0dGVybnMiLCJhZGQiLCJnaXRpZ25vcmVIYW5kbGUiLCJnZXRGaWxlSGFuZGxlIiwiY2F0Y2giLCJjb21iaW5lZFBhdHRlcm5zIiwiZ2l0aWdub3JlRmlsZSIsImdldEZpbGUiLCJnaXRpZ25vcmVDb250ZW50IiwidGV4dCIsImV4dHJhUGF0dGVybnMiLCJtYXAiLCJjb25jYXQiLCJpZyIsImhhbmRsZSIsImVudHJpZXMiLCJpZ25vcmVzIiwiaWQiLCJsYWJlbCIsImlnbm9yZWQiLCJFcnJvciIsInNldCIsImlnbm9yZWROb2RlIiwia2V5cyIsImZpbGUiLCJkZXAiLCJlZGdlS2V5IiwidGFyZ2V0IiwidGFyZ2V0UmVsIiwidGFyZ2V0RXh0IiwiZWRnZVR5cGUiLCJyb290IiwiQXJyYXkiLCJmcm9tIiwidmFsdWVzIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./lib/browser-scan.ts\n"));

/***/ })

});