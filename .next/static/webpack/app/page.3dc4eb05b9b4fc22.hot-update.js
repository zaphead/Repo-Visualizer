"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/page",{

/***/ "(app-pages-browser)/./lib/browser-scan.ts":
/*!*****************************!*\
  !*** ./lib/browser-scan.ts ***!
  \*****************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   scanDirectoryHandle: function() { return /* binding */ scanDirectoryHandle; }\n/* harmony export */ });\n/* harmony import */ var ignore__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ignore */ \"(app-pages-browser)/./node_modules/ignore/index.js\");\n/* harmony import */ var ignore__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(ignore__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _babel_parser__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @babel/parser */ \"(app-pages-browser)/./node_modules/@babel/parser/lib/index.js\");\n/* harmony import */ var _babel_traverse__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @babel/traverse */ \"(app-pages-browser)/./node_modules/@babel/traverse/lib/index.js\");\n\n\n\nconst ALWAYS_IGNORE = [\n    \".git/\",\n    \"node_modules/\",\n    \".next/\",\n    \"dist/\",\n    \"build/\",\n    \"out/\",\n    \"coverage/\",\n    \".turbo/\",\n    \".cache/\",\n    \".DS_Store\"\n];\nconst SCRIPT_EXTENSIONS = new Set([\n    \".js\",\n    \".jsx\",\n    \".ts\",\n    \".tsx\",\n    \".mjs\",\n    \".cjs\"\n]);\nconst STYLE_EXTENSIONS = new Set([\n    \".css\",\n    \".scss\",\n    \".sass\"\n]);\nconst SUPPORTED_EXTENSIONS = new Set([\n    ...SCRIPT_EXTENSIONS,\n    ...STYLE_EXTENSIONS\n]);\nconst IMPORT_EXTENSIONS = [\n    \".ts\",\n    \".tsx\",\n    \".js\",\n    \".jsx\",\n    \".mjs\",\n    \".cjs\",\n    \".css\",\n    \".scss\",\n    \".sass\"\n];\nconst ROUTE_REGEX = {\n    app: /(^|\\/)app\\/(.*\\/)?(page|route)\\.(t|j)sx?$/,\n    pages: /(^|\\/)pages\\/.+\\.(t|j)sx?$/\n};\nconst posixJoin = function() {\n    for(var _len = arguments.length, parts = new Array(_len), _key = 0; _key < _len; _key++){\n        parts[_key] = arguments[_key];\n    }\n    return parts.filter(Boolean).join(\"/\").replace(/\\/+/g, \"/\");\n};\nconst posixDirname = (value)=>{\n    const idx = value.lastIndexOf(\"/\");\n    return idx === -1 ? \"\" : value.slice(0, idx);\n};\nconst posixBasename = (value)=>{\n    const idx = value.lastIndexOf(\"/\");\n    return idx === -1 ? value : value.slice(idx + 1);\n};\nconst posixExtname = (value)=>{\n    const base = posixBasename(value);\n    const idx = base.lastIndexOf(\".\");\n    return idx === -1 ? \"\" : base.slice(idx);\n};\nconst normalizePosixPath = (value)=>{\n    const parts = value.split(\"/\");\n    const stack = [];\n    let escapedRoot = false;\n    for (const part of parts){\n        if (!part || part === \".\") continue;\n        if (part === \"..\") {\n            if (stack.length) {\n                stack.pop();\n            } else {\n                escapedRoot = true;\n            }\n            continue;\n        }\n        stack.push(part);\n    }\n    return {\n        path: stack.join(\"/\"),\n        escapedRoot\n    };\n};\nconst normalizeGitignorePattern = (dirRel, rawPattern)=>{\n    let pattern = rawPattern.trim();\n    if (!pattern || pattern.startsWith(\"#\")) return null;\n    const negated = pattern.startsWith(\"!\");\n    if (negated) pattern = pattern.slice(1);\n    if (!pattern) return null;\n    const anchored = pattern.startsWith(\"/\");\n    if (anchored) pattern = pattern.slice(1);\n    const hasSlash = pattern.includes(\"/\");\n    const endsWithSlash = pattern.endsWith(\"/\");\n    const base = dirRel ? dirRel : \"\";\n    let prefixed = pattern;\n    if (base) {\n        if (anchored || hasSlash) {\n            prefixed = posixJoin(base, pattern);\n        } else {\n            prefixed = posixJoin(base, \"**\", pattern);\n        }\n    } else if (!anchored && !hasSlash) {\n        prefixed = posixJoin(\"**\", pattern);\n    }\n    if (endsWithSlash && !prefixed.endsWith(\"/\")) {\n        prefixed += \"/\";\n    }\n    return negated ? \"!\".concat(prefixed) : prefixed;\n};\nconst nodeTypeFromPath = (relPath)=>{\n    if (relPath === \"__external__\") return \"external\";\n    if (ROUTE_REGEX.app.test(relPath) || ROUTE_REGEX.pages.test(relPath)) {\n        if (relPath.includes(\"/pages/\") || relPath.startsWith(\"pages/\")) {\n            const basename = posixBasename(relPath);\n            if (basename.startsWith(\"_\")) return \"module\";\n        }\n        return \"route\";\n    }\n    if (STYLE_EXTENSIONS.has(posixExtname(relPath))) return \"style\";\n    return \"module\";\n};\nconst extractDependencies = (filePath, code)=>{\n    const dependencies = [];\n    if (SCRIPT_EXTENSIONS.has(posixExtname(filePath))) {\n        let ast = null;\n        try {\n            ast = (0,_babel_parser__WEBPACK_IMPORTED_MODULE_1__.parse)(code, {\n                sourceType: \"unambiguous\",\n                plugins: [\n                    \"jsx\",\n                    \"typescript\",\n                    \"dynamicImport\",\n                    \"decorators-legacy\",\n                    \"classProperties\",\n                    \"classPrivateProperties\",\n                    \"importAssertions\",\n                    \"topLevelAwait\"\n                ]\n            });\n        } catch (e) {\n            return dependencies;\n        }\n        (0,_babel_traverse__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(ast, {\n            ImportDeclaration (pathNode) {\n                const value = pathNode.node.source.value;\n                var _pathNode_node_start, _pathNode_node_end;\n                dependencies.push({\n                    specifier: value,\n                    type: \"static\",\n                    statement: code.slice((_pathNode_node_start = pathNode.node.start) !== null && _pathNode_node_start !== void 0 ? _pathNode_node_start : 0, (_pathNode_node_end = pathNode.node.end) !== null && _pathNode_node_end !== void 0 ? _pathNode_node_end : 0),\n                    loc: pathNode.node.loc ? {\n                        line: pathNode.node.loc.start.line,\n                        column: pathNode.node.loc.start.column\n                    } : undefined\n                });\n            },\n            ExportAllDeclaration (pathNode) {\n                if (!pathNode.node.source) return;\n                const value = pathNode.node.source.value;\n                var _pathNode_node_start, _pathNode_node_end;\n                dependencies.push({\n                    specifier: value,\n                    type: \"static\",\n                    statement: code.slice((_pathNode_node_start = pathNode.node.start) !== null && _pathNode_node_start !== void 0 ? _pathNode_node_start : 0, (_pathNode_node_end = pathNode.node.end) !== null && _pathNode_node_end !== void 0 ? _pathNode_node_end : 0),\n                    loc: pathNode.node.loc ? {\n                        line: pathNode.node.loc.start.line,\n                        column: pathNode.node.loc.start.column\n                    } : undefined\n                });\n            },\n            ExportNamedDeclaration (pathNode) {\n                if (!pathNode.node.source) return;\n                const value = pathNode.node.source.value;\n                var _pathNode_node_start, _pathNode_node_end;\n                dependencies.push({\n                    specifier: value,\n                    type: \"static\",\n                    statement: code.slice((_pathNode_node_start = pathNode.node.start) !== null && _pathNode_node_start !== void 0 ? _pathNode_node_start : 0, (_pathNode_node_end = pathNode.node.end) !== null && _pathNode_node_end !== void 0 ? _pathNode_node_end : 0),\n                    loc: pathNode.node.loc ? {\n                        line: pathNode.node.loc.start.line,\n                        column: pathNode.node.loc.start.column\n                    } : undefined\n                });\n            },\n            CallExpression (pathNode) {\n                const callee = pathNode.node.callee;\n                if (callee.type === \"Import\") {\n                    const arg = pathNode.node.arguments[0];\n                    if (arg && arg.type === \"StringLiteral\") {\n                        var _pathNode_node_start, _pathNode_node_end;\n                        dependencies.push({\n                            specifier: arg.value,\n                            type: \"dynamic\",\n                            statement: code.slice((_pathNode_node_start = pathNode.node.start) !== null && _pathNode_node_start !== void 0 ? _pathNode_node_start : 0, (_pathNode_node_end = pathNode.node.end) !== null && _pathNode_node_end !== void 0 ? _pathNode_node_end : 0),\n                            loc: pathNode.node.loc ? {\n                                line: pathNode.node.loc.start.line,\n                                column: pathNode.node.loc.start.column\n                            } : undefined\n                        });\n                    }\n                }\n                if (callee.type === \"Identifier\" && callee.name === \"require\") {\n                    const arg = pathNode.node.arguments[0];\n                    if (arg && arg.type === \"StringLiteral\") {\n                        var _pathNode_node_start1, _pathNode_node_end1;\n                        dependencies.push({\n                            specifier: arg.value,\n                            type: \"static\",\n                            statement: code.slice((_pathNode_node_start1 = pathNode.node.start) !== null && _pathNode_node_start1 !== void 0 ? _pathNode_node_start1 : 0, (_pathNode_node_end1 = pathNode.node.end) !== null && _pathNode_node_end1 !== void 0 ? _pathNode_node_end1 : 0),\n                            loc: pathNode.node.loc ? {\n                                line: pathNode.node.loc.start.line,\n                                column: pathNode.node.loc.start.column\n                            } : undefined\n                        });\n                    }\n                }\n            }\n        });\n    }\n    if (STYLE_EXTENSIONS.has(posixExtname(filePath))) {\n        const regex = /@import\\s+(?:url\\()?['\"]([^'\"]+)['\"]/g;\n        let match;\n        while(match = regex.exec(code)){\n            dependencies.push({\n                specifier: match[1],\n                type: \"style\",\n                statement: match[0]\n            });\n        }\n    }\n    return dependencies;\n};\nconst resolveWithExtensions = (basePath, fileSet, dirSet)=>{\n    if (!basePath) return null;\n    if (fileSet.has(basePath)) return basePath;\n    if (dirSet.has(basePath)) {\n        for (const ext of IMPORT_EXTENSIONS){\n            const indexPath = posixJoin(basePath, \"index\".concat(ext));\n            if (fileSet.has(indexPath)) return indexPath;\n        }\n    }\n    if (!posixExtname(basePath)) {\n        for (const ext of IMPORT_EXTENSIONS){\n            const filePath = \"\".concat(basePath).concat(ext);\n            if (fileSet.has(filePath)) return filePath;\n        }\n    }\n    return null;\n};\nconst resolveImport = (fromFile, specifier, fileSet, dirSet)=>{\n    if (!specifier || specifier.startsWith(\"http\")) return null;\n    const cleanSpecifier = specifier.split(\"?\")[0].split(\"#\")[0];\n    let targetPath = null;\n    let escapedRoot = false;\n    if (cleanSpecifier.startsWith(\"@/\")) {\n        const normalized = normalizePosixPath(cleanSpecifier.slice(2));\n        targetPath = normalized.path;\n        escapedRoot = normalized.escapedRoot;\n    } else if (cleanSpecifier.startsWith(\"/\")) {\n        const normalized = normalizePosixPath(cleanSpecifier.slice(1));\n        targetPath = normalized.path;\n        escapedRoot = normalized.escapedRoot;\n    } else if (cleanSpecifier.startsWith(\".\")) {\n        const fromDir = posixDirname(fromFile);\n        const normalized = normalizePosixPath(posixJoin(fromDir, cleanSpecifier));\n        targetPath = normalized.path;\n        escapedRoot = normalized.escapedRoot;\n    } else {\n        return {\n            external: true,\n            resolved: null\n        };\n    }\n    if (!targetPath || escapedRoot) {\n        return {\n            external: true,\n            resolved: null\n        };\n    }\n    const resolved = resolveWithExtensions(targetPath, fileSet, dirSet);\n    if (!resolved) return {\n        external: true,\n        resolved: null\n    };\n    return {\n        external: false,\n        resolved\n    };\n};\nconst hashId = (value)=>{\n    let h1 = 0xdeadbeef ^ value.length;\n    let h2 = 0x41c6ce57 ^ value.length;\n    for(let i = 0; i < value.length; i += 1){\n        const ch = value.charCodeAt(i);\n        h1 = Math.imul(h1 ^ ch, 2654435761);\n        h2 = Math.imul(h2 ^ ch, 1597334677);\n    }\n    h1 = Math.imul(h1 ^ h1 >>> 16, 2246822507);\n    h2 = Math.imul(h2 ^ h2 >>> 16, 2246822507);\n    return \"\".concat((h1 >>> 0).toString(16)).concat((h2 >>> 0).toString(16));\n};\nconst scanDirectoryHandle = async (options)=>{\n    const { rootHandle, maxFiles, includeExternal } = options;\n    const rootLabel = rootHandle.name || \"Selected folder\";\n    const nodes = new Map();\n    const edges = [];\n    const edgeKeys = new Set();\n    const ignoredNodes = [];\n    const fileHandles = new Map();\n    const dirSet = new Set([\n        \"\"\n    ]);\n    let totalFiles = 0;\n    let ignoredCount = 0;\n    let externalCount = 0;\n    const walk = async (dirHandle, relDir, patterns)=>{\n        dirSet.add(relDir);\n        const gitignoreHandle = await dirHandle.getFileHandle(\".gitignore\").catch(()=>null);\n        let combinedPatterns = patterns;\n        if (gitignoreHandle) {\n            const gitignoreFile = await gitignoreHandle.getFile().catch(()=>null);\n            const gitignoreContent = await (gitignoreFile === null || gitignoreFile === void 0 ? void 0 : gitignoreFile.text());\n            if (gitignoreContent) {\n                const extraPatterns = gitignoreContent.split(/\\r?\\n/).map((line)=>normalizeGitignorePattern(relDir, line)).filter((value)=>Boolean(value));\n                combinedPatterns = patterns.concat(extraPatterns);\n            }\n        }\n        const ig = ignore__WEBPACK_IMPORTED_MODULE_0___default()().add(combinedPatterns);\n        for await (const [name, handle] of dirHandle.entries()){\n            const relPath = relDir ? \"\".concat(relDir, \"/\").concat(name) : name;\n            if (!relPath) continue;\n            if (ig.ignores(relPath)) {\n                ignoredCount += 1;\n                if (handle.kind === \"file\" && SUPPORTED_EXTENSIONS.has(posixExtname(relPath))) {\n                    ignoredNodes.push({\n                        id: relPath,\n                        path: relPath,\n                        label: posixBasename(relPath),\n                        type: nodeTypeFromPath(relPath),\n                        ignored: true\n                    });\n                }\n                continue;\n            }\n            if (handle.kind === \"directory\") {\n                await walk(handle, relPath, combinedPatterns);\n                continue;\n            }\n            totalFiles += 1;\n            if (totalFiles > maxFiles) {\n                throw new Error(\"File limit exceeded (\".concat(maxFiles, \"). Adjust the max files setting to continue.\"));\n            }\n            if (!SUPPORTED_EXTENSIONS.has(posixExtname(relPath))) continue;\n            nodes.set(relPath, {\n                id: relPath,\n                path: relPath,\n                label: posixBasename(relPath),\n                type: nodeTypeFromPath(relPath)\n            });\n            fileHandles.set(relPath, handle);\n        }\n    };\n    await walk(rootHandle, \"\", ALWAYS_IGNORE);\n    for (const ignoredNode of ignoredNodes){\n        nodes.set(ignoredNode.id, ignoredNode);\n    }\n    const fileSet = new Set(fileHandles.keys());\n    for (const [relPath, handle] of fileHandles.entries()){\n        const file = await handle.getFile().catch(()=>null);\n        const code = await (file === null || file === void 0 ? void 0 : file.text());\n        if (!code) continue;\n        const dependencies = extractDependencies(relPath, code);\n        for (const dep of dependencies){\n            var _dep_statement;\n            const resolved = resolveImport(relPath, dep.specifier, fileSet, dirSet);\n            if (!resolved) continue;\n            if (resolved.external) {\n                externalCount += 1;\n                if (!includeExternal) continue;\n                if (!nodes.has(\"__external__\")) {\n                    nodes.set(\"__external__\", {\n                        id: \"__external__\",\n                        path: \"__external__\",\n                        label: \"External\",\n                        type: \"external\"\n                    });\n                }\n                const edgeKey = \"\".concat(relPath, \"|__external__|external|\").concat(dep.specifier);\n                if (edgeKeys.has(edgeKey)) continue;\n                edgeKeys.add(edgeKey);\n                edges.push({\n                    id: hashId(edgeKey),\n                    source: relPath,\n                    target: \"__external__\",\n                    type: \"external\",\n                    statement: dep.statement,\n                    loc: dep.loc\n                });\n                continue;\n            }\n            if (!resolved.resolved) continue;\n            const targetRel = resolved.resolved;\n            if (!nodes.has(targetRel)) {\n                nodes.set(targetRel, {\n                    id: targetRel,\n                    path: targetRel,\n                    label: posixBasename(targetRel),\n                    type: nodeTypeFromPath(targetRel)\n                });\n            }\n            const targetExt = posixExtname(targetRel);\n            const edgeType = STYLE_EXTENSIONS.has(targetExt) ? \"style\" : dep.type;\n            var _dep_statement1;\n            const edgeKey = \"\".concat(relPath, \"|\").concat(targetRel, \"|\").concat(edgeType, \"|\").concat((_dep_statement1 = dep.statement) !== null && _dep_statement1 !== void 0 ? _dep_statement1 : \"\");\n            if (edgeKeys.has(edgeKey)) continue;\n            edgeKeys.add(edgeKey);\n            edges.push({\n                id: hashId(edgeKey),\n                source: relPath,\n                target: targetRel,\n                type: edgeType,\n                statement: (_dep_statement = dep.statement) === null || _dep_statement === void 0 ? void 0 : _dep_statement.slice(0, 200),\n                loc: dep.loc\n            });\n        }\n    }\n    return {\n        root: rootLabel,\n        nodes: Array.from(nodes.values()),\n        edges,\n        totalFiles,\n        ignoredCount,\n        externalCount\n    };\n};\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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Ly4vbGliL2Jyb3dzZXItc2Nhbi50cz8zMDBmIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBpZ25vcmUgZnJvbSAnaWdub3JlJztcbmltcG9ydCB7IHBhcnNlIH0gZnJvbSAnQGJhYmVsL3BhcnNlcic7XG5pbXBvcnQgdHJhdmVyc2UgZnJvbSAnQGJhYmVsL3RyYXZlcnNlJztcbmltcG9ydCB0eXBlIHsgRmlsZSB9IGZyb20gJ0BiYWJlbC90eXBlcyc7XG5pbXBvcnQgdHlwZSB7IEVkZ2VUeXBlLCBHcmFwaERhdGEsIEdyYXBoRWRnZSwgR3JhcGhOb2RlIH0gZnJvbSAnLi90eXBlcyc7XG5cbmNvbnN0IEFMV0FZU19JR05PUkUgPSBbXG4gICcuZ2l0LycsXG4gICdub2RlX21vZHVsZXMvJyxcbiAgJy5uZXh0LycsXG4gICdkaXN0LycsXG4gICdidWlsZC8nLFxuICAnb3V0LycsXG4gICdjb3ZlcmFnZS8nLFxuICAnLnR1cmJvLycsXG4gICcuY2FjaGUvJyxcbiAgJy5EU19TdG9yZSdcbl07XG5cbmNvbnN0IFNDUklQVF9FWFRFTlNJT05TID0gbmV3IFNldChbXG4gICcuanMnLFxuICAnLmpzeCcsXG4gICcudHMnLFxuICAnLnRzeCcsXG4gICcubWpzJyxcbiAgJy5janMnXG5dKTtcbmNvbnN0IFNUWUxFX0VYVEVOU0lPTlMgPSBuZXcgU2V0KFsnLmNzcycsICcuc2NzcycsICcuc2FzcyddKTtcbmNvbnN0IFNVUFBPUlRFRF9FWFRFTlNJT05TID0gbmV3IFNldChbXG4gIC4uLlNDUklQVF9FWFRFTlNJT05TLFxuICAuLi5TVFlMRV9FWFRFTlNJT05TXG5dKTtcblxuY29uc3QgSU1QT1JUX0VYVEVOU0lPTlMgPSBbXG4gICcudHMnLFxuICAnLnRzeCcsXG4gICcuanMnLFxuICAnLmpzeCcsXG4gICcubWpzJyxcbiAgJy5janMnLFxuICAnLmNzcycsXG4gICcuc2NzcycsXG4gICcuc2Fzcydcbl07XG5cbmNvbnN0IFJPVVRFX1JFR0VYID0ge1xuICBhcHA6IC8oXnxcXC8pYXBwXFwvKC4qXFwvKT8ocGFnZXxyb3V0ZSlcXC4odHxqKXN4PyQvLFxuICBwYWdlczogLyhefFxcLylwYWdlc1xcLy4rXFwuKHR8ailzeD8kL1xufTtcblxudHlwZSBEZXBlbmRlbmN5ID0ge1xuICBzcGVjaWZpZXI6IHN0cmluZztcbiAgdHlwZTogRWRnZVR5cGU7XG4gIHN0YXRlbWVudD86IHN0cmluZztcbiAgbG9jPzogeyBsaW5lOiBudW1iZXI7IGNvbHVtbjogbnVtYmVyIH07XG4gIGltcG9ydHM/OiBJbXBvcnRCaW5kaW5nW107XG59O1xuXG50eXBlIEJyb3dzZXJTY2FuT3B0aW9ucyA9IHtcbiAgcm9vdEhhbmRsZTogRmlsZVN5c3RlbURpcmVjdG9yeUhhbmRsZTtcbiAgbWF4RmlsZXM6IG51bWJlcjtcbiAgaW5jbHVkZUV4dGVybmFsOiBib29sZWFuO1xuICBncmFudWxhcml0eT86IFNjYW5HcmFudWxhcml0eTtcbn07XG5cbnR5cGUgU2NhbkdyYW51bGFyaXR5ID0gJ2ZpbGUnIHwgJ3N5bWJvbCc7XG5cbnR5cGUgSW1wb3J0QmluZGluZyA9IHtcbiAga2luZDogJ2RlZmF1bHQnIHwgJ25hbWVkJyB8ICduYW1lc3BhY2UnO1xuICBpbXBvcnRlZDogc3RyaW5nO1xuICBsb2NhbDogc3RyaW5nO1xufTtcblxudHlwZSBTeW1ib2xJbmZvID0ge1xuICBuYW1lOiBzdHJpbmc7XG4gIGtpbmQ6IHN0cmluZztcbiAgZGlzcGxheU5hbWU/OiBzdHJpbmc7XG59O1xuXG5jb25zdCBwb3NpeEpvaW4gPSAoLi4ucGFydHM6IHN0cmluZ1tdKSA9PlxuICBwYXJ0c1xuICAgIC5maWx0ZXIoQm9vbGVhbilcbiAgICAuam9pbignLycpXG4gICAgLnJlcGxhY2UoL1xcLysvZywgJy8nKTtcblxuY29uc3QgcG9zaXhEaXJuYW1lID0gKHZhbHVlOiBzdHJpbmcpID0+IHtcbiAgY29uc3QgaWR4ID0gdmFsdWUubGFzdEluZGV4T2YoJy8nKTtcbiAgcmV0dXJuIGlkeCA9PT0gLTEgPyAnJyA6IHZhbHVlLnNsaWNlKDAsIGlkeCk7XG59O1xuXG5jb25zdCBwb3NpeEJhc2VuYW1lID0gKHZhbHVlOiBzdHJpbmcpID0+IHtcbiAgY29uc3QgaWR4ID0gdmFsdWUubGFzdEluZGV4T2YoJy8nKTtcbiAgcmV0dXJuIGlkeCA9PT0gLTEgPyB2YWx1ZSA6IHZhbHVlLnNsaWNlKGlkeCArIDEpO1xufTtcblxuY29uc3QgcG9zaXhFeHRuYW1lID0gKHZhbHVlOiBzdHJpbmcpID0+IHtcbiAgY29uc3QgYmFzZSA9IHBvc2l4QmFzZW5hbWUodmFsdWUpO1xuICBjb25zdCBpZHggPSBiYXNlLmxhc3RJbmRleE9mKCcuJyk7XG4gIHJldHVybiBpZHggPT09IC0xID8gJycgOiBiYXNlLnNsaWNlKGlkeCk7XG59O1xuXG5jb25zdCBub3JtYWxpemVQb3NpeFBhdGggPSAodmFsdWU6IHN0cmluZykgPT4ge1xuICBjb25zdCBwYXJ0cyA9IHZhbHVlLnNwbGl0KCcvJyk7XG4gIGNvbnN0IHN0YWNrOiBzdHJpbmdbXSA9IFtdO1xuICBsZXQgZXNjYXBlZFJvb3QgPSBmYWxzZTtcblxuICBmb3IgKGNvbnN0IHBhcnQgb2YgcGFydHMpIHtcbiAgICBpZiAoIXBhcnQgfHwgcGFydCA9PT0gJy4nKSBjb250aW51ZTtcbiAgICBpZiAocGFydCA9PT0gJy4uJykge1xuICAgICAgaWYgKHN0YWNrLmxlbmd0aCkge1xuICAgICAgICBzdGFjay5wb3AoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGVzY2FwZWRSb290ID0gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICBzdGFjay5wdXNoKHBhcnQpO1xuICB9XG5cbiAgcmV0dXJuIHsgcGF0aDogc3RhY2suam9pbignLycpLCBlc2NhcGVkUm9vdCB9O1xufTtcblxuY29uc3Qgbm9ybWFsaXplR2l0aWdub3JlUGF0dGVybiA9IChkaXJSZWw6IHN0cmluZywgcmF3UGF0dGVybjogc3RyaW5nKSA9PiB7XG4gIGxldCBwYXR0ZXJuID0gcmF3UGF0dGVybi50cmltKCk7XG4gIGlmICghcGF0dGVybiB8fCBwYXR0ZXJuLnN0YXJ0c1dpdGgoJyMnKSkgcmV0dXJuIG51bGw7XG4gIGNvbnN0IG5lZ2F0ZWQgPSBwYXR0ZXJuLnN0YXJ0c1dpdGgoJyEnKTtcbiAgaWYgKG5lZ2F0ZWQpIHBhdHRlcm4gPSBwYXR0ZXJuLnNsaWNlKDEpO1xuICBpZiAoIXBhdHRlcm4pIHJldHVybiBudWxsO1xuXG4gIGNvbnN0IGFuY2hvcmVkID0gcGF0dGVybi5zdGFydHNXaXRoKCcvJyk7XG4gIGlmIChhbmNob3JlZCkgcGF0dGVybiA9IHBhdHRlcm4uc2xpY2UoMSk7XG5cbiAgY29uc3QgaGFzU2xhc2ggPSBwYXR0ZXJuLmluY2x1ZGVzKCcvJyk7XG4gIGNvbnN0IGVuZHNXaXRoU2xhc2ggPSBwYXR0ZXJuLmVuZHNXaXRoKCcvJyk7XG5cbiAgY29uc3QgYmFzZSA9IGRpclJlbCA/IGRpclJlbCA6ICcnO1xuXG4gIGxldCBwcmVmaXhlZCA9IHBhdHRlcm47XG5cbiAgaWYgKGJhc2UpIHtcbiAgICBpZiAoYW5jaG9yZWQgfHwgaGFzU2xhc2gpIHtcbiAgICAgIHByZWZpeGVkID0gcG9zaXhKb2luKGJhc2UsIHBhdHRlcm4pO1xuICAgIH0gZWxzZSB7XG4gICAgICBwcmVmaXhlZCA9IHBvc2l4Sm9pbihiYXNlLCAnKionLCBwYXR0ZXJuKTtcbiAgICB9XG4gIH0gZWxzZSBpZiAoIWFuY2hvcmVkICYmICFoYXNTbGFzaCkge1xuICAgIHByZWZpeGVkID0gcG9zaXhKb2luKCcqKicsIHBhdHRlcm4pO1xuICB9XG5cbiAgaWYgKGVuZHNXaXRoU2xhc2ggJiYgIXByZWZpeGVkLmVuZHNXaXRoKCcvJykpIHtcbiAgICBwcmVmaXhlZCArPSAnLyc7XG4gIH1cblxuICByZXR1cm4gbmVnYXRlZCA/IGAhJHtwcmVmaXhlZH1gIDogcHJlZml4ZWQ7XG59O1xuXG5jb25zdCBub2RlVHlwZUZyb21QYXRoID0gKHJlbFBhdGg6IHN0cmluZykgPT4ge1xuICBpZiAocmVsUGF0aCA9PT0gJ19fZXh0ZXJuYWxfXycpIHJldHVybiAnZXh0ZXJuYWwnO1xuICBpZiAoUk9VVEVfUkVHRVguYXBwLnRlc3QocmVsUGF0aCkgfHwgUk9VVEVfUkVHRVgucGFnZXMudGVzdChyZWxQYXRoKSkge1xuICAgIGlmIChyZWxQYXRoLmluY2x1ZGVzKCcvcGFnZXMvJykgfHwgcmVsUGF0aC5zdGFydHNXaXRoKCdwYWdlcy8nKSkge1xuICAgICAgY29uc3QgYmFzZW5hbWUgPSBwb3NpeEJhc2VuYW1lKHJlbFBhdGgpO1xuICAgICAgaWYgKGJhc2VuYW1lLnN0YXJ0c1dpdGgoJ18nKSkgcmV0dXJuICdtb2R1bGUnO1xuICAgIH1cbiAgICByZXR1cm4gJ3JvdXRlJztcbiAgfVxuICBpZiAoU1RZTEVfRVhURU5TSU9OUy5oYXMocG9zaXhFeHRuYW1lKHJlbFBhdGgpKSkgcmV0dXJuICdzdHlsZSc7XG4gIHJldHVybiAnbW9kdWxlJztcbn07XG5cbmNvbnN0IGV4dHJhY3REZXBlbmRlbmNpZXMgPSAoZmlsZVBhdGg6IHN0cmluZywgY29kZTogc3RyaW5nKTogRGVwZW5kZW5jeVtdID0+IHtcbiAgY29uc3QgZGVwZW5kZW5jaWVzOiBEZXBlbmRlbmN5W10gPSBbXTtcblxuICBpZiAoU0NSSVBUX0VYVEVOU0lPTlMuaGFzKHBvc2l4RXh0bmFtZShmaWxlUGF0aCkpKSB7XG4gICAgbGV0IGFzdDogRmlsZSB8IG51bGwgPSBudWxsO1xuICAgIHRyeSB7XG4gICAgICBhc3QgPSBwYXJzZShjb2RlLCB7XG4gICAgICAgIHNvdXJjZVR5cGU6ICd1bmFtYmlndW91cycsXG4gICAgICAgIHBsdWdpbnM6IFtcbiAgICAgICAgICAnanN4JyxcbiAgICAgICAgICAndHlwZXNjcmlwdCcsXG4gICAgICAgICAgJ2R5bmFtaWNJbXBvcnQnLFxuICAgICAgICAgICdkZWNvcmF0b3JzLWxlZ2FjeScsXG4gICAgICAgICAgJ2NsYXNzUHJvcGVydGllcycsXG4gICAgICAgICAgJ2NsYXNzUHJpdmF0ZVByb3BlcnRpZXMnLFxuICAgICAgICAgICdpbXBvcnRBc3NlcnRpb25zJyxcbiAgICAgICAgICAndG9wTGV2ZWxBd2FpdCdcbiAgICAgICAgXVxuICAgICAgfSk7XG4gICAgfSBjYXRjaCB7XG4gICAgICByZXR1cm4gZGVwZW5kZW5jaWVzO1xuICAgIH1cblxuICAgIHRyYXZlcnNlKGFzdCwge1xuICAgICAgSW1wb3J0RGVjbGFyYXRpb24ocGF0aE5vZGUpIHtcbiAgICAgICAgY29uc3QgdmFsdWUgPSBwYXRoTm9kZS5ub2RlLnNvdXJjZS52YWx1ZTtcbiAgICAgICAgZGVwZW5kZW5jaWVzLnB1c2goe1xuICAgICAgICAgIHNwZWNpZmllcjogdmFsdWUsXG4gICAgICAgICAgdHlwZTogJ3N0YXRpYycsXG4gICAgICAgICAgc3RhdGVtZW50OiBjb2RlLnNsaWNlKHBhdGhOb2RlLm5vZGUuc3RhcnQgPz8gMCwgcGF0aE5vZGUubm9kZS5lbmQgPz8gMCksXG4gICAgICAgICAgbG9jOiBwYXRoTm9kZS5ub2RlLmxvY1xuICAgICAgICAgICAgPyB7IGxpbmU6IHBhdGhOb2RlLm5vZGUubG9jLnN0YXJ0LmxpbmUsIGNvbHVtbjogcGF0aE5vZGUubm9kZS5sb2Muc3RhcnQuY29sdW1uIH1cbiAgICAgICAgICAgIDogdW5kZWZpbmVkXG4gICAgICAgIH0pO1xuICAgICAgfSxcbiAgICAgIEV4cG9ydEFsbERlY2xhcmF0aW9uKHBhdGhOb2RlKSB7XG4gICAgICAgIGlmICghcGF0aE5vZGUubm9kZS5zb3VyY2UpIHJldHVybjtcbiAgICAgICAgY29uc3QgdmFsdWUgPSBwYXRoTm9kZS5ub2RlLnNvdXJjZS52YWx1ZTtcbiAgICAgICAgZGVwZW5kZW5jaWVzLnB1c2goe1xuICAgICAgICAgIHNwZWNpZmllcjogdmFsdWUsXG4gICAgICAgICAgdHlwZTogJ3N0YXRpYycsXG4gICAgICAgICAgc3RhdGVtZW50OiBjb2RlLnNsaWNlKHBhdGhOb2RlLm5vZGUuc3RhcnQgPz8gMCwgcGF0aE5vZGUubm9kZS5lbmQgPz8gMCksXG4gICAgICAgICAgbG9jOiBwYXRoTm9kZS5ub2RlLmxvY1xuICAgICAgICAgICAgPyB7IGxpbmU6IHBhdGhOb2RlLm5vZGUubG9jLnN0YXJ0LmxpbmUsIGNvbHVtbjogcGF0aE5vZGUubm9kZS5sb2Muc3RhcnQuY29sdW1uIH1cbiAgICAgICAgICAgIDogdW5kZWZpbmVkXG4gICAgICAgIH0pO1xuICAgICAgfSxcbiAgICAgIEV4cG9ydE5hbWVkRGVjbGFyYXRpb24ocGF0aE5vZGUpIHtcbiAgICAgICAgaWYgKCFwYXRoTm9kZS5ub2RlLnNvdXJjZSkgcmV0dXJuO1xuICAgICAgICBjb25zdCB2YWx1ZSA9IHBhdGhOb2RlLm5vZGUuc291cmNlLnZhbHVlO1xuICAgICAgICBkZXBlbmRlbmNpZXMucHVzaCh7XG4gICAgICAgICAgc3BlY2lmaWVyOiB2YWx1ZSxcbiAgICAgICAgICB0eXBlOiAnc3RhdGljJyxcbiAgICAgICAgICBzdGF0ZW1lbnQ6IGNvZGUuc2xpY2UocGF0aE5vZGUubm9kZS5zdGFydCA/PyAwLCBwYXRoTm9kZS5ub2RlLmVuZCA/PyAwKSxcbiAgICAgICAgICBsb2M6IHBhdGhOb2RlLm5vZGUubG9jXG4gICAgICAgICAgICA/IHsgbGluZTogcGF0aE5vZGUubm9kZS5sb2Muc3RhcnQubGluZSwgY29sdW1uOiBwYXRoTm9kZS5ub2RlLmxvYy5zdGFydC5jb2x1bW4gfVxuICAgICAgICAgICAgOiB1bmRlZmluZWRcbiAgICAgICAgfSk7XG4gICAgICB9LFxuICAgICAgQ2FsbEV4cHJlc3Npb24ocGF0aE5vZGUpIHtcbiAgICAgICAgY29uc3QgY2FsbGVlID0gcGF0aE5vZGUubm9kZS5jYWxsZWU7XG4gICAgICAgIGlmIChjYWxsZWUudHlwZSA9PT0gJ0ltcG9ydCcpIHtcbiAgICAgICAgICBjb25zdCBhcmcgPSBwYXRoTm9kZS5ub2RlLmFyZ3VtZW50c1swXTtcbiAgICAgICAgICBpZiAoYXJnICYmIGFyZy50eXBlID09PSAnU3RyaW5nTGl0ZXJhbCcpIHtcbiAgICAgICAgICAgIGRlcGVuZGVuY2llcy5wdXNoKHtcbiAgICAgICAgICAgICAgc3BlY2lmaWVyOiBhcmcudmFsdWUsXG4gICAgICAgICAgICAgIHR5cGU6ICdkeW5hbWljJyxcbiAgICAgICAgICAgICAgc3RhdGVtZW50OiBjb2RlLnNsaWNlKHBhdGhOb2RlLm5vZGUuc3RhcnQgPz8gMCwgcGF0aE5vZGUubm9kZS5lbmQgPz8gMCksXG4gICAgICAgICAgICAgIGxvYzogcGF0aE5vZGUubm9kZS5sb2NcbiAgICAgICAgICAgICAgICA/IHsgbGluZTogcGF0aE5vZGUubm9kZS5sb2Muc3RhcnQubGluZSwgY29sdW1uOiBwYXRoTm9kZS5ub2RlLmxvYy5zdGFydC5jb2x1bW4gfVxuICAgICAgICAgICAgICAgIDogdW5kZWZpbmVkXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoY2FsbGVlLnR5cGUgPT09ICdJZGVudGlmaWVyJyAmJiBjYWxsZWUubmFtZSA9PT0gJ3JlcXVpcmUnKSB7XG4gICAgICAgICAgY29uc3QgYXJnID0gcGF0aE5vZGUubm9kZS5hcmd1bWVudHNbMF07XG4gICAgICAgICAgaWYgKGFyZyAmJiBhcmcudHlwZSA9PT0gJ1N0cmluZ0xpdGVyYWwnKSB7XG4gICAgICAgICAgICBkZXBlbmRlbmNpZXMucHVzaCh7XG4gICAgICAgICAgICAgIHNwZWNpZmllcjogYXJnLnZhbHVlLFxuICAgICAgICAgICAgICB0eXBlOiAnc3RhdGljJyxcbiAgICAgICAgICAgICAgc3RhdGVtZW50OiBjb2RlLnNsaWNlKHBhdGhOb2RlLm5vZGUuc3RhcnQgPz8gMCwgcGF0aE5vZGUubm9kZS5lbmQgPz8gMCksXG4gICAgICAgICAgICAgIGxvYzogcGF0aE5vZGUubm9kZS5sb2NcbiAgICAgICAgICAgICAgICA/IHsgbGluZTogcGF0aE5vZGUubm9kZS5sb2Muc3RhcnQubGluZSwgY29sdW1uOiBwYXRoTm9kZS5ub2RlLmxvYy5zdGFydC5jb2x1bW4gfVxuICAgICAgICAgICAgICAgIDogdW5kZWZpbmVkXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIGlmIChTVFlMRV9FWFRFTlNJT05TLmhhcyhwb3NpeEV4dG5hbWUoZmlsZVBhdGgpKSkge1xuICAgIGNvbnN0IHJlZ2V4ID0gL0BpbXBvcnRcXHMrKD86dXJsXFwoKT9bJ1wiXShbXidcIl0rKVsnXCJdL2c7XG4gICAgbGV0IG1hdGNoOiBSZWdFeHBFeGVjQXJyYXkgfCBudWxsO1xuICAgIHdoaWxlICgobWF0Y2ggPSByZWdleC5leGVjKGNvZGUpKSkge1xuICAgICAgZGVwZW5kZW5jaWVzLnB1c2goe1xuICAgICAgICBzcGVjaWZpZXI6IG1hdGNoWzFdLFxuICAgICAgICB0eXBlOiAnc3R5bGUnLFxuICAgICAgICBzdGF0ZW1lbnQ6IG1hdGNoWzBdXG4gICAgICB9KTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZGVwZW5kZW5jaWVzO1xufTtcblxuY29uc3QgcmVzb2x2ZVdpdGhFeHRlbnNpb25zID0gKFxuICBiYXNlUGF0aDogc3RyaW5nIHwgbnVsbCxcbiAgZmlsZVNldDogU2V0PHN0cmluZz4sXG4gIGRpclNldDogU2V0PHN0cmluZz5cbikgPT4ge1xuICBpZiAoIWJhc2VQYXRoKSByZXR1cm4gbnVsbDtcbiAgaWYgKGZpbGVTZXQuaGFzKGJhc2VQYXRoKSkgcmV0dXJuIGJhc2VQYXRoO1xuXG4gIGlmIChkaXJTZXQuaGFzKGJhc2VQYXRoKSkge1xuICAgIGZvciAoY29uc3QgZXh0IG9mIElNUE9SVF9FWFRFTlNJT05TKSB7XG4gICAgICBjb25zdCBpbmRleFBhdGggPSBwb3NpeEpvaW4oYmFzZVBhdGgsIGBpbmRleCR7ZXh0fWApO1xuICAgICAgaWYgKGZpbGVTZXQuaGFzKGluZGV4UGF0aCkpIHJldHVybiBpbmRleFBhdGg7XG4gICAgfVxuICB9XG5cbiAgaWYgKCFwb3NpeEV4dG5hbWUoYmFzZVBhdGgpKSB7XG4gICAgZm9yIChjb25zdCBleHQgb2YgSU1QT1JUX0VYVEVOU0lPTlMpIHtcbiAgICAgIGNvbnN0IGZpbGVQYXRoID0gYCR7YmFzZVBhdGh9JHtleHR9YDtcbiAgICAgIGlmIChmaWxlU2V0LmhhcyhmaWxlUGF0aCkpIHJldHVybiBmaWxlUGF0aDtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gbnVsbDtcbn07XG5cbmNvbnN0IHJlc29sdmVJbXBvcnQgPSAoXG4gIGZyb21GaWxlOiBzdHJpbmcsXG4gIHNwZWNpZmllcjogc3RyaW5nLFxuICBmaWxlU2V0OiBTZXQ8c3RyaW5nPixcbiAgZGlyU2V0OiBTZXQ8c3RyaW5nPlxuKSA9PiB7XG4gIGlmICghc3BlY2lmaWVyIHx8IHNwZWNpZmllci5zdGFydHNXaXRoKCdodHRwJykpIHJldHVybiBudWxsO1xuXG4gIGNvbnN0IGNsZWFuU3BlY2lmaWVyID0gc3BlY2lmaWVyLnNwbGl0KCc/JylbMF0uc3BsaXQoJyMnKVswXTtcbiAgbGV0IHRhcmdldFBhdGg6IHN0cmluZyB8IG51bGwgPSBudWxsO1xuICBsZXQgZXNjYXBlZFJvb3QgPSBmYWxzZTtcblxuICBpZiAoY2xlYW5TcGVjaWZpZXIuc3RhcnRzV2l0aCgnQC8nKSkge1xuICAgIGNvbnN0IG5vcm1hbGl6ZWQgPSBub3JtYWxpemVQb3NpeFBhdGgoY2xlYW5TcGVjaWZpZXIuc2xpY2UoMikpO1xuICAgIHRhcmdldFBhdGggPSBub3JtYWxpemVkLnBhdGg7XG4gICAgZXNjYXBlZFJvb3QgPSBub3JtYWxpemVkLmVzY2FwZWRSb290O1xuICB9IGVsc2UgaWYgKGNsZWFuU3BlY2lmaWVyLnN0YXJ0c1dpdGgoJy8nKSkge1xuICAgIGNvbnN0IG5vcm1hbGl6ZWQgPSBub3JtYWxpemVQb3NpeFBhdGgoY2xlYW5TcGVjaWZpZXIuc2xpY2UoMSkpO1xuICAgIHRhcmdldFBhdGggPSBub3JtYWxpemVkLnBhdGg7XG4gICAgZXNjYXBlZFJvb3QgPSBub3JtYWxpemVkLmVzY2FwZWRSb290O1xuICB9IGVsc2UgaWYgKGNsZWFuU3BlY2lmaWVyLnN0YXJ0c1dpdGgoJy4nKSkge1xuICAgIGNvbnN0IGZyb21EaXIgPSBwb3NpeERpcm5hbWUoZnJvbUZpbGUpO1xuICAgIGNvbnN0IG5vcm1hbGl6ZWQgPSBub3JtYWxpemVQb3NpeFBhdGgocG9zaXhKb2luKGZyb21EaXIsIGNsZWFuU3BlY2lmaWVyKSk7XG4gICAgdGFyZ2V0UGF0aCA9IG5vcm1hbGl6ZWQucGF0aDtcbiAgICBlc2NhcGVkUm9vdCA9IG5vcm1hbGl6ZWQuZXNjYXBlZFJvb3Q7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIHsgZXh0ZXJuYWw6IHRydWUsIHJlc29sdmVkOiBudWxsIH07XG4gIH1cblxuICBpZiAoIXRhcmdldFBhdGggfHwgZXNjYXBlZFJvb3QpIHtcbiAgICByZXR1cm4geyBleHRlcm5hbDogdHJ1ZSwgcmVzb2x2ZWQ6IG51bGwgfTtcbiAgfVxuXG4gIGNvbnN0IHJlc29sdmVkID0gcmVzb2x2ZVdpdGhFeHRlbnNpb25zKHRhcmdldFBhdGgsIGZpbGVTZXQsIGRpclNldCk7XG4gIGlmICghcmVzb2x2ZWQpIHJldHVybiB7IGV4dGVybmFsOiB0cnVlLCByZXNvbHZlZDogbnVsbCB9O1xuXG4gIHJldHVybiB7IGV4dGVybmFsOiBmYWxzZSwgcmVzb2x2ZWQgfTtcbn07XG5cbmNvbnN0IGhhc2hJZCA9ICh2YWx1ZTogc3RyaW5nKSA9PiB7XG4gIGxldCBoMSA9IDB4ZGVhZGJlZWYgXiB2YWx1ZS5sZW5ndGg7XG4gIGxldCBoMiA9IDB4NDFjNmNlNTcgXiB2YWx1ZS5sZW5ndGg7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgdmFsdWUubGVuZ3RoOyBpICs9IDEpIHtcbiAgICBjb25zdCBjaCA9IHZhbHVlLmNoYXJDb2RlQXQoaSk7XG4gICAgaDEgPSBNYXRoLmltdWwoaDEgXiBjaCwgMjY1NDQzNTc2MSk7XG4gICAgaDIgPSBNYXRoLmltdWwoaDIgXiBjaCwgMTU5NzMzNDY3Nyk7XG4gIH1cbiAgaDEgPSBNYXRoLmltdWwoaDEgXiAoaDEgPj4+IDE2KSwgMjI0NjgyMjUwNyk7XG4gIGgyID0gTWF0aC5pbXVsKGgyIF4gKGgyID4+PiAxNiksIDIyNDY4MjI1MDcpO1xuICByZXR1cm4gYCR7KGgxID4+PiAwKS50b1N0cmluZygxNil9JHsoaDIgPj4+IDApLnRvU3RyaW5nKDE2KX1gO1xufTtcblxuZXhwb3J0IGNvbnN0IHNjYW5EaXJlY3RvcnlIYW5kbGUgPSBhc3luYyAoXG4gIG9wdGlvbnM6IEJyb3dzZXJTY2FuT3B0aW9uc1xuKTogUHJvbWlzZTxHcmFwaERhdGE+ID0+IHtcbiAgY29uc3QgeyByb290SGFuZGxlLCBtYXhGaWxlcywgaW5jbHVkZUV4dGVybmFsIH0gPSBvcHRpb25zO1xuICBjb25zdCByb290TGFiZWwgPSByb290SGFuZGxlLm5hbWUgfHwgJ1NlbGVjdGVkIGZvbGRlcic7XG5cbiAgY29uc3Qgbm9kZXMgPSBuZXcgTWFwPHN0cmluZywgR3JhcGhOb2RlPigpO1xuICBjb25zdCBlZGdlczogR3JhcGhFZGdlW10gPSBbXTtcbiAgY29uc3QgZWRnZUtleXMgPSBuZXcgU2V0PHN0cmluZz4oKTtcbiAgY29uc3QgaWdub3JlZE5vZGVzOiBHcmFwaE5vZGVbXSA9IFtdO1xuICBjb25zdCBmaWxlSGFuZGxlcyA9IG5ldyBNYXA8c3RyaW5nLCBGaWxlU3lzdGVtRmlsZUhhbmRsZT4oKTtcbiAgY29uc3QgZGlyU2V0ID0gbmV3IFNldDxzdHJpbmc+KFsnJ10pO1xuXG4gIGxldCB0b3RhbEZpbGVzID0gMDtcbiAgbGV0IGlnbm9yZWRDb3VudCA9IDA7XG4gIGxldCBleHRlcm5hbENvdW50ID0gMDtcblxuICBjb25zdCB3YWxrID0gYXN5bmMgKFxuICAgIGRpckhhbmRsZTogRmlsZVN5c3RlbURpcmVjdG9yeUhhbmRsZSxcbiAgICByZWxEaXI6IHN0cmluZyxcbiAgICBwYXR0ZXJuczogc3RyaW5nW11cbiAgKSA9PiB7XG4gICAgZGlyU2V0LmFkZChyZWxEaXIpO1xuXG4gICAgY29uc3QgZ2l0aWdub3JlSGFuZGxlID0gYXdhaXQgZGlySGFuZGxlXG4gICAgICAuZ2V0RmlsZUhhbmRsZSgnLmdpdGlnbm9yZScpXG4gICAgICAuY2F0Y2goKCkgPT4gbnVsbCk7XG4gICAgbGV0IGNvbWJpbmVkUGF0dGVybnMgPSBwYXR0ZXJucztcblxuICAgIGlmIChnaXRpZ25vcmVIYW5kbGUpIHtcbiAgICAgIGNvbnN0IGdpdGlnbm9yZUZpbGUgPSBhd2FpdCBnaXRpZ25vcmVIYW5kbGUuZ2V0RmlsZSgpLmNhdGNoKCgpID0+IG51bGwpO1xuICAgICAgY29uc3QgZ2l0aWdub3JlQ29udGVudCA9IGF3YWl0IGdpdGlnbm9yZUZpbGU/LnRleHQoKTtcbiAgICAgIGlmIChnaXRpZ25vcmVDb250ZW50KSB7XG4gICAgICAgIGNvbnN0IGV4dHJhUGF0dGVybnMgPSBnaXRpZ25vcmVDb250ZW50XG4gICAgICAgICAgLnNwbGl0KC9cXHI/XFxuLylcbiAgICAgICAgICAubWFwKChsaW5lKSA9PiBub3JtYWxpemVHaXRpZ25vcmVQYXR0ZXJuKHJlbERpciwgbGluZSkpXG4gICAgICAgICAgLmZpbHRlcigodmFsdWUpOiB2YWx1ZSBpcyBzdHJpbmcgPT4gQm9vbGVhbih2YWx1ZSkpO1xuICAgICAgICBjb21iaW5lZFBhdHRlcm5zID0gcGF0dGVybnMuY29uY2F0KGV4dHJhUGF0dGVybnMpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGNvbnN0IGlnID0gaWdub3JlKCkuYWRkKGNvbWJpbmVkUGF0dGVybnMpO1xuXG4gICAgZm9yIGF3YWl0IChjb25zdCBbbmFtZSwgaGFuZGxlXSBvZiBkaXJIYW5kbGUuZW50cmllcygpKSB7XG4gICAgICBjb25zdCByZWxQYXRoID0gcmVsRGlyID8gYCR7cmVsRGlyfS8ke25hbWV9YCA6IG5hbWU7XG4gICAgICBpZiAoIXJlbFBhdGgpIGNvbnRpbnVlO1xuXG4gICAgICBpZiAoaWcuaWdub3JlcyhyZWxQYXRoKSkge1xuICAgICAgICBpZ25vcmVkQ291bnQgKz0gMTtcbiAgICAgICAgaWYgKGhhbmRsZS5raW5kID09PSAnZmlsZScgJiYgU1VQUE9SVEVEX0VYVEVOU0lPTlMuaGFzKHBvc2l4RXh0bmFtZShyZWxQYXRoKSkpIHtcbiAgICAgICAgICBpZ25vcmVkTm9kZXMucHVzaCh7XG4gICAgICAgICAgICBpZDogcmVsUGF0aCxcbiAgICAgICAgICAgIHBhdGg6IHJlbFBhdGgsXG4gICAgICAgICAgICBsYWJlbDogcG9zaXhCYXNlbmFtZShyZWxQYXRoKSxcbiAgICAgICAgICAgIHR5cGU6IG5vZGVUeXBlRnJvbVBhdGgocmVsUGF0aCksXG4gICAgICAgICAgICBpZ25vcmVkOiB0cnVlXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIGlmIChoYW5kbGUua2luZCA9PT0gJ2RpcmVjdG9yeScpIHtcbiAgICAgICAgYXdhaXQgd2FsayhoYW5kbGUsIHJlbFBhdGgsIGNvbWJpbmVkUGF0dGVybnMpO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgdG90YWxGaWxlcyArPSAxO1xuICAgICAgaWYgKHRvdGFsRmlsZXMgPiBtYXhGaWxlcykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgYEZpbGUgbGltaXQgZXhjZWVkZWQgKCR7bWF4RmlsZXN9KS4gQWRqdXN0IHRoZSBtYXggZmlsZXMgc2V0dGluZyB0byBjb250aW51ZS5gXG4gICAgICAgICk7XG4gICAgICB9XG5cbiAgICAgIGlmICghU1VQUE9SVEVEX0VYVEVOU0lPTlMuaGFzKHBvc2l4RXh0bmFtZShyZWxQYXRoKSkpIGNvbnRpbnVlO1xuXG4gICAgICBub2Rlcy5zZXQocmVsUGF0aCwge1xuICAgICAgICBpZDogcmVsUGF0aCxcbiAgICAgICAgcGF0aDogcmVsUGF0aCxcbiAgICAgICAgbGFiZWw6IHBvc2l4QmFzZW5hbWUocmVsUGF0aCksXG4gICAgICAgIHR5cGU6IG5vZGVUeXBlRnJvbVBhdGgocmVsUGF0aClcbiAgICAgIH0pO1xuXG4gICAgICBmaWxlSGFuZGxlcy5zZXQocmVsUGF0aCwgaGFuZGxlKTtcbiAgICB9XG4gIH07XG5cbiAgYXdhaXQgd2Fsayhyb290SGFuZGxlLCAnJywgQUxXQVlTX0lHTk9SRSk7XG5cbiAgZm9yIChjb25zdCBpZ25vcmVkTm9kZSBvZiBpZ25vcmVkTm9kZXMpIHtcbiAgICBub2Rlcy5zZXQoaWdub3JlZE5vZGUuaWQsIGlnbm9yZWROb2RlKTtcbiAgfVxuXG4gIGNvbnN0IGZpbGVTZXQgPSBuZXcgU2V0KGZpbGVIYW5kbGVzLmtleXMoKSk7XG5cbiAgZm9yIChjb25zdCBbcmVsUGF0aCwgaGFuZGxlXSBvZiBmaWxlSGFuZGxlcy5lbnRyaWVzKCkpIHtcbiAgICBjb25zdCBmaWxlID0gYXdhaXQgaGFuZGxlLmdldEZpbGUoKS5jYXRjaCgoKSA9PiBudWxsKTtcbiAgICBjb25zdCBjb2RlID0gYXdhaXQgZmlsZT8udGV4dCgpO1xuICAgIGlmICghY29kZSkgY29udGludWU7XG5cbiAgICBjb25zdCBkZXBlbmRlbmNpZXMgPSBleHRyYWN0RGVwZW5kZW5jaWVzKHJlbFBhdGgsIGNvZGUpO1xuXG4gICAgZm9yIChjb25zdCBkZXAgb2YgZGVwZW5kZW5jaWVzKSB7XG4gICAgICBjb25zdCByZXNvbHZlZCA9IHJlc29sdmVJbXBvcnQocmVsUGF0aCwgZGVwLnNwZWNpZmllciwgZmlsZVNldCwgZGlyU2V0KTtcbiAgICAgIGlmICghcmVzb2x2ZWQpIGNvbnRpbnVlO1xuXG4gICAgICBpZiAocmVzb2x2ZWQuZXh0ZXJuYWwpIHtcbiAgICAgICAgZXh0ZXJuYWxDb3VudCArPSAxO1xuICAgICAgICBpZiAoIWluY2x1ZGVFeHRlcm5hbCkgY29udGludWU7XG5cbiAgICAgICAgaWYgKCFub2Rlcy5oYXMoJ19fZXh0ZXJuYWxfXycpKSB7XG4gICAgICAgICAgbm9kZXMuc2V0KCdfX2V4dGVybmFsX18nLCB7XG4gICAgICAgICAgICBpZDogJ19fZXh0ZXJuYWxfXycsXG4gICAgICAgICAgICBwYXRoOiAnX19leHRlcm5hbF9fJyxcbiAgICAgICAgICAgIGxhYmVsOiAnRXh0ZXJuYWwnLFxuICAgICAgICAgICAgdHlwZTogJ2V4dGVybmFsJ1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgZWRnZUtleSA9IGAke3JlbFBhdGh9fF9fZXh0ZXJuYWxfX3xleHRlcm5hbHwke2RlcC5zcGVjaWZpZXJ9YDtcbiAgICAgICAgaWYgKGVkZ2VLZXlzLmhhcyhlZGdlS2V5KSkgY29udGludWU7XG4gICAgICAgIGVkZ2VLZXlzLmFkZChlZGdlS2V5KTtcbiAgICAgICAgZWRnZXMucHVzaCh7XG4gICAgICAgICAgaWQ6IGhhc2hJZChlZGdlS2V5KSxcbiAgICAgICAgICBzb3VyY2U6IHJlbFBhdGgsXG4gICAgICAgICAgdGFyZ2V0OiAnX19leHRlcm5hbF9fJyxcbiAgICAgICAgICB0eXBlOiAnZXh0ZXJuYWwnLFxuICAgICAgICAgIHN0YXRlbWVudDogZGVwLnN0YXRlbWVudCxcbiAgICAgICAgICBsb2M6IGRlcC5sb2NcbiAgICAgICAgfSk7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICBpZiAoIXJlc29sdmVkLnJlc29sdmVkKSBjb250aW51ZTtcblxuICAgICAgY29uc3QgdGFyZ2V0UmVsID0gcmVzb2x2ZWQucmVzb2x2ZWQ7XG4gICAgICBpZiAoIW5vZGVzLmhhcyh0YXJnZXRSZWwpKSB7XG4gICAgICAgIG5vZGVzLnNldCh0YXJnZXRSZWwsIHtcbiAgICAgICAgICBpZDogdGFyZ2V0UmVsLFxuICAgICAgICAgIHBhdGg6IHRhcmdldFJlbCxcbiAgICAgICAgICBsYWJlbDogcG9zaXhCYXNlbmFtZSh0YXJnZXRSZWwpLFxuICAgICAgICAgIHR5cGU6IG5vZGVUeXBlRnJvbVBhdGgodGFyZ2V0UmVsKVxuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgY29uc3QgdGFyZ2V0RXh0ID0gcG9zaXhFeHRuYW1lKHRhcmdldFJlbCk7XG4gICAgICBjb25zdCBlZGdlVHlwZTogRWRnZVR5cGUgPSBTVFlMRV9FWFRFTlNJT05TLmhhcyh0YXJnZXRFeHQpID8gJ3N0eWxlJyA6IGRlcC50eXBlO1xuXG4gICAgICBjb25zdCBlZGdlS2V5ID0gYCR7cmVsUGF0aH18JHt0YXJnZXRSZWx9fCR7ZWRnZVR5cGV9fCR7ZGVwLnN0YXRlbWVudCA/PyAnJ31gO1xuICAgICAgaWYgKGVkZ2VLZXlzLmhhcyhlZGdlS2V5KSkgY29udGludWU7XG4gICAgICBlZGdlS2V5cy5hZGQoZWRnZUtleSk7XG5cbiAgICAgIGVkZ2VzLnB1c2goe1xuICAgICAgICBpZDogaGFzaElkKGVkZ2VLZXkpLFxuICAgICAgICBzb3VyY2U6IHJlbFBhdGgsXG4gICAgICAgIHRhcmdldDogdGFyZ2V0UmVsLFxuICAgICAgICB0eXBlOiBlZGdlVHlwZSxcbiAgICAgICAgc3RhdGVtZW50OiBkZXAuc3RhdGVtZW50Py5zbGljZSgwLCAyMDApLFxuICAgICAgICBsb2M6IGRlcC5sb2NcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB7XG4gICAgcm9vdDogcm9vdExhYmVsLFxuICAgIG5vZGVzOiBBcnJheS5mcm9tKG5vZGVzLnZhbHVlcygpKSxcbiAgICBlZGdlcyxcbiAgICB0b3RhbEZpbGVzLFxuICAgIGlnbm9yZWRDb3VudCxcbiAgICBleHRlcm5hbENvdW50XG4gIH07XG59O1xuIl0sIm5hbWVzIjpbImlnbm9yZSIsInBhcnNlIiwidHJhdmVyc2UiLCJBTFdBWVNfSUdOT1JFIiwiU0NSSVBUX0VYVEVOU0lPTlMiLCJTZXQiLCJTVFlMRV9FWFRFTlNJT05TIiwiU1VQUE9SVEVEX0VYVEVOU0lPTlMiLCJJTVBPUlRfRVhURU5TSU9OUyIsIlJPVVRFX1JFR0VYIiwiYXBwIiwicGFnZXMiLCJwb3NpeEpvaW4iLCJwYXJ0cyIsImZpbHRlciIsIkJvb2xlYW4iLCJqb2luIiwicmVwbGFjZSIsInBvc2l4RGlybmFtZSIsInZhbHVlIiwiaWR4IiwibGFzdEluZGV4T2YiLCJzbGljZSIsInBvc2l4QmFzZW5hbWUiLCJwb3NpeEV4dG5hbWUiLCJiYXNlIiwibm9ybWFsaXplUG9zaXhQYXRoIiwic3BsaXQiLCJzdGFjayIsImVzY2FwZWRSb290IiwicGFydCIsImxlbmd0aCIsInBvcCIsInB1c2giLCJwYXRoIiwibm9ybWFsaXplR2l0aWdub3JlUGF0dGVybiIsImRpclJlbCIsInJhd1BhdHRlcm4iLCJwYXR0ZXJuIiwidHJpbSIsInN0YXJ0c1dpdGgiLCJuZWdhdGVkIiwiYW5jaG9yZWQiLCJoYXNTbGFzaCIsImluY2x1ZGVzIiwiZW5kc1dpdGhTbGFzaCIsImVuZHNXaXRoIiwicHJlZml4ZWQiLCJub2RlVHlwZUZyb21QYXRoIiwicmVsUGF0aCIsInRlc3QiLCJiYXNlbmFtZSIsImhhcyIsImV4dHJhY3REZXBlbmRlbmNpZXMiLCJmaWxlUGF0aCIsImNvZGUiLCJkZXBlbmRlbmNpZXMiLCJhc3QiLCJzb3VyY2VUeXBlIiwicGx1Z2lucyIsIkltcG9ydERlY2xhcmF0aW9uIiwicGF0aE5vZGUiLCJub2RlIiwic291cmNlIiwic3BlY2lmaWVyIiwidHlwZSIsInN0YXRlbWVudCIsInN0YXJ0IiwiZW5kIiwibG9jIiwibGluZSIsImNvbHVtbiIsInVuZGVmaW5lZCIsIkV4cG9ydEFsbERlY2xhcmF0aW9uIiwiRXhwb3J0TmFtZWREZWNsYXJhdGlvbiIsIkNhbGxFeHByZXNzaW9uIiwiY2FsbGVlIiwiYXJnIiwiYXJndW1lbnRzIiwibmFtZSIsInJlZ2V4IiwibWF0Y2giLCJleGVjIiwicmVzb2x2ZVdpdGhFeHRlbnNpb25zIiwiYmFzZVBhdGgiLCJmaWxlU2V0IiwiZGlyU2V0IiwiZXh0IiwiaW5kZXhQYXRoIiwicmVzb2x2ZUltcG9ydCIsImZyb21GaWxlIiwiY2xlYW5TcGVjaWZpZXIiLCJ0YXJnZXRQYXRoIiwibm9ybWFsaXplZCIsImZyb21EaXIiLCJleHRlcm5hbCIsInJlc29sdmVkIiwiaGFzaElkIiwiaDEiLCJoMiIsImkiLCJjaCIsImNoYXJDb2RlQXQiLCJNYXRoIiwiaW11bCIsInRvU3RyaW5nIiwic2NhbkRpcmVjdG9yeUhhbmRsZSIsIm9wdGlvbnMiLCJyb290SGFuZGxlIiwibWF4RmlsZXMiLCJpbmNsdWRlRXh0ZXJuYWwiLCJyb290TGFiZWwiLCJub2RlcyIsIk1hcCIsImVkZ2VzIiwiZWRnZUtleXMiLCJpZ25vcmVkTm9kZXMiLCJmaWxlSGFuZGxlcyIsInRvdGFsRmlsZXMiLCJpZ25vcmVkQ291bnQiLCJleHRlcm5hbENvdW50Iiwid2FsayIsImRpckhhbmRsZSIsInJlbERpciIsInBhdHRlcm5zIiwiYWRkIiwiZ2l0aWdub3JlSGFuZGxlIiwiZ2V0RmlsZUhhbmRsZSIsImNhdGNoIiwiY29tYmluZWRQYXR0ZXJucyIsImdpdGlnbm9yZUZpbGUiLCJnZXRGaWxlIiwiZ2l0aWdub3JlQ29udGVudCIsInRleHQiLCJleHRyYVBhdHRlcm5zIiwibWFwIiwiY29uY2F0IiwiaWciLCJoYW5kbGUiLCJlbnRyaWVzIiwiaWdub3JlcyIsImtpbmQiLCJpZCIsImxhYmVsIiwiaWdub3JlZCIsIkVycm9yIiwic2V0IiwiaWdub3JlZE5vZGUiLCJrZXlzIiwiZmlsZSIsImRlcCIsImVkZ2VLZXkiLCJ0YXJnZXQiLCJ0YXJnZXRSZWwiLCJ0YXJnZXRFeHQiLCJlZGdlVHlwZSIsInJvb3QiLCJBcnJheSIsImZyb20iLCJ2YWx1ZXMiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./lib/browser-scan.ts\n"));

/***/ })

});