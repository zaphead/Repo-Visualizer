"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/@babel";
exports.ids = ["vendor-chunks/@babel"];
exports.modules = {

/***/ "(ssr)/./node_modules/@babel/code-frame/lib/index.js":
/*!*****************************************************!*\
  !*** ./node_modules/@babel/code-frame/lib/index.js ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\n\nvar picocolors = __webpack_require__(/*! picocolors */ \"(ssr)/./node_modules/picocolors/picocolors.js\");\nvar jsTokens = __webpack_require__(/*! js-tokens */ \"(ssr)/./node_modules/js-tokens/index.js\");\nvar helperValidatorIdentifier = __webpack_require__(/*! @babel/helper-validator-identifier */ \"(ssr)/./node_modules/@babel/helper-validator-identifier/lib/index.js\");\n\nfunction isColorSupported() {\n  return (typeof process === \"object\" && (process.env.FORCE_COLOR === \"0\" || process.env.FORCE_COLOR === \"false\") ? false : picocolors.isColorSupported\n  );\n}\nconst compose = (f, g) => v => f(g(v));\nfunction buildDefs(colors) {\n  return {\n    keyword: colors.cyan,\n    capitalized: colors.yellow,\n    jsxIdentifier: colors.yellow,\n    punctuator: colors.yellow,\n    number: colors.magenta,\n    string: colors.green,\n    regex: colors.magenta,\n    comment: colors.gray,\n    invalid: compose(compose(colors.white, colors.bgRed), colors.bold),\n    gutter: colors.gray,\n    marker: compose(colors.red, colors.bold),\n    message: compose(colors.red, colors.bold),\n    reset: colors.reset\n  };\n}\nconst defsOn = buildDefs(picocolors.createColors(true));\nconst defsOff = buildDefs(picocolors.createColors(false));\nfunction getDefs(enabled) {\n  return enabled ? defsOn : defsOff;\n}\n\nconst sometimesKeywords = new Set([\"as\", \"async\", \"from\", \"get\", \"of\", \"set\"]);\nconst NEWLINE$1 = /\\r\\n|[\\n\\r\\u2028\\u2029]/;\nconst BRACKET = /^[()[\\]{}]$/;\nlet tokenize;\nconst JSX_TAG = /^[a-z][\\w-]*$/i;\nconst getTokenType = function (token, offset, text) {\n  if (token.type === \"name\") {\n    const tokenValue = token.value;\n    if (helperValidatorIdentifier.isKeyword(tokenValue) || helperValidatorIdentifier.isStrictReservedWord(tokenValue, true) || sometimesKeywords.has(tokenValue)) {\n      return \"keyword\";\n    }\n    if (JSX_TAG.test(tokenValue) && (text[offset - 1] === \"<\" || text.slice(offset - 2, offset) === \"</\")) {\n      return \"jsxIdentifier\";\n    }\n    const firstChar = String.fromCodePoint(tokenValue.codePointAt(0));\n    if (firstChar !== firstChar.toLowerCase()) {\n      return \"capitalized\";\n    }\n  }\n  if (token.type === \"punctuator\" && BRACKET.test(token.value)) {\n    return \"bracket\";\n  }\n  if (token.type === \"invalid\" && (token.value === \"@\" || token.value === \"#\")) {\n    return \"punctuator\";\n  }\n  return token.type;\n};\ntokenize = function* (text) {\n  let match;\n  while (match = jsTokens.default.exec(text)) {\n    const token = jsTokens.matchToToken(match);\n    yield {\n      type: getTokenType(token, match.index, text),\n      value: token.value\n    };\n  }\n};\nfunction highlight(text) {\n  if (text === \"\") return \"\";\n  const defs = getDefs(true);\n  let highlighted = \"\";\n  for (const {\n    type,\n    value\n  } of tokenize(text)) {\n    if (type in defs) {\n      highlighted += value.split(NEWLINE$1).map(str => defs[type](str)).join(\"\\n\");\n    } else {\n      highlighted += value;\n    }\n  }\n  return highlighted;\n}\n\nlet deprecationWarningShown = false;\nconst NEWLINE = /\\r\\n|[\\n\\r\\u2028\\u2029]/;\nfunction getMarkerLines(loc, source, opts) {\n  const startLoc = Object.assign({\n    column: 0,\n    line: -1\n  }, loc.start);\n  const endLoc = Object.assign({}, startLoc, loc.end);\n  const {\n    linesAbove = 2,\n    linesBelow = 3\n  } = opts || {};\n  const startLine = startLoc.line;\n  const startColumn = startLoc.column;\n  const endLine = endLoc.line;\n  const endColumn = endLoc.column;\n  let start = Math.max(startLine - (linesAbove + 1), 0);\n  let end = Math.min(source.length, endLine + linesBelow);\n  if (startLine === -1) {\n    start = 0;\n  }\n  if (endLine === -1) {\n    end = source.length;\n  }\n  const lineDiff = endLine - startLine;\n  const markerLines = {};\n  if (lineDiff) {\n    for (let i = 0; i <= lineDiff; i++) {\n      const lineNumber = i + startLine;\n      if (!startColumn) {\n        markerLines[lineNumber] = true;\n      } else if (i === 0) {\n        const sourceLength = source[lineNumber - 1].length;\n        markerLines[lineNumber] = [startColumn, sourceLength - startColumn + 1];\n      } else if (i === lineDiff) {\n        markerLines[lineNumber] = [0, endColumn];\n      } else {\n        const sourceLength = source[lineNumber - i].length;\n        markerLines[lineNumber] = [0, sourceLength];\n      }\n    }\n  } else {\n    if (startColumn === endColumn) {\n      if (startColumn) {\n        markerLines[startLine] = [startColumn, 0];\n      } else {\n        markerLines[startLine] = true;\n      }\n    } else {\n      markerLines[startLine] = [startColumn, endColumn - startColumn];\n    }\n  }\n  return {\n    start,\n    end,\n    markerLines\n  };\n}\nfunction codeFrameColumns(rawLines, loc, opts = {}) {\n  const shouldHighlight = opts.forceColor || isColorSupported() && opts.highlightCode;\n  const defs = getDefs(shouldHighlight);\n  const lines = rawLines.split(NEWLINE);\n  const {\n    start,\n    end,\n    markerLines\n  } = getMarkerLines(loc, lines, opts);\n  const hasColumns = loc.start && typeof loc.start.column === \"number\";\n  const numberMaxWidth = String(end).length;\n  const highlightedLines = shouldHighlight ? highlight(rawLines) : rawLines;\n  let frame = highlightedLines.split(NEWLINE, end).slice(start, end).map((line, index) => {\n    const number = start + 1 + index;\n    const paddedNumber = ` ${number}`.slice(-numberMaxWidth);\n    const gutter = ` ${paddedNumber} |`;\n    const hasMarker = markerLines[number];\n    const lastMarkerLine = !markerLines[number + 1];\n    if (hasMarker) {\n      let markerLine = \"\";\n      if (Array.isArray(hasMarker)) {\n        const markerSpacing = line.slice(0, Math.max(hasMarker[0] - 1, 0)).replace(/[^\\t]/g, \" \");\n        const numberOfMarkers = hasMarker[1] || 1;\n        markerLine = [\"\\n \", defs.gutter(gutter.replace(/\\d/g, \" \")), \" \", markerSpacing, defs.marker(\"^\").repeat(numberOfMarkers)].join(\"\");\n        if (lastMarkerLine && opts.message) {\n          markerLine += \" \" + defs.message(opts.message);\n        }\n      }\n      return [defs.marker(\">\"), defs.gutter(gutter), line.length > 0 ? ` ${line}` : \"\", markerLine].join(\"\");\n    } else {\n      return ` ${defs.gutter(gutter)}${line.length > 0 ? ` ${line}` : \"\"}`;\n    }\n  }).join(\"\\n\");\n  if (opts.message && !hasColumns) {\n    frame = `${\" \".repeat(numberMaxWidth + 1)}${opts.message}\\n${frame}`;\n  }\n  if (shouldHighlight) {\n    return defs.reset(frame);\n  } else {\n    return frame;\n  }\n}\nfunction index (rawLines, lineNumber, colNumber, opts = {}) {\n  if (!deprecationWarningShown) {\n    deprecationWarningShown = true;\n    const message = \"Passing lineNumber and colNumber is deprecated to @babel/code-frame. Please use `codeFrameColumns`.\";\n    if (process.emitWarning) {\n      process.emitWarning(message, \"DeprecationWarning\");\n    } else {\n      const deprecationError = new Error(message);\n      deprecationError.name = \"DeprecationWarning\";\n      console.warn(new Error(message));\n    }\n  }\n  colNumber = Math.max(colNumber, 0);\n  const location = {\n    start: {\n      column: colNumber,\n      line: lineNumber\n    }\n  };\n  return codeFrameColumns(rawLines, location, opts);\n}\n\nexports.codeFrameColumns = codeFrameColumns;\nexports[\"default\"] = index;\nexports.highlight = highlight;\n//# sourceMappingURL=index.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGJhYmVsL2NvZGUtZnJhbWUvbGliL2luZGV4LmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViLDhDQUE2QyxFQUFFLGFBQWEsRUFBQzs7QUFFN0QsaUJBQWlCLG1CQUFPLENBQUMsaUVBQVk7QUFDckMsZUFBZSxtQkFBTyxDQUFDLDBEQUFXO0FBQ2xDLGdDQUFnQyxtQkFBTyxDQUFDLGdIQUFvQzs7QUFFNUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSwwQkFBMEI7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILGlDQUFpQztBQUNqQztBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGVBQWU7QUFDbkM7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0RBQWtEO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsT0FBTztBQUNwQyx1QkFBdUIsY0FBYztBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyRUFBMkUsS0FBSztBQUNoRixNQUFNO0FBQ04saUJBQWlCLG9CQUFvQixFQUFFLHNCQUFzQixLQUFLLE9BQU87QUFDekU7QUFDQSxHQUFHO0FBQ0g7QUFDQSxlQUFlLCtCQUErQixFQUFFLGFBQWEsSUFBSSxNQUFNO0FBQ3ZFO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQSwwREFBMEQ7QUFDMUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHdCQUF3QjtBQUN4QixrQkFBZTtBQUNmLGlCQUFpQjtBQUNqQiIsInNvdXJjZXMiOlsid2VicGFjazovL3JlcG8tdmlzdWFsaXplci8uL25vZGVfbW9kdWxlcy9AYmFiZWwvY29kZS1mcmFtZS9saWIvaW5kZXguanM/YTdmYiJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG5cbnZhciBwaWNvY29sb3JzID0gcmVxdWlyZSgncGljb2NvbG9ycycpO1xudmFyIGpzVG9rZW5zID0gcmVxdWlyZSgnanMtdG9rZW5zJyk7XG52YXIgaGVscGVyVmFsaWRhdG9ySWRlbnRpZmllciA9IHJlcXVpcmUoJ0BiYWJlbC9oZWxwZXItdmFsaWRhdG9yLWlkZW50aWZpZXInKTtcblxuZnVuY3Rpb24gaXNDb2xvclN1cHBvcnRlZCgpIHtcbiAgcmV0dXJuICh0eXBlb2YgcHJvY2VzcyA9PT0gXCJvYmplY3RcIiAmJiAocHJvY2Vzcy5lbnYuRk9SQ0VfQ09MT1IgPT09IFwiMFwiIHx8IHByb2Nlc3MuZW52LkZPUkNFX0NPTE9SID09PSBcImZhbHNlXCIpID8gZmFsc2UgOiBwaWNvY29sb3JzLmlzQ29sb3JTdXBwb3J0ZWRcbiAgKTtcbn1cbmNvbnN0IGNvbXBvc2UgPSAoZiwgZykgPT4gdiA9PiBmKGcodikpO1xuZnVuY3Rpb24gYnVpbGREZWZzKGNvbG9ycykge1xuICByZXR1cm4ge1xuICAgIGtleXdvcmQ6IGNvbG9ycy5jeWFuLFxuICAgIGNhcGl0YWxpemVkOiBjb2xvcnMueWVsbG93LFxuICAgIGpzeElkZW50aWZpZXI6IGNvbG9ycy55ZWxsb3csXG4gICAgcHVuY3R1YXRvcjogY29sb3JzLnllbGxvdyxcbiAgICBudW1iZXI6IGNvbG9ycy5tYWdlbnRhLFxuICAgIHN0cmluZzogY29sb3JzLmdyZWVuLFxuICAgIHJlZ2V4OiBjb2xvcnMubWFnZW50YSxcbiAgICBjb21tZW50OiBjb2xvcnMuZ3JheSxcbiAgICBpbnZhbGlkOiBjb21wb3NlKGNvbXBvc2UoY29sb3JzLndoaXRlLCBjb2xvcnMuYmdSZWQpLCBjb2xvcnMuYm9sZCksXG4gICAgZ3V0dGVyOiBjb2xvcnMuZ3JheSxcbiAgICBtYXJrZXI6IGNvbXBvc2UoY29sb3JzLnJlZCwgY29sb3JzLmJvbGQpLFxuICAgIG1lc3NhZ2U6IGNvbXBvc2UoY29sb3JzLnJlZCwgY29sb3JzLmJvbGQpLFxuICAgIHJlc2V0OiBjb2xvcnMucmVzZXRcbiAgfTtcbn1cbmNvbnN0IGRlZnNPbiA9IGJ1aWxkRGVmcyhwaWNvY29sb3JzLmNyZWF0ZUNvbG9ycyh0cnVlKSk7XG5jb25zdCBkZWZzT2ZmID0gYnVpbGREZWZzKHBpY29jb2xvcnMuY3JlYXRlQ29sb3JzKGZhbHNlKSk7XG5mdW5jdGlvbiBnZXREZWZzKGVuYWJsZWQpIHtcbiAgcmV0dXJuIGVuYWJsZWQgPyBkZWZzT24gOiBkZWZzT2ZmO1xufVxuXG5jb25zdCBzb21ldGltZXNLZXl3b3JkcyA9IG5ldyBTZXQoW1wiYXNcIiwgXCJhc3luY1wiLCBcImZyb21cIiwgXCJnZXRcIiwgXCJvZlwiLCBcInNldFwiXSk7XG5jb25zdCBORVdMSU5FJDEgPSAvXFxyXFxufFtcXG5cXHJcXHUyMDI4XFx1MjAyOV0vO1xuY29uc3QgQlJBQ0tFVCA9IC9eWygpW1xcXXt9XSQvO1xubGV0IHRva2VuaXplO1xuY29uc3QgSlNYX1RBRyA9IC9eW2Etel1bXFx3LV0qJC9pO1xuY29uc3QgZ2V0VG9rZW5UeXBlID0gZnVuY3Rpb24gKHRva2VuLCBvZmZzZXQsIHRleHQpIHtcbiAgaWYgKHRva2VuLnR5cGUgPT09IFwibmFtZVwiKSB7XG4gICAgY29uc3QgdG9rZW5WYWx1ZSA9IHRva2VuLnZhbHVlO1xuICAgIGlmIChoZWxwZXJWYWxpZGF0b3JJZGVudGlmaWVyLmlzS2V5d29yZCh0b2tlblZhbHVlKSB8fCBoZWxwZXJWYWxpZGF0b3JJZGVudGlmaWVyLmlzU3RyaWN0UmVzZXJ2ZWRXb3JkKHRva2VuVmFsdWUsIHRydWUpIHx8IHNvbWV0aW1lc0tleXdvcmRzLmhhcyh0b2tlblZhbHVlKSkge1xuICAgICAgcmV0dXJuIFwia2V5d29yZFwiO1xuICAgIH1cbiAgICBpZiAoSlNYX1RBRy50ZXN0KHRva2VuVmFsdWUpICYmICh0ZXh0W29mZnNldCAtIDFdID09PSBcIjxcIiB8fCB0ZXh0LnNsaWNlKG9mZnNldCAtIDIsIG9mZnNldCkgPT09IFwiPC9cIikpIHtcbiAgICAgIHJldHVybiBcImpzeElkZW50aWZpZXJcIjtcbiAgICB9XG4gICAgY29uc3QgZmlyc3RDaGFyID0gU3RyaW5nLmZyb21Db2RlUG9pbnQodG9rZW5WYWx1ZS5jb2RlUG9pbnRBdCgwKSk7XG4gICAgaWYgKGZpcnN0Q2hhciAhPT0gZmlyc3RDaGFyLnRvTG93ZXJDYXNlKCkpIHtcbiAgICAgIHJldHVybiBcImNhcGl0YWxpemVkXCI7XG4gICAgfVxuICB9XG4gIGlmICh0b2tlbi50eXBlID09PSBcInB1bmN0dWF0b3JcIiAmJiBCUkFDS0VULnRlc3QodG9rZW4udmFsdWUpKSB7XG4gICAgcmV0dXJuIFwiYnJhY2tldFwiO1xuICB9XG4gIGlmICh0b2tlbi50eXBlID09PSBcImludmFsaWRcIiAmJiAodG9rZW4udmFsdWUgPT09IFwiQFwiIHx8IHRva2VuLnZhbHVlID09PSBcIiNcIikpIHtcbiAgICByZXR1cm4gXCJwdW5jdHVhdG9yXCI7XG4gIH1cbiAgcmV0dXJuIHRva2VuLnR5cGU7XG59O1xudG9rZW5pemUgPSBmdW5jdGlvbiogKHRleHQpIHtcbiAgbGV0IG1hdGNoO1xuICB3aGlsZSAobWF0Y2ggPSBqc1Rva2Vucy5kZWZhdWx0LmV4ZWModGV4dCkpIHtcbiAgICBjb25zdCB0b2tlbiA9IGpzVG9rZW5zLm1hdGNoVG9Ub2tlbihtYXRjaCk7XG4gICAgeWllbGQge1xuICAgICAgdHlwZTogZ2V0VG9rZW5UeXBlKHRva2VuLCBtYXRjaC5pbmRleCwgdGV4dCksXG4gICAgICB2YWx1ZTogdG9rZW4udmFsdWVcbiAgICB9O1xuICB9XG59O1xuZnVuY3Rpb24gaGlnaGxpZ2h0KHRleHQpIHtcbiAgaWYgKHRleHQgPT09IFwiXCIpIHJldHVybiBcIlwiO1xuICBjb25zdCBkZWZzID0gZ2V0RGVmcyh0cnVlKTtcbiAgbGV0IGhpZ2hsaWdodGVkID0gXCJcIjtcbiAgZm9yIChjb25zdCB7XG4gICAgdHlwZSxcbiAgICB2YWx1ZVxuICB9IG9mIHRva2VuaXplKHRleHQpKSB7XG4gICAgaWYgKHR5cGUgaW4gZGVmcykge1xuICAgICAgaGlnaGxpZ2h0ZWQgKz0gdmFsdWUuc3BsaXQoTkVXTElORSQxKS5tYXAoc3RyID0+IGRlZnNbdHlwZV0oc3RyKSkuam9pbihcIlxcblwiKTtcbiAgICB9IGVsc2Uge1xuICAgICAgaGlnaGxpZ2h0ZWQgKz0gdmFsdWU7XG4gICAgfVxuICB9XG4gIHJldHVybiBoaWdobGlnaHRlZDtcbn1cblxubGV0IGRlcHJlY2F0aW9uV2FybmluZ1Nob3duID0gZmFsc2U7XG5jb25zdCBORVdMSU5FID0gL1xcclxcbnxbXFxuXFxyXFx1MjAyOFxcdTIwMjldLztcbmZ1bmN0aW9uIGdldE1hcmtlckxpbmVzKGxvYywgc291cmNlLCBvcHRzKSB7XG4gIGNvbnN0IHN0YXJ0TG9jID0gT2JqZWN0LmFzc2lnbih7XG4gICAgY29sdW1uOiAwLFxuICAgIGxpbmU6IC0xXG4gIH0sIGxvYy5zdGFydCk7XG4gIGNvbnN0IGVuZExvYyA9IE9iamVjdC5hc3NpZ24oe30sIHN0YXJ0TG9jLCBsb2MuZW5kKTtcbiAgY29uc3Qge1xuICAgIGxpbmVzQWJvdmUgPSAyLFxuICAgIGxpbmVzQmVsb3cgPSAzXG4gIH0gPSBvcHRzIHx8IHt9O1xuICBjb25zdCBzdGFydExpbmUgPSBzdGFydExvYy5saW5lO1xuICBjb25zdCBzdGFydENvbHVtbiA9IHN0YXJ0TG9jLmNvbHVtbjtcbiAgY29uc3QgZW5kTGluZSA9IGVuZExvYy5saW5lO1xuICBjb25zdCBlbmRDb2x1bW4gPSBlbmRMb2MuY29sdW1uO1xuICBsZXQgc3RhcnQgPSBNYXRoLm1heChzdGFydExpbmUgLSAobGluZXNBYm92ZSArIDEpLCAwKTtcbiAgbGV0IGVuZCA9IE1hdGgubWluKHNvdXJjZS5sZW5ndGgsIGVuZExpbmUgKyBsaW5lc0JlbG93KTtcbiAgaWYgKHN0YXJ0TGluZSA9PT0gLTEpIHtcbiAgICBzdGFydCA9IDA7XG4gIH1cbiAgaWYgKGVuZExpbmUgPT09IC0xKSB7XG4gICAgZW5kID0gc291cmNlLmxlbmd0aDtcbiAgfVxuICBjb25zdCBsaW5lRGlmZiA9IGVuZExpbmUgLSBzdGFydExpbmU7XG4gIGNvbnN0IG1hcmtlckxpbmVzID0ge307XG4gIGlmIChsaW5lRGlmZikge1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDw9IGxpbmVEaWZmOyBpKyspIHtcbiAgICAgIGNvbnN0IGxpbmVOdW1iZXIgPSBpICsgc3RhcnRMaW5lO1xuICAgICAgaWYgKCFzdGFydENvbHVtbikge1xuICAgICAgICBtYXJrZXJMaW5lc1tsaW5lTnVtYmVyXSA9IHRydWU7XG4gICAgICB9IGVsc2UgaWYgKGkgPT09IDApIHtcbiAgICAgICAgY29uc3Qgc291cmNlTGVuZ3RoID0gc291cmNlW2xpbmVOdW1iZXIgLSAxXS5sZW5ndGg7XG4gICAgICAgIG1hcmtlckxpbmVzW2xpbmVOdW1iZXJdID0gW3N0YXJ0Q29sdW1uLCBzb3VyY2VMZW5ndGggLSBzdGFydENvbHVtbiArIDFdO1xuICAgICAgfSBlbHNlIGlmIChpID09PSBsaW5lRGlmZikge1xuICAgICAgICBtYXJrZXJMaW5lc1tsaW5lTnVtYmVyXSA9IFswLCBlbmRDb2x1bW5dO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc3Qgc291cmNlTGVuZ3RoID0gc291cmNlW2xpbmVOdW1iZXIgLSBpXS5sZW5ndGg7XG4gICAgICAgIG1hcmtlckxpbmVzW2xpbmVOdW1iZXJdID0gWzAsIHNvdXJjZUxlbmd0aF07XG4gICAgICB9XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGlmIChzdGFydENvbHVtbiA9PT0gZW5kQ29sdW1uKSB7XG4gICAgICBpZiAoc3RhcnRDb2x1bW4pIHtcbiAgICAgICAgbWFya2VyTGluZXNbc3RhcnRMaW5lXSA9IFtzdGFydENvbHVtbiwgMF07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBtYXJrZXJMaW5lc1tzdGFydExpbmVdID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgbWFya2VyTGluZXNbc3RhcnRMaW5lXSA9IFtzdGFydENvbHVtbiwgZW5kQ29sdW1uIC0gc3RhcnRDb2x1bW5dO1xuICAgIH1cbiAgfVxuICByZXR1cm4ge1xuICAgIHN0YXJ0LFxuICAgIGVuZCxcbiAgICBtYXJrZXJMaW5lc1xuICB9O1xufVxuZnVuY3Rpb24gY29kZUZyYW1lQ29sdW1ucyhyYXdMaW5lcywgbG9jLCBvcHRzID0ge30pIHtcbiAgY29uc3Qgc2hvdWxkSGlnaGxpZ2h0ID0gb3B0cy5mb3JjZUNvbG9yIHx8IGlzQ29sb3JTdXBwb3J0ZWQoKSAmJiBvcHRzLmhpZ2hsaWdodENvZGU7XG4gIGNvbnN0IGRlZnMgPSBnZXREZWZzKHNob3VsZEhpZ2hsaWdodCk7XG4gIGNvbnN0IGxpbmVzID0gcmF3TGluZXMuc3BsaXQoTkVXTElORSk7XG4gIGNvbnN0IHtcbiAgICBzdGFydCxcbiAgICBlbmQsXG4gICAgbWFya2VyTGluZXNcbiAgfSA9IGdldE1hcmtlckxpbmVzKGxvYywgbGluZXMsIG9wdHMpO1xuICBjb25zdCBoYXNDb2x1bW5zID0gbG9jLnN0YXJ0ICYmIHR5cGVvZiBsb2Muc3RhcnQuY29sdW1uID09PSBcIm51bWJlclwiO1xuICBjb25zdCBudW1iZXJNYXhXaWR0aCA9IFN0cmluZyhlbmQpLmxlbmd0aDtcbiAgY29uc3QgaGlnaGxpZ2h0ZWRMaW5lcyA9IHNob3VsZEhpZ2hsaWdodCA/IGhpZ2hsaWdodChyYXdMaW5lcykgOiByYXdMaW5lcztcbiAgbGV0IGZyYW1lID0gaGlnaGxpZ2h0ZWRMaW5lcy5zcGxpdChORVdMSU5FLCBlbmQpLnNsaWNlKHN0YXJ0LCBlbmQpLm1hcCgobGluZSwgaW5kZXgpID0+IHtcbiAgICBjb25zdCBudW1iZXIgPSBzdGFydCArIDEgKyBpbmRleDtcbiAgICBjb25zdCBwYWRkZWROdW1iZXIgPSBgICR7bnVtYmVyfWAuc2xpY2UoLW51bWJlck1heFdpZHRoKTtcbiAgICBjb25zdCBndXR0ZXIgPSBgICR7cGFkZGVkTnVtYmVyfSB8YDtcbiAgICBjb25zdCBoYXNNYXJrZXIgPSBtYXJrZXJMaW5lc1tudW1iZXJdO1xuICAgIGNvbnN0IGxhc3RNYXJrZXJMaW5lID0gIW1hcmtlckxpbmVzW251bWJlciArIDFdO1xuICAgIGlmIChoYXNNYXJrZXIpIHtcbiAgICAgIGxldCBtYXJrZXJMaW5lID0gXCJcIjtcbiAgICAgIGlmIChBcnJheS5pc0FycmF5KGhhc01hcmtlcikpIHtcbiAgICAgICAgY29uc3QgbWFya2VyU3BhY2luZyA9IGxpbmUuc2xpY2UoMCwgTWF0aC5tYXgoaGFzTWFya2VyWzBdIC0gMSwgMCkpLnJlcGxhY2UoL1teXFx0XS9nLCBcIiBcIik7XG4gICAgICAgIGNvbnN0IG51bWJlck9mTWFya2VycyA9IGhhc01hcmtlclsxXSB8fCAxO1xuICAgICAgICBtYXJrZXJMaW5lID0gW1wiXFxuIFwiLCBkZWZzLmd1dHRlcihndXR0ZXIucmVwbGFjZSgvXFxkL2csIFwiIFwiKSksIFwiIFwiLCBtYXJrZXJTcGFjaW5nLCBkZWZzLm1hcmtlcihcIl5cIikucmVwZWF0KG51bWJlck9mTWFya2VycyldLmpvaW4oXCJcIik7XG4gICAgICAgIGlmIChsYXN0TWFya2VyTGluZSAmJiBvcHRzLm1lc3NhZ2UpIHtcbiAgICAgICAgICBtYXJrZXJMaW5lICs9IFwiIFwiICsgZGVmcy5tZXNzYWdlKG9wdHMubWVzc2FnZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBbZGVmcy5tYXJrZXIoXCI+XCIpLCBkZWZzLmd1dHRlcihndXR0ZXIpLCBsaW5lLmxlbmd0aCA+IDAgPyBgICR7bGluZX1gIDogXCJcIiwgbWFya2VyTGluZV0uam9pbihcIlwiKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIGAgJHtkZWZzLmd1dHRlcihndXR0ZXIpfSR7bGluZS5sZW5ndGggPiAwID8gYCAke2xpbmV9YCA6IFwiXCJ9YDtcbiAgICB9XG4gIH0pLmpvaW4oXCJcXG5cIik7XG4gIGlmIChvcHRzLm1lc3NhZ2UgJiYgIWhhc0NvbHVtbnMpIHtcbiAgICBmcmFtZSA9IGAke1wiIFwiLnJlcGVhdChudW1iZXJNYXhXaWR0aCArIDEpfSR7b3B0cy5tZXNzYWdlfVxcbiR7ZnJhbWV9YDtcbiAgfVxuICBpZiAoc2hvdWxkSGlnaGxpZ2h0KSB7XG4gICAgcmV0dXJuIGRlZnMucmVzZXQoZnJhbWUpO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBmcmFtZTtcbiAgfVxufVxuZnVuY3Rpb24gaW5kZXggKHJhd0xpbmVzLCBsaW5lTnVtYmVyLCBjb2xOdW1iZXIsIG9wdHMgPSB7fSkge1xuICBpZiAoIWRlcHJlY2F0aW9uV2FybmluZ1Nob3duKSB7XG4gICAgZGVwcmVjYXRpb25XYXJuaW5nU2hvd24gPSB0cnVlO1xuICAgIGNvbnN0IG1lc3NhZ2UgPSBcIlBhc3NpbmcgbGluZU51bWJlciBhbmQgY29sTnVtYmVyIGlzIGRlcHJlY2F0ZWQgdG8gQGJhYmVsL2NvZGUtZnJhbWUuIFBsZWFzZSB1c2UgYGNvZGVGcmFtZUNvbHVtbnNgLlwiO1xuICAgIGlmIChwcm9jZXNzLmVtaXRXYXJuaW5nKSB7XG4gICAgICBwcm9jZXNzLmVtaXRXYXJuaW5nKG1lc3NhZ2UsIFwiRGVwcmVjYXRpb25XYXJuaW5nXCIpO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBkZXByZWNhdGlvbkVycm9yID0gbmV3IEVycm9yKG1lc3NhZ2UpO1xuICAgICAgZGVwcmVjYXRpb25FcnJvci5uYW1lID0gXCJEZXByZWNhdGlvbldhcm5pbmdcIjtcbiAgICAgIGNvbnNvbGUud2FybihuZXcgRXJyb3IobWVzc2FnZSkpO1xuICAgIH1cbiAgfVxuICBjb2xOdW1iZXIgPSBNYXRoLm1heChjb2xOdW1iZXIsIDApO1xuICBjb25zdCBsb2NhdGlvbiA9IHtcbiAgICBzdGFydDoge1xuICAgICAgY29sdW1uOiBjb2xOdW1iZXIsXG4gICAgICBsaW5lOiBsaW5lTnVtYmVyXG4gICAgfVxuICB9O1xuICByZXR1cm4gY29kZUZyYW1lQ29sdW1ucyhyYXdMaW5lcywgbG9jYXRpb24sIG9wdHMpO1xufVxuXG5leHBvcnRzLmNvZGVGcmFtZUNvbHVtbnMgPSBjb2RlRnJhbWVDb2x1bW5zO1xuZXhwb3J0cy5kZWZhdWx0ID0gaW5kZXg7XG5leHBvcnRzLmhpZ2hsaWdodCA9IGhpZ2hsaWdodDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcFxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@babel/code-frame/lib/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@babel/generator/lib/buffer.js":
/*!*****************************************************!*\
  !*** ./node_modules/@babel/generator/lib/buffer.js ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports[\"default\"] = void 0;\nclass Buffer {\n  constructor(map, indentChar) {\n    this._map = null;\n    this._buf = \"\";\n    this._str = \"\";\n    this._appendCount = 0;\n    this._last = 0;\n    this._queue = [];\n    this._queueCursor = 0;\n    this._canMarkIdName = true;\n    this._indentChar = \"\";\n    this._fastIndentations = [];\n    this._position = {\n      line: 1,\n      column: 0\n    };\n    this._sourcePosition = {\n      identifierName: undefined,\n      identifierNamePos: undefined,\n      line: undefined,\n      column: undefined,\n      filename: undefined\n    };\n    this._map = map;\n    this._indentChar = indentChar;\n    for (let i = 0; i < 64; i++) {\n      this._fastIndentations.push(indentChar.repeat(i));\n    }\n    this._allocQueue();\n  }\n  _allocQueue() {\n    const queue = this._queue;\n    for (let i = 0; i < 16; i++) {\n      queue.push({\n        char: 0,\n        repeat: 1,\n        line: undefined,\n        column: undefined,\n        identifierName: undefined,\n        identifierNamePos: undefined,\n        filename: \"\"\n      });\n    }\n  }\n  _pushQueue(char, repeat, line, column, filename) {\n    const cursor = this._queueCursor;\n    if (cursor === this._queue.length) {\n      this._allocQueue();\n    }\n    const item = this._queue[cursor];\n    item.char = char;\n    item.repeat = repeat;\n    item.line = line;\n    item.column = column;\n    item.filename = filename;\n    this._queueCursor++;\n  }\n  _popQueue() {\n    if (this._queueCursor === 0) {\n      throw new Error(\"Cannot pop from empty queue\");\n    }\n    return this._queue[--this._queueCursor];\n  }\n  get() {\n    this._flush();\n    const map = this._map;\n    const result = {\n      code: (this._buf + this._str).trimRight(),\n      decodedMap: map == null ? void 0 : map.getDecoded(),\n      get __mergedMap() {\n        return this.map;\n      },\n      get map() {\n        const resultMap = map ? map.get() : null;\n        result.map = resultMap;\n        return resultMap;\n      },\n      set map(value) {\n        Object.defineProperty(result, \"map\", {\n          value,\n          writable: true\n        });\n      },\n      get rawMappings() {\n        const mappings = map == null ? void 0 : map.getRawMappings();\n        result.rawMappings = mappings;\n        return mappings;\n      },\n      set rawMappings(value) {\n        Object.defineProperty(result, \"rawMappings\", {\n          value,\n          writable: true\n        });\n      }\n    };\n    return result;\n  }\n  append(str, maybeNewline) {\n    this._flush();\n    this._append(str, this._sourcePosition, maybeNewline);\n  }\n  appendChar(char) {\n    this._flush();\n    this._appendChar(char, 1, this._sourcePosition);\n  }\n  queue(char) {\n    if (char === 10) {\n      while (this._queueCursor !== 0) {\n        const char = this._queue[this._queueCursor - 1].char;\n        if (char !== 32 && char !== 9) {\n          break;\n        }\n        this._queueCursor--;\n      }\n    }\n    const sourcePosition = this._sourcePosition;\n    this._pushQueue(char, 1, sourcePosition.line, sourcePosition.column, sourcePosition.filename);\n  }\n  queueIndentation(repeat) {\n    if (repeat === 0) return;\n    this._pushQueue(-1, repeat, undefined, undefined, undefined);\n  }\n  _flush() {\n    const queueCursor = this._queueCursor;\n    const queue = this._queue;\n    for (let i = 0; i < queueCursor; i++) {\n      const item = queue[i];\n      this._appendChar(item.char, item.repeat, item);\n    }\n    this._queueCursor = 0;\n  }\n  _appendChar(char, repeat, sourcePos) {\n    this._last = char;\n    if (char === -1) {\n      const fastIndentation = this._fastIndentations[repeat];\n      if (fastIndentation !== undefined) {\n        this._str += fastIndentation;\n      } else {\n        this._str += repeat > 1 ? this._indentChar.repeat(repeat) : this._indentChar;\n      }\n    } else {\n      this._str += repeat > 1 ? String.fromCharCode(char).repeat(repeat) : String.fromCharCode(char);\n    }\n    if (char !== 10) {\n      this._mark(sourcePos.line, sourcePos.column, sourcePos.identifierName, sourcePos.identifierNamePos, sourcePos.filename);\n      this._position.column += repeat;\n    } else {\n      this._position.line++;\n      this._position.column = 0;\n    }\n    if (this._canMarkIdName) {\n      sourcePos.identifierName = undefined;\n      sourcePos.identifierNamePos = undefined;\n    }\n  }\n  _append(str, sourcePos, maybeNewline) {\n    const len = str.length;\n    const position = this._position;\n    this._last = str.charCodeAt(len - 1);\n    if (++this._appendCount > 4096) {\n      +this._str;\n      this._buf += this._str;\n      this._str = str;\n      this._appendCount = 0;\n    } else {\n      this._str += str;\n    }\n    if (!maybeNewline && !this._map) {\n      position.column += len;\n      return;\n    }\n    const {\n      column,\n      identifierName,\n      identifierNamePos,\n      filename\n    } = sourcePos;\n    let line = sourcePos.line;\n    if ((identifierName != null || identifierNamePos != null) && this._canMarkIdName) {\n      sourcePos.identifierName = undefined;\n      sourcePos.identifierNamePos = undefined;\n    }\n    let i = str.indexOf(\"\\n\");\n    let last = 0;\n    if (i !== 0) {\n      this._mark(line, column, identifierName, identifierNamePos, filename);\n    }\n    while (i !== -1) {\n      position.line++;\n      position.column = 0;\n      last = i + 1;\n      if (last < len && line !== undefined) {\n        this._mark(++line, 0, undefined, undefined, filename);\n      }\n      i = str.indexOf(\"\\n\", last);\n    }\n    position.column += len - last;\n  }\n  _mark(line, column, identifierName, identifierNamePos, filename) {\n    var _this$_map;\n    (_this$_map = this._map) == null || _this$_map.mark(this._position, line, column, identifierName, identifierNamePos, filename);\n  }\n  removeTrailingNewline() {\n    const queueCursor = this._queueCursor;\n    if (queueCursor !== 0 && this._queue[queueCursor - 1].char === 10) {\n      this._queueCursor--;\n    }\n  }\n  removeLastSemicolon() {\n    const queueCursor = this._queueCursor;\n    if (queueCursor !== 0 && this._queue[queueCursor - 1].char === 59) {\n      this._queueCursor--;\n    }\n  }\n  getLastChar() {\n    const queueCursor = this._queueCursor;\n    return queueCursor !== 0 ? this._queue[queueCursor - 1].char : this._last;\n  }\n  getNewlineCount() {\n    const queueCursor = this._queueCursor;\n    let count = 0;\n    if (queueCursor === 0) return this._last === 10 ? 1 : 0;\n    for (let i = queueCursor - 1; i >= 0; i--) {\n      if (this._queue[i].char !== 10) {\n        break;\n      }\n      count++;\n    }\n    return count === queueCursor && this._last === 10 ? count + 1 : count;\n  }\n  endsWithCharAndNewline() {\n    const queue = this._queue;\n    const queueCursor = this._queueCursor;\n    if (queueCursor !== 0) {\n      const lastCp = queue[queueCursor - 1].char;\n      if (lastCp !== 10) return;\n      if (queueCursor > 1) {\n        return queue[queueCursor - 2].char;\n      } else {\n        return this._last;\n      }\n    }\n  }\n  hasContent() {\n    return this._queueCursor !== 0 || !!this._last;\n  }\n  exactSource(loc, cb) {\n    if (!this._map) {\n      cb();\n      return;\n    }\n    this.source(\"start\", loc);\n    const identifierName = loc.identifierName;\n    const sourcePos = this._sourcePosition;\n    if (identifierName) {\n      this._canMarkIdName = false;\n      sourcePos.identifierName = identifierName;\n    }\n    cb();\n    if (identifierName) {\n      this._canMarkIdName = true;\n      sourcePos.identifierName = undefined;\n      sourcePos.identifierNamePos = undefined;\n    }\n    this.source(\"end\", loc);\n  }\n  source(prop, loc) {\n    if (!this._map) return;\n    this._normalizePosition(prop, loc, 0);\n  }\n  sourceWithOffset(prop, loc, columnOffset) {\n    if (!this._map) return;\n    this._normalizePosition(prop, loc, columnOffset);\n  }\n  _normalizePosition(prop, loc, columnOffset) {\n    const pos = loc[prop];\n    const target = this._sourcePosition;\n    if (pos) {\n      target.line = pos.line;\n      target.column = Math.max(pos.column + columnOffset, 0);\n      target.filename = loc.filename;\n    }\n  }\n  getCurrentColumn() {\n    const queue = this._queue;\n    const queueCursor = this._queueCursor;\n    let lastIndex = -1;\n    let len = 0;\n    for (let i = 0; i < queueCursor; i++) {\n      const item = queue[i];\n      if (item.char === 10) {\n        lastIndex = len;\n      }\n      len += item.repeat;\n    }\n    return lastIndex === -1 ? this._position.column + len : len - 1 - lastIndex;\n  }\n  getCurrentLine() {\n    let count = 0;\n    const queue = this._queue;\n    for (let i = 0; i < this._queueCursor; i++) {\n      if (queue[i].char === 10) {\n        count++;\n      }\n    }\n    return this._position.line + count;\n  }\n}\nexports[\"default\"] = Buffer;\n\n//# sourceMappingURL=buffer.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGJhYmVsL2dlbmVyYXRvci9saWIvYnVmZmVyLmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViLDhDQUE2QztBQUM3QztBQUNBLENBQUMsRUFBQztBQUNGLGtCQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsUUFBUTtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsUUFBUTtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsaUJBQWlCO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0MsUUFBUTtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsaUJBQWlCO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsdUJBQXVCO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWU7O0FBRWYiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9yZXBvLXZpc3VhbGl6ZXIvLi9ub2RlX21vZHVsZXMvQGJhYmVsL2dlbmVyYXRvci9saWIvYnVmZmVyLmpzPzBiZDYiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLmRlZmF1bHQgPSB2b2lkIDA7XG5jbGFzcyBCdWZmZXIge1xuICBjb25zdHJ1Y3RvcihtYXAsIGluZGVudENoYXIpIHtcbiAgICB0aGlzLl9tYXAgPSBudWxsO1xuICAgIHRoaXMuX2J1ZiA9IFwiXCI7XG4gICAgdGhpcy5fc3RyID0gXCJcIjtcbiAgICB0aGlzLl9hcHBlbmRDb3VudCA9IDA7XG4gICAgdGhpcy5fbGFzdCA9IDA7XG4gICAgdGhpcy5fcXVldWUgPSBbXTtcbiAgICB0aGlzLl9xdWV1ZUN1cnNvciA9IDA7XG4gICAgdGhpcy5fY2FuTWFya0lkTmFtZSA9IHRydWU7XG4gICAgdGhpcy5faW5kZW50Q2hhciA9IFwiXCI7XG4gICAgdGhpcy5fZmFzdEluZGVudGF0aW9ucyA9IFtdO1xuICAgIHRoaXMuX3Bvc2l0aW9uID0ge1xuICAgICAgbGluZTogMSxcbiAgICAgIGNvbHVtbjogMFxuICAgIH07XG4gICAgdGhpcy5fc291cmNlUG9zaXRpb24gPSB7XG4gICAgICBpZGVudGlmaWVyTmFtZTogdW5kZWZpbmVkLFxuICAgICAgaWRlbnRpZmllck5hbWVQb3M6IHVuZGVmaW5lZCxcbiAgICAgIGxpbmU6IHVuZGVmaW5lZCxcbiAgICAgIGNvbHVtbjogdW5kZWZpbmVkLFxuICAgICAgZmlsZW5hbWU6IHVuZGVmaW5lZFxuICAgIH07XG4gICAgdGhpcy5fbWFwID0gbWFwO1xuICAgIHRoaXMuX2luZGVudENoYXIgPSBpbmRlbnRDaGFyO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgNjQ7IGkrKykge1xuICAgICAgdGhpcy5fZmFzdEluZGVudGF0aW9ucy5wdXNoKGluZGVudENoYXIucmVwZWF0KGkpKTtcbiAgICB9XG4gICAgdGhpcy5fYWxsb2NRdWV1ZSgpO1xuICB9XG4gIF9hbGxvY1F1ZXVlKCkge1xuICAgIGNvbnN0IHF1ZXVlID0gdGhpcy5fcXVldWU7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCAxNjsgaSsrKSB7XG4gICAgICBxdWV1ZS5wdXNoKHtcbiAgICAgICAgY2hhcjogMCxcbiAgICAgICAgcmVwZWF0OiAxLFxuICAgICAgICBsaW5lOiB1bmRlZmluZWQsXG4gICAgICAgIGNvbHVtbjogdW5kZWZpbmVkLFxuICAgICAgICBpZGVudGlmaWVyTmFtZTogdW5kZWZpbmVkLFxuICAgICAgICBpZGVudGlmaWVyTmFtZVBvczogdW5kZWZpbmVkLFxuICAgICAgICBmaWxlbmFtZTogXCJcIlxuICAgICAgfSk7XG4gICAgfVxuICB9XG4gIF9wdXNoUXVldWUoY2hhciwgcmVwZWF0LCBsaW5lLCBjb2x1bW4sIGZpbGVuYW1lKSB7XG4gICAgY29uc3QgY3Vyc29yID0gdGhpcy5fcXVldWVDdXJzb3I7XG4gICAgaWYgKGN1cnNvciA9PT0gdGhpcy5fcXVldWUubGVuZ3RoKSB7XG4gICAgICB0aGlzLl9hbGxvY1F1ZXVlKCk7XG4gICAgfVxuICAgIGNvbnN0IGl0ZW0gPSB0aGlzLl9xdWV1ZVtjdXJzb3JdO1xuICAgIGl0ZW0uY2hhciA9IGNoYXI7XG4gICAgaXRlbS5yZXBlYXQgPSByZXBlYXQ7XG4gICAgaXRlbS5saW5lID0gbGluZTtcbiAgICBpdGVtLmNvbHVtbiA9IGNvbHVtbjtcbiAgICBpdGVtLmZpbGVuYW1lID0gZmlsZW5hbWU7XG4gICAgdGhpcy5fcXVldWVDdXJzb3IrKztcbiAgfVxuICBfcG9wUXVldWUoKSB7XG4gICAgaWYgKHRoaXMuX3F1ZXVlQ3Vyc29yID09PSAwKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3QgcG9wIGZyb20gZW1wdHkgcXVldWVcIik7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLl9xdWV1ZVstLXRoaXMuX3F1ZXVlQ3Vyc29yXTtcbiAgfVxuICBnZXQoKSB7XG4gICAgdGhpcy5fZmx1c2goKTtcbiAgICBjb25zdCBtYXAgPSB0aGlzLl9tYXA7XG4gICAgY29uc3QgcmVzdWx0ID0ge1xuICAgICAgY29kZTogKHRoaXMuX2J1ZiArIHRoaXMuX3N0cikudHJpbVJpZ2h0KCksXG4gICAgICBkZWNvZGVkTWFwOiBtYXAgPT0gbnVsbCA/IHZvaWQgMCA6IG1hcC5nZXREZWNvZGVkKCksXG4gICAgICBnZXQgX19tZXJnZWRNYXAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm1hcDtcbiAgICAgIH0sXG4gICAgICBnZXQgbWFwKCkge1xuICAgICAgICBjb25zdCByZXN1bHRNYXAgPSBtYXAgPyBtYXAuZ2V0KCkgOiBudWxsO1xuICAgICAgICByZXN1bHQubWFwID0gcmVzdWx0TWFwO1xuICAgICAgICByZXR1cm4gcmVzdWx0TWFwO1xuICAgICAgfSxcbiAgICAgIHNldCBtYXAodmFsdWUpIHtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHJlc3VsdCwgXCJtYXBcIiwge1xuICAgICAgICAgIHZhbHVlLFxuICAgICAgICAgIHdyaXRhYmxlOiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgfSxcbiAgICAgIGdldCByYXdNYXBwaW5ncygpIHtcbiAgICAgICAgY29uc3QgbWFwcGluZ3MgPSBtYXAgPT0gbnVsbCA/IHZvaWQgMCA6IG1hcC5nZXRSYXdNYXBwaW5ncygpO1xuICAgICAgICByZXN1bHQucmF3TWFwcGluZ3MgPSBtYXBwaW5ncztcbiAgICAgICAgcmV0dXJuIG1hcHBpbmdzO1xuICAgICAgfSxcbiAgICAgIHNldCByYXdNYXBwaW5ncyh2YWx1ZSkge1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkocmVzdWx0LCBcInJhd01hcHBpbmdzXCIsIHtcbiAgICAgICAgICB2YWx1ZSxcbiAgICAgICAgICB3cml0YWJsZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9O1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cbiAgYXBwZW5kKHN0ciwgbWF5YmVOZXdsaW5lKSB7XG4gICAgdGhpcy5fZmx1c2goKTtcbiAgICB0aGlzLl9hcHBlbmQoc3RyLCB0aGlzLl9zb3VyY2VQb3NpdGlvbiwgbWF5YmVOZXdsaW5lKTtcbiAgfVxuICBhcHBlbmRDaGFyKGNoYXIpIHtcbiAgICB0aGlzLl9mbHVzaCgpO1xuICAgIHRoaXMuX2FwcGVuZENoYXIoY2hhciwgMSwgdGhpcy5fc291cmNlUG9zaXRpb24pO1xuICB9XG4gIHF1ZXVlKGNoYXIpIHtcbiAgICBpZiAoY2hhciA9PT0gMTApIHtcbiAgICAgIHdoaWxlICh0aGlzLl9xdWV1ZUN1cnNvciAhPT0gMCkge1xuICAgICAgICBjb25zdCBjaGFyID0gdGhpcy5fcXVldWVbdGhpcy5fcXVldWVDdXJzb3IgLSAxXS5jaGFyO1xuICAgICAgICBpZiAoY2hhciAhPT0gMzIgJiYgY2hhciAhPT0gOSkge1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3F1ZXVlQ3Vyc29yLS07XG4gICAgICB9XG4gICAgfVxuICAgIGNvbnN0IHNvdXJjZVBvc2l0aW9uID0gdGhpcy5fc291cmNlUG9zaXRpb247XG4gICAgdGhpcy5fcHVzaFF1ZXVlKGNoYXIsIDEsIHNvdXJjZVBvc2l0aW9uLmxpbmUsIHNvdXJjZVBvc2l0aW9uLmNvbHVtbiwgc291cmNlUG9zaXRpb24uZmlsZW5hbWUpO1xuICB9XG4gIHF1ZXVlSW5kZW50YXRpb24ocmVwZWF0KSB7XG4gICAgaWYgKHJlcGVhdCA9PT0gMCkgcmV0dXJuO1xuICAgIHRoaXMuX3B1c2hRdWV1ZSgtMSwgcmVwZWF0LCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgdW5kZWZpbmVkKTtcbiAgfVxuICBfZmx1c2goKSB7XG4gICAgY29uc3QgcXVldWVDdXJzb3IgPSB0aGlzLl9xdWV1ZUN1cnNvcjtcbiAgICBjb25zdCBxdWV1ZSA9IHRoaXMuX3F1ZXVlO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcXVldWVDdXJzb3I7IGkrKykge1xuICAgICAgY29uc3QgaXRlbSA9IHF1ZXVlW2ldO1xuICAgICAgdGhpcy5fYXBwZW5kQ2hhcihpdGVtLmNoYXIsIGl0ZW0ucmVwZWF0LCBpdGVtKTtcbiAgICB9XG4gICAgdGhpcy5fcXVldWVDdXJzb3IgPSAwO1xuICB9XG4gIF9hcHBlbmRDaGFyKGNoYXIsIHJlcGVhdCwgc291cmNlUG9zKSB7XG4gICAgdGhpcy5fbGFzdCA9IGNoYXI7XG4gICAgaWYgKGNoYXIgPT09IC0xKSB7XG4gICAgICBjb25zdCBmYXN0SW5kZW50YXRpb24gPSB0aGlzLl9mYXN0SW5kZW50YXRpb25zW3JlcGVhdF07XG4gICAgICBpZiAoZmFzdEluZGVudGF0aW9uICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhpcy5fc3RyICs9IGZhc3RJbmRlbnRhdGlvbjtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuX3N0ciArPSByZXBlYXQgPiAxID8gdGhpcy5faW5kZW50Q2hhci5yZXBlYXQocmVwZWF0KSA6IHRoaXMuX2luZGVudENoYXI7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuX3N0ciArPSByZXBlYXQgPiAxID8gU3RyaW5nLmZyb21DaGFyQ29kZShjaGFyKS5yZXBlYXQocmVwZWF0KSA6IFN0cmluZy5mcm9tQ2hhckNvZGUoY2hhcik7XG4gICAgfVxuICAgIGlmIChjaGFyICE9PSAxMCkge1xuICAgICAgdGhpcy5fbWFyayhzb3VyY2VQb3MubGluZSwgc291cmNlUG9zLmNvbHVtbiwgc291cmNlUG9zLmlkZW50aWZpZXJOYW1lLCBzb3VyY2VQb3MuaWRlbnRpZmllck5hbWVQb3MsIHNvdXJjZVBvcy5maWxlbmFtZSk7XG4gICAgICB0aGlzLl9wb3NpdGlvbi5jb2x1bW4gKz0gcmVwZWF0O1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLl9wb3NpdGlvbi5saW5lKys7XG4gICAgICB0aGlzLl9wb3NpdGlvbi5jb2x1bW4gPSAwO1xuICAgIH1cbiAgICBpZiAodGhpcy5fY2FuTWFya0lkTmFtZSkge1xuICAgICAgc291cmNlUG9zLmlkZW50aWZpZXJOYW1lID0gdW5kZWZpbmVkO1xuICAgICAgc291cmNlUG9zLmlkZW50aWZpZXJOYW1lUG9zID0gdW5kZWZpbmVkO1xuICAgIH1cbiAgfVxuICBfYXBwZW5kKHN0ciwgc291cmNlUG9zLCBtYXliZU5ld2xpbmUpIHtcbiAgICBjb25zdCBsZW4gPSBzdHIubGVuZ3RoO1xuICAgIGNvbnN0IHBvc2l0aW9uID0gdGhpcy5fcG9zaXRpb247XG4gICAgdGhpcy5fbGFzdCA9IHN0ci5jaGFyQ29kZUF0KGxlbiAtIDEpO1xuICAgIGlmICgrK3RoaXMuX2FwcGVuZENvdW50ID4gNDA5Nikge1xuICAgICAgK3RoaXMuX3N0cjtcbiAgICAgIHRoaXMuX2J1ZiArPSB0aGlzLl9zdHI7XG4gICAgICB0aGlzLl9zdHIgPSBzdHI7XG4gICAgICB0aGlzLl9hcHBlbmRDb3VudCA9IDA7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuX3N0ciArPSBzdHI7XG4gICAgfVxuICAgIGlmICghbWF5YmVOZXdsaW5lICYmICF0aGlzLl9tYXApIHtcbiAgICAgIHBvc2l0aW9uLmNvbHVtbiArPSBsZW47XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHtcbiAgICAgIGNvbHVtbixcbiAgICAgIGlkZW50aWZpZXJOYW1lLFxuICAgICAgaWRlbnRpZmllck5hbWVQb3MsXG4gICAgICBmaWxlbmFtZVxuICAgIH0gPSBzb3VyY2VQb3M7XG4gICAgbGV0IGxpbmUgPSBzb3VyY2VQb3MubGluZTtcbiAgICBpZiAoKGlkZW50aWZpZXJOYW1lICE9IG51bGwgfHwgaWRlbnRpZmllck5hbWVQb3MgIT0gbnVsbCkgJiYgdGhpcy5fY2FuTWFya0lkTmFtZSkge1xuICAgICAgc291cmNlUG9zLmlkZW50aWZpZXJOYW1lID0gdW5kZWZpbmVkO1xuICAgICAgc291cmNlUG9zLmlkZW50aWZpZXJOYW1lUG9zID0gdW5kZWZpbmVkO1xuICAgIH1cbiAgICBsZXQgaSA9IHN0ci5pbmRleE9mKFwiXFxuXCIpO1xuICAgIGxldCBsYXN0ID0gMDtcbiAgICBpZiAoaSAhPT0gMCkge1xuICAgICAgdGhpcy5fbWFyayhsaW5lLCBjb2x1bW4sIGlkZW50aWZpZXJOYW1lLCBpZGVudGlmaWVyTmFtZVBvcywgZmlsZW5hbWUpO1xuICAgIH1cbiAgICB3aGlsZSAoaSAhPT0gLTEpIHtcbiAgICAgIHBvc2l0aW9uLmxpbmUrKztcbiAgICAgIHBvc2l0aW9uLmNvbHVtbiA9IDA7XG4gICAgICBsYXN0ID0gaSArIDE7XG4gICAgICBpZiAobGFzdCA8IGxlbiAmJiBsaW5lICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhpcy5fbWFyaygrK2xpbmUsIDAsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCBmaWxlbmFtZSk7XG4gICAgICB9XG4gICAgICBpID0gc3RyLmluZGV4T2YoXCJcXG5cIiwgbGFzdCk7XG4gICAgfVxuICAgIHBvc2l0aW9uLmNvbHVtbiArPSBsZW4gLSBsYXN0O1xuICB9XG4gIF9tYXJrKGxpbmUsIGNvbHVtbiwgaWRlbnRpZmllck5hbWUsIGlkZW50aWZpZXJOYW1lUG9zLCBmaWxlbmFtZSkge1xuICAgIHZhciBfdGhpcyRfbWFwO1xuICAgIChfdGhpcyRfbWFwID0gdGhpcy5fbWFwKSA9PSBudWxsIHx8IF90aGlzJF9tYXAubWFyayh0aGlzLl9wb3NpdGlvbiwgbGluZSwgY29sdW1uLCBpZGVudGlmaWVyTmFtZSwgaWRlbnRpZmllck5hbWVQb3MsIGZpbGVuYW1lKTtcbiAgfVxuICByZW1vdmVUcmFpbGluZ05ld2xpbmUoKSB7XG4gICAgY29uc3QgcXVldWVDdXJzb3IgPSB0aGlzLl9xdWV1ZUN1cnNvcjtcbiAgICBpZiAocXVldWVDdXJzb3IgIT09IDAgJiYgdGhpcy5fcXVldWVbcXVldWVDdXJzb3IgLSAxXS5jaGFyID09PSAxMCkge1xuICAgICAgdGhpcy5fcXVldWVDdXJzb3ItLTtcbiAgICB9XG4gIH1cbiAgcmVtb3ZlTGFzdFNlbWljb2xvbigpIHtcbiAgICBjb25zdCBxdWV1ZUN1cnNvciA9IHRoaXMuX3F1ZXVlQ3Vyc29yO1xuICAgIGlmIChxdWV1ZUN1cnNvciAhPT0gMCAmJiB0aGlzLl9xdWV1ZVtxdWV1ZUN1cnNvciAtIDFdLmNoYXIgPT09IDU5KSB7XG4gICAgICB0aGlzLl9xdWV1ZUN1cnNvci0tO1xuICAgIH1cbiAgfVxuICBnZXRMYXN0Q2hhcigpIHtcbiAgICBjb25zdCBxdWV1ZUN1cnNvciA9IHRoaXMuX3F1ZXVlQ3Vyc29yO1xuICAgIHJldHVybiBxdWV1ZUN1cnNvciAhPT0gMCA/IHRoaXMuX3F1ZXVlW3F1ZXVlQ3Vyc29yIC0gMV0uY2hhciA6IHRoaXMuX2xhc3Q7XG4gIH1cbiAgZ2V0TmV3bGluZUNvdW50KCkge1xuICAgIGNvbnN0IHF1ZXVlQ3Vyc29yID0gdGhpcy5fcXVldWVDdXJzb3I7XG4gICAgbGV0IGNvdW50ID0gMDtcbiAgICBpZiAocXVldWVDdXJzb3IgPT09IDApIHJldHVybiB0aGlzLl9sYXN0ID09PSAxMCA/IDEgOiAwO1xuICAgIGZvciAobGV0IGkgPSBxdWV1ZUN1cnNvciAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICBpZiAodGhpcy5fcXVldWVbaV0uY2hhciAhPT0gMTApIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBjb3VudCsrO1xuICAgIH1cbiAgICByZXR1cm4gY291bnQgPT09IHF1ZXVlQ3Vyc29yICYmIHRoaXMuX2xhc3QgPT09IDEwID8gY291bnQgKyAxIDogY291bnQ7XG4gIH1cbiAgZW5kc1dpdGhDaGFyQW5kTmV3bGluZSgpIHtcbiAgICBjb25zdCBxdWV1ZSA9IHRoaXMuX3F1ZXVlO1xuICAgIGNvbnN0IHF1ZXVlQ3Vyc29yID0gdGhpcy5fcXVldWVDdXJzb3I7XG4gICAgaWYgKHF1ZXVlQ3Vyc29yICE9PSAwKSB7XG4gICAgICBjb25zdCBsYXN0Q3AgPSBxdWV1ZVtxdWV1ZUN1cnNvciAtIDFdLmNoYXI7XG4gICAgICBpZiAobGFzdENwICE9PSAxMCkgcmV0dXJuO1xuICAgICAgaWYgKHF1ZXVlQ3Vyc29yID4gMSkge1xuICAgICAgICByZXR1cm4gcXVldWVbcXVldWVDdXJzb3IgLSAyXS5jaGFyO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2xhc3Q7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGhhc0NvbnRlbnQoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3F1ZXVlQ3Vyc29yICE9PSAwIHx8ICEhdGhpcy5fbGFzdDtcbiAgfVxuICBleGFjdFNvdXJjZShsb2MsIGNiKSB7XG4gICAgaWYgKCF0aGlzLl9tYXApIHtcbiAgICAgIGNiKCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuc291cmNlKFwic3RhcnRcIiwgbG9jKTtcbiAgICBjb25zdCBpZGVudGlmaWVyTmFtZSA9IGxvYy5pZGVudGlmaWVyTmFtZTtcbiAgICBjb25zdCBzb3VyY2VQb3MgPSB0aGlzLl9zb3VyY2VQb3NpdGlvbjtcbiAgICBpZiAoaWRlbnRpZmllck5hbWUpIHtcbiAgICAgIHRoaXMuX2Nhbk1hcmtJZE5hbWUgPSBmYWxzZTtcbiAgICAgIHNvdXJjZVBvcy5pZGVudGlmaWVyTmFtZSA9IGlkZW50aWZpZXJOYW1lO1xuICAgIH1cbiAgICBjYigpO1xuICAgIGlmIChpZGVudGlmaWVyTmFtZSkge1xuICAgICAgdGhpcy5fY2FuTWFya0lkTmFtZSA9IHRydWU7XG4gICAgICBzb3VyY2VQb3MuaWRlbnRpZmllck5hbWUgPSB1bmRlZmluZWQ7XG4gICAgICBzb3VyY2VQb3MuaWRlbnRpZmllck5hbWVQb3MgPSB1bmRlZmluZWQ7XG4gICAgfVxuICAgIHRoaXMuc291cmNlKFwiZW5kXCIsIGxvYyk7XG4gIH1cbiAgc291cmNlKHByb3AsIGxvYykge1xuICAgIGlmICghdGhpcy5fbWFwKSByZXR1cm47XG4gICAgdGhpcy5fbm9ybWFsaXplUG9zaXRpb24ocHJvcCwgbG9jLCAwKTtcbiAgfVxuICBzb3VyY2VXaXRoT2Zmc2V0KHByb3AsIGxvYywgY29sdW1uT2Zmc2V0KSB7XG4gICAgaWYgKCF0aGlzLl9tYXApIHJldHVybjtcbiAgICB0aGlzLl9ub3JtYWxpemVQb3NpdGlvbihwcm9wLCBsb2MsIGNvbHVtbk9mZnNldCk7XG4gIH1cbiAgX25vcm1hbGl6ZVBvc2l0aW9uKHByb3AsIGxvYywgY29sdW1uT2Zmc2V0KSB7XG4gICAgY29uc3QgcG9zID0gbG9jW3Byb3BdO1xuICAgIGNvbnN0IHRhcmdldCA9IHRoaXMuX3NvdXJjZVBvc2l0aW9uO1xuICAgIGlmIChwb3MpIHtcbiAgICAgIHRhcmdldC5saW5lID0gcG9zLmxpbmU7XG4gICAgICB0YXJnZXQuY29sdW1uID0gTWF0aC5tYXgocG9zLmNvbHVtbiArIGNvbHVtbk9mZnNldCwgMCk7XG4gICAgICB0YXJnZXQuZmlsZW5hbWUgPSBsb2MuZmlsZW5hbWU7XG4gICAgfVxuICB9XG4gIGdldEN1cnJlbnRDb2x1bW4oKSB7XG4gICAgY29uc3QgcXVldWUgPSB0aGlzLl9xdWV1ZTtcbiAgICBjb25zdCBxdWV1ZUN1cnNvciA9IHRoaXMuX3F1ZXVlQ3Vyc29yO1xuICAgIGxldCBsYXN0SW5kZXggPSAtMTtcbiAgICBsZXQgbGVuID0gMDtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHF1ZXVlQ3Vyc29yOyBpKyspIHtcbiAgICAgIGNvbnN0IGl0ZW0gPSBxdWV1ZVtpXTtcbiAgICAgIGlmIChpdGVtLmNoYXIgPT09IDEwKSB7XG4gICAgICAgIGxhc3RJbmRleCA9IGxlbjtcbiAgICAgIH1cbiAgICAgIGxlbiArPSBpdGVtLnJlcGVhdDtcbiAgICB9XG4gICAgcmV0dXJuIGxhc3RJbmRleCA9PT0gLTEgPyB0aGlzLl9wb3NpdGlvbi5jb2x1bW4gKyBsZW4gOiBsZW4gLSAxIC0gbGFzdEluZGV4O1xuICB9XG4gIGdldEN1cnJlbnRMaW5lKCkge1xuICAgIGxldCBjb3VudCA9IDA7XG4gICAgY29uc3QgcXVldWUgPSB0aGlzLl9xdWV1ZTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuX3F1ZXVlQ3Vyc29yOyBpKyspIHtcbiAgICAgIGlmIChxdWV1ZVtpXS5jaGFyID09PSAxMCkge1xuICAgICAgICBjb3VudCsrO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdGhpcy5fcG9zaXRpb24ubGluZSArIGNvdW50O1xuICB9XG59XG5leHBvcnRzLmRlZmF1bHQgPSBCdWZmZXI7XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWJ1ZmZlci5qcy5tYXBcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@babel/generator/lib/buffer.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@babel/generator/lib/generators/base.js":
/*!**************************************************************!*\
  !*** ./node_modules/@babel/generator/lib/generators/base.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports.BlockStatement = BlockStatement;\nexports.Directive = Directive;\nexports.DirectiveLiteral = DirectiveLiteral;\nexports.File = File;\nexports.InterpreterDirective = InterpreterDirective;\nexports.Placeholder = Placeholder;\nexports.Program = Program;\nfunction File(node) {\n  if (node.program) {\n    this.print(node.program.interpreter);\n  }\n  this.print(node.program);\n}\nfunction Program(node) {\n  var _node$directives;\n  this.noIndentInnerCommentsHere();\n  this.printInnerComments();\n  const directivesLen = (_node$directives = node.directives) == null ? void 0 : _node$directives.length;\n  if (directivesLen) {\n    var _node$directives$trai;\n    const newline = node.body.length ? 2 : 1;\n    this.printSequence(node.directives, undefined, newline);\n    if (!((_node$directives$trai = node.directives[directivesLen - 1].trailingComments) != null && _node$directives$trai.length)) {\n      this.newline(newline);\n    }\n  }\n  this.printSequence(node.body);\n}\nfunction BlockStatement(node) {\n  var _node$directives2;\n  this.tokenChar(123);\n  const exit = this.enterDelimited();\n  const directivesLen = (_node$directives2 = node.directives) == null ? void 0 : _node$directives2.length;\n  if (directivesLen) {\n    var _node$directives$trai2;\n    const newline = node.body.length ? 2 : 1;\n    this.printSequence(node.directives, true, newline);\n    if (!((_node$directives$trai2 = node.directives[directivesLen - 1].trailingComments) != null && _node$directives$trai2.length)) {\n      this.newline(newline);\n    }\n  }\n  this.printSequence(node.body, true);\n  exit();\n  this.rightBrace(node);\n}\nfunction Directive(node) {\n  this.print(node.value);\n  this.semicolon();\n}\nconst unescapedSingleQuoteRE = /(?:^|[^\\\\])(?:\\\\\\\\)*'/;\nconst unescapedDoubleQuoteRE = /(?:^|[^\\\\])(?:\\\\\\\\)*\"/;\nfunction DirectiveLiteral(node) {\n  const raw = this.getPossibleRaw(node);\n  if (!this.format.minified && raw !== undefined) {\n    this.token(raw);\n    return;\n  }\n  const {\n    value\n  } = node;\n  if (!unescapedDoubleQuoteRE.test(value)) {\n    this.token(`\"${value}\"`);\n  } else if (!unescapedSingleQuoteRE.test(value)) {\n    this.token(`'${value}'`);\n  } else {\n    throw new Error(\"Malformed AST: it is not possible to print a directive containing\" + \" both unescaped single and double quotes.\");\n  }\n}\nfunction InterpreterDirective(node) {\n  this.token(`#!${node.value}`);\n  this.newline(1, true);\n}\nfunction Placeholder(node) {\n  this.token(\"%%\");\n  this.print(node.name);\n  this.token(\"%%\");\n  if (node.expectedNode === \"Statement\") {\n    this.semicolon();\n  }\n}\n\n//# sourceMappingURL=base.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGJhYmVsL2dlbmVyYXRvci9saWIvZ2VuZXJhdG9ycy9iYXNlLmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViLDhDQUE2QztBQUM3QztBQUNBLENBQUMsRUFBQztBQUNGLHNCQUFzQjtBQUN0QixpQkFBaUI7QUFDakIsd0JBQXdCO0FBQ3hCLFlBQVk7QUFDWiw0QkFBNEI7QUFDNUIsbUJBQW1CO0FBQ25CLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBLG1CQUFtQixNQUFNO0FBQ3pCLElBQUk7QUFDSixtQkFBbUIsTUFBTTtBQUN6QixJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsV0FBVztBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSIsInNvdXJjZXMiOlsid2VicGFjazovL3JlcG8tdmlzdWFsaXplci8uL25vZGVfbW9kdWxlcy9AYmFiZWwvZ2VuZXJhdG9yL2xpYi9nZW5lcmF0b3JzL2Jhc2UuanM/ZjAyNSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuQmxvY2tTdGF0ZW1lbnQgPSBCbG9ja1N0YXRlbWVudDtcbmV4cG9ydHMuRGlyZWN0aXZlID0gRGlyZWN0aXZlO1xuZXhwb3J0cy5EaXJlY3RpdmVMaXRlcmFsID0gRGlyZWN0aXZlTGl0ZXJhbDtcbmV4cG9ydHMuRmlsZSA9IEZpbGU7XG5leHBvcnRzLkludGVycHJldGVyRGlyZWN0aXZlID0gSW50ZXJwcmV0ZXJEaXJlY3RpdmU7XG5leHBvcnRzLlBsYWNlaG9sZGVyID0gUGxhY2Vob2xkZXI7XG5leHBvcnRzLlByb2dyYW0gPSBQcm9ncmFtO1xuZnVuY3Rpb24gRmlsZShub2RlKSB7XG4gIGlmIChub2RlLnByb2dyYW0pIHtcbiAgICB0aGlzLnByaW50KG5vZGUucHJvZ3JhbS5pbnRlcnByZXRlcik7XG4gIH1cbiAgdGhpcy5wcmludChub2RlLnByb2dyYW0pO1xufVxuZnVuY3Rpb24gUHJvZ3JhbShub2RlKSB7XG4gIHZhciBfbm9kZSRkaXJlY3RpdmVzO1xuICB0aGlzLm5vSW5kZW50SW5uZXJDb21tZW50c0hlcmUoKTtcbiAgdGhpcy5wcmludElubmVyQ29tbWVudHMoKTtcbiAgY29uc3QgZGlyZWN0aXZlc0xlbiA9IChfbm9kZSRkaXJlY3RpdmVzID0gbm9kZS5kaXJlY3RpdmVzKSA9PSBudWxsID8gdm9pZCAwIDogX25vZGUkZGlyZWN0aXZlcy5sZW5ndGg7XG4gIGlmIChkaXJlY3RpdmVzTGVuKSB7XG4gICAgdmFyIF9ub2RlJGRpcmVjdGl2ZXMkdHJhaTtcbiAgICBjb25zdCBuZXdsaW5lID0gbm9kZS5ib2R5Lmxlbmd0aCA/IDIgOiAxO1xuICAgIHRoaXMucHJpbnRTZXF1ZW5jZShub2RlLmRpcmVjdGl2ZXMsIHVuZGVmaW5lZCwgbmV3bGluZSk7XG4gICAgaWYgKCEoKF9ub2RlJGRpcmVjdGl2ZXMkdHJhaSA9IG5vZGUuZGlyZWN0aXZlc1tkaXJlY3RpdmVzTGVuIC0gMV0udHJhaWxpbmdDb21tZW50cykgIT0gbnVsbCAmJiBfbm9kZSRkaXJlY3RpdmVzJHRyYWkubGVuZ3RoKSkge1xuICAgICAgdGhpcy5uZXdsaW5lKG5ld2xpbmUpO1xuICAgIH1cbiAgfVxuICB0aGlzLnByaW50U2VxdWVuY2Uobm9kZS5ib2R5KTtcbn1cbmZ1bmN0aW9uIEJsb2NrU3RhdGVtZW50KG5vZGUpIHtcbiAgdmFyIF9ub2RlJGRpcmVjdGl2ZXMyO1xuICB0aGlzLnRva2VuQ2hhcigxMjMpO1xuICBjb25zdCBleGl0ID0gdGhpcy5lbnRlckRlbGltaXRlZCgpO1xuICBjb25zdCBkaXJlY3RpdmVzTGVuID0gKF9ub2RlJGRpcmVjdGl2ZXMyID0gbm9kZS5kaXJlY3RpdmVzKSA9PSBudWxsID8gdm9pZCAwIDogX25vZGUkZGlyZWN0aXZlczIubGVuZ3RoO1xuICBpZiAoZGlyZWN0aXZlc0xlbikge1xuICAgIHZhciBfbm9kZSRkaXJlY3RpdmVzJHRyYWkyO1xuICAgIGNvbnN0IG5ld2xpbmUgPSBub2RlLmJvZHkubGVuZ3RoID8gMiA6IDE7XG4gICAgdGhpcy5wcmludFNlcXVlbmNlKG5vZGUuZGlyZWN0aXZlcywgdHJ1ZSwgbmV3bGluZSk7XG4gICAgaWYgKCEoKF9ub2RlJGRpcmVjdGl2ZXMkdHJhaTIgPSBub2RlLmRpcmVjdGl2ZXNbZGlyZWN0aXZlc0xlbiAtIDFdLnRyYWlsaW5nQ29tbWVudHMpICE9IG51bGwgJiYgX25vZGUkZGlyZWN0aXZlcyR0cmFpMi5sZW5ndGgpKSB7XG4gICAgICB0aGlzLm5ld2xpbmUobmV3bGluZSk7XG4gICAgfVxuICB9XG4gIHRoaXMucHJpbnRTZXF1ZW5jZShub2RlLmJvZHksIHRydWUpO1xuICBleGl0KCk7XG4gIHRoaXMucmlnaHRCcmFjZShub2RlKTtcbn1cbmZ1bmN0aW9uIERpcmVjdGl2ZShub2RlKSB7XG4gIHRoaXMucHJpbnQobm9kZS52YWx1ZSk7XG4gIHRoaXMuc2VtaWNvbG9uKCk7XG59XG5jb25zdCB1bmVzY2FwZWRTaW5nbGVRdW90ZVJFID0gLyg/Ol58W15cXFxcXSkoPzpcXFxcXFxcXCkqJy87XG5jb25zdCB1bmVzY2FwZWREb3VibGVRdW90ZVJFID0gLyg/Ol58W15cXFxcXSkoPzpcXFxcXFxcXCkqXCIvO1xuZnVuY3Rpb24gRGlyZWN0aXZlTGl0ZXJhbChub2RlKSB7XG4gIGNvbnN0IHJhdyA9IHRoaXMuZ2V0UG9zc2libGVSYXcobm9kZSk7XG4gIGlmICghdGhpcy5mb3JtYXQubWluaWZpZWQgJiYgcmF3ICE9PSB1bmRlZmluZWQpIHtcbiAgICB0aGlzLnRva2VuKHJhdyk7XG4gICAgcmV0dXJuO1xuICB9XG4gIGNvbnN0IHtcbiAgICB2YWx1ZVxuICB9ID0gbm9kZTtcbiAgaWYgKCF1bmVzY2FwZWREb3VibGVRdW90ZVJFLnRlc3QodmFsdWUpKSB7XG4gICAgdGhpcy50b2tlbihgXCIke3ZhbHVlfVwiYCk7XG4gIH0gZWxzZSBpZiAoIXVuZXNjYXBlZFNpbmdsZVF1b3RlUkUudGVzdCh2YWx1ZSkpIHtcbiAgICB0aGlzLnRva2VuKGAnJHt2YWx1ZX0nYCk7XG4gIH0gZWxzZSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiTWFsZm9ybWVkIEFTVDogaXQgaXMgbm90IHBvc3NpYmxlIHRvIHByaW50IGEgZGlyZWN0aXZlIGNvbnRhaW5pbmdcIiArIFwiIGJvdGggdW5lc2NhcGVkIHNpbmdsZSBhbmQgZG91YmxlIHF1b3Rlcy5cIik7XG4gIH1cbn1cbmZ1bmN0aW9uIEludGVycHJldGVyRGlyZWN0aXZlKG5vZGUpIHtcbiAgdGhpcy50b2tlbihgIyEke25vZGUudmFsdWV9YCk7XG4gIHRoaXMubmV3bGluZSgxLCB0cnVlKTtcbn1cbmZ1bmN0aW9uIFBsYWNlaG9sZGVyKG5vZGUpIHtcbiAgdGhpcy50b2tlbihcIiUlXCIpO1xuICB0aGlzLnByaW50KG5vZGUubmFtZSk7XG4gIHRoaXMudG9rZW4oXCIlJVwiKTtcbiAgaWYgKG5vZGUuZXhwZWN0ZWROb2RlID09PSBcIlN0YXRlbWVudFwiKSB7XG4gICAgdGhpcy5zZW1pY29sb24oKTtcbiAgfVxufVxuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1iYXNlLmpzLm1hcFxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@babel/generator/lib/generators/base.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@babel/generator/lib/generators/classes.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@babel/generator/lib/generators/classes.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports.ClassAccessorProperty = ClassAccessorProperty;\nexports.ClassBody = ClassBody;\nexports.ClassExpression = exports.ClassDeclaration = ClassDeclaration;\nexports.ClassMethod = ClassMethod;\nexports.ClassPrivateMethod = ClassPrivateMethod;\nexports.ClassPrivateProperty = ClassPrivateProperty;\nexports.ClassProperty = ClassProperty;\nexports.StaticBlock = StaticBlock;\nexports._classMethodHead = _classMethodHead;\nvar _t = __webpack_require__(/*! @babel/types */ \"(ssr)/./node_modules/@babel/types/lib/index.js\");\nconst {\n  isExportDefaultDeclaration,\n  isExportNamedDeclaration\n} = _t;\nfunction ClassDeclaration(node, parent) {\n  const inExport = isExportDefaultDeclaration(parent) || isExportNamedDeclaration(parent);\n  if (!inExport || !this._shouldPrintDecoratorsBeforeExport(parent)) {\n    this.printJoin(node.decorators);\n  }\n  if (node.declare) {\n    this.word(\"declare\");\n    this.space();\n  }\n  if (node.abstract) {\n    this.word(\"abstract\");\n    this.space();\n  }\n  this.word(\"class\");\n  if (node.id) {\n    this.space();\n    this.print(node.id);\n  }\n  this.print(node.typeParameters);\n  if (node.superClass) {\n    this.space();\n    this.word(\"extends\");\n    this.space();\n    this.print(node.superClass);\n    this.print(node.superTypeParameters);\n  }\n  if (node.implements) {\n    this.space();\n    this.word(\"implements\");\n    this.space();\n    this.printList(node.implements);\n  }\n  this.space();\n  this.print(node.body);\n}\nfunction ClassBody(node) {\n  this.tokenChar(123);\n  if (node.body.length === 0) {\n    this.tokenChar(125);\n  } else {\n    this.newline();\n    const separator = classBodyEmptySemicolonsPrinter(this, node);\n    separator == null || separator(-1);\n    const exit = this.enterDelimited();\n    this.printJoin(node.body, true, true, separator, true);\n    exit();\n    if (!this.endsWith(10)) this.newline();\n    this.rightBrace(node);\n  }\n}\nfunction classBodyEmptySemicolonsPrinter(printer, node) {\n  if (!printer.tokenMap || node.start == null || node.end == null) {\n    return null;\n  }\n  const indexes = printer.tokenMap.getIndexes(node);\n  if (!indexes) return null;\n  let k = 1;\n  let occurrenceCount = 0;\n  let nextLocIndex = 0;\n  const advanceNextLocIndex = () => {\n    while (nextLocIndex < node.body.length && node.body[nextLocIndex].start == null) {\n      nextLocIndex++;\n    }\n  };\n  advanceNextLocIndex();\n  return i => {\n    if (nextLocIndex <= i) {\n      nextLocIndex = i + 1;\n      advanceNextLocIndex();\n    }\n    const end = nextLocIndex === node.body.length ? node.end : node.body[nextLocIndex].start;\n    let tok;\n    while (k < indexes.length && printer.tokenMap.matchesOriginal(tok = printer._tokens[indexes[k]], \";\") && tok.start < end) {\n      printer.token(\";\", undefined, occurrenceCount++);\n      k++;\n    }\n  };\n}\nfunction ClassProperty(node) {\n  this.printJoin(node.decorators);\n  if (!node.static && !this.format.preserveFormat) {\n    var _node$key$loc;\n    const endLine = (_node$key$loc = node.key.loc) == null || (_node$key$loc = _node$key$loc.end) == null ? void 0 : _node$key$loc.line;\n    if (endLine) this.catchUp(endLine);\n  }\n  this.tsPrintClassMemberModifiers(node);\n  if (node.computed) {\n    this.tokenChar(91);\n    this.print(node.key);\n    this.tokenChar(93);\n  } else {\n    this._variance(node);\n    this.print(node.key);\n  }\n  if (node.optional) {\n    this.tokenChar(63);\n  }\n  if (node.definite) {\n    this.tokenChar(33);\n  }\n  this.print(node.typeAnnotation);\n  if (node.value) {\n    this.space();\n    this.tokenChar(61);\n    this.space();\n    this.print(node.value);\n  }\n  this.semicolon();\n}\nfunction ClassAccessorProperty(node) {\n  var _node$key$loc2;\n  this.printJoin(node.decorators);\n  const endLine = (_node$key$loc2 = node.key.loc) == null || (_node$key$loc2 = _node$key$loc2.end) == null ? void 0 : _node$key$loc2.line;\n  if (endLine) this.catchUp(endLine);\n  this.tsPrintClassMemberModifiers(node);\n  this.word(\"accessor\", true);\n  this.space();\n  if (node.computed) {\n    this.tokenChar(91);\n    this.print(node.key);\n    this.tokenChar(93);\n  } else {\n    this._variance(node);\n    this.print(node.key);\n  }\n  if (node.optional) {\n    this.tokenChar(63);\n  }\n  if (node.definite) {\n    this.tokenChar(33);\n  }\n  this.print(node.typeAnnotation);\n  if (node.value) {\n    this.space();\n    this.tokenChar(61);\n    this.space();\n    this.print(node.value);\n  }\n  this.semicolon();\n}\nfunction ClassPrivateProperty(node) {\n  this.printJoin(node.decorators);\n  this.tsPrintClassMemberModifiers(node);\n  this.print(node.key);\n  if (node.optional) {\n    this.tokenChar(63);\n  }\n  if (node.definite) {\n    this.tokenChar(33);\n  }\n  this.print(node.typeAnnotation);\n  if (node.value) {\n    this.space();\n    this.tokenChar(61);\n    this.space();\n    this.print(node.value);\n  }\n  this.semicolon();\n}\nfunction ClassMethod(node) {\n  this._classMethodHead(node);\n  this.space();\n  this.print(node.body);\n}\nfunction ClassPrivateMethod(node) {\n  this._classMethodHead(node);\n  this.space();\n  this.print(node.body);\n}\nfunction _classMethodHead(node) {\n  this.printJoin(node.decorators);\n  if (!this.format.preserveFormat) {\n    var _node$key$loc3;\n    const endLine = (_node$key$loc3 = node.key.loc) == null || (_node$key$loc3 = _node$key$loc3.end) == null ? void 0 : _node$key$loc3.line;\n    if (endLine) this.catchUp(endLine);\n  }\n  this.tsPrintClassMemberModifiers(node);\n  this._methodHead(node);\n}\nfunction StaticBlock(node) {\n  this.word(\"static\");\n  this.space();\n  this.tokenChar(123);\n  if (node.body.length === 0) {\n    this.tokenChar(125);\n  } else {\n    this.newline();\n    this.printSequence(node.body, true);\n    this.rightBrace(node);\n  }\n}\n\n//# sourceMappingURL=classes.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGJhYmVsL2dlbmVyYXRvci9saWIvZ2VuZXJhdG9ycy9jbGFzc2VzLmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViLDhDQUE2QztBQUM3QztBQUNBLENBQUMsRUFBQztBQUNGLDZCQUE2QjtBQUM3QixpQkFBaUI7QUFDakIsdUJBQXVCLEdBQUcsd0JBQXdCO0FBQ2xELG1CQUFtQjtBQUNuQiwwQkFBMEI7QUFDMUIsNEJBQTRCO0FBQzVCLHFCQUFxQjtBQUNyQixtQkFBbUI7QUFDbkIsd0JBQXdCO0FBQ3hCLFNBQVMsbUJBQU8sQ0FBQyxvRUFBYztBQUMvQjtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1R0FBdUc7QUFDdkcsc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSIsInNvdXJjZXMiOlsid2VicGFjazovL3JlcG8tdmlzdWFsaXplci8uL25vZGVfbW9kdWxlcy9AYmFiZWwvZ2VuZXJhdG9yL2xpYi9nZW5lcmF0b3JzL2NsYXNzZXMuanM/MWZjYSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuQ2xhc3NBY2Nlc3NvclByb3BlcnR5ID0gQ2xhc3NBY2Nlc3NvclByb3BlcnR5O1xuZXhwb3J0cy5DbGFzc0JvZHkgPSBDbGFzc0JvZHk7XG5leHBvcnRzLkNsYXNzRXhwcmVzc2lvbiA9IGV4cG9ydHMuQ2xhc3NEZWNsYXJhdGlvbiA9IENsYXNzRGVjbGFyYXRpb247XG5leHBvcnRzLkNsYXNzTWV0aG9kID0gQ2xhc3NNZXRob2Q7XG5leHBvcnRzLkNsYXNzUHJpdmF0ZU1ldGhvZCA9IENsYXNzUHJpdmF0ZU1ldGhvZDtcbmV4cG9ydHMuQ2xhc3NQcml2YXRlUHJvcGVydHkgPSBDbGFzc1ByaXZhdGVQcm9wZXJ0eTtcbmV4cG9ydHMuQ2xhc3NQcm9wZXJ0eSA9IENsYXNzUHJvcGVydHk7XG5leHBvcnRzLlN0YXRpY0Jsb2NrID0gU3RhdGljQmxvY2s7XG5leHBvcnRzLl9jbGFzc01ldGhvZEhlYWQgPSBfY2xhc3NNZXRob2RIZWFkO1xudmFyIF90ID0gcmVxdWlyZShcIkBiYWJlbC90eXBlc1wiKTtcbmNvbnN0IHtcbiAgaXNFeHBvcnREZWZhdWx0RGVjbGFyYXRpb24sXG4gIGlzRXhwb3J0TmFtZWREZWNsYXJhdGlvblxufSA9IF90O1xuZnVuY3Rpb24gQ2xhc3NEZWNsYXJhdGlvbihub2RlLCBwYXJlbnQpIHtcbiAgY29uc3QgaW5FeHBvcnQgPSBpc0V4cG9ydERlZmF1bHREZWNsYXJhdGlvbihwYXJlbnQpIHx8IGlzRXhwb3J0TmFtZWREZWNsYXJhdGlvbihwYXJlbnQpO1xuICBpZiAoIWluRXhwb3J0IHx8ICF0aGlzLl9zaG91bGRQcmludERlY29yYXRvcnNCZWZvcmVFeHBvcnQocGFyZW50KSkge1xuICAgIHRoaXMucHJpbnRKb2luKG5vZGUuZGVjb3JhdG9ycyk7XG4gIH1cbiAgaWYgKG5vZGUuZGVjbGFyZSkge1xuICAgIHRoaXMud29yZChcImRlY2xhcmVcIik7XG4gICAgdGhpcy5zcGFjZSgpO1xuICB9XG4gIGlmIChub2RlLmFic3RyYWN0KSB7XG4gICAgdGhpcy53b3JkKFwiYWJzdHJhY3RcIik7XG4gICAgdGhpcy5zcGFjZSgpO1xuICB9XG4gIHRoaXMud29yZChcImNsYXNzXCIpO1xuICBpZiAobm9kZS5pZCkge1xuICAgIHRoaXMuc3BhY2UoKTtcbiAgICB0aGlzLnByaW50KG5vZGUuaWQpO1xuICB9XG4gIHRoaXMucHJpbnQobm9kZS50eXBlUGFyYW1ldGVycyk7XG4gIGlmIChub2RlLnN1cGVyQ2xhc3MpIHtcbiAgICB0aGlzLnNwYWNlKCk7XG4gICAgdGhpcy53b3JkKFwiZXh0ZW5kc1wiKTtcbiAgICB0aGlzLnNwYWNlKCk7XG4gICAgdGhpcy5wcmludChub2RlLnN1cGVyQ2xhc3MpO1xuICAgIHRoaXMucHJpbnQobm9kZS5zdXBlclR5cGVQYXJhbWV0ZXJzKTtcbiAgfVxuICBpZiAobm9kZS5pbXBsZW1lbnRzKSB7XG4gICAgdGhpcy5zcGFjZSgpO1xuICAgIHRoaXMud29yZChcImltcGxlbWVudHNcIik7XG4gICAgdGhpcy5zcGFjZSgpO1xuICAgIHRoaXMucHJpbnRMaXN0KG5vZGUuaW1wbGVtZW50cyk7XG4gIH1cbiAgdGhpcy5zcGFjZSgpO1xuICB0aGlzLnByaW50KG5vZGUuYm9keSk7XG59XG5mdW5jdGlvbiBDbGFzc0JvZHkobm9kZSkge1xuICB0aGlzLnRva2VuQ2hhcigxMjMpO1xuICBpZiAobm9kZS5ib2R5Lmxlbmd0aCA9PT0gMCkge1xuICAgIHRoaXMudG9rZW5DaGFyKDEyNSk7XG4gIH0gZWxzZSB7XG4gICAgdGhpcy5uZXdsaW5lKCk7XG4gICAgY29uc3Qgc2VwYXJhdG9yID0gY2xhc3NCb2R5RW1wdHlTZW1pY29sb25zUHJpbnRlcih0aGlzLCBub2RlKTtcbiAgICBzZXBhcmF0b3IgPT0gbnVsbCB8fCBzZXBhcmF0b3IoLTEpO1xuICAgIGNvbnN0IGV4aXQgPSB0aGlzLmVudGVyRGVsaW1pdGVkKCk7XG4gICAgdGhpcy5wcmludEpvaW4obm9kZS5ib2R5LCB0cnVlLCB0cnVlLCBzZXBhcmF0b3IsIHRydWUpO1xuICAgIGV4aXQoKTtcbiAgICBpZiAoIXRoaXMuZW5kc1dpdGgoMTApKSB0aGlzLm5ld2xpbmUoKTtcbiAgICB0aGlzLnJpZ2h0QnJhY2Uobm9kZSk7XG4gIH1cbn1cbmZ1bmN0aW9uIGNsYXNzQm9keUVtcHR5U2VtaWNvbG9uc1ByaW50ZXIocHJpbnRlciwgbm9kZSkge1xuICBpZiAoIXByaW50ZXIudG9rZW5NYXAgfHwgbm9kZS5zdGFydCA9PSBudWxsIHx8IG5vZGUuZW5kID09IG51bGwpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICBjb25zdCBpbmRleGVzID0gcHJpbnRlci50b2tlbk1hcC5nZXRJbmRleGVzKG5vZGUpO1xuICBpZiAoIWluZGV4ZXMpIHJldHVybiBudWxsO1xuICBsZXQgayA9IDE7XG4gIGxldCBvY2N1cnJlbmNlQ291bnQgPSAwO1xuICBsZXQgbmV4dExvY0luZGV4ID0gMDtcbiAgY29uc3QgYWR2YW5jZU5leHRMb2NJbmRleCA9ICgpID0+IHtcbiAgICB3aGlsZSAobmV4dExvY0luZGV4IDwgbm9kZS5ib2R5Lmxlbmd0aCAmJiBub2RlLmJvZHlbbmV4dExvY0luZGV4XS5zdGFydCA9PSBudWxsKSB7XG4gICAgICBuZXh0TG9jSW5kZXgrKztcbiAgICB9XG4gIH07XG4gIGFkdmFuY2VOZXh0TG9jSW5kZXgoKTtcbiAgcmV0dXJuIGkgPT4ge1xuICAgIGlmIChuZXh0TG9jSW5kZXggPD0gaSkge1xuICAgICAgbmV4dExvY0luZGV4ID0gaSArIDE7XG4gICAgICBhZHZhbmNlTmV4dExvY0luZGV4KCk7XG4gICAgfVxuICAgIGNvbnN0IGVuZCA9IG5leHRMb2NJbmRleCA9PT0gbm9kZS5ib2R5Lmxlbmd0aCA/IG5vZGUuZW5kIDogbm9kZS5ib2R5W25leHRMb2NJbmRleF0uc3RhcnQ7XG4gICAgbGV0IHRvaztcbiAgICB3aGlsZSAoayA8IGluZGV4ZXMubGVuZ3RoICYmIHByaW50ZXIudG9rZW5NYXAubWF0Y2hlc09yaWdpbmFsKHRvayA9IHByaW50ZXIuX3Rva2Vuc1tpbmRleGVzW2tdXSwgXCI7XCIpICYmIHRvay5zdGFydCA8IGVuZCkge1xuICAgICAgcHJpbnRlci50b2tlbihcIjtcIiwgdW5kZWZpbmVkLCBvY2N1cnJlbmNlQ291bnQrKyk7XG4gICAgICBrKys7XG4gICAgfVxuICB9O1xufVxuZnVuY3Rpb24gQ2xhc3NQcm9wZXJ0eShub2RlKSB7XG4gIHRoaXMucHJpbnRKb2luKG5vZGUuZGVjb3JhdG9ycyk7XG4gIGlmICghbm9kZS5zdGF0aWMgJiYgIXRoaXMuZm9ybWF0LnByZXNlcnZlRm9ybWF0KSB7XG4gICAgdmFyIF9ub2RlJGtleSRsb2M7XG4gICAgY29uc3QgZW5kTGluZSA9IChfbm9kZSRrZXkkbG9jID0gbm9kZS5rZXkubG9jKSA9PSBudWxsIHx8IChfbm9kZSRrZXkkbG9jID0gX25vZGUka2V5JGxvYy5lbmQpID09IG51bGwgPyB2b2lkIDAgOiBfbm9kZSRrZXkkbG9jLmxpbmU7XG4gICAgaWYgKGVuZExpbmUpIHRoaXMuY2F0Y2hVcChlbmRMaW5lKTtcbiAgfVxuICB0aGlzLnRzUHJpbnRDbGFzc01lbWJlck1vZGlmaWVycyhub2RlKTtcbiAgaWYgKG5vZGUuY29tcHV0ZWQpIHtcbiAgICB0aGlzLnRva2VuQ2hhcig5MSk7XG4gICAgdGhpcy5wcmludChub2RlLmtleSk7XG4gICAgdGhpcy50b2tlbkNoYXIoOTMpO1xuICB9IGVsc2Uge1xuICAgIHRoaXMuX3ZhcmlhbmNlKG5vZGUpO1xuICAgIHRoaXMucHJpbnQobm9kZS5rZXkpO1xuICB9XG4gIGlmIChub2RlLm9wdGlvbmFsKSB7XG4gICAgdGhpcy50b2tlbkNoYXIoNjMpO1xuICB9XG4gIGlmIChub2RlLmRlZmluaXRlKSB7XG4gICAgdGhpcy50b2tlbkNoYXIoMzMpO1xuICB9XG4gIHRoaXMucHJpbnQobm9kZS50eXBlQW5ub3RhdGlvbik7XG4gIGlmIChub2RlLnZhbHVlKSB7XG4gICAgdGhpcy5zcGFjZSgpO1xuICAgIHRoaXMudG9rZW5DaGFyKDYxKTtcbiAgICB0aGlzLnNwYWNlKCk7XG4gICAgdGhpcy5wcmludChub2RlLnZhbHVlKTtcbiAgfVxuICB0aGlzLnNlbWljb2xvbigpO1xufVxuZnVuY3Rpb24gQ2xhc3NBY2Nlc3NvclByb3BlcnR5KG5vZGUpIHtcbiAgdmFyIF9ub2RlJGtleSRsb2MyO1xuICB0aGlzLnByaW50Sm9pbihub2RlLmRlY29yYXRvcnMpO1xuICBjb25zdCBlbmRMaW5lID0gKF9ub2RlJGtleSRsb2MyID0gbm9kZS5rZXkubG9jKSA9PSBudWxsIHx8IChfbm9kZSRrZXkkbG9jMiA9IF9ub2RlJGtleSRsb2MyLmVuZCkgPT0gbnVsbCA/IHZvaWQgMCA6IF9ub2RlJGtleSRsb2MyLmxpbmU7XG4gIGlmIChlbmRMaW5lKSB0aGlzLmNhdGNoVXAoZW5kTGluZSk7XG4gIHRoaXMudHNQcmludENsYXNzTWVtYmVyTW9kaWZpZXJzKG5vZGUpO1xuICB0aGlzLndvcmQoXCJhY2Nlc3NvclwiLCB0cnVlKTtcbiAgdGhpcy5zcGFjZSgpO1xuICBpZiAobm9kZS5jb21wdXRlZCkge1xuICAgIHRoaXMudG9rZW5DaGFyKDkxKTtcbiAgICB0aGlzLnByaW50KG5vZGUua2V5KTtcbiAgICB0aGlzLnRva2VuQ2hhcig5Myk7XG4gIH0gZWxzZSB7XG4gICAgdGhpcy5fdmFyaWFuY2Uobm9kZSk7XG4gICAgdGhpcy5wcmludChub2RlLmtleSk7XG4gIH1cbiAgaWYgKG5vZGUub3B0aW9uYWwpIHtcbiAgICB0aGlzLnRva2VuQ2hhcig2Myk7XG4gIH1cbiAgaWYgKG5vZGUuZGVmaW5pdGUpIHtcbiAgICB0aGlzLnRva2VuQ2hhcigzMyk7XG4gIH1cbiAgdGhpcy5wcmludChub2RlLnR5cGVBbm5vdGF0aW9uKTtcbiAgaWYgKG5vZGUudmFsdWUpIHtcbiAgICB0aGlzLnNwYWNlKCk7XG4gICAgdGhpcy50b2tlbkNoYXIoNjEpO1xuICAgIHRoaXMuc3BhY2UoKTtcbiAgICB0aGlzLnByaW50KG5vZGUudmFsdWUpO1xuICB9XG4gIHRoaXMuc2VtaWNvbG9uKCk7XG59XG5mdW5jdGlvbiBDbGFzc1ByaXZhdGVQcm9wZXJ0eShub2RlKSB7XG4gIHRoaXMucHJpbnRKb2luKG5vZGUuZGVjb3JhdG9ycyk7XG4gIHRoaXMudHNQcmludENsYXNzTWVtYmVyTW9kaWZpZXJzKG5vZGUpO1xuICB0aGlzLnByaW50KG5vZGUua2V5KTtcbiAgaWYgKG5vZGUub3B0aW9uYWwpIHtcbiAgICB0aGlzLnRva2VuQ2hhcig2Myk7XG4gIH1cbiAgaWYgKG5vZGUuZGVmaW5pdGUpIHtcbiAgICB0aGlzLnRva2VuQ2hhcigzMyk7XG4gIH1cbiAgdGhpcy5wcmludChub2RlLnR5cGVBbm5vdGF0aW9uKTtcbiAgaWYgKG5vZGUudmFsdWUpIHtcbiAgICB0aGlzLnNwYWNlKCk7XG4gICAgdGhpcy50b2tlbkNoYXIoNjEpO1xuICAgIHRoaXMuc3BhY2UoKTtcbiAgICB0aGlzLnByaW50KG5vZGUudmFsdWUpO1xuICB9XG4gIHRoaXMuc2VtaWNvbG9uKCk7XG59XG5mdW5jdGlvbiBDbGFzc01ldGhvZChub2RlKSB7XG4gIHRoaXMuX2NsYXNzTWV0aG9kSGVhZChub2RlKTtcbiAgdGhpcy5zcGFjZSgpO1xuICB0aGlzLnByaW50KG5vZGUuYm9keSk7XG59XG5mdW5jdGlvbiBDbGFzc1ByaXZhdGVNZXRob2Qobm9kZSkge1xuICB0aGlzLl9jbGFzc01ldGhvZEhlYWQobm9kZSk7XG4gIHRoaXMuc3BhY2UoKTtcbiAgdGhpcy5wcmludChub2RlLmJvZHkpO1xufVxuZnVuY3Rpb24gX2NsYXNzTWV0aG9kSGVhZChub2RlKSB7XG4gIHRoaXMucHJpbnRKb2luKG5vZGUuZGVjb3JhdG9ycyk7XG4gIGlmICghdGhpcy5mb3JtYXQucHJlc2VydmVGb3JtYXQpIHtcbiAgICB2YXIgX25vZGUka2V5JGxvYzM7XG4gICAgY29uc3QgZW5kTGluZSA9IChfbm9kZSRrZXkkbG9jMyA9IG5vZGUua2V5LmxvYykgPT0gbnVsbCB8fCAoX25vZGUka2V5JGxvYzMgPSBfbm9kZSRrZXkkbG9jMy5lbmQpID09IG51bGwgPyB2b2lkIDAgOiBfbm9kZSRrZXkkbG9jMy5saW5lO1xuICAgIGlmIChlbmRMaW5lKSB0aGlzLmNhdGNoVXAoZW5kTGluZSk7XG4gIH1cbiAgdGhpcy50c1ByaW50Q2xhc3NNZW1iZXJNb2RpZmllcnMobm9kZSk7XG4gIHRoaXMuX21ldGhvZEhlYWQobm9kZSk7XG59XG5mdW5jdGlvbiBTdGF0aWNCbG9jayhub2RlKSB7XG4gIHRoaXMud29yZChcInN0YXRpY1wiKTtcbiAgdGhpcy5zcGFjZSgpO1xuICB0aGlzLnRva2VuQ2hhcigxMjMpO1xuICBpZiAobm9kZS5ib2R5Lmxlbmd0aCA9PT0gMCkge1xuICAgIHRoaXMudG9rZW5DaGFyKDEyNSk7XG4gIH0gZWxzZSB7XG4gICAgdGhpcy5uZXdsaW5lKCk7XG4gICAgdGhpcy5wcmludFNlcXVlbmNlKG5vZGUuYm9keSwgdHJ1ZSk7XG4gICAgdGhpcy5yaWdodEJyYWNlKG5vZGUpO1xuICB9XG59XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNsYXNzZXMuanMubWFwXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@babel/generator/lib/generators/classes.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@babel/generator/lib/generators/deprecated.js":
/*!********************************************************************!*\
  !*** ./node_modules/@babel/generator/lib/generators/deprecated.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports.addDeprecatedGenerators = addDeprecatedGenerators;\nfunction addDeprecatedGenerators(PrinterClass) {\n  const deprecatedBabel7Generators = {\n    Noop() {},\n    TSExpressionWithTypeArguments(node) {\n      this.print(node.expression);\n      this.print(node.typeParameters);\n    },\n    DecimalLiteral(node) {\n      const raw = this.getPossibleRaw(node);\n      if (!this.format.minified && raw !== undefined) {\n        this.word(raw);\n        return;\n      }\n      this.word(node.value + \"m\");\n    },\n    RecordExpression(node) {\n      const props = node.properties;\n      let startToken;\n      let endToken;\n      if (this.format.recordAndTupleSyntaxType === \"bar\") {\n        startToken = \"{|\";\n        endToken = \"|}\";\n      } else if (this.format.recordAndTupleSyntaxType !== \"hash\" && this.format.recordAndTupleSyntaxType != null) {\n        throw new Error(`The \"recordAndTupleSyntaxType\" generator option must be \"bar\" or \"hash\" (${JSON.stringify(this.format.recordAndTupleSyntaxType)} received).`);\n      } else {\n        startToken = \"#{\";\n        endToken = \"}\";\n      }\n      this.token(startToken);\n      if (props.length) {\n        this.space();\n        this.printList(props, this.shouldPrintTrailingComma(endToken), true, true);\n        this.space();\n      }\n      this.token(endToken);\n    },\n    TupleExpression(node) {\n      const elems = node.elements;\n      const len = elems.length;\n      let startToken;\n      let endToken;\n      if (this.format.recordAndTupleSyntaxType === \"bar\") {\n        startToken = \"[|\";\n        endToken = \"|]\";\n      } else if (this.format.recordAndTupleSyntaxType === \"hash\") {\n        startToken = \"#[\";\n        endToken = \"]\";\n      } else {\n        throw new Error(`${this.format.recordAndTupleSyntaxType} is not a valid recordAndTuple syntax type`);\n      }\n      this.token(startToken);\n      for (let i = 0; i < elems.length; i++) {\n        const elem = elems[i];\n        if (elem) {\n          if (i > 0) this.space();\n          this.print(elem);\n          if (i < len - 1 || this.shouldPrintTrailingComma(endToken)) {\n            this.token(\",\", false, i);\n          }\n        }\n      }\n      this.token(endToken);\n    }\n  };\n  Object.assign(PrinterClass.prototype, deprecatedBabel7Generators);\n}\n\n//# sourceMappingURL=deprecated.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGJhYmVsL2dlbmVyYXRvci9saWIvZ2VuZXJhdG9ycy9kZXByZWNhdGVkLmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViLDhDQUE2QztBQUM3QztBQUNBLENBQUMsRUFBQztBQUNGLCtCQUErQjtBQUMvQjtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCO0FBQ3ZCLHNCQUFzQjtBQUN0QixRQUFRO0FBQ1Isb0dBQW9HLHNEQUFzRDtBQUMxSixRQUFRO0FBQ1Isd0JBQXdCO0FBQ3hCLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLFFBQVE7QUFDUiwyQkFBMkIsc0NBQXNDO0FBQ2pFO0FBQ0E7QUFDQSxzQkFBc0Isa0JBQWtCO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9yZXBvLXZpc3VhbGl6ZXIvLi9ub2RlX21vZHVsZXMvQGJhYmVsL2dlbmVyYXRvci9saWIvZ2VuZXJhdG9ycy9kZXByZWNhdGVkLmpzPzJkYTUiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLmFkZERlcHJlY2F0ZWRHZW5lcmF0b3JzID0gYWRkRGVwcmVjYXRlZEdlbmVyYXRvcnM7XG5mdW5jdGlvbiBhZGREZXByZWNhdGVkR2VuZXJhdG9ycyhQcmludGVyQ2xhc3MpIHtcbiAgY29uc3QgZGVwcmVjYXRlZEJhYmVsN0dlbmVyYXRvcnMgPSB7XG4gICAgTm9vcCgpIHt9LFxuICAgIFRTRXhwcmVzc2lvbldpdGhUeXBlQXJndW1lbnRzKG5vZGUpIHtcbiAgICAgIHRoaXMucHJpbnQobm9kZS5leHByZXNzaW9uKTtcbiAgICAgIHRoaXMucHJpbnQobm9kZS50eXBlUGFyYW1ldGVycyk7XG4gICAgfSxcbiAgICBEZWNpbWFsTGl0ZXJhbChub2RlKSB7XG4gICAgICBjb25zdCByYXcgPSB0aGlzLmdldFBvc3NpYmxlUmF3KG5vZGUpO1xuICAgICAgaWYgKCF0aGlzLmZvcm1hdC5taW5pZmllZCAmJiByYXcgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aGlzLndvcmQocmF3KTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdGhpcy53b3JkKG5vZGUudmFsdWUgKyBcIm1cIik7XG4gICAgfSxcbiAgICBSZWNvcmRFeHByZXNzaW9uKG5vZGUpIHtcbiAgICAgIGNvbnN0IHByb3BzID0gbm9kZS5wcm9wZXJ0aWVzO1xuICAgICAgbGV0IHN0YXJ0VG9rZW47XG4gICAgICBsZXQgZW5kVG9rZW47XG4gICAgICBpZiAodGhpcy5mb3JtYXQucmVjb3JkQW5kVHVwbGVTeW50YXhUeXBlID09PSBcImJhclwiKSB7XG4gICAgICAgIHN0YXJ0VG9rZW4gPSBcInt8XCI7XG4gICAgICAgIGVuZFRva2VuID0gXCJ8fVwiO1xuICAgICAgfSBlbHNlIGlmICh0aGlzLmZvcm1hdC5yZWNvcmRBbmRUdXBsZVN5bnRheFR5cGUgIT09IFwiaGFzaFwiICYmIHRoaXMuZm9ybWF0LnJlY29yZEFuZFR1cGxlU3ludGF4VHlwZSAhPSBudWxsKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgVGhlIFwicmVjb3JkQW5kVHVwbGVTeW50YXhUeXBlXCIgZ2VuZXJhdG9yIG9wdGlvbiBtdXN0IGJlIFwiYmFyXCIgb3IgXCJoYXNoXCIgKCR7SlNPTi5zdHJpbmdpZnkodGhpcy5mb3JtYXQucmVjb3JkQW5kVHVwbGVTeW50YXhUeXBlKX0gcmVjZWl2ZWQpLmApO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc3RhcnRUb2tlbiA9IFwiI3tcIjtcbiAgICAgICAgZW5kVG9rZW4gPSBcIn1cIjtcbiAgICAgIH1cbiAgICAgIHRoaXMudG9rZW4oc3RhcnRUb2tlbik7XG4gICAgICBpZiAocHJvcHMubGVuZ3RoKSB7XG4gICAgICAgIHRoaXMuc3BhY2UoKTtcbiAgICAgICAgdGhpcy5wcmludExpc3QocHJvcHMsIHRoaXMuc2hvdWxkUHJpbnRUcmFpbGluZ0NvbW1hKGVuZFRva2VuKSwgdHJ1ZSwgdHJ1ZSk7XG4gICAgICAgIHRoaXMuc3BhY2UoKTtcbiAgICAgIH1cbiAgICAgIHRoaXMudG9rZW4oZW5kVG9rZW4pO1xuICAgIH0sXG4gICAgVHVwbGVFeHByZXNzaW9uKG5vZGUpIHtcbiAgICAgIGNvbnN0IGVsZW1zID0gbm9kZS5lbGVtZW50cztcbiAgICAgIGNvbnN0IGxlbiA9IGVsZW1zLmxlbmd0aDtcbiAgICAgIGxldCBzdGFydFRva2VuO1xuICAgICAgbGV0IGVuZFRva2VuO1xuICAgICAgaWYgKHRoaXMuZm9ybWF0LnJlY29yZEFuZFR1cGxlU3ludGF4VHlwZSA9PT0gXCJiYXJcIikge1xuICAgICAgICBzdGFydFRva2VuID0gXCJbfFwiO1xuICAgICAgICBlbmRUb2tlbiA9IFwifF1cIjtcbiAgICAgIH0gZWxzZSBpZiAodGhpcy5mb3JtYXQucmVjb3JkQW5kVHVwbGVTeW50YXhUeXBlID09PSBcImhhc2hcIikge1xuICAgICAgICBzdGFydFRva2VuID0gXCIjW1wiO1xuICAgICAgICBlbmRUb2tlbiA9IFwiXVwiO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGAke3RoaXMuZm9ybWF0LnJlY29yZEFuZFR1cGxlU3ludGF4VHlwZX0gaXMgbm90IGEgdmFsaWQgcmVjb3JkQW5kVHVwbGUgc3ludGF4IHR5cGVgKTtcbiAgICAgIH1cbiAgICAgIHRoaXMudG9rZW4oc3RhcnRUb2tlbik7XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGVsZW1zLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IGVsZW0gPSBlbGVtc1tpXTtcbiAgICAgICAgaWYgKGVsZW0pIHtcbiAgICAgICAgICBpZiAoaSA+IDApIHRoaXMuc3BhY2UoKTtcbiAgICAgICAgICB0aGlzLnByaW50KGVsZW0pO1xuICAgICAgICAgIGlmIChpIDwgbGVuIC0gMSB8fCB0aGlzLnNob3VsZFByaW50VHJhaWxpbmdDb21tYShlbmRUb2tlbikpIHtcbiAgICAgICAgICAgIHRoaXMudG9rZW4oXCIsXCIsIGZhbHNlLCBpKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHRoaXMudG9rZW4oZW5kVG9rZW4pO1xuICAgIH1cbiAgfTtcbiAgT2JqZWN0LmFzc2lnbihQcmludGVyQ2xhc3MucHJvdG90eXBlLCBkZXByZWNhdGVkQmFiZWw3R2VuZXJhdG9ycyk7XG59XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWRlcHJlY2F0ZWQuanMubWFwXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@babel/generator/lib/generators/deprecated.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@babel/generator/lib/generators/expressions.js":
/*!*********************************************************************!*\
  !*** ./node_modules/@babel/generator/lib/generators/expressions.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports.LogicalExpression = exports.BinaryExpression = exports.AssignmentExpression = AssignmentExpression;\nexports.AssignmentPattern = AssignmentPattern;\nexports.AwaitExpression = AwaitExpression;\nexports.BindExpression = BindExpression;\nexports.CallExpression = CallExpression;\nexports.ConditionalExpression = ConditionalExpression;\nexports.Decorator = Decorator;\nexports.DoExpression = DoExpression;\nexports.EmptyStatement = EmptyStatement;\nexports.ExpressionStatement = ExpressionStatement;\nexports.Import = Import;\nexports.MemberExpression = MemberExpression;\nexports.MetaProperty = MetaProperty;\nexports.ModuleExpression = ModuleExpression;\nexports.NewExpression = NewExpression;\nexports.OptionalCallExpression = OptionalCallExpression;\nexports.OptionalMemberExpression = OptionalMemberExpression;\nexports.ParenthesizedExpression = ParenthesizedExpression;\nexports.PrivateName = PrivateName;\nexports.SequenceExpression = SequenceExpression;\nexports.Super = Super;\nexports.ThisExpression = ThisExpression;\nexports.UnaryExpression = UnaryExpression;\nexports.UpdateExpression = UpdateExpression;\nexports.V8IntrinsicIdentifier = V8IntrinsicIdentifier;\nexports.YieldExpression = YieldExpression;\nexports._shouldPrintDecoratorsBeforeExport = _shouldPrintDecoratorsBeforeExport;\nvar _t = __webpack_require__(/*! @babel/types */ \"(ssr)/./node_modules/@babel/types/lib/index.js\");\nvar _index = __webpack_require__(/*! ../node/index.js */ \"(ssr)/./node_modules/@babel/generator/lib/node/index.js\");\nconst {\n  isCallExpression,\n  isLiteral,\n  isMemberExpression,\n  isNewExpression,\n  isPattern\n} = _t;\nfunction UnaryExpression(node) {\n  const {\n    operator\n  } = node;\n  if (operator === \"void\" || operator === \"delete\" || operator === \"typeof\" || operator === \"throw\") {\n    this.word(operator);\n    this.space();\n  } else {\n    this.token(operator);\n  }\n  this.print(node.argument);\n}\nfunction DoExpression(node) {\n  if (node.async) {\n    this.word(\"async\", true);\n    this.space();\n  }\n  this.word(\"do\");\n  this.space();\n  this.print(node.body);\n}\nfunction ParenthesizedExpression(node) {\n  this.tokenChar(40);\n  const exit = this.enterDelimited();\n  this.print(node.expression);\n  exit();\n  this.rightParens(node);\n}\nfunction UpdateExpression(node) {\n  if (node.prefix) {\n    this.token(node.operator);\n    this.print(node.argument);\n  } else {\n    this.print(node.argument, true);\n    this.token(node.operator);\n  }\n}\nfunction ConditionalExpression(node) {\n  this.print(node.test);\n  this.space();\n  this.tokenChar(63);\n  this.space();\n  this.print(node.consequent);\n  this.space();\n  this.tokenChar(58);\n  this.space();\n  this.print(node.alternate);\n}\nfunction NewExpression(node, parent) {\n  this.word(\"new\");\n  this.space();\n  this.print(node.callee);\n  if (this.format.minified && node.arguments.length === 0 && !node.optional && !isCallExpression(parent, {\n    callee: node\n  }) && !isMemberExpression(parent) && !isNewExpression(parent)) {\n    return;\n  }\n  this.print(node.typeArguments);\n  this.print(node.typeParameters);\n  if (node.optional) {\n    this.token(\"?.\");\n  }\n  if (node.arguments.length === 0 && this.tokenMap && !this.tokenMap.endMatches(node, \")\")) {\n    return;\n  }\n  this.tokenChar(40);\n  const exit = this.enterDelimited();\n  this.printList(node.arguments, this.shouldPrintTrailingComma(\")\"));\n  exit();\n  this.rightParens(node);\n}\nfunction SequenceExpression(node) {\n  this.printList(node.expressions);\n}\nfunction ThisExpression() {\n  this.word(\"this\");\n}\nfunction Super() {\n  this.word(\"super\");\n}\nfunction _shouldPrintDecoratorsBeforeExport(node) {\n  if (typeof this.format.decoratorsBeforeExport === \"boolean\") {\n    return this.format.decoratorsBeforeExport;\n  }\n  return typeof node.start === \"number\" && node.start === node.declaration.start;\n}\nfunction Decorator(node) {\n  this.tokenChar(64);\n  this.print(node.expression);\n  this.newline();\n}\nfunction OptionalMemberExpression(node) {\n  let {\n    computed\n  } = node;\n  const {\n    optional,\n    property\n  } = node;\n  this.print(node.object);\n  if (!computed && isMemberExpression(property)) {\n    throw new TypeError(\"Got a MemberExpression for MemberExpression property\");\n  }\n  if (isLiteral(property) && typeof property.value === \"number\") {\n    computed = true;\n  }\n  if (optional) {\n    this.token(\"?.\");\n  }\n  if (computed) {\n    this.tokenChar(91);\n    this.print(property);\n    this.tokenChar(93);\n  } else {\n    if (!optional) {\n      this.tokenChar(46);\n    }\n    this.print(property);\n  }\n}\nfunction OptionalCallExpression(node) {\n  this.print(node.callee);\n  this.print(node.typeParameters);\n  if (node.optional) {\n    this.token(\"?.\");\n  }\n  this.print(node.typeArguments);\n  this.tokenChar(40);\n  const exit = this.enterDelimited();\n  this.printList(node.arguments);\n  exit();\n  this.rightParens(node);\n}\nfunction CallExpression(node) {\n  this.print(node.callee);\n  this.print(node.typeArguments);\n  this.print(node.typeParameters);\n  this.tokenChar(40);\n  const exit = this.enterDelimited();\n  this.printList(node.arguments, this.shouldPrintTrailingComma(\")\"));\n  exit();\n  this.rightParens(node);\n}\nfunction Import() {\n  this.word(\"import\");\n}\nfunction AwaitExpression(node) {\n  this.word(\"await\");\n  this.space();\n  this.print(node.argument);\n}\nfunction YieldExpression(node) {\n  if (node.delegate) {\n    this.word(\"yield\", true);\n    this.tokenChar(42);\n    if (node.argument) {\n      this.space();\n      this.print(node.argument);\n    }\n  } else if (node.argument) {\n    this.word(\"yield\", true);\n    this.space();\n    this.print(node.argument);\n  } else {\n    this.word(\"yield\");\n  }\n}\nfunction EmptyStatement() {\n  this.semicolon(true);\n}\nfunction ExpressionStatement(node) {\n  this.tokenContext |= _index.TokenContext.expressionStatement;\n  this.print(node.expression);\n  this.semicolon();\n}\nfunction AssignmentPattern(node) {\n  this.print(node.left);\n  if (node.left.type === \"Identifier\" || isPattern(node.left)) {\n    if (node.left.optional) this.tokenChar(63);\n    this.print(node.left.typeAnnotation);\n  }\n  this.space();\n  this.tokenChar(61);\n  this.space();\n  this.print(node.right);\n}\nfunction AssignmentExpression(node) {\n  this.print(node.left);\n  this.space();\n  if (node.operator === \"in\" || node.operator === \"instanceof\") {\n    this.word(node.operator);\n  } else {\n    this.token(node.operator);\n    this._endsWithDiv = node.operator === \"/\";\n  }\n  this.space();\n  this.print(node.right);\n}\nfunction BindExpression(node) {\n  this.print(node.object);\n  this.token(\"::\");\n  this.print(node.callee);\n}\nfunction MemberExpression(node) {\n  this.print(node.object);\n  if (!node.computed && isMemberExpression(node.property)) {\n    throw new TypeError(\"Got a MemberExpression for MemberExpression property\");\n  }\n  let computed = node.computed;\n  if (isLiteral(node.property) && typeof node.property.value === \"number\") {\n    computed = true;\n  }\n  if (computed) {\n    const exit = this.enterDelimited();\n    this.tokenChar(91);\n    this.print(node.property);\n    this.tokenChar(93);\n    exit();\n  } else {\n    this.tokenChar(46);\n    this.print(node.property);\n  }\n}\nfunction MetaProperty(node) {\n  this.print(node.meta);\n  this.tokenChar(46);\n  this.print(node.property);\n}\nfunction PrivateName(node) {\n  this.tokenChar(35);\n  this.print(node.id);\n}\nfunction V8IntrinsicIdentifier(node) {\n  this.tokenChar(37);\n  this.word(node.name);\n}\nfunction ModuleExpression(node) {\n  this.word(\"module\", true);\n  this.space();\n  this.tokenChar(123);\n  this.indent();\n  const {\n    body\n  } = node;\n  if (body.body.length || body.directives.length) {\n    this.newline();\n  }\n  this.print(body);\n  this.dedent();\n  this.rightBrace(node);\n}\n\n//# sourceMappingURL=expressions.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGJhYmVsL2dlbmVyYXRvci9saWIvZ2VuZXJhdG9ycy9leHByZXNzaW9ucy5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYiw4Q0FBNkM7QUFDN0M7QUFDQSxDQUFDLEVBQUM7QUFDRix5QkFBeUIsR0FBRyx3QkFBd0IsR0FBRyw0QkFBNEI7QUFDbkYseUJBQXlCO0FBQ3pCLHVCQUF1QjtBQUN2QixzQkFBc0I7QUFDdEIsc0JBQXNCO0FBQ3RCLDZCQUE2QjtBQUM3QixpQkFBaUI7QUFDakIsb0JBQW9CO0FBQ3BCLHNCQUFzQjtBQUN0QiwyQkFBMkI7QUFDM0IsY0FBYztBQUNkLHdCQUF3QjtBQUN4QixvQkFBb0I7QUFDcEIsd0JBQXdCO0FBQ3hCLHFCQUFxQjtBQUNyQiw4QkFBOEI7QUFDOUIsZ0NBQWdDO0FBQ2hDLCtCQUErQjtBQUMvQixtQkFBbUI7QUFDbkIsMEJBQTBCO0FBQzFCLGFBQWE7QUFDYixzQkFBc0I7QUFDdEIsdUJBQXVCO0FBQ3ZCLHdCQUF3QjtBQUN4Qiw2QkFBNkI7QUFDN0IsdUJBQXVCO0FBQ3ZCLDBDQUEwQztBQUMxQyxTQUFTLG1CQUFPLENBQUMsb0VBQWM7QUFDL0IsYUFBYSxtQkFBTyxDQUFDLGlGQUFrQjtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSIsInNvdXJjZXMiOlsid2VicGFjazovL3JlcG8tdmlzdWFsaXplci8uL25vZGVfbW9kdWxlcy9AYmFiZWwvZ2VuZXJhdG9yL2xpYi9nZW5lcmF0b3JzL2V4cHJlc3Npb25zLmpzP2EwMWMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLkxvZ2ljYWxFeHByZXNzaW9uID0gZXhwb3J0cy5CaW5hcnlFeHByZXNzaW9uID0gZXhwb3J0cy5Bc3NpZ25tZW50RXhwcmVzc2lvbiA9IEFzc2lnbm1lbnRFeHByZXNzaW9uO1xuZXhwb3J0cy5Bc3NpZ25tZW50UGF0dGVybiA9IEFzc2lnbm1lbnRQYXR0ZXJuO1xuZXhwb3J0cy5Bd2FpdEV4cHJlc3Npb24gPSBBd2FpdEV4cHJlc3Npb247XG5leHBvcnRzLkJpbmRFeHByZXNzaW9uID0gQmluZEV4cHJlc3Npb247XG5leHBvcnRzLkNhbGxFeHByZXNzaW9uID0gQ2FsbEV4cHJlc3Npb247XG5leHBvcnRzLkNvbmRpdGlvbmFsRXhwcmVzc2lvbiA9IENvbmRpdGlvbmFsRXhwcmVzc2lvbjtcbmV4cG9ydHMuRGVjb3JhdG9yID0gRGVjb3JhdG9yO1xuZXhwb3J0cy5Eb0V4cHJlc3Npb24gPSBEb0V4cHJlc3Npb247XG5leHBvcnRzLkVtcHR5U3RhdGVtZW50ID0gRW1wdHlTdGF0ZW1lbnQ7XG5leHBvcnRzLkV4cHJlc3Npb25TdGF0ZW1lbnQgPSBFeHByZXNzaW9uU3RhdGVtZW50O1xuZXhwb3J0cy5JbXBvcnQgPSBJbXBvcnQ7XG5leHBvcnRzLk1lbWJlckV4cHJlc3Npb24gPSBNZW1iZXJFeHByZXNzaW9uO1xuZXhwb3J0cy5NZXRhUHJvcGVydHkgPSBNZXRhUHJvcGVydHk7XG5leHBvcnRzLk1vZHVsZUV4cHJlc3Npb24gPSBNb2R1bGVFeHByZXNzaW9uO1xuZXhwb3J0cy5OZXdFeHByZXNzaW9uID0gTmV3RXhwcmVzc2lvbjtcbmV4cG9ydHMuT3B0aW9uYWxDYWxsRXhwcmVzc2lvbiA9IE9wdGlvbmFsQ2FsbEV4cHJlc3Npb247XG5leHBvcnRzLk9wdGlvbmFsTWVtYmVyRXhwcmVzc2lvbiA9IE9wdGlvbmFsTWVtYmVyRXhwcmVzc2lvbjtcbmV4cG9ydHMuUGFyZW50aGVzaXplZEV4cHJlc3Npb24gPSBQYXJlbnRoZXNpemVkRXhwcmVzc2lvbjtcbmV4cG9ydHMuUHJpdmF0ZU5hbWUgPSBQcml2YXRlTmFtZTtcbmV4cG9ydHMuU2VxdWVuY2VFeHByZXNzaW9uID0gU2VxdWVuY2VFeHByZXNzaW9uO1xuZXhwb3J0cy5TdXBlciA9IFN1cGVyO1xuZXhwb3J0cy5UaGlzRXhwcmVzc2lvbiA9IFRoaXNFeHByZXNzaW9uO1xuZXhwb3J0cy5VbmFyeUV4cHJlc3Npb24gPSBVbmFyeUV4cHJlc3Npb247XG5leHBvcnRzLlVwZGF0ZUV4cHJlc3Npb24gPSBVcGRhdGVFeHByZXNzaW9uO1xuZXhwb3J0cy5WOEludHJpbnNpY0lkZW50aWZpZXIgPSBWOEludHJpbnNpY0lkZW50aWZpZXI7XG5leHBvcnRzLllpZWxkRXhwcmVzc2lvbiA9IFlpZWxkRXhwcmVzc2lvbjtcbmV4cG9ydHMuX3Nob3VsZFByaW50RGVjb3JhdG9yc0JlZm9yZUV4cG9ydCA9IF9zaG91bGRQcmludERlY29yYXRvcnNCZWZvcmVFeHBvcnQ7XG52YXIgX3QgPSByZXF1aXJlKFwiQGJhYmVsL3R5cGVzXCIpO1xudmFyIF9pbmRleCA9IHJlcXVpcmUoXCIuLi9ub2RlL2luZGV4LmpzXCIpO1xuY29uc3Qge1xuICBpc0NhbGxFeHByZXNzaW9uLFxuICBpc0xpdGVyYWwsXG4gIGlzTWVtYmVyRXhwcmVzc2lvbixcbiAgaXNOZXdFeHByZXNzaW9uLFxuICBpc1BhdHRlcm5cbn0gPSBfdDtcbmZ1bmN0aW9uIFVuYXJ5RXhwcmVzc2lvbihub2RlKSB7XG4gIGNvbnN0IHtcbiAgICBvcGVyYXRvclxuICB9ID0gbm9kZTtcbiAgaWYgKG9wZXJhdG9yID09PSBcInZvaWRcIiB8fCBvcGVyYXRvciA9PT0gXCJkZWxldGVcIiB8fCBvcGVyYXRvciA9PT0gXCJ0eXBlb2ZcIiB8fCBvcGVyYXRvciA9PT0gXCJ0aHJvd1wiKSB7XG4gICAgdGhpcy53b3JkKG9wZXJhdG9yKTtcbiAgICB0aGlzLnNwYWNlKCk7XG4gIH0gZWxzZSB7XG4gICAgdGhpcy50b2tlbihvcGVyYXRvcik7XG4gIH1cbiAgdGhpcy5wcmludChub2RlLmFyZ3VtZW50KTtcbn1cbmZ1bmN0aW9uIERvRXhwcmVzc2lvbihub2RlKSB7XG4gIGlmIChub2RlLmFzeW5jKSB7XG4gICAgdGhpcy53b3JkKFwiYXN5bmNcIiwgdHJ1ZSk7XG4gICAgdGhpcy5zcGFjZSgpO1xuICB9XG4gIHRoaXMud29yZChcImRvXCIpO1xuICB0aGlzLnNwYWNlKCk7XG4gIHRoaXMucHJpbnQobm9kZS5ib2R5KTtcbn1cbmZ1bmN0aW9uIFBhcmVudGhlc2l6ZWRFeHByZXNzaW9uKG5vZGUpIHtcbiAgdGhpcy50b2tlbkNoYXIoNDApO1xuICBjb25zdCBleGl0ID0gdGhpcy5lbnRlckRlbGltaXRlZCgpO1xuICB0aGlzLnByaW50KG5vZGUuZXhwcmVzc2lvbik7XG4gIGV4aXQoKTtcbiAgdGhpcy5yaWdodFBhcmVucyhub2RlKTtcbn1cbmZ1bmN0aW9uIFVwZGF0ZUV4cHJlc3Npb24obm9kZSkge1xuICBpZiAobm9kZS5wcmVmaXgpIHtcbiAgICB0aGlzLnRva2VuKG5vZGUub3BlcmF0b3IpO1xuICAgIHRoaXMucHJpbnQobm9kZS5hcmd1bWVudCk7XG4gIH0gZWxzZSB7XG4gICAgdGhpcy5wcmludChub2RlLmFyZ3VtZW50LCB0cnVlKTtcbiAgICB0aGlzLnRva2VuKG5vZGUub3BlcmF0b3IpO1xuICB9XG59XG5mdW5jdGlvbiBDb25kaXRpb25hbEV4cHJlc3Npb24obm9kZSkge1xuICB0aGlzLnByaW50KG5vZGUudGVzdCk7XG4gIHRoaXMuc3BhY2UoKTtcbiAgdGhpcy50b2tlbkNoYXIoNjMpO1xuICB0aGlzLnNwYWNlKCk7XG4gIHRoaXMucHJpbnQobm9kZS5jb25zZXF1ZW50KTtcbiAgdGhpcy5zcGFjZSgpO1xuICB0aGlzLnRva2VuQ2hhcig1OCk7XG4gIHRoaXMuc3BhY2UoKTtcbiAgdGhpcy5wcmludChub2RlLmFsdGVybmF0ZSk7XG59XG5mdW5jdGlvbiBOZXdFeHByZXNzaW9uKG5vZGUsIHBhcmVudCkge1xuICB0aGlzLndvcmQoXCJuZXdcIik7XG4gIHRoaXMuc3BhY2UoKTtcbiAgdGhpcy5wcmludChub2RlLmNhbGxlZSk7XG4gIGlmICh0aGlzLmZvcm1hdC5taW5pZmllZCAmJiBub2RlLmFyZ3VtZW50cy5sZW5ndGggPT09IDAgJiYgIW5vZGUub3B0aW9uYWwgJiYgIWlzQ2FsbEV4cHJlc3Npb24ocGFyZW50LCB7XG4gICAgY2FsbGVlOiBub2RlXG4gIH0pICYmICFpc01lbWJlckV4cHJlc3Npb24ocGFyZW50KSAmJiAhaXNOZXdFeHByZXNzaW9uKHBhcmVudCkpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgdGhpcy5wcmludChub2RlLnR5cGVBcmd1bWVudHMpO1xuICB0aGlzLnByaW50KG5vZGUudHlwZVBhcmFtZXRlcnMpO1xuICBpZiAobm9kZS5vcHRpb25hbCkge1xuICAgIHRoaXMudG9rZW4oXCI/LlwiKTtcbiAgfVxuICBpZiAobm9kZS5hcmd1bWVudHMubGVuZ3RoID09PSAwICYmIHRoaXMudG9rZW5NYXAgJiYgIXRoaXMudG9rZW5NYXAuZW5kTWF0Y2hlcyhub2RlLCBcIilcIikpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgdGhpcy50b2tlbkNoYXIoNDApO1xuICBjb25zdCBleGl0ID0gdGhpcy5lbnRlckRlbGltaXRlZCgpO1xuICB0aGlzLnByaW50TGlzdChub2RlLmFyZ3VtZW50cywgdGhpcy5zaG91bGRQcmludFRyYWlsaW5nQ29tbWEoXCIpXCIpKTtcbiAgZXhpdCgpO1xuICB0aGlzLnJpZ2h0UGFyZW5zKG5vZGUpO1xufVxuZnVuY3Rpb24gU2VxdWVuY2VFeHByZXNzaW9uKG5vZGUpIHtcbiAgdGhpcy5wcmludExpc3Qobm9kZS5leHByZXNzaW9ucyk7XG59XG5mdW5jdGlvbiBUaGlzRXhwcmVzc2lvbigpIHtcbiAgdGhpcy53b3JkKFwidGhpc1wiKTtcbn1cbmZ1bmN0aW9uIFN1cGVyKCkge1xuICB0aGlzLndvcmQoXCJzdXBlclwiKTtcbn1cbmZ1bmN0aW9uIF9zaG91bGRQcmludERlY29yYXRvcnNCZWZvcmVFeHBvcnQobm9kZSkge1xuICBpZiAodHlwZW9mIHRoaXMuZm9ybWF0LmRlY29yYXRvcnNCZWZvcmVFeHBvcnQgPT09IFwiYm9vbGVhblwiKSB7XG4gICAgcmV0dXJuIHRoaXMuZm9ybWF0LmRlY29yYXRvcnNCZWZvcmVFeHBvcnQ7XG4gIH1cbiAgcmV0dXJuIHR5cGVvZiBub2RlLnN0YXJ0ID09PSBcIm51bWJlclwiICYmIG5vZGUuc3RhcnQgPT09IG5vZGUuZGVjbGFyYXRpb24uc3RhcnQ7XG59XG5mdW5jdGlvbiBEZWNvcmF0b3Iobm9kZSkge1xuICB0aGlzLnRva2VuQ2hhcig2NCk7XG4gIHRoaXMucHJpbnQobm9kZS5leHByZXNzaW9uKTtcbiAgdGhpcy5uZXdsaW5lKCk7XG59XG5mdW5jdGlvbiBPcHRpb25hbE1lbWJlckV4cHJlc3Npb24obm9kZSkge1xuICBsZXQge1xuICAgIGNvbXB1dGVkXG4gIH0gPSBub2RlO1xuICBjb25zdCB7XG4gICAgb3B0aW9uYWwsXG4gICAgcHJvcGVydHlcbiAgfSA9IG5vZGU7XG4gIHRoaXMucHJpbnQobm9kZS5vYmplY3QpO1xuICBpZiAoIWNvbXB1dGVkICYmIGlzTWVtYmVyRXhwcmVzc2lvbihwcm9wZXJ0eSkpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiR290IGEgTWVtYmVyRXhwcmVzc2lvbiBmb3IgTWVtYmVyRXhwcmVzc2lvbiBwcm9wZXJ0eVwiKTtcbiAgfVxuICBpZiAoaXNMaXRlcmFsKHByb3BlcnR5KSAmJiB0eXBlb2YgcHJvcGVydHkudmFsdWUgPT09IFwibnVtYmVyXCIpIHtcbiAgICBjb21wdXRlZCA9IHRydWU7XG4gIH1cbiAgaWYgKG9wdGlvbmFsKSB7XG4gICAgdGhpcy50b2tlbihcIj8uXCIpO1xuICB9XG4gIGlmIChjb21wdXRlZCkge1xuICAgIHRoaXMudG9rZW5DaGFyKDkxKTtcbiAgICB0aGlzLnByaW50KHByb3BlcnR5KTtcbiAgICB0aGlzLnRva2VuQ2hhcig5Myk7XG4gIH0gZWxzZSB7XG4gICAgaWYgKCFvcHRpb25hbCkge1xuICAgICAgdGhpcy50b2tlbkNoYXIoNDYpO1xuICAgIH1cbiAgICB0aGlzLnByaW50KHByb3BlcnR5KTtcbiAgfVxufVxuZnVuY3Rpb24gT3B0aW9uYWxDYWxsRXhwcmVzc2lvbihub2RlKSB7XG4gIHRoaXMucHJpbnQobm9kZS5jYWxsZWUpO1xuICB0aGlzLnByaW50KG5vZGUudHlwZVBhcmFtZXRlcnMpO1xuICBpZiAobm9kZS5vcHRpb25hbCkge1xuICAgIHRoaXMudG9rZW4oXCI/LlwiKTtcbiAgfVxuICB0aGlzLnByaW50KG5vZGUudHlwZUFyZ3VtZW50cyk7XG4gIHRoaXMudG9rZW5DaGFyKDQwKTtcbiAgY29uc3QgZXhpdCA9IHRoaXMuZW50ZXJEZWxpbWl0ZWQoKTtcbiAgdGhpcy5wcmludExpc3Qobm9kZS5hcmd1bWVudHMpO1xuICBleGl0KCk7XG4gIHRoaXMucmlnaHRQYXJlbnMobm9kZSk7XG59XG5mdW5jdGlvbiBDYWxsRXhwcmVzc2lvbihub2RlKSB7XG4gIHRoaXMucHJpbnQobm9kZS5jYWxsZWUpO1xuICB0aGlzLnByaW50KG5vZGUudHlwZUFyZ3VtZW50cyk7XG4gIHRoaXMucHJpbnQobm9kZS50eXBlUGFyYW1ldGVycyk7XG4gIHRoaXMudG9rZW5DaGFyKDQwKTtcbiAgY29uc3QgZXhpdCA9IHRoaXMuZW50ZXJEZWxpbWl0ZWQoKTtcbiAgdGhpcy5wcmludExpc3Qobm9kZS5hcmd1bWVudHMsIHRoaXMuc2hvdWxkUHJpbnRUcmFpbGluZ0NvbW1hKFwiKVwiKSk7XG4gIGV4aXQoKTtcbiAgdGhpcy5yaWdodFBhcmVucyhub2RlKTtcbn1cbmZ1bmN0aW9uIEltcG9ydCgpIHtcbiAgdGhpcy53b3JkKFwiaW1wb3J0XCIpO1xufVxuZnVuY3Rpb24gQXdhaXRFeHByZXNzaW9uKG5vZGUpIHtcbiAgdGhpcy53b3JkKFwiYXdhaXRcIik7XG4gIHRoaXMuc3BhY2UoKTtcbiAgdGhpcy5wcmludChub2RlLmFyZ3VtZW50KTtcbn1cbmZ1bmN0aW9uIFlpZWxkRXhwcmVzc2lvbihub2RlKSB7XG4gIGlmIChub2RlLmRlbGVnYXRlKSB7XG4gICAgdGhpcy53b3JkKFwieWllbGRcIiwgdHJ1ZSk7XG4gICAgdGhpcy50b2tlbkNoYXIoNDIpO1xuICAgIGlmIChub2RlLmFyZ3VtZW50KSB7XG4gICAgICB0aGlzLnNwYWNlKCk7XG4gICAgICB0aGlzLnByaW50KG5vZGUuYXJndW1lbnQpO1xuICAgIH1cbiAgfSBlbHNlIGlmIChub2RlLmFyZ3VtZW50KSB7XG4gICAgdGhpcy53b3JkKFwieWllbGRcIiwgdHJ1ZSk7XG4gICAgdGhpcy5zcGFjZSgpO1xuICAgIHRoaXMucHJpbnQobm9kZS5hcmd1bWVudCk7XG4gIH0gZWxzZSB7XG4gICAgdGhpcy53b3JkKFwieWllbGRcIik7XG4gIH1cbn1cbmZ1bmN0aW9uIEVtcHR5U3RhdGVtZW50KCkge1xuICB0aGlzLnNlbWljb2xvbih0cnVlKTtcbn1cbmZ1bmN0aW9uIEV4cHJlc3Npb25TdGF0ZW1lbnQobm9kZSkge1xuICB0aGlzLnRva2VuQ29udGV4dCB8PSBfaW5kZXguVG9rZW5Db250ZXh0LmV4cHJlc3Npb25TdGF0ZW1lbnQ7XG4gIHRoaXMucHJpbnQobm9kZS5leHByZXNzaW9uKTtcbiAgdGhpcy5zZW1pY29sb24oKTtcbn1cbmZ1bmN0aW9uIEFzc2lnbm1lbnRQYXR0ZXJuKG5vZGUpIHtcbiAgdGhpcy5wcmludChub2RlLmxlZnQpO1xuICBpZiAobm9kZS5sZWZ0LnR5cGUgPT09IFwiSWRlbnRpZmllclwiIHx8IGlzUGF0dGVybihub2RlLmxlZnQpKSB7XG4gICAgaWYgKG5vZGUubGVmdC5vcHRpb25hbCkgdGhpcy50b2tlbkNoYXIoNjMpO1xuICAgIHRoaXMucHJpbnQobm9kZS5sZWZ0LnR5cGVBbm5vdGF0aW9uKTtcbiAgfVxuICB0aGlzLnNwYWNlKCk7XG4gIHRoaXMudG9rZW5DaGFyKDYxKTtcbiAgdGhpcy5zcGFjZSgpO1xuICB0aGlzLnByaW50KG5vZGUucmlnaHQpO1xufVxuZnVuY3Rpb24gQXNzaWdubWVudEV4cHJlc3Npb24obm9kZSkge1xuICB0aGlzLnByaW50KG5vZGUubGVmdCk7XG4gIHRoaXMuc3BhY2UoKTtcbiAgaWYgKG5vZGUub3BlcmF0b3IgPT09IFwiaW5cIiB8fCBub2RlLm9wZXJhdG9yID09PSBcImluc3RhbmNlb2ZcIikge1xuICAgIHRoaXMud29yZChub2RlLm9wZXJhdG9yKTtcbiAgfSBlbHNlIHtcbiAgICB0aGlzLnRva2VuKG5vZGUub3BlcmF0b3IpO1xuICAgIHRoaXMuX2VuZHNXaXRoRGl2ID0gbm9kZS5vcGVyYXRvciA9PT0gXCIvXCI7XG4gIH1cbiAgdGhpcy5zcGFjZSgpO1xuICB0aGlzLnByaW50KG5vZGUucmlnaHQpO1xufVxuZnVuY3Rpb24gQmluZEV4cHJlc3Npb24obm9kZSkge1xuICB0aGlzLnByaW50KG5vZGUub2JqZWN0KTtcbiAgdGhpcy50b2tlbihcIjo6XCIpO1xuICB0aGlzLnByaW50KG5vZGUuY2FsbGVlKTtcbn1cbmZ1bmN0aW9uIE1lbWJlckV4cHJlc3Npb24obm9kZSkge1xuICB0aGlzLnByaW50KG5vZGUub2JqZWN0KTtcbiAgaWYgKCFub2RlLmNvbXB1dGVkICYmIGlzTWVtYmVyRXhwcmVzc2lvbihub2RlLnByb3BlcnR5KSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJHb3QgYSBNZW1iZXJFeHByZXNzaW9uIGZvciBNZW1iZXJFeHByZXNzaW9uIHByb3BlcnR5XCIpO1xuICB9XG4gIGxldCBjb21wdXRlZCA9IG5vZGUuY29tcHV0ZWQ7XG4gIGlmIChpc0xpdGVyYWwobm9kZS5wcm9wZXJ0eSkgJiYgdHlwZW9mIG5vZGUucHJvcGVydHkudmFsdWUgPT09IFwibnVtYmVyXCIpIHtcbiAgICBjb21wdXRlZCA9IHRydWU7XG4gIH1cbiAgaWYgKGNvbXB1dGVkKSB7XG4gICAgY29uc3QgZXhpdCA9IHRoaXMuZW50ZXJEZWxpbWl0ZWQoKTtcbiAgICB0aGlzLnRva2VuQ2hhcig5MSk7XG4gICAgdGhpcy5wcmludChub2RlLnByb3BlcnR5KTtcbiAgICB0aGlzLnRva2VuQ2hhcig5Myk7XG4gICAgZXhpdCgpO1xuICB9IGVsc2Uge1xuICAgIHRoaXMudG9rZW5DaGFyKDQ2KTtcbiAgICB0aGlzLnByaW50KG5vZGUucHJvcGVydHkpO1xuICB9XG59XG5mdW5jdGlvbiBNZXRhUHJvcGVydHkobm9kZSkge1xuICB0aGlzLnByaW50KG5vZGUubWV0YSk7XG4gIHRoaXMudG9rZW5DaGFyKDQ2KTtcbiAgdGhpcy5wcmludChub2RlLnByb3BlcnR5KTtcbn1cbmZ1bmN0aW9uIFByaXZhdGVOYW1lKG5vZGUpIHtcbiAgdGhpcy50b2tlbkNoYXIoMzUpO1xuICB0aGlzLnByaW50KG5vZGUuaWQpO1xufVxuZnVuY3Rpb24gVjhJbnRyaW5zaWNJZGVudGlmaWVyKG5vZGUpIHtcbiAgdGhpcy50b2tlbkNoYXIoMzcpO1xuICB0aGlzLndvcmQobm9kZS5uYW1lKTtcbn1cbmZ1bmN0aW9uIE1vZHVsZUV4cHJlc3Npb24obm9kZSkge1xuICB0aGlzLndvcmQoXCJtb2R1bGVcIiwgdHJ1ZSk7XG4gIHRoaXMuc3BhY2UoKTtcbiAgdGhpcy50b2tlbkNoYXIoMTIzKTtcbiAgdGhpcy5pbmRlbnQoKTtcbiAgY29uc3Qge1xuICAgIGJvZHlcbiAgfSA9IG5vZGU7XG4gIGlmIChib2R5LmJvZHkubGVuZ3RoIHx8IGJvZHkuZGlyZWN0aXZlcy5sZW5ndGgpIHtcbiAgICB0aGlzLm5ld2xpbmUoKTtcbiAgfVxuICB0aGlzLnByaW50KGJvZHkpO1xuICB0aGlzLmRlZGVudCgpO1xuICB0aGlzLnJpZ2h0QnJhY2Uobm9kZSk7XG59XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWV4cHJlc3Npb25zLmpzLm1hcFxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@babel/generator/lib/generators/expressions.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@babel/generator/lib/generators/flow.js":
/*!**************************************************************!*\
  !*** ./node_modules/@babel/generator/lib/generators/flow.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports.AnyTypeAnnotation = AnyTypeAnnotation;\nexports.ArrayTypeAnnotation = ArrayTypeAnnotation;\nexports.BooleanLiteralTypeAnnotation = BooleanLiteralTypeAnnotation;\nexports.BooleanTypeAnnotation = BooleanTypeAnnotation;\nexports.DeclareClass = DeclareClass;\nexports.DeclareExportAllDeclaration = DeclareExportAllDeclaration;\nexports.DeclareExportDeclaration = DeclareExportDeclaration;\nexports.DeclareFunction = DeclareFunction;\nexports.DeclareInterface = DeclareInterface;\nexports.DeclareModule = DeclareModule;\nexports.DeclareModuleExports = DeclareModuleExports;\nexports.DeclareOpaqueType = DeclareOpaqueType;\nexports.DeclareTypeAlias = DeclareTypeAlias;\nexports.DeclareVariable = DeclareVariable;\nexports.DeclaredPredicate = DeclaredPredicate;\nexports.EmptyTypeAnnotation = EmptyTypeAnnotation;\nexports.EnumBooleanBody = EnumBooleanBody;\nexports.EnumBooleanMember = EnumBooleanMember;\nexports.EnumDeclaration = EnumDeclaration;\nexports.EnumDefaultedMember = EnumDefaultedMember;\nexports.EnumNumberBody = EnumNumberBody;\nexports.EnumNumberMember = EnumNumberMember;\nexports.EnumStringBody = EnumStringBody;\nexports.EnumStringMember = EnumStringMember;\nexports.EnumSymbolBody = EnumSymbolBody;\nexports.ExistsTypeAnnotation = ExistsTypeAnnotation;\nexports.FunctionTypeAnnotation = FunctionTypeAnnotation;\nexports.FunctionTypeParam = FunctionTypeParam;\nexports.IndexedAccessType = IndexedAccessType;\nexports.InferredPredicate = InferredPredicate;\nexports.InterfaceDeclaration = InterfaceDeclaration;\nexports.GenericTypeAnnotation = exports.ClassImplements = exports.InterfaceExtends = InterfaceExtends;\nexports.InterfaceTypeAnnotation = InterfaceTypeAnnotation;\nexports.IntersectionTypeAnnotation = IntersectionTypeAnnotation;\nexports.MixedTypeAnnotation = MixedTypeAnnotation;\nexports.NullLiteralTypeAnnotation = NullLiteralTypeAnnotation;\nexports.NullableTypeAnnotation = NullableTypeAnnotation;\nObject.defineProperty(exports, \"NumberLiteralTypeAnnotation\", ({\n  enumerable: true,\n  get: function () {\n    return _types2.NumericLiteral;\n  }\n}));\nexports.NumberTypeAnnotation = NumberTypeAnnotation;\nexports.ObjectTypeAnnotation = ObjectTypeAnnotation;\nexports.ObjectTypeCallProperty = ObjectTypeCallProperty;\nexports.ObjectTypeIndexer = ObjectTypeIndexer;\nexports.ObjectTypeInternalSlot = ObjectTypeInternalSlot;\nexports.ObjectTypeProperty = ObjectTypeProperty;\nexports.ObjectTypeSpreadProperty = ObjectTypeSpreadProperty;\nexports.OpaqueType = OpaqueType;\nexports.OptionalIndexedAccessType = OptionalIndexedAccessType;\nexports.QualifiedTypeIdentifier = QualifiedTypeIdentifier;\nObject.defineProperty(exports, \"StringLiteralTypeAnnotation\", ({\n  enumerable: true,\n  get: function () {\n    return _types2.StringLiteral;\n  }\n}));\nexports.StringTypeAnnotation = StringTypeAnnotation;\nexports.SymbolTypeAnnotation = SymbolTypeAnnotation;\nexports.ThisTypeAnnotation = ThisTypeAnnotation;\nexports.TupleTypeAnnotation = TupleTypeAnnotation;\nexports.TypeAlias = TypeAlias;\nexports.TypeAnnotation = TypeAnnotation;\nexports.TypeCastExpression = TypeCastExpression;\nexports.TypeParameter = TypeParameter;\nexports.TypeParameterDeclaration = exports.TypeParameterInstantiation = TypeParameterInstantiation;\nexports.TypeofTypeAnnotation = TypeofTypeAnnotation;\nexports.UnionTypeAnnotation = UnionTypeAnnotation;\nexports.Variance = Variance;\nexports.VoidTypeAnnotation = VoidTypeAnnotation;\nexports._interfaceish = _interfaceish;\nexports._variance = _variance;\nvar _t = __webpack_require__(/*! @babel/types */ \"(ssr)/./node_modules/@babel/types/lib/index.js\");\nvar _modules = __webpack_require__(/*! ./modules.js */ \"(ssr)/./node_modules/@babel/generator/lib/generators/modules.js\");\nvar _index = __webpack_require__(/*! ../node/index.js */ \"(ssr)/./node_modules/@babel/generator/lib/node/index.js\");\nvar _types2 = __webpack_require__(/*! ./types.js */ \"(ssr)/./node_modules/@babel/generator/lib/generators/types.js\");\nconst {\n  isDeclareExportDeclaration,\n  isStatement\n} = _t;\nfunction AnyTypeAnnotation() {\n  this.word(\"any\");\n}\nfunction ArrayTypeAnnotation(node) {\n  this.print(node.elementType, true);\n  this.tokenChar(91);\n  this.tokenChar(93);\n}\nfunction BooleanTypeAnnotation() {\n  this.word(\"boolean\");\n}\nfunction BooleanLiteralTypeAnnotation(node) {\n  this.word(node.value ? \"true\" : \"false\");\n}\nfunction NullLiteralTypeAnnotation() {\n  this.word(\"null\");\n}\nfunction DeclareClass(node, parent) {\n  if (!isDeclareExportDeclaration(parent)) {\n    this.word(\"declare\");\n    this.space();\n  }\n  this.word(\"class\");\n  this.space();\n  this._interfaceish(node);\n}\nfunction DeclareFunction(node, parent) {\n  if (!isDeclareExportDeclaration(parent)) {\n    this.word(\"declare\");\n    this.space();\n  }\n  this.word(\"function\");\n  this.space();\n  this.print(node.id);\n  this.print(node.id.typeAnnotation.typeAnnotation);\n  if (node.predicate) {\n    this.space();\n    this.print(node.predicate);\n  }\n  this.semicolon();\n}\nfunction InferredPredicate() {\n  this.tokenChar(37);\n  this.word(\"checks\");\n}\nfunction DeclaredPredicate(node) {\n  this.tokenChar(37);\n  this.word(\"checks\");\n  this.tokenChar(40);\n  this.print(node.value);\n  this.tokenChar(41);\n}\nfunction DeclareInterface(node) {\n  this.word(\"declare\");\n  this.space();\n  this.InterfaceDeclaration(node);\n}\nfunction DeclareModule(node) {\n  this.word(\"declare\");\n  this.space();\n  this.word(\"module\");\n  this.space();\n  this.print(node.id);\n  this.space();\n  this.print(node.body);\n}\nfunction DeclareModuleExports(node) {\n  this.word(\"declare\");\n  this.space();\n  this.word(\"module\");\n  this.tokenChar(46);\n  this.word(\"exports\");\n  this.print(node.typeAnnotation);\n}\nfunction DeclareTypeAlias(node) {\n  this.word(\"declare\");\n  this.space();\n  this.TypeAlias(node);\n}\nfunction DeclareOpaqueType(node, parent) {\n  if (!isDeclareExportDeclaration(parent)) {\n    this.word(\"declare\");\n    this.space();\n  }\n  this.OpaqueType(node);\n}\nfunction DeclareVariable(node, parent) {\n  if (!isDeclareExportDeclaration(parent)) {\n    this.word(\"declare\");\n    this.space();\n  }\n  this.word(\"var\");\n  this.space();\n  this.print(node.id);\n  this.print(node.id.typeAnnotation);\n  this.semicolon();\n}\nfunction DeclareExportDeclaration(node) {\n  this.word(\"declare\");\n  this.space();\n  this.word(\"export\");\n  this.space();\n  if (node.default) {\n    this.word(\"default\");\n    this.space();\n  }\n  FlowExportDeclaration.call(this, node);\n}\nfunction DeclareExportAllDeclaration(node) {\n  this.word(\"declare\");\n  this.space();\n  _modules.ExportAllDeclaration.call(this, node);\n}\nfunction EnumDeclaration(node) {\n  const {\n    id,\n    body\n  } = node;\n  this.word(\"enum\");\n  this.space();\n  this.print(id);\n  this.print(body);\n}\nfunction enumExplicitType(context, name, hasExplicitType) {\n  if (hasExplicitType) {\n    context.space();\n    context.word(\"of\");\n    context.space();\n    context.word(name);\n  }\n  context.space();\n}\nfunction enumBody(context, node) {\n  const {\n    members\n  } = node;\n  context.token(\"{\");\n  context.indent();\n  context.newline();\n  for (const member of members) {\n    context.print(member);\n    context.newline();\n  }\n  if (node.hasUnknownMembers) {\n    context.token(\"...\");\n    context.newline();\n  }\n  context.dedent();\n  context.token(\"}\");\n}\nfunction EnumBooleanBody(node) {\n  const {\n    explicitType\n  } = node;\n  enumExplicitType(this, \"boolean\", explicitType);\n  enumBody(this, node);\n}\nfunction EnumNumberBody(node) {\n  const {\n    explicitType\n  } = node;\n  enumExplicitType(this, \"number\", explicitType);\n  enumBody(this, node);\n}\nfunction EnumStringBody(node) {\n  const {\n    explicitType\n  } = node;\n  enumExplicitType(this, \"string\", explicitType);\n  enumBody(this, node);\n}\nfunction EnumSymbolBody(node) {\n  enumExplicitType(this, \"symbol\", true);\n  enumBody(this, node);\n}\nfunction EnumDefaultedMember(node) {\n  const {\n    id\n  } = node;\n  this.print(id);\n  this.tokenChar(44);\n}\nfunction enumInitializedMember(context, node) {\n  context.print(node.id);\n  context.space();\n  context.token(\"=\");\n  context.space();\n  context.print(node.init);\n  context.token(\",\");\n}\nfunction EnumBooleanMember(node) {\n  enumInitializedMember(this, node);\n}\nfunction EnumNumberMember(node) {\n  enumInitializedMember(this, node);\n}\nfunction EnumStringMember(node) {\n  enumInitializedMember(this, node);\n}\nfunction FlowExportDeclaration(node) {\n  if (node.declaration) {\n    const declar = node.declaration;\n    this.print(declar);\n    if (!isStatement(declar)) this.semicolon();\n  } else {\n    this.tokenChar(123);\n    if (node.specifiers.length) {\n      this.space();\n      this.printList(node.specifiers);\n      this.space();\n    }\n    this.tokenChar(125);\n    if (node.source) {\n      this.space();\n      this.word(\"from\");\n      this.space();\n      this.print(node.source);\n    }\n    this.semicolon();\n  }\n}\nfunction ExistsTypeAnnotation() {\n  this.tokenChar(42);\n}\nfunction FunctionTypeAnnotation(node, parent) {\n  this.print(node.typeParameters);\n  this.tokenChar(40);\n  if (node.this) {\n    this.word(\"this\");\n    this.tokenChar(58);\n    this.space();\n    this.print(node.this.typeAnnotation);\n    if (node.params.length || node.rest) {\n      this.tokenChar(44);\n      this.space();\n    }\n  }\n  this.printList(node.params);\n  if (node.rest) {\n    if (node.params.length) {\n      this.tokenChar(44);\n      this.space();\n    }\n    this.token(\"...\");\n    this.print(node.rest);\n  }\n  this.tokenChar(41);\n  const type = parent == null ? void 0 : parent.type;\n  if (type != null && (type === \"ObjectTypeCallProperty\" || type === \"ObjectTypeInternalSlot\" || type === \"DeclareFunction\" || type === \"ObjectTypeProperty\" && parent.method)) {\n    this.tokenChar(58);\n  } else {\n    this.space();\n    this.token(\"=>\");\n  }\n  this.space();\n  this.print(node.returnType);\n}\nfunction FunctionTypeParam(node) {\n  this.print(node.name);\n  if (node.optional) this.tokenChar(63);\n  if (node.name) {\n    this.tokenChar(58);\n    this.space();\n  }\n  this.print(node.typeAnnotation);\n}\nfunction InterfaceExtends(node) {\n  this.print(node.id);\n  this.print(node.typeParameters, true);\n}\nfunction _interfaceish(node) {\n  var _node$extends;\n  this.print(node.id);\n  this.print(node.typeParameters);\n  if ((_node$extends = node.extends) != null && _node$extends.length) {\n    this.space();\n    this.word(\"extends\");\n    this.space();\n    this.printList(node.extends);\n  }\n  if (node.type === \"DeclareClass\") {\n    var _node$mixins, _node$implements;\n    if ((_node$mixins = node.mixins) != null && _node$mixins.length) {\n      this.space();\n      this.word(\"mixins\");\n      this.space();\n      this.printList(node.mixins);\n    }\n    if ((_node$implements = node.implements) != null && _node$implements.length) {\n      this.space();\n      this.word(\"implements\");\n      this.space();\n      this.printList(node.implements);\n    }\n  }\n  this.space();\n  this.print(node.body);\n}\nfunction _variance(node) {\n  var _node$variance;\n  const kind = (_node$variance = node.variance) == null ? void 0 : _node$variance.kind;\n  if (kind != null) {\n    if (kind === \"plus\") {\n      this.tokenChar(43);\n    } else if (kind === \"minus\") {\n      this.tokenChar(45);\n    }\n  }\n}\nfunction InterfaceDeclaration(node) {\n  this.word(\"interface\");\n  this.space();\n  this._interfaceish(node);\n}\nfunction andSeparator(occurrenceCount) {\n  this.space();\n  this.token(\"&\", false, occurrenceCount);\n  this.space();\n}\nfunction InterfaceTypeAnnotation(node) {\n  var _node$extends2;\n  this.word(\"interface\");\n  if ((_node$extends2 = node.extends) != null && _node$extends2.length) {\n    this.space();\n    this.word(\"extends\");\n    this.space();\n    this.printList(node.extends);\n  }\n  this.space();\n  this.print(node.body);\n}\nfunction IntersectionTypeAnnotation(node) {\n  this.printJoin(node.types, undefined, undefined, andSeparator);\n}\nfunction MixedTypeAnnotation() {\n  this.word(\"mixed\");\n}\nfunction EmptyTypeAnnotation() {\n  this.word(\"empty\");\n}\nfunction NullableTypeAnnotation(node) {\n  this.tokenChar(63);\n  this.print(node.typeAnnotation);\n}\nfunction NumberTypeAnnotation() {\n  this.word(\"number\");\n}\nfunction StringTypeAnnotation() {\n  this.word(\"string\");\n}\nfunction ThisTypeAnnotation() {\n  this.word(\"this\");\n}\nfunction TupleTypeAnnotation(node) {\n  this.tokenChar(91);\n  this.printList(node.types);\n  this.tokenChar(93);\n}\nfunction TypeofTypeAnnotation(node) {\n  this.word(\"typeof\");\n  this.space();\n  this.print(node.argument);\n}\nfunction TypeAlias(node) {\n  this.word(\"type\");\n  this.space();\n  this.print(node.id);\n  this.print(node.typeParameters);\n  this.space();\n  this.tokenChar(61);\n  this.space();\n  this.print(node.right);\n  this.semicolon();\n}\nfunction TypeAnnotation(node, parent) {\n  this.tokenChar(58);\n  this.space();\n  if (parent.type === \"ArrowFunctionExpression\") {\n    this.tokenContext |= _index.TokenContext.arrowFlowReturnType;\n  } else if (node.optional) {\n    this.tokenChar(63);\n  }\n  this.print(node.typeAnnotation);\n}\nfunction TypeParameterInstantiation(node) {\n  this.tokenChar(60);\n  this.printList(node.params);\n  this.tokenChar(62);\n}\nfunction TypeParameter(node) {\n  this._variance(node);\n  this.word(node.name);\n  if (node.bound) {\n    this.print(node.bound);\n  }\n  if (node.default) {\n    this.space();\n    this.tokenChar(61);\n    this.space();\n    this.print(node.default);\n  }\n}\nfunction OpaqueType(node) {\n  this.word(\"opaque\");\n  this.space();\n  this.word(\"type\");\n  this.space();\n  this.print(node.id);\n  this.print(node.typeParameters);\n  if (node.supertype) {\n    this.tokenChar(58);\n    this.space();\n    this.print(node.supertype);\n  }\n  if (node.impltype) {\n    this.space();\n    this.tokenChar(61);\n    this.space();\n    this.print(node.impltype);\n  }\n  this.semicolon();\n}\nfunction ObjectTypeAnnotation(node) {\n  if (node.exact) {\n    this.token(\"{|\");\n  } else {\n    this.tokenChar(123);\n  }\n  const props = [...node.properties, ...(node.callProperties || []), ...(node.indexers || []), ...(node.internalSlots || [])];\n  if (props.length) {\n    this.newline();\n    this.space();\n    this.printJoin(props, true, true, undefined, undefined, () => {\n      if (props.length !== 1 || node.inexact) {\n        this.tokenChar(44);\n        this.space();\n      }\n    });\n    this.space();\n  }\n  if (node.inexact) {\n    this.indent();\n    this.token(\"...\");\n    if (props.length) {\n      this.newline();\n    }\n    this.dedent();\n  }\n  if (node.exact) {\n    this.token(\"|}\");\n  } else {\n    this.tokenChar(125);\n  }\n}\nfunction ObjectTypeInternalSlot(node) {\n  if (node.static) {\n    this.word(\"static\");\n    this.space();\n  }\n  this.tokenChar(91);\n  this.tokenChar(91);\n  this.print(node.id);\n  this.tokenChar(93);\n  this.tokenChar(93);\n  if (node.optional) this.tokenChar(63);\n  if (!node.method) {\n    this.tokenChar(58);\n    this.space();\n  }\n  this.print(node.value);\n}\nfunction ObjectTypeCallProperty(node) {\n  if (node.static) {\n    this.word(\"static\");\n    this.space();\n  }\n  this.print(node.value);\n}\nfunction ObjectTypeIndexer(node) {\n  if (node.static) {\n    this.word(\"static\");\n    this.space();\n  }\n  this._variance(node);\n  this.tokenChar(91);\n  if (node.id) {\n    this.print(node.id);\n    this.tokenChar(58);\n    this.space();\n  }\n  this.print(node.key);\n  this.tokenChar(93);\n  this.tokenChar(58);\n  this.space();\n  this.print(node.value);\n}\nfunction ObjectTypeProperty(node) {\n  if (node.proto) {\n    this.word(\"proto\");\n    this.space();\n  }\n  if (node.static) {\n    this.word(\"static\");\n    this.space();\n  }\n  if (node.kind === \"get\" || node.kind === \"set\") {\n    this.word(node.kind);\n    this.space();\n  }\n  this._variance(node);\n  this.print(node.key);\n  if (node.optional) this.tokenChar(63);\n  if (!node.method) {\n    this.tokenChar(58);\n    this.space();\n  }\n  this.print(node.value);\n}\nfunction ObjectTypeSpreadProperty(node) {\n  this.token(\"...\");\n  this.print(node.argument);\n}\nfunction QualifiedTypeIdentifier(node) {\n  this.print(node.qualification);\n  this.tokenChar(46);\n  this.print(node.id);\n}\nfunction SymbolTypeAnnotation() {\n  this.word(\"symbol\");\n}\nfunction orSeparator(occurrenceCount) {\n  this.space();\n  this.token(\"|\", false, occurrenceCount);\n  this.space();\n}\nfunction UnionTypeAnnotation(node) {\n  this.printJoin(node.types, undefined, undefined, orSeparator);\n}\nfunction TypeCastExpression(node) {\n  this.tokenChar(40);\n  this.print(node.expression);\n  this.print(node.typeAnnotation);\n  this.tokenChar(41);\n}\nfunction Variance(node) {\n  if (node.kind === \"plus\") {\n    this.tokenChar(43);\n  } else {\n    this.tokenChar(45);\n  }\n}\nfunction VoidTypeAnnotation() {\n  this.word(\"void\");\n}\nfunction IndexedAccessType(node) {\n  this.print(node.objectType, true);\n  this.tokenChar(91);\n  this.print(node.indexType);\n  this.tokenChar(93);\n}\nfunction OptionalIndexedAccessType(node) {\n  this.print(node.objectType);\n  if (node.optional) {\n    this.token(\"?.\");\n  }\n  this.tokenChar(91);\n  this.print(node.indexType);\n  this.tokenChar(93);\n}\n\n//# sourceMappingURL=flow.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGJhYmVsL2dlbmVyYXRvci9saWIvZ2VuZXJhdG9ycy9mbG93LmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViLDhDQUE2QztBQUM3QztBQUNBLENBQUMsRUFBQztBQUNGLHlCQUF5QjtBQUN6QiwyQkFBMkI7QUFDM0Isb0NBQW9DO0FBQ3BDLDZCQUE2QjtBQUM3QixvQkFBb0I7QUFDcEIsbUNBQW1DO0FBQ25DLGdDQUFnQztBQUNoQyx1QkFBdUI7QUFDdkIsd0JBQXdCO0FBQ3hCLHFCQUFxQjtBQUNyQiw0QkFBNEI7QUFDNUIseUJBQXlCO0FBQ3pCLHdCQUF3QjtBQUN4Qix1QkFBdUI7QUFDdkIseUJBQXlCO0FBQ3pCLDJCQUEyQjtBQUMzQix1QkFBdUI7QUFDdkIseUJBQXlCO0FBQ3pCLHVCQUF1QjtBQUN2QiwyQkFBMkI7QUFDM0Isc0JBQXNCO0FBQ3RCLHdCQUF3QjtBQUN4QixzQkFBc0I7QUFDdEIsd0JBQXdCO0FBQ3hCLHNCQUFzQjtBQUN0Qiw0QkFBNEI7QUFDNUIsOEJBQThCO0FBQzlCLHlCQUF5QjtBQUN6Qix5QkFBeUI7QUFDekIseUJBQXlCO0FBQ3pCLDRCQUE0QjtBQUM1Qiw2QkFBNkIsR0FBRyx1QkFBdUIsR0FBRyx3QkFBd0I7QUFDbEYsK0JBQStCO0FBQy9CLGtDQUFrQztBQUNsQywyQkFBMkI7QUFDM0IsaUNBQWlDO0FBQ2pDLDhCQUE4QjtBQUM5QiwrREFBOEQ7QUFDOUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLEVBQUM7QUFDRiw0QkFBNEI7QUFDNUIsNEJBQTRCO0FBQzVCLDhCQUE4QjtBQUM5Qix5QkFBeUI7QUFDekIsOEJBQThCO0FBQzlCLDBCQUEwQjtBQUMxQixnQ0FBZ0M7QUFDaEMsa0JBQWtCO0FBQ2xCLGlDQUFpQztBQUNqQywrQkFBK0I7QUFDL0IsK0RBQThEO0FBQzlEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxFQUFDO0FBQ0YsNEJBQTRCO0FBQzVCLDRCQUE0QjtBQUM1QiwwQkFBMEI7QUFDMUIsMkJBQTJCO0FBQzNCLGlCQUFpQjtBQUNqQixzQkFBc0I7QUFDdEIsMEJBQTBCO0FBQzFCLHFCQUFxQjtBQUNyQixnQ0FBZ0MsR0FBRyxrQ0FBa0M7QUFDckUsNEJBQTRCO0FBQzVCLDJCQUEyQjtBQUMzQixnQkFBZ0I7QUFDaEIsMEJBQTBCO0FBQzFCLHFCQUFxQjtBQUNyQixpQkFBaUI7QUFDakIsU0FBUyxtQkFBTyxDQUFDLG9FQUFjO0FBQy9CLGVBQWUsbUJBQU8sQ0FBQyxxRkFBYztBQUNyQyxhQUFhLG1CQUFPLENBQUMsaUZBQWtCO0FBQ3ZDLGNBQWMsbUJBQU8sQ0FBQyxpRkFBWTtBQUNsQztBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0osa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakIsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQixJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSIsInNvdXJjZXMiOlsid2VicGFjazovL3JlcG8tdmlzdWFsaXplci8uL25vZGVfbW9kdWxlcy9AYmFiZWwvZ2VuZXJhdG9yL2xpYi9nZW5lcmF0b3JzL2Zsb3cuanM/ZWQwMCJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuQW55VHlwZUFubm90YXRpb24gPSBBbnlUeXBlQW5ub3RhdGlvbjtcbmV4cG9ydHMuQXJyYXlUeXBlQW5ub3RhdGlvbiA9IEFycmF5VHlwZUFubm90YXRpb247XG5leHBvcnRzLkJvb2xlYW5MaXRlcmFsVHlwZUFubm90YXRpb24gPSBCb29sZWFuTGl0ZXJhbFR5cGVBbm5vdGF0aW9uO1xuZXhwb3J0cy5Cb29sZWFuVHlwZUFubm90YXRpb24gPSBCb29sZWFuVHlwZUFubm90YXRpb247XG5leHBvcnRzLkRlY2xhcmVDbGFzcyA9IERlY2xhcmVDbGFzcztcbmV4cG9ydHMuRGVjbGFyZUV4cG9ydEFsbERlY2xhcmF0aW9uID0gRGVjbGFyZUV4cG9ydEFsbERlY2xhcmF0aW9uO1xuZXhwb3J0cy5EZWNsYXJlRXhwb3J0RGVjbGFyYXRpb24gPSBEZWNsYXJlRXhwb3J0RGVjbGFyYXRpb247XG5leHBvcnRzLkRlY2xhcmVGdW5jdGlvbiA9IERlY2xhcmVGdW5jdGlvbjtcbmV4cG9ydHMuRGVjbGFyZUludGVyZmFjZSA9IERlY2xhcmVJbnRlcmZhY2U7XG5leHBvcnRzLkRlY2xhcmVNb2R1bGUgPSBEZWNsYXJlTW9kdWxlO1xuZXhwb3J0cy5EZWNsYXJlTW9kdWxlRXhwb3J0cyA9IERlY2xhcmVNb2R1bGVFeHBvcnRzO1xuZXhwb3J0cy5EZWNsYXJlT3BhcXVlVHlwZSA9IERlY2xhcmVPcGFxdWVUeXBlO1xuZXhwb3J0cy5EZWNsYXJlVHlwZUFsaWFzID0gRGVjbGFyZVR5cGVBbGlhcztcbmV4cG9ydHMuRGVjbGFyZVZhcmlhYmxlID0gRGVjbGFyZVZhcmlhYmxlO1xuZXhwb3J0cy5EZWNsYXJlZFByZWRpY2F0ZSA9IERlY2xhcmVkUHJlZGljYXRlO1xuZXhwb3J0cy5FbXB0eVR5cGVBbm5vdGF0aW9uID0gRW1wdHlUeXBlQW5ub3RhdGlvbjtcbmV4cG9ydHMuRW51bUJvb2xlYW5Cb2R5ID0gRW51bUJvb2xlYW5Cb2R5O1xuZXhwb3J0cy5FbnVtQm9vbGVhbk1lbWJlciA9IEVudW1Cb29sZWFuTWVtYmVyO1xuZXhwb3J0cy5FbnVtRGVjbGFyYXRpb24gPSBFbnVtRGVjbGFyYXRpb247XG5leHBvcnRzLkVudW1EZWZhdWx0ZWRNZW1iZXIgPSBFbnVtRGVmYXVsdGVkTWVtYmVyO1xuZXhwb3J0cy5FbnVtTnVtYmVyQm9keSA9IEVudW1OdW1iZXJCb2R5O1xuZXhwb3J0cy5FbnVtTnVtYmVyTWVtYmVyID0gRW51bU51bWJlck1lbWJlcjtcbmV4cG9ydHMuRW51bVN0cmluZ0JvZHkgPSBFbnVtU3RyaW5nQm9keTtcbmV4cG9ydHMuRW51bVN0cmluZ01lbWJlciA9IEVudW1TdHJpbmdNZW1iZXI7XG5leHBvcnRzLkVudW1TeW1ib2xCb2R5ID0gRW51bVN5bWJvbEJvZHk7XG5leHBvcnRzLkV4aXN0c1R5cGVBbm5vdGF0aW9uID0gRXhpc3RzVHlwZUFubm90YXRpb247XG5leHBvcnRzLkZ1bmN0aW9uVHlwZUFubm90YXRpb24gPSBGdW5jdGlvblR5cGVBbm5vdGF0aW9uO1xuZXhwb3J0cy5GdW5jdGlvblR5cGVQYXJhbSA9IEZ1bmN0aW9uVHlwZVBhcmFtO1xuZXhwb3J0cy5JbmRleGVkQWNjZXNzVHlwZSA9IEluZGV4ZWRBY2Nlc3NUeXBlO1xuZXhwb3J0cy5JbmZlcnJlZFByZWRpY2F0ZSA9IEluZmVycmVkUHJlZGljYXRlO1xuZXhwb3J0cy5JbnRlcmZhY2VEZWNsYXJhdGlvbiA9IEludGVyZmFjZURlY2xhcmF0aW9uO1xuZXhwb3J0cy5HZW5lcmljVHlwZUFubm90YXRpb24gPSBleHBvcnRzLkNsYXNzSW1wbGVtZW50cyA9IGV4cG9ydHMuSW50ZXJmYWNlRXh0ZW5kcyA9IEludGVyZmFjZUV4dGVuZHM7XG5leHBvcnRzLkludGVyZmFjZVR5cGVBbm5vdGF0aW9uID0gSW50ZXJmYWNlVHlwZUFubm90YXRpb247XG5leHBvcnRzLkludGVyc2VjdGlvblR5cGVBbm5vdGF0aW9uID0gSW50ZXJzZWN0aW9uVHlwZUFubm90YXRpb247XG5leHBvcnRzLk1peGVkVHlwZUFubm90YXRpb24gPSBNaXhlZFR5cGVBbm5vdGF0aW9uO1xuZXhwb3J0cy5OdWxsTGl0ZXJhbFR5cGVBbm5vdGF0aW9uID0gTnVsbExpdGVyYWxUeXBlQW5ub3RhdGlvbjtcbmV4cG9ydHMuTnVsbGFibGVUeXBlQW5ub3RhdGlvbiA9IE51bGxhYmxlVHlwZUFubm90YXRpb247XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJOdW1iZXJMaXRlcmFsVHlwZUFubm90YXRpb25cIiwge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gX3R5cGVzMi5OdW1lcmljTGl0ZXJhbDtcbiAgfVxufSk7XG5leHBvcnRzLk51bWJlclR5cGVBbm5vdGF0aW9uID0gTnVtYmVyVHlwZUFubm90YXRpb247XG5leHBvcnRzLk9iamVjdFR5cGVBbm5vdGF0aW9uID0gT2JqZWN0VHlwZUFubm90YXRpb247XG5leHBvcnRzLk9iamVjdFR5cGVDYWxsUHJvcGVydHkgPSBPYmplY3RUeXBlQ2FsbFByb3BlcnR5O1xuZXhwb3J0cy5PYmplY3RUeXBlSW5kZXhlciA9IE9iamVjdFR5cGVJbmRleGVyO1xuZXhwb3J0cy5PYmplY3RUeXBlSW50ZXJuYWxTbG90ID0gT2JqZWN0VHlwZUludGVybmFsU2xvdDtcbmV4cG9ydHMuT2JqZWN0VHlwZVByb3BlcnR5ID0gT2JqZWN0VHlwZVByb3BlcnR5O1xuZXhwb3J0cy5PYmplY3RUeXBlU3ByZWFkUHJvcGVydHkgPSBPYmplY3RUeXBlU3ByZWFkUHJvcGVydHk7XG5leHBvcnRzLk9wYXF1ZVR5cGUgPSBPcGFxdWVUeXBlO1xuZXhwb3J0cy5PcHRpb25hbEluZGV4ZWRBY2Nlc3NUeXBlID0gT3B0aW9uYWxJbmRleGVkQWNjZXNzVHlwZTtcbmV4cG9ydHMuUXVhbGlmaWVkVHlwZUlkZW50aWZpZXIgPSBRdWFsaWZpZWRUeXBlSWRlbnRpZmllcjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIlN0cmluZ0xpdGVyYWxUeXBlQW5ub3RhdGlvblwiLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBfdHlwZXMyLlN0cmluZ0xpdGVyYWw7XG4gIH1cbn0pO1xuZXhwb3J0cy5TdHJpbmdUeXBlQW5ub3RhdGlvbiA9IFN0cmluZ1R5cGVBbm5vdGF0aW9uO1xuZXhwb3J0cy5TeW1ib2xUeXBlQW5ub3RhdGlvbiA9IFN5bWJvbFR5cGVBbm5vdGF0aW9uO1xuZXhwb3J0cy5UaGlzVHlwZUFubm90YXRpb24gPSBUaGlzVHlwZUFubm90YXRpb247XG5leHBvcnRzLlR1cGxlVHlwZUFubm90YXRpb24gPSBUdXBsZVR5cGVBbm5vdGF0aW9uO1xuZXhwb3J0cy5UeXBlQWxpYXMgPSBUeXBlQWxpYXM7XG5leHBvcnRzLlR5cGVBbm5vdGF0aW9uID0gVHlwZUFubm90YXRpb247XG5leHBvcnRzLlR5cGVDYXN0RXhwcmVzc2lvbiA9IFR5cGVDYXN0RXhwcmVzc2lvbjtcbmV4cG9ydHMuVHlwZVBhcmFtZXRlciA9IFR5cGVQYXJhbWV0ZXI7XG5leHBvcnRzLlR5cGVQYXJhbWV0ZXJEZWNsYXJhdGlvbiA9IGV4cG9ydHMuVHlwZVBhcmFtZXRlckluc3RhbnRpYXRpb24gPSBUeXBlUGFyYW1ldGVySW5zdGFudGlhdGlvbjtcbmV4cG9ydHMuVHlwZW9mVHlwZUFubm90YXRpb24gPSBUeXBlb2ZUeXBlQW5ub3RhdGlvbjtcbmV4cG9ydHMuVW5pb25UeXBlQW5ub3RhdGlvbiA9IFVuaW9uVHlwZUFubm90YXRpb247XG5leHBvcnRzLlZhcmlhbmNlID0gVmFyaWFuY2U7XG5leHBvcnRzLlZvaWRUeXBlQW5ub3RhdGlvbiA9IFZvaWRUeXBlQW5ub3RhdGlvbjtcbmV4cG9ydHMuX2ludGVyZmFjZWlzaCA9IF9pbnRlcmZhY2Vpc2g7XG5leHBvcnRzLl92YXJpYW5jZSA9IF92YXJpYW5jZTtcbnZhciBfdCA9IHJlcXVpcmUoXCJAYmFiZWwvdHlwZXNcIik7XG52YXIgX21vZHVsZXMgPSByZXF1aXJlKFwiLi9tb2R1bGVzLmpzXCIpO1xudmFyIF9pbmRleCA9IHJlcXVpcmUoXCIuLi9ub2RlL2luZGV4LmpzXCIpO1xudmFyIF90eXBlczIgPSByZXF1aXJlKFwiLi90eXBlcy5qc1wiKTtcbmNvbnN0IHtcbiAgaXNEZWNsYXJlRXhwb3J0RGVjbGFyYXRpb24sXG4gIGlzU3RhdGVtZW50XG59ID0gX3Q7XG5mdW5jdGlvbiBBbnlUeXBlQW5ub3RhdGlvbigpIHtcbiAgdGhpcy53b3JkKFwiYW55XCIpO1xufVxuZnVuY3Rpb24gQXJyYXlUeXBlQW5ub3RhdGlvbihub2RlKSB7XG4gIHRoaXMucHJpbnQobm9kZS5lbGVtZW50VHlwZSwgdHJ1ZSk7XG4gIHRoaXMudG9rZW5DaGFyKDkxKTtcbiAgdGhpcy50b2tlbkNoYXIoOTMpO1xufVxuZnVuY3Rpb24gQm9vbGVhblR5cGVBbm5vdGF0aW9uKCkge1xuICB0aGlzLndvcmQoXCJib29sZWFuXCIpO1xufVxuZnVuY3Rpb24gQm9vbGVhbkxpdGVyYWxUeXBlQW5ub3RhdGlvbihub2RlKSB7XG4gIHRoaXMud29yZChub2RlLnZhbHVlID8gXCJ0cnVlXCIgOiBcImZhbHNlXCIpO1xufVxuZnVuY3Rpb24gTnVsbExpdGVyYWxUeXBlQW5ub3RhdGlvbigpIHtcbiAgdGhpcy53b3JkKFwibnVsbFwiKTtcbn1cbmZ1bmN0aW9uIERlY2xhcmVDbGFzcyhub2RlLCBwYXJlbnQpIHtcbiAgaWYgKCFpc0RlY2xhcmVFeHBvcnREZWNsYXJhdGlvbihwYXJlbnQpKSB7XG4gICAgdGhpcy53b3JkKFwiZGVjbGFyZVwiKTtcbiAgICB0aGlzLnNwYWNlKCk7XG4gIH1cbiAgdGhpcy53b3JkKFwiY2xhc3NcIik7XG4gIHRoaXMuc3BhY2UoKTtcbiAgdGhpcy5faW50ZXJmYWNlaXNoKG5vZGUpO1xufVxuZnVuY3Rpb24gRGVjbGFyZUZ1bmN0aW9uKG5vZGUsIHBhcmVudCkge1xuICBpZiAoIWlzRGVjbGFyZUV4cG9ydERlY2xhcmF0aW9uKHBhcmVudCkpIHtcbiAgICB0aGlzLndvcmQoXCJkZWNsYXJlXCIpO1xuICAgIHRoaXMuc3BhY2UoKTtcbiAgfVxuICB0aGlzLndvcmQoXCJmdW5jdGlvblwiKTtcbiAgdGhpcy5zcGFjZSgpO1xuICB0aGlzLnByaW50KG5vZGUuaWQpO1xuICB0aGlzLnByaW50KG5vZGUuaWQudHlwZUFubm90YXRpb24udHlwZUFubm90YXRpb24pO1xuICBpZiAobm9kZS5wcmVkaWNhdGUpIHtcbiAgICB0aGlzLnNwYWNlKCk7XG4gICAgdGhpcy5wcmludChub2RlLnByZWRpY2F0ZSk7XG4gIH1cbiAgdGhpcy5zZW1pY29sb24oKTtcbn1cbmZ1bmN0aW9uIEluZmVycmVkUHJlZGljYXRlKCkge1xuICB0aGlzLnRva2VuQ2hhcigzNyk7XG4gIHRoaXMud29yZChcImNoZWNrc1wiKTtcbn1cbmZ1bmN0aW9uIERlY2xhcmVkUHJlZGljYXRlKG5vZGUpIHtcbiAgdGhpcy50b2tlbkNoYXIoMzcpO1xuICB0aGlzLndvcmQoXCJjaGVja3NcIik7XG4gIHRoaXMudG9rZW5DaGFyKDQwKTtcbiAgdGhpcy5wcmludChub2RlLnZhbHVlKTtcbiAgdGhpcy50b2tlbkNoYXIoNDEpO1xufVxuZnVuY3Rpb24gRGVjbGFyZUludGVyZmFjZShub2RlKSB7XG4gIHRoaXMud29yZChcImRlY2xhcmVcIik7XG4gIHRoaXMuc3BhY2UoKTtcbiAgdGhpcy5JbnRlcmZhY2VEZWNsYXJhdGlvbihub2RlKTtcbn1cbmZ1bmN0aW9uIERlY2xhcmVNb2R1bGUobm9kZSkge1xuICB0aGlzLndvcmQoXCJkZWNsYXJlXCIpO1xuICB0aGlzLnNwYWNlKCk7XG4gIHRoaXMud29yZChcIm1vZHVsZVwiKTtcbiAgdGhpcy5zcGFjZSgpO1xuICB0aGlzLnByaW50KG5vZGUuaWQpO1xuICB0aGlzLnNwYWNlKCk7XG4gIHRoaXMucHJpbnQobm9kZS5ib2R5KTtcbn1cbmZ1bmN0aW9uIERlY2xhcmVNb2R1bGVFeHBvcnRzKG5vZGUpIHtcbiAgdGhpcy53b3JkKFwiZGVjbGFyZVwiKTtcbiAgdGhpcy5zcGFjZSgpO1xuICB0aGlzLndvcmQoXCJtb2R1bGVcIik7XG4gIHRoaXMudG9rZW5DaGFyKDQ2KTtcbiAgdGhpcy53b3JkKFwiZXhwb3J0c1wiKTtcbiAgdGhpcy5wcmludChub2RlLnR5cGVBbm5vdGF0aW9uKTtcbn1cbmZ1bmN0aW9uIERlY2xhcmVUeXBlQWxpYXMobm9kZSkge1xuICB0aGlzLndvcmQoXCJkZWNsYXJlXCIpO1xuICB0aGlzLnNwYWNlKCk7XG4gIHRoaXMuVHlwZUFsaWFzKG5vZGUpO1xufVxuZnVuY3Rpb24gRGVjbGFyZU9wYXF1ZVR5cGUobm9kZSwgcGFyZW50KSB7XG4gIGlmICghaXNEZWNsYXJlRXhwb3J0RGVjbGFyYXRpb24ocGFyZW50KSkge1xuICAgIHRoaXMud29yZChcImRlY2xhcmVcIik7XG4gICAgdGhpcy5zcGFjZSgpO1xuICB9XG4gIHRoaXMuT3BhcXVlVHlwZShub2RlKTtcbn1cbmZ1bmN0aW9uIERlY2xhcmVWYXJpYWJsZShub2RlLCBwYXJlbnQpIHtcbiAgaWYgKCFpc0RlY2xhcmVFeHBvcnREZWNsYXJhdGlvbihwYXJlbnQpKSB7XG4gICAgdGhpcy53b3JkKFwiZGVjbGFyZVwiKTtcbiAgICB0aGlzLnNwYWNlKCk7XG4gIH1cbiAgdGhpcy53b3JkKFwidmFyXCIpO1xuICB0aGlzLnNwYWNlKCk7XG4gIHRoaXMucHJpbnQobm9kZS5pZCk7XG4gIHRoaXMucHJpbnQobm9kZS5pZC50eXBlQW5ub3RhdGlvbik7XG4gIHRoaXMuc2VtaWNvbG9uKCk7XG59XG5mdW5jdGlvbiBEZWNsYXJlRXhwb3J0RGVjbGFyYXRpb24obm9kZSkge1xuICB0aGlzLndvcmQoXCJkZWNsYXJlXCIpO1xuICB0aGlzLnNwYWNlKCk7XG4gIHRoaXMud29yZChcImV4cG9ydFwiKTtcbiAgdGhpcy5zcGFjZSgpO1xuICBpZiAobm9kZS5kZWZhdWx0KSB7XG4gICAgdGhpcy53b3JkKFwiZGVmYXVsdFwiKTtcbiAgICB0aGlzLnNwYWNlKCk7XG4gIH1cbiAgRmxvd0V4cG9ydERlY2xhcmF0aW9uLmNhbGwodGhpcywgbm9kZSk7XG59XG5mdW5jdGlvbiBEZWNsYXJlRXhwb3J0QWxsRGVjbGFyYXRpb24obm9kZSkge1xuICB0aGlzLndvcmQoXCJkZWNsYXJlXCIpO1xuICB0aGlzLnNwYWNlKCk7XG4gIF9tb2R1bGVzLkV4cG9ydEFsbERlY2xhcmF0aW9uLmNhbGwodGhpcywgbm9kZSk7XG59XG5mdW5jdGlvbiBFbnVtRGVjbGFyYXRpb24obm9kZSkge1xuICBjb25zdCB7XG4gICAgaWQsXG4gICAgYm9keVxuICB9ID0gbm9kZTtcbiAgdGhpcy53b3JkKFwiZW51bVwiKTtcbiAgdGhpcy5zcGFjZSgpO1xuICB0aGlzLnByaW50KGlkKTtcbiAgdGhpcy5wcmludChib2R5KTtcbn1cbmZ1bmN0aW9uIGVudW1FeHBsaWNpdFR5cGUoY29udGV4dCwgbmFtZSwgaGFzRXhwbGljaXRUeXBlKSB7XG4gIGlmIChoYXNFeHBsaWNpdFR5cGUpIHtcbiAgICBjb250ZXh0LnNwYWNlKCk7XG4gICAgY29udGV4dC53b3JkKFwib2ZcIik7XG4gICAgY29udGV4dC5zcGFjZSgpO1xuICAgIGNvbnRleHQud29yZChuYW1lKTtcbiAgfVxuICBjb250ZXh0LnNwYWNlKCk7XG59XG5mdW5jdGlvbiBlbnVtQm9keShjb250ZXh0LCBub2RlKSB7XG4gIGNvbnN0IHtcbiAgICBtZW1iZXJzXG4gIH0gPSBub2RlO1xuICBjb250ZXh0LnRva2VuKFwie1wiKTtcbiAgY29udGV4dC5pbmRlbnQoKTtcbiAgY29udGV4dC5uZXdsaW5lKCk7XG4gIGZvciAoY29uc3QgbWVtYmVyIG9mIG1lbWJlcnMpIHtcbiAgICBjb250ZXh0LnByaW50KG1lbWJlcik7XG4gICAgY29udGV4dC5uZXdsaW5lKCk7XG4gIH1cbiAgaWYgKG5vZGUuaGFzVW5rbm93bk1lbWJlcnMpIHtcbiAgICBjb250ZXh0LnRva2VuKFwiLi4uXCIpO1xuICAgIGNvbnRleHQubmV3bGluZSgpO1xuICB9XG4gIGNvbnRleHQuZGVkZW50KCk7XG4gIGNvbnRleHQudG9rZW4oXCJ9XCIpO1xufVxuZnVuY3Rpb24gRW51bUJvb2xlYW5Cb2R5KG5vZGUpIHtcbiAgY29uc3Qge1xuICAgIGV4cGxpY2l0VHlwZVxuICB9ID0gbm9kZTtcbiAgZW51bUV4cGxpY2l0VHlwZSh0aGlzLCBcImJvb2xlYW5cIiwgZXhwbGljaXRUeXBlKTtcbiAgZW51bUJvZHkodGhpcywgbm9kZSk7XG59XG5mdW5jdGlvbiBFbnVtTnVtYmVyQm9keShub2RlKSB7XG4gIGNvbnN0IHtcbiAgICBleHBsaWNpdFR5cGVcbiAgfSA9IG5vZGU7XG4gIGVudW1FeHBsaWNpdFR5cGUodGhpcywgXCJudW1iZXJcIiwgZXhwbGljaXRUeXBlKTtcbiAgZW51bUJvZHkodGhpcywgbm9kZSk7XG59XG5mdW5jdGlvbiBFbnVtU3RyaW5nQm9keShub2RlKSB7XG4gIGNvbnN0IHtcbiAgICBleHBsaWNpdFR5cGVcbiAgfSA9IG5vZGU7XG4gIGVudW1FeHBsaWNpdFR5cGUodGhpcywgXCJzdHJpbmdcIiwgZXhwbGljaXRUeXBlKTtcbiAgZW51bUJvZHkodGhpcywgbm9kZSk7XG59XG5mdW5jdGlvbiBFbnVtU3ltYm9sQm9keShub2RlKSB7XG4gIGVudW1FeHBsaWNpdFR5cGUodGhpcywgXCJzeW1ib2xcIiwgdHJ1ZSk7XG4gIGVudW1Cb2R5KHRoaXMsIG5vZGUpO1xufVxuZnVuY3Rpb24gRW51bURlZmF1bHRlZE1lbWJlcihub2RlKSB7XG4gIGNvbnN0IHtcbiAgICBpZFxuICB9ID0gbm9kZTtcbiAgdGhpcy5wcmludChpZCk7XG4gIHRoaXMudG9rZW5DaGFyKDQ0KTtcbn1cbmZ1bmN0aW9uIGVudW1Jbml0aWFsaXplZE1lbWJlcihjb250ZXh0LCBub2RlKSB7XG4gIGNvbnRleHQucHJpbnQobm9kZS5pZCk7XG4gIGNvbnRleHQuc3BhY2UoKTtcbiAgY29udGV4dC50b2tlbihcIj1cIik7XG4gIGNvbnRleHQuc3BhY2UoKTtcbiAgY29udGV4dC5wcmludChub2RlLmluaXQpO1xuICBjb250ZXh0LnRva2VuKFwiLFwiKTtcbn1cbmZ1bmN0aW9uIEVudW1Cb29sZWFuTWVtYmVyKG5vZGUpIHtcbiAgZW51bUluaXRpYWxpemVkTWVtYmVyKHRoaXMsIG5vZGUpO1xufVxuZnVuY3Rpb24gRW51bU51bWJlck1lbWJlcihub2RlKSB7XG4gIGVudW1Jbml0aWFsaXplZE1lbWJlcih0aGlzLCBub2RlKTtcbn1cbmZ1bmN0aW9uIEVudW1TdHJpbmdNZW1iZXIobm9kZSkge1xuICBlbnVtSW5pdGlhbGl6ZWRNZW1iZXIodGhpcywgbm9kZSk7XG59XG5mdW5jdGlvbiBGbG93RXhwb3J0RGVjbGFyYXRpb24obm9kZSkge1xuICBpZiAobm9kZS5kZWNsYXJhdGlvbikge1xuICAgIGNvbnN0IGRlY2xhciA9IG5vZGUuZGVjbGFyYXRpb247XG4gICAgdGhpcy5wcmludChkZWNsYXIpO1xuICAgIGlmICghaXNTdGF0ZW1lbnQoZGVjbGFyKSkgdGhpcy5zZW1pY29sb24oKTtcbiAgfSBlbHNlIHtcbiAgICB0aGlzLnRva2VuQ2hhcigxMjMpO1xuICAgIGlmIChub2RlLnNwZWNpZmllcnMubGVuZ3RoKSB7XG4gICAgICB0aGlzLnNwYWNlKCk7XG4gICAgICB0aGlzLnByaW50TGlzdChub2RlLnNwZWNpZmllcnMpO1xuICAgICAgdGhpcy5zcGFjZSgpO1xuICAgIH1cbiAgICB0aGlzLnRva2VuQ2hhcigxMjUpO1xuICAgIGlmIChub2RlLnNvdXJjZSkge1xuICAgICAgdGhpcy5zcGFjZSgpO1xuICAgICAgdGhpcy53b3JkKFwiZnJvbVwiKTtcbiAgICAgIHRoaXMuc3BhY2UoKTtcbiAgICAgIHRoaXMucHJpbnQobm9kZS5zb3VyY2UpO1xuICAgIH1cbiAgICB0aGlzLnNlbWljb2xvbigpO1xuICB9XG59XG5mdW5jdGlvbiBFeGlzdHNUeXBlQW5ub3RhdGlvbigpIHtcbiAgdGhpcy50b2tlbkNoYXIoNDIpO1xufVxuZnVuY3Rpb24gRnVuY3Rpb25UeXBlQW5ub3RhdGlvbihub2RlLCBwYXJlbnQpIHtcbiAgdGhpcy5wcmludChub2RlLnR5cGVQYXJhbWV0ZXJzKTtcbiAgdGhpcy50b2tlbkNoYXIoNDApO1xuICBpZiAobm9kZS50aGlzKSB7XG4gICAgdGhpcy53b3JkKFwidGhpc1wiKTtcbiAgICB0aGlzLnRva2VuQ2hhcig1OCk7XG4gICAgdGhpcy5zcGFjZSgpO1xuICAgIHRoaXMucHJpbnQobm9kZS50aGlzLnR5cGVBbm5vdGF0aW9uKTtcbiAgICBpZiAobm9kZS5wYXJhbXMubGVuZ3RoIHx8IG5vZGUucmVzdCkge1xuICAgICAgdGhpcy50b2tlbkNoYXIoNDQpO1xuICAgICAgdGhpcy5zcGFjZSgpO1xuICAgIH1cbiAgfVxuICB0aGlzLnByaW50TGlzdChub2RlLnBhcmFtcyk7XG4gIGlmIChub2RlLnJlc3QpIHtcbiAgICBpZiAobm9kZS5wYXJhbXMubGVuZ3RoKSB7XG4gICAgICB0aGlzLnRva2VuQ2hhcig0NCk7XG4gICAgICB0aGlzLnNwYWNlKCk7XG4gICAgfVxuICAgIHRoaXMudG9rZW4oXCIuLi5cIik7XG4gICAgdGhpcy5wcmludChub2RlLnJlc3QpO1xuICB9XG4gIHRoaXMudG9rZW5DaGFyKDQxKTtcbiAgY29uc3QgdHlwZSA9IHBhcmVudCA9PSBudWxsID8gdm9pZCAwIDogcGFyZW50LnR5cGU7XG4gIGlmICh0eXBlICE9IG51bGwgJiYgKHR5cGUgPT09IFwiT2JqZWN0VHlwZUNhbGxQcm9wZXJ0eVwiIHx8IHR5cGUgPT09IFwiT2JqZWN0VHlwZUludGVybmFsU2xvdFwiIHx8IHR5cGUgPT09IFwiRGVjbGFyZUZ1bmN0aW9uXCIgfHwgdHlwZSA9PT0gXCJPYmplY3RUeXBlUHJvcGVydHlcIiAmJiBwYXJlbnQubWV0aG9kKSkge1xuICAgIHRoaXMudG9rZW5DaGFyKDU4KTtcbiAgfSBlbHNlIHtcbiAgICB0aGlzLnNwYWNlKCk7XG4gICAgdGhpcy50b2tlbihcIj0+XCIpO1xuICB9XG4gIHRoaXMuc3BhY2UoKTtcbiAgdGhpcy5wcmludChub2RlLnJldHVyblR5cGUpO1xufVxuZnVuY3Rpb24gRnVuY3Rpb25UeXBlUGFyYW0obm9kZSkge1xuICB0aGlzLnByaW50KG5vZGUubmFtZSk7XG4gIGlmIChub2RlLm9wdGlvbmFsKSB0aGlzLnRva2VuQ2hhcig2Myk7XG4gIGlmIChub2RlLm5hbWUpIHtcbiAgICB0aGlzLnRva2VuQ2hhcig1OCk7XG4gICAgdGhpcy5zcGFjZSgpO1xuICB9XG4gIHRoaXMucHJpbnQobm9kZS50eXBlQW5ub3RhdGlvbik7XG59XG5mdW5jdGlvbiBJbnRlcmZhY2VFeHRlbmRzKG5vZGUpIHtcbiAgdGhpcy5wcmludChub2RlLmlkKTtcbiAgdGhpcy5wcmludChub2RlLnR5cGVQYXJhbWV0ZXJzLCB0cnVlKTtcbn1cbmZ1bmN0aW9uIF9pbnRlcmZhY2Vpc2gobm9kZSkge1xuICB2YXIgX25vZGUkZXh0ZW5kcztcbiAgdGhpcy5wcmludChub2RlLmlkKTtcbiAgdGhpcy5wcmludChub2RlLnR5cGVQYXJhbWV0ZXJzKTtcbiAgaWYgKChfbm9kZSRleHRlbmRzID0gbm9kZS5leHRlbmRzKSAhPSBudWxsICYmIF9ub2RlJGV4dGVuZHMubGVuZ3RoKSB7XG4gICAgdGhpcy5zcGFjZSgpO1xuICAgIHRoaXMud29yZChcImV4dGVuZHNcIik7XG4gICAgdGhpcy5zcGFjZSgpO1xuICAgIHRoaXMucHJpbnRMaXN0KG5vZGUuZXh0ZW5kcyk7XG4gIH1cbiAgaWYgKG5vZGUudHlwZSA9PT0gXCJEZWNsYXJlQ2xhc3NcIikge1xuICAgIHZhciBfbm9kZSRtaXhpbnMsIF9ub2RlJGltcGxlbWVudHM7XG4gICAgaWYgKChfbm9kZSRtaXhpbnMgPSBub2RlLm1peGlucykgIT0gbnVsbCAmJiBfbm9kZSRtaXhpbnMubGVuZ3RoKSB7XG4gICAgICB0aGlzLnNwYWNlKCk7XG4gICAgICB0aGlzLndvcmQoXCJtaXhpbnNcIik7XG4gICAgICB0aGlzLnNwYWNlKCk7XG4gICAgICB0aGlzLnByaW50TGlzdChub2RlLm1peGlucyk7XG4gICAgfVxuICAgIGlmICgoX25vZGUkaW1wbGVtZW50cyA9IG5vZGUuaW1wbGVtZW50cykgIT0gbnVsbCAmJiBfbm9kZSRpbXBsZW1lbnRzLmxlbmd0aCkge1xuICAgICAgdGhpcy5zcGFjZSgpO1xuICAgICAgdGhpcy53b3JkKFwiaW1wbGVtZW50c1wiKTtcbiAgICAgIHRoaXMuc3BhY2UoKTtcbiAgICAgIHRoaXMucHJpbnRMaXN0KG5vZGUuaW1wbGVtZW50cyk7XG4gICAgfVxuICB9XG4gIHRoaXMuc3BhY2UoKTtcbiAgdGhpcy5wcmludChub2RlLmJvZHkpO1xufVxuZnVuY3Rpb24gX3ZhcmlhbmNlKG5vZGUpIHtcbiAgdmFyIF9ub2RlJHZhcmlhbmNlO1xuICBjb25zdCBraW5kID0gKF9ub2RlJHZhcmlhbmNlID0gbm9kZS52YXJpYW5jZSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9ub2RlJHZhcmlhbmNlLmtpbmQ7XG4gIGlmIChraW5kICE9IG51bGwpIHtcbiAgICBpZiAoa2luZCA9PT0gXCJwbHVzXCIpIHtcbiAgICAgIHRoaXMudG9rZW5DaGFyKDQzKTtcbiAgICB9IGVsc2UgaWYgKGtpbmQgPT09IFwibWludXNcIikge1xuICAgICAgdGhpcy50b2tlbkNoYXIoNDUpO1xuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gSW50ZXJmYWNlRGVjbGFyYXRpb24obm9kZSkge1xuICB0aGlzLndvcmQoXCJpbnRlcmZhY2VcIik7XG4gIHRoaXMuc3BhY2UoKTtcbiAgdGhpcy5faW50ZXJmYWNlaXNoKG5vZGUpO1xufVxuZnVuY3Rpb24gYW5kU2VwYXJhdG9yKG9jY3VycmVuY2VDb3VudCkge1xuICB0aGlzLnNwYWNlKCk7XG4gIHRoaXMudG9rZW4oXCImXCIsIGZhbHNlLCBvY2N1cnJlbmNlQ291bnQpO1xuICB0aGlzLnNwYWNlKCk7XG59XG5mdW5jdGlvbiBJbnRlcmZhY2VUeXBlQW5ub3RhdGlvbihub2RlKSB7XG4gIHZhciBfbm9kZSRleHRlbmRzMjtcbiAgdGhpcy53b3JkKFwiaW50ZXJmYWNlXCIpO1xuICBpZiAoKF9ub2RlJGV4dGVuZHMyID0gbm9kZS5leHRlbmRzKSAhPSBudWxsICYmIF9ub2RlJGV4dGVuZHMyLmxlbmd0aCkge1xuICAgIHRoaXMuc3BhY2UoKTtcbiAgICB0aGlzLndvcmQoXCJleHRlbmRzXCIpO1xuICAgIHRoaXMuc3BhY2UoKTtcbiAgICB0aGlzLnByaW50TGlzdChub2RlLmV4dGVuZHMpO1xuICB9XG4gIHRoaXMuc3BhY2UoKTtcbiAgdGhpcy5wcmludChub2RlLmJvZHkpO1xufVxuZnVuY3Rpb24gSW50ZXJzZWN0aW9uVHlwZUFubm90YXRpb24obm9kZSkge1xuICB0aGlzLnByaW50Sm9pbihub2RlLnR5cGVzLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgYW5kU2VwYXJhdG9yKTtcbn1cbmZ1bmN0aW9uIE1peGVkVHlwZUFubm90YXRpb24oKSB7XG4gIHRoaXMud29yZChcIm1peGVkXCIpO1xufVxuZnVuY3Rpb24gRW1wdHlUeXBlQW5ub3RhdGlvbigpIHtcbiAgdGhpcy53b3JkKFwiZW1wdHlcIik7XG59XG5mdW5jdGlvbiBOdWxsYWJsZVR5cGVBbm5vdGF0aW9uKG5vZGUpIHtcbiAgdGhpcy50b2tlbkNoYXIoNjMpO1xuICB0aGlzLnByaW50KG5vZGUudHlwZUFubm90YXRpb24pO1xufVxuZnVuY3Rpb24gTnVtYmVyVHlwZUFubm90YXRpb24oKSB7XG4gIHRoaXMud29yZChcIm51bWJlclwiKTtcbn1cbmZ1bmN0aW9uIFN0cmluZ1R5cGVBbm5vdGF0aW9uKCkge1xuICB0aGlzLndvcmQoXCJzdHJpbmdcIik7XG59XG5mdW5jdGlvbiBUaGlzVHlwZUFubm90YXRpb24oKSB7XG4gIHRoaXMud29yZChcInRoaXNcIik7XG59XG5mdW5jdGlvbiBUdXBsZVR5cGVBbm5vdGF0aW9uKG5vZGUpIHtcbiAgdGhpcy50b2tlbkNoYXIoOTEpO1xuICB0aGlzLnByaW50TGlzdChub2RlLnR5cGVzKTtcbiAgdGhpcy50b2tlbkNoYXIoOTMpO1xufVxuZnVuY3Rpb24gVHlwZW9mVHlwZUFubm90YXRpb24obm9kZSkge1xuICB0aGlzLndvcmQoXCJ0eXBlb2ZcIik7XG4gIHRoaXMuc3BhY2UoKTtcbiAgdGhpcy5wcmludChub2RlLmFyZ3VtZW50KTtcbn1cbmZ1bmN0aW9uIFR5cGVBbGlhcyhub2RlKSB7XG4gIHRoaXMud29yZChcInR5cGVcIik7XG4gIHRoaXMuc3BhY2UoKTtcbiAgdGhpcy5wcmludChub2RlLmlkKTtcbiAgdGhpcy5wcmludChub2RlLnR5cGVQYXJhbWV0ZXJzKTtcbiAgdGhpcy5zcGFjZSgpO1xuICB0aGlzLnRva2VuQ2hhcig2MSk7XG4gIHRoaXMuc3BhY2UoKTtcbiAgdGhpcy5wcmludChub2RlLnJpZ2h0KTtcbiAgdGhpcy5zZW1pY29sb24oKTtcbn1cbmZ1bmN0aW9uIFR5cGVBbm5vdGF0aW9uKG5vZGUsIHBhcmVudCkge1xuICB0aGlzLnRva2VuQ2hhcig1OCk7XG4gIHRoaXMuc3BhY2UoKTtcbiAgaWYgKHBhcmVudC50eXBlID09PSBcIkFycm93RnVuY3Rpb25FeHByZXNzaW9uXCIpIHtcbiAgICB0aGlzLnRva2VuQ29udGV4dCB8PSBfaW5kZXguVG9rZW5Db250ZXh0LmFycm93Rmxvd1JldHVyblR5cGU7XG4gIH0gZWxzZSBpZiAobm9kZS5vcHRpb25hbCkge1xuICAgIHRoaXMudG9rZW5DaGFyKDYzKTtcbiAgfVxuICB0aGlzLnByaW50KG5vZGUudHlwZUFubm90YXRpb24pO1xufVxuZnVuY3Rpb24gVHlwZVBhcmFtZXRlckluc3RhbnRpYXRpb24obm9kZSkge1xuICB0aGlzLnRva2VuQ2hhcig2MCk7XG4gIHRoaXMucHJpbnRMaXN0KG5vZGUucGFyYW1zKTtcbiAgdGhpcy50b2tlbkNoYXIoNjIpO1xufVxuZnVuY3Rpb24gVHlwZVBhcmFtZXRlcihub2RlKSB7XG4gIHRoaXMuX3ZhcmlhbmNlKG5vZGUpO1xuICB0aGlzLndvcmQobm9kZS5uYW1lKTtcbiAgaWYgKG5vZGUuYm91bmQpIHtcbiAgICB0aGlzLnByaW50KG5vZGUuYm91bmQpO1xuICB9XG4gIGlmIChub2RlLmRlZmF1bHQpIHtcbiAgICB0aGlzLnNwYWNlKCk7XG4gICAgdGhpcy50b2tlbkNoYXIoNjEpO1xuICAgIHRoaXMuc3BhY2UoKTtcbiAgICB0aGlzLnByaW50KG5vZGUuZGVmYXVsdCk7XG4gIH1cbn1cbmZ1bmN0aW9uIE9wYXF1ZVR5cGUobm9kZSkge1xuICB0aGlzLndvcmQoXCJvcGFxdWVcIik7XG4gIHRoaXMuc3BhY2UoKTtcbiAgdGhpcy53b3JkKFwidHlwZVwiKTtcbiAgdGhpcy5zcGFjZSgpO1xuICB0aGlzLnByaW50KG5vZGUuaWQpO1xuICB0aGlzLnByaW50KG5vZGUudHlwZVBhcmFtZXRlcnMpO1xuICBpZiAobm9kZS5zdXBlcnR5cGUpIHtcbiAgICB0aGlzLnRva2VuQ2hhcig1OCk7XG4gICAgdGhpcy5zcGFjZSgpO1xuICAgIHRoaXMucHJpbnQobm9kZS5zdXBlcnR5cGUpO1xuICB9XG4gIGlmIChub2RlLmltcGx0eXBlKSB7XG4gICAgdGhpcy5zcGFjZSgpO1xuICAgIHRoaXMudG9rZW5DaGFyKDYxKTtcbiAgICB0aGlzLnNwYWNlKCk7XG4gICAgdGhpcy5wcmludChub2RlLmltcGx0eXBlKTtcbiAgfVxuICB0aGlzLnNlbWljb2xvbigpO1xufVxuZnVuY3Rpb24gT2JqZWN0VHlwZUFubm90YXRpb24obm9kZSkge1xuICBpZiAobm9kZS5leGFjdCkge1xuICAgIHRoaXMudG9rZW4oXCJ7fFwiKTtcbiAgfSBlbHNlIHtcbiAgICB0aGlzLnRva2VuQ2hhcigxMjMpO1xuICB9XG4gIGNvbnN0IHByb3BzID0gWy4uLm5vZGUucHJvcGVydGllcywgLi4uKG5vZGUuY2FsbFByb3BlcnRpZXMgfHwgW10pLCAuLi4obm9kZS5pbmRleGVycyB8fCBbXSksIC4uLihub2RlLmludGVybmFsU2xvdHMgfHwgW10pXTtcbiAgaWYgKHByb3BzLmxlbmd0aCkge1xuICAgIHRoaXMubmV3bGluZSgpO1xuICAgIHRoaXMuc3BhY2UoKTtcbiAgICB0aGlzLnByaW50Sm9pbihwcm9wcywgdHJ1ZSwgdHJ1ZSwgdW5kZWZpbmVkLCB1bmRlZmluZWQsICgpID0+IHtcbiAgICAgIGlmIChwcm9wcy5sZW5ndGggIT09IDEgfHwgbm9kZS5pbmV4YWN0KSB7XG4gICAgICAgIHRoaXMudG9rZW5DaGFyKDQ0KTtcbiAgICAgICAgdGhpcy5zcGFjZSgpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHRoaXMuc3BhY2UoKTtcbiAgfVxuICBpZiAobm9kZS5pbmV4YWN0KSB7XG4gICAgdGhpcy5pbmRlbnQoKTtcbiAgICB0aGlzLnRva2VuKFwiLi4uXCIpO1xuICAgIGlmIChwcm9wcy5sZW5ndGgpIHtcbiAgICAgIHRoaXMubmV3bGluZSgpO1xuICAgIH1cbiAgICB0aGlzLmRlZGVudCgpO1xuICB9XG4gIGlmIChub2RlLmV4YWN0KSB7XG4gICAgdGhpcy50b2tlbihcInx9XCIpO1xuICB9IGVsc2Uge1xuICAgIHRoaXMudG9rZW5DaGFyKDEyNSk7XG4gIH1cbn1cbmZ1bmN0aW9uIE9iamVjdFR5cGVJbnRlcm5hbFNsb3Qobm9kZSkge1xuICBpZiAobm9kZS5zdGF0aWMpIHtcbiAgICB0aGlzLndvcmQoXCJzdGF0aWNcIik7XG4gICAgdGhpcy5zcGFjZSgpO1xuICB9XG4gIHRoaXMudG9rZW5DaGFyKDkxKTtcbiAgdGhpcy50b2tlbkNoYXIoOTEpO1xuICB0aGlzLnByaW50KG5vZGUuaWQpO1xuICB0aGlzLnRva2VuQ2hhcig5Myk7XG4gIHRoaXMudG9rZW5DaGFyKDkzKTtcbiAgaWYgKG5vZGUub3B0aW9uYWwpIHRoaXMudG9rZW5DaGFyKDYzKTtcbiAgaWYgKCFub2RlLm1ldGhvZCkge1xuICAgIHRoaXMudG9rZW5DaGFyKDU4KTtcbiAgICB0aGlzLnNwYWNlKCk7XG4gIH1cbiAgdGhpcy5wcmludChub2RlLnZhbHVlKTtcbn1cbmZ1bmN0aW9uIE9iamVjdFR5cGVDYWxsUHJvcGVydHkobm9kZSkge1xuICBpZiAobm9kZS5zdGF0aWMpIHtcbiAgICB0aGlzLndvcmQoXCJzdGF0aWNcIik7XG4gICAgdGhpcy5zcGFjZSgpO1xuICB9XG4gIHRoaXMucHJpbnQobm9kZS52YWx1ZSk7XG59XG5mdW5jdGlvbiBPYmplY3RUeXBlSW5kZXhlcihub2RlKSB7XG4gIGlmIChub2RlLnN0YXRpYykge1xuICAgIHRoaXMud29yZChcInN0YXRpY1wiKTtcbiAgICB0aGlzLnNwYWNlKCk7XG4gIH1cbiAgdGhpcy5fdmFyaWFuY2Uobm9kZSk7XG4gIHRoaXMudG9rZW5DaGFyKDkxKTtcbiAgaWYgKG5vZGUuaWQpIHtcbiAgICB0aGlzLnByaW50KG5vZGUuaWQpO1xuICAgIHRoaXMudG9rZW5DaGFyKDU4KTtcbiAgICB0aGlzLnNwYWNlKCk7XG4gIH1cbiAgdGhpcy5wcmludChub2RlLmtleSk7XG4gIHRoaXMudG9rZW5DaGFyKDkzKTtcbiAgdGhpcy50b2tlbkNoYXIoNTgpO1xuICB0aGlzLnNwYWNlKCk7XG4gIHRoaXMucHJpbnQobm9kZS52YWx1ZSk7XG59XG5mdW5jdGlvbiBPYmplY3RUeXBlUHJvcGVydHkobm9kZSkge1xuICBpZiAobm9kZS5wcm90bykge1xuICAgIHRoaXMud29yZChcInByb3RvXCIpO1xuICAgIHRoaXMuc3BhY2UoKTtcbiAgfVxuICBpZiAobm9kZS5zdGF0aWMpIHtcbiAgICB0aGlzLndvcmQoXCJzdGF0aWNcIik7XG4gICAgdGhpcy5zcGFjZSgpO1xuICB9XG4gIGlmIChub2RlLmtpbmQgPT09IFwiZ2V0XCIgfHwgbm9kZS5raW5kID09PSBcInNldFwiKSB7XG4gICAgdGhpcy53b3JkKG5vZGUua2luZCk7XG4gICAgdGhpcy5zcGFjZSgpO1xuICB9XG4gIHRoaXMuX3ZhcmlhbmNlKG5vZGUpO1xuICB0aGlzLnByaW50KG5vZGUua2V5KTtcbiAgaWYgKG5vZGUub3B0aW9uYWwpIHRoaXMudG9rZW5DaGFyKDYzKTtcbiAgaWYgKCFub2RlLm1ldGhvZCkge1xuICAgIHRoaXMudG9rZW5DaGFyKDU4KTtcbiAgICB0aGlzLnNwYWNlKCk7XG4gIH1cbiAgdGhpcy5wcmludChub2RlLnZhbHVlKTtcbn1cbmZ1bmN0aW9uIE9iamVjdFR5cGVTcHJlYWRQcm9wZXJ0eShub2RlKSB7XG4gIHRoaXMudG9rZW4oXCIuLi5cIik7XG4gIHRoaXMucHJpbnQobm9kZS5hcmd1bWVudCk7XG59XG5mdW5jdGlvbiBRdWFsaWZpZWRUeXBlSWRlbnRpZmllcihub2RlKSB7XG4gIHRoaXMucHJpbnQobm9kZS5xdWFsaWZpY2F0aW9uKTtcbiAgdGhpcy50b2tlbkNoYXIoNDYpO1xuICB0aGlzLnByaW50KG5vZGUuaWQpO1xufVxuZnVuY3Rpb24gU3ltYm9sVHlwZUFubm90YXRpb24oKSB7XG4gIHRoaXMud29yZChcInN5bWJvbFwiKTtcbn1cbmZ1bmN0aW9uIG9yU2VwYXJhdG9yKG9jY3VycmVuY2VDb3VudCkge1xuICB0aGlzLnNwYWNlKCk7XG4gIHRoaXMudG9rZW4oXCJ8XCIsIGZhbHNlLCBvY2N1cnJlbmNlQ291bnQpO1xuICB0aGlzLnNwYWNlKCk7XG59XG5mdW5jdGlvbiBVbmlvblR5cGVBbm5vdGF0aW9uKG5vZGUpIHtcbiAgdGhpcy5wcmludEpvaW4obm9kZS50eXBlcywgdW5kZWZpbmVkLCB1bmRlZmluZWQsIG9yU2VwYXJhdG9yKTtcbn1cbmZ1bmN0aW9uIFR5cGVDYXN0RXhwcmVzc2lvbihub2RlKSB7XG4gIHRoaXMudG9rZW5DaGFyKDQwKTtcbiAgdGhpcy5wcmludChub2RlLmV4cHJlc3Npb24pO1xuICB0aGlzLnByaW50KG5vZGUudHlwZUFubm90YXRpb24pO1xuICB0aGlzLnRva2VuQ2hhcig0MSk7XG59XG5mdW5jdGlvbiBWYXJpYW5jZShub2RlKSB7XG4gIGlmIChub2RlLmtpbmQgPT09IFwicGx1c1wiKSB7XG4gICAgdGhpcy50b2tlbkNoYXIoNDMpO1xuICB9IGVsc2Uge1xuICAgIHRoaXMudG9rZW5DaGFyKDQ1KTtcbiAgfVxufVxuZnVuY3Rpb24gVm9pZFR5cGVBbm5vdGF0aW9uKCkge1xuICB0aGlzLndvcmQoXCJ2b2lkXCIpO1xufVxuZnVuY3Rpb24gSW5kZXhlZEFjY2Vzc1R5cGUobm9kZSkge1xuICB0aGlzLnByaW50KG5vZGUub2JqZWN0VHlwZSwgdHJ1ZSk7XG4gIHRoaXMudG9rZW5DaGFyKDkxKTtcbiAgdGhpcy5wcmludChub2RlLmluZGV4VHlwZSk7XG4gIHRoaXMudG9rZW5DaGFyKDkzKTtcbn1cbmZ1bmN0aW9uIE9wdGlvbmFsSW5kZXhlZEFjY2Vzc1R5cGUobm9kZSkge1xuICB0aGlzLnByaW50KG5vZGUub2JqZWN0VHlwZSk7XG4gIGlmIChub2RlLm9wdGlvbmFsKSB7XG4gICAgdGhpcy50b2tlbihcIj8uXCIpO1xuICB9XG4gIHRoaXMudG9rZW5DaGFyKDkxKTtcbiAgdGhpcy5wcmludChub2RlLmluZGV4VHlwZSk7XG4gIHRoaXMudG9rZW5DaGFyKDkzKTtcbn1cblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Zmxvdy5qcy5tYXBcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@babel/generator/lib/generators/flow.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@babel/generator/lib/generators/index.js":
/*!***************************************************************!*\
  !*** ./node_modules/@babel/generator/lib/generators/index.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nvar _templateLiterals = __webpack_require__(/*! ./template-literals.js */ \"(ssr)/./node_modules/@babel/generator/lib/generators/template-literals.js\");\nObject.keys(_templateLiterals).forEach(function (key) {\n  if (key === \"default\" || key === \"__esModule\") return;\n  if (key in exports && exports[key] === _templateLiterals[key]) return;\n  Object.defineProperty(exports, key, {\n    enumerable: true,\n    get: function () {\n      return _templateLiterals[key];\n    }\n  });\n});\nvar _expressions = __webpack_require__(/*! ./expressions.js */ \"(ssr)/./node_modules/@babel/generator/lib/generators/expressions.js\");\nObject.keys(_expressions).forEach(function (key) {\n  if (key === \"default\" || key === \"__esModule\") return;\n  if (key in exports && exports[key] === _expressions[key]) return;\n  Object.defineProperty(exports, key, {\n    enumerable: true,\n    get: function () {\n      return _expressions[key];\n    }\n  });\n});\nvar _statements = __webpack_require__(/*! ./statements.js */ \"(ssr)/./node_modules/@babel/generator/lib/generators/statements.js\");\nObject.keys(_statements).forEach(function (key) {\n  if (key === \"default\" || key === \"__esModule\") return;\n  if (key in exports && exports[key] === _statements[key]) return;\n  Object.defineProperty(exports, key, {\n    enumerable: true,\n    get: function () {\n      return _statements[key];\n    }\n  });\n});\nvar _classes = __webpack_require__(/*! ./classes.js */ \"(ssr)/./node_modules/@babel/generator/lib/generators/classes.js\");\nObject.keys(_classes).forEach(function (key) {\n  if (key === \"default\" || key === \"__esModule\") return;\n  if (key in exports && exports[key] === _classes[key]) return;\n  Object.defineProperty(exports, key, {\n    enumerable: true,\n    get: function () {\n      return _classes[key];\n    }\n  });\n});\nvar _methods = __webpack_require__(/*! ./methods.js */ \"(ssr)/./node_modules/@babel/generator/lib/generators/methods.js\");\nObject.keys(_methods).forEach(function (key) {\n  if (key === \"default\" || key === \"__esModule\") return;\n  if (key in exports && exports[key] === _methods[key]) return;\n  Object.defineProperty(exports, key, {\n    enumerable: true,\n    get: function () {\n      return _methods[key];\n    }\n  });\n});\nvar _modules = __webpack_require__(/*! ./modules.js */ \"(ssr)/./node_modules/@babel/generator/lib/generators/modules.js\");\nObject.keys(_modules).forEach(function (key) {\n  if (key === \"default\" || key === \"__esModule\") return;\n  if (key in exports && exports[key] === _modules[key]) return;\n  Object.defineProperty(exports, key, {\n    enumerable: true,\n    get: function () {\n      return _modules[key];\n    }\n  });\n});\nvar _types = __webpack_require__(/*! ./types.js */ \"(ssr)/./node_modules/@babel/generator/lib/generators/types.js\");\nObject.keys(_types).forEach(function (key) {\n  if (key === \"default\" || key === \"__esModule\") return;\n  if (key in exports && exports[key] === _types[key]) return;\n  Object.defineProperty(exports, key, {\n    enumerable: true,\n    get: function () {\n      return _types[key];\n    }\n  });\n});\nvar _flow = __webpack_require__(/*! ./flow.js */ \"(ssr)/./node_modules/@babel/generator/lib/generators/flow.js\");\nObject.keys(_flow).forEach(function (key) {\n  if (key === \"default\" || key === \"__esModule\") return;\n  if (key in exports && exports[key] === _flow[key]) return;\n  Object.defineProperty(exports, key, {\n    enumerable: true,\n    get: function () {\n      return _flow[key];\n    }\n  });\n});\nvar _base = __webpack_require__(/*! ./base.js */ \"(ssr)/./node_modules/@babel/generator/lib/generators/base.js\");\nObject.keys(_base).forEach(function (key) {\n  if (key === \"default\" || key === \"__esModule\") return;\n  if (key in exports && exports[key] === _base[key]) return;\n  Object.defineProperty(exports, key, {\n    enumerable: true,\n    get: function () {\n      return _base[key];\n    }\n  });\n});\nvar _jsx = __webpack_require__(/*! ./jsx.js */ \"(ssr)/./node_modules/@babel/generator/lib/generators/jsx.js\");\nObject.keys(_jsx).forEach(function (key) {\n  if (key === \"default\" || key === \"__esModule\") return;\n  if (key in exports && exports[key] === _jsx[key]) return;\n  Object.defineProperty(exports, key, {\n    enumerable: true,\n    get: function () {\n      return _jsx[key];\n    }\n  });\n});\nvar _typescript = __webpack_require__(/*! ./typescript.js */ \"(ssr)/./node_modules/@babel/generator/lib/generators/typescript.js\");\nObject.keys(_typescript).forEach(function (key) {\n  if (key === \"default\" || key === \"__esModule\") return;\n  if (key in exports && exports[key] === _typescript[key]) return;\n  Object.defineProperty(exports, key, {\n    enumerable: true,\n    get: function () {\n      return _typescript[key];\n    }\n  });\n});\n\n//# sourceMappingURL=index.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGJhYmVsL2dlbmVyYXRvci9saWIvZ2VuZXJhdG9ycy9pbmRleC5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYiw4Q0FBNkM7QUFDN0M7QUFDQSxDQUFDLEVBQUM7QUFDRix3QkFBd0IsbUJBQU8sQ0FBQyx5R0FBd0I7QUFDeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxDQUFDO0FBQ0QsbUJBQW1CLG1CQUFPLENBQUMsNkZBQWtCO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsQ0FBQztBQUNELGtCQUFrQixtQkFBTyxDQUFDLDJGQUFpQjtBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILENBQUM7QUFDRCxlQUFlLG1CQUFPLENBQUMscUZBQWM7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxDQUFDO0FBQ0QsZUFBZSxtQkFBTyxDQUFDLHFGQUFjO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsQ0FBQztBQUNELGVBQWUsbUJBQU8sQ0FBQyxxRkFBYztBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILENBQUM7QUFDRCxhQUFhLG1CQUFPLENBQUMsaUZBQVk7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxDQUFDO0FBQ0QsWUFBWSxtQkFBTyxDQUFDLCtFQUFXO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsQ0FBQztBQUNELFlBQVksbUJBQU8sQ0FBQywrRUFBVztBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILENBQUM7QUFDRCxXQUFXLG1CQUFPLENBQUMsNkVBQVU7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxDQUFDO0FBQ0Qsa0JBQWtCLG1CQUFPLENBQUMsMkZBQWlCO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsQ0FBQzs7QUFFRCIsInNvdXJjZXMiOlsid2VicGFjazovL3JlcG8tdmlzdWFsaXplci8uL25vZGVfbW9kdWxlcy9AYmFiZWwvZ2VuZXJhdG9yL2xpYi9nZW5lcmF0b3JzL2luZGV4LmpzP2QyYmUiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG52YXIgX3RlbXBsYXRlTGl0ZXJhbHMgPSByZXF1aXJlKFwiLi90ZW1wbGF0ZS1saXRlcmFscy5qc1wiKTtcbk9iamVjdC5rZXlzKF90ZW1wbGF0ZUxpdGVyYWxzKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgaWYgKGtleSA9PT0gXCJkZWZhdWx0XCIgfHwga2V5ID09PSBcIl9fZXNNb2R1bGVcIikgcmV0dXJuO1xuICBpZiAoa2V5IGluIGV4cG9ydHMgJiYgZXhwb3J0c1trZXldID09PSBfdGVtcGxhdGVMaXRlcmFsc1trZXldKSByZXR1cm47XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBrZXksIHtcbiAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIF90ZW1wbGF0ZUxpdGVyYWxzW2tleV07XG4gICAgfVxuICB9KTtcbn0pO1xudmFyIF9leHByZXNzaW9ucyA9IHJlcXVpcmUoXCIuL2V4cHJlc3Npb25zLmpzXCIpO1xuT2JqZWN0LmtleXMoX2V4cHJlc3Npb25zKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgaWYgKGtleSA9PT0gXCJkZWZhdWx0XCIgfHwga2V5ID09PSBcIl9fZXNNb2R1bGVcIikgcmV0dXJuO1xuICBpZiAoa2V5IGluIGV4cG9ydHMgJiYgZXhwb3J0c1trZXldID09PSBfZXhwcmVzc2lvbnNba2V5XSkgcmV0dXJuO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywga2V5LCB7XG4gICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBfZXhwcmVzc2lvbnNba2V5XTtcbiAgICB9XG4gIH0pO1xufSk7XG52YXIgX3N0YXRlbWVudHMgPSByZXF1aXJlKFwiLi9zdGF0ZW1lbnRzLmpzXCIpO1xuT2JqZWN0LmtleXMoX3N0YXRlbWVudHMpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICBpZiAoa2V5ID09PSBcImRlZmF1bHRcIiB8fCBrZXkgPT09IFwiX19lc01vZHVsZVwiKSByZXR1cm47XG4gIGlmIChrZXkgaW4gZXhwb3J0cyAmJiBleHBvcnRzW2tleV0gPT09IF9zdGF0ZW1lbnRzW2tleV0pIHJldHVybjtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIGtleSwge1xuICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gX3N0YXRlbWVudHNba2V5XTtcbiAgICB9XG4gIH0pO1xufSk7XG52YXIgX2NsYXNzZXMgPSByZXF1aXJlKFwiLi9jbGFzc2VzLmpzXCIpO1xuT2JqZWN0LmtleXMoX2NsYXNzZXMpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICBpZiAoa2V5ID09PSBcImRlZmF1bHRcIiB8fCBrZXkgPT09IFwiX19lc01vZHVsZVwiKSByZXR1cm47XG4gIGlmIChrZXkgaW4gZXhwb3J0cyAmJiBleHBvcnRzW2tleV0gPT09IF9jbGFzc2VzW2tleV0pIHJldHVybjtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIGtleSwge1xuICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gX2NsYXNzZXNba2V5XTtcbiAgICB9XG4gIH0pO1xufSk7XG52YXIgX21ldGhvZHMgPSByZXF1aXJlKFwiLi9tZXRob2RzLmpzXCIpO1xuT2JqZWN0LmtleXMoX21ldGhvZHMpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICBpZiAoa2V5ID09PSBcImRlZmF1bHRcIiB8fCBrZXkgPT09IFwiX19lc01vZHVsZVwiKSByZXR1cm47XG4gIGlmIChrZXkgaW4gZXhwb3J0cyAmJiBleHBvcnRzW2tleV0gPT09IF9tZXRob2RzW2tleV0pIHJldHVybjtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIGtleSwge1xuICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gX21ldGhvZHNba2V5XTtcbiAgICB9XG4gIH0pO1xufSk7XG52YXIgX21vZHVsZXMgPSByZXF1aXJlKFwiLi9tb2R1bGVzLmpzXCIpO1xuT2JqZWN0LmtleXMoX21vZHVsZXMpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICBpZiAoa2V5ID09PSBcImRlZmF1bHRcIiB8fCBrZXkgPT09IFwiX19lc01vZHVsZVwiKSByZXR1cm47XG4gIGlmIChrZXkgaW4gZXhwb3J0cyAmJiBleHBvcnRzW2tleV0gPT09IF9tb2R1bGVzW2tleV0pIHJldHVybjtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIGtleSwge1xuICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gX21vZHVsZXNba2V5XTtcbiAgICB9XG4gIH0pO1xufSk7XG52YXIgX3R5cGVzID0gcmVxdWlyZShcIi4vdHlwZXMuanNcIik7XG5PYmplY3Qua2V5cyhfdHlwZXMpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICBpZiAoa2V5ID09PSBcImRlZmF1bHRcIiB8fCBrZXkgPT09IFwiX19lc01vZHVsZVwiKSByZXR1cm47XG4gIGlmIChrZXkgaW4gZXhwb3J0cyAmJiBleHBvcnRzW2tleV0gPT09IF90eXBlc1trZXldKSByZXR1cm47XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBrZXksIHtcbiAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIF90eXBlc1trZXldO1xuICAgIH1cbiAgfSk7XG59KTtcbnZhciBfZmxvdyA9IHJlcXVpcmUoXCIuL2Zsb3cuanNcIik7XG5PYmplY3Qua2V5cyhfZmxvdykuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gIGlmIChrZXkgPT09IFwiZGVmYXVsdFwiIHx8IGtleSA9PT0gXCJfX2VzTW9kdWxlXCIpIHJldHVybjtcbiAgaWYgKGtleSBpbiBleHBvcnRzICYmIGV4cG9ydHNba2V5XSA9PT0gX2Zsb3dba2V5XSkgcmV0dXJuO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywga2V5LCB7XG4gICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBfZmxvd1trZXldO1xuICAgIH1cbiAgfSk7XG59KTtcbnZhciBfYmFzZSA9IHJlcXVpcmUoXCIuL2Jhc2UuanNcIik7XG5PYmplY3Qua2V5cyhfYmFzZSkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gIGlmIChrZXkgPT09IFwiZGVmYXVsdFwiIHx8IGtleSA9PT0gXCJfX2VzTW9kdWxlXCIpIHJldHVybjtcbiAgaWYgKGtleSBpbiBleHBvcnRzICYmIGV4cG9ydHNba2V5XSA9PT0gX2Jhc2Vba2V5XSkgcmV0dXJuO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywga2V5LCB7XG4gICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBfYmFzZVtrZXldO1xuICAgIH1cbiAgfSk7XG59KTtcbnZhciBfanN4ID0gcmVxdWlyZShcIi4vanN4LmpzXCIpO1xuT2JqZWN0LmtleXMoX2pzeCkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gIGlmIChrZXkgPT09IFwiZGVmYXVsdFwiIHx8IGtleSA9PT0gXCJfX2VzTW9kdWxlXCIpIHJldHVybjtcbiAgaWYgKGtleSBpbiBleHBvcnRzICYmIGV4cG9ydHNba2V5XSA9PT0gX2pzeFtrZXldKSByZXR1cm47XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBrZXksIHtcbiAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIF9qc3hba2V5XTtcbiAgICB9XG4gIH0pO1xufSk7XG52YXIgX3R5cGVzY3JpcHQgPSByZXF1aXJlKFwiLi90eXBlc2NyaXB0LmpzXCIpO1xuT2JqZWN0LmtleXMoX3R5cGVzY3JpcHQpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICBpZiAoa2V5ID09PSBcImRlZmF1bHRcIiB8fCBrZXkgPT09IFwiX19lc01vZHVsZVwiKSByZXR1cm47XG4gIGlmIChrZXkgaW4gZXhwb3J0cyAmJiBleHBvcnRzW2tleV0gPT09IF90eXBlc2NyaXB0W2tleV0pIHJldHVybjtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIGtleSwge1xuICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gX3R5cGVzY3JpcHRba2V5XTtcbiAgICB9XG4gIH0pO1xufSk7XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcFxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@babel/generator/lib/generators/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@babel/generator/lib/generators/jsx.js":
/*!*************************************************************!*\
  !*** ./node_modules/@babel/generator/lib/generators/jsx.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports.JSXAttribute = JSXAttribute;\nexports.JSXClosingElement = JSXClosingElement;\nexports.JSXClosingFragment = JSXClosingFragment;\nexports.JSXElement = JSXElement;\nexports.JSXEmptyExpression = JSXEmptyExpression;\nexports.JSXExpressionContainer = JSXExpressionContainer;\nexports.JSXFragment = JSXFragment;\nexports.JSXIdentifier = JSXIdentifier;\nexports.JSXMemberExpression = JSXMemberExpression;\nexports.JSXNamespacedName = JSXNamespacedName;\nexports.JSXOpeningElement = JSXOpeningElement;\nexports.JSXOpeningFragment = JSXOpeningFragment;\nexports.JSXSpreadAttribute = JSXSpreadAttribute;\nexports.JSXSpreadChild = JSXSpreadChild;\nexports.JSXText = JSXText;\nfunction JSXAttribute(node) {\n  this.print(node.name);\n  if (node.value) {\n    this.tokenChar(61);\n    this.print(node.value);\n  }\n}\nfunction JSXIdentifier(node) {\n  this.word(node.name);\n}\nfunction JSXNamespacedName(node) {\n  this.print(node.namespace);\n  this.tokenChar(58);\n  this.print(node.name);\n}\nfunction JSXMemberExpression(node) {\n  this.print(node.object);\n  this.tokenChar(46);\n  this.print(node.property);\n}\nfunction JSXSpreadAttribute(node) {\n  this.tokenChar(123);\n  this.token(\"...\");\n  this.print(node.argument);\n  this.rightBrace(node);\n}\nfunction JSXExpressionContainer(node) {\n  this.tokenChar(123);\n  this.print(node.expression);\n  this.rightBrace(node);\n}\nfunction JSXSpreadChild(node) {\n  this.tokenChar(123);\n  this.token(\"...\");\n  this.print(node.expression);\n  this.rightBrace(node);\n}\nfunction JSXText(node) {\n  const raw = this.getPossibleRaw(node);\n  if (raw !== undefined) {\n    this.token(raw, true);\n  } else {\n    this.token(node.value, true);\n  }\n}\nfunction JSXElement(node) {\n  const open = node.openingElement;\n  this.print(open);\n  if (open.selfClosing) return;\n  this.indent();\n  for (const child of node.children) {\n    this.print(child);\n  }\n  this.dedent();\n  this.print(node.closingElement);\n}\nfunction spaceSeparator() {\n  this.space();\n}\nfunction JSXOpeningElement(node) {\n  this.tokenChar(60);\n  this.print(node.name);\n  if (node.typeArguments) {\n    this.print(node.typeArguments);\n  }\n  this.print(node.typeParameters);\n  if (node.attributes.length > 0) {\n    this.space();\n    this.printJoin(node.attributes, undefined, undefined, spaceSeparator);\n  }\n  if (node.selfClosing) {\n    this.space();\n    this.tokenChar(47);\n  }\n  this.tokenChar(62);\n}\nfunction JSXClosingElement(node) {\n  this.tokenChar(60);\n  this.tokenChar(47);\n  this.print(node.name);\n  this.tokenChar(62);\n}\nfunction JSXEmptyExpression() {\n  this.printInnerComments();\n}\nfunction JSXFragment(node) {\n  this.print(node.openingFragment);\n  this.indent();\n  for (const child of node.children) {\n    this.print(child);\n  }\n  this.dedent();\n  this.print(node.closingFragment);\n}\nfunction JSXOpeningFragment() {\n  this.tokenChar(60);\n  this.tokenChar(62);\n}\nfunction JSXClosingFragment() {\n  this.token(\"</\");\n  this.tokenChar(62);\n}\n\n//# sourceMappingURL=jsx.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGJhYmVsL2dlbmVyYXRvci9saWIvZ2VuZXJhdG9ycy9qc3guanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWIsOENBQTZDO0FBQzdDO0FBQ0EsQ0FBQyxFQUFDO0FBQ0Ysb0JBQW9CO0FBQ3BCLHlCQUF5QjtBQUN6QiwwQkFBMEI7QUFDMUIsa0JBQWtCO0FBQ2xCLDBCQUEwQjtBQUMxQiw4QkFBOEI7QUFDOUIsbUJBQW1CO0FBQ25CLHFCQUFxQjtBQUNyQiwyQkFBMkI7QUFDM0IseUJBQXlCO0FBQ3pCLHlCQUF5QjtBQUN6QiwwQkFBMEI7QUFDMUIsMEJBQTBCO0FBQzFCLHNCQUFzQjtBQUN0QixlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9yZXBvLXZpc3VhbGl6ZXIvLi9ub2RlX21vZHVsZXMvQGJhYmVsL2dlbmVyYXRvci9saWIvZ2VuZXJhdG9ycy9qc3guanM/NTk2MyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuSlNYQXR0cmlidXRlID0gSlNYQXR0cmlidXRlO1xuZXhwb3J0cy5KU1hDbG9zaW5nRWxlbWVudCA9IEpTWENsb3NpbmdFbGVtZW50O1xuZXhwb3J0cy5KU1hDbG9zaW5nRnJhZ21lbnQgPSBKU1hDbG9zaW5nRnJhZ21lbnQ7XG5leHBvcnRzLkpTWEVsZW1lbnQgPSBKU1hFbGVtZW50O1xuZXhwb3J0cy5KU1hFbXB0eUV4cHJlc3Npb24gPSBKU1hFbXB0eUV4cHJlc3Npb247XG5leHBvcnRzLkpTWEV4cHJlc3Npb25Db250YWluZXIgPSBKU1hFeHByZXNzaW9uQ29udGFpbmVyO1xuZXhwb3J0cy5KU1hGcmFnbWVudCA9IEpTWEZyYWdtZW50O1xuZXhwb3J0cy5KU1hJZGVudGlmaWVyID0gSlNYSWRlbnRpZmllcjtcbmV4cG9ydHMuSlNYTWVtYmVyRXhwcmVzc2lvbiA9IEpTWE1lbWJlckV4cHJlc3Npb247XG5leHBvcnRzLkpTWE5hbWVzcGFjZWROYW1lID0gSlNYTmFtZXNwYWNlZE5hbWU7XG5leHBvcnRzLkpTWE9wZW5pbmdFbGVtZW50ID0gSlNYT3BlbmluZ0VsZW1lbnQ7XG5leHBvcnRzLkpTWE9wZW5pbmdGcmFnbWVudCA9IEpTWE9wZW5pbmdGcmFnbWVudDtcbmV4cG9ydHMuSlNYU3ByZWFkQXR0cmlidXRlID0gSlNYU3ByZWFkQXR0cmlidXRlO1xuZXhwb3J0cy5KU1hTcHJlYWRDaGlsZCA9IEpTWFNwcmVhZENoaWxkO1xuZXhwb3J0cy5KU1hUZXh0ID0gSlNYVGV4dDtcbmZ1bmN0aW9uIEpTWEF0dHJpYnV0ZShub2RlKSB7XG4gIHRoaXMucHJpbnQobm9kZS5uYW1lKTtcbiAgaWYgKG5vZGUudmFsdWUpIHtcbiAgICB0aGlzLnRva2VuQ2hhcig2MSk7XG4gICAgdGhpcy5wcmludChub2RlLnZhbHVlKTtcbiAgfVxufVxuZnVuY3Rpb24gSlNYSWRlbnRpZmllcihub2RlKSB7XG4gIHRoaXMud29yZChub2RlLm5hbWUpO1xufVxuZnVuY3Rpb24gSlNYTmFtZXNwYWNlZE5hbWUobm9kZSkge1xuICB0aGlzLnByaW50KG5vZGUubmFtZXNwYWNlKTtcbiAgdGhpcy50b2tlbkNoYXIoNTgpO1xuICB0aGlzLnByaW50KG5vZGUubmFtZSk7XG59XG5mdW5jdGlvbiBKU1hNZW1iZXJFeHByZXNzaW9uKG5vZGUpIHtcbiAgdGhpcy5wcmludChub2RlLm9iamVjdCk7XG4gIHRoaXMudG9rZW5DaGFyKDQ2KTtcbiAgdGhpcy5wcmludChub2RlLnByb3BlcnR5KTtcbn1cbmZ1bmN0aW9uIEpTWFNwcmVhZEF0dHJpYnV0ZShub2RlKSB7XG4gIHRoaXMudG9rZW5DaGFyKDEyMyk7XG4gIHRoaXMudG9rZW4oXCIuLi5cIik7XG4gIHRoaXMucHJpbnQobm9kZS5hcmd1bWVudCk7XG4gIHRoaXMucmlnaHRCcmFjZShub2RlKTtcbn1cbmZ1bmN0aW9uIEpTWEV4cHJlc3Npb25Db250YWluZXIobm9kZSkge1xuICB0aGlzLnRva2VuQ2hhcigxMjMpO1xuICB0aGlzLnByaW50KG5vZGUuZXhwcmVzc2lvbik7XG4gIHRoaXMucmlnaHRCcmFjZShub2RlKTtcbn1cbmZ1bmN0aW9uIEpTWFNwcmVhZENoaWxkKG5vZGUpIHtcbiAgdGhpcy50b2tlbkNoYXIoMTIzKTtcbiAgdGhpcy50b2tlbihcIi4uLlwiKTtcbiAgdGhpcy5wcmludChub2RlLmV4cHJlc3Npb24pO1xuICB0aGlzLnJpZ2h0QnJhY2Uobm9kZSk7XG59XG5mdW5jdGlvbiBKU1hUZXh0KG5vZGUpIHtcbiAgY29uc3QgcmF3ID0gdGhpcy5nZXRQb3NzaWJsZVJhdyhub2RlKTtcbiAgaWYgKHJhdyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgdGhpcy50b2tlbihyYXcsIHRydWUpO1xuICB9IGVsc2Uge1xuICAgIHRoaXMudG9rZW4obm9kZS52YWx1ZSwgdHJ1ZSk7XG4gIH1cbn1cbmZ1bmN0aW9uIEpTWEVsZW1lbnQobm9kZSkge1xuICBjb25zdCBvcGVuID0gbm9kZS5vcGVuaW5nRWxlbWVudDtcbiAgdGhpcy5wcmludChvcGVuKTtcbiAgaWYgKG9wZW4uc2VsZkNsb3NpbmcpIHJldHVybjtcbiAgdGhpcy5pbmRlbnQoKTtcbiAgZm9yIChjb25zdCBjaGlsZCBvZiBub2RlLmNoaWxkcmVuKSB7XG4gICAgdGhpcy5wcmludChjaGlsZCk7XG4gIH1cbiAgdGhpcy5kZWRlbnQoKTtcbiAgdGhpcy5wcmludChub2RlLmNsb3NpbmdFbGVtZW50KTtcbn1cbmZ1bmN0aW9uIHNwYWNlU2VwYXJhdG9yKCkge1xuICB0aGlzLnNwYWNlKCk7XG59XG5mdW5jdGlvbiBKU1hPcGVuaW5nRWxlbWVudChub2RlKSB7XG4gIHRoaXMudG9rZW5DaGFyKDYwKTtcbiAgdGhpcy5wcmludChub2RlLm5hbWUpO1xuICBpZiAobm9kZS50eXBlQXJndW1lbnRzKSB7XG4gICAgdGhpcy5wcmludChub2RlLnR5cGVBcmd1bWVudHMpO1xuICB9XG4gIHRoaXMucHJpbnQobm9kZS50eXBlUGFyYW1ldGVycyk7XG4gIGlmIChub2RlLmF0dHJpYnV0ZXMubGVuZ3RoID4gMCkge1xuICAgIHRoaXMuc3BhY2UoKTtcbiAgICB0aGlzLnByaW50Sm9pbihub2RlLmF0dHJpYnV0ZXMsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCBzcGFjZVNlcGFyYXRvcik7XG4gIH1cbiAgaWYgKG5vZGUuc2VsZkNsb3NpbmcpIHtcbiAgICB0aGlzLnNwYWNlKCk7XG4gICAgdGhpcy50b2tlbkNoYXIoNDcpO1xuICB9XG4gIHRoaXMudG9rZW5DaGFyKDYyKTtcbn1cbmZ1bmN0aW9uIEpTWENsb3NpbmdFbGVtZW50KG5vZGUpIHtcbiAgdGhpcy50b2tlbkNoYXIoNjApO1xuICB0aGlzLnRva2VuQ2hhcig0Nyk7XG4gIHRoaXMucHJpbnQobm9kZS5uYW1lKTtcbiAgdGhpcy50b2tlbkNoYXIoNjIpO1xufVxuZnVuY3Rpb24gSlNYRW1wdHlFeHByZXNzaW9uKCkge1xuICB0aGlzLnByaW50SW5uZXJDb21tZW50cygpO1xufVxuZnVuY3Rpb24gSlNYRnJhZ21lbnQobm9kZSkge1xuICB0aGlzLnByaW50KG5vZGUub3BlbmluZ0ZyYWdtZW50KTtcbiAgdGhpcy5pbmRlbnQoKTtcbiAgZm9yIChjb25zdCBjaGlsZCBvZiBub2RlLmNoaWxkcmVuKSB7XG4gICAgdGhpcy5wcmludChjaGlsZCk7XG4gIH1cbiAgdGhpcy5kZWRlbnQoKTtcbiAgdGhpcy5wcmludChub2RlLmNsb3NpbmdGcmFnbWVudCk7XG59XG5mdW5jdGlvbiBKU1hPcGVuaW5nRnJhZ21lbnQoKSB7XG4gIHRoaXMudG9rZW5DaGFyKDYwKTtcbiAgdGhpcy50b2tlbkNoYXIoNjIpO1xufVxuZnVuY3Rpb24gSlNYQ2xvc2luZ0ZyYWdtZW50KCkge1xuICB0aGlzLnRva2VuKFwiPC9cIik7XG4gIHRoaXMudG9rZW5DaGFyKDYyKTtcbn1cblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9anN4LmpzLm1hcFxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@babel/generator/lib/generators/jsx.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@babel/generator/lib/generators/methods.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@babel/generator/lib/generators/methods.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports.ArrowFunctionExpression = ArrowFunctionExpression;\nexports.FunctionDeclaration = exports.FunctionExpression = FunctionExpression;\nexports._functionHead = _functionHead;\nexports._methodHead = _methodHead;\nexports._param = _param;\nexports._parameters = _parameters;\nexports._params = _params;\nexports._predicate = _predicate;\nexports._shouldPrintArrowParamsParens = _shouldPrintArrowParamsParens;\nvar _t = __webpack_require__(/*! @babel/types */ \"(ssr)/./node_modules/@babel/types/lib/index.js\");\nvar _index = __webpack_require__(/*! ../node/index.js */ \"(ssr)/./node_modules/@babel/generator/lib/node/index.js\");\nconst {\n  isIdentifier\n} = _t;\nfunction _params(node, idNode, parentNode) {\n  this.print(node.typeParameters);\n  const nameInfo = _getFuncIdName.call(this, idNode, parentNode);\n  if (nameInfo) {\n    this.sourceIdentifierName(nameInfo.name, nameInfo.pos);\n  }\n  this.tokenChar(40);\n  this._parameters(node.params, \")\");\n  const noLineTerminator = node.type === \"ArrowFunctionExpression\";\n  this.print(node.returnType, noLineTerminator);\n  this._noLineTerminator = noLineTerminator;\n}\nfunction _parameters(parameters, endToken) {\n  const exit = this.enterDelimited();\n  const trailingComma = this.shouldPrintTrailingComma(endToken);\n  const paramLength = parameters.length;\n  for (let i = 0; i < paramLength; i++) {\n    this._param(parameters[i]);\n    if (trailingComma || i < paramLength - 1) {\n      this.token(\",\", undefined, i);\n      this.space();\n    }\n  }\n  this.token(endToken);\n  exit();\n}\nfunction _param(parameter) {\n  this.printJoin(parameter.decorators);\n  this.print(parameter);\n  if (parameter.optional) {\n    this.tokenChar(63);\n  }\n  this.print(parameter.typeAnnotation);\n}\nfunction _methodHead(node) {\n  const kind = node.kind;\n  const key = node.key;\n  if (kind === \"get\" || kind === \"set\") {\n    this.word(kind);\n    this.space();\n  }\n  if (node.async) {\n    this.word(\"async\", true);\n    this.space();\n  }\n  if (kind === \"method\" || kind === \"init\") {\n    if (node.generator) {\n      this.tokenChar(42);\n    }\n  }\n  if (node.computed) {\n    this.tokenChar(91);\n    this.print(key);\n    this.tokenChar(93);\n  } else {\n    this.print(key);\n  }\n  if (node.optional) {\n    this.tokenChar(63);\n  }\n  this._params(node, node.computed && node.key.type !== \"StringLiteral\" ? undefined : node.key);\n}\nfunction _predicate(node, noLineTerminatorAfter) {\n  if (node.predicate) {\n    if (!node.returnType) {\n      this.tokenChar(58);\n    }\n    this.space();\n    this.print(node.predicate, noLineTerminatorAfter);\n  }\n}\nfunction _functionHead(node, parent) {\n  if (node.async) {\n    this.word(\"async\");\n    if (!this.format.preserveFormat) {\n      this._endsWithInnerRaw = false;\n    }\n    this.space();\n  }\n  this.word(\"function\");\n  if (node.generator) {\n    if (!this.format.preserveFormat) {\n      this._endsWithInnerRaw = false;\n    }\n    this.tokenChar(42);\n  }\n  this.space();\n  if (node.id) {\n    this.print(node.id);\n  }\n  this._params(node, node.id, parent);\n  if (node.type !== \"TSDeclareFunction\") {\n    this._predicate(node);\n  }\n}\nfunction FunctionExpression(node, parent) {\n  this._functionHead(node, parent);\n  this.space();\n  this.print(node.body);\n}\nfunction ArrowFunctionExpression(node, parent) {\n  if (node.async) {\n    this.word(\"async\", true);\n    this.space();\n  }\n  if (this._shouldPrintArrowParamsParens(node)) {\n    this._params(node, undefined, parent);\n  } else {\n    this.print(node.params[0], true);\n  }\n  this._predicate(node, true);\n  this.space();\n  this.printInnerComments();\n  this.token(\"=>\");\n  this.space();\n  this.tokenContext |= _index.TokenContext.arrowBody;\n  this.print(node.body);\n}\nfunction _shouldPrintArrowParamsParens(node) {\n  var _firstParam$leadingCo, _firstParam$trailingC;\n  if (node.params.length !== 1) return true;\n  if (node.typeParameters || node.returnType || node.predicate) {\n    return true;\n  }\n  const firstParam = node.params[0];\n  if (!isIdentifier(firstParam) || firstParam.typeAnnotation || firstParam.optional || (_firstParam$leadingCo = firstParam.leadingComments) != null && _firstParam$leadingCo.length || (_firstParam$trailingC = firstParam.trailingComments) != null && _firstParam$trailingC.length) {\n    return true;\n  }\n  if (this.tokenMap) {\n    if (node.loc == null) return true;\n    if (this.tokenMap.findMatching(node, \"(\") !== null) return true;\n    const arrowToken = this.tokenMap.findMatching(node, \"=>\");\n    if ((arrowToken == null ? void 0 : arrowToken.loc) == null) return true;\n    return arrowToken.loc.start.line !== node.loc.start.line;\n  }\n  if (this.format.retainLines) return true;\n  return false;\n}\nfunction _getFuncIdName(idNode, parent) {\n  let id = idNode;\n  if (!id && parent) {\n    const parentType = parent.type;\n    if (parentType === \"VariableDeclarator\") {\n      id = parent.id;\n    } else if (parentType === \"AssignmentExpression\" || parentType === \"AssignmentPattern\") {\n      id = parent.left;\n    } else if (parentType === \"ObjectProperty\" || parentType === \"ClassProperty\") {\n      if (!parent.computed || parent.key.type === \"StringLiteral\") {\n        id = parent.key;\n      }\n    } else if (parentType === \"ClassPrivateProperty\" || parentType === \"ClassAccessorProperty\") {\n      id = parent.key;\n    }\n  }\n  if (!id) return;\n  let nameInfo;\n  if (id.type === \"Identifier\") {\n    var _id$loc, _id$loc2;\n    nameInfo = {\n      pos: (_id$loc = id.loc) == null ? void 0 : _id$loc.start,\n      name: ((_id$loc2 = id.loc) == null ? void 0 : _id$loc2.identifierName) || id.name\n    };\n  } else if (id.type === \"PrivateName\") {\n    var _id$loc3;\n    nameInfo = {\n      pos: (_id$loc3 = id.loc) == null ? void 0 : _id$loc3.start,\n      name: \"#\" + id.id.name\n    };\n  } else if (id.type === \"StringLiteral\") {\n    var _id$loc4;\n    nameInfo = {\n      pos: (_id$loc4 = id.loc) == null ? void 0 : _id$loc4.start,\n      name: id.value\n    };\n  }\n  return nameInfo;\n}\n\n//# sourceMappingURL=methods.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGJhYmVsL2dlbmVyYXRvci9saWIvZ2VuZXJhdG9ycy9tZXRob2RzLmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViLDhDQUE2QztBQUM3QztBQUNBLENBQUMsRUFBQztBQUNGLCtCQUErQjtBQUMvQiwyQkFBMkIsR0FBRywwQkFBMEI7QUFDeEQscUJBQXFCO0FBQ3JCLG1CQUFtQjtBQUNuQixjQUFjO0FBQ2QsbUJBQW1CO0FBQ25CLGVBQWU7QUFDZixrQkFBa0I7QUFDbEIscUNBQXFDO0FBQ3JDLFNBQVMsbUJBQU8sQ0FBQyxvRUFBYztBQUMvQixhQUFhLG1CQUFPLENBQUMsaUZBQWtCO0FBQ3ZDO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsaUJBQWlCO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9yZXBvLXZpc3VhbGl6ZXIvLi9ub2RlX21vZHVsZXMvQGJhYmVsL2dlbmVyYXRvci9saWIvZ2VuZXJhdG9ycy9tZXRob2RzLmpzP2FhMzMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLkFycm93RnVuY3Rpb25FeHByZXNzaW9uID0gQXJyb3dGdW5jdGlvbkV4cHJlc3Npb247XG5leHBvcnRzLkZ1bmN0aW9uRGVjbGFyYXRpb24gPSBleHBvcnRzLkZ1bmN0aW9uRXhwcmVzc2lvbiA9IEZ1bmN0aW9uRXhwcmVzc2lvbjtcbmV4cG9ydHMuX2Z1bmN0aW9uSGVhZCA9IF9mdW5jdGlvbkhlYWQ7XG5leHBvcnRzLl9tZXRob2RIZWFkID0gX21ldGhvZEhlYWQ7XG5leHBvcnRzLl9wYXJhbSA9IF9wYXJhbTtcbmV4cG9ydHMuX3BhcmFtZXRlcnMgPSBfcGFyYW1ldGVycztcbmV4cG9ydHMuX3BhcmFtcyA9IF9wYXJhbXM7XG5leHBvcnRzLl9wcmVkaWNhdGUgPSBfcHJlZGljYXRlO1xuZXhwb3J0cy5fc2hvdWxkUHJpbnRBcnJvd1BhcmFtc1BhcmVucyA9IF9zaG91bGRQcmludEFycm93UGFyYW1zUGFyZW5zO1xudmFyIF90ID0gcmVxdWlyZShcIkBiYWJlbC90eXBlc1wiKTtcbnZhciBfaW5kZXggPSByZXF1aXJlKFwiLi4vbm9kZS9pbmRleC5qc1wiKTtcbmNvbnN0IHtcbiAgaXNJZGVudGlmaWVyXG59ID0gX3Q7XG5mdW5jdGlvbiBfcGFyYW1zKG5vZGUsIGlkTm9kZSwgcGFyZW50Tm9kZSkge1xuICB0aGlzLnByaW50KG5vZGUudHlwZVBhcmFtZXRlcnMpO1xuICBjb25zdCBuYW1lSW5mbyA9IF9nZXRGdW5jSWROYW1lLmNhbGwodGhpcywgaWROb2RlLCBwYXJlbnROb2RlKTtcbiAgaWYgKG5hbWVJbmZvKSB7XG4gICAgdGhpcy5zb3VyY2VJZGVudGlmaWVyTmFtZShuYW1lSW5mby5uYW1lLCBuYW1lSW5mby5wb3MpO1xuICB9XG4gIHRoaXMudG9rZW5DaGFyKDQwKTtcbiAgdGhpcy5fcGFyYW1ldGVycyhub2RlLnBhcmFtcywgXCIpXCIpO1xuICBjb25zdCBub0xpbmVUZXJtaW5hdG9yID0gbm9kZS50eXBlID09PSBcIkFycm93RnVuY3Rpb25FeHByZXNzaW9uXCI7XG4gIHRoaXMucHJpbnQobm9kZS5yZXR1cm5UeXBlLCBub0xpbmVUZXJtaW5hdG9yKTtcbiAgdGhpcy5fbm9MaW5lVGVybWluYXRvciA9IG5vTGluZVRlcm1pbmF0b3I7XG59XG5mdW5jdGlvbiBfcGFyYW1ldGVycyhwYXJhbWV0ZXJzLCBlbmRUb2tlbikge1xuICBjb25zdCBleGl0ID0gdGhpcy5lbnRlckRlbGltaXRlZCgpO1xuICBjb25zdCB0cmFpbGluZ0NvbW1hID0gdGhpcy5zaG91bGRQcmludFRyYWlsaW5nQ29tbWEoZW5kVG9rZW4pO1xuICBjb25zdCBwYXJhbUxlbmd0aCA9IHBhcmFtZXRlcnMubGVuZ3RoO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IHBhcmFtTGVuZ3RoOyBpKyspIHtcbiAgICB0aGlzLl9wYXJhbShwYXJhbWV0ZXJzW2ldKTtcbiAgICBpZiAodHJhaWxpbmdDb21tYSB8fCBpIDwgcGFyYW1MZW5ndGggLSAxKSB7XG4gICAgICB0aGlzLnRva2VuKFwiLFwiLCB1bmRlZmluZWQsIGkpO1xuICAgICAgdGhpcy5zcGFjZSgpO1xuICAgIH1cbiAgfVxuICB0aGlzLnRva2VuKGVuZFRva2VuKTtcbiAgZXhpdCgpO1xufVxuZnVuY3Rpb24gX3BhcmFtKHBhcmFtZXRlcikge1xuICB0aGlzLnByaW50Sm9pbihwYXJhbWV0ZXIuZGVjb3JhdG9ycyk7XG4gIHRoaXMucHJpbnQocGFyYW1ldGVyKTtcbiAgaWYgKHBhcmFtZXRlci5vcHRpb25hbCkge1xuICAgIHRoaXMudG9rZW5DaGFyKDYzKTtcbiAgfVxuICB0aGlzLnByaW50KHBhcmFtZXRlci50eXBlQW5ub3RhdGlvbik7XG59XG5mdW5jdGlvbiBfbWV0aG9kSGVhZChub2RlKSB7XG4gIGNvbnN0IGtpbmQgPSBub2RlLmtpbmQ7XG4gIGNvbnN0IGtleSA9IG5vZGUua2V5O1xuICBpZiAoa2luZCA9PT0gXCJnZXRcIiB8fCBraW5kID09PSBcInNldFwiKSB7XG4gICAgdGhpcy53b3JkKGtpbmQpO1xuICAgIHRoaXMuc3BhY2UoKTtcbiAgfVxuICBpZiAobm9kZS5hc3luYykge1xuICAgIHRoaXMud29yZChcImFzeW5jXCIsIHRydWUpO1xuICAgIHRoaXMuc3BhY2UoKTtcbiAgfVxuICBpZiAoa2luZCA9PT0gXCJtZXRob2RcIiB8fCBraW5kID09PSBcImluaXRcIikge1xuICAgIGlmIChub2RlLmdlbmVyYXRvcikge1xuICAgICAgdGhpcy50b2tlbkNoYXIoNDIpO1xuICAgIH1cbiAgfVxuICBpZiAobm9kZS5jb21wdXRlZCkge1xuICAgIHRoaXMudG9rZW5DaGFyKDkxKTtcbiAgICB0aGlzLnByaW50KGtleSk7XG4gICAgdGhpcy50b2tlbkNoYXIoOTMpO1xuICB9IGVsc2Uge1xuICAgIHRoaXMucHJpbnQoa2V5KTtcbiAgfVxuICBpZiAobm9kZS5vcHRpb25hbCkge1xuICAgIHRoaXMudG9rZW5DaGFyKDYzKTtcbiAgfVxuICB0aGlzLl9wYXJhbXMobm9kZSwgbm9kZS5jb21wdXRlZCAmJiBub2RlLmtleS50eXBlICE9PSBcIlN0cmluZ0xpdGVyYWxcIiA/IHVuZGVmaW5lZCA6IG5vZGUua2V5KTtcbn1cbmZ1bmN0aW9uIF9wcmVkaWNhdGUobm9kZSwgbm9MaW5lVGVybWluYXRvckFmdGVyKSB7XG4gIGlmIChub2RlLnByZWRpY2F0ZSkge1xuICAgIGlmICghbm9kZS5yZXR1cm5UeXBlKSB7XG4gICAgICB0aGlzLnRva2VuQ2hhcig1OCk7XG4gICAgfVxuICAgIHRoaXMuc3BhY2UoKTtcbiAgICB0aGlzLnByaW50KG5vZGUucHJlZGljYXRlLCBub0xpbmVUZXJtaW5hdG9yQWZ0ZXIpO1xuICB9XG59XG5mdW5jdGlvbiBfZnVuY3Rpb25IZWFkKG5vZGUsIHBhcmVudCkge1xuICBpZiAobm9kZS5hc3luYykge1xuICAgIHRoaXMud29yZChcImFzeW5jXCIpO1xuICAgIGlmICghdGhpcy5mb3JtYXQucHJlc2VydmVGb3JtYXQpIHtcbiAgICAgIHRoaXMuX2VuZHNXaXRoSW5uZXJSYXcgPSBmYWxzZTtcbiAgICB9XG4gICAgdGhpcy5zcGFjZSgpO1xuICB9XG4gIHRoaXMud29yZChcImZ1bmN0aW9uXCIpO1xuICBpZiAobm9kZS5nZW5lcmF0b3IpIHtcbiAgICBpZiAoIXRoaXMuZm9ybWF0LnByZXNlcnZlRm9ybWF0KSB7XG4gICAgICB0aGlzLl9lbmRzV2l0aElubmVyUmF3ID0gZmFsc2U7XG4gICAgfVxuICAgIHRoaXMudG9rZW5DaGFyKDQyKTtcbiAgfVxuICB0aGlzLnNwYWNlKCk7XG4gIGlmIChub2RlLmlkKSB7XG4gICAgdGhpcy5wcmludChub2RlLmlkKTtcbiAgfVxuICB0aGlzLl9wYXJhbXMobm9kZSwgbm9kZS5pZCwgcGFyZW50KTtcbiAgaWYgKG5vZGUudHlwZSAhPT0gXCJUU0RlY2xhcmVGdW5jdGlvblwiKSB7XG4gICAgdGhpcy5fcHJlZGljYXRlKG5vZGUpO1xuICB9XG59XG5mdW5jdGlvbiBGdW5jdGlvbkV4cHJlc3Npb24obm9kZSwgcGFyZW50KSB7XG4gIHRoaXMuX2Z1bmN0aW9uSGVhZChub2RlLCBwYXJlbnQpO1xuICB0aGlzLnNwYWNlKCk7XG4gIHRoaXMucHJpbnQobm9kZS5ib2R5KTtcbn1cbmZ1bmN0aW9uIEFycm93RnVuY3Rpb25FeHByZXNzaW9uKG5vZGUsIHBhcmVudCkge1xuICBpZiAobm9kZS5hc3luYykge1xuICAgIHRoaXMud29yZChcImFzeW5jXCIsIHRydWUpO1xuICAgIHRoaXMuc3BhY2UoKTtcbiAgfVxuICBpZiAodGhpcy5fc2hvdWxkUHJpbnRBcnJvd1BhcmFtc1BhcmVucyhub2RlKSkge1xuICAgIHRoaXMuX3BhcmFtcyhub2RlLCB1bmRlZmluZWQsIHBhcmVudCk7XG4gIH0gZWxzZSB7XG4gICAgdGhpcy5wcmludChub2RlLnBhcmFtc1swXSwgdHJ1ZSk7XG4gIH1cbiAgdGhpcy5fcHJlZGljYXRlKG5vZGUsIHRydWUpO1xuICB0aGlzLnNwYWNlKCk7XG4gIHRoaXMucHJpbnRJbm5lckNvbW1lbnRzKCk7XG4gIHRoaXMudG9rZW4oXCI9PlwiKTtcbiAgdGhpcy5zcGFjZSgpO1xuICB0aGlzLnRva2VuQ29udGV4dCB8PSBfaW5kZXguVG9rZW5Db250ZXh0LmFycm93Qm9keTtcbiAgdGhpcy5wcmludChub2RlLmJvZHkpO1xufVxuZnVuY3Rpb24gX3Nob3VsZFByaW50QXJyb3dQYXJhbXNQYXJlbnMobm9kZSkge1xuICB2YXIgX2ZpcnN0UGFyYW0kbGVhZGluZ0NvLCBfZmlyc3RQYXJhbSR0cmFpbGluZ0M7XG4gIGlmIChub2RlLnBhcmFtcy5sZW5ndGggIT09IDEpIHJldHVybiB0cnVlO1xuICBpZiAobm9kZS50eXBlUGFyYW1ldGVycyB8fCBub2RlLnJldHVyblR5cGUgfHwgbm9kZS5wcmVkaWNhdGUpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICBjb25zdCBmaXJzdFBhcmFtID0gbm9kZS5wYXJhbXNbMF07XG4gIGlmICghaXNJZGVudGlmaWVyKGZpcnN0UGFyYW0pIHx8IGZpcnN0UGFyYW0udHlwZUFubm90YXRpb24gfHwgZmlyc3RQYXJhbS5vcHRpb25hbCB8fCAoX2ZpcnN0UGFyYW0kbGVhZGluZ0NvID0gZmlyc3RQYXJhbS5sZWFkaW5nQ29tbWVudHMpICE9IG51bGwgJiYgX2ZpcnN0UGFyYW0kbGVhZGluZ0NvLmxlbmd0aCB8fCAoX2ZpcnN0UGFyYW0kdHJhaWxpbmdDID0gZmlyc3RQYXJhbS50cmFpbGluZ0NvbW1lbnRzKSAhPSBudWxsICYmIF9maXJzdFBhcmFtJHRyYWlsaW5nQy5sZW5ndGgpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICBpZiAodGhpcy50b2tlbk1hcCkge1xuICAgIGlmIChub2RlLmxvYyA9PSBudWxsKSByZXR1cm4gdHJ1ZTtcbiAgICBpZiAodGhpcy50b2tlbk1hcC5maW5kTWF0Y2hpbmcobm9kZSwgXCIoXCIpICE9PSBudWxsKSByZXR1cm4gdHJ1ZTtcbiAgICBjb25zdCBhcnJvd1Rva2VuID0gdGhpcy50b2tlbk1hcC5maW5kTWF0Y2hpbmcobm9kZSwgXCI9PlwiKTtcbiAgICBpZiAoKGFycm93VG9rZW4gPT0gbnVsbCA/IHZvaWQgMCA6IGFycm93VG9rZW4ubG9jKSA9PSBudWxsKSByZXR1cm4gdHJ1ZTtcbiAgICByZXR1cm4gYXJyb3dUb2tlbi5sb2Muc3RhcnQubGluZSAhPT0gbm9kZS5sb2Muc3RhcnQubGluZTtcbiAgfVxuICBpZiAodGhpcy5mb3JtYXQucmV0YWluTGluZXMpIHJldHVybiB0cnVlO1xuICByZXR1cm4gZmFsc2U7XG59XG5mdW5jdGlvbiBfZ2V0RnVuY0lkTmFtZShpZE5vZGUsIHBhcmVudCkge1xuICBsZXQgaWQgPSBpZE5vZGU7XG4gIGlmICghaWQgJiYgcGFyZW50KSB7XG4gICAgY29uc3QgcGFyZW50VHlwZSA9IHBhcmVudC50eXBlO1xuICAgIGlmIChwYXJlbnRUeXBlID09PSBcIlZhcmlhYmxlRGVjbGFyYXRvclwiKSB7XG4gICAgICBpZCA9IHBhcmVudC5pZDtcbiAgICB9IGVsc2UgaWYgKHBhcmVudFR5cGUgPT09IFwiQXNzaWdubWVudEV4cHJlc3Npb25cIiB8fCBwYXJlbnRUeXBlID09PSBcIkFzc2lnbm1lbnRQYXR0ZXJuXCIpIHtcbiAgICAgIGlkID0gcGFyZW50LmxlZnQ7XG4gICAgfSBlbHNlIGlmIChwYXJlbnRUeXBlID09PSBcIk9iamVjdFByb3BlcnR5XCIgfHwgcGFyZW50VHlwZSA9PT0gXCJDbGFzc1Byb3BlcnR5XCIpIHtcbiAgICAgIGlmICghcGFyZW50LmNvbXB1dGVkIHx8IHBhcmVudC5rZXkudHlwZSA9PT0gXCJTdHJpbmdMaXRlcmFsXCIpIHtcbiAgICAgICAgaWQgPSBwYXJlbnQua2V5O1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAocGFyZW50VHlwZSA9PT0gXCJDbGFzc1ByaXZhdGVQcm9wZXJ0eVwiIHx8IHBhcmVudFR5cGUgPT09IFwiQ2xhc3NBY2Nlc3NvclByb3BlcnR5XCIpIHtcbiAgICAgIGlkID0gcGFyZW50LmtleTtcbiAgICB9XG4gIH1cbiAgaWYgKCFpZCkgcmV0dXJuO1xuICBsZXQgbmFtZUluZm87XG4gIGlmIChpZC50eXBlID09PSBcIklkZW50aWZpZXJcIikge1xuICAgIHZhciBfaWQkbG9jLCBfaWQkbG9jMjtcbiAgICBuYW1lSW5mbyA9IHtcbiAgICAgIHBvczogKF9pZCRsb2MgPSBpZC5sb2MpID09IG51bGwgPyB2b2lkIDAgOiBfaWQkbG9jLnN0YXJ0LFxuICAgICAgbmFtZTogKChfaWQkbG9jMiA9IGlkLmxvYykgPT0gbnVsbCA/IHZvaWQgMCA6IF9pZCRsb2MyLmlkZW50aWZpZXJOYW1lKSB8fCBpZC5uYW1lXG4gICAgfTtcbiAgfSBlbHNlIGlmIChpZC50eXBlID09PSBcIlByaXZhdGVOYW1lXCIpIHtcbiAgICB2YXIgX2lkJGxvYzM7XG4gICAgbmFtZUluZm8gPSB7XG4gICAgICBwb3M6IChfaWQkbG9jMyA9IGlkLmxvYykgPT0gbnVsbCA/IHZvaWQgMCA6IF9pZCRsb2MzLnN0YXJ0LFxuICAgICAgbmFtZTogXCIjXCIgKyBpZC5pZC5uYW1lXG4gICAgfTtcbiAgfSBlbHNlIGlmIChpZC50eXBlID09PSBcIlN0cmluZ0xpdGVyYWxcIikge1xuICAgIHZhciBfaWQkbG9jNDtcbiAgICBuYW1lSW5mbyA9IHtcbiAgICAgIHBvczogKF9pZCRsb2M0ID0gaWQubG9jKSA9PSBudWxsID8gdm9pZCAwIDogX2lkJGxvYzQuc3RhcnQsXG4gICAgICBuYW1lOiBpZC52YWx1ZVxuICAgIH07XG4gIH1cbiAgcmV0dXJuIG5hbWVJbmZvO1xufVxuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1tZXRob2RzLmpzLm1hcFxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@babel/generator/lib/generators/methods.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@babel/generator/lib/generators/modules.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@babel/generator/lib/generators/modules.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports.ExportAllDeclaration = ExportAllDeclaration;\nexports.ExportDefaultDeclaration = ExportDefaultDeclaration;\nexports.ExportDefaultSpecifier = ExportDefaultSpecifier;\nexports.ExportNamedDeclaration = ExportNamedDeclaration;\nexports.ExportNamespaceSpecifier = ExportNamespaceSpecifier;\nexports.ExportSpecifier = ExportSpecifier;\nexports.ImportAttribute = ImportAttribute;\nexports.ImportDeclaration = ImportDeclaration;\nexports.ImportDefaultSpecifier = ImportDefaultSpecifier;\nexports.ImportExpression = ImportExpression;\nexports.ImportNamespaceSpecifier = ImportNamespaceSpecifier;\nexports.ImportSpecifier = ImportSpecifier;\nexports._printAttributes = _printAttributes;\nvar _t = __webpack_require__(/*! @babel/types */ \"(ssr)/./node_modules/@babel/types/lib/index.js\");\nvar _index = __webpack_require__(/*! ../node/index.js */ \"(ssr)/./node_modules/@babel/generator/lib/node/index.js\");\nconst {\n  isClassDeclaration,\n  isExportDefaultSpecifier,\n  isExportNamespaceSpecifier,\n  isImportDefaultSpecifier,\n  isImportNamespaceSpecifier,\n  isStatement\n} = _t;\nfunction ImportSpecifier(node) {\n  if (node.importKind === \"type\" || node.importKind === \"typeof\") {\n    this.word(node.importKind);\n    this.space();\n  }\n  this.print(node.imported);\n  if (node.local && node.local.name !== node.imported.name) {\n    this.space();\n    this.word(\"as\");\n    this.space();\n    this.print(node.local);\n  }\n}\nfunction ImportDefaultSpecifier(node) {\n  this.print(node.local);\n}\nfunction ExportDefaultSpecifier(node) {\n  this.print(node.exported);\n}\nfunction ExportSpecifier(node) {\n  if (node.exportKind === \"type\") {\n    this.word(\"type\");\n    this.space();\n  }\n  this.print(node.local);\n  if (node.exported && node.local.name !== node.exported.name) {\n    this.space();\n    this.word(\"as\");\n    this.space();\n    this.print(node.exported);\n  }\n}\nfunction ExportNamespaceSpecifier(node) {\n  this.tokenChar(42);\n  this.space();\n  this.word(\"as\");\n  this.space();\n  this.print(node.exported);\n}\nlet warningShown = false;\nfunction _printAttributes(node, hasPreviousBrace) {\n  var _node$extra;\n  const {\n    attributes\n  } = node;\n  var {\n    assertions\n  } = node;\n  const {\n    importAttributesKeyword\n  } = this.format;\n  if (attributes && !importAttributesKeyword && node.extra && (node.extra.deprecatedAssertSyntax || node.extra.deprecatedWithLegacySyntax) && !warningShown) {\n    warningShown = true;\n    console.warn(`\\\nYou are using import attributes, without specifying the desired output syntax.\nPlease specify the \"importAttributesKeyword\" generator option, whose value can be one of:\n - \"with\"        : \\`import { a } from \"b\" with { type: \"json\" };\\`\n - \"assert\"      : \\`import { a } from \"b\" assert { type: \"json\" };\\`\n - \"with-legacy\" : \\`import { a } from \"b\" with type: \"json\";\\`\n`);\n  }\n  const useAssertKeyword = importAttributesKeyword === \"assert\" || !importAttributesKeyword && assertions;\n  this.word(useAssertKeyword ? \"assert\" : \"with\");\n  this.space();\n  if (!useAssertKeyword && (importAttributesKeyword === \"with-legacy\" || !importAttributesKeyword && (_node$extra = node.extra) != null && _node$extra.deprecatedWithLegacySyntax)) {\n    this.printList(attributes || assertions);\n    return;\n  }\n  const occurrenceCount = hasPreviousBrace ? 1 : 0;\n  this.token(\"{\", undefined, occurrenceCount);\n  this.space();\n  this.printList(attributes || assertions, this.shouldPrintTrailingComma(\"}\"));\n  this.space();\n  this.token(\"}\", undefined, occurrenceCount);\n}\nfunction ExportAllDeclaration(node) {\n  var _node$attributes, _node$assertions;\n  this.word(\"export\");\n  this.space();\n  if (node.exportKind === \"type\") {\n    this.word(\"type\");\n    this.space();\n  }\n  this.tokenChar(42);\n  this.space();\n  this.word(\"from\");\n  this.space();\n  if ((_node$attributes = node.attributes) != null && _node$attributes.length || (_node$assertions = node.assertions) != null && _node$assertions.length) {\n    this.print(node.source, true);\n    this.space();\n    this._printAttributes(node, false);\n  } else {\n    this.print(node.source);\n  }\n  this.semicolon();\n}\nfunction maybePrintDecoratorsBeforeExport(printer, node) {\n  if (isClassDeclaration(node.declaration) && printer._shouldPrintDecoratorsBeforeExport(node)) {\n    printer.printJoin(node.declaration.decorators);\n  }\n}\nfunction ExportNamedDeclaration(node) {\n  maybePrintDecoratorsBeforeExport(this, node);\n  this.word(\"export\");\n  this.space();\n  if (node.declaration) {\n    const declar = node.declaration;\n    this.print(declar);\n    if (!isStatement(declar)) this.semicolon();\n  } else {\n    if (node.exportKind === \"type\") {\n      this.word(\"type\");\n      this.space();\n    }\n    const specifiers = node.specifiers.slice(0);\n    let hasSpecial = false;\n    for (;;) {\n      const first = specifiers[0];\n      if (isExportDefaultSpecifier(first) || isExportNamespaceSpecifier(first)) {\n        hasSpecial = true;\n        this.print(specifiers.shift());\n        if (specifiers.length) {\n          this.tokenChar(44);\n          this.space();\n        }\n      } else {\n        break;\n      }\n    }\n    let hasBrace = false;\n    if (specifiers.length || !specifiers.length && !hasSpecial) {\n      hasBrace = true;\n      this.tokenChar(123);\n      if (specifiers.length) {\n        this.space();\n        this.printList(specifiers, this.shouldPrintTrailingComma(\"}\"));\n        this.space();\n      }\n      this.tokenChar(125);\n    }\n    if (node.source) {\n      var _node$attributes2, _node$assertions2;\n      this.space();\n      this.word(\"from\");\n      this.space();\n      if ((_node$attributes2 = node.attributes) != null && _node$attributes2.length || (_node$assertions2 = node.assertions) != null && _node$assertions2.length) {\n        this.print(node.source, true);\n        this.space();\n        this._printAttributes(node, hasBrace);\n      } else {\n        this.print(node.source);\n      }\n    }\n    this.semicolon();\n  }\n}\nfunction ExportDefaultDeclaration(node) {\n  maybePrintDecoratorsBeforeExport(this, node);\n  this.word(\"export\");\n  this.noIndentInnerCommentsHere();\n  this.space();\n  this.word(\"default\");\n  this.space();\n  this.tokenContext |= _index.TokenContext.exportDefault;\n  const declar = node.declaration;\n  this.print(declar);\n  if (!isStatement(declar)) this.semicolon();\n}\nfunction ImportDeclaration(node) {\n  var _node$attributes3, _node$assertions3;\n  this.word(\"import\");\n  this.space();\n  const isTypeKind = node.importKind === \"type\" || node.importKind === \"typeof\";\n  if (isTypeKind) {\n    this.noIndentInnerCommentsHere();\n    this.word(node.importKind);\n    this.space();\n  } else if (node.module) {\n    this.noIndentInnerCommentsHere();\n    this.word(\"module\");\n    this.space();\n  } else if (node.phase) {\n    this.noIndentInnerCommentsHere();\n    this.word(node.phase);\n    this.space();\n  }\n  const specifiers = node.specifiers.slice(0);\n  const hasSpecifiers = !!specifiers.length;\n  while (hasSpecifiers) {\n    const first = specifiers[0];\n    if (isImportDefaultSpecifier(first) || isImportNamespaceSpecifier(first)) {\n      this.print(specifiers.shift());\n      if (specifiers.length) {\n        this.tokenChar(44);\n        this.space();\n      }\n    } else {\n      break;\n    }\n  }\n  let hasBrace = false;\n  if (specifiers.length) {\n    hasBrace = true;\n    this.tokenChar(123);\n    this.space();\n    this.printList(specifiers, this.shouldPrintTrailingComma(\"}\"));\n    this.space();\n    this.tokenChar(125);\n  } else if (isTypeKind && !hasSpecifiers) {\n    hasBrace = true;\n    this.tokenChar(123);\n    this.tokenChar(125);\n  }\n  if (hasSpecifiers || isTypeKind) {\n    this.space();\n    this.word(\"from\");\n    this.space();\n  }\n  if ((_node$attributes3 = node.attributes) != null && _node$attributes3.length || (_node$assertions3 = node.assertions) != null && _node$assertions3.length) {\n    this.print(node.source, true);\n    this.space();\n    this._printAttributes(node, hasBrace);\n  } else {\n    this.print(node.source);\n  }\n  this.semicolon();\n}\nfunction ImportAttribute(node) {\n  this.print(node.key);\n  this.tokenChar(58);\n  this.space();\n  this.print(node.value);\n}\nfunction ImportNamespaceSpecifier(node) {\n  this.tokenChar(42);\n  this.space();\n  this.word(\"as\");\n  this.space();\n  this.print(node.local);\n}\nfunction ImportExpression(node) {\n  this.word(\"import\");\n  if (node.phase) {\n    this.tokenChar(46);\n    this.word(node.phase);\n  }\n  this.tokenChar(40);\n  const shouldPrintTrailingComma = this.shouldPrintTrailingComma(\")\");\n  this.print(node.source);\n  if (node.options != null) {\n    this.tokenChar(44);\n    this.space();\n    this.print(node.options);\n  }\n  if (shouldPrintTrailingComma) {\n    this.tokenChar(44);\n  }\n  this.rightParens(node);\n}\n\n//# sourceMappingURL=modules.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGJhYmVsL2dlbmVyYXRvci9saWIvZ2VuZXJhdG9ycy9tb2R1bGVzLmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViLDhDQUE2QztBQUM3QztBQUNBLENBQUMsRUFBQztBQUNGLDRCQUE0QjtBQUM1QixnQ0FBZ0M7QUFDaEMsOEJBQThCO0FBQzlCLDhCQUE4QjtBQUM5QixnQ0FBZ0M7QUFDaEMsdUJBQXVCO0FBQ3ZCLHVCQUF1QjtBQUN2Qix5QkFBeUI7QUFDekIsOEJBQThCO0FBQzlCLHdCQUF3QjtBQUN4QixnQ0FBZ0M7QUFDaEMsdUJBQXVCO0FBQ3ZCLHdCQUF3QjtBQUN4QixTQUFTLG1CQUFPLENBQUMsb0VBQWM7QUFDL0IsYUFBYSxtQkFBTyxDQUFDLGlGQUFrQjtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLElBQUksZ0JBQWdCLGVBQWU7QUFDakUsOEJBQThCLElBQUksa0JBQWtCLGVBQWU7QUFDbkUsOEJBQThCLElBQUksMkJBQTJCO0FBQzdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0EsMkVBQTJFO0FBQzNFO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtRUFBbUU7QUFDbkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrREFBK0Q7QUFDL0Q7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9yZXBvLXZpc3VhbGl6ZXIvLi9ub2RlX21vZHVsZXMvQGJhYmVsL2dlbmVyYXRvci9saWIvZ2VuZXJhdG9ycy9tb2R1bGVzLmpzPzY1NmEiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLkV4cG9ydEFsbERlY2xhcmF0aW9uID0gRXhwb3J0QWxsRGVjbGFyYXRpb247XG5leHBvcnRzLkV4cG9ydERlZmF1bHREZWNsYXJhdGlvbiA9IEV4cG9ydERlZmF1bHREZWNsYXJhdGlvbjtcbmV4cG9ydHMuRXhwb3J0RGVmYXVsdFNwZWNpZmllciA9IEV4cG9ydERlZmF1bHRTcGVjaWZpZXI7XG5leHBvcnRzLkV4cG9ydE5hbWVkRGVjbGFyYXRpb24gPSBFeHBvcnROYW1lZERlY2xhcmF0aW9uO1xuZXhwb3J0cy5FeHBvcnROYW1lc3BhY2VTcGVjaWZpZXIgPSBFeHBvcnROYW1lc3BhY2VTcGVjaWZpZXI7XG5leHBvcnRzLkV4cG9ydFNwZWNpZmllciA9IEV4cG9ydFNwZWNpZmllcjtcbmV4cG9ydHMuSW1wb3J0QXR0cmlidXRlID0gSW1wb3J0QXR0cmlidXRlO1xuZXhwb3J0cy5JbXBvcnREZWNsYXJhdGlvbiA9IEltcG9ydERlY2xhcmF0aW9uO1xuZXhwb3J0cy5JbXBvcnREZWZhdWx0U3BlY2lmaWVyID0gSW1wb3J0RGVmYXVsdFNwZWNpZmllcjtcbmV4cG9ydHMuSW1wb3J0RXhwcmVzc2lvbiA9IEltcG9ydEV4cHJlc3Npb247XG5leHBvcnRzLkltcG9ydE5hbWVzcGFjZVNwZWNpZmllciA9IEltcG9ydE5hbWVzcGFjZVNwZWNpZmllcjtcbmV4cG9ydHMuSW1wb3J0U3BlY2lmaWVyID0gSW1wb3J0U3BlY2lmaWVyO1xuZXhwb3J0cy5fcHJpbnRBdHRyaWJ1dGVzID0gX3ByaW50QXR0cmlidXRlcztcbnZhciBfdCA9IHJlcXVpcmUoXCJAYmFiZWwvdHlwZXNcIik7XG52YXIgX2luZGV4ID0gcmVxdWlyZShcIi4uL25vZGUvaW5kZXguanNcIik7XG5jb25zdCB7XG4gIGlzQ2xhc3NEZWNsYXJhdGlvbixcbiAgaXNFeHBvcnREZWZhdWx0U3BlY2lmaWVyLFxuICBpc0V4cG9ydE5hbWVzcGFjZVNwZWNpZmllcixcbiAgaXNJbXBvcnREZWZhdWx0U3BlY2lmaWVyLFxuICBpc0ltcG9ydE5hbWVzcGFjZVNwZWNpZmllcixcbiAgaXNTdGF0ZW1lbnRcbn0gPSBfdDtcbmZ1bmN0aW9uIEltcG9ydFNwZWNpZmllcihub2RlKSB7XG4gIGlmIChub2RlLmltcG9ydEtpbmQgPT09IFwidHlwZVwiIHx8IG5vZGUuaW1wb3J0S2luZCA9PT0gXCJ0eXBlb2ZcIikge1xuICAgIHRoaXMud29yZChub2RlLmltcG9ydEtpbmQpO1xuICAgIHRoaXMuc3BhY2UoKTtcbiAgfVxuICB0aGlzLnByaW50KG5vZGUuaW1wb3J0ZWQpO1xuICBpZiAobm9kZS5sb2NhbCAmJiBub2RlLmxvY2FsLm5hbWUgIT09IG5vZGUuaW1wb3J0ZWQubmFtZSkge1xuICAgIHRoaXMuc3BhY2UoKTtcbiAgICB0aGlzLndvcmQoXCJhc1wiKTtcbiAgICB0aGlzLnNwYWNlKCk7XG4gICAgdGhpcy5wcmludChub2RlLmxvY2FsKTtcbiAgfVxufVxuZnVuY3Rpb24gSW1wb3J0RGVmYXVsdFNwZWNpZmllcihub2RlKSB7XG4gIHRoaXMucHJpbnQobm9kZS5sb2NhbCk7XG59XG5mdW5jdGlvbiBFeHBvcnREZWZhdWx0U3BlY2lmaWVyKG5vZGUpIHtcbiAgdGhpcy5wcmludChub2RlLmV4cG9ydGVkKTtcbn1cbmZ1bmN0aW9uIEV4cG9ydFNwZWNpZmllcihub2RlKSB7XG4gIGlmIChub2RlLmV4cG9ydEtpbmQgPT09IFwidHlwZVwiKSB7XG4gICAgdGhpcy53b3JkKFwidHlwZVwiKTtcbiAgICB0aGlzLnNwYWNlKCk7XG4gIH1cbiAgdGhpcy5wcmludChub2RlLmxvY2FsKTtcbiAgaWYgKG5vZGUuZXhwb3J0ZWQgJiYgbm9kZS5sb2NhbC5uYW1lICE9PSBub2RlLmV4cG9ydGVkLm5hbWUpIHtcbiAgICB0aGlzLnNwYWNlKCk7XG4gICAgdGhpcy53b3JkKFwiYXNcIik7XG4gICAgdGhpcy5zcGFjZSgpO1xuICAgIHRoaXMucHJpbnQobm9kZS5leHBvcnRlZCk7XG4gIH1cbn1cbmZ1bmN0aW9uIEV4cG9ydE5hbWVzcGFjZVNwZWNpZmllcihub2RlKSB7XG4gIHRoaXMudG9rZW5DaGFyKDQyKTtcbiAgdGhpcy5zcGFjZSgpO1xuICB0aGlzLndvcmQoXCJhc1wiKTtcbiAgdGhpcy5zcGFjZSgpO1xuICB0aGlzLnByaW50KG5vZGUuZXhwb3J0ZWQpO1xufVxubGV0IHdhcm5pbmdTaG93biA9IGZhbHNlO1xuZnVuY3Rpb24gX3ByaW50QXR0cmlidXRlcyhub2RlLCBoYXNQcmV2aW91c0JyYWNlKSB7XG4gIHZhciBfbm9kZSRleHRyYTtcbiAgY29uc3Qge1xuICAgIGF0dHJpYnV0ZXNcbiAgfSA9IG5vZGU7XG4gIHZhciB7XG4gICAgYXNzZXJ0aW9uc1xuICB9ID0gbm9kZTtcbiAgY29uc3Qge1xuICAgIGltcG9ydEF0dHJpYnV0ZXNLZXl3b3JkXG4gIH0gPSB0aGlzLmZvcm1hdDtcbiAgaWYgKGF0dHJpYnV0ZXMgJiYgIWltcG9ydEF0dHJpYnV0ZXNLZXl3b3JkICYmIG5vZGUuZXh0cmEgJiYgKG5vZGUuZXh0cmEuZGVwcmVjYXRlZEFzc2VydFN5bnRheCB8fCBub2RlLmV4dHJhLmRlcHJlY2F0ZWRXaXRoTGVnYWN5U3ludGF4KSAmJiAhd2FybmluZ1Nob3duKSB7XG4gICAgd2FybmluZ1Nob3duID0gdHJ1ZTtcbiAgICBjb25zb2xlLndhcm4oYFxcXG5Zb3UgYXJlIHVzaW5nIGltcG9ydCBhdHRyaWJ1dGVzLCB3aXRob3V0IHNwZWNpZnlpbmcgdGhlIGRlc2lyZWQgb3V0cHV0IHN5bnRheC5cblBsZWFzZSBzcGVjaWZ5IHRoZSBcImltcG9ydEF0dHJpYnV0ZXNLZXl3b3JkXCIgZ2VuZXJhdG9yIG9wdGlvbiwgd2hvc2UgdmFsdWUgY2FuIGJlIG9uZSBvZjpcbiAtIFwid2l0aFwiICAgICAgICA6IFxcYGltcG9ydCB7IGEgfSBmcm9tIFwiYlwiIHdpdGggeyB0eXBlOiBcImpzb25cIiB9O1xcYFxuIC0gXCJhc3NlcnRcIiAgICAgIDogXFxgaW1wb3J0IHsgYSB9IGZyb20gXCJiXCIgYXNzZXJ0IHsgdHlwZTogXCJqc29uXCIgfTtcXGBcbiAtIFwid2l0aC1sZWdhY3lcIiA6IFxcYGltcG9ydCB7IGEgfSBmcm9tIFwiYlwiIHdpdGggdHlwZTogXCJqc29uXCI7XFxgXG5gKTtcbiAgfVxuICBjb25zdCB1c2VBc3NlcnRLZXl3b3JkID0gaW1wb3J0QXR0cmlidXRlc0tleXdvcmQgPT09IFwiYXNzZXJ0XCIgfHwgIWltcG9ydEF0dHJpYnV0ZXNLZXl3b3JkICYmIGFzc2VydGlvbnM7XG4gIHRoaXMud29yZCh1c2VBc3NlcnRLZXl3b3JkID8gXCJhc3NlcnRcIiA6IFwid2l0aFwiKTtcbiAgdGhpcy5zcGFjZSgpO1xuICBpZiAoIXVzZUFzc2VydEtleXdvcmQgJiYgKGltcG9ydEF0dHJpYnV0ZXNLZXl3b3JkID09PSBcIndpdGgtbGVnYWN5XCIgfHwgIWltcG9ydEF0dHJpYnV0ZXNLZXl3b3JkICYmIChfbm9kZSRleHRyYSA9IG5vZGUuZXh0cmEpICE9IG51bGwgJiYgX25vZGUkZXh0cmEuZGVwcmVjYXRlZFdpdGhMZWdhY3lTeW50YXgpKSB7XG4gICAgdGhpcy5wcmludExpc3QoYXR0cmlidXRlcyB8fCBhc3NlcnRpb25zKTtcbiAgICByZXR1cm47XG4gIH1cbiAgY29uc3Qgb2NjdXJyZW5jZUNvdW50ID0gaGFzUHJldmlvdXNCcmFjZSA/IDEgOiAwO1xuICB0aGlzLnRva2VuKFwie1wiLCB1bmRlZmluZWQsIG9jY3VycmVuY2VDb3VudCk7XG4gIHRoaXMuc3BhY2UoKTtcbiAgdGhpcy5wcmludExpc3QoYXR0cmlidXRlcyB8fCBhc3NlcnRpb25zLCB0aGlzLnNob3VsZFByaW50VHJhaWxpbmdDb21tYShcIn1cIikpO1xuICB0aGlzLnNwYWNlKCk7XG4gIHRoaXMudG9rZW4oXCJ9XCIsIHVuZGVmaW5lZCwgb2NjdXJyZW5jZUNvdW50KTtcbn1cbmZ1bmN0aW9uIEV4cG9ydEFsbERlY2xhcmF0aW9uKG5vZGUpIHtcbiAgdmFyIF9ub2RlJGF0dHJpYnV0ZXMsIF9ub2RlJGFzc2VydGlvbnM7XG4gIHRoaXMud29yZChcImV4cG9ydFwiKTtcbiAgdGhpcy5zcGFjZSgpO1xuICBpZiAobm9kZS5leHBvcnRLaW5kID09PSBcInR5cGVcIikge1xuICAgIHRoaXMud29yZChcInR5cGVcIik7XG4gICAgdGhpcy5zcGFjZSgpO1xuICB9XG4gIHRoaXMudG9rZW5DaGFyKDQyKTtcbiAgdGhpcy5zcGFjZSgpO1xuICB0aGlzLndvcmQoXCJmcm9tXCIpO1xuICB0aGlzLnNwYWNlKCk7XG4gIGlmICgoX25vZGUkYXR0cmlidXRlcyA9IG5vZGUuYXR0cmlidXRlcykgIT0gbnVsbCAmJiBfbm9kZSRhdHRyaWJ1dGVzLmxlbmd0aCB8fCAoX25vZGUkYXNzZXJ0aW9ucyA9IG5vZGUuYXNzZXJ0aW9ucykgIT0gbnVsbCAmJiBfbm9kZSRhc3NlcnRpb25zLmxlbmd0aCkge1xuICAgIHRoaXMucHJpbnQobm9kZS5zb3VyY2UsIHRydWUpO1xuICAgIHRoaXMuc3BhY2UoKTtcbiAgICB0aGlzLl9wcmludEF0dHJpYnV0ZXMobm9kZSwgZmFsc2UpO1xuICB9IGVsc2Uge1xuICAgIHRoaXMucHJpbnQobm9kZS5zb3VyY2UpO1xuICB9XG4gIHRoaXMuc2VtaWNvbG9uKCk7XG59XG5mdW5jdGlvbiBtYXliZVByaW50RGVjb3JhdG9yc0JlZm9yZUV4cG9ydChwcmludGVyLCBub2RlKSB7XG4gIGlmIChpc0NsYXNzRGVjbGFyYXRpb24obm9kZS5kZWNsYXJhdGlvbikgJiYgcHJpbnRlci5fc2hvdWxkUHJpbnREZWNvcmF0b3JzQmVmb3JlRXhwb3J0KG5vZGUpKSB7XG4gICAgcHJpbnRlci5wcmludEpvaW4obm9kZS5kZWNsYXJhdGlvbi5kZWNvcmF0b3JzKTtcbiAgfVxufVxuZnVuY3Rpb24gRXhwb3J0TmFtZWREZWNsYXJhdGlvbihub2RlKSB7XG4gIG1heWJlUHJpbnREZWNvcmF0b3JzQmVmb3JlRXhwb3J0KHRoaXMsIG5vZGUpO1xuICB0aGlzLndvcmQoXCJleHBvcnRcIik7XG4gIHRoaXMuc3BhY2UoKTtcbiAgaWYgKG5vZGUuZGVjbGFyYXRpb24pIHtcbiAgICBjb25zdCBkZWNsYXIgPSBub2RlLmRlY2xhcmF0aW9uO1xuICAgIHRoaXMucHJpbnQoZGVjbGFyKTtcbiAgICBpZiAoIWlzU3RhdGVtZW50KGRlY2xhcikpIHRoaXMuc2VtaWNvbG9uKCk7XG4gIH0gZWxzZSB7XG4gICAgaWYgKG5vZGUuZXhwb3J0S2luZCA9PT0gXCJ0eXBlXCIpIHtcbiAgICAgIHRoaXMud29yZChcInR5cGVcIik7XG4gICAgICB0aGlzLnNwYWNlKCk7XG4gICAgfVxuICAgIGNvbnN0IHNwZWNpZmllcnMgPSBub2RlLnNwZWNpZmllcnMuc2xpY2UoMCk7XG4gICAgbGV0IGhhc1NwZWNpYWwgPSBmYWxzZTtcbiAgICBmb3IgKDs7KSB7XG4gICAgICBjb25zdCBmaXJzdCA9IHNwZWNpZmllcnNbMF07XG4gICAgICBpZiAoaXNFeHBvcnREZWZhdWx0U3BlY2lmaWVyKGZpcnN0KSB8fCBpc0V4cG9ydE5hbWVzcGFjZVNwZWNpZmllcihmaXJzdCkpIHtcbiAgICAgICAgaGFzU3BlY2lhbCA9IHRydWU7XG4gICAgICAgIHRoaXMucHJpbnQoc3BlY2lmaWVycy5zaGlmdCgpKTtcbiAgICAgICAgaWYgKHNwZWNpZmllcnMubGVuZ3RoKSB7XG4gICAgICAgICAgdGhpcy50b2tlbkNoYXIoNDQpO1xuICAgICAgICAgIHRoaXMuc3BhY2UoKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICAgIGxldCBoYXNCcmFjZSA9IGZhbHNlO1xuICAgIGlmIChzcGVjaWZpZXJzLmxlbmd0aCB8fCAhc3BlY2lmaWVycy5sZW5ndGggJiYgIWhhc1NwZWNpYWwpIHtcbiAgICAgIGhhc0JyYWNlID0gdHJ1ZTtcbiAgICAgIHRoaXMudG9rZW5DaGFyKDEyMyk7XG4gICAgICBpZiAoc3BlY2lmaWVycy5sZW5ndGgpIHtcbiAgICAgICAgdGhpcy5zcGFjZSgpO1xuICAgICAgICB0aGlzLnByaW50TGlzdChzcGVjaWZpZXJzLCB0aGlzLnNob3VsZFByaW50VHJhaWxpbmdDb21tYShcIn1cIikpO1xuICAgICAgICB0aGlzLnNwYWNlKCk7XG4gICAgICB9XG4gICAgICB0aGlzLnRva2VuQ2hhcigxMjUpO1xuICAgIH1cbiAgICBpZiAobm9kZS5zb3VyY2UpIHtcbiAgICAgIHZhciBfbm9kZSRhdHRyaWJ1dGVzMiwgX25vZGUkYXNzZXJ0aW9uczI7XG4gICAgICB0aGlzLnNwYWNlKCk7XG4gICAgICB0aGlzLndvcmQoXCJmcm9tXCIpO1xuICAgICAgdGhpcy5zcGFjZSgpO1xuICAgICAgaWYgKChfbm9kZSRhdHRyaWJ1dGVzMiA9IG5vZGUuYXR0cmlidXRlcykgIT0gbnVsbCAmJiBfbm9kZSRhdHRyaWJ1dGVzMi5sZW5ndGggfHwgKF9ub2RlJGFzc2VydGlvbnMyID0gbm9kZS5hc3NlcnRpb25zKSAhPSBudWxsICYmIF9ub2RlJGFzc2VydGlvbnMyLmxlbmd0aCkge1xuICAgICAgICB0aGlzLnByaW50KG5vZGUuc291cmNlLCB0cnVlKTtcbiAgICAgICAgdGhpcy5zcGFjZSgpO1xuICAgICAgICB0aGlzLl9wcmludEF0dHJpYnV0ZXMobm9kZSwgaGFzQnJhY2UpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5wcmludChub2RlLnNvdXJjZSk7XG4gICAgICB9XG4gICAgfVxuICAgIHRoaXMuc2VtaWNvbG9uKCk7XG4gIH1cbn1cbmZ1bmN0aW9uIEV4cG9ydERlZmF1bHREZWNsYXJhdGlvbihub2RlKSB7XG4gIG1heWJlUHJpbnREZWNvcmF0b3JzQmVmb3JlRXhwb3J0KHRoaXMsIG5vZGUpO1xuICB0aGlzLndvcmQoXCJleHBvcnRcIik7XG4gIHRoaXMubm9JbmRlbnRJbm5lckNvbW1lbnRzSGVyZSgpO1xuICB0aGlzLnNwYWNlKCk7XG4gIHRoaXMud29yZChcImRlZmF1bHRcIik7XG4gIHRoaXMuc3BhY2UoKTtcbiAgdGhpcy50b2tlbkNvbnRleHQgfD0gX2luZGV4LlRva2VuQ29udGV4dC5leHBvcnREZWZhdWx0O1xuICBjb25zdCBkZWNsYXIgPSBub2RlLmRlY2xhcmF0aW9uO1xuICB0aGlzLnByaW50KGRlY2xhcik7XG4gIGlmICghaXNTdGF0ZW1lbnQoZGVjbGFyKSkgdGhpcy5zZW1pY29sb24oKTtcbn1cbmZ1bmN0aW9uIEltcG9ydERlY2xhcmF0aW9uKG5vZGUpIHtcbiAgdmFyIF9ub2RlJGF0dHJpYnV0ZXMzLCBfbm9kZSRhc3NlcnRpb25zMztcbiAgdGhpcy53b3JkKFwiaW1wb3J0XCIpO1xuICB0aGlzLnNwYWNlKCk7XG4gIGNvbnN0IGlzVHlwZUtpbmQgPSBub2RlLmltcG9ydEtpbmQgPT09IFwidHlwZVwiIHx8IG5vZGUuaW1wb3J0S2luZCA9PT0gXCJ0eXBlb2ZcIjtcbiAgaWYgKGlzVHlwZUtpbmQpIHtcbiAgICB0aGlzLm5vSW5kZW50SW5uZXJDb21tZW50c0hlcmUoKTtcbiAgICB0aGlzLndvcmQobm9kZS5pbXBvcnRLaW5kKTtcbiAgICB0aGlzLnNwYWNlKCk7XG4gIH0gZWxzZSBpZiAobm9kZS5tb2R1bGUpIHtcbiAgICB0aGlzLm5vSW5kZW50SW5uZXJDb21tZW50c0hlcmUoKTtcbiAgICB0aGlzLndvcmQoXCJtb2R1bGVcIik7XG4gICAgdGhpcy5zcGFjZSgpO1xuICB9IGVsc2UgaWYgKG5vZGUucGhhc2UpIHtcbiAgICB0aGlzLm5vSW5kZW50SW5uZXJDb21tZW50c0hlcmUoKTtcbiAgICB0aGlzLndvcmQobm9kZS5waGFzZSk7XG4gICAgdGhpcy5zcGFjZSgpO1xuICB9XG4gIGNvbnN0IHNwZWNpZmllcnMgPSBub2RlLnNwZWNpZmllcnMuc2xpY2UoMCk7XG4gIGNvbnN0IGhhc1NwZWNpZmllcnMgPSAhIXNwZWNpZmllcnMubGVuZ3RoO1xuICB3aGlsZSAoaGFzU3BlY2lmaWVycykge1xuICAgIGNvbnN0IGZpcnN0ID0gc3BlY2lmaWVyc1swXTtcbiAgICBpZiAoaXNJbXBvcnREZWZhdWx0U3BlY2lmaWVyKGZpcnN0KSB8fCBpc0ltcG9ydE5hbWVzcGFjZVNwZWNpZmllcihmaXJzdCkpIHtcbiAgICAgIHRoaXMucHJpbnQoc3BlY2lmaWVycy5zaGlmdCgpKTtcbiAgICAgIGlmIChzcGVjaWZpZXJzLmxlbmd0aCkge1xuICAgICAgICB0aGlzLnRva2VuQ2hhcig0NCk7XG4gICAgICAgIHRoaXMuc3BhY2UoKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG4gIGxldCBoYXNCcmFjZSA9IGZhbHNlO1xuICBpZiAoc3BlY2lmaWVycy5sZW5ndGgpIHtcbiAgICBoYXNCcmFjZSA9IHRydWU7XG4gICAgdGhpcy50b2tlbkNoYXIoMTIzKTtcbiAgICB0aGlzLnNwYWNlKCk7XG4gICAgdGhpcy5wcmludExpc3Qoc3BlY2lmaWVycywgdGhpcy5zaG91bGRQcmludFRyYWlsaW5nQ29tbWEoXCJ9XCIpKTtcbiAgICB0aGlzLnNwYWNlKCk7XG4gICAgdGhpcy50b2tlbkNoYXIoMTI1KTtcbiAgfSBlbHNlIGlmIChpc1R5cGVLaW5kICYmICFoYXNTcGVjaWZpZXJzKSB7XG4gICAgaGFzQnJhY2UgPSB0cnVlO1xuICAgIHRoaXMudG9rZW5DaGFyKDEyMyk7XG4gICAgdGhpcy50b2tlbkNoYXIoMTI1KTtcbiAgfVxuICBpZiAoaGFzU3BlY2lmaWVycyB8fCBpc1R5cGVLaW5kKSB7XG4gICAgdGhpcy5zcGFjZSgpO1xuICAgIHRoaXMud29yZChcImZyb21cIik7XG4gICAgdGhpcy5zcGFjZSgpO1xuICB9XG4gIGlmICgoX25vZGUkYXR0cmlidXRlczMgPSBub2RlLmF0dHJpYnV0ZXMpICE9IG51bGwgJiYgX25vZGUkYXR0cmlidXRlczMubGVuZ3RoIHx8IChfbm9kZSRhc3NlcnRpb25zMyA9IG5vZGUuYXNzZXJ0aW9ucykgIT0gbnVsbCAmJiBfbm9kZSRhc3NlcnRpb25zMy5sZW5ndGgpIHtcbiAgICB0aGlzLnByaW50KG5vZGUuc291cmNlLCB0cnVlKTtcbiAgICB0aGlzLnNwYWNlKCk7XG4gICAgdGhpcy5fcHJpbnRBdHRyaWJ1dGVzKG5vZGUsIGhhc0JyYWNlKTtcbiAgfSBlbHNlIHtcbiAgICB0aGlzLnByaW50KG5vZGUuc291cmNlKTtcbiAgfVxuICB0aGlzLnNlbWljb2xvbigpO1xufVxuZnVuY3Rpb24gSW1wb3J0QXR0cmlidXRlKG5vZGUpIHtcbiAgdGhpcy5wcmludChub2RlLmtleSk7XG4gIHRoaXMudG9rZW5DaGFyKDU4KTtcbiAgdGhpcy5zcGFjZSgpO1xuICB0aGlzLnByaW50KG5vZGUudmFsdWUpO1xufVxuZnVuY3Rpb24gSW1wb3J0TmFtZXNwYWNlU3BlY2lmaWVyKG5vZGUpIHtcbiAgdGhpcy50b2tlbkNoYXIoNDIpO1xuICB0aGlzLnNwYWNlKCk7XG4gIHRoaXMud29yZChcImFzXCIpO1xuICB0aGlzLnNwYWNlKCk7XG4gIHRoaXMucHJpbnQobm9kZS5sb2NhbCk7XG59XG5mdW5jdGlvbiBJbXBvcnRFeHByZXNzaW9uKG5vZGUpIHtcbiAgdGhpcy53b3JkKFwiaW1wb3J0XCIpO1xuICBpZiAobm9kZS5waGFzZSkge1xuICAgIHRoaXMudG9rZW5DaGFyKDQ2KTtcbiAgICB0aGlzLndvcmQobm9kZS5waGFzZSk7XG4gIH1cbiAgdGhpcy50b2tlbkNoYXIoNDApO1xuICBjb25zdCBzaG91bGRQcmludFRyYWlsaW5nQ29tbWEgPSB0aGlzLnNob3VsZFByaW50VHJhaWxpbmdDb21tYShcIilcIik7XG4gIHRoaXMucHJpbnQobm9kZS5zb3VyY2UpO1xuICBpZiAobm9kZS5vcHRpb25zICE9IG51bGwpIHtcbiAgICB0aGlzLnRva2VuQ2hhcig0NCk7XG4gICAgdGhpcy5zcGFjZSgpO1xuICAgIHRoaXMucHJpbnQobm9kZS5vcHRpb25zKTtcbiAgfVxuICBpZiAoc2hvdWxkUHJpbnRUcmFpbGluZ0NvbW1hKSB7XG4gICAgdGhpcy50b2tlbkNoYXIoNDQpO1xuICB9XG4gIHRoaXMucmlnaHRQYXJlbnMobm9kZSk7XG59XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW1vZHVsZXMuanMubWFwXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@babel/generator/lib/generators/modules.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@babel/generator/lib/generators/statements.js":
/*!********************************************************************!*\
  !*** ./node_modules/@babel/generator/lib/generators/statements.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports.BreakStatement = BreakStatement;\nexports.CatchClause = CatchClause;\nexports.ContinueStatement = ContinueStatement;\nexports.DebuggerStatement = DebuggerStatement;\nexports.DoWhileStatement = DoWhileStatement;\nexports.ForOfStatement = exports.ForInStatement = void 0;\nexports.ForStatement = ForStatement;\nexports.IfStatement = IfStatement;\nexports.LabeledStatement = LabeledStatement;\nexports.ReturnStatement = ReturnStatement;\nexports.SwitchCase = SwitchCase;\nexports.SwitchStatement = SwitchStatement;\nexports.ThrowStatement = ThrowStatement;\nexports.TryStatement = TryStatement;\nexports.VariableDeclaration = VariableDeclaration;\nexports.VariableDeclarator = VariableDeclarator;\nexports.WhileStatement = WhileStatement;\nexports.WithStatement = WithStatement;\nvar _t = __webpack_require__(/*! @babel/types */ \"(ssr)/./node_modules/@babel/types/lib/index.js\");\nconst {\n  isFor,\n  isForStatement,\n  isIfStatement,\n  isStatement\n} = _t;\nfunction WithStatement(node) {\n  this.word(\"with\");\n  this.space();\n  this.tokenChar(40);\n  this.print(node.object);\n  this.tokenChar(41);\n  this.printBlock(node);\n}\nfunction IfStatement(node) {\n  this.word(\"if\");\n  this.space();\n  this.tokenChar(40);\n  this.print(node.test);\n  this.tokenChar(41);\n  this.space();\n  const needsBlock = node.alternate && isIfStatement(getLastStatement(node.consequent));\n  if (needsBlock) {\n    this.tokenChar(123);\n    this.newline();\n    this.indent();\n  }\n  this.printAndIndentOnComments(node.consequent);\n  if (needsBlock) {\n    this.dedent();\n    this.newline();\n    this.tokenChar(125);\n  }\n  if (node.alternate) {\n    if (this.endsWith(125)) this.space();\n    this.word(\"else\");\n    this.space();\n    this.printAndIndentOnComments(node.alternate);\n  }\n}\nfunction getLastStatement(statement) {\n  const {\n    body\n  } = statement;\n  if (isStatement(body) === false) {\n    return statement;\n  }\n  return getLastStatement(body);\n}\nfunction ForStatement(node) {\n  this.word(\"for\");\n  this.space();\n  this.tokenChar(40);\n  {\n    const exit = this.enterForStatementInit();\n    this.print(node.init);\n    exit();\n  }\n  this.tokenChar(59);\n  if (node.test) {\n    this.space();\n    this.print(node.test);\n  }\n  this.token(\";\", false, 1);\n  if (node.update) {\n    this.space();\n    this.print(node.update);\n  }\n  this.tokenChar(41);\n  this.printBlock(node);\n}\nfunction WhileStatement(node) {\n  this.word(\"while\");\n  this.space();\n  this.tokenChar(40);\n  this.print(node.test);\n  this.tokenChar(41);\n  this.printBlock(node);\n}\nfunction ForXStatement(node) {\n  this.word(\"for\");\n  this.space();\n  const isForOf = node.type === \"ForOfStatement\";\n  if (isForOf && node.await) {\n    this.word(\"await\");\n    this.space();\n  }\n  this.noIndentInnerCommentsHere();\n  this.tokenChar(40);\n  {\n    const exit = this.enterForXStatementInit(isForOf);\n    this.print(node.left);\n    exit == null || exit();\n  }\n  this.space();\n  this.word(isForOf ? \"of\" : \"in\");\n  this.space();\n  this.print(node.right);\n  this.tokenChar(41);\n  this.printBlock(node);\n}\nconst ForInStatement = exports.ForInStatement = ForXStatement;\nconst ForOfStatement = exports.ForOfStatement = ForXStatement;\nfunction DoWhileStatement(node) {\n  this.word(\"do\");\n  this.space();\n  this.print(node.body);\n  this.space();\n  this.word(\"while\");\n  this.space();\n  this.tokenChar(40);\n  this.print(node.test);\n  this.tokenChar(41);\n  this.semicolon();\n}\nfunction printStatementAfterKeyword(printer, node) {\n  if (node) {\n    printer.space();\n    printer.printTerminatorless(node);\n  }\n  printer.semicolon();\n}\nfunction BreakStatement(node) {\n  this.word(\"break\");\n  printStatementAfterKeyword(this, node.label);\n}\nfunction ContinueStatement(node) {\n  this.word(\"continue\");\n  printStatementAfterKeyword(this, node.label);\n}\nfunction ReturnStatement(node) {\n  this.word(\"return\");\n  printStatementAfterKeyword(this, node.argument);\n}\nfunction ThrowStatement(node) {\n  this.word(\"throw\");\n  printStatementAfterKeyword(this, node.argument);\n}\nfunction LabeledStatement(node) {\n  this.print(node.label);\n  this.tokenChar(58);\n  this.space();\n  this.print(node.body);\n}\nfunction TryStatement(node) {\n  this.word(\"try\");\n  this.space();\n  this.print(node.block);\n  this.space();\n  if (node.handlers) {\n    this.print(node.handlers[0]);\n  } else {\n    this.print(node.handler);\n  }\n  if (node.finalizer) {\n    this.space();\n    this.word(\"finally\");\n    this.space();\n    this.print(node.finalizer);\n  }\n}\nfunction CatchClause(node) {\n  this.word(\"catch\");\n  this.space();\n  if (node.param) {\n    this.tokenChar(40);\n    this.print(node.param);\n    this.print(node.param.typeAnnotation);\n    this.tokenChar(41);\n    this.space();\n  }\n  this.print(node.body);\n}\nfunction SwitchStatement(node) {\n  this.word(\"switch\");\n  this.space();\n  this.tokenChar(40);\n  this.print(node.discriminant);\n  this.tokenChar(41);\n  this.space();\n  this.tokenChar(123);\n  this.printSequence(node.cases, true);\n  this.rightBrace(node);\n}\nfunction SwitchCase(node) {\n  if (node.test) {\n    this.word(\"case\");\n    this.space();\n    this.print(node.test);\n    this.tokenChar(58);\n  } else {\n    this.word(\"default\");\n    this.tokenChar(58);\n  }\n  if (node.consequent.length) {\n    this.newline();\n    this.printSequence(node.consequent, true);\n  }\n}\nfunction DebuggerStatement() {\n  this.word(\"debugger\");\n  this.semicolon();\n}\nfunction VariableDeclaration(node, parent) {\n  if (node.declare) {\n    this.word(\"declare\");\n    this.space();\n  }\n  const {\n    kind\n  } = node;\n  if (kind === \"await using\") {\n    this.word(\"await\");\n    this.space();\n    this.word(\"using\", true);\n  } else {\n    this.word(kind, kind === \"using\");\n  }\n  this.space();\n  let hasInits = false;\n  if (!isFor(parent)) {\n    for (const declar of node.declarations) {\n      if (declar.init) {\n        hasInits = true;\n      }\n    }\n  }\n  this.printList(node.declarations, undefined, undefined, node.declarations.length > 1, hasInits ? function (occurrenceCount) {\n    this.token(\",\", false, occurrenceCount);\n    this.newline();\n  } : undefined);\n  if (isFor(parent)) {\n    if (isForStatement(parent)) {\n      if (parent.init === node) return;\n    } else {\n      if (parent.left === node) return;\n    }\n  }\n  this.semicolon();\n}\nfunction VariableDeclarator(node) {\n  this.print(node.id);\n  if (node.definite) this.tokenChar(33);\n  this.print(node.id.typeAnnotation);\n  if (node.init) {\n    this.space();\n    this.tokenChar(61);\n    this.space();\n    this.print(node.init);\n  }\n}\n\n//# sourceMappingURL=statements.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGJhYmVsL2dlbmVyYXRvci9saWIvZ2VuZXJhdG9ycy9zdGF0ZW1lbnRzLmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViLDhDQUE2QztBQUM3QztBQUNBLENBQUMsRUFBQztBQUNGLHNCQUFzQjtBQUN0QixtQkFBbUI7QUFDbkIseUJBQXlCO0FBQ3pCLHlCQUF5QjtBQUN6Qix3QkFBd0I7QUFDeEIsc0JBQXNCLEdBQUcsc0JBQXNCO0FBQy9DLG9CQUFvQjtBQUNwQixtQkFBbUI7QUFDbkIsd0JBQXdCO0FBQ3hCLHVCQUF1QjtBQUN2QixrQkFBa0I7QUFDbEIsdUJBQXVCO0FBQ3ZCLHNCQUFzQjtBQUN0QixvQkFBb0I7QUFDcEIsMkJBQTJCO0FBQzNCLDBCQUEwQjtBQUMxQixzQkFBc0I7QUFDdEIscUJBQXFCO0FBQ3JCLFNBQVMsbUJBQU8sQ0FBQyxvRUFBYztBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLHNCQUFzQjtBQUM3Qyx1QkFBdUIsc0JBQXNCO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcmVwby12aXN1YWxpemVyLy4vbm9kZV9tb2R1bGVzL0BiYWJlbC9nZW5lcmF0b3IvbGliL2dlbmVyYXRvcnMvc3RhdGVtZW50cy5qcz81MzJjIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5CcmVha1N0YXRlbWVudCA9IEJyZWFrU3RhdGVtZW50O1xuZXhwb3J0cy5DYXRjaENsYXVzZSA9IENhdGNoQ2xhdXNlO1xuZXhwb3J0cy5Db250aW51ZVN0YXRlbWVudCA9IENvbnRpbnVlU3RhdGVtZW50O1xuZXhwb3J0cy5EZWJ1Z2dlclN0YXRlbWVudCA9IERlYnVnZ2VyU3RhdGVtZW50O1xuZXhwb3J0cy5Eb1doaWxlU3RhdGVtZW50ID0gRG9XaGlsZVN0YXRlbWVudDtcbmV4cG9ydHMuRm9yT2ZTdGF0ZW1lbnQgPSBleHBvcnRzLkZvckluU3RhdGVtZW50ID0gdm9pZCAwO1xuZXhwb3J0cy5Gb3JTdGF0ZW1lbnQgPSBGb3JTdGF0ZW1lbnQ7XG5leHBvcnRzLklmU3RhdGVtZW50ID0gSWZTdGF0ZW1lbnQ7XG5leHBvcnRzLkxhYmVsZWRTdGF0ZW1lbnQgPSBMYWJlbGVkU3RhdGVtZW50O1xuZXhwb3J0cy5SZXR1cm5TdGF0ZW1lbnQgPSBSZXR1cm5TdGF0ZW1lbnQ7XG5leHBvcnRzLlN3aXRjaENhc2UgPSBTd2l0Y2hDYXNlO1xuZXhwb3J0cy5Td2l0Y2hTdGF0ZW1lbnQgPSBTd2l0Y2hTdGF0ZW1lbnQ7XG5leHBvcnRzLlRocm93U3RhdGVtZW50ID0gVGhyb3dTdGF0ZW1lbnQ7XG5leHBvcnRzLlRyeVN0YXRlbWVudCA9IFRyeVN0YXRlbWVudDtcbmV4cG9ydHMuVmFyaWFibGVEZWNsYXJhdGlvbiA9IFZhcmlhYmxlRGVjbGFyYXRpb247XG5leHBvcnRzLlZhcmlhYmxlRGVjbGFyYXRvciA9IFZhcmlhYmxlRGVjbGFyYXRvcjtcbmV4cG9ydHMuV2hpbGVTdGF0ZW1lbnQgPSBXaGlsZVN0YXRlbWVudDtcbmV4cG9ydHMuV2l0aFN0YXRlbWVudCA9IFdpdGhTdGF0ZW1lbnQ7XG52YXIgX3QgPSByZXF1aXJlKFwiQGJhYmVsL3R5cGVzXCIpO1xuY29uc3Qge1xuICBpc0ZvcixcbiAgaXNGb3JTdGF0ZW1lbnQsXG4gIGlzSWZTdGF0ZW1lbnQsXG4gIGlzU3RhdGVtZW50XG59ID0gX3Q7XG5mdW5jdGlvbiBXaXRoU3RhdGVtZW50KG5vZGUpIHtcbiAgdGhpcy53b3JkKFwid2l0aFwiKTtcbiAgdGhpcy5zcGFjZSgpO1xuICB0aGlzLnRva2VuQ2hhcig0MCk7XG4gIHRoaXMucHJpbnQobm9kZS5vYmplY3QpO1xuICB0aGlzLnRva2VuQ2hhcig0MSk7XG4gIHRoaXMucHJpbnRCbG9jayhub2RlKTtcbn1cbmZ1bmN0aW9uIElmU3RhdGVtZW50KG5vZGUpIHtcbiAgdGhpcy53b3JkKFwiaWZcIik7XG4gIHRoaXMuc3BhY2UoKTtcbiAgdGhpcy50b2tlbkNoYXIoNDApO1xuICB0aGlzLnByaW50KG5vZGUudGVzdCk7XG4gIHRoaXMudG9rZW5DaGFyKDQxKTtcbiAgdGhpcy5zcGFjZSgpO1xuICBjb25zdCBuZWVkc0Jsb2NrID0gbm9kZS5hbHRlcm5hdGUgJiYgaXNJZlN0YXRlbWVudChnZXRMYXN0U3RhdGVtZW50KG5vZGUuY29uc2VxdWVudCkpO1xuICBpZiAobmVlZHNCbG9jaykge1xuICAgIHRoaXMudG9rZW5DaGFyKDEyMyk7XG4gICAgdGhpcy5uZXdsaW5lKCk7XG4gICAgdGhpcy5pbmRlbnQoKTtcbiAgfVxuICB0aGlzLnByaW50QW5kSW5kZW50T25Db21tZW50cyhub2RlLmNvbnNlcXVlbnQpO1xuICBpZiAobmVlZHNCbG9jaykge1xuICAgIHRoaXMuZGVkZW50KCk7XG4gICAgdGhpcy5uZXdsaW5lKCk7XG4gICAgdGhpcy50b2tlbkNoYXIoMTI1KTtcbiAgfVxuICBpZiAobm9kZS5hbHRlcm5hdGUpIHtcbiAgICBpZiAodGhpcy5lbmRzV2l0aCgxMjUpKSB0aGlzLnNwYWNlKCk7XG4gICAgdGhpcy53b3JkKFwiZWxzZVwiKTtcbiAgICB0aGlzLnNwYWNlKCk7XG4gICAgdGhpcy5wcmludEFuZEluZGVudE9uQ29tbWVudHMobm9kZS5hbHRlcm5hdGUpO1xuICB9XG59XG5mdW5jdGlvbiBnZXRMYXN0U3RhdGVtZW50KHN0YXRlbWVudCkge1xuICBjb25zdCB7XG4gICAgYm9keVxuICB9ID0gc3RhdGVtZW50O1xuICBpZiAoaXNTdGF0ZW1lbnQoYm9keSkgPT09IGZhbHNlKSB7XG4gICAgcmV0dXJuIHN0YXRlbWVudDtcbiAgfVxuICByZXR1cm4gZ2V0TGFzdFN0YXRlbWVudChib2R5KTtcbn1cbmZ1bmN0aW9uIEZvclN0YXRlbWVudChub2RlKSB7XG4gIHRoaXMud29yZChcImZvclwiKTtcbiAgdGhpcy5zcGFjZSgpO1xuICB0aGlzLnRva2VuQ2hhcig0MCk7XG4gIHtcbiAgICBjb25zdCBleGl0ID0gdGhpcy5lbnRlckZvclN0YXRlbWVudEluaXQoKTtcbiAgICB0aGlzLnByaW50KG5vZGUuaW5pdCk7XG4gICAgZXhpdCgpO1xuICB9XG4gIHRoaXMudG9rZW5DaGFyKDU5KTtcbiAgaWYgKG5vZGUudGVzdCkge1xuICAgIHRoaXMuc3BhY2UoKTtcbiAgICB0aGlzLnByaW50KG5vZGUudGVzdCk7XG4gIH1cbiAgdGhpcy50b2tlbihcIjtcIiwgZmFsc2UsIDEpO1xuICBpZiAobm9kZS51cGRhdGUpIHtcbiAgICB0aGlzLnNwYWNlKCk7XG4gICAgdGhpcy5wcmludChub2RlLnVwZGF0ZSk7XG4gIH1cbiAgdGhpcy50b2tlbkNoYXIoNDEpO1xuICB0aGlzLnByaW50QmxvY2sobm9kZSk7XG59XG5mdW5jdGlvbiBXaGlsZVN0YXRlbWVudChub2RlKSB7XG4gIHRoaXMud29yZChcIndoaWxlXCIpO1xuICB0aGlzLnNwYWNlKCk7XG4gIHRoaXMudG9rZW5DaGFyKDQwKTtcbiAgdGhpcy5wcmludChub2RlLnRlc3QpO1xuICB0aGlzLnRva2VuQ2hhcig0MSk7XG4gIHRoaXMucHJpbnRCbG9jayhub2RlKTtcbn1cbmZ1bmN0aW9uIEZvclhTdGF0ZW1lbnQobm9kZSkge1xuICB0aGlzLndvcmQoXCJmb3JcIik7XG4gIHRoaXMuc3BhY2UoKTtcbiAgY29uc3QgaXNGb3JPZiA9IG5vZGUudHlwZSA9PT0gXCJGb3JPZlN0YXRlbWVudFwiO1xuICBpZiAoaXNGb3JPZiAmJiBub2RlLmF3YWl0KSB7XG4gICAgdGhpcy53b3JkKFwiYXdhaXRcIik7XG4gICAgdGhpcy5zcGFjZSgpO1xuICB9XG4gIHRoaXMubm9JbmRlbnRJbm5lckNvbW1lbnRzSGVyZSgpO1xuICB0aGlzLnRva2VuQ2hhcig0MCk7XG4gIHtcbiAgICBjb25zdCBleGl0ID0gdGhpcy5lbnRlckZvclhTdGF0ZW1lbnRJbml0KGlzRm9yT2YpO1xuICAgIHRoaXMucHJpbnQobm9kZS5sZWZ0KTtcbiAgICBleGl0ID09IG51bGwgfHwgZXhpdCgpO1xuICB9XG4gIHRoaXMuc3BhY2UoKTtcbiAgdGhpcy53b3JkKGlzRm9yT2YgPyBcIm9mXCIgOiBcImluXCIpO1xuICB0aGlzLnNwYWNlKCk7XG4gIHRoaXMucHJpbnQobm9kZS5yaWdodCk7XG4gIHRoaXMudG9rZW5DaGFyKDQxKTtcbiAgdGhpcy5wcmludEJsb2NrKG5vZGUpO1xufVxuY29uc3QgRm9ySW5TdGF0ZW1lbnQgPSBleHBvcnRzLkZvckluU3RhdGVtZW50ID0gRm9yWFN0YXRlbWVudDtcbmNvbnN0IEZvck9mU3RhdGVtZW50ID0gZXhwb3J0cy5Gb3JPZlN0YXRlbWVudCA9IEZvclhTdGF0ZW1lbnQ7XG5mdW5jdGlvbiBEb1doaWxlU3RhdGVtZW50KG5vZGUpIHtcbiAgdGhpcy53b3JkKFwiZG9cIik7XG4gIHRoaXMuc3BhY2UoKTtcbiAgdGhpcy5wcmludChub2RlLmJvZHkpO1xuICB0aGlzLnNwYWNlKCk7XG4gIHRoaXMud29yZChcIndoaWxlXCIpO1xuICB0aGlzLnNwYWNlKCk7XG4gIHRoaXMudG9rZW5DaGFyKDQwKTtcbiAgdGhpcy5wcmludChub2RlLnRlc3QpO1xuICB0aGlzLnRva2VuQ2hhcig0MSk7XG4gIHRoaXMuc2VtaWNvbG9uKCk7XG59XG5mdW5jdGlvbiBwcmludFN0YXRlbWVudEFmdGVyS2V5d29yZChwcmludGVyLCBub2RlKSB7XG4gIGlmIChub2RlKSB7XG4gICAgcHJpbnRlci5zcGFjZSgpO1xuICAgIHByaW50ZXIucHJpbnRUZXJtaW5hdG9ybGVzcyhub2RlKTtcbiAgfVxuICBwcmludGVyLnNlbWljb2xvbigpO1xufVxuZnVuY3Rpb24gQnJlYWtTdGF0ZW1lbnQobm9kZSkge1xuICB0aGlzLndvcmQoXCJicmVha1wiKTtcbiAgcHJpbnRTdGF0ZW1lbnRBZnRlcktleXdvcmQodGhpcywgbm9kZS5sYWJlbCk7XG59XG5mdW5jdGlvbiBDb250aW51ZVN0YXRlbWVudChub2RlKSB7XG4gIHRoaXMud29yZChcImNvbnRpbnVlXCIpO1xuICBwcmludFN0YXRlbWVudEFmdGVyS2V5d29yZCh0aGlzLCBub2RlLmxhYmVsKTtcbn1cbmZ1bmN0aW9uIFJldHVyblN0YXRlbWVudChub2RlKSB7XG4gIHRoaXMud29yZChcInJldHVyblwiKTtcbiAgcHJpbnRTdGF0ZW1lbnRBZnRlcktleXdvcmQodGhpcywgbm9kZS5hcmd1bWVudCk7XG59XG5mdW5jdGlvbiBUaHJvd1N0YXRlbWVudChub2RlKSB7XG4gIHRoaXMud29yZChcInRocm93XCIpO1xuICBwcmludFN0YXRlbWVudEFmdGVyS2V5d29yZCh0aGlzLCBub2RlLmFyZ3VtZW50KTtcbn1cbmZ1bmN0aW9uIExhYmVsZWRTdGF0ZW1lbnQobm9kZSkge1xuICB0aGlzLnByaW50KG5vZGUubGFiZWwpO1xuICB0aGlzLnRva2VuQ2hhcig1OCk7XG4gIHRoaXMuc3BhY2UoKTtcbiAgdGhpcy5wcmludChub2RlLmJvZHkpO1xufVxuZnVuY3Rpb24gVHJ5U3RhdGVtZW50KG5vZGUpIHtcbiAgdGhpcy53b3JkKFwidHJ5XCIpO1xuICB0aGlzLnNwYWNlKCk7XG4gIHRoaXMucHJpbnQobm9kZS5ibG9jayk7XG4gIHRoaXMuc3BhY2UoKTtcbiAgaWYgKG5vZGUuaGFuZGxlcnMpIHtcbiAgICB0aGlzLnByaW50KG5vZGUuaGFuZGxlcnNbMF0pO1xuICB9IGVsc2Uge1xuICAgIHRoaXMucHJpbnQobm9kZS5oYW5kbGVyKTtcbiAgfVxuICBpZiAobm9kZS5maW5hbGl6ZXIpIHtcbiAgICB0aGlzLnNwYWNlKCk7XG4gICAgdGhpcy53b3JkKFwiZmluYWxseVwiKTtcbiAgICB0aGlzLnNwYWNlKCk7XG4gICAgdGhpcy5wcmludChub2RlLmZpbmFsaXplcik7XG4gIH1cbn1cbmZ1bmN0aW9uIENhdGNoQ2xhdXNlKG5vZGUpIHtcbiAgdGhpcy53b3JkKFwiY2F0Y2hcIik7XG4gIHRoaXMuc3BhY2UoKTtcbiAgaWYgKG5vZGUucGFyYW0pIHtcbiAgICB0aGlzLnRva2VuQ2hhcig0MCk7XG4gICAgdGhpcy5wcmludChub2RlLnBhcmFtKTtcbiAgICB0aGlzLnByaW50KG5vZGUucGFyYW0udHlwZUFubm90YXRpb24pO1xuICAgIHRoaXMudG9rZW5DaGFyKDQxKTtcbiAgICB0aGlzLnNwYWNlKCk7XG4gIH1cbiAgdGhpcy5wcmludChub2RlLmJvZHkpO1xufVxuZnVuY3Rpb24gU3dpdGNoU3RhdGVtZW50KG5vZGUpIHtcbiAgdGhpcy53b3JkKFwic3dpdGNoXCIpO1xuICB0aGlzLnNwYWNlKCk7XG4gIHRoaXMudG9rZW5DaGFyKDQwKTtcbiAgdGhpcy5wcmludChub2RlLmRpc2NyaW1pbmFudCk7XG4gIHRoaXMudG9rZW5DaGFyKDQxKTtcbiAgdGhpcy5zcGFjZSgpO1xuICB0aGlzLnRva2VuQ2hhcigxMjMpO1xuICB0aGlzLnByaW50U2VxdWVuY2Uobm9kZS5jYXNlcywgdHJ1ZSk7XG4gIHRoaXMucmlnaHRCcmFjZShub2RlKTtcbn1cbmZ1bmN0aW9uIFN3aXRjaENhc2Uobm9kZSkge1xuICBpZiAobm9kZS50ZXN0KSB7XG4gICAgdGhpcy53b3JkKFwiY2FzZVwiKTtcbiAgICB0aGlzLnNwYWNlKCk7XG4gICAgdGhpcy5wcmludChub2RlLnRlc3QpO1xuICAgIHRoaXMudG9rZW5DaGFyKDU4KTtcbiAgfSBlbHNlIHtcbiAgICB0aGlzLndvcmQoXCJkZWZhdWx0XCIpO1xuICAgIHRoaXMudG9rZW5DaGFyKDU4KTtcbiAgfVxuICBpZiAobm9kZS5jb25zZXF1ZW50Lmxlbmd0aCkge1xuICAgIHRoaXMubmV3bGluZSgpO1xuICAgIHRoaXMucHJpbnRTZXF1ZW5jZShub2RlLmNvbnNlcXVlbnQsIHRydWUpO1xuICB9XG59XG5mdW5jdGlvbiBEZWJ1Z2dlclN0YXRlbWVudCgpIHtcbiAgdGhpcy53b3JkKFwiZGVidWdnZXJcIik7XG4gIHRoaXMuc2VtaWNvbG9uKCk7XG59XG5mdW5jdGlvbiBWYXJpYWJsZURlY2xhcmF0aW9uKG5vZGUsIHBhcmVudCkge1xuICBpZiAobm9kZS5kZWNsYXJlKSB7XG4gICAgdGhpcy53b3JkKFwiZGVjbGFyZVwiKTtcbiAgICB0aGlzLnNwYWNlKCk7XG4gIH1cbiAgY29uc3Qge1xuICAgIGtpbmRcbiAgfSA9IG5vZGU7XG4gIGlmIChraW5kID09PSBcImF3YWl0IHVzaW5nXCIpIHtcbiAgICB0aGlzLndvcmQoXCJhd2FpdFwiKTtcbiAgICB0aGlzLnNwYWNlKCk7XG4gICAgdGhpcy53b3JkKFwidXNpbmdcIiwgdHJ1ZSk7XG4gIH0gZWxzZSB7XG4gICAgdGhpcy53b3JkKGtpbmQsIGtpbmQgPT09IFwidXNpbmdcIik7XG4gIH1cbiAgdGhpcy5zcGFjZSgpO1xuICBsZXQgaGFzSW5pdHMgPSBmYWxzZTtcbiAgaWYgKCFpc0ZvcihwYXJlbnQpKSB7XG4gICAgZm9yIChjb25zdCBkZWNsYXIgb2Ygbm9kZS5kZWNsYXJhdGlvbnMpIHtcbiAgICAgIGlmIChkZWNsYXIuaW5pdCkge1xuICAgICAgICBoYXNJbml0cyA9IHRydWU7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHRoaXMucHJpbnRMaXN0KG5vZGUuZGVjbGFyYXRpb25zLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgbm9kZS5kZWNsYXJhdGlvbnMubGVuZ3RoID4gMSwgaGFzSW5pdHMgPyBmdW5jdGlvbiAob2NjdXJyZW5jZUNvdW50KSB7XG4gICAgdGhpcy50b2tlbihcIixcIiwgZmFsc2UsIG9jY3VycmVuY2VDb3VudCk7XG4gICAgdGhpcy5uZXdsaW5lKCk7XG4gIH0gOiB1bmRlZmluZWQpO1xuICBpZiAoaXNGb3IocGFyZW50KSkge1xuICAgIGlmIChpc0ZvclN0YXRlbWVudChwYXJlbnQpKSB7XG4gICAgICBpZiAocGFyZW50LmluaXQgPT09IG5vZGUpIHJldHVybjtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKHBhcmVudC5sZWZ0ID09PSBub2RlKSByZXR1cm47XG4gICAgfVxuICB9XG4gIHRoaXMuc2VtaWNvbG9uKCk7XG59XG5mdW5jdGlvbiBWYXJpYWJsZURlY2xhcmF0b3Iobm9kZSkge1xuICB0aGlzLnByaW50KG5vZGUuaWQpO1xuICBpZiAobm9kZS5kZWZpbml0ZSkgdGhpcy50b2tlbkNoYXIoMzMpO1xuICB0aGlzLnByaW50KG5vZGUuaWQudHlwZUFubm90YXRpb24pO1xuICBpZiAobm9kZS5pbml0KSB7XG4gICAgdGhpcy5zcGFjZSgpO1xuICAgIHRoaXMudG9rZW5DaGFyKDYxKTtcbiAgICB0aGlzLnNwYWNlKCk7XG4gICAgdGhpcy5wcmludChub2RlLmluaXQpO1xuICB9XG59XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXN0YXRlbWVudHMuanMubWFwXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@babel/generator/lib/generators/statements.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@babel/generator/lib/generators/template-literals.js":
/*!***************************************************************************!*\
  !*** ./node_modules/@babel/generator/lib/generators/template-literals.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports.TaggedTemplateExpression = TaggedTemplateExpression;\nexports.TemplateElement = TemplateElement;\nexports.TemplateLiteral = TemplateLiteral;\nexports._printTemplate = _printTemplate;\nfunction TaggedTemplateExpression(node) {\n  this.print(node.tag);\n  this.print(node.typeParameters);\n  this.print(node.quasi);\n}\nfunction TemplateElement() {\n  throw new Error(\"TemplateElement printing is handled in TemplateLiteral\");\n}\nfunction _printTemplate(node, substitutions) {\n  const quasis = node.quasis;\n  let partRaw = \"`\";\n  for (let i = 0; i < quasis.length - 1; i++) {\n    partRaw += quasis[i].value.raw;\n    this.token(partRaw + \"${\", true);\n    this.print(substitutions[i]);\n    partRaw = \"}\";\n    if (this.tokenMap) {\n      const token = this.tokenMap.findMatching(node, \"}\", i);\n      if (token) this._catchUpTo(token.loc.start);\n    }\n  }\n  partRaw += quasis[quasis.length - 1].value.raw;\n  this.token(partRaw + \"`\", true);\n}\nfunction TemplateLiteral(node) {\n  this._printTemplate(node, node.expressions);\n}\n\n//# sourceMappingURL=template-literals.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGJhYmVsL2dlbmVyYXRvci9saWIvZ2VuZXJhdG9ycy90ZW1wbGF0ZS1saXRlcmFscy5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYiw4Q0FBNkM7QUFDN0M7QUFDQSxDQUFDLEVBQUM7QUFDRixnQ0FBZ0M7QUFDaEMsdUJBQXVCO0FBQ3ZCLHVCQUF1QjtBQUN2QixzQkFBc0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQix1QkFBdUI7QUFDekM7QUFDQSw0QkFBNEI7QUFDNUI7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQSx1REFBdUQ7QUFDdkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcmVwby12aXN1YWxpemVyLy4vbm9kZV9tb2R1bGVzL0BiYWJlbC9nZW5lcmF0b3IvbGliL2dlbmVyYXRvcnMvdGVtcGxhdGUtbGl0ZXJhbHMuanM/ZGViZCJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuVGFnZ2VkVGVtcGxhdGVFeHByZXNzaW9uID0gVGFnZ2VkVGVtcGxhdGVFeHByZXNzaW9uO1xuZXhwb3J0cy5UZW1wbGF0ZUVsZW1lbnQgPSBUZW1wbGF0ZUVsZW1lbnQ7XG5leHBvcnRzLlRlbXBsYXRlTGl0ZXJhbCA9IFRlbXBsYXRlTGl0ZXJhbDtcbmV4cG9ydHMuX3ByaW50VGVtcGxhdGUgPSBfcHJpbnRUZW1wbGF0ZTtcbmZ1bmN0aW9uIFRhZ2dlZFRlbXBsYXRlRXhwcmVzc2lvbihub2RlKSB7XG4gIHRoaXMucHJpbnQobm9kZS50YWcpO1xuICB0aGlzLnByaW50KG5vZGUudHlwZVBhcmFtZXRlcnMpO1xuICB0aGlzLnByaW50KG5vZGUucXVhc2kpO1xufVxuZnVuY3Rpb24gVGVtcGxhdGVFbGVtZW50KCkge1xuICB0aHJvdyBuZXcgRXJyb3IoXCJUZW1wbGF0ZUVsZW1lbnQgcHJpbnRpbmcgaXMgaGFuZGxlZCBpbiBUZW1wbGF0ZUxpdGVyYWxcIik7XG59XG5mdW5jdGlvbiBfcHJpbnRUZW1wbGF0ZShub2RlLCBzdWJzdGl0dXRpb25zKSB7XG4gIGNvbnN0IHF1YXNpcyA9IG5vZGUucXVhc2lzO1xuICBsZXQgcGFydFJhdyA9IFwiYFwiO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IHF1YXNpcy5sZW5ndGggLSAxOyBpKyspIHtcbiAgICBwYXJ0UmF3ICs9IHF1YXNpc1tpXS52YWx1ZS5yYXc7XG4gICAgdGhpcy50b2tlbihwYXJ0UmF3ICsgXCIke1wiLCB0cnVlKTtcbiAgICB0aGlzLnByaW50KHN1YnN0aXR1dGlvbnNbaV0pO1xuICAgIHBhcnRSYXcgPSBcIn1cIjtcbiAgICBpZiAodGhpcy50b2tlbk1hcCkge1xuICAgICAgY29uc3QgdG9rZW4gPSB0aGlzLnRva2VuTWFwLmZpbmRNYXRjaGluZyhub2RlLCBcIn1cIiwgaSk7XG4gICAgICBpZiAodG9rZW4pIHRoaXMuX2NhdGNoVXBUbyh0b2tlbi5sb2Muc3RhcnQpO1xuICAgIH1cbiAgfVxuICBwYXJ0UmF3ICs9IHF1YXNpc1txdWFzaXMubGVuZ3RoIC0gMV0udmFsdWUucmF3O1xuICB0aGlzLnRva2VuKHBhcnRSYXcgKyBcImBcIiwgdHJ1ZSk7XG59XG5mdW5jdGlvbiBUZW1wbGF0ZUxpdGVyYWwobm9kZSkge1xuICB0aGlzLl9wcmludFRlbXBsYXRlKG5vZGUsIG5vZGUuZXhwcmVzc2lvbnMpO1xufVxuXG4vLyMgc291cmNlTWFwcGluZ1VSTD10ZW1wbGF0ZS1saXRlcmFscy5qcy5tYXBcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@babel/generator/lib/generators/template-literals.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@babel/generator/lib/generators/types.js":
/*!***************************************************************!*\
  !*** ./node_modules/@babel/generator/lib/generators/types.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports.ArgumentPlaceholder = ArgumentPlaceholder;\nexports.ArrayPattern = exports.ArrayExpression = ArrayExpression;\nexports.BigIntLiteral = BigIntLiteral;\nexports.BooleanLiteral = BooleanLiteral;\nexports.Identifier = Identifier;\nexports.NullLiteral = NullLiteral;\nexports.NumericLiteral = NumericLiteral;\nexports.ObjectPattern = exports.ObjectExpression = ObjectExpression;\nexports.ObjectMethod = ObjectMethod;\nexports.ObjectProperty = ObjectProperty;\nexports.PipelineBareFunction = PipelineBareFunction;\nexports.PipelinePrimaryTopicReference = PipelinePrimaryTopicReference;\nexports.PipelineTopicExpression = PipelineTopicExpression;\nexports.RegExpLiteral = RegExpLiteral;\nexports.SpreadElement = exports.RestElement = RestElement;\nexports.StringLiteral = StringLiteral;\nexports.TopicReference = TopicReference;\nexports.VoidPattern = VoidPattern;\nexports._getRawIdentifier = _getRawIdentifier;\nvar _t = __webpack_require__(/*! @babel/types */ \"(ssr)/./node_modules/@babel/types/lib/index.js\");\nvar _jsesc = __webpack_require__(/*! jsesc */ \"(ssr)/./node_modules/jsesc/jsesc.js\");\nconst {\n  isAssignmentPattern,\n  isIdentifier\n} = _t;\nlet lastRawIdentNode = null;\nlet lastRawIdentResult = \"\";\nfunction _getRawIdentifier(node) {\n  if (node === lastRawIdentNode) return lastRawIdentResult;\n  lastRawIdentNode = node;\n  const {\n    name\n  } = node;\n  const token = this.tokenMap.find(node, tok => tok.value === name);\n  if (token) {\n    lastRawIdentResult = this._originalCode.slice(token.start, token.end);\n    return lastRawIdentResult;\n  }\n  return lastRawIdentResult = node.name;\n}\nfunction Identifier(node) {\n  var _node$loc;\n  this.sourceIdentifierName(((_node$loc = node.loc) == null ? void 0 : _node$loc.identifierName) || node.name);\n  this.word(this.tokenMap ? this._getRawIdentifier(node) : node.name);\n}\nfunction ArgumentPlaceholder() {\n  this.tokenChar(63);\n}\nfunction RestElement(node) {\n  this.token(\"...\");\n  this.print(node.argument);\n}\nfunction ObjectExpression(node) {\n  const props = node.properties;\n  this.tokenChar(123);\n  if (props.length) {\n    const exit = this.enterDelimited();\n    this.space();\n    this.printList(props, this.shouldPrintTrailingComma(\"}\"), true, true);\n    this.space();\n    exit();\n  }\n  this.sourceWithOffset(\"end\", node.loc, -1);\n  this.tokenChar(125);\n}\nfunction ObjectMethod(node) {\n  this.printJoin(node.decorators);\n  this._methodHead(node);\n  this.space();\n  this.print(node.body);\n}\nfunction ObjectProperty(node) {\n  this.printJoin(node.decorators);\n  if (node.computed) {\n    this.tokenChar(91);\n    this.print(node.key);\n    this.tokenChar(93);\n  } else {\n    if (isAssignmentPattern(node.value) && isIdentifier(node.key) && node.key.name === node.value.left.name) {\n      this.print(node.value);\n      return;\n    }\n    this.print(node.key);\n    if (node.shorthand && isIdentifier(node.key) && isIdentifier(node.value) && node.key.name === node.value.name) {\n      return;\n    }\n  }\n  this.tokenChar(58);\n  this.space();\n  this.print(node.value);\n}\nfunction ArrayExpression(node) {\n  const elems = node.elements;\n  const len = elems.length;\n  this.tokenChar(91);\n  const exit = this.enterDelimited();\n  for (let i = 0; i < elems.length; i++) {\n    const elem = elems[i];\n    if (elem) {\n      if (i > 0) this.space();\n      this.print(elem);\n      if (i < len - 1 || this.shouldPrintTrailingComma(\"]\")) {\n        this.token(\",\", false, i);\n      }\n    } else {\n      this.token(\",\", false, i);\n    }\n  }\n  exit();\n  this.tokenChar(93);\n}\nfunction RegExpLiteral(node) {\n  this.word(`/${node.pattern}/${node.flags}`);\n}\nfunction BooleanLiteral(node) {\n  this.word(node.value ? \"true\" : \"false\");\n}\nfunction NullLiteral() {\n  this.word(\"null\");\n}\nfunction NumericLiteral(node) {\n  const raw = this.getPossibleRaw(node);\n  const opts = this.format.jsescOption;\n  const value = node.value;\n  const str = value + \"\";\n  if (opts.numbers) {\n    this.number(_jsesc(value, opts), value);\n  } else if (raw == null) {\n    this.number(str, value);\n  } else if (this.format.minified) {\n    this.number(raw.length < str.length ? raw : str, value);\n  } else {\n    this.number(raw, value);\n  }\n}\nfunction StringLiteral(node) {\n  const raw = this.getPossibleRaw(node);\n  if (!this.format.minified && raw !== undefined) {\n    this.token(raw);\n    return;\n  }\n  const val = _jsesc(node.value, this.format.jsescOption);\n  this.token(val);\n}\nfunction BigIntLiteral(node) {\n  const raw = this.getPossibleRaw(node);\n  if (!this.format.minified && raw !== undefined) {\n    this.word(raw);\n    return;\n  }\n  this.word(node.value + \"n\");\n}\nconst validTopicTokenSet = new Set([\"^^\", \"@@\", \"^\", \"%\", \"#\"]);\nfunction TopicReference() {\n  const {\n    topicToken\n  } = this.format;\n  if (validTopicTokenSet.has(topicToken)) {\n    this.token(topicToken);\n  } else {\n    const givenTopicTokenJSON = JSON.stringify(topicToken);\n    const validTopics = Array.from(validTopicTokenSet, v => JSON.stringify(v));\n    throw new Error(`The \"topicToken\" generator option must be one of ` + `${validTopics.join(\", \")} (${givenTopicTokenJSON} received instead).`);\n  }\n}\nfunction PipelineTopicExpression(node) {\n  this.print(node.expression);\n}\nfunction PipelineBareFunction(node) {\n  this.print(node.callee);\n}\nfunction PipelinePrimaryTopicReference() {\n  this.tokenChar(35);\n}\nfunction VoidPattern() {\n  this.word(\"void\");\n}\n\n//# sourceMappingURL=types.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGJhYmVsL2dlbmVyYXRvci9saWIvZ2VuZXJhdG9ycy90eXBlcy5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYiw4Q0FBNkM7QUFDN0M7QUFDQSxDQUFDLEVBQUM7QUFDRiwyQkFBMkI7QUFDM0Isb0JBQW9CLEdBQUcsdUJBQXVCO0FBQzlDLHFCQUFxQjtBQUNyQixzQkFBc0I7QUFDdEIsa0JBQWtCO0FBQ2xCLG1CQUFtQjtBQUNuQixzQkFBc0I7QUFDdEIscUJBQXFCLEdBQUcsd0JBQXdCO0FBQ2hELG9CQUFvQjtBQUNwQixzQkFBc0I7QUFDdEIsNEJBQTRCO0FBQzVCLHFDQUFxQztBQUNyQywrQkFBK0I7QUFDL0IscUJBQXFCO0FBQ3JCLHFCQUFxQixHQUFHLG1CQUFtQjtBQUMzQyxxQkFBcUI7QUFDckIsc0JBQXNCO0FBQ3RCLG1CQUFtQjtBQUNuQix5QkFBeUI7QUFDekIsU0FBUyxtQkFBTyxDQUFDLG9FQUFjO0FBQy9CLGFBQWEsbUJBQU8sQ0FBQyxrREFBTztBQUM1QjtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwREFBMEQ7QUFDMUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixrQkFBa0I7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsYUFBYSxHQUFHLFdBQVc7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBLElBQUk7QUFDSjtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0EsNkVBQTZFLHdCQUF3QixHQUFHLHFCQUFxQjtBQUM3SDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcmVwby12aXN1YWxpemVyLy4vbm9kZV9tb2R1bGVzL0BiYWJlbC9nZW5lcmF0b3IvbGliL2dlbmVyYXRvcnMvdHlwZXMuanM/MWEwMSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuQXJndW1lbnRQbGFjZWhvbGRlciA9IEFyZ3VtZW50UGxhY2Vob2xkZXI7XG5leHBvcnRzLkFycmF5UGF0dGVybiA9IGV4cG9ydHMuQXJyYXlFeHByZXNzaW9uID0gQXJyYXlFeHByZXNzaW9uO1xuZXhwb3J0cy5CaWdJbnRMaXRlcmFsID0gQmlnSW50TGl0ZXJhbDtcbmV4cG9ydHMuQm9vbGVhbkxpdGVyYWwgPSBCb29sZWFuTGl0ZXJhbDtcbmV4cG9ydHMuSWRlbnRpZmllciA9IElkZW50aWZpZXI7XG5leHBvcnRzLk51bGxMaXRlcmFsID0gTnVsbExpdGVyYWw7XG5leHBvcnRzLk51bWVyaWNMaXRlcmFsID0gTnVtZXJpY0xpdGVyYWw7XG5leHBvcnRzLk9iamVjdFBhdHRlcm4gPSBleHBvcnRzLk9iamVjdEV4cHJlc3Npb24gPSBPYmplY3RFeHByZXNzaW9uO1xuZXhwb3J0cy5PYmplY3RNZXRob2QgPSBPYmplY3RNZXRob2Q7XG5leHBvcnRzLk9iamVjdFByb3BlcnR5ID0gT2JqZWN0UHJvcGVydHk7XG5leHBvcnRzLlBpcGVsaW5lQmFyZUZ1bmN0aW9uID0gUGlwZWxpbmVCYXJlRnVuY3Rpb247XG5leHBvcnRzLlBpcGVsaW5lUHJpbWFyeVRvcGljUmVmZXJlbmNlID0gUGlwZWxpbmVQcmltYXJ5VG9waWNSZWZlcmVuY2U7XG5leHBvcnRzLlBpcGVsaW5lVG9waWNFeHByZXNzaW9uID0gUGlwZWxpbmVUb3BpY0V4cHJlc3Npb247XG5leHBvcnRzLlJlZ0V4cExpdGVyYWwgPSBSZWdFeHBMaXRlcmFsO1xuZXhwb3J0cy5TcHJlYWRFbGVtZW50ID0gZXhwb3J0cy5SZXN0RWxlbWVudCA9IFJlc3RFbGVtZW50O1xuZXhwb3J0cy5TdHJpbmdMaXRlcmFsID0gU3RyaW5nTGl0ZXJhbDtcbmV4cG9ydHMuVG9waWNSZWZlcmVuY2UgPSBUb3BpY1JlZmVyZW5jZTtcbmV4cG9ydHMuVm9pZFBhdHRlcm4gPSBWb2lkUGF0dGVybjtcbmV4cG9ydHMuX2dldFJhd0lkZW50aWZpZXIgPSBfZ2V0UmF3SWRlbnRpZmllcjtcbnZhciBfdCA9IHJlcXVpcmUoXCJAYmFiZWwvdHlwZXNcIik7XG52YXIgX2pzZXNjID0gcmVxdWlyZShcImpzZXNjXCIpO1xuY29uc3Qge1xuICBpc0Fzc2lnbm1lbnRQYXR0ZXJuLFxuICBpc0lkZW50aWZpZXJcbn0gPSBfdDtcbmxldCBsYXN0UmF3SWRlbnROb2RlID0gbnVsbDtcbmxldCBsYXN0UmF3SWRlbnRSZXN1bHQgPSBcIlwiO1xuZnVuY3Rpb24gX2dldFJhd0lkZW50aWZpZXIobm9kZSkge1xuICBpZiAobm9kZSA9PT0gbGFzdFJhd0lkZW50Tm9kZSkgcmV0dXJuIGxhc3RSYXdJZGVudFJlc3VsdDtcbiAgbGFzdFJhd0lkZW50Tm9kZSA9IG5vZGU7XG4gIGNvbnN0IHtcbiAgICBuYW1lXG4gIH0gPSBub2RlO1xuICBjb25zdCB0b2tlbiA9IHRoaXMudG9rZW5NYXAuZmluZChub2RlLCB0b2sgPT4gdG9rLnZhbHVlID09PSBuYW1lKTtcbiAgaWYgKHRva2VuKSB7XG4gICAgbGFzdFJhd0lkZW50UmVzdWx0ID0gdGhpcy5fb3JpZ2luYWxDb2RlLnNsaWNlKHRva2VuLnN0YXJ0LCB0b2tlbi5lbmQpO1xuICAgIHJldHVybiBsYXN0UmF3SWRlbnRSZXN1bHQ7XG4gIH1cbiAgcmV0dXJuIGxhc3RSYXdJZGVudFJlc3VsdCA9IG5vZGUubmFtZTtcbn1cbmZ1bmN0aW9uIElkZW50aWZpZXIobm9kZSkge1xuICB2YXIgX25vZGUkbG9jO1xuICB0aGlzLnNvdXJjZUlkZW50aWZpZXJOYW1lKCgoX25vZGUkbG9jID0gbm9kZS5sb2MpID09IG51bGwgPyB2b2lkIDAgOiBfbm9kZSRsb2MuaWRlbnRpZmllck5hbWUpIHx8IG5vZGUubmFtZSk7XG4gIHRoaXMud29yZCh0aGlzLnRva2VuTWFwID8gdGhpcy5fZ2V0UmF3SWRlbnRpZmllcihub2RlKSA6IG5vZGUubmFtZSk7XG59XG5mdW5jdGlvbiBBcmd1bWVudFBsYWNlaG9sZGVyKCkge1xuICB0aGlzLnRva2VuQ2hhcig2Myk7XG59XG5mdW5jdGlvbiBSZXN0RWxlbWVudChub2RlKSB7XG4gIHRoaXMudG9rZW4oXCIuLi5cIik7XG4gIHRoaXMucHJpbnQobm9kZS5hcmd1bWVudCk7XG59XG5mdW5jdGlvbiBPYmplY3RFeHByZXNzaW9uKG5vZGUpIHtcbiAgY29uc3QgcHJvcHMgPSBub2RlLnByb3BlcnRpZXM7XG4gIHRoaXMudG9rZW5DaGFyKDEyMyk7XG4gIGlmIChwcm9wcy5sZW5ndGgpIHtcbiAgICBjb25zdCBleGl0ID0gdGhpcy5lbnRlckRlbGltaXRlZCgpO1xuICAgIHRoaXMuc3BhY2UoKTtcbiAgICB0aGlzLnByaW50TGlzdChwcm9wcywgdGhpcy5zaG91bGRQcmludFRyYWlsaW5nQ29tbWEoXCJ9XCIpLCB0cnVlLCB0cnVlKTtcbiAgICB0aGlzLnNwYWNlKCk7XG4gICAgZXhpdCgpO1xuICB9XG4gIHRoaXMuc291cmNlV2l0aE9mZnNldChcImVuZFwiLCBub2RlLmxvYywgLTEpO1xuICB0aGlzLnRva2VuQ2hhcigxMjUpO1xufVxuZnVuY3Rpb24gT2JqZWN0TWV0aG9kKG5vZGUpIHtcbiAgdGhpcy5wcmludEpvaW4obm9kZS5kZWNvcmF0b3JzKTtcbiAgdGhpcy5fbWV0aG9kSGVhZChub2RlKTtcbiAgdGhpcy5zcGFjZSgpO1xuICB0aGlzLnByaW50KG5vZGUuYm9keSk7XG59XG5mdW5jdGlvbiBPYmplY3RQcm9wZXJ0eShub2RlKSB7XG4gIHRoaXMucHJpbnRKb2luKG5vZGUuZGVjb3JhdG9ycyk7XG4gIGlmIChub2RlLmNvbXB1dGVkKSB7XG4gICAgdGhpcy50b2tlbkNoYXIoOTEpO1xuICAgIHRoaXMucHJpbnQobm9kZS5rZXkpO1xuICAgIHRoaXMudG9rZW5DaGFyKDkzKTtcbiAgfSBlbHNlIHtcbiAgICBpZiAoaXNBc3NpZ25tZW50UGF0dGVybihub2RlLnZhbHVlKSAmJiBpc0lkZW50aWZpZXIobm9kZS5rZXkpICYmIG5vZGUua2V5Lm5hbWUgPT09IG5vZGUudmFsdWUubGVmdC5uYW1lKSB7XG4gICAgICB0aGlzLnByaW50KG5vZGUudmFsdWUpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLnByaW50KG5vZGUua2V5KTtcbiAgICBpZiAobm9kZS5zaG9ydGhhbmQgJiYgaXNJZGVudGlmaWVyKG5vZGUua2V5KSAmJiBpc0lkZW50aWZpZXIobm9kZS52YWx1ZSkgJiYgbm9kZS5rZXkubmFtZSA9PT0gbm9kZS52YWx1ZS5uYW1lKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICB9XG4gIHRoaXMudG9rZW5DaGFyKDU4KTtcbiAgdGhpcy5zcGFjZSgpO1xuICB0aGlzLnByaW50KG5vZGUudmFsdWUpO1xufVxuZnVuY3Rpb24gQXJyYXlFeHByZXNzaW9uKG5vZGUpIHtcbiAgY29uc3QgZWxlbXMgPSBub2RlLmVsZW1lbnRzO1xuICBjb25zdCBsZW4gPSBlbGVtcy5sZW5ndGg7XG4gIHRoaXMudG9rZW5DaGFyKDkxKTtcbiAgY29uc3QgZXhpdCA9IHRoaXMuZW50ZXJEZWxpbWl0ZWQoKTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBlbGVtcy5sZW5ndGg7IGkrKykge1xuICAgIGNvbnN0IGVsZW0gPSBlbGVtc1tpXTtcbiAgICBpZiAoZWxlbSkge1xuICAgICAgaWYgKGkgPiAwKSB0aGlzLnNwYWNlKCk7XG4gICAgICB0aGlzLnByaW50KGVsZW0pO1xuICAgICAgaWYgKGkgPCBsZW4gLSAxIHx8IHRoaXMuc2hvdWxkUHJpbnRUcmFpbGluZ0NvbW1hKFwiXVwiKSkge1xuICAgICAgICB0aGlzLnRva2VuKFwiLFwiLCBmYWxzZSwgaSk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMudG9rZW4oXCIsXCIsIGZhbHNlLCBpKTtcbiAgICB9XG4gIH1cbiAgZXhpdCgpO1xuICB0aGlzLnRva2VuQ2hhcig5Myk7XG59XG5mdW5jdGlvbiBSZWdFeHBMaXRlcmFsKG5vZGUpIHtcbiAgdGhpcy53b3JkKGAvJHtub2RlLnBhdHRlcm59LyR7bm9kZS5mbGFnc31gKTtcbn1cbmZ1bmN0aW9uIEJvb2xlYW5MaXRlcmFsKG5vZGUpIHtcbiAgdGhpcy53b3JkKG5vZGUudmFsdWUgPyBcInRydWVcIiA6IFwiZmFsc2VcIik7XG59XG5mdW5jdGlvbiBOdWxsTGl0ZXJhbCgpIHtcbiAgdGhpcy53b3JkKFwibnVsbFwiKTtcbn1cbmZ1bmN0aW9uIE51bWVyaWNMaXRlcmFsKG5vZGUpIHtcbiAgY29uc3QgcmF3ID0gdGhpcy5nZXRQb3NzaWJsZVJhdyhub2RlKTtcbiAgY29uc3Qgb3B0cyA9IHRoaXMuZm9ybWF0LmpzZXNjT3B0aW9uO1xuICBjb25zdCB2YWx1ZSA9IG5vZGUudmFsdWU7XG4gIGNvbnN0IHN0ciA9IHZhbHVlICsgXCJcIjtcbiAgaWYgKG9wdHMubnVtYmVycykge1xuICAgIHRoaXMubnVtYmVyKF9qc2VzYyh2YWx1ZSwgb3B0cyksIHZhbHVlKTtcbiAgfSBlbHNlIGlmIChyYXcgPT0gbnVsbCkge1xuICAgIHRoaXMubnVtYmVyKHN0ciwgdmFsdWUpO1xuICB9IGVsc2UgaWYgKHRoaXMuZm9ybWF0Lm1pbmlmaWVkKSB7XG4gICAgdGhpcy5udW1iZXIocmF3Lmxlbmd0aCA8IHN0ci5sZW5ndGggPyByYXcgOiBzdHIsIHZhbHVlKTtcbiAgfSBlbHNlIHtcbiAgICB0aGlzLm51bWJlcihyYXcsIHZhbHVlKTtcbiAgfVxufVxuZnVuY3Rpb24gU3RyaW5nTGl0ZXJhbChub2RlKSB7XG4gIGNvbnN0IHJhdyA9IHRoaXMuZ2V0UG9zc2libGVSYXcobm9kZSk7XG4gIGlmICghdGhpcy5mb3JtYXQubWluaWZpZWQgJiYgcmF3ICE9PSB1bmRlZmluZWQpIHtcbiAgICB0aGlzLnRva2VuKHJhdyk7XG4gICAgcmV0dXJuO1xuICB9XG4gIGNvbnN0IHZhbCA9IF9qc2VzYyhub2RlLnZhbHVlLCB0aGlzLmZvcm1hdC5qc2VzY09wdGlvbik7XG4gIHRoaXMudG9rZW4odmFsKTtcbn1cbmZ1bmN0aW9uIEJpZ0ludExpdGVyYWwobm9kZSkge1xuICBjb25zdCByYXcgPSB0aGlzLmdldFBvc3NpYmxlUmF3KG5vZGUpO1xuICBpZiAoIXRoaXMuZm9ybWF0Lm1pbmlmaWVkICYmIHJhdyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgdGhpcy53b3JkKHJhdyk7XG4gICAgcmV0dXJuO1xuICB9XG4gIHRoaXMud29yZChub2RlLnZhbHVlICsgXCJuXCIpO1xufVxuY29uc3QgdmFsaWRUb3BpY1Rva2VuU2V0ID0gbmV3IFNldChbXCJeXlwiLCBcIkBAXCIsIFwiXlwiLCBcIiVcIiwgXCIjXCJdKTtcbmZ1bmN0aW9uIFRvcGljUmVmZXJlbmNlKCkge1xuICBjb25zdCB7XG4gICAgdG9waWNUb2tlblxuICB9ID0gdGhpcy5mb3JtYXQ7XG4gIGlmICh2YWxpZFRvcGljVG9rZW5TZXQuaGFzKHRvcGljVG9rZW4pKSB7XG4gICAgdGhpcy50b2tlbih0b3BpY1Rva2VuKTtcbiAgfSBlbHNlIHtcbiAgICBjb25zdCBnaXZlblRvcGljVG9rZW5KU09OID0gSlNPTi5zdHJpbmdpZnkodG9waWNUb2tlbik7XG4gICAgY29uc3QgdmFsaWRUb3BpY3MgPSBBcnJheS5mcm9tKHZhbGlkVG9waWNUb2tlblNldCwgdiA9PiBKU09OLnN0cmluZ2lmeSh2KSk7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBUaGUgXCJ0b3BpY1Rva2VuXCIgZ2VuZXJhdG9yIG9wdGlvbiBtdXN0IGJlIG9uZSBvZiBgICsgYCR7dmFsaWRUb3BpY3Muam9pbihcIiwgXCIpfSAoJHtnaXZlblRvcGljVG9rZW5KU09OfSByZWNlaXZlZCBpbnN0ZWFkKS5gKTtcbiAgfVxufVxuZnVuY3Rpb24gUGlwZWxpbmVUb3BpY0V4cHJlc3Npb24obm9kZSkge1xuICB0aGlzLnByaW50KG5vZGUuZXhwcmVzc2lvbik7XG59XG5mdW5jdGlvbiBQaXBlbGluZUJhcmVGdW5jdGlvbihub2RlKSB7XG4gIHRoaXMucHJpbnQobm9kZS5jYWxsZWUpO1xufVxuZnVuY3Rpb24gUGlwZWxpbmVQcmltYXJ5VG9waWNSZWZlcmVuY2UoKSB7XG4gIHRoaXMudG9rZW5DaGFyKDM1KTtcbn1cbmZ1bmN0aW9uIFZvaWRQYXR0ZXJuKCkge1xuICB0aGlzLndvcmQoXCJ2b2lkXCIpO1xufVxuXG4vLyMgc291cmNlTWFwcGluZ1VSTD10eXBlcy5qcy5tYXBcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@babel/generator/lib/generators/types.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@babel/generator/lib/generators/typescript.js":
/*!********************************************************************!*\
  !*** ./node_modules/@babel/generator/lib/generators/typescript.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports.TSAnyKeyword = TSAnyKeyword;\nexports.TSArrayType = TSArrayType;\nexports.TSSatisfiesExpression = exports.TSAsExpression = TSTypeExpression;\nexports.TSBigIntKeyword = TSBigIntKeyword;\nexports.TSBooleanKeyword = TSBooleanKeyword;\nexports.TSCallSignatureDeclaration = TSCallSignatureDeclaration;\nexports.TSInterfaceHeritage = exports.TSClassImplements = TSClassImplements;\nexports.TSConditionalType = TSConditionalType;\nexports.TSConstructSignatureDeclaration = TSConstructSignatureDeclaration;\nexports.TSConstructorType = TSConstructorType;\nexports.TSDeclareFunction = TSDeclareFunction;\nexports.TSDeclareMethod = TSDeclareMethod;\nexports.TSEnumBody = TSEnumBody;\nexports.TSEnumDeclaration = TSEnumDeclaration;\nexports.TSEnumMember = TSEnumMember;\nexports.TSExportAssignment = TSExportAssignment;\nexports.TSExternalModuleReference = TSExternalModuleReference;\nexports.TSFunctionType = TSFunctionType;\nexports.TSImportEqualsDeclaration = TSImportEqualsDeclaration;\nexports.TSImportType = TSImportType;\nexports.TSIndexSignature = TSIndexSignature;\nexports.TSIndexedAccessType = TSIndexedAccessType;\nexports.TSInferType = TSInferType;\nexports.TSInstantiationExpression = TSInstantiationExpression;\nexports.TSInterfaceBody = TSInterfaceBody;\nexports.TSInterfaceDeclaration = TSInterfaceDeclaration;\nexports.TSIntersectionType = TSIntersectionType;\nexports.TSIntrinsicKeyword = TSIntrinsicKeyword;\nexports.TSLiteralType = TSLiteralType;\nexports.TSMappedType = TSMappedType;\nexports.TSMethodSignature = TSMethodSignature;\nexports.TSModuleBlock = TSModuleBlock;\nexports.TSModuleDeclaration = TSModuleDeclaration;\nexports.TSNamedTupleMember = TSNamedTupleMember;\nexports.TSNamespaceExportDeclaration = TSNamespaceExportDeclaration;\nexports.TSNeverKeyword = TSNeverKeyword;\nexports.TSNonNullExpression = TSNonNullExpression;\nexports.TSNullKeyword = TSNullKeyword;\nexports.TSNumberKeyword = TSNumberKeyword;\nexports.TSObjectKeyword = TSObjectKeyword;\nexports.TSOptionalType = TSOptionalType;\nexports.TSParameterProperty = TSParameterProperty;\nexports.TSParenthesizedType = TSParenthesizedType;\nexports.TSPropertySignature = TSPropertySignature;\nexports.TSQualifiedName = TSQualifiedName;\nexports.TSRestType = TSRestType;\nexports.TSStringKeyword = TSStringKeyword;\nexports.TSSymbolKeyword = TSSymbolKeyword;\nexports.TSTemplateLiteralType = TSTemplateLiteralType;\nexports.TSThisType = TSThisType;\nexports.TSTupleType = TSTupleType;\nexports.TSTypeAliasDeclaration = TSTypeAliasDeclaration;\nexports.TSTypeAnnotation = TSTypeAnnotation;\nexports.TSTypeAssertion = TSTypeAssertion;\nexports.TSTypeLiteral = TSTypeLiteral;\nexports.TSTypeOperator = TSTypeOperator;\nexports.TSTypeParameter = TSTypeParameter;\nexports.TSTypeParameterDeclaration = exports.TSTypeParameterInstantiation = TSTypeParameterInstantiation;\nexports.TSTypePredicate = TSTypePredicate;\nexports.TSTypeQuery = TSTypeQuery;\nexports.TSTypeReference = TSTypeReference;\nexports.TSUndefinedKeyword = TSUndefinedKeyword;\nexports.TSUnionType = TSUnionType;\nexports.TSUnknownKeyword = TSUnknownKeyword;\nexports.TSVoidKeyword = TSVoidKeyword;\nexports.tsPrintClassMemberModifiers = tsPrintClassMemberModifiers;\nexports.tsPrintFunctionOrConstructorType = tsPrintFunctionOrConstructorType;\nexports.tsPrintPropertyOrMethodName = tsPrintPropertyOrMethodName;\nexports.tsPrintSignatureDeclarationBase = tsPrintSignatureDeclarationBase;\nfunction TSTypeAnnotation(node, parent) {\n  this.token((parent.type === \"TSFunctionType\" || parent.type === \"TSConstructorType\") && parent.typeAnnotation === node ? \"=>\" : \":\");\n  this.space();\n  if (node.optional) this.tokenChar(63);\n  this.print(node.typeAnnotation);\n}\nfunction TSTypeParameterInstantiation(node, parent) {\n  this.tokenChar(60);\n  let printTrailingSeparator = parent.type === \"ArrowFunctionExpression\" && node.params.length === 1;\n  if (this.tokenMap && node.start != null && node.end != null) {\n    printTrailingSeparator && (printTrailingSeparator = !!this.tokenMap.find(node, t => this.tokenMap.matchesOriginal(t, \",\")));\n    printTrailingSeparator || (printTrailingSeparator = this.shouldPrintTrailingComma(\">\"));\n  }\n  this.printList(node.params, printTrailingSeparator);\n  this.tokenChar(62);\n}\nfunction TSTypeParameter(node) {\n  if (node.const) {\n    this.word(\"const\");\n    this.space();\n  }\n  if (node.in) {\n    this.word(\"in\");\n    this.space();\n  }\n  if (node.out) {\n    this.word(\"out\");\n    this.space();\n  }\n  this.word(node.name);\n  if (node.constraint) {\n    this.space();\n    this.word(\"extends\");\n    this.space();\n    this.print(node.constraint);\n  }\n  if (node.default) {\n    this.space();\n    this.tokenChar(61);\n    this.space();\n    this.print(node.default);\n  }\n}\nfunction TSParameterProperty(node) {\n  if (node.accessibility) {\n    this.word(node.accessibility);\n    this.space();\n  }\n  if (node.readonly) {\n    this.word(\"readonly\");\n    this.space();\n  }\n  this._param(node.parameter);\n}\nfunction TSDeclareFunction(node, parent) {\n  if (node.declare) {\n    this.word(\"declare\");\n    this.space();\n  }\n  this._functionHead(node, parent);\n  this.semicolon();\n}\nfunction TSDeclareMethod(node) {\n  this._classMethodHead(node);\n  this.semicolon();\n}\nfunction TSQualifiedName(node) {\n  this.print(node.left);\n  this.tokenChar(46);\n  this.print(node.right);\n}\nfunction TSCallSignatureDeclaration(node) {\n  this.tsPrintSignatureDeclarationBase(node);\n  maybePrintTrailingCommaOrSemicolon(this, node);\n}\nfunction maybePrintTrailingCommaOrSemicolon(printer, node) {\n  if (!printer.tokenMap || !node.start || !node.end) {\n    printer.semicolon();\n    return;\n  }\n  if (printer.tokenMap.endMatches(node, \",\")) {\n    printer.token(\",\");\n  } else if (printer.tokenMap.endMatches(node, \";\")) {\n    printer.semicolon();\n  }\n}\nfunction TSConstructSignatureDeclaration(node) {\n  this.word(\"new\");\n  this.space();\n  this.tsPrintSignatureDeclarationBase(node);\n  maybePrintTrailingCommaOrSemicolon(this, node);\n}\nfunction TSPropertySignature(node) {\n  const {\n    readonly\n  } = node;\n  if (readonly) {\n    this.word(\"readonly\");\n    this.space();\n  }\n  this.tsPrintPropertyOrMethodName(node);\n  this.print(node.typeAnnotation);\n  maybePrintTrailingCommaOrSemicolon(this, node);\n}\nfunction tsPrintPropertyOrMethodName(node) {\n  if (node.computed) {\n    this.tokenChar(91);\n  }\n  this.print(node.key);\n  if (node.computed) {\n    this.tokenChar(93);\n  }\n  if (node.optional) {\n    this.tokenChar(63);\n  }\n}\nfunction TSMethodSignature(node) {\n  const {\n    kind\n  } = node;\n  if (kind === \"set\" || kind === \"get\") {\n    this.word(kind);\n    this.space();\n  }\n  this.tsPrintPropertyOrMethodName(node);\n  this.tsPrintSignatureDeclarationBase(node);\n  maybePrintTrailingCommaOrSemicolon(this, node);\n}\nfunction TSIndexSignature(node) {\n  const {\n    readonly,\n    static: isStatic\n  } = node;\n  if (isStatic) {\n    this.word(\"static\");\n    this.space();\n  }\n  if (readonly) {\n    this.word(\"readonly\");\n    this.space();\n  }\n  this.tokenChar(91);\n  this._parameters(node.parameters, \"]\");\n  this.print(node.typeAnnotation);\n  maybePrintTrailingCommaOrSemicolon(this, node);\n}\nfunction TSAnyKeyword() {\n  this.word(\"any\");\n}\nfunction TSBigIntKeyword() {\n  this.word(\"bigint\");\n}\nfunction TSUnknownKeyword() {\n  this.word(\"unknown\");\n}\nfunction TSNumberKeyword() {\n  this.word(\"number\");\n}\nfunction TSObjectKeyword() {\n  this.word(\"object\");\n}\nfunction TSBooleanKeyword() {\n  this.word(\"boolean\");\n}\nfunction TSStringKeyword() {\n  this.word(\"string\");\n}\nfunction TSSymbolKeyword() {\n  this.word(\"symbol\");\n}\nfunction TSVoidKeyword() {\n  this.word(\"void\");\n}\nfunction TSUndefinedKeyword() {\n  this.word(\"undefined\");\n}\nfunction TSNullKeyword() {\n  this.word(\"null\");\n}\nfunction TSNeverKeyword() {\n  this.word(\"never\");\n}\nfunction TSIntrinsicKeyword() {\n  this.word(\"intrinsic\");\n}\nfunction TSThisType() {\n  this.word(\"this\");\n}\nfunction TSFunctionType(node) {\n  this.tsPrintFunctionOrConstructorType(node);\n}\nfunction TSConstructorType(node) {\n  if (node.abstract) {\n    this.word(\"abstract\");\n    this.space();\n  }\n  this.word(\"new\");\n  this.space();\n  this.tsPrintFunctionOrConstructorType(node);\n}\nfunction tsPrintFunctionOrConstructorType(node) {\n  const {\n    typeParameters\n  } = node;\n  const parameters = node.parameters;\n  this.print(typeParameters);\n  this.tokenChar(40);\n  this._parameters(parameters, \")\");\n  this.space();\n  const returnType = node.typeAnnotation;\n  this.print(returnType);\n}\nfunction TSTypeReference(node) {\n  const typeArguments = node.typeParameters;\n  this.print(node.typeName, !!typeArguments);\n  this.print(typeArguments);\n}\nfunction TSTypePredicate(node) {\n  if (node.asserts) {\n    this.word(\"asserts\");\n    this.space();\n  }\n  this.print(node.parameterName);\n  if (node.typeAnnotation) {\n    this.space();\n    this.word(\"is\");\n    this.space();\n    this.print(node.typeAnnotation.typeAnnotation);\n  }\n}\nfunction TSTypeQuery(node) {\n  this.word(\"typeof\");\n  this.space();\n  this.print(node.exprName);\n  const typeArguments = node.typeParameters;\n  if (typeArguments) {\n    this.print(typeArguments);\n  }\n}\nfunction TSTypeLiteral(node) {\n  printBraced(this, node, () => this.printJoin(node.members, true, true));\n}\nfunction TSArrayType(node) {\n  this.print(node.elementType, true);\n  this.tokenChar(91);\n  this.tokenChar(93);\n}\nfunction TSTupleType(node) {\n  this.tokenChar(91);\n  this.printList(node.elementTypes, this.shouldPrintTrailingComma(\"]\"));\n  this.tokenChar(93);\n}\nfunction TSOptionalType(node) {\n  this.print(node.typeAnnotation);\n  this.tokenChar(63);\n}\nfunction TSRestType(node) {\n  this.token(\"...\");\n  this.print(node.typeAnnotation);\n}\nfunction TSNamedTupleMember(node) {\n  this.print(node.label);\n  if (node.optional) this.tokenChar(63);\n  this.tokenChar(58);\n  this.space();\n  this.print(node.elementType);\n}\nfunction TSUnionType(node) {\n  tsPrintUnionOrIntersectionType(this, node, \"|\");\n}\nfunction TSIntersectionType(node) {\n  tsPrintUnionOrIntersectionType(this, node, \"&\");\n}\nfunction tsPrintUnionOrIntersectionType(printer, node, sep) {\n  var _printer$tokenMap;\n  let hasLeadingToken = 0;\n  if ((_printer$tokenMap = printer.tokenMap) != null && _printer$tokenMap.startMatches(node, sep)) {\n    hasLeadingToken = 1;\n    printer.token(sep);\n  }\n  printer.printJoin(node.types, undefined, undefined, function (i) {\n    this.space();\n    this.token(sep, undefined, i + hasLeadingToken);\n    this.space();\n  });\n}\nfunction TSConditionalType(node) {\n  this.print(node.checkType);\n  this.space();\n  this.word(\"extends\");\n  this.space();\n  this.print(node.extendsType);\n  this.space();\n  this.tokenChar(63);\n  this.space();\n  this.print(node.trueType);\n  this.space();\n  this.tokenChar(58);\n  this.space();\n  this.print(node.falseType);\n}\nfunction TSInferType(node) {\n  this.word(\"infer\");\n  this.print(node.typeParameter);\n}\nfunction TSParenthesizedType(node) {\n  this.tokenChar(40);\n  this.print(node.typeAnnotation);\n  this.tokenChar(41);\n}\nfunction TSTypeOperator(node) {\n  this.word(node.operator);\n  this.space();\n  this.print(node.typeAnnotation);\n}\nfunction TSIndexedAccessType(node) {\n  this.print(node.objectType, true);\n  this.tokenChar(91);\n  this.print(node.indexType);\n  this.tokenChar(93);\n}\nfunction TSMappedType(node) {\n  const {\n    nameType,\n    optional,\n    readonly,\n    typeAnnotation\n  } = node;\n  this.tokenChar(123);\n  const exit = this.enterDelimited();\n  this.space();\n  if (readonly) {\n    tokenIfPlusMinus(this, readonly);\n    this.word(\"readonly\");\n    this.space();\n  }\n  this.tokenChar(91);\n  this.word(node.typeParameter.name);\n  this.space();\n  this.word(\"in\");\n  this.space();\n  this.print(node.typeParameter.constraint);\n  if (nameType) {\n    this.space();\n    this.word(\"as\");\n    this.space();\n    this.print(nameType);\n  }\n  this.tokenChar(93);\n  if (optional) {\n    tokenIfPlusMinus(this, optional);\n    this.tokenChar(63);\n  }\n  if (typeAnnotation) {\n    this.tokenChar(58);\n    this.space();\n    this.print(typeAnnotation);\n  }\n  this.space();\n  exit();\n  this.tokenChar(125);\n}\nfunction tokenIfPlusMinus(self, tok) {\n  if (tok !== true) {\n    self.token(tok);\n  }\n}\nfunction TSTemplateLiteralType(node) {\n  this._printTemplate(node, node.types);\n}\nfunction TSLiteralType(node) {\n  this.print(node.literal);\n}\nfunction TSClassImplements(node) {\n  this.print(node.expression);\n  this.print(node.typeArguments);\n}\nfunction TSInterfaceDeclaration(node) {\n  const {\n    declare,\n    id,\n    typeParameters,\n    extends: extendz,\n    body\n  } = node;\n  if (declare) {\n    this.word(\"declare\");\n    this.space();\n  }\n  this.word(\"interface\");\n  this.space();\n  this.print(id);\n  this.print(typeParameters);\n  if (extendz != null && extendz.length) {\n    this.space();\n    this.word(\"extends\");\n    this.space();\n    this.printList(extendz);\n  }\n  this.space();\n  this.print(body);\n}\nfunction TSInterfaceBody(node) {\n  printBraced(this, node, () => this.printJoin(node.body, true, true));\n}\nfunction TSTypeAliasDeclaration(node) {\n  const {\n    declare,\n    id,\n    typeParameters,\n    typeAnnotation\n  } = node;\n  if (declare) {\n    this.word(\"declare\");\n    this.space();\n  }\n  this.word(\"type\");\n  this.space();\n  this.print(id);\n  this.print(typeParameters);\n  this.space();\n  this.tokenChar(61);\n  this.space();\n  this.print(typeAnnotation);\n  this.semicolon();\n}\nfunction TSTypeExpression(node) {\n  const {\n    type,\n    expression,\n    typeAnnotation\n  } = node;\n  this.print(expression, true);\n  this.space();\n  this.word(type === \"TSAsExpression\" ? \"as\" : \"satisfies\");\n  this.space();\n  this.print(typeAnnotation);\n}\nfunction TSTypeAssertion(node) {\n  const {\n    typeAnnotation,\n    expression\n  } = node;\n  this.tokenChar(60);\n  this.print(typeAnnotation);\n  this.tokenChar(62);\n  this.space();\n  this.print(expression);\n}\nfunction TSInstantiationExpression(node) {\n  this.print(node.expression);\n  this.print(node.typeParameters);\n}\nfunction TSEnumDeclaration(node) {\n  const {\n    declare,\n    const: isConst,\n    id\n  } = node;\n  if (declare) {\n    this.word(\"declare\");\n    this.space();\n  }\n  if (isConst) {\n    this.word(\"const\");\n    this.space();\n  }\n  this.word(\"enum\");\n  this.space();\n  this.print(id);\n  this.space();\n  TSEnumBody.call(this, node);\n}\nfunction TSEnumBody(node) {\n  printBraced(this, node, () => {\n    var _this$shouldPrintTrai;\n    return this.printList(node.members, (_this$shouldPrintTrai = this.shouldPrintTrailingComma(\"}\")) != null ? _this$shouldPrintTrai : true, true, true);\n  });\n}\nfunction TSEnumMember(node) {\n  const {\n    id,\n    initializer\n  } = node;\n  this.print(id);\n  if (initializer) {\n    this.space();\n    this.tokenChar(61);\n    this.space();\n    this.print(initializer);\n  }\n}\nfunction TSModuleDeclaration(node) {\n  const {\n    declare,\n    id,\n    kind\n  } = node;\n  if (declare) {\n    this.word(\"declare\");\n    this.space();\n  }\n  if (!node.global) {\n    this.word(kind != null ? kind : id.type === \"Identifier\" ? \"namespace\" : \"module\");\n    this.space();\n  }\n  this.print(id);\n  if (!node.body) {\n    this.semicolon();\n    return;\n  }\n  let body = node.body;\n  while (body.type === \"TSModuleDeclaration\") {\n    this.tokenChar(46);\n    this.print(body.id);\n    body = body.body;\n  }\n  this.space();\n  this.print(body);\n}\nfunction TSModuleBlock(node) {\n  printBraced(this, node, () => this.printSequence(node.body, true));\n}\nfunction TSImportType(node) {\n  const {\n    qualifier,\n    options\n  } = node;\n  this.word(\"import\");\n  this.tokenChar(40);\n  this.print(node.argument);\n  if (options) {\n    this.tokenChar(44);\n    this.print(options);\n  }\n  this.tokenChar(41);\n  if (qualifier) {\n    this.tokenChar(46);\n    this.print(qualifier);\n  }\n  const typeArguments = node.typeParameters;\n  if (typeArguments) {\n    this.print(typeArguments);\n  }\n}\nfunction TSImportEqualsDeclaration(node) {\n  const {\n    id,\n    moduleReference\n  } = node;\n  if (node.isExport) {\n    this.word(\"export\");\n    this.space();\n  }\n  this.word(\"import\");\n  this.space();\n  this.print(id);\n  this.space();\n  this.tokenChar(61);\n  this.space();\n  this.print(moduleReference);\n  this.semicolon();\n}\nfunction TSExternalModuleReference(node) {\n  this.token(\"require(\");\n  this.print(node.expression);\n  this.tokenChar(41);\n}\nfunction TSNonNullExpression(node) {\n  this.print(node.expression);\n  this.tokenChar(33);\n}\nfunction TSExportAssignment(node) {\n  this.word(\"export\");\n  this.space();\n  this.tokenChar(61);\n  this.space();\n  this.print(node.expression);\n  this.semicolon();\n}\nfunction TSNamespaceExportDeclaration(node) {\n  this.word(\"export\");\n  this.space();\n  this.word(\"as\");\n  this.space();\n  this.word(\"namespace\");\n  this.space();\n  this.print(node.id);\n  this.semicolon();\n}\nfunction tsPrintSignatureDeclarationBase(node) {\n  const {\n    typeParameters\n  } = node;\n  const parameters = node.parameters;\n  this.print(typeParameters);\n  this.tokenChar(40);\n  this._parameters(parameters, \")\");\n  const returnType = node.typeAnnotation;\n  this.print(returnType);\n}\nfunction tsPrintClassMemberModifiers(node) {\n  const isPrivateField = node.type === \"ClassPrivateProperty\";\n  const isPublicField = node.type === \"ClassAccessorProperty\" || node.type === \"ClassProperty\";\n  printModifiersList(this, node, [isPublicField && node.declare && \"declare\", !isPrivateField && node.accessibility]);\n  if (node.static) {\n    this.word(\"static\");\n    this.space();\n  }\n  printModifiersList(this, node, [!isPrivateField && node.abstract && \"abstract\", !isPrivateField && node.override && \"override\", (isPublicField || isPrivateField) && node.readonly && \"readonly\"]);\n}\nfunction printBraced(printer, node, cb) {\n  printer.token(\"{\");\n  const exit = printer.enterDelimited();\n  cb();\n  exit();\n  printer.rightBrace(node);\n}\nfunction printModifiersList(printer, node, modifiers) {\n  var _printer$tokenMap2;\n  const modifiersSet = new Set();\n  for (const modifier of modifiers) {\n    if (modifier) modifiersSet.add(modifier);\n  }\n  (_printer$tokenMap2 = printer.tokenMap) == null || _printer$tokenMap2.find(node, tok => {\n    if (modifiersSet.has(tok.value)) {\n      printer.token(tok.value);\n      printer.space();\n      modifiersSet.delete(tok.value);\n      return modifiersSet.size === 0;\n    }\n    return false;\n  });\n  for (const modifier of modifiersSet) {\n    printer.word(modifier);\n    printer.space();\n  }\n}\n\n//# sourceMappingURL=typescript.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGJhYmVsL2dlbmVyYXRvci9saWIvZ2VuZXJhdG9ycy90eXBlc2NyaXB0LmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViLDhDQUE2QztBQUM3QztBQUNBLENBQUMsRUFBQztBQUNGLG9CQUFvQjtBQUNwQixtQkFBbUI7QUFDbkIsNkJBQTZCLEdBQUcsc0JBQXNCO0FBQ3RELHVCQUF1QjtBQUN2Qix3QkFBd0I7QUFDeEIsa0NBQWtDO0FBQ2xDLDJCQUEyQixHQUFHLHlCQUF5QjtBQUN2RCx5QkFBeUI7QUFDekIsdUNBQXVDO0FBQ3ZDLHlCQUF5QjtBQUN6Qix5QkFBeUI7QUFDekIsdUJBQXVCO0FBQ3ZCLGtCQUFrQjtBQUNsQix5QkFBeUI7QUFDekIsb0JBQW9CO0FBQ3BCLDBCQUEwQjtBQUMxQixpQ0FBaUM7QUFDakMsc0JBQXNCO0FBQ3RCLGlDQUFpQztBQUNqQyxvQkFBb0I7QUFDcEIsd0JBQXdCO0FBQ3hCLDJCQUEyQjtBQUMzQixtQkFBbUI7QUFDbkIsaUNBQWlDO0FBQ2pDLHVCQUF1QjtBQUN2Qiw4QkFBOEI7QUFDOUIsMEJBQTBCO0FBQzFCLDBCQUEwQjtBQUMxQixxQkFBcUI7QUFDckIsb0JBQW9CO0FBQ3BCLHlCQUF5QjtBQUN6QixxQkFBcUI7QUFDckIsMkJBQTJCO0FBQzNCLDBCQUEwQjtBQUMxQixvQ0FBb0M7QUFDcEMsc0JBQXNCO0FBQ3RCLDJCQUEyQjtBQUMzQixxQkFBcUI7QUFDckIsdUJBQXVCO0FBQ3ZCLHVCQUF1QjtBQUN2QixzQkFBc0I7QUFDdEIsMkJBQTJCO0FBQzNCLDJCQUEyQjtBQUMzQiwyQkFBMkI7QUFDM0IsdUJBQXVCO0FBQ3ZCLGtCQUFrQjtBQUNsQix1QkFBdUI7QUFDdkIsdUJBQXVCO0FBQ3ZCLDZCQUE2QjtBQUM3QixrQkFBa0I7QUFDbEIsbUJBQW1CO0FBQ25CLDhCQUE4QjtBQUM5Qix3QkFBd0I7QUFDeEIsdUJBQXVCO0FBQ3ZCLHFCQUFxQjtBQUNyQixzQkFBc0I7QUFDdEIsdUJBQXVCO0FBQ3ZCLGtDQUFrQyxHQUFHLG9DQUFvQztBQUN6RSx1QkFBdUI7QUFDdkIsbUJBQW1CO0FBQ25CLHVCQUF1QjtBQUN2QiwwQkFBMEI7QUFDMUIsbUJBQW1CO0FBQ25CLHdCQUF3QjtBQUN4QixxQkFBcUI7QUFDckIsbUNBQW1DO0FBQ25DLHdDQUF3QztBQUN4QyxtQ0FBbUM7QUFDbkMsdUNBQXVDO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSSw2Q0FBNkM7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlHQUFpRztBQUNqRyxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSIsInNvdXJjZXMiOlsid2VicGFjazovL3JlcG8tdmlzdWFsaXplci8uL25vZGVfbW9kdWxlcy9AYmFiZWwvZ2VuZXJhdG9yL2xpYi9nZW5lcmF0b3JzL3R5cGVzY3JpcHQuanM/ODk4OSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuVFNBbnlLZXl3b3JkID0gVFNBbnlLZXl3b3JkO1xuZXhwb3J0cy5UU0FycmF5VHlwZSA9IFRTQXJyYXlUeXBlO1xuZXhwb3J0cy5UU1NhdGlzZmllc0V4cHJlc3Npb24gPSBleHBvcnRzLlRTQXNFeHByZXNzaW9uID0gVFNUeXBlRXhwcmVzc2lvbjtcbmV4cG9ydHMuVFNCaWdJbnRLZXl3b3JkID0gVFNCaWdJbnRLZXl3b3JkO1xuZXhwb3J0cy5UU0Jvb2xlYW5LZXl3b3JkID0gVFNCb29sZWFuS2V5d29yZDtcbmV4cG9ydHMuVFNDYWxsU2lnbmF0dXJlRGVjbGFyYXRpb24gPSBUU0NhbGxTaWduYXR1cmVEZWNsYXJhdGlvbjtcbmV4cG9ydHMuVFNJbnRlcmZhY2VIZXJpdGFnZSA9IGV4cG9ydHMuVFNDbGFzc0ltcGxlbWVudHMgPSBUU0NsYXNzSW1wbGVtZW50cztcbmV4cG9ydHMuVFNDb25kaXRpb25hbFR5cGUgPSBUU0NvbmRpdGlvbmFsVHlwZTtcbmV4cG9ydHMuVFNDb25zdHJ1Y3RTaWduYXR1cmVEZWNsYXJhdGlvbiA9IFRTQ29uc3RydWN0U2lnbmF0dXJlRGVjbGFyYXRpb247XG5leHBvcnRzLlRTQ29uc3RydWN0b3JUeXBlID0gVFNDb25zdHJ1Y3RvclR5cGU7XG5leHBvcnRzLlRTRGVjbGFyZUZ1bmN0aW9uID0gVFNEZWNsYXJlRnVuY3Rpb247XG5leHBvcnRzLlRTRGVjbGFyZU1ldGhvZCA9IFRTRGVjbGFyZU1ldGhvZDtcbmV4cG9ydHMuVFNFbnVtQm9keSA9IFRTRW51bUJvZHk7XG5leHBvcnRzLlRTRW51bURlY2xhcmF0aW9uID0gVFNFbnVtRGVjbGFyYXRpb247XG5leHBvcnRzLlRTRW51bU1lbWJlciA9IFRTRW51bU1lbWJlcjtcbmV4cG9ydHMuVFNFeHBvcnRBc3NpZ25tZW50ID0gVFNFeHBvcnRBc3NpZ25tZW50O1xuZXhwb3J0cy5UU0V4dGVybmFsTW9kdWxlUmVmZXJlbmNlID0gVFNFeHRlcm5hbE1vZHVsZVJlZmVyZW5jZTtcbmV4cG9ydHMuVFNGdW5jdGlvblR5cGUgPSBUU0Z1bmN0aW9uVHlwZTtcbmV4cG9ydHMuVFNJbXBvcnRFcXVhbHNEZWNsYXJhdGlvbiA9IFRTSW1wb3J0RXF1YWxzRGVjbGFyYXRpb247XG5leHBvcnRzLlRTSW1wb3J0VHlwZSA9IFRTSW1wb3J0VHlwZTtcbmV4cG9ydHMuVFNJbmRleFNpZ25hdHVyZSA9IFRTSW5kZXhTaWduYXR1cmU7XG5leHBvcnRzLlRTSW5kZXhlZEFjY2Vzc1R5cGUgPSBUU0luZGV4ZWRBY2Nlc3NUeXBlO1xuZXhwb3J0cy5UU0luZmVyVHlwZSA9IFRTSW5mZXJUeXBlO1xuZXhwb3J0cy5UU0luc3RhbnRpYXRpb25FeHByZXNzaW9uID0gVFNJbnN0YW50aWF0aW9uRXhwcmVzc2lvbjtcbmV4cG9ydHMuVFNJbnRlcmZhY2VCb2R5ID0gVFNJbnRlcmZhY2VCb2R5O1xuZXhwb3J0cy5UU0ludGVyZmFjZURlY2xhcmF0aW9uID0gVFNJbnRlcmZhY2VEZWNsYXJhdGlvbjtcbmV4cG9ydHMuVFNJbnRlcnNlY3Rpb25UeXBlID0gVFNJbnRlcnNlY3Rpb25UeXBlO1xuZXhwb3J0cy5UU0ludHJpbnNpY0tleXdvcmQgPSBUU0ludHJpbnNpY0tleXdvcmQ7XG5leHBvcnRzLlRTTGl0ZXJhbFR5cGUgPSBUU0xpdGVyYWxUeXBlO1xuZXhwb3J0cy5UU01hcHBlZFR5cGUgPSBUU01hcHBlZFR5cGU7XG5leHBvcnRzLlRTTWV0aG9kU2lnbmF0dXJlID0gVFNNZXRob2RTaWduYXR1cmU7XG5leHBvcnRzLlRTTW9kdWxlQmxvY2sgPSBUU01vZHVsZUJsb2NrO1xuZXhwb3J0cy5UU01vZHVsZURlY2xhcmF0aW9uID0gVFNNb2R1bGVEZWNsYXJhdGlvbjtcbmV4cG9ydHMuVFNOYW1lZFR1cGxlTWVtYmVyID0gVFNOYW1lZFR1cGxlTWVtYmVyO1xuZXhwb3J0cy5UU05hbWVzcGFjZUV4cG9ydERlY2xhcmF0aW9uID0gVFNOYW1lc3BhY2VFeHBvcnREZWNsYXJhdGlvbjtcbmV4cG9ydHMuVFNOZXZlcktleXdvcmQgPSBUU05ldmVyS2V5d29yZDtcbmV4cG9ydHMuVFNOb25OdWxsRXhwcmVzc2lvbiA9IFRTTm9uTnVsbEV4cHJlc3Npb247XG5leHBvcnRzLlRTTnVsbEtleXdvcmQgPSBUU051bGxLZXl3b3JkO1xuZXhwb3J0cy5UU051bWJlcktleXdvcmQgPSBUU051bWJlcktleXdvcmQ7XG5leHBvcnRzLlRTT2JqZWN0S2V5d29yZCA9IFRTT2JqZWN0S2V5d29yZDtcbmV4cG9ydHMuVFNPcHRpb25hbFR5cGUgPSBUU09wdGlvbmFsVHlwZTtcbmV4cG9ydHMuVFNQYXJhbWV0ZXJQcm9wZXJ0eSA9IFRTUGFyYW1ldGVyUHJvcGVydHk7XG5leHBvcnRzLlRTUGFyZW50aGVzaXplZFR5cGUgPSBUU1BhcmVudGhlc2l6ZWRUeXBlO1xuZXhwb3J0cy5UU1Byb3BlcnR5U2lnbmF0dXJlID0gVFNQcm9wZXJ0eVNpZ25hdHVyZTtcbmV4cG9ydHMuVFNRdWFsaWZpZWROYW1lID0gVFNRdWFsaWZpZWROYW1lO1xuZXhwb3J0cy5UU1Jlc3RUeXBlID0gVFNSZXN0VHlwZTtcbmV4cG9ydHMuVFNTdHJpbmdLZXl3b3JkID0gVFNTdHJpbmdLZXl3b3JkO1xuZXhwb3J0cy5UU1N5bWJvbEtleXdvcmQgPSBUU1N5bWJvbEtleXdvcmQ7XG5leHBvcnRzLlRTVGVtcGxhdGVMaXRlcmFsVHlwZSA9IFRTVGVtcGxhdGVMaXRlcmFsVHlwZTtcbmV4cG9ydHMuVFNUaGlzVHlwZSA9IFRTVGhpc1R5cGU7XG5leHBvcnRzLlRTVHVwbGVUeXBlID0gVFNUdXBsZVR5cGU7XG5leHBvcnRzLlRTVHlwZUFsaWFzRGVjbGFyYXRpb24gPSBUU1R5cGVBbGlhc0RlY2xhcmF0aW9uO1xuZXhwb3J0cy5UU1R5cGVBbm5vdGF0aW9uID0gVFNUeXBlQW5ub3RhdGlvbjtcbmV4cG9ydHMuVFNUeXBlQXNzZXJ0aW9uID0gVFNUeXBlQXNzZXJ0aW9uO1xuZXhwb3J0cy5UU1R5cGVMaXRlcmFsID0gVFNUeXBlTGl0ZXJhbDtcbmV4cG9ydHMuVFNUeXBlT3BlcmF0b3IgPSBUU1R5cGVPcGVyYXRvcjtcbmV4cG9ydHMuVFNUeXBlUGFyYW1ldGVyID0gVFNUeXBlUGFyYW1ldGVyO1xuZXhwb3J0cy5UU1R5cGVQYXJhbWV0ZXJEZWNsYXJhdGlvbiA9IGV4cG9ydHMuVFNUeXBlUGFyYW1ldGVySW5zdGFudGlhdGlvbiA9IFRTVHlwZVBhcmFtZXRlckluc3RhbnRpYXRpb247XG5leHBvcnRzLlRTVHlwZVByZWRpY2F0ZSA9IFRTVHlwZVByZWRpY2F0ZTtcbmV4cG9ydHMuVFNUeXBlUXVlcnkgPSBUU1R5cGVRdWVyeTtcbmV4cG9ydHMuVFNUeXBlUmVmZXJlbmNlID0gVFNUeXBlUmVmZXJlbmNlO1xuZXhwb3J0cy5UU1VuZGVmaW5lZEtleXdvcmQgPSBUU1VuZGVmaW5lZEtleXdvcmQ7XG5leHBvcnRzLlRTVW5pb25UeXBlID0gVFNVbmlvblR5cGU7XG5leHBvcnRzLlRTVW5rbm93bktleXdvcmQgPSBUU1Vua25vd25LZXl3b3JkO1xuZXhwb3J0cy5UU1ZvaWRLZXl3b3JkID0gVFNWb2lkS2V5d29yZDtcbmV4cG9ydHMudHNQcmludENsYXNzTWVtYmVyTW9kaWZpZXJzID0gdHNQcmludENsYXNzTWVtYmVyTW9kaWZpZXJzO1xuZXhwb3J0cy50c1ByaW50RnVuY3Rpb25PckNvbnN0cnVjdG9yVHlwZSA9IHRzUHJpbnRGdW5jdGlvbk9yQ29uc3RydWN0b3JUeXBlO1xuZXhwb3J0cy50c1ByaW50UHJvcGVydHlPck1ldGhvZE5hbWUgPSB0c1ByaW50UHJvcGVydHlPck1ldGhvZE5hbWU7XG5leHBvcnRzLnRzUHJpbnRTaWduYXR1cmVEZWNsYXJhdGlvbkJhc2UgPSB0c1ByaW50U2lnbmF0dXJlRGVjbGFyYXRpb25CYXNlO1xuZnVuY3Rpb24gVFNUeXBlQW5ub3RhdGlvbihub2RlLCBwYXJlbnQpIHtcbiAgdGhpcy50b2tlbigocGFyZW50LnR5cGUgPT09IFwiVFNGdW5jdGlvblR5cGVcIiB8fCBwYXJlbnQudHlwZSA9PT0gXCJUU0NvbnN0cnVjdG9yVHlwZVwiKSAmJiBwYXJlbnQudHlwZUFubm90YXRpb24gPT09IG5vZGUgPyBcIj0+XCIgOiBcIjpcIik7XG4gIHRoaXMuc3BhY2UoKTtcbiAgaWYgKG5vZGUub3B0aW9uYWwpIHRoaXMudG9rZW5DaGFyKDYzKTtcbiAgdGhpcy5wcmludChub2RlLnR5cGVBbm5vdGF0aW9uKTtcbn1cbmZ1bmN0aW9uIFRTVHlwZVBhcmFtZXRlckluc3RhbnRpYXRpb24obm9kZSwgcGFyZW50KSB7XG4gIHRoaXMudG9rZW5DaGFyKDYwKTtcbiAgbGV0IHByaW50VHJhaWxpbmdTZXBhcmF0b3IgPSBwYXJlbnQudHlwZSA9PT0gXCJBcnJvd0Z1bmN0aW9uRXhwcmVzc2lvblwiICYmIG5vZGUucGFyYW1zLmxlbmd0aCA9PT0gMTtcbiAgaWYgKHRoaXMudG9rZW5NYXAgJiYgbm9kZS5zdGFydCAhPSBudWxsICYmIG5vZGUuZW5kICE9IG51bGwpIHtcbiAgICBwcmludFRyYWlsaW5nU2VwYXJhdG9yICYmIChwcmludFRyYWlsaW5nU2VwYXJhdG9yID0gISF0aGlzLnRva2VuTWFwLmZpbmQobm9kZSwgdCA9PiB0aGlzLnRva2VuTWFwLm1hdGNoZXNPcmlnaW5hbCh0LCBcIixcIikpKTtcbiAgICBwcmludFRyYWlsaW5nU2VwYXJhdG9yIHx8IChwcmludFRyYWlsaW5nU2VwYXJhdG9yID0gdGhpcy5zaG91bGRQcmludFRyYWlsaW5nQ29tbWEoXCI+XCIpKTtcbiAgfVxuICB0aGlzLnByaW50TGlzdChub2RlLnBhcmFtcywgcHJpbnRUcmFpbGluZ1NlcGFyYXRvcik7XG4gIHRoaXMudG9rZW5DaGFyKDYyKTtcbn1cbmZ1bmN0aW9uIFRTVHlwZVBhcmFtZXRlcihub2RlKSB7XG4gIGlmIChub2RlLmNvbnN0KSB7XG4gICAgdGhpcy53b3JkKFwiY29uc3RcIik7XG4gICAgdGhpcy5zcGFjZSgpO1xuICB9XG4gIGlmIChub2RlLmluKSB7XG4gICAgdGhpcy53b3JkKFwiaW5cIik7XG4gICAgdGhpcy5zcGFjZSgpO1xuICB9XG4gIGlmIChub2RlLm91dCkge1xuICAgIHRoaXMud29yZChcIm91dFwiKTtcbiAgICB0aGlzLnNwYWNlKCk7XG4gIH1cbiAgdGhpcy53b3JkKG5vZGUubmFtZSk7XG4gIGlmIChub2RlLmNvbnN0cmFpbnQpIHtcbiAgICB0aGlzLnNwYWNlKCk7XG4gICAgdGhpcy53b3JkKFwiZXh0ZW5kc1wiKTtcbiAgICB0aGlzLnNwYWNlKCk7XG4gICAgdGhpcy5wcmludChub2RlLmNvbnN0cmFpbnQpO1xuICB9XG4gIGlmIChub2RlLmRlZmF1bHQpIHtcbiAgICB0aGlzLnNwYWNlKCk7XG4gICAgdGhpcy50b2tlbkNoYXIoNjEpO1xuICAgIHRoaXMuc3BhY2UoKTtcbiAgICB0aGlzLnByaW50KG5vZGUuZGVmYXVsdCk7XG4gIH1cbn1cbmZ1bmN0aW9uIFRTUGFyYW1ldGVyUHJvcGVydHkobm9kZSkge1xuICBpZiAobm9kZS5hY2Nlc3NpYmlsaXR5KSB7XG4gICAgdGhpcy53b3JkKG5vZGUuYWNjZXNzaWJpbGl0eSk7XG4gICAgdGhpcy5zcGFjZSgpO1xuICB9XG4gIGlmIChub2RlLnJlYWRvbmx5KSB7XG4gICAgdGhpcy53b3JkKFwicmVhZG9ubHlcIik7XG4gICAgdGhpcy5zcGFjZSgpO1xuICB9XG4gIHRoaXMuX3BhcmFtKG5vZGUucGFyYW1ldGVyKTtcbn1cbmZ1bmN0aW9uIFRTRGVjbGFyZUZ1bmN0aW9uKG5vZGUsIHBhcmVudCkge1xuICBpZiAobm9kZS5kZWNsYXJlKSB7XG4gICAgdGhpcy53b3JkKFwiZGVjbGFyZVwiKTtcbiAgICB0aGlzLnNwYWNlKCk7XG4gIH1cbiAgdGhpcy5fZnVuY3Rpb25IZWFkKG5vZGUsIHBhcmVudCk7XG4gIHRoaXMuc2VtaWNvbG9uKCk7XG59XG5mdW5jdGlvbiBUU0RlY2xhcmVNZXRob2Qobm9kZSkge1xuICB0aGlzLl9jbGFzc01ldGhvZEhlYWQobm9kZSk7XG4gIHRoaXMuc2VtaWNvbG9uKCk7XG59XG5mdW5jdGlvbiBUU1F1YWxpZmllZE5hbWUobm9kZSkge1xuICB0aGlzLnByaW50KG5vZGUubGVmdCk7XG4gIHRoaXMudG9rZW5DaGFyKDQ2KTtcbiAgdGhpcy5wcmludChub2RlLnJpZ2h0KTtcbn1cbmZ1bmN0aW9uIFRTQ2FsbFNpZ25hdHVyZURlY2xhcmF0aW9uKG5vZGUpIHtcbiAgdGhpcy50c1ByaW50U2lnbmF0dXJlRGVjbGFyYXRpb25CYXNlKG5vZGUpO1xuICBtYXliZVByaW50VHJhaWxpbmdDb21tYU9yU2VtaWNvbG9uKHRoaXMsIG5vZGUpO1xufVxuZnVuY3Rpb24gbWF5YmVQcmludFRyYWlsaW5nQ29tbWFPclNlbWljb2xvbihwcmludGVyLCBub2RlKSB7XG4gIGlmICghcHJpbnRlci50b2tlbk1hcCB8fCAhbm9kZS5zdGFydCB8fCAhbm9kZS5lbmQpIHtcbiAgICBwcmludGVyLnNlbWljb2xvbigpO1xuICAgIHJldHVybjtcbiAgfVxuICBpZiAocHJpbnRlci50b2tlbk1hcC5lbmRNYXRjaGVzKG5vZGUsIFwiLFwiKSkge1xuICAgIHByaW50ZXIudG9rZW4oXCIsXCIpO1xuICB9IGVsc2UgaWYgKHByaW50ZXIudG9rZW5NYXAuZW5kTWF0Y2hlcyhub2RlLCBcIjtcIikpIHtcbiAgICBwcmludGVyLnNlbWljb2xvbigpO1xuICB9XG59XG5mdW5jdGlvbiBUU0NvbnN0cnVjdFNpZ25hdHVyZURlY2xhcmF0aW9uKG5vZGUpIHtcbiAgdGhpcy53b3JkKFwibmV3XCIpO1xuICB0aGlzLnNwYWNlKCk7XG4gIHRoaXMudHNQcmludFNpZ25hdHVyZURlY2xhcmF0aW9uQmFzZShub2RlKTtcbiAgbWF5YmVQcmludFRyYWlsaW5nQ29tbWFPclNlbWljb2xvbih0aGlzLCBub2RlKTtcbn1cbmZ1bmN0aW9uIFRTUHJvcGVydHlTaWduYXR1cmUobm9kZSkge1xuICBjb25zdCB7XG4gICAgcmVhZG9ubHlcbiAgfSA9IG5vZGU7XG4gIGlmIChyZWFkb25seSkge1xuICAgIHRoaXMud29yZChcInJlYWRvbmx5XCIpO1xuICAgIHRoaXMuc3BhY2UoKTtcbiAgfVxuICB0aGlzLnRzUHJpbnRQcm9wZXJ0eU9yTWV0aG9kTmFtZShub2RlKTtcbiAgdGhpcy5wcmludChub2RlLnR5cGVBbm5vdGF0aW9uKTtcbiAgbWF5YmVQcmludFRyYWlsaW5nQ29tbWFPclNlbWljb2xvbih0aGlzLCBub2RlKTtcbn1cbmZ1bmN0aW9uIHRzUHJpbnRQcm9wZXJ0eU9yTWV0aG9kTmFtZShub2RlKSB7XG4gIGlmIChub2RlLmNvbXB1dGVkKSB7XG4gICAgdGhpcy50b2tlbkNoYXIoOTEpO1xuICB9XG4gIHRoaXMucHJpbnQobm9kZS5rZXkpO1xuICBpZiAobm9kZS5jb21wdXRlZCkge1xuICAgIHRoaXMudG9rZW5DaGFyKDkzKTtcbiAgfVxuICBpZiAobm9kZS5vcHRpb25hbCkge1xuICAgIHRoaXMudG9rZW5DaGFyKDYzKTtcbiAgfVxufVxuZnVuY3Rpb24gVFNNZXRob2RTaWduYXR1cmUobm9kZSkge1xuICBjb25zdCB7XG4gICAga2luZFxuICB9ID0gbm9kZTtcbiAgaWYgKGtpbmQgPT09IFwic2V0XCIgfHwga2luZCA9PT0gXCJnZXRcIikge1xuICAgIHRoaXMud29yZChraW5kKTtcbiAgICB0aGlzLnNwYWNlKCk7XG4gIH1cbiAgdGhpcy50c1ByaW50UHJvcGVydHlPck1ldGhvZE5hbWUobm9kZSk7XG4gIHRoaXMudHNQcmludFNpZ25hdHVyZURlY2xhcmF0aW9uQmFzZShub2RlKTtcbiAgbWF5YmVQcmludFRyYWlsaW5nQ29tbWFPclNlbWljb2xvbih0aGlzLCBub2RlKTtcbn1cbmZ1bmN0aW9uIFRTSW5kZXhTaWduYXR1cmUobm9kZSkge1xuICBjb25zdCB7XG4gICAgcmVhZG9ubHksXG4gICAgc3RhdGljOiBpc1N0YXRpY1xuICB9ID0gbm9kZTtcbiAgaWYgKGlzU3RhdGljKSB7XG4gICAgdGhpcy53b3JkKFwic3RhdGljXCIpO1xuICAgIHRoaXMuc3BhY2UoKTtcbiAgfVxuICBpZiAocmVhZG9ubHkpIHtcbiAgICB0aGlzLndvcmQoXCJyZWFkb25seVwiKTtcbiAgICB0aGlzLnNwYWNlKCk7XG4gIH1cbiAgdGhpcy50b2tlbkNoYXIoOTEpO1xuICB0aGlzLl9wYXJhbWV0ZXJzKG5vZGUucGFyYW1ldGVycywgXCJdXCIpO1xuICB0aGlzLnByaW50KG5vZGUudHlwZUFubm90YXRpb24pO1xuICBtYXliZVByaW50VHJhaWxpbmdDb21tYU9yU2VtaWNvbG9uKHRoaXMsIG5vZGUpO1xufVxuZnVuY3Rpb24gVFNBbnlLZXl3b3JkKCkge1xuICB0aGlzLndvcmQoXCJhbnlcIik7XG59XG5mdW5jdGlvbiBUU0JpZ0ludEtleXdvcmQoKSB7XG4gIHRoaXMud29yZChcImJpZ2ludFwiKTtcbn1cbmZ1bmN0aW9uIFRTVW5rbm93bktleXdvcmQoKSB7XG4gIHRoaXMud29yZChcInVua25vd25cIik7XG59XG5mdW5jdGlvbiBUU051bWJlcktleXdvcmQoKSB7XG4gIHRoaXMud29yZChcIm51bWJlclwiKTtcbn1cbmZ1bmN0aW9uIFRTT2JqZWN0S2V5d29yZCgpIHtcbiAgdGhpcy53b3JkKFwib2JqZWN0XCIpO1xufVxuZnVuY3Rpb24gVFNCb29sZWFuS2V5d29yZCgpIHtcbiAgdGhpcy53b3JkKFwiYm9vbGVhblwiKTtcbn1cbmZ1bmN0aW9uIFRTU3RyaW5nS2V5d29yZCgpIHtcbiAgdGhpcy53b3JkKFwic3RyaW5nXCIpO1xufVxuZnVuY3Rpb24gVFNTeW1ib2xLZXl3b3JkKCkge1xuICB0aGlzLndvcmQoXCJzeW1ib2xcIik7XG59XG5mdW5jdGlvbiBUU1ZvaWRLZXl3b3JkKCkge1xuICB0aGlzLndvcmQoXCJ2b2lkXCIpO1xufVxuZnVuY3Rpb24gVFNVbmRlZmluZWRLZXl3b3JkKCkge1xuICB0aGlzLndvcmQoXCJ1bmRlZmluZWRcIik7XG59XG5mdW5jdGlvbiBUU051bGxLZXl3b3JkKCkge1xuICB0aGlzLndvcmQoXCJudWxsXCIpO1xufVxuZnVuY3Rpb24gVFNOZXZlcktleXdvcmQoKSB7XG4gIHRoaXMud29yZChcIm5ldmVyXCIpO1xufVxuZnVuY3Rpb24gVFNJbnRyaW5zaWNLZXl3b3JkKCkge1xuICB0aGlzLndvcmQoXCJpbnRyaW5zaWNcIik7XG59XG5mdW5jdGlvbiBUU1RoaXNUeXBlKCkge1xuICB0aGlzLndvcmQoXCJ0aGlzXCIpO1xufVxuZnVuY3Rpb24gVFNGdW5jdGlvblR5cGUobm9kZSkge1xuICB0aGlzLnRzUHJpbnRGdW5jdGlvbk9yQ29uc3RydWN0b3JUeXBlKG5vZGUpO1xufVxuZnVuY3Rpb24gVFNDb25zdHJ1Y3RvclR5cGUobm9kZSkge1xuICBpZiAobm9kZS5hYnN0cmFjdCkge1xuICAgIHRoaXMud29yZChcImFic3RyYWN0XCIpO1xuICAgIHRoaXMuc3BhY2UoKTtcbiAgfVxuICB0aGlzLndvcmQoXCJuZXdcIik7XG4gIHRoaXMuc3BhY2UoKTtcbiAgdGhpcy50c1ByaW50RnVuY3Rpb25PckNvbnN0cnVjdG9yVHlwZShub2RlKTtcbn1cbmZ1bmN0aW9uIHRzUHJpbnRGdW5jdGlvbk9yQ29uc3RydWN0b3JUeXBlKG5vZGUpIHtcbiAgY29uc3Qge1xuICAgIHR5cGVQYXJhbWV0ZXJzXG4gIH0gPSBub2RlO1xuICBjb25zdCBwYXJhbWV0ZXJzID0gbm9kZS5wYXJhbWV0ZXJzO1xuICB0aGlzLnByaW50KHR5cGVQYXJhbWV0ZXJzKTtcbiAgdGhpcy50b2tlbkNoYXIoNDApO1xuICB0aGlzLl9wYXJhbWV0ZXJzKHBhcmFtZXRlcnMsIFwiKVwiKTtcbiAgdGhpcy5zcGFjZSgpO1xuICBjb25zdCByZXR1cm5UeXBlID0gbm9kZS50eXBlQW5ub3RhdGlvbjtcbiAgdGhpcy5wcmludChyZXR1cm5UeXBlKTtcbn1cbmZ1bmN0aW9uIFRTVHlwZVJlZmVyZW5jZShub2RlKSB7XG4gIGNvbnN0IHR5cGVBcmd1bWVudHMgPSBub2RlLnR5cGVQYXJhbWV0ZXJzO1xuICB0aGlzLnByaW50KG5vZGUudHlwZU5hbWUsICEhdHlwZUFyZ3VtZW50cyk7XG4gIHRoaXMucHJpbnQodHlwZUFyZ3VtZW50cyk7XG59XG5mdW5jdGlvbiBUU1R5cGVQcmVkaWNhdGUobm9kZSkge1xuICBpZiAobm9kZS5hc3NlcnRzKSB7XG4gICAgdGhpcy53b3JkKFwiYXNzZXJ0c1wiKTtcbiAgICB0aGlzLnNwYWNlKCk7XG4gIH1cbiAgdGhpcy5wcmludChub2RlLnBhcmFtZXRlck5hbWUpO1xuICBpZiAobm9kZS50eXBlQW5ub3RhdGlvbikge1xuICAgIHRoaXMuc3BhY2UoKTtcbiAgICB0aGlzLndvcmQoXCJpc1wiKTtcbiAgICB0aGlzLnNwYWNlKCk7XG4gICAgdGhpcy5wcmludChub2RlLnR5cGVBbm5vdGF0aW9uLnR5cGVBbm5vdGF0aW9uKTtcbiAgfVxufVxuZnVuY3Rpb24gVFNUeXBlUXVlcnkobm9kZSkge1xuICB0aGlzLndvcmQoXCJ0eXBlb2ZcIik7XG4gIHRoaXMuc3BhY2UoKTtcbiAgdGhpcy5wcmludChub2RlLmV4cHJOYW1lKTtcbiAgY29uc3QgdHlwZUFyZ3VtZW50cyA9IG5vZGUudHlwZVBhcmFtZXRlcnM7XG4gIGlmICh0eXBlQXJndW1lbnRzKSB7XG4gICAgdGhpcy5wcmludCh0eXBlQXJndW1lbnRzKTtcbiAgfVxufVxuZnVuY3Rpb24gVFNUeXBlTGl0ZXJhbChub2RlKSB7XG4gIHByaW50QnJhY2VkKHRoaXMsIG5vZGUsICgpID0+IHRoaXMucHJpbnRKb2luKG5vZGUubWVtYmVycywgdHJ1ZSwgdHJ1ZSkpO1xufVxuZnVuY3Rpb24gVFNBcnJheVR5cGUobm9kZSkge1xuICB0aGlzLnByaW50KG5vZGUuZWxlbWVudFR5cGUsIHRydWUpO1xuICB0aGlzLnRva2VuQ2hhcig5MSk7XG4gIHRoaXMudG9rZW5DaGFyKDkzKTtcbn1cbmZ1bmN0aW9uIFRTVHVwbGVUeXBlKG5vZGUpIHtcbiAgdGhpcy50b2tlbkNoYXIoOTEpO1xuICB0aGlzLnByaW50TGlzdChub2RlLmVsZW1lbnRUeXBlcywgdGhpcy5zaG91bGRQcmludFRyYWlsaW5nQ29tbWEoXCJdXCIpKTtcbiAgdGhpcy50b2tlbkNoYXIoOTMpO1xufVxuZnVuY3Rpb24gVFNPcHRpb25hbFR5cGUobm9kZSkge1xuICB0aGlzLnByaW50KG5vZGUudHlwZUFubm90YXRpb24pO1xuICB0aGlzLnRva2VuQ2hhcig2Myk7XG59XG5mdW5jdGlvbiBUU1Jlc3RUeXBlKG5vZGUpIHtcbiAgdGhpcy50b2tlbihcIi4uLlwiKTtcbiAgdGhpcy5wcmludChub2RlLnR5cGVBbm5vdGF0aW9uKTtcbn1cbmZ1bmN0aW9uIFRTTmFtZWRUdXBsZU1lbWJlcihub2RlKSB7XG4gIHRoaXMucHJpbnQobm9kZS5sYWJlbCk7XG4gIGlmIChub2RlLm9wdGlvbmFsKSB0aGlzLnRva2VuQ2hhcig2Myk7XG4gIHRoaXMudG9rZW5DaGFyKDU4KTtcbiAgdGhpcy5zcGFjZSgpO1xuICB0aGlzLnByaW50KG5vZGUuZWxlbWVudFR5cGUpO1xufVxuZnVuY3Rpb24gVFNVbmlvblR5cGUobm9kZSkge1xuICB0c1ByaW50VW5pb25PckludGVyc2VjdGlvblR5cGUodGhpcywgbm9kZSwgXCJ8XCIpO1xufVxuZnVuY3Rpb24gVFNJbnRlcnNlY3Rpb25UeXBlKG5vZGUpIHtcbiAgdHNQcmludFVuaW9uT3JJbnRlcnNlY3Rpb25UeXBlKHRoaXMsIG5vZGUsIFwiJlwiKTtcbn1cbmZ1bmN0aW9uIHRzUHJpbnRVbmlvbk9ySW50ZXJzZWN0aW9uVHlwZShwcmludGVyLCBub2RlLCBzZXApIHtcbiAgdmFyIF9wcmludGVyJHRva2VuTWFwO1xuICBsZXQgaGFzTGVhZGluZ1Rva2VuID0gMDtcbiAgaWYgKChfcHJpbnRlciR0b2tlbk1hcCA9IHByaW50ZXIudG9rZW5NYXApICE9IG51bGwgJiYgX3ByaW50ZXIkdG9rZW5NYXAuc3RhcnRNYXRjaGVzKG5vZGUsIHNlcCkpIHtcbiAgICBoYXNMZWFkaW5nVG9rZW4gPSAxO1xuICAgIHByaW50ZXIudG9rZW4oc2VwKTtcbiAgfVxuICBwcmludGVyLnByaW50Sm9pbihub2RlLnR5cGVzLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgZnVuY3Rpb24gKGkpIHtcbiAgICB0aGlzLnNwYWNlKCk7XG4gICAgdGhpcy50b2tlbihzZXAsIHVuZGVmaW5lZCwgaSArIGhhc0xlYWRpbmdUb2tlbik7XG4gICAgdGhpcy5zcGFjZSgpO1xuICB9KTtcbn1cbmZ1bmN0aW9uIFRTQ29uZGl0aW9uYWxUeXBlKG5vZGUpIHtcbiAgdGhpcy5wcmludChub2RlLmNoZWNrVHlwZSk7XG4gIHRoaXMuc3BhY2UoKTtcbiAgdGhpcy53b3JkKFwiZXh0ZW5kc1wiKTtcbiAgdGhpcy5zcGFjZSgpO1xuICB0aGlzLnByaW50KG5vZGUuZXh0ZW5kc1R5cGUpO1xuICB0aGlzLnNwYWNlKCk7XG4gIHRoaXMudG9rZW5DaGFyKDYzKTtcbiAgdGhpcy5zcGFjZSgpO1xuICB0aGlzLnByaW50KG5vZGUudHJ1ZVR5cGUpO1xuICB0aGlzLnNwYWNlKCk7XG4gIHRoaXMudG9rZW5DaGFyKDU4KTtcbiAgdGhpcy5zcGFjZSgpO1xuICB0aGlzLnByaW50KG5vZGUuZmFsc2VUeXBlKTtcbn1cbmZ1bmN0aW9uIFRTSW5mZXJUeXBlKG5vZGUpIHtcbiAgdGhpcy53b3JkKFwiaW5mZXJcIik7XG4gIHRoaXMucHJpbnQobm9kZS50eXBlUGFyYW1ldGVyKTtcbn1cbmZ1bmN0aW9uIFRTUGFyZW50aGVzaXplZFR5cGUobm9kZSkge1xuICB0aGlzLnRva2VuQ2hhcig0MCk7XG4gIHRoaXMucHJpbnQobm9kZS50eXBlQW5ub3RhdGlvbik7XG4gIHRoaXMudG9rZW5DaGFyKDQxKTtcbn1cbmZ1bmN0aW9uIFRTVHlwZU9wZXJhdG9yKG5vZGUpIHtcbiAgdGhpcy53b3JkKG5vZGUub3BlcmF0b3IpO1xuICB0aGlzLnNwYWNlKCk7XG4gIHRoaXMucHJpbnQobm9kZS50eXBlQW5ub3RhdGlvbik7XG59XG5mdW5jdGlvbiBUU0luZGV4ZWRBY2Nlc3NUeXBlKG5vZGUpIHtcbiAgdGhpcy5wcmludChub2RlLm9iamVjdFR5cGUsIHRydWUpO1xuICB0aGlzLnRva2VuQ2hhcig5MSk7XG4gIHRoaXMucHJpbnQobm9kZS5pbmRleFR5cGUpO1xuICB0aGlzLnRva2VuQ2hhcig5Myk7XG59XG5mdW5jdGlvbiBUU01hcHBlZFR5cGUobm9kZSkge1xuICBjb25zdCB7XG4gICAgbmFtZVR5cGUsXG4gICAgb3B0aW9uYWwsXG4gICAgcmVhZG9ubHksXG4gICAgdHlwZUFubm90YXRpb25cbiAgfSA9IG5vZGU7XG4gIHRoaXMudG9rZW5DaGFyKDEyMyk7XG4gIGNvbnN0IGV4aXQgPSB0aGlzLmVudGVyRGVsaW1pdGVkKCk7XG4gIHRoaXMuc3BhY2UoKTtcbiAgaWYgKHJlYWRvbmx5KSB7XG4gICAgdG9rZW5JZlBsdXNNaW51cyh0aGlzLCByZWFkb25seSk7XG4gICAgdGhpcy53b3JkKFwicmVhZG9ubHlcIik7XG4gICAgdGhpcy5zcGFjZSgpO1xuICB9XG4gIHRoaXMudG9rZW5DaGFyKDkxKTtcbiAgdGhpcy53b3JkKG5vZGUudHlwZVBhcmFtZXRlci5uYW1lKTtcbiAgdGhpcy5zcGFjZSgpO1xuICB0aGlzLndvcmQoXCJpblwiKTtcbiAgdGhpcy5zcGFjZSgpO1xuICB0aGlzLnByaW50KG5vZGUudHlwZVBhcmFtZXRlci5jb25zdHJhaW50KTtcbiAgaWYgKG5hbWVUeXBlKSB7XG4gICAgdGhpcy5zcGFjZSgpO1xuICAgIHRoaXMud29yZChcImFzXCIpO1xuICAgIHRoaXMuc3BhY2UoKTtcbiAgICB0aGlzLnByaW50KG5hbWVUeXBlKTtcbiAgfVxuICB0aGlzLnRva2VuQ2hhcig5Myk7XG4gIGlmIChvcHRpb25hbCkge1xuICAgIHRva2VuSWZQbHVzTWludXModGhpcywgb3B0aW9uYWwpO1xuICAgIHRoaXMudG9rZW5DaGFyKDYzKTtcbiAgfVxuICBpZiAodHlwZUFubm90YXRpb24pIHtcbiAgICB0aGlzLnRva2VuQ2hhcig1OCk7XG4gICAgdGhpcy5zcGFjZSgpO1xuICAgIHRoaXMucHJpbnQodHlwZUFubm90YXRpb24pO1xuICB9XG4gIHRoaXMuc3BhY2UoKTtcbiAgZXhpdCgpO1xuICB0aGlzLnRva2VuQ2hhcigxMjUpO1xufVxuZnVuY3Rpb24gdG9rZW5JZlBsdXNNaW51cyhzZWxmLCB0b2spIHtcbiAgaWYgKHRvayAhPT0gdHJ1ZSkge1xuICAgIHNlbGYudG9rZW4odG9rKTtcbiAgfVxufVxuZnVuY3Rpb24gVFNUZW1wbGF0ZUxpdGVyYWxUeXBlKG5vZGUpIHtcbiAgdGhpcy5fcHJpbnRUZW1wbGF0ZShub2RlLCBub2RlLnR5cGVzKTtcbn1cbmZ1bmN0aW9uIFRTTGl0ZXJhbFR5cGUobm9kZSkge1xuICB0aGlzLnByaW50KG5vZGUubGl0ZXJhbCk7XG59XG5mdW5jdGlvbiBUU0NsYXNzSW1wbGVtZW50cyhub2RlKSB7XG4gIHRoaXMucHJpbnQobm9kZS5leHByZXNzaW9uKTtcbiAgdGhpcy5wcmludChub2RlLnR5cGVBcmd1bWVudHMpO1xufVxuZnVuY3Rpb24gVFNJbnRlcmZhY2VEZWNsYXJhdGlvbihub2RlKSB7XG4gIGNvbnN0IHtcbiAgICBkZWNsYXJlLFxuICAgIGlkLFxuICAgIHR5cGVQYXJhbWV0ZXJzLFxuICAgIGV4dGVuZHM6IGV4dGVuZHosXG4gICAgYm9keVxuICB9ID0gbm9kZTtcbiAgaWYgKGRlY2xhcmUpIHtcbiAgICB0aGlzLndvcmQoXCJkZWNsYXJlXCIpO1xuICAgIHRoaXMuc3BhY2UoKTtcbiAgfVxuICB0aGlzLndvcmQoXCJpbnRlcmZhY2VcIik7XG4gIHRoaXMuc3BhY2UoKTtcbiAgdGhpcy5wcmludChpZCk7XG4gIHRoaXMucHJpbnQodHlwZVBhcmFtZXRlcnMpO1xuICBpZiAoZXh0ZW5keiAhPSBudWxsICYmIGV4dGVuZHoubGVuZ3RoKSB7XG4gICAgdGhpcy5zcGFjZSgpO1xuICAgIHRoaXMud29yZChcImV4dGVuZHNcIik7XG4gICAgdGhpcy5zcGFjZSgpO1xuICAgIHRoaXMucHJpbnRMaXN0KGV4dGVuZHopO1xuICB9XG4gIHRoaXMuc3BhY2UoKTtcbiAgdGhpcy5wcmludChib2R5KTtcbn1cbmZ1bmN0aW9uIFRTSW50ZXJmYWNlQm9keShub2RlKSB7XG4gIHByaW50QnJhY2VkKHRoaXMsIG5vZGUsICgpID0+IHRoaXMucHJpbnRKb2luKG5vZGUuYm9keSwgdHJ1ZSwgdHJ1ZSkpO1xufVxuZnVuY3Rpb24gVFNUeXBlQWxpYXNEZWNsYXJhdGlvbihub2RlKSB7XG4gIGNvbnN0IHtcbiAgICBkZWNsYXJlLFxuICAgIGlkLFxuICAgIHR5cGVQYXJhbWV0ZXJzLFxuICAgIHR5cGVBbm5vdGF0aW9uXG4gIH0gPSBub2RlO1xuICBpZiAoZGVjbGFyZSkge1xuICAgIHRoaXMud29yZChcImRlY2xhcmVcIik7XG4gICAgdGhpcy5zcGFjZSgpO1xuICB9XG4gIHRoaXMud29yZChcInR5cGVcIik7XG4gIHRoaXMuc3BhY2UoKTtcbiAgdGhpcy5wcmludChpZCk7XG4gIHRoaXMucHJpbnQodHlwZVBhcmFtZXRlcnMpO1xuICB0aGlzLnNwYWNlKCk7XG4gIHRoaXMudG9rZW5DaGFyKDYxKTtcbiAgdGhpcy5zcGFjZSgpO1xuICB0aGlzLnByaW50KHR5cGVBbm5vdGF0aW9uKTtcbiAgdGhpcy5zZW1pY29sb24oKTtcbn1cbmZ1bmN0aW9uIFRTVHlwZUV4cHJlc3Npb24obm9kZSkge1xuICBjb25zdCB7XG4gICAgdHlwZSxcbiAgICBleHByZXNzaW9uLFxuICAgIHR5cGVBbm5vdGF0aW9uXG4gIH0gPSBub2RlO1xuICB0aGlzLnByaW50KGV4cHJlc3Npb24sIHRydWUpO1xuICB0aGlzLnNwYWNlKCk7XG4gIHRoaXMud29yZCh0eXBlID09PSBcIlRTQXNFeHByZXNzaW9uXCIgPyBcImFzXCIgOiBcInNhdGlzZmllc1wiKTtcbiAgdGhpcy5zcGFjZSgpO1xuICB0aGlzLnByaW50KHR5cGVBbm5vdGF0aW9uKTtcbn1cbmZ1bmN0aW9uIFRTVHlwZUFzc2VydGlvbihub2RlKSB7XG4gIGNvbnN0IHtcbiAgICB0eXBlQW5ub3RhdGlvbixcbiAgICBleHByZXNzaW9uXG4gIH0gPSBub2RlO1xuICB0aGlzLnRva2VuQ2hhcig2MCk7XG4gIHRoaXMucHJpbnQodHlwZUFubm90YXRpb24pO1xuICB0aGlzLnRva2VuQ2hhcig2Mik7XG4gIHRoaXMuc3BhY2UoKTtcbiAgdGhpcy5wcmludChleHByZXNzaW9uKTtcbn1cbmZ1bmN0aW9uIFRTSW5zdGFudGlhdGlvbkV4cHJlc3Npb24obm9kZSkge1xuICB0aGlzLnByaW50KG5vZGUuZXhwcmVzc2lvbik7XG4gIHRoaXMucHJpbnQobm9kZS50eXBlUGFyYW1ldGVycyk7XG59XG5mdW5jdGlvbiBUU0VudW1EZWNsYXJhdGlvbihub2RlKSB7XG4gIGNvbnN0IHtcbiAgICBkZWNsYXJlLFxuICAgIGNvbnN0OiBpc0NvbnN0LFxuICAgIGlkXG4gIH0gPSBub2RlO1xuICBpZiAoZGVjbGFyZSkge1xuICAgIHRoaXMud29yZChcImRlY2xhcmVcIik7XG4gICAgdGhpcy5zcGFjZSgpO1xuICB9XG4gIGlmIChpc0NvbnN0KSB7XG4gICAgdGhpcy53b3JkKFwiY29uc3RcIik7XG4gICAgdGhpcy5zcGFjZSgpO1xuICB9XG4gIHRoaXMud29yZChcImVudW1cIik7XG4gIHRoaXMuc3BhY2UoKTtcbiAgdGhpcy5wcmludChpZCk7XG4gIHRoaXMuc3BhY2UoKTtcbiAgVFNFbnVtQm9keS5jYWxsKHRoaXMsIG5vZGUpO1xufVxuZnVuY3Rpb24gVFNFbnVtQm9keShub2RlKSB7XG4gIHByaW50QnJhY2VkKHRoaXMsIG5vZGUsICgpID0+IHtcbiAgICB2YXIgX3RoaXMkc2hvdWxkUHJpbnRUcmFpO1xuICAgIHJldHVybiB0aGlzLnByaW50TGlzdChub2RlLm1lbWJlcnMsIChfdGhpcyRzaG91bGRQcmludFRyYWkgPSB0aGlzLnNob3VsZFByaW50VHJhaWxpbmdDb21tYShcIn1cIikpICE9IG51bGwgPyBfdGhpcyRzaG91bGRQcmludFRyYWkgOiB0cnVlLCB0cnVlLCB0cnVlKTtcbiAgfSk7XG59XG5mdW5jdGlvbiBUU0VudW1NZW1iZXIobm9kZSkge1xuICBjb25zdCB7XG4gICAgaWQsXG4gICAgaW5pdGlhbGl6ZXJcbiAgfSA9IG5vZGU7XG4gIHRoaXMucHJpbnQoaWQpO1xuICBpZiAoaW5pdGlhbGl6ZXIpIHtcbiAgICB0aGlzLnNwYWNlKCk7XG4gICAgdGhpcy50b2tlbkNoYXIoNjEpO1xuICAgIHRoaXMuc3BhY2UoKTtcbiAgICB0aGlzLnByaW50KGluaXRpYWxpemVyKTtcbiAgfVxufVxuZnVuY3Rpb24gVFNNb2R1bGVEZWNsYXJhdGlvbihub2RlKSB7XG4gIGNvbnN0IHtcbiAgICBkZWNsYXJlLFxuICAgIGlkLFxuICAgIGtpbmRcbiAgfSA9IG5vZGU7XG4gIGlmIChkZWNsYXJlKSB7XG4gICAgdGhpcy53b3JkKFwiZGVjbGFyZVwiKTtcbiAgICB0aGlzLnNwYWNlKCk7XG4gIH1cbiAgaWYgKCFub2RlLmdsb2JhbCkge1xuICAgIHRoaXMud29yZChraW5kICE9IG51bGwgPyBraW5kIDogaWQudHlwZSA9PT0gXCJJZGVudGlmaWVyXCIgPyBcIm5hbWVzcGFjZVwiIDogXCJtb2R1bGVcIik7XG4gICAgdGhpcy5zcGFjZSgpO1xuICB9XG4gIHRoaXMucHJpbnQoaWQpO1xuICBpZiAoIW5vZGUuYm9keSkge1xuICAgIHRoaXMuc2VtaWNvbG9uKCk7XG4gICAgcmV0dXJuO1xuICB9XG4gIGxldCBib2R5ID0gbm9kZS5ib2R5O1xuICB3aGlsZSAoYm9keS50eXBlID09PSBcIlRTTW9kdWxlRGVjbGFyYXRpb25cIikge1xuICAgIHRoaXMudG9rZW5DaGFyKDQ2KTtcbiAgICB0aGlzLnByaW50KGJvZHkuaWQpO1xuICAgIGJvZHkgPSBib2R5LmJvZHk7XG4gIH1cbiAgdGhpcy5zcGFjZSgpO1xuICB0aGlzLnByaW50KGJvZHkpO1xufVxuZnVuY3Rpb24gVFNNb2R1bGVCbG9jayhub2RlKSB7XG4gIHByaW50QnJhY2VkKHRoaXMsIG5vZGUsICgpID0+IHRoaXMucHJpbnRTZXF1ZW5jZShub2RlLmJvZHksIHRydWUpKTtcbn1cbmZ1bmN0aW9uIFRTSW1wb3J0VHlwZShub2RlKSB7XG4gIGNvbnN0IHtcbiAgICBxdWFsaWZpZXIsXG4gICAgb3B0aW9uc1xuICB9ID0gbm9kZTtcbiAgdGhpcy53b3JkKFwiaW1wb3J0XCIpO1xuICB0aGlzLnRva2VuQ2hhcig0MCk7XG4gIHRoaXMucHJpbnQobm9kZS5hcmd1bWVudCk7XG4gIGlmIChvcHRpb25zKSB7XG4gICAgdGhpcy50b2tlbkNoYXIoNDQpO1xuICAgIHRoaXMucHJpbnQob3B0aW9ucyk7XG4gIH1cbiAgdGhpcy50b2tlbkNoYXIoNDEpO1xuICBpZiAocXVhbGlmaWVyKSB7XG4gICAgdGhpcy50b2tlbkNoYXIoNDYpO1xuICAgIHRoaXMucHJpbnQocXVhbGlmaWVyKTtcbiAgfVxuICBjb25zdCB0eXBlQXJndW1lbnRzID0gbm9kZS50eXBlUGFyYW1ldGVycztcbiAgaWYgKHR5cGVBcmd1bWVudHMpIHtcbiAgICB0aGlzLnByaW50KHR5cGVBcmd1bWVudHMpO1xuICB9XG59XG5mdW5jdGlvbiBUU0ltcG9ydEVxdWFsc0RlY2xhcmF0aW9uKG5vZGUpIHtcbiAgY29uc3Qge1xuICAgIGlkLFxuICAgIG1vZHVsZVJlZmVyZW5jZVxuICB9ID0gbm9kZTtcbiAgaWYgKG5vZGUuaXNFeHBvcnQpIHtcbiAgICB0aGlzLndvcmQoXCJleHBvcnRcIik7XG4gICAgdGhpcy5zcGFjZSgpO1xuICB9XG4gIHRoaXMud29yZChcImltcG9ydFwiKTtcbiAgdGhpcy5zcGFjZSgpO1xuICB0aGlzLnByaW50KGlkKTtcbiAgdGhpcy5zcGFjZSgpO1xuICB0aGlzLnRva2VuQ2hhcig2MSk7XG4gIHRoaXMuc3BhY2UoKTtcbiAgdGhpcy5wcmludChtb2R1bGVSZWZlcmVuY2UpO1xuICB0aGlzLnNlbWljb2xvbigpO1xufVxuZnVuY3Rpb24gVFNFeHRlcm5hbE1vZHVsZVJlZmVyZW5jZShub2RlKSB7XG4gIHRoaXMudG9rZW4oXCJyZXF1aXJlKFwiKTtcbiAgdGhpcy5wcmludChub2RlLmV4cHJlc3Npb24pO1xuICB0aGlzLnRva2VuQ2hhcig0MSk7XG59XG5mdW5jdGlvbiBUU05vbk51bGxFeHByZXNzaW9uKG5vZGUpIHtcbiAgdGhpcy5wcmludChub2RlLmV4cHJlc3Npb24pO1xuICB0aGlzLnRva2VuQ2hhcigzMyk7XG59XG5mdW5jdGlvbiBUU0V4cG9ydEFzc2lnbm1lbnQobm9kZSkge1xuICB0aGlzLndvcmQoXCJleHBvcnRcIik7XG4gIHRoaXMuc3BhY2UoKTtcbiAgdGhpcy50b2tlbkNoYXIoNjEpO1xuICB0aGlzLnNwYWNlKCk7XG4gIHRoaXMucHJpbnQobm9kZS5leHByZXNzaW9uKTtcbiAgdGhpcy5zZW1pY29sb24oKTtcbn1cbmZ1bmN0aW9uIFRTTmFtZXNwYWNlRXhwb3J0RGVjbGFyYXRpb24obm9kZSkge1xuICB0aGlzLndvcmQoXCJleHBvcnRcIik7XG4gIHRoaXMuc3BhY2UoKTtcbiAgdGhpcy53b3JkKFwiYXNcIik7XG4gIHRoaXMuc3BhY2UoKTtcbiAgdGhpcy53b3JkKFwibmFtZXNwYWNlXCIpO1xuICB0aGlzLnNwYWNlKCk7XG4gIHRoaXMucHJpbnQobm9kZS5pZCk7XG4gIHRoaXMuc2VtaWNvbG9uKCk7XG59XG5mdW5jdGlvbiB0c1ByaW50U2lnbmF0dXJlRGVjbGFyYXRpb25CYXNlKG5vZGUpIHtcbiAgY29uc3Qge1xuICAgIHR5cGVQYXJhbWV0ZXJzXG4gIH0gPSBub2RlO1xuICBjb25zdCBwYXJhbWV0ZXJzID0gbm9kZS5wYXJhbWV0ZXJzO1xuICB0aGlzLnByaW50KHR5cGVQYXJhbWV0ZXJzKTtcbiAgdGhpcy50b2tlbkNoYXIoNDApO1xuICB0aGlzLl9wYXJhbWV0ZXJzKHBhcmFtZXRlcnMsIFwiKVwiKTtcbiAgY29uc3QgcmV0dXJuVHlwZSA9IG5vZGUudHlwZUFubm90YXRpb247XG4gIHRoaXMucHJpbnQocmV0dXJuVHlwZSk7XG59XG5mdW5jdGlvbiB0c1ByaW50Q2xhc3NNZW1iZXJNb2RpZmllcnMobm9kZSkge1xuICBjb25zdCBpc1ByaXZhdGVGaWVsZCA9IG5vZGUudHlwZSA9PT0gXCJDbGFzc1ByaXZhdGVQcm9wZXJ0eVwiO1xuICBjb25zdCBpc1B1YmxpY0ZpZWxkID0gbm9kZS50eXBlID09PSBcIkNsYXNzQWNjZXNzb3JQcm9wZXJ0eVwiIHx8IG5vZGUudHlwZSA9PT0gXCJDbGFzc1Byb3BlcnR5XCI7XG4gIHByaW50TW9kaWZpZXJzTGlzdCh0aGlzLCBub2RlLCBbaXNQdWJsaWNGaWVsZCAmJiBub2RlLmRlY2xhcmUgJiYgXCJkZWNsYXJlXCIsICFpc1ByaXZhdGVGaWVsZCAmJiBub2RlLmFjY2Vzc2liaWxpdHldKTtcbiAgaWYgKG5vZGUuc3RhdGljKSB7XG4gICAgdGhpcy53b3JkKFwic3RhdGljXCIpO1xuICAgIHRoaXMuc3BhY2UoKTtcbiAgfVxuICBwcmludE1vZGlmaWVyc0xpc3QodGhpcywgbm9kZSwgWyFpc1ByaXZhdGVGaWVsZCAmJiBub2RlLmFic3RyYWN0ICYmIFwiYWJzdHJhY3RcIiwgIWlzUHJpdmF0ZUZpZWxkICYmIG5vZGUub3ZlcnJpZGUgJiYgXCJvdmVycmlkZVwiLCAoaXNQdWJsaWNGaWVsZCB8fCBpc1ByaXZhdGVGaWVsZCkgJiYgbm9kZS5yZWFkb25seSAmJiBcInJlYWRvbmx5XCJdKTtcbn1cbmZ1bmN0aW9uIHByaW50QnJhY2VkKHByaW50ZXIsIG5vZGUsIGNiKSB7XG4gIHByaW50ZXIudG9rZW4oXCJ7XCIpO1xuICBjb25zdCBleGl0ID0gcHJpbnRlci5lbnRlckRlbGltaXRlZCgpO1xuICBjYigpO1xuICBleGl0KCk7XG4gIHByaW50ZXIucmlnaHRCcmFjZShub2RlKTtcbn1cbmZ1bmN0aW9uIHByaW50TW9kaWZpZXJzTGlzdChwcmludGVyLCBub2RlLCBtb2RpZmllcnMpIHtcbiAgdmFyIF9wcmludGVyJHRva2VuTWFwMjtcbiAgY29uc3QgbW9kaWZpZXJzU2V0ID0gbmV3IFNldCgpO1xuICBmb3IgKGNvbnN0IG1vZGlmaWVyIG9mIG1vZGlmaWVycykge1xuICAgIGlmIChtb2RpZmllcikgbW9kaWZpZXJzU2V0LmFkZChtb2RpZmllcik7XG4gIH1cbiAgKF9wcmludGVyJHRva2VuTWFwMiA9IHByaW50ZXIudG9rZW5NYXApID09IG51bGwgfHwgX3ByaW50ZXIkdG9rZW5NYXAyLmZpbmQobm9kZSwgdG9rID0+IHtcbiAgICBpZiAobW9kaWZpZXJzU2V0Lmhhcyh0b2sudmFsdWUpKSB7XG4gICAgICBwcmludGVyLnRva2VuKHRvay52YWx1ZSk7XG4gICAgICBwcmludGVyLnNwYWNlKCk7XG4gICAgICBtb2RpZmllcnNTZXQuZGVsZXRlKHRvay52YWx1ZSk7XG4gICAgICByZXR1cm4gbW9kaWZpZXJzU2V0LnNpemUgPT09IDA7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfSk7XG4gIGZvciAoY29uc3QgbW9kaWZpZXIgb2YgbW9kaWZpZXJzU2V0KSB7XG4gICAgcHJpbnRlci53b3JkKG1vZGlmaWVyKTtcbiAgICBwcmludGVyLnNwYWNlKCk7XG4gIH1cbn1cblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dHlwZXNjcmlwdC5qcy5tYXBcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@babel/generator/lib/generators/typescript.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@babel/generator/lib/index.js":
/*!****************************************************!*\
  !*** ./node_modules/@babel/generator/lib/index.js ***!
  \****************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports[\"default\"] = void 0;\nexports.generate = generate;\nvar _sourceMap = __webpack_require__(/*! ./source-map.js */ \"(ssr)/./node_modules/@babel/generator/lib/source-map.js\");\nvar _printer = __webpack_require__(/*! ./printer.js */ \"(ssr)/./node_modules/@babel/generator/lib/printer.js\");\nfunction normalizeOptions(code, opts, ast) {\n  var _opts$recordAndTupleS;\n  if (opts.experimental_preserveFormat) {\n    if (typeof code !== \"string\") {\n      throw new Error(\"`experimental_preserveFormat` requires the original `code` to be passed to @babel/generator as a string\");\n    }\n    if (!opts.retainLines) {\n      throw new Error(\"`experimental_preserveFormat` requires `retainLines` to be set to `true`\");\n    }\n    if (opts.compact && opts.compact !== \"auto\") {\n      throw new Error(\"`experimental_preserveFormat` is not compatible with the `compact` option\");\n    }\n    if (opts.minified) {\n      throw new Error(\"`experimental_preserveFormat` is not compatible with the `minified` option\");\n    }\n    if (opts.jsescOption) {\n      throw new Error(\"`experimental_preserveFormat` is not compatible with the `jsescOption` option\");\n    }\n    if (!Array.isArray(ast.tokens)) {\n      throw new Error(\"`experimental_preserveFormat` requires the AST to have attached the token of the input code. Make sure to enable the `tokens: true` parser option.\");\n    }\n  }\n  const format = {\n    auxiliaryCommentBefore: opts.auxiliaryCommentBefore,\n    auxiliaryCommentAfter: opts.auxiliaryCommentAfter,\n    shouldPrintComment: opts.shouldPrintComment,\n    preserveFormat: opts.experimental_preserveFormat,\n    retainLines: opts.retainLines,\n    retainFunctionParens: opts.retainFunctionParens,\n    comments: opts.comments == null || opts.comments,\n    compact: opts.compact,\n    minified: opts.minified,\n    concise: opts.concise,\n    indent: {\n      adjustMultilineComment: true,\n      style: \"  \"\n    },\n    jsescOption: Object.assign({\n      quotes: \"double\",\n      wrap: true,\n      minimal: false\n    }, opts.jsescOption),\n    topicToken: opts.topicToken\n  };\n  format.decoratorsBeforeExport = opts.decoratorsBeforeExport;\n  format.jsescOption.json = opts.jsonCompatibleStrings;\n  format.recordAndTupleSyntaxType = (_opts$recordAndTupleS = opts.recordAndTupleSyntaxType) != null ? _opts$recordAndTupleS : \"hash\";\n  format.importAttributesKeyword = opts.importAttributesKeyword;\n  if (format.minified) {\n    format.compact = true;\n    format.shouldPrintComment = format.shouldPrintComment || (() => format.comments);\n  } else {\n    format.shouldPrintComment = format.shouldPrintComment || (value => format.comments || value.includes(\"@license\") || value.includes(\"@preserve\"));\n  }\n  if (format.compact === \"auto\") {\n    format.compact = typeof code === \"string\" && code.length > 500000;\n    if (format.compact) {\n      console.error(\"[BABEL] Note: The code generator has deoptimised the styling of \" + `${opts.filename} as it exceeds the max of ${\"500KB\"}.`);\n    }\n  }\n  if (format.compact || format.preserveFormat) {\n    format.indent.adjustMultilineComment = false;\n  }\n  const {\n    auxiliaryCommentBefore,\n    auxiliaryCommentAfter,\n    shouldPrintComment\n  } = format;\n  if (auxiliaryCommentBefore && !shouldPrintComment(auxiliaryCommentBefore)) {\n    format.auxiliaryCommentBefore = undefined;\n  }\n  if (auxiliaryCommentAfter && !shouldPrintComment(auxiliaryCommentAfter)) {\n    format.auxiliaryCommentAfter = undefined;\n  }\n  return format;\n}\nexports.CodeGenerator = class CodeGenerator {\n  constructor(ast, opts = {}, code) {\n    this._ast = void 0;\n    this._format = void 0;\n    this._map = void 0;\n    this._ast = ast;\n    this._format = normalizeOptions(code, opts, ast);\n    this._map = opts.sourceMaps ? new _sourceMap.default(opts, code) : null;\n  }\n  generate() {\n    const printer = new _printer.default(this._format, this._map);\n    return printer.generate(this._ast);\n  }\n};\nfunction generate(ast, opts = {}, code) {\n  const format = normalizeOptions(code, opts, ast);\n  const map = opts.sourceMaps ? new _sourceMap.default(opts, code) : null;\n  const printer = new _printer.default(format, map, ast.tokens, typeof code === \"string\" ? code : null);\n  return printer.generate(ast);\n}\nvar _default = exports[\"default\"] = generate;\n\n//# sourceMappingURL=index.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGJhYmVsL2dlbmVyYXRvci9saWIvaW5kZXguanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWIsOENBQTZDO0FBQzdDO0FBQ0EsQ0FBQyxFQUFDO0FBQ0Ysa0JBQWU7QUFDZixnQkFBZ0I7QUFDaEIsaUJBQWlCLG1CQUFPLENBQUMsZ0ZBQWlCO0FBQzFDLGVBQWUsbUJBQU8sQ0FBQywwRUFBYztBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0RkFBNEYsZUFBZSwyQkFBMkIsUUFBUTtBQUM5STtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQiw0QkFBNEI7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLGtCQUFlOztBQUU5QiIsInNvdXJjZXMiOlsid2VicGFjazovL3JlcG8tdmlzdWFsaXplci8uL25vZGVfbW9kdWxlcy9AYmFiZWwvZ2VuZXJhdG9yL2xpYi9pbmRleC5qcz81MDliIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5kZWZhdWx0ID0gdm9pZCAwO1xuZXhwb3J0cy5nZW5lcmF0ZSA9IGdlbmVyYXRlO1xudmFyIF9zb3VyY2VNYXAgPSByZXF1aXJlKFwiLi9zb3VyY2UtbWFwLmpzXCIpO1xudmFyIF9wcmludGVyID0gcmVxdWlyZShcIi4vcHJpbnRlci5qc1wiKTtcbmZ1bmN0aW9uIG5vcm1hbGl6ZU9wdGlvbnMoY29kZSwgb3B0cywgYXN0KSB7XG4gIHZhciBfb3B0cyRyZWNvcmRBbmRUdXBsZVM7XG4gIGlmIChvcHRzLmV4cGVyaW1lbnRhbF9wcmVzZXJ2ZUZvcm1hdCkge1xuICAgIGlmICh0eXBlb2YgY29kZSAhPT0gXCJzdHJpbmdcIikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiYGV4cGVyaW1lbnRhbF9wcmVzZXJ2ZUZvcm1hdGAgcmVxdWlyZXMgdGhlIG9yaWdpbmFsIGBjb2RlYCB0byBiZSBwYXNzZWQgdG8gQGJhYmVsL2dlbmVyYXRvciBhcyBhIHN0cmluZ1wiKTtcbiAgICB9XG4gICAgaWYgKCFvcHRzLnJldGFpbkxpbmVzKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJgZXhwZXJpbWVudGFsX3ByZXNlcnZlRm9ybWF0YCByZXF1aXJlcyBgcmV0YWluTGluZXNgIHRvIGJlIHNldCB0byBgdHJ1ZWBcIik7XG4gICAgfVxuICAgIGlmIChvcHRzLmNvbXBhY3QgJiYgb3B0cy5jb21wYWN0ICE9PSBcImF1dG9cIikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiYGV4cGVyaW1lbnRhbF9wcmVzZXJ2ZUZvcm1hdGAgaXMgbm90IGNvbXBhdGlibGUgd2l0aCB0aGUgYGNvbXBhY3RgIG9wdGlvblwiKTtcbiAgICB9XG4gICAgaWYgKG9wdHMubWluaWZpZWQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcImBleHBlcmltZW50YWxfcHJlc2VydmVGb3JtYXRgIGlzIG5vdCBjb21wYXRpYmxlIHdpdGggdGhlIGBtaW5pZmllZGAgb3B0aW9uXCIpO1xuICAgIH1cbiAgICBpZiAob3B0cy5qc2VzY09wdGlvbikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiYGV4cGVyaW1lbnRhbF9wcmVzZXJ2ZUZvcm1hdGAgaXMgbm90IGNvbXBhdGlibGUgd2l0aCB0aGUgYGpzZXNjT3B0aW9uYCBvcHRpb25cIik7XG4gICAgfVxuICAgIGlmICghQXJyYXkuaXNBcnJheShhc3QudG9rZW5zKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiYGV4cGVyaW1lbnRhbF9wcmVzZXJ2ZUZvcm1hdGAgcmVxdWlyZXMgdGhlIEFTVCB0byBoYXZlIGF0dGFjaGVkIHRoZSB0b2tlbiBvZiB0aGUgaW5wdXQgY29kZS4gTWFrZSBzdXJlIHRvIGVuYWJsZSB0aGUgYHRva2VuczogdHJ1ZWAgcGFyc2VyIG9wdGlvbi5cIik7XG4gICAgfVxuICB9XG4gIGNvbnN0IGZvcm1hdCA9IHtcbiAgICBhdXhpbGlhcnlDb21tZW50QmVmb3JlOiBvcHRzLmF1eGlsaWFyeUNvbW1lbnRCZWZvcmUsXG4gICAgYXV4aWxpYXJ5Q29tbWVudEFmdGVyOiBvcHRzLmF1eGlsaWFyeUNvbW1lbnRBZnRlcixcbiAgICBzaG91bGRQcmludENvbW1lbnQ6IG9wdHMuc2hvdWxkUHJpbnRDb21tZW50LFxuICAgIHByZXNlcnZlRm9ybWF0OiBvcHRzLmV4cGVyaW1lbnRhbF9wcmVzZXJ2ZUZvcm1hdCxcbiAgICByZXRhaW5MaW5lczogb3B0cy5yZXRhaW5MaW5lcyxcbiAgICByZXRhaW5GdW5jdGlvblBhcmVuczogb3B0cy5yZXRhaW5GdW5jdGlvblBhcmVucyxcbiAgICBjb21tZW50czogb3B0cy5jb21tZW50cyA9PSBudWxsIHx8IG9wdHMuY29tbWVudHMsXG4gICAgY29tcGFjdDogb3B0cy5jb21wYWN0LFxuICAgIG1pbmlmaWVkOiBvcHRzLm1pbmlmaWVkLFxuICAgIGNvbmNpc2U6IG9wdHMuY29uY2lzZSxcbiAgICBpbmRlbnQ6IHtcbiAgICAgIGFkanVzdE11bHRpbGluZUNvbW1lbnQ6IHRydWUsXG4gICAgICBzdHlsZTogXCIgIFwiXG4gICAgfSxcbiAgICBqc2VzY09wdGlvbjogT2JqZWN0LmFzc2lnbih7XG4gICAgICBxdW90ZXM6IFwiZG91YmxlXCIsXG4gICAgICB3cmFwOiB0cnVlLFxuICAgICAgbWluaW1hbDogZmFsc2VcbiAgICB9LCBvcHRzLmpzZXNjT3B0aW9uKSxcbiAgICB0b3BpY1Rva2VuOiBvcHRzLnRvcGljVG9rZW5cbiAgfTtcbiAgZm9ybWF0LmRlY29yYXRvcnNCZWZvcmVFeHBvcnQgPSBvcHRzLmRlY29yYXRvcnNCZWZvcmVFeHBvcnQ7XG4gIGZvcm1hdC5qc2VzY09wdGlvbi5qc29uID0gb3B0cy5qc29uQ29tcGF0aWJsZVN0cmluZ3M7XG4gIGZvcm1hdC5yZWNvcmRBbmRUdXBsZVN5bnRheFR5cGUgPSAoX29wdHMkcmVjb3JkQW5kVHVwbGVTID0gb3B0cy5yZWNvcmRBbmRUdXBsZVN5bnRheFR5cGUpICE9IG51bGwgPyBfb3B0cyRyZWNvcmRBbmRUdXBsZVMgOiBcImhhc2hcIjtcbiAgZm9ybWF0LmltcG9ydEF0dHJpYnV0ZXNLZXl3b3JkID0gb3B0cy5pbXBvcnRBdHRyaWJ1dGVzS2V5d29yZDtcbiAgaWYgKGZvcm1hdC5taW5pZmllZCkge1xuICAgIGZvcm1hdC5jb21wYWN0ID0gdHJ1ZTtcbiAgICBmb3JtYXQuc2hvdWxkUHJpbnRDb21tZW50ID0gZm9ybWF0LnNob3VsZFByaW50Q29tbWVudCB8fCAoKCkgPT4gZm9ybWF0LmNvbW1lbnRzKTtcbiAgfSBlbHNlIHtcbiAgICBmb3JtYXQuc2hvdWxkUHJpbnRDb21tZW50ID0gZm9ybWF0LnNob3VsZFByaW50Q29tbWVudCB8fCAodmFsdWUgPT4gZm9ybWF0LmNvbW1lbnRzIHx8IHZhbHVlLmluY2x1ZGVzKFwiQGxpY2Vuc2VcIikgfHwgdmFsdWUuaW5jbHVkZXMoXCJAcHJlc2VydmVcIikpO1xuICB9XG4gIGlmIChmb3JtYXQuY29tcGFjdCA9PT0gXCJhdXRvXCIpIHtcbiAgICBmb3JtYXQuY29tcGFjdCA9IHR5cGVvZiBjb2RlID09PSBcInN0cmluZ1wiICYmIGNvZGUubGVuZ3RoID4gNTAwMDAwO1xuICAgIGlmIChmb3JtYXQuY29tcGFjdCkge1xuICAgICAgY29uc29sZS5lcnJvcihcIltCQUJFTF0gTm90ZTogVGhlIGNvZGUgZ2VuZXJhdG9yIGhhcyBkZW9wdGltaXNlZCB0aGUgc3R5bGluZyBvZiBcIiArIGAke29wdHMuZmlsZW5hbWV9IGFzIGl0IGV4Y2VlZHMgdGhlIG1heCBvZiAke1wiNTAwS0JcIn0uYCk7XG4gICAgfVxuICB9XG4gIGlmIChmb3JtYXQuY29tcGFjdCB8fCBmb3JtYXQucHJlc2VydmVGb3JtYXQpIHtcbiAgICBmb3JtYXQuaW5kZW50LmFkanVzdE11bHRpbGluZUNvbW1lbnQgPSBmYWxzZTtcbiAgfVxuICBjb25zdCB7XG4gICAgYXV4aWxpYXJ5Q29tbWVudEJlZm9yZSxcbiAgICBhdXhpbGlhcnlDb21tZW50QWZ0ZXIsXG4gICAgc2hvdWxkUHJpbnRDb21tZW50XG4gIH0gPSBmb3JtYXQ7XG4gIGlmIChhdXhpbGlhcnlDb21tZW50QmVmb3JlICYmICFzaG91bGRQcmludENvbW1lbnQoYXV4aWxpYXJ5Q29tbWVudEJlZm9yZSkpIHtcbiAgICBmb3JtYXQuYXV4aWxpYXJ5Q29tbWVudEJlZm9yZSA9IHVuZGVmaW5lZDtcbiAgfVxuICBpZiAoYXV4aWxpYXJ5Q29tbWVudEFmdGVyICYmICFzaG91bGRQcmludENvbW1lbnQoYXV4aWxpYXJ5Q29tbWVudEFmdGVyKSkge1xuICAgIGZvcm1hdC5hdXhpbGlhcnlDb21tZW50QWZ0ZXIgPSB1bmRlZmluZWQ7XG4gIH1cbiAgcmV0dXJuIGZvcm1hdDtcbn1cbmV4cG9ydHMuQ29kZUdlbmVyYXRvciA9IGNsYXNzIENvZGVHZW5lcmF0b3Ige1xuICBjb25zdHJ1Y3Rvcihhc3QsIG9wdHMgPSB7fSwgY29kZSkge1xuICAgIHRoaXMuX2FzdCA9IHZvaWQgMDtcbiAgICB0aGlzLl9mb3JtYXQgPSB2b2lkIDA7XG4gICAgdGhpcy5fbWFwID0gdm9pZCAwO1xuICAgIHRoaXMuX2FzdCA9IGFzdDtcbiAgICB0aGlzLl9mb3JtYXQgPSBub3JtYWxpemVPcHRpb25zKGNvZGUsIG9wdHMsIGFzdCk7XG4gICAgdGhpcy5fbWFwID0gb3B0cy5zb3VyY2VNYXBzID8gbmV3IF9zb3VyY2VNYXAuZGVmYXVsdChvcHRzLCBjb2RlKSA6IG51bGw7XG4gIH1cbiAgZ2VuZXJhdGUoKSB7XG4gICAgY29uc3QgcHJpbnRlciA9IG5ldyBfcHJpbnRlci5kZWZhdWx0KHRoaXMuX2Zvcm1hdCwgdGhpcy5fbWFwKTtcbiAgICByZXR1cm4gcHJpbnRlci5nZW5lcmF0ZSh0aGlzLl9hc3QpO1xuICB9XG59O1xuZnVuY3Rpb24gZ2VuZXJhdGUoYXN0LCBvcHRzID0ge30sIGNvZGUpIHtcbiAgY29uc3QgZm9ybWF0ID0gbm9ybWFsaXplT3B0aW9ucyhjb2RlLCBvcHRzLCBhc3QpO1xuICBjb25zdCBtYXAgPSBvcHRzLnNvdXJjZU1hcHMgPyBuZXcgX3NvdXJjZU1hcC5kZWZhdWx0KG9wdHMsIGNvZGUpIDogbnVsbDtcbiAgY29uc3QgcHJpbnRlciA9IG5ldyBfcHJpbnRlci5kZWZhdWx0KGZvcm1hdCwgbWFwLCBhc3QudG9rZW5zLCB0eXBlb2YgY29kZSA9PT0gXCJzdHJpbmdcIiA/IGNvZGUgOiBudWxsKTtcbiAgcmV0dXJuIHByaW50ZXIuZ2VuZXJhdGUoYXN0KTtcbn1cbnZhciBfZGVmYXVsdCA9IGV4cG9ydHMuZGVmYXVsdCA9IGdlbmVyYXRlO1xuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXBcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@babel/generator/lib/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@babel/generator/lib/node/index.js":
/*!*********************************************************!*\
  !*** ./node_modules/@babel/generator/lib/node/index.js ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports.TokenContext = void 0;\nexports.isLastChild = isLastChild;\nexports.needsParens = needsParens;\nexports.needsWhitespace = needsWhitespace;\nexports.needsWhitespaceAfter = needsWhitespaceAfter;\nexports.needsWhitespaceBefore = needsWhitespaceBefore;\nvar whitespace = __webpack_require__(/*! ./whitespace.js */ \"(ssr)/./node_modules/@babel/generator/lib/node/whitespace.js\");\nvar parens = __webpack_require__(/*! ./parentheses.js */ \"(ssr)/./node_modules/@babel/generator/lib/node/parentheses.js\");\nvar _t = __webpack_require__(/*! @babel/types */ \"(ssr)/./node_modules/@babel/types/lib/index.js\");\nconst {\n  FLIPPED_ALIAS_KEYS,\n  VISITOR_KEYS,\n  isCallExpression,\n  isDecorator,\n  isExpressionStatement,\n  isMemberExpression,\n  isNewExpression,\n  isParenthesizedExpression\n} = _t;\nconst TokenContext = exports.TokenContext = {\n  normal: 0,\n  expressionStatement: 1,\n  arrowBody: 2,\n  exportDefault: 4,\n  arrowFlowReturnType: 8,\n  forInitHead: 16,\n  forInHead: 32,\n  forOfHead: 64,\n  forInOrInitHeadAccumulate: 128,\n  forInOrInitHeadAccumulatePassThroughMask: 128\n};\nfunction expandAliases(obj) {\n  const map = new Map();\n  function add(type, func) {\n    const fn = map.get(type);\n    map.set(type, fn ? function (node, parent, stack, getRawIdentifier) {\n      var _fn;\n      return (_fn = fn(node, parent, stack, getRawIdentifier)) != null ? _fn : func(node, parent, stack, getRawIdentifier);\n    } : func);\n  }\n  for (const type of Object.keys(obj)) {\n    const aliases = FLIPPED_ALIAS_KEYS[type];\n    if (aliases) {\n      for (const alias of aliases) {\n        add(alias, obj[type]);\n      }\n    } else {\n      add(type, obj[type]);\n    }\n  }\n  return map;\n}\nconst expandedParens = expandAliases(parens);\nconst expandedWhitespaceNodes = expandAliases(whitespace.nodes);\nfunction isOrHasCallExpression(node) {\n  if (isCallExpression(node)) {\n    return true;\n  }\n  return isMemberExpression(node) && isOrHasCallExpression(node.object);\n}\nfunction needsWhitespace(node, parent, type) {\n  var _expandedWhitespaceNo;\n  if (!node) return false;\n  if (isExpressionStatement(node)) {\n    node = node.expression;\n  }\n  const flag = (_expandedWhitespaceNo = expandedWhitespaceNodes.get(node.type)) == null ? void 0 : _expandedWhitespaceNo(node, parent);\n  if (typeof flag === \"number\") {\n    return (flag & type) !== 0;\n  }\n  return false;\n}\nfunction needsWhitespaceBefore(node, parent) {\n  return needsWhitespace(node, parent, 1);\n}\nfunction needsWhitespaceAfter(node, parent) {\n  return needsWhitespace(node, parent, 2);\n}\nfunction needsParens(node, parent, tokenContext, getRawIdentifier) {\n  var _expandedParens$get;\n  if (!parent) return false;\n  if (isNewExpression(parent) && parent.callee === node) {\n    if (isOrHasCallExpression(node)) return true;\n  }\n  if (isDecorator(parent)) {\n    return !isDecoratorMemberExpression(node) && !(isCallExpression(node) && isDecoratorMemberExpression(node.callee)) && !isParenthesizedExpression(node);\n  }\n  return ((_expandedParens$get = expandedParens.get(node.type)) == null ? void 0 : _expandedParens$get(node, parent, tokenContext, getRawIdentifier)) || false;\n}\nfunction isDecoratorMemberExpression(node) {\n  switch (node.type) {\n    case \"Identifier\":\n      return true;\n    case \"MemberExpression\":\n      return !node.computed && node.property.type === \"Identifier\" && isDecoratorMemberExpression(node.object);\n    default:\n      return false;\n  }\n}\nfunction isLastChild(parent, child) {\n  const visitorKeys = VISITOR_KEYS[parent.type];\n  for (let i = visitorKeys.length - 1; i >= 0; i--) {\n    const val = parent[visitorKeys[i]];\n    if (val === child) {\n      return true;\n    } else if (Array.isArray(val)) {\n      let j = val.length - 1;\n      while (j >= 0 && val[j] === null) j--;\n      return j >= 0 && val[j] === child;\n    } else if (val) {\n      return false;\n    }\n  }\n  return false;\n}\n\n//# sourceMappingURL=index.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGJhYmVsL2dlbmVyYXRvci9saWIvbm9kZS9pbmRleC5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYiw4Q0FBNkM7QUFDN0M7QUFDQSxDQUFDLEVBQUM7QUFDRixvQkFBb0I7QUFDcEIsbUJBQW1CO0FBQ25CLG1CQUFtQjtBQUNuQix1QkFBdUI7QUFDdkIsNEJBQTRCO0FBQzVCLDZCQUE2QjtBQUM3QixpQkFBaUIsbUJBQU8sQ0FBQyxxRkFBaUI7QUFDMUMsYUFBYSxtQkFBTyxDQUFDLHVGQUFrQjtBQUN2QyxTQUFTLG1CQUFPLENBQUMsb0VBQWM7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGLHFCQUFxQixvQkFBb0I7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1QyxRQUFRO0FBQy9DO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSIsInNvdXJjZXMiOlsid2VicGFjazovL3JlcG8tdmlzdWFsaXplci8uL25vZGVfbW9kdWxlcy9AYmFiZWwvZ2VuZXJhdG9yL2xpYi9ub2RlL2luZGV4LmpzP2RkNzIiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLlRva2VuQ29udGV4dCA9IHZvaWQgMDtcbmV4cG9ydHMuaXNMYXN0Q2hpbGQgPSBpc0xhc3RDaGlsZDtcbmV4cG9ydHMubmVlZHNQYXJlbnMgPSBuZWVkc1BhcmVucztcbmV4cG9ydHMubmVlZHNXaGl0ZXNwYWNlID0gbmVlZHNXaGl0ZXNwYWNlO1xuZXhwb3J0cy5uZWVkc1doaXRlc3BhY2VBZnRlciA9IG5lZWRzV2hpdGVzcGFjZUFmdGVyO1xuZXhwb3J0cy5uZWVkc1doaXRlc3BhY2VCZWZvcmUgPSBuZWVkc1doaXRlc3BhY2VCZWZvcmU7XG52YXIgd2hpdGVzcGFjZSA9IHJlcXVpcmUoXCIuL3doaXRlc3BhY2UuanNcIik7XG52YXIgcGFyZW5zID0gcmVxdWlyZShcIi4vcGFyZW50aGVzZXMuanNcIik7XG52YXIgX3QgPSByZXF1aXJlKFwiQGJhYmVsL3R5cGVzXCIpO1xuY29uc3Qge1xuICBGTElQUEVEX0FMSUFTX0tFWVMsXG4gIFZJU0lUT1JfS0VZUyxcbiAgaXNDYWxsRXhwcmVzc2lvbixcbiAgaXNEZWNvcmF0b3IsXG4gIGlzRXhwcmVzc2lvblN0YXRlbWVudCxcbiAgaXNNZW1iZXJFeHByZXNzaW9uLFxuICBpc05ld0V4cHJlc3Npb24sXG4gIGlzUGFyZW50aGVzaXplZEV4cHJlc3Npb25cbn0gPSBfdDtcbmNvbnN0IFRva2VuQ29udGV4dCA9IGV4cG9ydHMuVG9rZW5Db250ZXh0ID0ge1xuICBub3JtYWw6IDAsXG4gIGV4cHJlc3Npb25TdGF0ZW1lbnQ6IDEsXG4gIGFycm93Qm9keTogMixcbiAgZXhwb3J0RGVmYXVsdDogNCxcbiAgYXJyb3dGbG93UmV0dXJuVHlwZTogOCxcbiAgZm9ySW5pdEhlYWQ6IDE2LFxuICBmb3JJbkhlYWQ6IDMyLFxuICBmb3JPZkhlYWQ6IDY0LFxuICBmb3JJbk9ySW5pdEhlYWRBY2N1bXVsYXRlOiAxMjgsXG4gIGZvckluT3JJbml0SGVhZEFjY3VtdWxhdGVQYXNzVGhyb3VnaE1hc2s6IDEyOFxufTtcbmZ1bmN0aW9uIGV4cGFuZEFsaWFzZXMob2JqKSB7XG4gIGNvbnN0IG1hcCA9IG5ldyBNYXAoKTtcbiAgZnVuY3Rpb24gYWRkKHR5cGUsIGZ1bmMpIHtcbiAgICBjb25zdCBmbiA9IG1hcC5nZXQodHlwZSk7XG4gICAgbWFwLnNldCh0eXBlLCBmbiA/IGZ1bmN0aW9uIChub2RlLCBwYXJlbnQsIHN0YWNrLCBnZXRSYXdJZGVudGlmaWVyKSB7XG4gICAgICB2YXIgX2ZuO1xuICAgICAgcmV0dXJuIChfZm4gPSBmbihub2RlLCBwYXJlbnQsIHN0YWNrLCBnZXRSYXdJZGVudGlmaWVyKSkgIT0gbnVsbCA/IF9mbiA6IGZ1bmMobm9kZSwgcGFyZW50LCBzdGFjaywgZ2V0UmF3SWRlbnRpZmllcik7XG4gICAgfSA6IGZ1bmMpO1xuICB9XG4gIGZvciAoY29uc3QgdHlwZSBvZiBPYmplY3Qua2V5cyhvYmopKSB7XG4gICAgY29uc3QgYWxpYXNlcyA9IEZMSVBQRURfQUxJQVNfS0VZU1t0eXBlXTtcbiAgICBpZiAoYWxpYXNlcykge1xuICAgICAgZm9yIChjb25zdCBhbGlhcyBvZiBhbGlhc2VzKSB7XG4gICAgICAgIGFkZChhbGlhcywgb2JqW3R5cGVdKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgYWRkKHR5cGUsIG9ialt0eXBlXSk7XG4gICAgfVxuICB9XG4gIHJldHVybiBtYXA7XG59XG5jb25zdCBleHBhbmRlZFBhcmVucyA9IGV4cGFuZEFsaWFzZXMocGFyZW5zKTtcbmNvbnN0IGV4cGFuZGVkV2hpdGVzcGFjZU5vZGVzID0gZXhwYW5kQWxpYXNlcyh3aGl0ZXNwYWNlLm5vZGVzKTtcbmZ1bmN0aW9uIGlzT3JIYXNDYWxsRXhwcmVzc2lvbihub2RlKSB7XG4gIGlmIChpc0NhbGxFeHByZXNzaW9uKG5vZGUpKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgcmV0dXJuIGlzTWVtYmVyRXhwcmVzc2lvbihub2RlKSAmJiBpc09ySGFzQ2FsbEV4cHJlc3Npb24obm9kZS5vYmplY3QpO1xufVxuZnVuY3Rpb24gbmVlZHNXaGl0ZXNwYWNlKG5vZGUsIHBhcmVudCwgdHlwZSkge1xuICB2YXIgX2V4cGFuZGVkV2hpdGVzcGFjZU5vO1xuICBpZiAoIW5vZGUpIHJldHVybiBmYWxzZTtcbiAgaWYgKGlzRXhwcmVzc2lvblN0YXRlbWVudChub2RlKSkge1xuICAgIG5vZGUgPSBub2RlLmV4cHJlc3Npb247XG4gIH1cbiAgY29uc3QgZmxhZyA9IChfZXhwYW5kZWRXaGl0ZXNwYWNlTm8gPSBleHBhbmRlZFdoaXRlc3BhY2VOb2Rlcy5nZXQobm9kZS50eXBlKSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9leHBhbmRlZFdoaXRlc3BhY2VObyhub2RlLCBwYXJlbnQpO1xuICBpZiAodHlwZW9mIGZsYWcgPT09IFwibnVtYmVyXCIpIHtcbiAgICByZXR1cm4gKGZsYWcgJiB0eXBlKSAhPT0gMDtcbiAgfVxuICByZXR1cm4gZmFsc2U7XG59XG5mdW5jdGlvbiBuZWVkc1doaXRlc3BhY2VCZWZvcmUobm9kZSwgcGFyZW50KSB7XG4gIHJldHVybiBuZWVkc1doaXRlc3BhY2Uobm9kZSwgcGFyZW50LCAxKTtcbn1cbmZ1bmN0aW9uIG5lZWRzV2hpdGVzcGFjZUFmdGVyKG5vZGUsIHBhcmVudCkge1xuICByZXR1cm4gbmVlZHNXaGl0ZXNwYWNlKG5vZGUsIHBhcmVudCwgMik7XG59XG5mdW5jdGlvbiBuZWVkc1BhcmVucyhub2RlLCBwYXJlbnQsIHRva2VuQ29udGV4dCwgZ2V0UmF3SWRlbnRpZmllcikge1xuICB2YXIgX2V4cGFuZGVkUGFyZW5zJGdldDtcbiAgaWYgKCFwYXJlbnQpIHJldHVybiBmYWxzZTtcbiAgaWYgKGlzTmV3RXhwcmVzc2lvbihwYXJlbnQpICYmIHBhcmVudC5jYWxsZWUgPT09IG5vZGUpIHtcbiAgICBpZiAoaXNPckhhc0NhbGxFeHByZXNzaW9uKG5vZGUpKSByZXR1cm4gdHJ1ZTtcbiAgfVxuICBpZiAoaXNEZWNvcmF0b3IocGFyZW50KSkge1xuICAgIHJldHVybiAhaXNEZWNvcmF0b3JNZW1iZXJFeHByZXNzaW9uKG5vZGUpICYmICEoaXNDYWxsRXhwcmVzc2lvbihub2RlKSAmJiBpc0RlY29yYXRvck1lbWJlckV4cHJlc3Npb24obm9kZS5jYWxsZWUpKSAmJiAhaXNQYXJlbnRoZXNpemVkRXhwcmVzc2lvbihub2RlKTtcbiAgfVxuICByZXR1cm4gKChfZXhwYW5kZWRQYXJlbnMkZ2V0ID0gZXhwYW5kZWRQYXJlbnMuZ2V0KG5vZGUudHlwZSkpID09IG51bGwgPyB2b2lkIDAgOiBfZXhwYW5kZWRQYXJlbnMkZ2V0KG5vZGUsIHBhcmVudCwgdG9rZW5Db250ZXh0LCBnZXRSYXdJZGVudGlmaWVyKSkgfHwgZmFsc2U7XG59XG5mdW5jdGlvbiBpc0RlY29yYXRvck1lbWJlckV4cHJlc3Npb24obm9kZSkge1xuICBzd2l0Y2ggKG5vZGUudHlwZSkge1xuICAgIGNhc2UgXCJJZGVudGlmaWVyXCI6XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICBjYXNlIFwiTWVtYmVyRXhwcmVzc2lvblwiOlxuICAgICAgcmV0dXJuICFub2RlLmNvbXB1dGVkICYmIG5vZGUucHJvcGVydHkudHlwZSA9PT0gXCJJZGVudGlmaWVyXCIgJiYgaXNEZWNvcmF0b3JNZW1iZXJFeHByZXNzaW9uKG5vZGUub2JqZWN0KTtcbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIGZhbHNlO1xuICB9XG59XG5mdW5jdGlvbiBpc0xhc3RDaGlsZChwYXJlbnQsIGNoaWxkKSB7XG4gIGNvbnN0IHZpc2l0b3JLZXlzID0gVklTSVRPUl9LRVlTW3BhcmVudC50eXBlXTtcbiAgZm9yIChsZXQgaSA9IHZpc2l0b3JLZXlzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgY29uc3QgdmFsID0gcGFyZW50W3Zpc2l0b3JLZXlzW2ldXTtcbiAgICBpZiAodmFsID09PSBjaGlsZCkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBlbHNlIGlmIChBcnJheS5pc0FycmF5KHZhbCkpIHtcbiAgICAgIGxldCBqID0gdmFsLmxlbmd0aCAtIDE7XG4gICAgICB3aGlsZSAoaiA+PSAwICYmIHZhbFtqXSA9PT0gbnVsbCkgai0tO1xuICAgICAgcmV0dXJuIGogPj0gMCAmJiB2YWxbal0gPT09IGNoaWxkO1xuICAgIH0gZWxzZSBpZiAodmFsKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG4gIHJldHVybiBmYWxzZTtcbn1cblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@babel/generator/lib/node/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@babel/generator/lib/node/parentheses.js":
/*!***************************************************************!*\
  !*** ./node_modules/@babel/generator/lib/node/parentheses.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports.AssignmentExpression = AssignmentExpression;\nexports.Binary = Binary;\nexports.BinaryExpression = BinaryExpression;\nexports.ClassExpression = ClassExpression;\nexports.ArrowFunctionExpression = exports.ConditionalExpression = ConditionalExpression;\nexports.DoExpression = DoExpression;\nexports.FunctionExpression = FunctionExpression;\nexports.FunctionTypeAnnotation = FunctionTypeAnnotation;\nexports.Identifier = Identifier;\nexports.LogicalExpression = LogicalExpression;\nexports.NullableTypeAnnotation = NullableTypeAnnotation;\nexports.ObjectExpression = ObjectExpression;\nexports.OptionalIndexedAccessType = OptionalIndexedAccessType;\nexports.OptionalCallExpression = exports.OptionalMemberExpression = OptionalMemberExpression;\nexports.SequenceExpression = SequenceExpression;\nexports.TSSatisfiesExpression = exports.TSAsExpression = TSAsExpression;\nexports.TSConditionalType = TSConditionalType;\nexports.TSConstructorType = exports.TSFunctionType = TSFunctionType;\nexports.TSInferType = TSInferType;\nexports.TSInstantiationExpression = TSInstantiationExpression;\nexports.TSIntersectionType = TSIntersectionType;\nexports.UnaryLike = exports.TSTypeAssertion = UnaryLike;\nexports.TSTypeOperator = TSTypeOperator;\nexports.TSUnionType = TSUnionType;\nexports.IntersectionTypeAnnotation = exports.UnionTypeAnnotation = UnionTypeAnnotation;\nexports.UpdateExpression = UpdateExpression;\nexports.AwaitExpression = exports.YieldExpression = YieldExpression;\nvar _t = __webpack_require__(/*! @babel/types */ \"(ssr)/./node_modules/@babel/types/lib/index.js\");\nvar _index = __webpack_require__(/*! ./index.js */ \"(ssr)/./node_modules/@babel/generator/lib/node/index.js\");\nconst {\n  isArrayTypeAnnotation,\n  isBinaryExpression,\n  isCallExpression,\n  isForOfStatement,\n  isIndexedAccessType,\n  isMemberExpression,\n  isObjectPattern,\n  isOptionalMemberExpression,\n  isYieldExpression,\n  isStatement\n} = _t;\nconst PRECEDENCE = new Map([[\"||\", 0], [\"??\", 0], [\"|>\", 0], [\"&&\", 1], [\"|\", 2], [\"^\", 3], [\"&\", 4], [\"==\", 5], [\"===\", 5], [\"!=\", 5], [\"!==\", 5], [\"<\", 6], [\">\", 6], [\"<=\", 6], [\">=\", 6], [\"in\", 6], [\"instanceof\", 6], [\">>\", 7], [\"<<\", 7], [\">>>\", 7], [\"+\", 8], [\"-\", 8], [\"*\", 9], [\"/\", 9], [\"%\", 9], [\"**\", 10]]);\nfunction getBinaryPrecedence(node, nodeType) {\n  if (nodeType === \"BinaryExpression\" || nodeType === \"LogicalExpression\") {\n    return PRECEDENCE.get(node.operator);\n  }\n  if (nodeType === \"TSAsExpression\" || nodeType === \"TSSatisfiesExpression\") {\n    return PRECEDENCE.get(\"in\");\n  }\n}\nfunction isTSTypeExpression(nodeType) {\n  return nodeType === \"TSAsExpression\" || nodeType === \"TSSatisfiesExpression\" || nodeType === \"TSTypeAssertion\";\n}\nconst isClassExtendsClause = (node, parent) => {\n  const parentType = parent.type;\n  return (parentType === \"ClassDeclaration\" || parentType === \"ClassExpression\") && parent.superClass === node;\n};\nconst hasPostfixPart = (node, parent) => {\n  const parentType = parent.type;\n  return (parentType === \"MemberExpression\" || parentType === \"OptionalMemberExpression\") && parent.object === node || (parentType === \"CallExpression\" || parentType === \"OptionalCallExpression\" || parentType === \"NewExpression\") && parent.callee === node || parentType === \"TaggedTemplateExpression\" && parent.tag === node || parentType === \"TSNonNullExpression\";\n};\nfunction NullableTypeAnnotation(node, parent) {\n  return isArrayTypeAnnotation(parent);\n}\nfunction FunctionTypeAnnotation(node, parent, tokenContext) {\n  const parentType = parent.type;\n  return (parentType === \"UnionTypeAnnotation\" || parentType === \"IntersectionTypeAnnotation\" || parentType === \"ArrayTypeAnnotation\" || Boolean(tokenContext & _index.TokenContext.arrowFlowReturnType)\n  );\n}\nfunction UpdateExpression(node, parent) {\n  return hasPostfixPart(node, parent) || isClassExtendsClause(node, parent);\n}\nfunction needsParenBeforeExpressionBrace(tokenContext) {\n  return Boolean(tokenContext & (_index.TokenContext.expressionStatement | _index.TokenContext.arrowBody));\n}\nfunction ObjectExpression(node, parent, tokenContext) {\n  return needsParenBeforeExpressionBrace(tokenContext);\n}\nfunction DoExpression(node, parent, tokenContext) {\n  return !node.async && Boolean(tokenContext & _index.TokenContext.expressionStatement);\n}\nfunction Binary(node, parent) {\n  const parentType = parent.type;\n  if (node.type === \"BinaryExpression\" && node.operator === \"**\" && parentType === \"BinaryExpression\" && parent.operator === \"**\") {\n    return parent.left === node;\n  }\n  if (isClassExtendsClause(node, parent)) {\n    return true;\n  }\n  if (hasPostfixPart(node, parent) || parentType === \"UnaryExpression\" || parentType === \"SpreadElement\" || parentType === \"AwaitExpression\") {\n    return true;\n  }\n  const parentPos = getBinaryPrecedence(parent, parentType);\n  if (parentPos != null) {\n    const nodePos = getBinaryPrecedence(node, node.type);\n    if (parentPos === nodePos && parentType === \"BinaryExpression\" && parent.right === node || parentPos > nodePos) {\n      return true;\n    }\n  }\n}\nfunction UnionTypeAnnotation(node, parent) {\n  const parentType = parent.type;\n  return parentType === \"ArrayTypeAnnotation\" || parentType === \"NullableTypeAnnotation\" || parentType === \"IntersectionTypeAnnotation\" || parentType === \"UnionTypeAnnotation\";\n}\nfunction OptionalIndexedAccessType(node, parent) {\n  return isIndexedAccessType(parent) && parent.objectType === node;\n}\nfunction TSAsExpression(node, parent) {\n  if ((parent.type === \"AssignmentExpression\" || parent.type === \"AssignmentPattern\") && parent.left === node) {\n    return true;\n  }\n  if (parent.type === \"BinaryExpression\" && (parent.operator === \"|\" || parent.operator === \"&\") && node === parent.left) {\n    return true;\n  }\n  return Binary(node, parent);\n}\nfunction TSConditionalType(node, parent) {\n  const parentType = parent.type;\n  if (parentType === \"TSArrayType\" || parentType === \"TSIndexedAccessType\" && parent.objectType === node || parentType === \"TSOptionalType\" || parentType === \"TSTypeOperator\" || parentType === \"TSTypeParameter\") {\n    return true;\n  }\n  if ((parentType === \"TSIntersectionType\" || parentType === \"TSUnionType\") && parent.types[0] === node) {\n    return true;\n  }\n  if (parentType === \"TSConditionalType\" && (parent.checkType === node || parent.extendsType === node)) {\n    return true;\n  }\n  return false;\n}\nfunction TSUnionType(node, parent) {\n  const parentType = parent.type;\n  return parentType === \"TSIntersectionType\" || parentType === \"TSTypeOperator\" || parentType === \"TSArrayType\" || parentType === \"TSIndexedAccessType\" && parent.objectType === node || parentType === \"TSOptionalType\";\n}\nfunction TSIntersectionType(node, parent) {\n  const parentType = parent.type;\n  return parentType === \"TSTypeOperator\" || parentType === \"TSArrayType\" || parentType === \"TSIndexedAccessType\" && parent.objectType === node || parentType === \"TSOptionalType\";\n}\nfunction TSInferType(node, parent) {\n  const parentType = parent.type;\n  if (parentType === \"TSArrayType\" || parentType === \"TSIndexedAccessType\" && parent.objectType === node || parentType === \"TSOptionalType\") {\n    return true;\n  }\n  if (node.typeParameter.constraint) {\n    if ((parentType === \"TSIntersectionType\" || parentType === \"TSUnionType\") && parent.types[0] === node) {\n      return true;\n    }\n  }\n  return false;\n}\nfunction TSTypeOperator(node, parent) {\n  const parentType = parent.type;\n  return parentType === \"TSArrayType\" || parentType === \"TSIndexedAccessType\" && parent.objectType === node || parentType === \"TSOptionalType\";\n}\nfunction TSInstantiationExpression(node, parent) {\n  const parentType = parent.type;\n  return (parentType === \"CallExpression\" || parentType === \"OptionalCallExpression\" || parentType === \"NewExpression\" || parentType === \"TSInstantiationExpression\") && !!parent.typeParameters;\n}\nfunction TSFunctionType(node, parent) {\n  const parentType = parent.type;\n  return parentType === \"TSIntersectionType\" || parentType === \"TSUnionType\" || parentType === \"TSTypeOperator\" || parentType === \"TSOptionalType\" || parentType === \"TSArrayType\" || parentType === \"TSIndexedAccessType\" && parent.objectType === node || parentType === \"TSConditionalType\" && (parent.checkType === node || parent.extendsType === node);\n}\nfunction BinaryExpression(node, parent, tokenContext) {\n  return node.operator === \"in\" && Boolean(tokenContext & _index.TokenContext.forInOrInitHeadAccumulate);\n}\nfunction SequenceExpression(node, parent) {\n  const parentType = parent.type;\n  if (parentType === \"SequenceExpression\" || parentType === \"ParenthesizedExpression\" || parentType === \"MemberExpression\" && parent.property === node || parentType === \"OptionalMemberExpression\" && parent.property === node || parentType === \"TemplateLiteral\") {\n    return false;\n  }\n  if (parentType === \"ClassDeclaration\") {\n    return true;\n  }\n  if (parentType === \"ForOfStatement\") {\n    return parent.right === node;\n  }\n  if (parentType === \"ExportDefaultDeclaration\") {\n    return true;\n  }\n  return !isStatement(parent);\n}\nfunction YieldExpression(node, parent) {\n  const parentType = parent.type;\n  return parentType === \"BinaryExpression\" || parentType === \"LogicalExpression\" || parentType === \"UnaryExpression\" || parentType === \"SpreadElement\" || hasPostfixPart(node, parent) || parentType === \"AwaitExpression\" && isYieldExpression(node) || parentType === \"ConditionalExpression\" && node === parent.test || isClassExtendsClause(node, parent) || isTSTypeExpression(parentType);\n}\nfunction ClassExpression(node, parent, tokenContext) {\n  return Boolean(tokenContext & (_index.TokenContext.expressionStatement | _index.TokenContext.exportDefault));\n}\nfunction UnaryLike(node, parent) {\n  return hasPostfixPart(node, parent) || isBinaryExpression(parent) && parent.operator === \"**\" && parent.left === node || isClassExtendsClause(node, parent);\n}\nfunction FunctionExpression(node, parent, tokenContext) {\n  return Boolean(tokenContext & (_index.TokenContext.expressionStatement | _index.TokenContext.exportDefault));\n}\nfunction ConditionalExpression(node, parent) {\n  const parentType = parent.type;\n  if (parentType === \"UnaryExpression\" || parentType === \"SpreadElement\" || parentType === \"BinaryExpression\" || parentType === \"LogicalExpression\" || parentType === \"ConditionalExpression\" && parent.test === node || parentType === \"AwaitExpression\" || isTSTypeExpression(parentType)) {\n    return true;\n  }\n  return UnaryLike(node, parent);\n}\nfunction OptionalMemberExpression(node, parent) {\n  return isCallExpression(parent) && parent.callee === node || isMemberExpression(parent) && parent.object === node;\n}\nfunction AssignmentExpression(node, parent, tokenContext) {\n  if (needsParenBeforeExpressionBrace(tokenContext) && isObjectPattern(node.left)) {\n    return true;\n  } else {\n    return ConditionalExpression(node, parent);\n  }\n}\nfunction LogicalExpression(node, parent) {\n  const parentType = parent.type;\n  if (isTSTypeExpression(parentType)) return true;\n  if (parentType !== \"LogicalExpression\") return false;\n  switch (node.operator) {\n    case \"||\":\n      return parent.operator === \"??\" || parent.operator === \"&&\";\n    case \"&&\":\n      return parent.operator === \"??\";\n    case \"??\":\n      return parent.operator !== \"??\";\n  }\n}\nfunction Identifier(node, parent, tokenContext, getRawIdentifier) {\n  var _node$extra;\n  const parentType = parent.type;\n  if ((_node$extra = node.extra) != null && _node$extra.parenthesized && parentType === \"AssignmentExpression\" && parent.left === node) {\n    const rightType = parent.right.type;\n    if ((rightType === \"FunctionExpression\" || rightType === \"ClassExpression\") && parent.right.id == null) {\n      return true;\n    }\n  }\n  if (getRawIdentifier && getRawIdentifier(node) !== node.name) {\n    return false;\n  }\n  if (node.name === \"let\") {\n    const isFollowedByBracket = isMemberExpression(parent, {\n      object: node,\n      computed: true\n    }) || isOptionalMemberExpression(parent, {\n      object: node,\n      computed: true,\n      optional: false\n    });\n    if (isFollowedByBracket && tokenContext & (_index.TokenContext.expressionStatement | _index.TokenContext.forInitHead | _index.TokenContext.forInHead)) {\n      return true;\n    }\n    return Boolean(tokenContext & _index.TokenContext.forOfHead);\n  }\n  return node.name === \"async\" && isForOfStatement(parent, {\n    left: node,\n    await: false\n  });\n}\n\n//# sourceMappingURL=parentheses.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGJhYmVsL2dlbmVyYXRvci9saWIvbm9kZS9wYXJlbnRoZXNlcy5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYiw4Q0FBNkM7QUFDN0M7QUFDQSxDQUFDLEVBQUM7QUFDRiw0QkFBNEI7QUFDNUIsY0FBYztBQUNkLHdCQUF3QjtBQUN4Qix1QkFBdUI7QUFDdkIsK0JBQStCLEdBQUcsNkJBQTZCO0FBQy9ELG9CQUFvQjtBQUNwQiwwQkFBMEI7QUFDMUIsOEJBQThCO0FBQzlCLGtCQUFrQjtBQUNsQix5QkFBeUI7QUFDekIsOEJBQThCO0FBQzlCLHdCQUF3QjtBQUN4QixpQ0FBaUM7QUFDakMsOEJBQThCLEdBQUcsZ0NBQWdDO0FBQ2pFLDBCQUEwQjtBQUMxQiw2QkFBNkIsR0FBRyxzQkFBc0I7QUFDdEQseUJBQXlCO0FBQ3pCLHlCQUF5QixHQUFHLHNCQUFzQjtBQUNsRCxtQkFBbUI7QUFDbkIsaUNBQWlDO0FBQ2pDLDBCQUEwQjtBQUMxQixpQkFBaUIsR0FBRyx1QkFBdUI7QUFDM0Msc0JBQXNCO0FBQ3RCLG1CQUFtQjtBQUNuQixrQ0FBa0MsR0FBRywyQkFBMkI7QUFDaEUsd0JBQXdCO0FBQ3hCLHVCQUF1QixHQUFHLHVCQUF1QjtBQUNqRCxTQUFTLG1CQUFPLENBQUMsb0VBQWM7QUFDL0IsYUFBYSxtQkFBTyxDQUFDLDJFQUFZO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUEiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9yZXBvLXZpc3VhbGl6ZXIvLi9ub2RlX21vZHVsZXMvQGJhYmVsL2dlbmVyYXRvci9saWIvbm9kZS9wYXJlbnRoZXNlcy5qcz8zMzViIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5Bc3NpZ25tZW50RXhwcmVzc2lvbiA9IEFzc2lnbm1lbnRFeHByZXNzaW9uO1xuZXhwb3J0cy5CaW5hcnkgPSBCaW5hcnk7XG5leHBvcnRzLkJpbmFyeUV4cHJlc3Npb24gPSBCaW5hcnlFeHByZXNzaW9uO1xuZXhwb3J0cy5DbGFzc0V4cHJlc3Npb24gPSBDbGFzc0V4cHJlc3Npb247XG5leHBvcnRzLkFycm93RnVuY3Rpb25FeHByZXNzaW9uID0gZXhwb3J0cy5Db25kaXRpb25hbEV4cHJlc3Npb24gPSBDb25kaXRpb25hbEV4cHJlc3Npb247XG5leHBvcnRzLkRvRXhwcmVzc2lvbiA9IERvRXhwcmVzc2lvbjtcbmV4cG9ydHMuRnVuY3Rpb25FeHByZXNzaW9uID0gRnVuY3Rpb25FeHByZXNzaW9uO1xuZXhwb3J0cy5GdW5jdGlvblR5cGVBbm5vdGF0aW9uID0gRnVuY3Rpb25UeXBlQW5ub3RhdGlvbjtcbmV4cG9ydHMuSWRlbnRpZmllciA9IElkZW50aWZpZXI7XG5leHBvcnRzLkxvZ2ljYWxFeHByZXNzaW9uID0gTG9naWNhbEV4cHJlc3Npb247XG5leHBvcnRzLk51bGxhYmxlVHlwZUFubm90YXRpb24gPSBOdWxsYWJsZVR5cGVBbm5vdGF0aW9uO1xuZXhwb3J0cy5PYmplY3RFeHByZXNzaW9uID0gT2JqZWN0RXhwcmVzc2lvbjtcbmV4cG9ydHMuT3B0aW9uYWxJbmRleGVkQWNjZXNzVHlwZSA9IE9wdGlvbmFsSW5kZXhlZEFjY2Vzc1R5cGU7XG5leHBvcnRzLk9wdGlvbmFsQ2FsbEV4cHJlc3Npb24gPSBleHBvcnRzLk9wdGlvbmFsTWVtYmVyRXhwcmVzc2lvbiA9IE9wdGlvbmFsTWVtYmVyRXhwcmVzc2lvbjtcbmV4cG9ydHMuU2VxdWVuY2VFeHByZXNzaW9uID0gU2VxdWVuY2VFeHByZXNzaW9uO1xuZXhwb3J0cy5UU1NhdGlzZmllc0V4cHJlc3Npb24gPSBleHBvcnRzLlRTQXNFeHByZXNzaW9uID0gVFNBc0V4cHJlc3Npb247XG5leHBvcnRzLlRTQ29uZGl0aW9uYWxUeXBlID0gVFNDb25kaXRpb25hbFR5cGU7XG5leHBvcnRzLlRTQ29uc3RydWN0b3JUeXBlID0gZXhwb3J0cy5UU0Z1bmN0aW9uVHlwZSA9IFRTRnVuY3Rpb25UeXBlO1xuZXhwb3J0cy5UU0luZmVyVHlwZSA9IFRTSW5mZXJUeXBlO1xuZXhwb3J0cy5UU0luc3RhbnRpYXRpb25FeHByZXNzaW9uID0gVFNJbnN0YW50aWF0aW9uRXhwcmVzc2lvbjtcbmV4cG9ydHMuVFNJbnRlcnNlY3Rpb25UeXBlID0gVFNJbnRlcnNlY3Rpb25UeXBlO1xuZXhwb3J0cy5VbmFyeUxpa2UgPSBleHBvcnRzLlRTVHlwZUFzc2VydGlvbiA9IFVuYXJ5TGlrZTtcbmV4cG9ydHMuVFNUeXBlT3BlcmF0b3IgPSBUU1R5cGVPcGVyYXRvcjtcbmV4cG9ydHMuVFNVbmlvblR5cGUgPSBUU1VuaW9uVHlwZTtcbmV4cG9ydHMuSW50ZXJzZWN0aW9uVHlwZUFubm90YXRpb24gPSBleHBvcnRzLlVuaW9uVHlwZUFubm90YXRpb24gPSBVbmlvblR5cGVBbm5vdGF0aW9uO1xuZXhwb3J0cy5VcGRhdGVFeHByZXNzaW9uID0gVXBkYXRlRXhwcmVzc2lvbjtcbmV4cG9ydHMuQXdhaXRFeHByZXNzaW9uID0gZXhwb3J0cy5ZaWVsZEV4cHJlc3Npb24gPSBZaWVsZEV4cHJlc3Npb247XG52YXIgX3QgPSByZXF1aXJlKFwiQGJhYmVsL3R5cGVzXCIpO1xudmFyIF9pbmRleCA9IHJlcXVpcmUoXCIuL2luZGV4LmpzXCIpO1xuY29uc3Qge1xuICBpc0FycmF5VHlwZUFubm90YXRpb24sXG4gIGlzQmluYXJ5RXhwcmVzc2lvbixcbiAgaXNDYWxsRXhwcmVzc2lvbixcbiAgaXNGb3JPZlN0YXRlbWVudCxcbiAgaXNJbmRleGVkQWNjZXNzVHlwZSxcbiAgaXNNZW1iZXJFeHByZXNzaW9uLFxuICBpc09iamVjdFBhdHRlcm4sXG4gIGlzT3B0aW9uYWxNZW1iZXJFeHByZXNzaW9uLFxuICBpc1lpZWxkRXhwcmVzc2lvbixcbiAgaXNTdGF0ZW1lbnRcbn0gPSBfdDtcbmNvbnN0IFBSRUNFREVOQ0UgPSBuZXcgTWFwKFtbXCJ8fFwiLCAwXSwgW1wiPz9cIiwgMF0sIFtcInw+XCIsIDBdLCBbXCImJlwiLCAxXSwgW1wifFwiLCAyXSwgW1wiXlwiLCAzXSwgW1wiJlwiLCA0XSwgW1wiPT1cIiwgNV0sIFtcIj09PVwiLCA1XSwgW1wiIT1cIiwgNV0sIFtcIiE9PVwiLCA1XSwgW1wiPFwiLCA2XSwgW1wiPlwiLCA2XSwgW1wiPD1cIiwgNl0sIFtcIj49XCIsIDZdLCBbXCJpblwiLCA2XSwgW1wiaW5zdGFuY2VvZlwiLCA2XSwgW1wiPj5cIiwgN10sIFtcIjw8XCIsIDddLCBbXCI+Pj5cIiwgN10sIFtcIitcIiwgOF0sIFtcIi1cIiwgOF0sIFtcIipcIiwgOV0sIFtcIi9cIiwgOV0sIFtcIiVcIiwgOV0sIFtcIioqXCIsIDEwXV0pO1xuZnVuY3Rpb24gZ2V0QmluYXJ5UHJlY2VkZW5jZShub2RlLCBub2RlVHlwZSkge1xuICBpZiAobm9kZVR5cGUgPT09IFwiQmluYXJ5RXhwcmVzc2lvblwiIHx8IG5vZGVUeXBlID09PSBcIkxvZ2ljYWxFeHByZXNzaW9uXCIpIHtcbiAgICByZXR1cm4gUFJFQ0VERU5DRS5nZXQobm9kZS5vcGVyYXRvcik7XG4gIH1cbiAgaWYgKG5vZGVUeXBlID09PSBcIlRTQXNFeHByZXNzaW9uXCIgfHwgbm9kZVR5cGUgPT09IFwiVFNTYXRpc2ZpZXNFeHByZXNzaW9uXCIpIHtcbiAgICByZXR1cm4gUFJFQ0VERU5DRS5nZXQoXCJpblwiKTtcbiAgfVxufVxuZnVuY3Rpb24gaXNUU1R5cGVFeHByZXNzaW9uKG5vZGVUeXBlKSB7XG4gIHJldHVybiBub2RlVHlwZSA9PT0gXCJUU0FzRXhwcmVzc2lvblwiIHx8IG5vZGVUeXBlID09PSBcIlRTU2F0aXNmaWVzRXhwcmVzc2lvblwiIHx8IG5vZGVUeXBlID09PSBcIlRTVHlwZUFzc2VydGlvblwiO1xufVxuY29uc3QgaXNDbGFzc0V4dGVuZHNDbGF1c2UgPSAobm9kZSwgcGFyZW50KSA9PiB7XG4gIGNvbnN0IHBhcmVudFR5cGUgPSBwYXJlbnQudHlwZTtcbiAgcmV0dXJuIChwYXJlbnRUeXBlID09PSBcIkNsYXNzRGVjbGFyYXRpb25cIiB8fCBwYXJlbnRUeXBlID09PSBcIkNsYXNzRXhwcmVzc2lvblwiKSAmJiBwYXJlbnQuc3VwZXJDbGFzcyA9PT0gbm9kZTtcbn07XG5jb25zdCBoYXNQb3N0Zml4UGFydCA9IChub2RlLCBwYXJlbnQpID0+IHtcbiAgY29uc3QgcGFyZW50VHlwZSA9IHBhcmVudC50eXBlO1xuICByZXR1cm4gKHBhcmVudFR5cGUgPT09IFwiTWVtYmVyRXhwcmVzc2lvblwiIHx8IHBhcmVudFR5cGUgPT09IFwiT3B0aW9uYWxNZW1iZXJFeHByZXNzaW9uXCIpICYmIHBhcmVudC5vYmplY3QgPT09IG5vZGUgfHwgKHBhcmVudFR5cGUgPT09IFwiQ2FsbEV4cHJlc3Npb25cIiB8fCBwYXJlbnRUeXBlID09PSBcIk9wdGlvbmFsQ2FsbEV4cHJlc3Npb25cIiB8fCBwYXJlbnRUeXBlID09PSBcIk5ld0V4cHJlc3Npb25cIikgJiYgcGFyZW50LmNhbGxlZSA9PT0gbm9kZSB8fCBwYXJlbnRUeXBlID09PSBcIlRhZ2dlZFRlbXBsYXRlRXhwcmVzc2lvblwiICYmIHBhcmVudC50YWcgPT09IG5vZGUgfHwgcGFyZW50VHlwZSA9PT0gXCJUU05vbk51bGxFeHByZXNzaW9uXCI7XG59O1xuZnVuY3Rpb24gTnVsbGFibGVUeXBlQW5ub3RhdGlvbihub2RlLCBwYXJlbnQpIHtcbiAgcmV0dXJuIGlzQXJyYXlUeXBlQW5ub3RhdGlvbihwYXJlbnQpO1xufVxuZnVuY3Rpb24gRnVuY3Rpb25UeXBlQW5ub3RhdGlvbihub2RlLCBwYXJlbnQsIHRva2VuQ29udGV4dCkge1xuICBjb25zdCBwYXJlbnRUeXBlID0gcGFyZW50LnR5cGU7XG4gIHJldHVybiAocGFyZW50VHlwZSA9PT0gXCJVbmlvblR5cGVBbm5vdGF0aW9uXCIgfHwgcGFyZW50VHlwZSA9PT0gXCJJbnRlcnNlY3Rpb25UeXBlQW5ub3RhdGlvblwiIHx8IHBhcmVudFR5cGUgPT09IFwiQXJyYXlUeXBlQW5ub3RhdGlvblwiIHx8IEJvb2xlYW4odG9rZW5Db250ZXh0ICYgX2luZGV4LlRva2VuQ29udGV4dC5hcnJvd0Zsb3dSZXR1cm5UeXBlKVxuICApO1xufVxuZnVuY3Rpb24gVXBkYXRlRXhwcmVzc2lvbihub2RlLCBwYXJlbnQpIHtcbiAgcmV0dXJuIGhhc1Bvc3RmaXhQYXJ0KG5vZGUsIHBhcmVudCkgfHwgaXNDbGFzc0V4dGVuZHNDbGF1c2Uobm9kZSwgcGFyZW50KTtcbn1cbmZ1bmN0aW9uIG5lZWRzUGFyZW5CZWZvcmVFeHByZXNzaW9uQnJhY2UodG9rZW5Db250ZXh0KSB7XG4gIHJldHVybiBCb29sZWFuKHRva2VuQ29udGV4dCAmIChfaW5kZXguVG9rZW5Db250ZXh0LmV4cHJlc3Npb25TdGF0ZW1lbnQgfCBfaW5kZXguVG9rZW5Db250ZXh0LmFycm93Qm9keSkpO1xufVxuZnVuY3Rpb24gT2JqZWN0RXhwcmVzc2lvbihub2RlLCBwYXJlbnQsIHRva2VuQ29udGV4dCkge1xuICByZXR1cm4gbmVlZHNQYXJlbkJlZm9yZUV4cHJlc3Npb25CcmFjZSh0b2tlbkNvbnRleHQpO1xufVxuZnVuY3Rpb24gRG9FeHByZXNzaW9uKG5vZGUsIHBhcmVudCwgdG9rZW5Db250ZXh0KSB7XG4gIHJldHVybiAhbm9kZS5hc3luYyAmJiBCb29sZWFuKHRva2VuQ29udGV4dCAmIF9pbmRleC5Ub2tlbkNvbnRleHQuZXhwcmVzc2lvblN0YXRlbWVudCk7XG59XG5mdW5jdGlvbiBCaW5hcnkobm9kZSwgcGFyZW50KSB7XG4gIGNvbnN0IHBhcmVudFR5cGUgPSBwYXJlbnQudHlwZTtcbiAgaWYgKG5vZGUudHlwZSA9PT0gXCJCaW5hcnlFeHByZXNzaW9uXCIgJiYgbm9kZS5vcGVyYXRvciA9PT0gXCIqKlwiICYmIHBhcmVudFR5cGUgPT09IFwiQmluYXJ5RXhwcmVzc2lvblwiICYmIHBhcmVudC5vcGVyYXRvciA9PT0gXCIqKlwiKSB7XG4gICAgcmV0dXJuIHBhcmVudC5sZWZ0ID09PSBub2RlO1xuICB9XG4gIGlmIChpc0NsYXNzRXh0ZW5kc0NsYXVzZShub2RlLCBwYXJlbnQpKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgaWYgKGhhc1Bvc3RmaXhQYXJ0KG5vZGUsIHBhcmVudCkgfHwgcGFyZW50VHlwZSA9PT0gXCJVbmFyeUV4cHJlc3Npb25cIiB8fCBwYXJlbnRUeXBlID09PSBcIlNwcmVhZEVsZW1lbnRcIiB8fCBwYXJlbnRUeXBlID09PSBcIkF3YWl0RXhwcmVzc2lvblwiKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgY29uc3QgcGFyZW50UG9zID0gZ2V0QmluYXJ5UHJlY2VkZW5jZShwYXJlbnQsIHBhcmVudFR5cGUpO1xuICBpZiAocGFyZW50UG9zICE9IG51bGwpIHtcbiAgICBjb25zdCBub2RlUG9zID0gZ2V0QmluYXJ5UHJlY2VkZW5jZShub2RlLCBub2RlLnR5cGUpO1xuICAgIGlmIChwYXJlbnRQb3MgPT09IG5vZGVQb3MgJiYgcGFyZW50VHlwZSA9PT0gXCJCaW5hcnlFeHByZXNzaW9uXCIgJiYgcGFyZW50LnJpZ2h0ID09PSBub2RlIHx8IHBhcmVudFBvcyA+IG5vZGVQb3MpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gVW5pb25UeXBlQW5ub3RhdGlvbihub2RlLCBwYXJlbnQpIHtcbiAgY29uc3QgcGFyZW50VHlwZSA9IHBhcmVudC50eXBlO1xuICByZXR1cm4gcGFyZW50VHlwZSA9PT0gXCJBcnJheVR5cGVBbm5vdGF0aW9uXCIgfHwgcGFyZW50VHlwZSA9PT0gXCJOdWxsYWJsZVR5cGVBbm5vdGF0aW9uXCIgfHwgcGFyZW50VHlwZSA9PT0gXCJJbnRlcnNlY3Rpb25UeXBlQW5ub3RhdGlvblwiIHx8IHBhcmVudFR5cGUgPT09IFwiVW5pb25UeXBlQW5ub3RhdGlvblwiO1xufVxuZnVuY3Rpb24gT3B0aW9uYWxJbmRleGVkQWNjZXNzVHlwZShub2RlLCBwYXJlbnQpIHtcbiAgcmV0dXJuIGlzSW5kZXhlZEFjY2Vzc1R5cGUocGFyZW50KSAmJiBwYXJlbnQub2JqZWN0VHlwZSA9PT0gbm9kZTtcbn1cbmZ1bmN0aW9uIFRTQXNFeHByZXNzaW9uKG5vZGUsIHBhcmVudCkge1xuICBpZiAoKHBhcmVudC50eXBlID09PSBcIkFzc2lnbm1lbnRFeHByZXNzaW9uXCIgfHwgcGFyZW50LnR5cGUgPT09IFwiQXNzaWdubWVudFBhdHRlcm5cIikgJiYgcGFyZW50LmxlZnQgPT09IG5vZGUpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICBpZiAocGFyZW50LnR5cGUgPT09IFwiQmluYXJ5RXhwcmVzc2lvblwiICYmIChwYXJlbnQub3BlcmF0b3IgPT09IFwifFwiIHx8IHBhcmVudC5vcGVyYXRvciA9PT0gXCImXCIpICYmIG5vZGUgPT09IHBhcmVudC5sZWZ0KSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgcmV0dXJuIEJpbmFyeShub2RlLCBwYXJlbnQpO1xufVxuZnVuY3Rpb24gVFNDb25kaXRpb25hbFR5cGUobm9kZSwgcGFyZW50KSB7XG4gIGNvbnN0IHBhcmVudFR5cGUgPSBwYXJlbnQudHlwZTtcbiAgaWYgKHBhcmVudFR5cGUgPT09IFwiVFNBcnJheVR5cGVcIiB8fCBwYXJlbnRUeXBlID09PSBcIlRTSW5kZXhlZEFjY2Vzc1R5cGVcIiAmJiBwYXJlbnQub2JqZWN0VHlwZSA9PT0gbm9kZSB8fCBwYXJlbnRUeXBlID09PSBcIlRTT3B0aW9uYWxUeXBlXCIgfHwgcGFyZW50VHlwZSA9PT0gXCJUU1R5cGVPcGVyYXRvclwiIHx8IHBhcmVudFR5cGUgPT09IFwiVFNUeXBlUGFyYW1ldGVyXCIpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICBpZiAoKHBhcmVudFR5cGUgPT09IFwiVFNJbnRlcnNlY3Rpb25UeXBlXCIgfHwgcGFyZW50VHlwZSA9PT0gXCJUU1VuaW9uVHlwZVwiKSAmJiBwYXJlbnQudHlwZXNbMF0gPT09IG5vZGUpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICBpZiAocGFyZW50VHlwZSA9PT0gXCJUU0NvbmRpdGlvbmFsVHlwZVwiICYmIChwYXJlbnQuY2hlY2tUeXBlID09PSBub2RlIHx8IHBhcmVudC5leHRlbmRzVHlwZSA9PT0gbm9kZSkpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICByZXR1cm4gZmFsc2U7XG59XG5mdW5jdGlvbiBUU1VuaW9uVHlwZShub2RlLCBwYXJlbnQpIHtcbiAgY29uc3QgcGFyZW50VHlwZSA9IHBhcmVudC50eXBlO1xuICByZXR1cm4gcGFyZW50VHlwZSA9PT0gXCJUU0ludGVyc2VjdGlvblR5cGVcIiB8fCBwYXJlbnRUeXBlID09PSBcIlRTVHlwZU9wZXJhdG9yXCIgfHwgcGFyZW50VHlwZSA9PT0gXCJUU0FycmF5VHlwZVwiIHx8IHBhcmVudFR5cGUgPT09IFwiVFNJbmRleGVkQWNjZXNzVHlwZVwiICYmIHBhcmVudC5vYmplY3RUeXBlID09PSBub2RlIHx8IHBhcmVudFR5cGUgPT09IFwiVFNPcHRpb25hbFR5cGVcIjtcbn1cbmZ1bmN0aW9uIFRTSW50ZXJzZWN0aW9uVHlwZShub2RlLCBwYXJlbnQpIHtcbiAgY29uc3QgcGFyZW50VHlwZSA9IHBhcmVudC50eXBlO1xuICByZXR1cm4gcGFyZW50VHlwZSA9PT0gXCJUU1R5cGVPcGVyYXRvclwiIHx8IHBhcmVudFR5cGUgPT09IFwiVFNBcnJheVR5cGVcIiB8fCBwYXJlbnRUeXBlID09PSBcIlRTSW5kZXhlZEFjY2Vzc1R5cGVcIiAmJiBwYXJlbnQub2JqZWN0VHlwZSA9PT0gbm9kZSB8fCBwYXJlbnRUeXBlID09PSBcIlRTT3B0aW9uYWxUeXBlXCI7XG59XG5mdW5jdGlvbiBUU0luZmVyVHlwZShub2RlLCBwYXJlbnQpIHtcbiAgY29uc3QgcGFyZW50VHlwZSA9IHBhcmVudC50eXBlO1xuICBpZiAocGFyZW50VHlwZSA9PT0gXCJUU0FycmF5VHlwZVwiIHx8IHBhcmVudFR5cGUgPT09IFwiVFNJbmRleGVkQWNjZXNzVHlwZVwiICYmIHBhcmVudC5vYmplY3RUeXBlID09PSBub2RlIHx8IHBhcmVudFR5cGUgPT09IFwiVFNPcHRpb25hbFR5cGVcIikge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIGlmIChub2RlLnR5cGVQYXJhbWV0ZXIuY29uc3RyYWludCkge1xuICAgIGlmICgocGFyZW50VHlwZSA9PT0gXCJUU0ludGVyc2VjdGlvblR5cGVcIiB8fCBwYXJlbnRUeXBlID09PSBcIlRTVW5pb25UeXBlXCIpICYmIHBhcmVudC50eXBlc1swXSA9PT0gbm9kZSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9XG4gIHJldHVybiBmYWxzZTtcbn1cbmZ1bmN0aW9uIFRTVHlwZU9wZXJhdG9yKG5vZGUsIHBhcmVudCkge1xuICBjb25zdCBwYXJlbnRUeXBlID0gcGFyZW50LnR5cGU7XG4gIHJldHVybiBwYXJlbnRUeXBlID09PSBcIlRTQXJyYXlUeXBlXCIgfHwgcGFyZW50VHlwZSA9PT0gXCJUU0luZGV4ZWRBY2Nlc3NUeXBlXCIgJiYgcGFyZW50Lm9iamVjdFR5cGUgPT09IG5vZGUgfHwgcGFyZW50VHlwZSA9PT0gXCJUU09wdGlvbmFsVHlwZVwiO1xufVxuZnVuY3Rpb24gVFNJbnN0YW50aWF0aW9uRXhwcmVzc2lvbihub2RlLCBwYXJlbnQpIHtcbiAgY29uc3QgcGFyZW50VHlwZSA9IHBhcmVudC50eXBlO1xuICByZXR1cm4gKHBhcmVudFR5cGUgPT09IFwiQ2FsbEV4cHJlc3Npb25cIiB8fCBwYXJlbnRUeXBlID09PSBcIk9wdGlvbmFsQ2FsbEV4cHJlc3Npb25cIiB8fCBwYXJlbnRUeXBlID09PSBcIk5ld0V4cHJlc3Npb25cIiB8fCBwYXJlbnRUeXBlID09PSBcIlRTSW5zdGFudGlhdGlvbkV4cHJlc3Npb25cIikgJiYgISFwYXJlbnQudHlwZVBhcmFtZXRlcnM7XG59XG5mdW5jdGlvbiBUU0Z1bmN0aW9uVHlwZShub2RlLCBwYXJlbnQpIHtcbiAgY29uc3QgcGFyZW50VHlwZSA9IHBhcmVudC50eXBlO1xuICByZXR1cm4gcGFyZW50VHlwZSA9PT0gXCJUU0ludGVyc2VjdGlvblR5cGVcIiB8fCBwYXJlbnRUeXBlID09PSBcIlRTVW5pb25UeXBlXCIgfHwgcGFyZW50VHlwZSA9PT0gXCJUU1R5cGVPcGVyYXRvclwiIHx8IHBhcmVudFR5cGUgPT09IFwiVFNPcHRpb25hbFR5cGVcIiB8fCBwYXJlbnRUeXBlID09PSBcIlRTQXJyYXlUeXBlXCIgfHwgcGFyZW50VHlwZSA9PT0gXCJUU0luZGV4ZWRBY2Nlc3NUeXBlXCIgJiYgcGFyZW50Lm9iamVjdFR5cGUgPT09IG5vZGUgfHwgcGFyZW50VHlwZSA9PT0gXCJUU0NvbmRpdGlvbmFsVHlwZVwiICYmIChwYXJlbnQuY2hlY2tUeXBlID09PSBub2RlIHx8IHBhcmVudC5leHRlbmRzVHlwZSA9PT0gbm9kZSk7XG59XG5mdW5jdGlvbiBCaW5hcnlFeHByZXNzaW9uKG5vZGUsIHBhcmVudCwgdG9rZW5Db250ZXh0KSB7XG4gIHJldHVybiBub2RlLm9wZXJhdG9yID09PSBcImluXCIgJiYgQm9vbGVhbih0b2tlbkNvbnRleHQgJiBfaW5kZXguVG9rZW5Db250ZXh0LmZvckluT3JJbml0SGVhZEFjY3VtdWxhdGUpO1xufVxuZnVuY3Rpb24gU2VxdWVuY2VFeHByZXNzaW9uKG5vZGUsIHBhcmVudCkge1xuICBjb25zdCBwYXJlbnRUeXBlID0gcGFyZW50LnR5cGU7XG4gIGlmIChwYXJlbnRUeXBlID09PSBcIlNlcXVlbmNlRXhwcmVzc2lvblwiIHx8IHBhcmVudFR5cGUgPT09IFwiUGFyZW50aGVzaXplZEV4cHJlc3Npb25cIiB8fCBwYXJlbnRUeXBlID09PSBcIk1lbWJlckV4cHJlc3Npb25cIiAmJiBwYXJlbnQucHJvcGVydHkgPT09IG5vZGUgfHwgcGFyZW50VHlwZSA9PT0gXCJPcHRpb25hbE1lbWJlckV4cHJlc3Npb25cIiAmJiBwYXJlbnQucHJvcGVydHkgPT09IG5vZGUgfHwgcGFyZW50VHlwZSA9PT0gXCJUZW1wbGF0ZUxpdGVyYWxcIikge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBpZiAocGFyZW50VHlwZSA9PT0gXCJDbGFzc0RlY2xhcmF0aW9uXCIpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICBpZiAocGFyZW50VHlwZSA9PT0gXCJGb3JPZlN0YXRlbWVudFwiKSB7XG4gICAgcmV0dXJuIHBhcmVudC5yaWdodCA9PT0gbm9kZTtcbiAgfVxuICBpZiAocGFyZW50VHlwZSA9PT0gXCJFeHBvcnREZWZhdWx0RGVjbGFyYXRpb25cIikge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIHJldHVybiAhaXNTdGF0ZW1lbnQocGFyZW50KTtcbn1cbmZ1bmN0aW9uIFlpZWxkRXhwcmVzc2lvbihub2RlLCBwYXJlbnQpIHtcbiAgY29uc3QgcGFyZW50VHlwZSA9IHBhcmVudC50eXBlO1xuICByZXR1cm4gcGFyZW50VHlwZSA9PT0gXCJCaW5hcnlFeHByZXNzaW9uXCIgfHwgcGFyZW50VHlwZSA9PT0gXCJMb2dpY2FsRXhwcmVzc2lvblwiIHx8IHBhcmVudFR5cGUgPT09IFwiVW5hcnlFeHByZXNzaW9uXCIgfHwgcGFyZW50VHlwZSA9PT0gXCJTcHJlYWRFbGVtZW50XCIgfHwgaGFzUG9zdGZpeFBhcnQobm9kZSwgcGFyZW50KSB8fCBwYXJlbnRUeXBlID09PSBcIkF3YWl0RXhwcmVzc2lvblwiICYmIGlzWWllbGRFeHByZXNzaW9uKG5vZGUpIHx8IHBhcmVudFR5cGUgPT09IFwiQ29uZGl0aW9uYWxFeHByZXNzaW9uXCIgJiYgbm9kZSA9PT0gcGFyZW50LnRlc3QgfHwgaXNDbGFzc0V4dGVuZHNDbGF1c2Uobm9kZSwgcGFyZW50KSB8fCBpc1RTVHlwZUV4cHJlc3Npb24ocGFyZW50VHlwZSk7XG59XG5mdW5jdGlvbiBDbGFzc0V4cHJlc3Npb24obm9kZSwgcGFyZW50LCB0b2tlbkNvbnRleHQpIHtcbiAgcmV0dXJuIEJvb2xlYW4odG9rZW5Db250ZXh0ICYgKF9pbmRleC5Ub2tlbkNvbnRleHQuZXhwcmVzc2lvblN0YXRlbWVudCB8IF9pbmRleC5Ub2tlbkNvbnRleHQuZXhwb3J0RGVmYXVsdCkpO1xufVxuZnVuY3Rpb24gVW5hcnlMaWtlKG5vZGUsIHBhcmVudCkge1xuICByZXR1cm4gaGFzUG9zdGZpeFBhcnQobm9kZSwgcGFyZW50KSB8fCBpc0JpbmFyeUV4cHJlc3Npb24ocGFyZW50KSAmJiBwYXJlbnQub3BlcmF0b3IgPT09IFwiKipcIiAmJiBwYXJlbnQubGVmdCA9PT0gbm9kZSB8fCBpc0NsYXNzRXh0ZW5kc0NsYXVzZShub2RlLCBwYXJlbnQpO1xufVxuZnVuY3Rpb24gRnVuY3Rpb25FeHByZXNzaW9uKG5vZGUsIHBhcmVudCwgdG9rZW5Db250ZXh0KSB7XG4gIHJldHVybiBCb29sZWFuKHRva2VuQ29udGV4dCAmIChfaW5kZXguVG9rZW5Db250ZXh0LmV4cHJlc3Npb25TdGF0ZW1lbnQgfCBfaW5kZXguVG9rZW5Db250ZXh0LmV4cG9ydERlZmF1bHQpKTtcbn1cbmZ1bmN0aW9uIENvbmRpdGlvbmFsRXhwcmVzc2lvbihub2RlLCBwYXJlbnQpIHtcbiAgY29uc3QgcGFyZW50VHlwZSA9IHBhcmVudC50eXBlO1xuICBpZiAocGFyZW50VHlwZSA9PT0gXCJVbmFyeUV4cHJlc3Npb25cIiB8fCBwYXJlbnRUeXBlID09PSBcIlNwcmVhZEVsZW1lbnRcIiB8fCBwYXJlbnRUeXBlID09PSBcIkJpbmFyeUV4cHJlc3Npb25cIiB8fCBwYXJlbnRUeXBlID09PSBcIkxvZ2ljYWxFeHByZXNzaW9uXCIgfHwgcGFyZW50VHlwZSA9PT0gXCJDb25kaXRpb25hbEV4cHJlc3Npb25cIiAmJiBwYXJlbnQudGVzdCA9PT0gbm9kZSB8fCBwYXJlbnRUeXBlID09PSBcIkF3YWl0RXhwcmVzc2lvblwiIHx8IGlzVFNUeXBlRXhwcmVzc2lvbihwYXJlbnRUeXBlKSkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIHJldHVybiBVbmFyeUxpa2Uobm9kZSwgcGFyZW50KTtcbn1cbmZ1bmN0aW9uIE9wdGlvbmFsTWVtYmVyRXhwcmVzc2lvbihub2RlLCBwYXJlbnQpIHtcbiAgcmV0dXJuIGlzQ2FsbEV4cHJlc3Npb24ocGFyZW50KSAmJiBwYXJlbnQuY2FsbGVlID09PSBub2RlIHx8IGlzTWVtYmVyRXhwcmVzc2lvbihwYXJlbnQpICYmIHBhcmVudC5vYmplY3QgPT09IG5vZGU7XG59XG5mdW5jdGlvbiBBc3NpZ25tZW50RXhwcmVzc2lvbihub2RlLCBwYXJlbnQsIHRva2VuQ29udGV4dCkge1xuICBpZiAobmVlZHNQYXJlbkJlZm9yZUV4cHJlc3Npb25CcmFjZSh0b2tlbkNvbnRleHQpICYmIGlzT2JqZWN0UGF0dGVybihub2RlLmxlZnQpKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIENvbmRpdGlvbmFsRXhwcmVzc2lvbihub2RlLCBwYXJlbnQpO1xuICB9XG59XG5mdW5jdGlvbiBMb2dpY2FsRXhwcmVzc2lvbihub2RlLCBwYXJlbnQpIHtcbiAgY29uc3QgcGFyZW50VHlwZSA9IHBhcmVudC50eXBlO1xuICBpZiAoaXNUU1R5cGVFeHByZXNzaW9uKHBhcmVudFR5cGUpKSByZXR1cm4gdHJ1ZTtcbiAgaWYgKHBhcmVudFR5cGUgIT09IFwiTG9naWNhbEV4cHJlc3Npb25cIikgcmV0dXJuIGZhbHNlO1xuICBzd2l0Y2ggKG5vZGUub3BlcmF0b3IpIHtcbiAgICBjYXNlIFwifHxcIjpcbiAgICAgIHJldHVybiBwYXJlbnQub3BlcmF0b3IgPT09IFwiPz9cIiB8fCBwYXJlbnQub3BlcmF0b3IgPT09IFwiJiZcIjtcbiAgICBjYXNlIFwiJiZcIjpcbiAgICAgIHJldHVybiBwYXJlbnQub3BlcmF0b3IgPT09IFwiPz9cIjtcbiAgICBjYXNlIFwiPz9cIjpcbiAgICAgIHJldHVybiBwYXJlbnQub3BlcmF0b3IgIT09IFwiPz9cIjtcbiAgfVxufVxuZnVuY3Rpb24gSWRlbnRpZmllcihub2RlLCBwYXJlbnQsIHRva2VuQ29udGV4dCwgZ2V0UmF3SWRlbnRpZmllcikge1xuICB2YXIgX25vZGUkZXh0cmE7XG4gIGNvbnN0IHBhcmVudFR5cGUgPSBwYXJlbnQudHlwZTtcbiAgaWYgKChfbm9kZSRleHRyYSA9IG5vZGUuZXh0cmEpICE9IG51bGwgJiYgX25vZGUkZXh0cmEucGFyZW50aGVzaXplZCAmJiBwYXJlbnRUeXBlID09PSBcIkFzc2lnbm1lbnRFeHByZXNzaW9uXCIgJiYgcGFyZW50LmxlZnQgPT09IG5vZGUpIHtcbiAgICBjb25zdCByaWdodFR5cGUgPSBwYXJlbnQucmlnaHQudHlwZTtcbiAgICBpZiAoKHJpZ2h0VHlwZSA9PT0gXCJGdW5jdGlvbkV4cHJlc3Npb25cIiB8fCByaWdodFR5cGUgPT09IFwiQ2xhc3NFeHByZXNzaW9uXCIpICYmIHBhcmVudC5yaWdodC5pZCA9PSBudWxsKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH1cbiAgaWYgKGdldFJhd0lkZW50aWZpZXIgJiYgZ2V0UmF3SWRlbnRpZmllcihub2RlKSAhPT0gbm9kZS5uYW1lKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGlmIChub2RlLm5hbWUgPT09IFwibGV0XCIpIHtcbiAgICBjb25zdCBpc0ZvbGxvd2VkQnlCcmFja2V0ID0gaXNNZW1iZXJFeHByZXNzaW9uKHBhcmVudCwge1xuICAgICAgb2JqZWN0OiBub2RlLFxuICAgICAgY29tcHV0ZWQ6IHRydWVcbiAgICB9KSB8fCBpc09wdGlvbmFsTWVtYmVyRXhwcmVzc2lvbihwYXJlbnQsIHtcbiAgICAgIG9iamVjdDogbm9kZSxcbiAgICAgIGNvbXB1dGVkOiB0cnVlLFxuICAgICAgb3B0aW9uYWw6IGZhbHNlXG4gICAgfSk7XG4gICAgaWYgKGlzRm9sbG93ZWRCeUJyYWNrZXQgJiYgdG9rZW5Db250ZXh0ICYgKF9pbmRleC5Ub2tlbkNvbnRleHQuZXhwcmVzc2lvblN0YXRlbWVudCB8IF9pbmRleC5Ub2tlbkNvbnRleHQuZm9ySW5pdEhlYWQgfCBfaW5kZXguVG9rZW5Db250ZXh0LmZvckluSGVhZCkpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gQm9vbGVhbih0b2tlbkNvbnRleHQgJiBfaW5kZXguVG9rZW5Db250ZXh0LmZvck9mSGVhZCk7XG4gIH1cbiAgcmV0dXJuIG5vZGUubmFtZSA9PT0gXCJhc3luY1wiICYmIGlzRm9yT2ZTdGF0ZW1lbnQocGFyZW50LCB7XG4gICAgbGVmdDogbm9kZSxcbiAgICBhd2FpdDogZmFsc2VcbiAgfSk7XG59XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXBhcmVudGhlc2VzLmpzLm1hcFxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@babel/generator/lib/node/parentheses.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@babel/generator/lib/node/whitespace.js":
/*!**************************************************************!*\
  !*** ./node_modules/@babel/generator/lib/node/whitespace.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports.nodes = void 0;\nvar _t = __webpack_require__(/*! @babel/types */ \"(ssr)/./node_modules/@babel/types/lib/index.js\");\nconst {\n  FLIPPED_ALIAS_KEYS,\n  isArrayExpression,\n  isAssignmentExpression,\n  isBinary,\n  isBlockStatement,\n  isCallExpression,\n  isFunction,\n  isIdentifier,\n  isLiteral,\n  isMemberExpression,\n  isObjectExpression,\n  isOptionalCallExpression,\n  isOptionalMemberExpression,\n  isStringLiteral\n} = _t;\nfunction crawlInternal(node, state) {\n  if (!node) return state;\n  if (isMemberExpression(node) || isOptionalMemberExpression(node)) {\n    crawlInternal(node.object, state);\n    if (node.computed) crawlInternal(node.property, state);\n  } else if (isBinary(node) || isAssignmentExpression(node)) {\n    crawlInternal(node.left, state);\n    crawlInternal(node.right, state);\n  } else if (isCallExpression(node) || isOptionalCallExpression(node)) {\n    state.hasCall = true;\n    crawlInternal(node.callee, state);\n  } else if (isFunction(node)) {\n    state.hasFunction = true;\n  } else if (isIdentifier(node)) {\n    state.hasHelper = state.hasHelper || node.callee && isHelper(node.callee);\n  }\n  return state;\n}\nfunction crawl(node) {\n  return crawlInternal(node, {\n    hasCall: false,\n    hasFunction: false,\n    hasHelper: false\n  });\n}\nfunction isHelper(node) {\n  if (!node) return false;\n  if (isMemberExpression(node)) {\n    return isHelper(node.object) || isHelper(node.property);\n  } else if (isIdentifier(node)) {\n    return node.name === \"require\" || node.name.charCodeAt(0) === 95;\n  } else if (isCallExpression(node)) {\n    return isHelper(node.callee);\n  } else if (isBinary(node) || isAssignmentExpression(node)) {\n    return isIdentifier(node.left) && isHelper(node.left) || isHelper(node.right);\n  } else {\n    return false;\n  }\n}\nfunction isType(node) {\n  return isLiteral(node) || isObjectExpression(node) || isArrayExpression(node) || isIdentifier(node) || isMemberExpression(node);\n}\nconst nodes = exports.nodes = {\n  AssignmentExpression(node) {\n    const state = crawl(node.right);\n    if (state.hasCall && state.hasHelper || state.hasFunction) {\n      return state.hasFunction ? 1 | 2 : 2;\n    }\n    return 0;\n  },\n  SwitchCase(node, parent) {\n    return (!!node.consequent.length || parent.cases[0] === node ? 1 : 0) | (!node.consequent.length && parent.cases[parent.cases.length - 1] === node ? 2 : 0);\n  },\n  LogicalExpression(node) {\n    if (isFunction(node.left) || isFunction(node.right)) {\n      return 2;\n    }\n    return 0;\n  },\n  Literal(node) {\n    if (isStringLiteral(node) && node.value === \"use strict\") {\n      return 2;\n    }\n    return 0;\n  },\n  CallExpression(node) {\n    if (isFunction(node.callee) || isHelper(node)) {\n      return 1 | 2;\n    }\n    return 0;\n  },\n  OptionalCallExpression(node) {\n    if (isFunction(node.callee)) {\n      return 1 | 2;\n    }\n    return 0;\n  },\n  VariableDeclaration(node) {\n    for (let i = 0; i < node.declarations.length; i++) {\n      const declar = node.declarations[i];\n      let enabled = isHelper(declar.id) && !isType(declar.init);\n      if (!enabled && declar.init) {\n        const state = crawl(declar.init);\n        enabled = isHelper(declar.init) && state.hasCall || state.hasFunction;\n      }\n      if (enabled) {\n        return 1 | 2;\n      }\n    }\n    return 0;\n  },\n  IfStatement(node) {\n    if (isBlockStatement(node.consequent)) {\n      return 1 | 2;\n    }\n    return 0;\n  }\n};\nnodes.ObjectProperty = nodes.ObjectTypeProperty = nodes.ObjectMethod = function (node, parent) {\n  if (parent.properties[0] === node) {\n    return 1;\n  }\n  return 0;\n};\nnodes.ObjectTypeCallProperty = function (node, parent) {\n  var _parent$properties;\n  if (parent.callProperties[0] === node && !((_parent$properties = parent.properties) != null && _parent$properties.length)) {\n    return 1;\n  }\n  return 0;\n};\nnodes.ObjectTypeIndexer = function (node, parent) {\n  var _parent$properties2, _parent$callPropertie;\n  if (parent.indexers[0] === node && !((_parent$properties2 = parent.properties) != null && _parent$properties2.length) && !((_parent$callPropertie = parent.callProperties) != null && _parent$callPropertie.length)) {\n    return 1;\n  }\n  return 0;\n};\nnodes.ObjectTypeInternalSlot = function (node, parent) {\n  var _parent$properties3, _parent$callPropertie2, _parent$indexers;\n  if (parent.internalSlots[0] === node && !((_parent$properties3 = parent.properties) != null && _parent$properties3.length) && !((_parent$callPropertie2 = parent.callProperties) != null && _parent$callPropertie2.length) && !((_parent$indexers = parent.indexers) != null && _parent$indexers.length)) {\n    return 1;\n  }\n  return 0;\n};\n[[\"Function\", true], [\"Class\", true], [\"Loop\", true], [\"LabeledStatement\", true], [\"SwitchStatement\", true], [\"TryStatement\", true]].forEach(function ([type, amounts]) {\n  [type].concat(FLIPPED_ALIAS_KEYS[type] || []).forEach(function (type) {\n    const ret = amounts ? 1 | 2 : 0;\n    nodes[type] = () => ret;\n  });\n});\n\n//# sourceMappingURL=whitespace.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGJhYmVsL2dlbmVyYXRvci9saWIvbm9kZS93aGl0ZXNwYWNlLmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViLDhDQUE2QztBQUM3QztBQUNBLENBQUMsRUFBQztBQUNGLGFBQWE7QUFDYixTQUFTLG1CQUFPLENBQUMsb0VBQWM7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsYUFBYTtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0Esb0JBQW9CLDhCQUE4QjtBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsQ0FBQzs7QUFFRCIsInNvdXJjZXMiOlsid2VicGFjazovL3JlcG8tdmlzdWFsaXplci8uL25vZGVfbW9kdWxlcy9AYmFiZWwvZ2VuZXJhdG9yL2xpYi9ub2RlL3doaXRlc3BhY2UuanM/NGMxOCJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMubm9kZXMgPSB2b2lkIDA7XG52YXIgX3QgPSByZXF1aXJlKFwiQGJhYmVsL3R5cGVzXCIpO1xuY29uc3Qge1xuICBGTElQUEVEX0FMSUFTX0tFWVMsXG4gIGlzQXJyYXlFeHByZXNzaW9uLFxuICBpc0Fzc2lnbm1lbnRFeHByZXNzaW9uLFxuICBpc0JpbmFyeSxcbiAgaXNCbG9ja1N0YXRlbWVudCxcbiAgaXNDYWxsRXhwcmVzc2lvbixcbiAgaXNGdW5jdGlvbixcbiAgaXNJZGVudGlmaWVyLFxuICBpc0xpdGVyYWwsXG4gIGlzTWVtYmVyRXhwcmVzc2lvbixcbiAgaXNPYmplY3RFeHByZXNzaW9uLFxuICBpc09wdGlvbmFsQ2FsbEV4cHJlc3Npb24sXG4gIGlzT3B0aW9uYWxNZW1iZXJFeHByZXNzaW9uLFxuICBpc1N0cmluZ0xpdGVyYWxcbn0gPSBfdDtcbmZ1bmN0aW9uIGNyYXdsSW50ZXJuYWwobm9kZSwgc3RhdGUpIHtcbiAgaWYgKCFub2RlKSByZXR1cm4gc3RhdGU7XG4gIGlmIChpc01lbWJlckV4cHJlc3Npb24obm9kZSkgfHwgaXNPcHRpb25hbE1lbWJlckV4cHJlc3Npb24obm9kZSkpIHtcbiAgICBjcmF3bEludGVybmFsKG5vZGUub2JqZWN0LCBzdGF0ZSk7XG4gICAgaWYgKG5vZGUuY29tcHV0ZWQpIGNyYXdsSW50ZXJuYWwobm9kZS5wcm9wZXJ0eSwgc3RhdGUpO1xuICB9IGVsc2UgaWYgKGlzQmluYXJ5KG5vZGUpIHx8IGlzQXNzaWdubWVudEV4cHJlc3Npb24obm9kZSkpIHtcbiAgICBjcmF3bEludGVybmFsKG5vZGUubGVmdCwgc3RhdGUpO1xuICAgIGNyYXdsSW50ZXJuYWwobm9kZS5yaWdodCwgc3RhdGUpO1xuICB9IGVsc2UgaWYgKGlzQ2FsbEV4cHJlc3Npb24obm9kZSkgfHwgaXNPcHRpb25hbENhbGxFeHByZXNzaW9uKG5vZGUpKSB7XG4gICAgc3RhdGUuaGFzQ2FsbCA9IHRydWU7XG4gICAgY3Jhd2xJbnRlcm5hbChub2RlLmNhbGxlZSwgc3RhdGUpO1xuICB9IGVsc2UgaWYgKGlzRnVuY3Rpb24obm9kZSkpIHtcbiAgICBzdGF0ZS5oYXNGdW5jdGlvbiA9IHRydWU7XG4gIH0gZWxzZSBpZiAoaXNJZGVudGlmaWVyKG5vZGUpKSB7XG4gICAgc3RhdGUuaGFzSGVscGVyID0gc3RhdGUuaGFzSGVscGVyIHx8IG5vZGUuY2FsbGVlICYmIGlzSGVscGVyKG5vZGUuY2FsbGVlKTtcbiAgfVxuICByZXR1cm4gc3RhdGU7XG59XG5mdW5jdGlvbiBjcmF3bChub2RlKSB7XG4gIHJldHVybiBjcmF3bEludGVybmFsKG5vZGUsIHtcbiAgICBoYXNDYWxsOiBmYWxzZSxcbiAgICBoYXNGdW5jdGlvbjogZmFsc2UsXG4gICAgaGFzSGVscGVyOiBmYWxzZVxuICB9KTtcbn1cbmZ1bmN0aW9uIGlzSGVscGVyKG5vZGUpIHtcbiAgaWYgKCFub2RlKSByZXR1cm4gZmFsc2U7XG4gIGlmIChpc01lbWJlckV4cHJlc3Npb24obm9kZSkpIHtcbiAgICByZXR1cm4gaXNIZWxwZXIobm9kZS5vYmplY3QpIHx8IGlzSGVscGVyKG5vZGUucHJvcGVydHkpO1xuICB9IGVsc2UgaWYgKGlzSWRlbnRpZmllcihub2RlKSkge1xuICAgIHJldHVybiBub2RlLm5hbWUgPT09IFwicmVxdWlyZVwiIHx8IG5vZGUubmFtZS5jaGFyQ29kZUF0KDApID09PSA5NTtcbiAgfSBlbHNlIGlmIChpc0NhbGxFeHByZXNzaW9uKG5vZGUpKSB7XG4gICAgcmV0dXJuIGlzSGVscGVyKG5vZGUuY2FsbGVlKTtcbiAgfSBlbHNlIGlmIChpc0JpbmFyeShub2RlKSB8fCBpc0Fzc2lnbm1lbnRFeHByZXNzaW9uKG5vZGUpKSB7XG4gICAgcmV0dXJuIGlzSWRlbnRpZmllcihub2RlLmxlZnQpICYmIGlzSGVscGVyKG5vZGUubGVmdCkgfHwgaXNIZWxwZXIobm9kZS5yaWdodCk7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG59XG5mdW5jdGlvbiBpc1R5cGUobm9kZSkge1xuICByZXR1cm4gaXNMaXRlcmFsKG5vZGUpIHx8IGlzT2JqZWN0RXhwcmVzc2lvbihub2RlKSB8fCBpc0FycmF5RXhwcmVzc2lvbihub2RlKSB8fCBpc0lkZW50aWZpZXIobm9kZSkgfHwgaXNNZW1iZXJFeHByZXNzaW9uKG5vZGUpO1xufVxuY29uc3Qgbm9kZXMgPSBleHBvcnRzLm5vZGVzID0ge1xuICBBc3NpZ25tZW50RXhwcmVzc2lvbihub2RlKSB7XG4gICAgY29uc3Qgc3RhdGUgPSBjcmF3bChub2RlLnJpZ2h0KTtcbiAgICBpZiAoc3RhdGUuaGFzQ2FsbCAmJiBzdGF0ZS5oYXNIZWxwZXIgfHwgc3RhdGUuaGFzRnVuY3Rpb24pIHtcbiAgICAgIHJldHVybiBzdGF0ZS5oYXNGdW5jdGlvbiA/IDEgfCAyIDogMjtcbiAgICB9XG4gICAgcmV0dXJuIDA7XG4gIH0sXG4gIFN3aXRjaENhc2Uobm9kZSwgcGFyZW50KSB7XG4gICAgcmV0dXJuICghIW5vZGUuY29uc2VxdWVudC5sZW5ndGggfHwgcGFyZW50LmNhc2VzWzBdID09PSBub2RlID8gMSA6IDApIHwgKCFub2RlLmNvbnNlcXVlbnQubGVuZ3RoICYmIHBhcmVudC5jYXNlc1twYXJlbnQuY2FzZXMubGVuZ3RoIC0gMV0gPT09IG5vZGUgPyAyIDogMCk7XG4gIH0sXG4gIExvZ2ljYWxFeHByZXNzaW9uKG5vZGUpIHtcbiAgICBpZiAoaXNGdW5jdGlvbihub2RlLmxlZnQpIHx8IGlzRnVuY3Rpb24obm9kZS5yaWdodCkpIHtcbiAgICAgIHJldHVybiAyO1xuICAgIH1cbiAgICByZXR1cm4gMDtcbiAgfSxcbiAgTGl0ZXJhbChub2RlKSB7XG4gICAgaWYgKGlzU3RyaW5nTGl0ZXJhbChub2RlKSAmJiBub2RlLnZhbHVlID09PSBcInVzZSBzdHJpY3RcIikge1xuICAgICAgcmV0dXJuIDI7XG4gICAgfVxuICAgIHJldHVybiAwO1xuICB9LFxuICBDYWxsRXhwcmVzc2lvbihub2RlKSB7XG4gICAgaWYgKGlzRnVuY3Rpb24obm9kZS5jYWxsZWUpIHx8IGlzSGVscGVyKG5vZGUpKSB7XG4gICAgICByZXR1cm4gMSB8IDI7XG4gICAgfVxuICAgIHJldHVybiAwO1xuICB9LFxuICBPcHRpb25hbENhbGxFeHByZXNzaW9uKG5vZGUpIHtcbiAgICBpZiAoaXNGdW5jdGlvbihub2RlLmNhbGxlZSkpIHtcbiAgICAgIHJldHVybiAxIHwgMjtcbiAgICB9XG4gICAgcmV0dXJuIDA7XG4gIH0sXG4gIFZhcmlhYmxlRGVjbGFyYXRpb24obm9kZSkge1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbm9kZS5kZWNsYXJhdGlvbnMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvbnN0IGRlY2xhciA9IG5vZGUuZGVjbGFyYXRpb25zW2ldO1xuICAgICAgbGV0IGVuYWJsZWQgPSBpc0hlbHBlcihkZWNsYXIuaWQpICYmICFpc1R5cGUoZGVjbGFyLmluaXQpO1xuICAgICAgaWYgKCFlbmFibGVkICYmIGRlY2xhci5pbml0KSB7XG4gICAgICAgIGNvbnN0IHN0YXRlID0gY3Jhd2woZGVjbGFyLmluaXQpO1xuICAgICAgICBlbmFibGVkID0gaXNIZWxwZXIoZGVjbGFyLmluaXQpICYmIHN0YXRlLmhhc0NhbGwgfHwgc3RhdGUuaGFzRnVuY3Rpb247XG4gICAgICB9XG4gICAgICBpZiAoZW5hYmxlZCkge1xuICAgICAgICByZXR1cm4gMSB8IDI7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiAwO1xuICB9LFxuICBJZlN0YXRlbWVudChub2RlKSB7XG4gICAgaWYgKGlzQmxvY2tTdGF0ZW1lbnQobm9kZS5jb25zZXF1ZW50KSkge1xuICAgICAgcmV0dXJuIDEgfCAyO1xuICAgIH1cbiAgICByZXR1cm4gMDtcbiAgfVxufTtcbm5vZGVzLk9iamVjdFByb3BlcnR5ID0gbm9kZXMuT2JqZWN0VHlwZVByb3BlcnR5ID0gbm9kZXMuT2JqZWN0TWV0aG9kID0gZnVuY3Rpb24gKG5vZGUsIHBhcmVudCkge1xuICBpZiAocGFyZW50LnByb3BlcnRpZXNbMF0gPT09IG5vZGUpIHtcbiAgICByZXR1cm4gMTtcbiAgfVxuICByZXR1cm4gMDtcbn07XG5ub2Rlcy5PYmplY3RUeXBlQ2FsbFByb3BlcnR5ID0gZnVuY3Rpb24gKG5vZGUsIHBhcmVudCkge1xuICB2YXIgX3BhcmVudCRwcm9wZXJ0aWVzO1xuICBpZiAocGFyZW50LmNhbGxQcm9wZXJ0aWVzWzBdID09PSBub2RlICYmICEoKF9wYXJlbnQkcHJvcGVydGllcyA9IHBhcmVudC5wcm9wZXJ0aWVzKSAhPSBudWxsICYmIF9wYXJlbnQkcHJvcGVydGllcy5sZW5ndGgpKSB7XG4gICAgcmV0dXJuIDE7XG4gIH1cbiAgcmV0dXJuIDA7XG59O1xubm9kZXMuT2JqZWN0VHlwZUluZGV4ZXIgPSBmdW5jdGlvbiAobm9kZSwgcGFyZW50KSB7XG4gIHZhciBfcGFyZW50JHByb3BlcnRpZXMyLCBfcGFyZW50JGNhbGxQcm9wZXJ0aWU7XG4gIGlmIChwYXJlbnQuaW5kZXhlcnNbMF0gPT09IG5vZGUgJiYgISgoX3BhcmVudCRwcm9wZXJ0aWVzMiA9IHBhcmVudC5wcm9wZXJ0aWVzKSAhPSBudWxsICYmIF9wYXJlbnQkcHJvcGVydGllczIubGVuZ3RoKSAmJiAhKChfcGFyZW50JGNhbGxQcm9wZXJ0aWUgPSBwYXJlbnQuY2FsbFByb3BlcnRpZXMpICE9IG51bGwgJiYgX3BhcmVudCRjYWxsUHJvcGVydGllLmxlbmd0aCkpIHtcbiAgICByZXR1cm4gMTtcbiAgfVxuICByZXR1cm4gMDtcbn07XG5ub2Rlcy5PYmplY3RUeXBlSW50ZXJuYWxTbG90ID0gZnVuY3Rpb24gKG5vZGUsIHBhcmVudCkge1xuICB2YXIgX3BhcmVudCRwcm9wZXJ0aWVzMywgX3BhcmVudCRjYWxsUHJvcGVydGllMiwgX3BhcmVudCRpbmRleGVycztcbiAgaWYgKHBhcmVudC5pbnRlcm5hbFNsb3RzWzBdID09PSBub2RlICYmICEoKF9wYXJlbnQkcHJvcGVydGllczMgPSBwYXJlbnQucHJvcGVydGllcykgIT0gbnVsbCAmJiBfcGFyZW50JHByb3BlcnRpZXMzLmxlbmd0aCkgJiYgISgoX3BhcmVudCRjYWxsUHJvcGVydGllMiA9IHBhcmVudC5jYWxsUHJvcGVydGllcykgIT0gbnVsbCAmJiBfcGFyZW50JGNhbGxQcm9wZXJ0aWUyLmxlbmd0aCkgJiYgISgoX3BhcmVudCRpbmRleGVycyA9IHBhcmVudC5pbmRleGVycykgIT0gbnVsbCAmJiBfcGFyZW50JGluZGV4ZXJzLmxlbmd0aCkpIHtcbiAgICByZXR1cm4gMTtcbiAgfVxuICByZXR1cm4gMDtcbn07XG5bW1wiRnVuY3Rpb25cIiwgdHJ1ZV0sIFtcIkNsYXNzXCIsIHRydWVdLCBbXCJMb29wXCIsIHRydWVdLCBbXCJMYWJlbGVkU3RhdGVtZW50XCIsIHRydWVdLCBbXCJTd2l0Y2hTdGF0ZW1lbnRcIiwgdHJ1ZV0sIFtcIlRyeVN0YXRlbWVudFwiLCB0cnVlXV0uZm9yRWFjaChmdW5jdGlvbiAoW3R5cGUsIGFtb3VudHNdKSB7XG4gIFt0eXBlXS5jb25jYXQoRkxJUFBFRF9BTElBU19LRVlTW3R5cGVdIHx8IFtdKS5mb3JFYWNoKGZ1bmN0aW9uICh0eXBlKSB7XG4gICAgY29uc3QgcmV0ID0gYW1vdW50cyA/IDEgfCAyIDogMDtcbiAgICBub2Rlc1t0eXBlXSA9ICgpID0+IHJldDtcbiAgfSk7XG59KTtcblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9d2hpdGVzcGFjZS5qcy5tYXBcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@babel/generator/lib/node/whitespace.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@babel/generator/lib/printer.js":
/*!******************************************************!*\
  !*** ./node_modules/@babel/generator/lib/printer.js ***!
  \******************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports[\"default\"] = void 0;\nvar _buffer = __webpack_require__(/*! ./buffer.js */ \"(ssr)/./node_modules/@babel/generator/lib/buffer.js\");\nvar _index = __webpack_require__(/*! ./node/index.js */ \"(ssr)/./node_modules/@babel/generator/lib/node/index.js\");\nvar n = _index;\nvar _t = __webpack_require__(/*! @babel/types */ \"(ssr)/./node_modules/@babel/types/lib/index.js\");\nvar _tokenMap = __webpack_require__(/*! ./token-map.js */ \"(ssr)/./node_modules/@babel/generator/lib/token-map.js\");\nvar generatorFunctions = __webpack_require__(/*! ./generators/index.js */ \"(ssr)/./node_modules/@babel/generator/lib/generators/index.js\");\nvar _deprecated = __webpack_require__(/*! ./generators/deprecated.js */ \"(ssr)/./node_modules/@babel/generator/lib/generators/deprecated.js\");\nconst {\n  isExpression,\n  isFunction,\n  isStatement,\n  isClassBody,\n  isTSInterfaceBody,\n  isTSEnumMember\n} = _t;\nconst SCIENTIFIC_NOTATION = /e/i;\nconst ZERO_DECIMAL_INTEGER = /\\.0+$/;\nconst HAS_NEWLINE = /[\\n\\r\\u2028\\u2029]/;\nconst HAS_NEWLINE_OR_BlOCK_COMMENT_END = /[\\n\\r\\u2028\\u2029]|\\*\\//;\nfunction commentIsNewline(c) {\n  return c.type === \"CommentLine\" || HAS_NEWLINE.test(c.value);\n}\nconst {\n  needsParens\n} = n;\nclass Printer {\n  constructor(format, map, tokens = null, originalCode = null) {\n    this.tokenContext = _index.TokenContext.normal;\n    this._tokens = null;\n    this._originalCode = null;\n    this._currentNode = null;\n    this._indent = 0;\n    this._indentRepeat = 0;\n    this._insideAux = false;\n    this._noLineTerminator = false;\n    this._noLineTerminatorAfterNode = null;\n    this._printAuxAfterOnNextUserNode = false;\n    this._printedComments = new Set();\n    this._endsWithInteger = false;\n    this._endsWithWord = false;\n    this._endsWithDiv = false;\n    this._lastCommentLine = 0;\n    this._endsWithInnerRaw = false;\n    this._indentInnerComments = true;\n    this.tokenMap = null;\n    this._boundGetRawIdentifier = this._getRawIdentifier.bind(this);\n    this._printSemicolonBeforeNextNode = -1;\n    this._printSemicolonBeforeNextToken = -1;\n    this.format = format;\n    this._tokens = tokens;\n    this._originalCode = originalCode;\n    this._indentRepeat = format.indent.style.length;\n    this._inputMap = (map == null ? void 0 : map._inputMap) || null;\n    this._buf = new _buffer.default(map, format.indent.style[0]);\n  }\n  enterForStatementInit() {\n    this.tokenContext |= _index.TokenContext.forInitHead | _index.TokenContext.forInOrInitHeadAccumulate;\n    return () => this.tokenContext = _index.TokenContext.normal;\n  }\n  enterForXStatementInit(isForOf) {\n    if (isForOf) {\n      this.tokenContext |= _index.TokenContext.forOfHead;\n      return null;\n    } else {\n      this.tokenContext |= _index.TokenContext.forInHead | _index.TokenContext.forInOrInitHeadAccumulate;\n      return () => this.tokenContext = _index.TokenContext.normal;\n    }\n  }\n  enterDelimited() {\n    const oldTokenContext = this.tokenContext;\n    const oldNoLineTerminatorAfterNode = this._noLineTerminatorAfterNode;\n    if (!(oldTokenContext & _index.TokenContext.forInOrInitHeadAccumulate) && oldNoLineTerminatorAfterNode === null) {\n      return () => {};\n    }\n    this._noLineTerminatorAfterNode = null;\n    this.tokenContext = _index.TokenContext.normal;\n    return () => {\n      this._noLineTerminatorAfterNode = oldNoLineTerminatorAfterNode;\n      this.tokenContext = oldTokenContext;\n    };\n  }\n  generate(ast) {\n    if (this.format.preserveFormat) {\n      this.tokenMap = new _tokenMap.TokenMap(ast, this._tokens, this._originalCode);\n    }\n    this.print(ast);\n    this._maybeAddAuxComment();\n    return this._buf.get();\n  }\n  indent() {\n    const {\n      format\n    } = this;\n    if (format.preserveFormat || format.compact || format.concise) {\n      return;\n    }\n    this._indent++;\n  }\n  dedent() {\n    const {\n      format\n    } = this;\n    if (format.preserveFormat || format.compact || format.concise) {\n      return;\n    }\n    this._indent--;\n  }\n  semicolon(force = false) {\n    this._maybeAddAuxComment();\n    if (force) {\n      this._appendChar(59);\n      this._noLineTerminator = false;\n      return;\n    }\n    if (this.tokenMap) {\n      const node = this._currentNode;\n      if (node.start != null && node.end != null) {\n        if (!this.tokenMap.endMatches(node, \";\")) {\n          this._printSemicolonBeforeNextNode = this._buf.getCurrentLine();\n          return;\n        }\n        const indexes = this.tokenMap.getIndexes(this._currentNode);\n        this._catchUpTo(this._tokens[indexes[indexes.length - 1]].loc.start);\n      }\n    }\n    this._queue(59);\n    this._noLineTerminator = false;\n  }\n  rightBrace(node) {\n    if (this.format.minified) {\n      this._buf.removeLastSemicolon();\n    }\n    this.sourceWithOffset(\"end\", node.loc, -1);\n    this.tokenChar(125);\n  }\n  rightParens(node) {\n    this.sourceWithOffset(\"end\", node.loc, -1);\n    this.tokenChar(41);\n  }\n  space(force = false) {\n    const {\n      format\n    } = this;\n    if (format.compact || format.preserveFormat) return;\n    if (force) {\n      this._space();\n    } else if (this._buf.hasContent()) {\n      const lastCp = this.getLastChar();\n      if (lastCp !== 32 && lastCp !== 10) {\n        this._space();\n      }\n    }\n  }\n  word(str, noLineTerminatorAfter = false) {\n    this.tokenContext &= _index.TokenContext.forInOrInitHeadAccumulatePassThroughMask;\n    this._maybePrintInnerComments(str);\n    this._maybeAddAuxComment();\n    if (this.tokenMap) this._catchUpToCurrentToken(str);\n    if (this._endsWithWord || this._endsWithDiv && str.charCodeAt(0) === 47) {\n      this._space();\n    }\n    this._append(str, false);\n    this._endsWithWord = true;\n    this._noLineTerminator = noLineTerminatorAfter;\n  }\n  number(str, number) {\n    function isNonDecimalLiteral(str) {\n      if (str.length > 2 && str.charCodeAt(0) === 48) {\n        const secondChar = str.charCodeAt(1);\n        return secondChar === 98 || secondChar === 111 || secondChar === 120;\n      }\n      return false;\n    }\n    this.word(str);\n    this._endsWithInteger = Number.isInteger(number) && !isNonDecimalLiteral(str) && !SCIENTIFIC_NOTATION.test(str) && !ZERO_DECIMAL_INTEGER.test(str) && str.charCodeAt(str.length - 1) !== 46;\n  }\n  token(str, maybeNewline = false, occurrenceCount = 0) {\n    this.tokenContext &= _index.TokenContext.forInOrInitHeadAccumulatePassThroughMask;\n    this._maybePrintInnerComments(str, occurrenceCount);\n    this._maybeAddAuxComment();\n    if (this.tokenMap) this._catchUpToCurrentToken(str, occurrenceCount);\n    const lastChar = this.getLastChar();\n    const strFirst = str.charCodeAt(0);\n    if (lastChar === 33 && (str === \"--\" || strFirst === 61) || strFirst === 43 && lastChar === 43 || strFirst === 45 && lastChar === 45 || strFirst === 46 && this._endsWithInteger) {\n      this._space();\n    }\n    this._append(str, maybeNewline);\n    this._noLineTerminator = false;\n  }\n  tokenChar(char) {\n    this.tokenContext &= _index.TokenContext.forInOrInitHeadAccumulatePassThroughMask;\n    const str = String.fromCharCode(char);\n    this._maybePrintInnerComments(str);\n    this._maybeAddAuxComment();\n    if (this.tokenMap) this._catchUpToCurrentToken(str);\n    const lastChar = this.getLastChar();\n    if (char === 43 && lastChar === 43 || char === 45 && lastChar === 45 || char === 46 && this._endsWithInteger) {\n      this._space();\n    }\n    this._appendChar(char);\n    this._noLineTerminator = false;\n  }\n  newline(i = 1, force) {\n    if (i <= 0) return;\n    if (!force) {\n      if (this.format.retainLines || this.format.compact) return;\n      if (this.format.concise) {\n        this.space();\n        return;\n      }\n    }\n    if (i > 2) i = 2;\n    i -= this._buf.getNewlineCount();\n    for (let j = 0; j < i; j++) {\n      this._newline();\n    }\n    return;\n  }\n  endsWith(char) {\n    return this.getLastChar() === char;\n  }\n  getLastChar() {\n    return this._buf.getLastChar();\n  }\n  endsWithCharAndNewline() {\n    return this._buf.endsWithCharAndNewline();\n  }\n  removeTrailingNewline() {\n    this._buf.removeTrailingNewline();\n  }\n  exactSource(loc, cb) {\n    if (!loc) {\n      cb();\n      return;\n    }\n    this._catchUp(\"start\", loc);\n    this._buf.exactSource(loc, cb);\n  }\n  source(prop, loc) {\n    if (!loc) return;\n    this._catchUp(prop, loc);\n    this._buf.source(prop, loc);\n  }\n  sourceWithOffset(prop, loc, columnOffset) {\n    if (!loc || this.format.preserveFormat) return;\n    this._catchUp(prop, loc);\n    this._buf.sourceWithOffset(prop, loc, columnOffset);\n  }\n  sourceIdentifierName(identifierName, pos) {\n    if (!this._buf._canMarkIdName) return;\n    const sourcePosition = this._buf._sourcePosition;\n    sourcePosition.identifierNamePos = pos;\n    sourcePosition.identifierName = identifierName;\n  }\n  _space() {\n    this._queue(32);\n  }\n  _newline() {\n    this._queue(10);\n  }\n  _catchUpToCurrentToken(str, occurrenceCount = 0) {\n    const token = this.tokenMap.findMatching(this._currentNode, str, occurrenceCount);\n    if (token) this._catchUpTo(token.loc.start);\n    if (this._printSemicolonBeforeNextToken !== -1 && this._printSemicolonBeforeNextToken === this._buf.getCurrentLine()) {\n      this._buf.appendChar(59);\n      this._endsWithWord = false;\n      this._endsWithInteger = false;\n      this._endsWithDiv = false;\n    }\n    this._printSemicolonBeforeNextToken = -1;\n    this._printSemicolonBeforeNextNode = -1;\n  }\n  _append(str, maybeNewline) {\n    this._maybeIndent(str.charCodeAt(0));\n    this._buf.append(str, maybeNewline);\n    this._endsWithWord = false;\n    this._endsWithInteger = false;\n    this._endsWithDiv = false;\n  }\n  _appendChar(char) {\n    this._maybeIndent(char);\n    this._buf.appendChar(char);\n    this._endsWithWord = false;\n    this._endsWithInteger = false;\n    this._endsWithDiv = false;\n  }\n  _queue(char) {\n    this._maybeIndent(char);\n    this._buf.queue(char);\n    this._endsWithWord = false;\n    this._endsWithInteger = false;\n  }\n  _maybeIndent(firstChar) {\n    if (this._indent && firstChar !== 10 && this.endsWith(10)) {\n      this._buf.queueIndentation(this._getIndent());\n    }\n  }\n  _shouldIndent(firstChar) {\n    if (this._indent && firstChar !== 10 && this.endsWith(10)) {\n      return true;\n    }\n  }\n  catchUp(line) {\n    if (!this.format.retainLines) return;\n    const count = line - this._buf.getCurrentLine();\n    for (let i = 0; i < count; i++) {\n      this._newline();\n    }\n  }\n  _catchUp(prop, loc) {\n    const {\n      format\n    } = this;\n    if (!format.preserveFormat) {\n      if (format.retainLines && loc != null && loc[prop]) {\n        this.catchUp(loc[prop].line);\n      }\n      return;\n    }\n    const pos = loc == null ? void 0 : loc[prop];\n    if (pos != null) this._catchUpTo(pos);\n  }\n  _catchUpTo({\n    line,\n    column,\n    index\n  }) {\n    const count = line - this._buf.getCurrentLine();\n    if (count > 0 && this._noLineTerminator) {\n      return;\n    }\n    for (let i = 0; i < count; i++) {\n      this._newline();\n    }\n    const spacesCount = count > 0 ? column : column - this._buf.getCurrentColumn();\n    if (spacesCount > 0) {\n      const spaces = this._originalCode ? this._originalCode.slice(index - spacesCount, index).replace(/[^\\t\\x0B\\f \\xA0\\u1680\\u2000-\\u200A\\u202F\\u205F\\u3000\\uFEFF]/gu, \" \") : \" \".repeat(spacesCount);\n      this._append(spaces, false);\n    }\n  }\n  _getIndent() {\n    return this._indentRepeat * this._indent;\n  }\n  printTerminatorless(node) {\n    this._noLineTerminator = true;\n    this.print(node);\n  }\n  print(node, noLineTerminatorAfter = false, trailingCommentsLineOffset) {\n    var _node$extra, _node$leadingComments, _node$leadingComments2;\n    if (!node) return;\n    this._endsWithInnerRaw = false;\n    const nodeType = node.type;\n    const format = this.format;\n    const oldConcise = format.concise;\n    if (node._compact) {\n      format.concise = true;\n    }\n    const printMethod = this[nodeType];\n    if (printMethod === undefined) {\n      throw new ReferenceError(`unknown node of type ${JSON.stringify(nodeType)} with constructor ${JSON.stringify(node.constructor.name)}`);\n    }\n    const parent = this._currentNode;\n    this._currentNode = node;\n    if (this.tokenMap) {\n      this._printSemicolonBeforeNextToken = this._printSemicolonBeforeNextNode;\n    }\n    const oldInAux = this._insideAux;\n    this._insideAux = node.loc == null;\n    this._maybeAddAuxComment(this._insideAux && !oldInAux);\n    const parenthesized = (_node$extra = node.extra) == null ? void 0 : _node$extra.parenthesized;\n    let shouldPrintParens = parenthesized && format.preserveFormat || parenthesized && format.retainFunctionParens && nodeType === \"FunctionExpression\" || needsParens(node, parent, this.tokenContext, format.preserveFormat ? this._boundGetRawIdentifier : undefined);\n    if (!shouldPrintParens && parenthesized && (_node$leadingComments = node.leadingComments) != null && _node$leadingComments.length && node.leadingComments[0].type === \"CommentBlock\") {\n      const parentType = parent == null ? void 0 : parent.type;\n      switch (parentType) {\n        case \"ExpressionStatement\":\n        case \"VariableDeclarator\":\n        case \"AssignmentExpression\":\n        case \"ReturnStatement\":\n          break;\n        case \"CallExpression\":\n        case \"OptionalCallExpression\":\n        case \"NewExpression\":\n          if (parent.callee !== node) break;\n        default:\n          shouldPrintParens = true;\n      }\n    }\n    let indentParenthesized = false;\n    if (!shouldPrintParens && this._noLineTerminator && ((_node$leadingComments2 = node.leadingComments) != null && _node$leadingComments2.some(commentIsNewline) || this.format.retainLines && node.loc && node.loc.start.line > this._buf.getCurrentLine())) {\n      shouldPrintParens = true;\n      indentParenthesized = true;\n    }\n    let oldNoLineTerminatorAfterNode;\n    let oldTokenContext;\n    if (!shouldPrintParens) {\n      noLineTerminatorAfter || (noLineTerminatorAfter = !!parent && this._noLineTerminatorAfterNode === parent && n.isLastChild(parent, node));\n      if (noLineTerminatorAfter) {\n        var _node$trailingComment;\n        if ((_node$trailingComment = node.trailingComments) != null && _node$trailingComment.some(commentIsNewline)) {\n          if (isExpression(node)) shouldPrintParens = true;\n        } else {\n          oldNoLineTerminatorAfterNode = this._noLineTerminatorAfterNode;\n          this._noLineTerminatorAfterNode = node;\n        }\n      }\n    }\n    if (shouldPrintParens) {\n      this.tokenChar(40);\n      if (indentParenthesized) this.indent();\n      this._endsWithInnerRaw = false;\n      if (this.tokenContext & _index.TokenContext.forInOrInitHeadAccumulate) {\n        oldTokenContext = this.tokenContext;\n        this.tokenContext = _index.TokenContext.normal;\n      }\n      oldNoLineTerminatorAfterNode = this._noLineTerminatorAfterNode;\n      this._noLineTerminatorAfterNode = null;\n    }\n    this._lastCommentLine = 0;\n    this._printLeadingComments(node, parent);\n    const loc = nodeType === \"Program\" || nodeType === \"File\" ? null : node.loc;\n    this.exactSource(loc, printMethod.bind(this, node, parent));\n    if (shouldPrintParens) {\n      this._printTrailingComments(node, parent);\n      if (indentParenthesized) {\n        this.dedent();\n        this.newline();\n      }\n      this.tokenChar(41);\n      this._noLineTerminator = noLineTerminatorAfter;\n      if (oldTokenContext) this.tokenContext = oldTokenContext;\n    } else if (noLineTerminatorAfter && !this._noLineTerminator) {\n      this._noLineTerminator = true;\n      this._printTrailingComments(node, parent);\n    } else {\n      this._printTrailingComments(node, parent, trailingCommentsLineOffset);\n    }\n    this._currentNode = parent;\n    format.concise = oldConcise;\n    this._insideAux = oldInAux;\n    if (oldNoLineTerminatorAfterNode !== undefined) {\n      this._noLineTerminatorAfterNode = oldNoLineTerminatorAfterNode;\n    }\n    this._endsWithInnerRaw = false;\n  }\n  _maybeAddAuxComment(enteredPositionlessNode) {\n    if (enteredPositionlessNode) this._printAuxBeforeComment();\n    if (!this._insideAux) this._printAuxAfterComment();\n  }\n  _printAuxBeforeComment() {\n    if (this._printAuxAfterOnNextUserNode) return;\n    this._printAuxAfterOnNextUserNode = true;\n    const comment = this.format.auxiliaryCommentBefore;\n    if (comment) {\n      this._printComment({\n        type: \"CommentBlock\",\n        value: comment\n      }, 0);\n    }\n  }\n  _printAuxAfterComment() {\n    if (!this._printAuxAfterOnNextUserNode) return;\n    this._printAuxAfterOnNextUserNode = false;\n    const comment = this.format.auxiliaryCommentAfter;\n    if (comment) {\n      this._printComment({\n        type: \"CommentBlock\",\n        value: comment\n      }, 0);\n    }\n  }\n  getPossibleRaw(node) {\n    const extra = node.extra;\n    if ((extra == null ? void 0 : extra.raw) != null && extra.rawValue != null && node.value === extra.rawValue) {\n      return extra.raw;\n    }\n  }\n  printJoin(nodes, statement, indent, separator, printTrailingSeparator, iterator, trailingCommentsLineOffset) {\n    if (!(nodes != null && nodes.length)) return;\n    if (indent == null && this.format.retainLines) {\n      var _nodes$0$loc;\n      const startLine = (_nodes$0$loc = nodes[0].loc) == null ? void 0 : _nodes$0$loc.start.line;\n      if (startLine != null && startLine !== this._buf.getCurrentLine()) {\n        indent = true;\n      }\n    }\n    if (indent) this.indent();\n    const newlineOpts = {\n      nextNodeStartLine: 0\n    };\n    const boundSeparator = separator == null ? void 0 : separator.bind(this);\n    const len = nodes.length;\n    for (let i = 0; i < len; i++) {\n      const node = nodes[i];\n      if (!node) continue;\n      if (statement) this._printNewline(i === 0, newlineOpts);\n      this.print(node, undefined, trailingCommentsLineOffset || 0);\n      iterator == null || iterator(node, i);\n      if (boundSeparator != null) {\n        if (i < len - 1) boundSeparator(i, false);else if (printTrailingSeparator) boundSeparator(i, true);\n      }\n      if (statement) {\n        var _node$trailingComment2;\n        if (!((_node$trailingComment2 = node.trailingComments) != null && _node$trailingComment2.length)) {\n          this._lastCommentLine = 0;\n        }\n        if (i + 1 === len) {\n          this.newline(1);\n        } else {\n          var _nextNode$loc;\n          const nextNode = nodes[i + 1];\n          newlineOpts.nextNodeStartLine = ((_nextNode$loc = nextNode.loc) == null ? void 0 : _nextNode$loc.start.line) || 0;\n          this._printNewline(true, newlineOpts);\n        }\n      }\n    }\n    if (indent) this.dedent();\n  }\n  printAndIndentOnComments(node) {\n    const indent = node.leadingComments && node.leadingComments.length > 0;\n    if (indent) this.indent();\n    this.print(node);\n    if (indent) this.dedent();\n  }\n  printBlock(parent) {\n    const node = parent.body;\n    if (node.type !== \"EmptyStatement\") {\n      this.space();\n    }\n    this.print(node);\n  }\n  _printTrailingComments(node, parent, lineOffset) {\n    const {\n      innerComments,\n      trailingComments\n    } = node;\n    if (innerComments != null && innerComments.length) {\n      this._printComments(2, innerComments, node, parent, lineOffset);\n    }\n    if (trailingComments != null && trailingComments.length) {\n      this._printComments(2, trailingComments, node, parent, lineOffset);\n    }\n  }\n  _printLeadingComments(node, parent) {\n    const comments = node.leadingComments;\n    if (!(comments != null && comments.length)) return;\n    this._printComments(0, comments, node, parent);\n  }\n  _maybePrintInnerComments(nextTokenStr, nextTokenOccurrenceCount) {\n    if (this._endsWithInnerRaw) {\n      var _this$tokenMap;\n      this.printInnerComments((_this$tokenMap = this.tokenMap) == null ? void 0 : _this$tokenMap.findMatching(this._currentNode, nextTokenStr, nextTokenOccurrenceCount));\n    }\n    this._endsWithInnerRaw = true;\n    this._indentInnerComments = true;\n  }\n  printInnerComments(nextToken) {\n    const node = this._currentNode;\n    const comments = node.innerComments;\n    if (!(comments != null && comments.length)) return;\n    const hasSpace = this.endsWith(32);\n    const indent = this._indentInnerComments;\n    const printedCommentsCount = this._printedComments.size;\n    if (indent) this.indent();\n    this._printComments(1, comments, node, undefined, undefined, nextToken);\n    if (hasSpace && printedCommentsCount !== this._printedComments.size) {\n      this.space();\n    }\n    if (indent) this.dedent();\n  }\n  noIndentInnerCommentsHere() {\n    this._indentInnerComments = false;\n  }\n  printSequence(nodes, indent, trailingCommentsLineOffset) {\n    this.printJoin(nodes, true, indent != null ? indent : false, undefined, undefined, undefined, trailingCommentsLineOffset);\n  }\n  printList(items, printTrailingSeparator, statement, indent, separator, iterator) {\n    this.printJoin(items, statement, indent, separator != null ? separator : commaSeparator, printTrailingSeparator, iterator);\n  }\n  shouldPrintTrailingComma(listEnd) {\n    if (!this.tokenMap) return null;\n    const listEndIndex = this.tokenMap.findLastIndex(this._currentNode, token => this.tokenMap.matchesOriginal(token, listEnd));\n    if (listEndIndex <= 0) return null;\n    return this.tokenMap.matchesOriginal(this._tokens[listEndIndex - 1], \",\");\n  }\n  _printNewline(newLine, opts) {\n    const format = this.format;\n    if (format.retainLines || format.compact) return;\n    if (format.concise) {\n      this.space();\n      return;\n    }\n    if (!newLine) {\n      return;\n    }\n    const startLine = opts.nextNodeStartLine;\n    const lastCommentLine = this._lastCommentLine;\n    if (startLine > 0 && lastCommentLine > 0) {\n      const offset = startLine - lastCommentLine;\n      if (offset >= 0) {\n        this.newline(offset || 1);\n        return;\n      }\n    }\n    if (this._buf.hasContent()) {\n      this.newline(1);\n    }\n  }\n  _shouldPrintComment(comment, nextToken) {\n    if (comment.ignore) return 0;\n    if (this._printedComments.has(comment)) return 0;\n    if (this._noLineTerminator && HAS_NEWLINE_OR_BlOCK_COMMENT_END.test(comment.value)) {\n      return 2;\n    }\n    if (nextToken && this.tokenMap) {\n      const commentTok = this.tokenMap.find(this._currentNode, token => token.value === comment.value);\n      if (commentTok && commentTok.start > nextToken.start) {\n        return 2;\n      }\n    }\n    this._printedComments.add(comment);\n    if (!this.format.shouldPrintComment(comment.value)) {\n      return 0;\n    }\n    return 1;\n  }\n  _printComment(comment, skipNewLines) {\n    const noLineTerminator = this._noLineTerminator;\n    const isBlockComment = comment.type === \"CommentBlock\";\n    const printNewLines = isBlockComment && skipNewLines !== 1 && !this._noLineTerminator;\n    if (printNewLines && this._buf.hasContent() && skipNewLines !== 2) {\n      this.newline(1);\n    }\n    const lastCharCode = this.getLastChar();\n    if (lastCharCode !== 91 && lastCharCode !== 123 && lastCharCode !== 40) {\n      this.space();\n    }\n    let val;\n    if (isBlockComment) {\n      val = `/*${comment.value}*/`;\n      if (this.format.indent.adjustMultilineComment) {\n        var _comment$loc;\n        const offset = (_comment$loc = comment.loc) == null ? void 0 : _comment$loc.start.column;\n        if (offset) {\n          const newlineRegex = new RegExp(\"\\\\n\\\\s{1,\" + offset + \"}\", \"g\");\n          val = val.replace(newlineRegex, \"\\n\");\n        }\n        if (this.format.concise) {\n          val = val.replace(/\\n(?!$)/g, `\\n`);\n        } else {\n          let indentSize = this.format.retainLines ? 0 : this._buf.getCurrentColumn();\n          if (this._shouldIndent(47) || this.format.retainLines) {\n            indentSize += this._getIndent();\n          }\n          val = val.replace(/\\n(?!$)/g, `\\n${\" \".repeat(indentSize)}`);\n        }\n      }\n    } else if (!noLineTerminator) {\n      val = `//${comment.value}`;\n    } else {\n      val = `/*${comment.value}*/`;\n    }\n    if (this._endsWithDiv) this._space();\n    if (this.tokenMap) {\n      const {\n        _printSemicolonBeforeNextToken,\n        _printSemicolonBeforeNextNode\n      } = this;\n      this._printSemicolonBeforeNextToken = -1;\n      this._printSemicolonBeforeNextNode = -1;\n      this.source(\"start\", comment.loc);\n      this._append(val, isBlockComment);\n      this._printSemicolonBeforeNextNode = _printSemicolonBeforeNextNode;\n      this._printSemicolonBeforeNextToken = _printSemicolonBeforeNextToken;\n    } else {\n      this.source(\"start\", comment.loc);\n      this._append(val, isBlockComment);\n    }\n    if (!isBlockComment && !noLineTerminator) {\n      this.newline(1, true);\n    }\n    if (printNewLines && skipNewLines !== 3) {\n      this.newline(1);\n    }\n  }\n  _printComments(type, comments, node, parent, lineOffset = 0, nextToken) {\n    const nodeLoc = node.loc;\n    const len = comments.length;\n    let hasLoc = !!nodeLoc;\n    const nodeStartLine = hasLoc ? nodeLoc.start.line : 0;\n    const nodeEndLine = hasLoc ? nodeLoc.end.line : 0;\n    let lastLine = 0;\n    let leadingCommentNewline = 0;\n    const maybeNewline = this._noLineTerminator ? function () {} : this.newline.bind(this);\n    for (let i = 0; i < len; i++) {\n      const comment = comments[i];\n      const shouldPrint = this._shouldPrintComment(comment, nextToken);\n      if (shouldPrint === 2) {\n        hasLoc = false;\n        break;\n      }\n      if (hasLoc && comment.loc && shouldPrint === 1) {\n        const commentStartLine = comment.loc.start.line;\n        const commentEndLine = comment.loc.end.line;\n        if (type === 0) {\n          let offset = 0;\n          if (i === 0) {\n            if (this._buf.hasContent() && (comment.type === \"CommentLine\" || commentStartLine !== commentEndLine)) {\n              offset = leadingCommentNewline = 1;\n            }\n          } else {\n            offset = commentStartLine - lastLine;\n          }\n          lastLine = commentEndLine;\n          maybeNewline(offset);\n          this._printComment(comment, 1);\n          if (i + 1 === len) {\n            maybeNewline(Math.max(nodeStartLine - lastLine, leadingCommentNewline));\n            lastLine = nodeStartLine;\n          }\n        } else if (type === 1) {\n          const offset = commentStartLine - (i === 0 ? nodeStartLine : lastLine);\n          lastLine = commentEndLine;\n          maybeNewline(offset);\n          this._printComment(comment, 1);\n          if (i + 1 === len) {\n            maybeNewline(Math.min(1, nodeEndLine - lastLine));\n            lastLine = nodeEndLine;\n          }\n        } else {\n          const offset = commentStartLine - (i === 0 ? nodeEndLine - lineOffset : lastLine);\n          lastLine = commentEndLine;\n          maybeNewline(offset);\n          this._printComment(comment, 1);\n        }\n      } else {\n        hasLoc = false;\n        if (shouldPrint !== 1) {\n          continue;\n        }\n        if (len === 1) {\n          const singleLine = comment.loc ? comment.loc.start.line === comment.loc.end.line : !HAS_NEWLINE.test(comment.value);\n          const shouldSkipNewline = singleLine && !isStatement(node) && !isClassBody(parent) && !isTSInterfaceBody(parent) && !isTSEnumMember(node);\n          if (type === 0) {\n            this._printComment(comment, shouldSkipNewline && node.type !== \"ObjectExpression\" || singleLine && isFunction(parent, {\n              body: node\n            }) ? 1 : 0);\n          } else if (shouldSkipNewline && type === 2) {\n            this._printComment(comment, 1);\n          } else {\n            this._printComment(comment, 0);\n          }\n        } else if (type === 1 && !(node.type === \"ObjectExpression\" && node.properties.length > 1) && node.type !== \"ClassBody\" && node.type !== \"TSInterfaceBody\") {\n          this._printComment(comment, i === 0 ? 2 : i === len - 1 ? 3 : 0);\n        } else {\n          this._printComment(comment, 0);\n        }\n      }\n    }\n    if (type === 2 && hasLoc && lastLine) {\n      this._lastCommentLine = lastLine;\n    }\n  }\n}\nObject.assign(Printer.prototype, generatorFunctions);\n(0, _deprecated.addDeprecatedGenerators)(Printer);\nvar _default = exports[\"default\"] = Printer;\nfunction commaSeparator(occurrenceCount, last) {\n  this.token(\",\", false, occurrenceCount);\n  if (!last) this.space();\n}\n\n//# sourceMappingURL=printer.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGJhYmVsL2dlbmVyYXRvci9saWIvcHJpbnRlci5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYiw4Q0FBNkM7QUFDN0M7QUFDQSxDQUFDLEVBQUM7QUFDRixrQkFBZTtBQUNmLGNBQWMsbUJBQU8sQ0FBQyx3RUFBYTtBQUNuQyxhQUFhLG1CQUFPLENBQUMsZ0ZBQWlCO0FBQ3RDO0FBQ0EsU0FBUyxtQkFBTyxDQUFDLG9FQUFjO0FBQy9CLGdCQUFnQixtQkFBTyxDQUFDLDhFQUFnQjtBQUN4Qyx5QkFBeUIsbUJBQU8sQ0FBQyw0RkFBdUI7QUFDeEQsa0JBQWtCLG1CQUFPLENBQUMsc0dBQTRCO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLE9BQU87QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsV0FBVztBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsV0FBVztBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1REFBdUQsMEJBQTBCLG1CQUFtQixzQ0FBc0M7QUFDMUk7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsU0FBUztBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrREFBa0Q7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLGNBQWM7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrREFBa0QsaUJBQWlCO0FBQ25FO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDLHVCQUF1QjtBQUNwRTtBQUNBO0FBQ0EsTUFBTTtBQUNOLGlCQUFpQixjQUFjO0FBQy9CLE1BQU07QUFDTixpQkFBaUIsY0FBYztBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlFQUFpRTtBQUNqRSxvQkFBb0IsU0FBUztBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixZQUFZO0FBQ1o7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxrQkFBZTtBQUM5QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQSIsInNvdXJjZXMiOlsid2VicGFjazovL3JlcG8tdmlzdWFsaXplci8uL25vZGVfbW9kdWxlcy9AYmFiZWwvZ2VuZXJhdG9yL2xpYi9wcmludGVyLmpzP2EyZmYiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLmRlZmF1bHQgPSB2b2lkIDA7XG52YXIgX2J1ZmZlciA9IHJlcXVpcmUoXCIuL2J1ZmZlci5qc1wiKTtcbnZhciBfaW5kZXggPSByZXF1aXJlKFwiLi9ub2RlL2luZGV4LmpzXCIpO1xudmFyIG4gPSBfaW5kZXg7XG52YXIgX3QgPSByZXF1aXJlKFwiQGJhYmVsL3R5cGVzXCIpO1xudmFyIF90b2tlbk1hcCA9IHJlcXVpcmUoXCIuL3Rva2VuLW1hcC5qc1wiKTtcbnZhciBnZW5lcmF0b3JGdW5jdGlvbnMgPSByZXF1aXJlKFwiLi9nZW5lcmF0b3JzL2luZGV4LmpzXCIpO1xudmFyIF9kZXByZWNhdGVkID0gcmVxdWlyZShcIi4vZ2VuZXJhdG9ycy9kZXByZWNhdGVkLmpzXCIpO1xuY29uc3Qge1xuICBpc0V4cHJlc3Npb24sXG4gIGlzRnVuY3Rpb24sXG4gIGlzU3RhdGVtZW50LFxuICBpc0NsYXNzQm9keSxcbiAgaXNUU0ludGVyZmFjZUJvZHksXG4gIGlzVFNFbnVtTWVtYmVyXG59ID0gX3Q7XG5jb25zdCBTQ0lFTlRJRklDX05PVEFUSU9OID0gL2UvaTtcbmNvbnN0IFpFUk9fREVDSU1BTF9JTlRFR0VSID0gL1xcLjArJC87XG5jb25zdCBIQVNfTkVXTElORSA9IC9bXFxuXFxyXFx1MjAyOFxcdTIwMjldLztcbmNvbnN0IEhBU19ORVdMSU5FX09SX0JsT0NLX0NPTU1FTlRfRU5EID0gL1tcXG5cXHJcXHUyMDI4XFx1MjAyOV18XFwqXFwvLztcbmZ1bmN0aW9uIGNvbW1lbnRJc05ld2xpbmUoYykge1xuICByZXR1cm4gYy50eXBlID09PSBcIkNvbW1lbnRMaW5lXCIgfHwgSEFTX05FV0xJTkUudGVzdChjLnZhbHVlKTtcbn1cbmNvbnN0IHtcbiAgbmVlZHNQYXJlbnNcbn0gPSBuO1xuY2xhc3MgUHJpbnRlciB7XG4gIGNvbnN0cnVjdG9yKGZvcm1hdCwgbWFwLCB0b2tlbnMgPSBudWxsLCBvcmlnaW5hbENvZGUgPSBudWxsKSB7XG4gICAgdGhpcy50b2tlbkNvbnRleHQgPSBfaW5kZXguVG9rZW5Db250ZXh0Lm5vcm1hbDtcbiAgICB0aGlzLl90b2tlbnMgPSBudWxsO1xuICAgIHRoaXMuX29yaWdpbmFsQ29kZSA9IG51bGw7XG4gICAgdGhpcy5fY3VycmVudE5vZGUgPSBudWxsO1xuICAgIHRoaXMuX2luZGVudCA9IDA7XG4gICAgdGhpcy5faW5kZW50UmVwZWF0ID0gMDtcbiAgICB0aGlzLl9pbnNpZGVBdXggPSBmYWxzZTtcbiAgICB0aGlzLl9ub0xpbmVUZXJtaW5hdG9yID0gZmFsc2U7XG4gICAgdGhpcy5fbm9MaW5lVGVybWluYXRvckFmdGVyTm9kZSA9IG51bGw7XG4gICAgdGhpcy5fcHJpbnRBdXhBZnRlck9uTmV4dFVzZXJOb2RlID0gZmFsc2U7XG4gICAgdGhpcy5fcHJpbnRlZENvbW1lbnRzID0gbmV3IFNldCgpO1xuICAgIHRoaXMuX2VuZHNXaXRoSW50ZWdlciA9IGZhbHNlO1xuICAgIHRoaXMuX2VuZHNXaXRoV29yZCA9IGZhbHNlO1xuICAgIHRoaXMuX2VuZHNXaXRoRGl2ID0gZmFsc2U7XG4gICAgdGhpcy5fbGFzdENvbW1lbnRMaW5lID0gMDtcbiAgICB0aGlzLl9lbmRzV2l0aElubmVyUmF3ID0gZmFsc2U7XG4gICAgdGhpcy5faW5kZW50SW5uZXJDb21tZW50cyA9IHRydWU7XG4gICAgdGhpcy50b2tlbk1hcCA9IG51bGw7XG4gICAgdGhpcy5fYm91bmRHZXRSYXdJZGVudGlmaWVyID0gdGhpcy5fZ2V0UmF3SWRlbnRpZmllci5iaW5kKHRoaXMpO1xuICAgIHRoaXMuX3ByaW50U2VtaWNvbG9uQmVmb3JlTmV4dE5vZGUgPSAtMTtcbiAgICB0aGlzLl9wcmludFNlbWljb2xvbkJlZm9yZU5leHRUb2tlbiA9IC0xO1xuICAgIHRoaXMuZm9ybWF0ID0gZm9ybWF0O1xuICAgIHRoaXMuX3Rva2VucyA9IHRva2VucztcbiAgICB0aGlzLl9vcmlnaW5hbENvZGUgPSBvcmlnaW5hbENvZGU7XG4gICAgdGhpcy5faW5kZW50UmVwZWF0ID0gZm9ybWF0LmluZGVudC5zdHlsZS5sZW5ndGg7XG4gICAgdGhpcy5faW5wdXRNYXAgPSAobWFwID09IG51bGwgPyB2b2lkIDAgOiBtYXAuX2lucHV0TWFwKSB8fCBudWxsO1xuICAgIHRoaXMuX2J1ZiA9IG5ldyBfYnVmZmVyLmRlZmF1bHQobWFwLCBmb3JtYXQuaW5kZW50LnN0eWxlWzBdKTtcbiAgfVxuICBlbnRlckZvclN0YXRlbWVudEluaXQoKSB7XG4gICAgdGhpcy50b2tlbkNvbnRleHQgfD0gX2luZGV4LlRva2VuQ29udGV4dC5mb3JJbml0SGVhZCB8IF9pbmRleC5Ub2tlbkNvbnRleHQuZm9ySW5PckluaXRIZWFkQWNjdW11bGF0ZTtcbiAgICByZXR1cm4gKCkgPT4gdGhpcy50b2tlbkNvbnRleHQgPSBfaW5kZXguVG9rZW5Db250ZXh0Lm5vcm1hbDtcbiAgfVxuICBlbnRlckZvclhTdGF0ZW1lbnRJbml0KGlzRm9yT2YpIHtcbiAgICBpZiAoaXNGb3JPZikge1xuICAgICAgdGhpcy50b2tlbkNvbnRleHQgfD0gX2luZGV4LlRva2VuQ29udGV4dC5mb3JPZkhlYWQ7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy50b2tlbkNvbnRleHQgfD0gX2luZGV4LlRva2VuQ29udGV4dC5mb3JJbkhlYWQgfCBfaW5kZXguVG9rZW5Db250ZXh0LmZvckluT3JJbml0SGVhZEFjY3VtdWxhdGU7XG4gICAgICByZXR1cm4gKCkgPT4gdGhpcy50b2tlbkNvbnRleHQgPSBfaW5kZXguVG9rZW5Db250ZXh0Lm5vcm1hbDtcbiAgICB9XG4gIH1cbiAgZW50ZXJEZWxpbWl0ZWQoKSB7XG4gICAgY29uc3Qgb2xkVG9rZW5Db250ZXh0ID0gdGhpcy50b2tlbkNvbnRleHQ7XG4gICAgY29uc3Qgb2xkTm9MaW5lVGVybWluYXRvckFmdGVyTm9kZSA9IHRoaXMuX25vTGluZVRlcm1pbmF0b3JBZnRlck5vZGU7XG4gICAgaWYgKCEob2xkVG9rZW5Db250ZXh0ICYgX2luZGV4LlRva2VuQ29udGV4dC5mb3JJbk9ySW5pdEhlYWRBY2N1bXVsYXRlKSAmJiBvbGROb0xpbmVUZXJtaW5hdG9yQWZ0ZXJOb2RlID09PSBudWxsKSB7XG4gICAgICByZXR1cm4gKCkgPT4ge307XG4gICAgfVxuICAgIHRoaXMuX25vTGluZVRlcm1pbmF0b3JBZnRlck5vZGUgPSBudWxsO1xuICAgIHRoaXMudG9rZW5Db250ZXh0ID0gX2luZGV4LlRva2VuQ29udGV4dC5ub3JtYWw7XG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgIHRoaXMuX25vTGluZVRlcm1pbmF0b3JBZnRlck5vZGUgPSBvbGROb0xpbmVUZXJtaW5hdG9yQWZ0ZXJOb2RlO1xuICAgICAgdGhpcy50b2tlbkNvbnRleHQgPSBvbGRUb2tlbkNvbnRleHQ7XG4gICAgfTtcbiAgfVxuICBnZW5lcmF0ZShhc3QpIHtcbiAgICBpZiAodGhpcy5mb3JtYXQucHJlc2VydmVGb3JtYXQpIHtcbiAgICAgIHRoaXMudG9rZW5NYXAgPSBuZXcgX3Rva2VuTWFwLlRva2VuTWFwKGFzdCwgdGhpcy5fdG9rZW5zLCB0aGlzLl9vcmlnaW5hbENvZGUpO1xuICAgIH1cbiAgICB0aGlzLnByaW50KGFzdCk7XG4gICAgdGhpcy5fbWF5YmVBZGRBdXhDb21tZW50KCk7XG4gICAgcmV0dXJuIHRoaXMuX2J1Zi5nZXQoKTtcbiAgfVxuICBpbmRlbnQoKSB7XG4gICAgY29uc3Qge1xuICAgICAgZm9ybWF0XG4gICAgfSA9IHRoaXM7XG4gICAgaWYgKGZvcm1hdC5wcmVzZXJ2ZUZvcm1hdCB8fCBmb3JtYXQuY29tcGFjdCB8fCBmb3JtYXQuY29uY2lzZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLl9pbmRlbnQrKztcbiAgfVxuICBkZWRlbnQoKSB7XG4gICAgY29uc3Qge1xuICAgICAgZm9ybWF0XG4gICAgfSA9IHRoaXM7XG4gICAgaWYgKGZvcm1hdC5wcmVzZXJ2ZUZvcm1hdCB8fCBmb3JtYXQuY29tcGFjdCB8fCBmb3JtYXQuY29uY2lzZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLl9pbmRlbnQtLTtcbiAgfVxuICBzZW1pY29sb24oZm9yY2UgPSBmYWxzZSkge1xuICAgIHRoaXMuX21heWJlQWRkQXV4Q29tbWVudCgpO1xuICAgIGlmIChmb3JjZSkge1xuICAgICAgdGhpcy5fYXBwZW5kQ2hhcig1OSk7XG4gICAgICB0aGlzLl9ub0xpbmVUZXJtaW5hdG9yID0gZmFsc2U7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICh0aGlzLnRva2VuTWFwKSB7XG4gICAgICBjb25zdCBub2RlID0gdGhpcy5fY3VycmVudE5vZGU7XG4gICAgICBpZiAobm9kZS5zdGFydCAhPSBudWxsICYmIG5vZGUuZW5kICE9IG51bGwpIHtcbiAgICAgICAgaWYgKCF0aGlzLnRva2VuTWFwLmVuZE1hdGNoZXMobm9kZSwgXCI7XCIpKSB7XG4gICAgICAgICAgdGhpcy5fcHJpbnRTZW1pY29sb25CZWZvcmVOZXh0Tm9kZSA9IHRoaXMuX2J1Zi5nZXRDdXJyZW50TGluZSgpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBpbmRleGVzID0gdGhpcy50b2tlbk1hcC5nZXRJbmRleGVzKHRoaXMuX2N1cnJlbnROb2RlKTtcbiAgICAgICAgdGhpcy5fY2F0Y2hVcFRvKHRoaXMuX3Rva2Vuc1tpbmRleGVzW2luZGV4ZXMubGVuZ3RoIC0gMV1dLmxvYy5zdGFydCk7XG4gICAgICB9XG4gICAgfVxuICAgIHRoaXMuX3F1ZXVlKDU5KTtcbiAgICB0aGlzLl9ub0xpbmVUZXJtaW5hdG9yID0gZmFsc2U7XG4gIH1cbiAgcmlnaHRCcmFjZShub2RlKSB7XG4gICAgaWYgKHRoaXMuZm9ybWF0Lm1pbmlmaWVkKSB7XG4gICAgICB0aGlzLl9idWYucmVtb3ZlTGFzdFNlbWljb2xvbigpO1xuICAgIH1cbiAgICB0aGlzLnNvdXJjZVdpdGhPZmZzZXQoXCJlbmRcIiwgbm9kZS5sb2MsIC0xKTtcbiAgICB0aGlzLnRva2VuQ2hhcigxMjUpO1xuICB9XG4gIHJpZ2h0UGFyZW5zKG5vZGUpIHtcbiAgICB0aGlzLnNvdXJjZVdpdGhPZmZzZXQoXCJlbmRcIiwgbm9kZS5sb2MsIC0xKTtcbiAgICB0aGlzLnRva2VuQ2hhcig0MSk7XG4gIH1cbiAgc3BhY2UoZm9yY2UgPSBmYWxzZSkge1xuICAgIGNvbnN0IHtcbiAgICAgIGZvcm1hdFxuICAgIH0gPSB0aGlzO1xuICAgIGlmIChmb3JtYXQuY29tcGFjdCB8fCBmb3JtYXQucHJlc2VydmVGb3JtYXQpIHJldHVybjtcbiAgICBpZiAoZm9yY2UpIHtcbiAgICAgIHRoaXMuX3NwYWNlKCk7XG4gICAgfSBlbHNlIGlmICh0aGlzLl9idWYuaGFzQ29udGVudCgpKSB7XG4gICAgICBjb25zdCBsYXN0Q3AgPSB0aGlzLmdldExhc3RDaGFyKCk7XG4gICAgICBpZiAobGFzdENwICE9PSAzMiAmJiBsYXN0Q3AgIT09IDEwKSB7XG4gICAgICAgIHRoaXMuX3NwYWNlKCk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHdvcmQoc3RyLCBub0xpbmVUZXJtaW5hdG9yQWZ0ZXIgPSBmYWxzZSkge1xuICAgIHRoaXMudG9rZW5Db250ZXh0ICY9IF9pbmRleC5Ub2tlbkNvbnRleHQuZm9ySW5PckluaXRIZWFkQWNjdW11bGF0ZVBhc3NUaHJvdWdoTWFzaztcbiAgICB0aGlzLl9tYXliZVByaW50SW5uZXJDb21tZW50cyhzdHIpO1xuICAgIHRoaXMuX21heWJlQWRkQXV4Q29tbWVudCgpO1xuICAgIGlmICh0aGlzLnRva2VuTWFwKSB0aGlzLl9jYXRjaFVwVG9DdXJyZW50VG9rZW4oc3RyKTtcbiAgICBpZiAodGhpcy5fZW5kc1dpdGhXb3JkIHx8IHRoaXMuX2VuZHNXaXRoRGl2ICYmIHN0ci5jaGFyQ29kZUF0KDApID09PSA0Nykge1xuICAgICAgdGhpcy5fc3BhY2UoKTtcbiAgICB9XG4gICAgdGhpcy5fYXBwZW5kKHN0ciwgZmFsc2UpO1xuICAgIHRoaXMuX2VuZHNXaXRoV29yZCA9IHRydWU7XG4gICAgdGhpcy5fbm9MaW5lVGVybWluYXRvciA9IG5vTGluZVRlcm1pbmF0b3JBZnRlcjtcbiAgfVxuICBudW1iZXIoc3RyLCBudW1iZXIpIHtcbiAgICBmdW5jdGlvbiBpc05vbkRlY2ltYWxMaXRlcmFsKHN0cikge1xuICAgICAgaWYgKHN0ci5sZW5ndGggPiAyICYmIHN0ci5jaGFyQ29kZUF0KDApID09PSA0OCkge1xuICAgICAgICBjb25zdCBzZWNvbmRDaGFyID0gc3RyLmNoYXJDb2RlQXQoMSk7XG4gICAgICAgIHJldHVybiBzZWNvbmRDaGFyID09PSA5OCB8fCBzZWNvbmRDaGFyID09PSAxMTEgfHwgc2Vjb25kQ2hhciA9PT0gMTIwO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICB0aGlzLndvcmQoc3RyKTtcbiAgICB0aGlzLl9lbmRzV2l0aEludGVnZXIgPSBOdW1iZXIuaXNJbnRlZ2VyKG51bWJlcikgJiYgIWlzTm9uRGVjaW1hbExpdGVyYWwoc3RyKSAmJiAhU0NJRU5USUZJQ19OT1RBVElPTi50ZXN0KHN0cikgJiYgIVpFUk9fREVDSU1BTF9JTlRFR0VSLnRlc3Qoc3RyKSAmJiBzdHIuY2hhckNvZGVBdChzdHIubGVuZ3RoIC0gMSkgIT09IDQ2O1xuICB9XG4gIHRva2VuKHN0ciwgbWF5YmVOZXdsaW5lID0gZmFsc2UsIG9jY3VycmVuY2VDb3VudCA9IDApIHtcbiAgICB0aGlzLnRva2VuQ29udGV4dCAmPSBfaW5kZXguVG9rZW5Db250ZXh0LmZvckluT3JJbml0SGVhZEFjY3VtdWxhdGVQYXNzVGhyb3VnaE1hc2s7XG4gICAgdGhpcy5fbWF5YmVQcmludElubmVyQ29tbWVudHMoc3RyLCBvY2N1cnJlbmNlQ291bnQpO1xuICAgIHRoaXMuX21heWJlQWRkQXV4Q29tbWVudCgpO1xuICAgIGlmICh0aGlzLnRva2VuTWFwKSB0aGlzLl9jYXRjaFVwVG9DdXJyZW50VG9rZW4oc3RyLCBvY2N1cnJlbmNlQ291bnQpO1xuICAgIGNvbnN0IGxhc3RDaGFyID0gdGhpcy5nZXRMYXN0Q2hhcigpO1xuICAgIGNvbnN0IHN0ckZpcnN0ID0gc3RyLmNoYXJDb2RlQXQoMCk7XG4gICAgaWYgKGxhc3RDaGFyID09PSAzMyAmJiAoc3RyID09PSBcIi0tXCIgfHwgc3RyRmlyc3QgPT09IDYxKSB8fCBzdHJGaXJzdCA9PT0gNDMgJiYgbGFzdENoYXIgPT09IDQzIHx8IHN0ckZpcnN0ID09PSA0NSAmJiBsYXN0Q2hhciA9PT0gNDUgfHwgc3RyRmlyc3QgPT09IDQ2ICYmIHRoaXMuX2VuZHNXaXRoSW50ZWdlcikge1xuICAgICAgdGhpcy5fc3BhY2UoKTtcbiAgICB9XG4gICAgdGhpcy5fYXBwZW5kKHN0ciwgbWF5YmVOZXdsaW5lKTtcbiAgICB0aGlzLl9ub0xpbmVUZXJtaW5hdG9yID0gZmFsc2U7XG4gIH1cbiAgdG9rZW5DaGFyKGNoYXIpIHtcbiAgICB0aGlzLnRva2VuQ29udGV4dCAmPSBfaW5kZXguVG9rZW5Db250ZXh0LmZvckluT3JJbml0SGVhZEFjY3VtdWxhdGVQYXNzVGhyb3VnaE1hc2s7XG4gICAgY29uc3Qgc3RyID0gU3RyaW5nLmZyb21DaGFyQ29kZShjaGFyKTtcbiAgICB0aGlzLl9tYXliZVByaW50SW5uZXJDb21tZW50cyhzdHIpO1xuICAgIHRoaXMuX21heWJlQWRkQXV4Q29tbWVudCgpO1xuICAgIGlmICh0aGlzLnRva2VuTWFwKSB0aGlzLl9jYXRjaFVwVG9DdXJyZW50VG9rZW4oc3RyKTtcbiAgICBjb25zdCBsYXN0Q2hhciA9IHRoaXMuZ2V0TGFzdENoYXIoKTtcbiAgICBpZiAoY2hhciA9PT0gNDMgJiYgbGFzdENoYXIgPT09IDQzIHx8IGNoYXIgPT09IDQ1ICYmIGxhc3RDaGFyID09PSA0NSB8fCBjaGFyID09PSA0NiAmJiB0aGlzLl9lbmRzV2l0aEludGVnZXIpIHtcbiAgICAgIHRoaXMuX3NwYWNlKCk7XG4gICAgfVxuICAgIHRoaXMuX2FwcGVuZENoYXIoY2hhcik7XG4gICAgdGhpcy5fbm9MaW5lVGVybWluYXRvciA9IGZhbHNlO1xuICB9XG4gIG5ld2xpbmUoaSA9IDEsIGZvcmNlKSB7XG4gICAgaWYgKGkgPD0gMCkgcmV0dXJuO1xuICAgIGlmICghZm9yY2UpIHtcbiAgICAgIGlmICh0aGlzLmZvcm1hdC5yZXRhaW5MaW5lcyB8fCB0aGlzLmZvcm1hdC5jb21wYWN0KSByZXR1cm47XG4gICAgICBpZiAodGhpcy5mb3JtYXQuY29uY2lzZSkge1xuICAgICAgICB0aGlzLnNwYWNlKCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGkgPiAyKSBpID0gMjtcbiAgICBpIC09IHRoaXMuX2J1Zi5nZXROZXdsaW5lQ291bnQoKTtcbiAgICBmb3IgKGxldCBqID0gMDsgaiA8IGk7IGorKykge1xuICAgICAgdGhpcy5fbmV3bGluZSgpO1xuICAgIH1cbiAgICByZXR1cm47XG4gIH1cbiAgZW5kc1dpdGgoY2hhcikge1xuICAgIHJldHVybiB0aGlzLmdldExhc3RDaGFyKCkgPT09IGNoYXI7XG4gIH1cbiAgZ2V0TGFzdENoYXIoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2J1Zi5nZXRMYXN0Q2hhcigpO1xuICB9XG4gIGVuZHNXaXRoQ2hhckFuZE5ld2xpbmUoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2J1Zi5lbmRzV2l0aENoYXJBbmROZXdsaW5lKCk7XG4gIH1cbiAgcmVtb3ZlVHJhaWxpbmdOZXdsaW5lKCkge1xuICAgIHRoaXMuX2J1Zi5yZW1vdmVUcmFpbGluZ05ld2xpbmUoKTtcbiAgfVxuICBleGFjdFNvdXJjZShsb2MsIGNiKSB7XG4gICAgaWYgKCFsb2MpIHtcbiAgICAgIGNiKCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuX2NhdGNoVXAoXCJzdGFydFwiLCBsb2MpO1xuICAgIHRoaXMuX2J1Zi5leGFjdFNvdXJjZShsb2MsIGNiKTtcbiAgfVxuICBzb3VyY2UocHJvcCwgbG9jKSB7XG4gICAgaWYgKCFsb2MpIHJldHVybjtcbiAgICB0aGlzLl9jYXRjaFVwKHByb3AsIGxvYyk7XG4gICAgdGhpcy5fYnVmLnNvdXJjZShwcm9wLCBsb2MpO1xuICB9XG4gIHNvdXJjZVdpdGhPZmZzZXQocHJvcCwgbG9jLCBjb2x1bW5PZmZzZXQpIHtcbiAgICBpZiAoIWxvYyB8fCB0aGlzLmZvcm1hdC5wcmVzZXJ2ZUZvcm1hdCkgcmV0dXJuO1xuICAgIHRoaXMuX2NhdGNoVXAocHJvcCwgbG9jKTtcbiAgICB0aGlzLl9idWYuc291cmNlV2l0aE9mZnNldChwcm9wLCBsb2MsIGNvbHVtbk9mZnNldCk7XG4gIH1cbiAgc291cmNlSWRlbnRpZmllck5hbWUoaWRlbnRpZmllck5hbWUsIHBvcykge1xuICAgIGlmICghdGhpcy5fYnVmLl9jYW5NYXJrSWROYW1lKSByZXR1cm47XG4gICAgY29uc3Qgc291cmNlUG9zaXRpb24gPSB0aGlzLl9idWYuX3NvdXJjZVBvc2l0aW9uO1xuICAgIHNvdXJjZVBvc2l0aW9uLmlkZW50aWZpZXJOYW1lUG9zID0gcG9zO1xuICAgIHNvdXJjZVBvc2l0aW9uLmlkZW50aWZpZXJOYW1lID0gaWRlbnRpZmllck5hbWU7XG4gIH1cbiAgX3NwYWNlKCkge1xuICAgIHRoaXMuX3F1ZXVlKDMyKTtcbiAgfVxuICBfbmV3bGluZSgpIHtcbiAgICB0aGlzLl9xdWV1ZSgxMCk7XG4gIH1cbiAgX2NhdGNoVXBUb0N1cnJlbnRUb2tlbihzdHIsIG9jY3VycmVuY2VDb3VudCA9IDApIHtcbiAgICBjb25zdCB0b2tlbiA9IHRoaXMudG9rZW5NYXAuZmluZE1hdGNoaW5nKHRoaXMuX2N1cnJlbnROb2RlLCBzdHIsIG9jY3VycmVuY2VDb3VudCk7XG4gICAgaWYgKHRva2VuKSB0aGlzLl9jYXRjaFVwVG8odG9rZW4ubG9jLnN0YXJ0KTtcbiAgICBpZiAodGhpcy5fcHJpbnRTZW1pY29sb25CZWZvcmVOZXh0VG9rZW4gIT09IC0xICYmIHRoaXMuX3ByaW50U2VtaWNvbG9uQmVmb3JlTmV4dFRva2VuID09PSB0aGlzLl9idWYuZ2V0Q3VycmVudExpbmUoKSkge1xuICAgICAgdGhpcy5fYnVmLmFwcGVuZENoYXIoNTkpO1xuICAgICAgdGhpcy5fZW5kc1dpdGhXb3JkID0gZmFsc2U7XG4gICAgICB0aGlzLl9lbmRzV2l0aEludGVnZXIgPSBmYWxzZTtcbiAgICAgIHRoaXMuX2VuZHNXaXRoRGl2ID0gZmFsc2U7XG4gICAgfVxuICAgIHRoaXMuX3ByaW50U2VtaWNvbG9uQmVmb3JlTmV4dFRva2VuID0gLTE7XG4gICAgdGhpcy5fcHJpbnRTZW1pY29sb25CZWZvcmVOZXh0Tm9kZSA9IC0xO1xuICB9XG4gIF9hcHBlbmQoc3RyLCBtYXliZU5ld2xpbmUpIHtcbiAgICB0aGlzLl9tYXliZUluZGVudChzdHIuY2hhckNvZGVBdCgwKSk7XG4gICAgdGhpcy5fYnVmLmFwcGVuZChzdHIsIG1heWJlTmV3bGluZSk7XG4gICAgdGhpcy5fZW5kc1dpdGhXb3JkID0gZmFsc2U7XG4gICAgdGhpcy5fZW5kc1dpdGhJbnRlZ2VyID0gZmFsc2U7XG4gICAgdGhpcy5fZW5kc1dpdGhEaXYgPSBmYWxzZTtcbiAgfVxuICBfYXBwZW5kQ2hhcihjaGFyKSB7XG4gICAgdGhpcy5fbWF5YmVJbmRlbnQoY2hhcik7XG4gICAgdGhpcy5fYnVmLmFwcGVuZENoYXIoY2hhcik7XG4gICAgdGhpcy5fZW5kc1dpdGhXb3JkID0gZmFsc2U7XG4gICAgdGhpcy5fZW5kc1dpdGhJbnRlZ2VyID0gZmFsc2U7XG4gICAgdGhpcy5fZW5kc1dpdGhEaXYgPSBmYWxzZTtcbiAgfVxuICBfcXVldWUoY2hhcikge1xuICAgIHRoaXMuX21heWJlSW5kZW50KGNoYXIpO1xuICAgIHRoaXMuX2J1Zi5xdWV1ZShjaGFyKTtcbiAgICB0aGlzLl9lbmRzV2l0aFdvcmQgPSBmYWxzZTtcbiAgICB0aGlzLl9lbmRzV2l0aEludGVnZXIgPSBmYWxzZTtcbiAgfVxuICBfbWF5YmVJbmRlbnQoZmlyc3RDaGFyKSB7XG4gICAgaWYgKHRoaXMuX2luZGVudCAmJiBmaXJzdENoYXIgIT09IDEwICYmIHRoaXMuZW5kc1dpdGgoMTApKSB7XG4gICAgICB0aGlzLl9idWYucXVldWVJbmRlbnRhdGlvbih0aGlzLl9nZXRJbmRlbnQoKSk7XG4gICAgfVxuICB9XG4gIF9zaG91bGRJbmRlbnQoZmlyc3RDaGFyKSB7XG4gICAgaWYgKHRoaXMuX2luZGVudCAmJiBmaXJzdENoYXIgIT09IDEwICYmIHRoaXMuZW5kc1dpdGgoMTApKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH1cbiAgY2F0Y2hVcChsaW5lKSB7XG4gICAgaWYgKCF0aGlzLmZvcm1hdC5yZXRhaW5MaW5lcykgcmV0dXJuO1xuICAgIGNvbnN0IGNvdW50ID0gbGluZSAtIHRoaXMuX2J1Zi5nZXRDdXJyZW50TGluZSgpO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY291bnQ7IGkrKykge1xuICAgICAgdGhpcy5fbmV3bGluZSgpO1xuICAgIH1cbiAgfVxuICBfY2F0Y2hVcChwcm9wLCBsb2MpIHtcbiAgICBjb25zdCB7XG4gICAgICBmb3JtYXRcbiAgICB9ID0gdGhpcztcbiAgICBpZiAoIWZvcm1hdC5wcmVzZXJ2ZUZvcm1hdCkge1xuICAgICAgaWYgKGZvcm1hdC5yZXRhaW5MaW5lcyAmJiBsb2MgIT0gbnVsbCAmJiBsb2NbcHJvcF0pIHtcbiAgICAgICAgdGhpcy5jYXRjaFVwKGxvY1twcm9wXS5saW5lKTtcbiAgICAgIH1cbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgcG9zID0gbG9jID09IG51bGwgPyB2b2lkIDAgOiBsb2NbcHJvcF07XG4gICAgaWYgKHBvcyAhPSBudWxsKSB0aGlzLl9jYXRjaFVwVG8ocG9zKTtcbiAgfVxuICBfY2F0Y2hVcFRvKHtcbiAgICBsaW5lLFxuICAgIGNvbHVtbixcbiAgICBpbmRleFxuICB9KSB7XG4gICAgY29uc3QgY291bnQgPSBsaW5lIC0gdGhpcy5fYnVmLmdldEN1cnJlbnRMaW5lKCk7XG4gICAgaWYgKGNvdW50ID4gMCAmJiB0aGlzLl9ub0xpbmVUZXJtaW5hdG9yKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY291bnQ7IGkrKykge1xuICAgICAgdGhpcy5fbmV3bGluZSgpO1xuICAgIH1cbiAgICBjb25zdCBzcGFjZXNDb3VudCA9IGNvdW50ID4gMCA/IGNvbHVtbiA6IGNvbHVtbiAtIHRoaXMuX2J1Zi5nZXRDdXJyZW50Q29sdW1uKCk7XG4gICAgaWYgKHNwYWNlc0NvdW50ID4gMCkge1xuICAgICAgY29uc3Qgc3BhY2VzID0gdGhpcy5fb3JpZ2luYWxDb2RlID8gdGhpcy5fb3JpZ2luYWxDb2RlLnNsaWNlKGluZGV4IC0gc3BhY2VzQ291bnQsIGluZGV4KS5yZXBsYWNlKC9bXlxcdFxceDBCXFxmIFxceEEwXFx1MTY4MFxcdTIwMDAtXFx1MjAwQVxcdTIwMkZcXHUyMDVGXFx1MzAwMFxcdUZFRkZdL2d1LCBcIiBcIikgOiBcIiBcIi5yZXBlYXQoc3BhY2VzQ291bnQpO1xuICAgICAgdGhpcy5fYXBwZW5kKHNwYWNlcywgZmFsc2UpO1xuICAgIH1cbiAgfVxuICBfZ2V0SW5kZW50KCkge1xuICAgIHJldHVybiB0aGlzLl9pbmRlbnRSZXBlYXQgKiB0aGlzLl9pbmRlbnQ7XG4gIH1cbiAgcHJpbnRUZXJtaW5hdG9ybGVzcyhub2RlKSB7XG4gICAgdGhpcy5fbm9MaW5lVGVybWluYXRvciA9IHRydWU7XG4gICAgdGhpcy5wcmludChub2RlKTtcbiAgfVxuICBwcmludChub2RlLCBub0xpbmVUZXJtaW5hdG9yQWZ0ZXIgPSBmYWxzZSwgdHJhaWxpbmdDb21tZW50c0xpbmVPZmZzZXQpIHtcbiAgICB2YXIgX25vZGUkZXh0cmEsIF9ub2RlJGxlYWRpbmdDb21tZW50cywgX25vZGUkbGVhZGluZ0NvbW1lbnRzMjtcbiAgICBpZiAoIW5vZGUpIHJldHVybjtcbiAgICB0aGlzLl9lbmRzV2l0aElubmVyUmF3ID0gZmFsc2U7XG4gICAgY29uc3Qgbm9kZVR5cGUgPSBub2RlLnR5cGU7XG4gICAgY29uc3QgZm9ybWF0ID0gdGhpcy5mb3JtYXQ7XG4gICAgY29uc3Qgb2xkQ29uY2lzZSA9IGZvcm1hdC5jb25jaXNlO1xuICAgIGlmIChub2RlLl9jb21wYWN0KSB7XG4gICAgICBmb3JtYXQuY29uY2lzZSA9IHRydWU7XG4gICAgfVxuICAgIGNvbnN0IHByaW50TWV0aG9kID0gdGhpc1tub2RlVHlwZV07XG4gICAgaWYgKHByaW50TWV0aG9kID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihgdW5rbm93biBub2RlIG9mIHR5cGUgJHtKU09OLnN0cmluZ2lmeShub2RlVHlwZSl9IHdpdGggY29uc3RydWN0b3IgJHtKU09OLnN0cmluZ2lmeShub2RlLmNvbnN0cnVjdG9yLm5hbWUpfWApO1xuICAgIH1cbiAgICBjb25zdCBwYXJlbnQgPSB0aGlzLl9jdXJyZW50Tm9kZTtcbiAgICB0aGlzLl9jdXJyZW50Tm9kZSA9IG5vZGU7XG4gICAgaWYgKHRoaXMudG9rZW5NYXApIHtcbiAgICAgIHRoaXMuX3ByaW50U2VtaWNvbG9uQmVmb3JlTmV4dFRva2VuID0gdGhpcy5fcHJpbnRTZW1pY29sb25CZWZvcmVOZXh0Tm9kZTtcbiAgICB9XG4gICAgY29uc3Qgb2xkSW5BdXggPSB0aGlzLl9pbnNpZGVBdXg7XG4gICAgdGhpcy5faW5zaWRlQXV4ID0gbm9kZS5sb2MgPT0gbnVsbDtcbiAgICB0aGlzLl9tYXliZUFkZEF1eENvbW1lbnQodGhpcy5faW5zaWRlQXV4ICYmICFvbGRJbkF1eCk7XG4gICAgY29uc3QgcGFyZW50aGVzaXplZCA9IChfbm9kZSRleHRyYSA9IG5vZGUuZXh0cmEpID09IG51bGwgPyB2b2lkIDAgOiBfbm9kZSRleHRyYS5wYXJlbnRoZXNpemVkO1xuICAgIGxldCBzaG91bGRQcmludFBhcmVucyA9IHBhcmVudGhlc2l6ZWQgJiYgZm9ybWF0LnByZXNlcnZlRm9ybWF0IHx8IHBhcmVudGhlc2l6ZWQgJiYgZm9ybWF0LnJldGFpbkZ1bmN0aW9uUGFyZW5zICYmIG5vZGVUeXBlID09PSBcIkZ1bmN0aW9uRXhwcmVzc2lvblwiIHx8IG5lZWRzUGFyZW5zKG5vZGUsIHBhcmVudCwgdGhpcy50b2tlbkNvbnRleHQsIGZvcm1hdC5wcmVzZXJ2ZUZvcm1hdCA/IHRoaXMuX2JvdW5kR2V0UmF3SWRlbnRpZmllciA6IHVuZGVmaW5lZCk7XG4gICAgaWYgKCFzaG91bGRQcmludFBhcmVucyAmJiBwYXJlbnRoZXNpemVkICYmIChfbm9kZSRsZWFkaW5nQ29tbWVudHMgPSBub2RlLmxlYWRpbmdDb21tZW50cykgIT0gbnVsbCAmJiBfbm9kZSRsZWFkaW5nQ29tbWVudHMubGVuZ3RoICYmIG5vZGUubGVhZGluZ0NvbW1lbnRzWzBdLnR5cGUgPT09IFwiQ29tbWVudEJsb2NrXCIpIHtcbiAgICAgIGNvbnN0IHBhcmVudFR5cGUgPSBwYXJlbnQgPT0gbnVsbCA/IHZvaWQgMCA6IHBhcmVudC50eXBlO1xuICAgICAgc3dpdGNoIChwYXJlbnRUeXBlKSB7XG4gICAgICAgIGNhc2UgXCJFeHByZXNzaW9uU3RhdGVtZW50XCI6XG4gICAgICAgIGNhc2UgXCJWYXJpYWJsZURlY2xhcmF0b3JcIjpcbiAgICAgICAgY2FzZSBcIkFzc2lnbm1lbnRFeHByZXNzaW9uXCI6XG4gICAgICAgIGNhc2UgXCJSZXR1cm5TdGF0ZW1lbnRcIjpcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcIkNhbGxFeHByZXNzaW9uXCI6XG4gICAgICAgIGNhc2UgXCJPcHRpb25hbENhbGxFeHByZXNzaW9uXCI6XG4gICAgICAgIGNhc2UgXCJOZXdFeHByZXNzaW9uXCI6XG4gICAgICAgICAgaWYgKHBhcmVudC5jYWxsZWUgIT09IG5vZGUpIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIHNob3VsZFByaW50UGFyZW5zID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG4gICAgbGV0IGluZGVudFBhcmVudGhlc2l6ZWQgPSBmYWxzZTtcbiAgICBpZiAoIXNob3VsZFByaW50UGFyZW5zICYmIHRoaXMuX25vTGluZVRlcm1pbmF0b3IgJiYgKChfbm9kZSRsZWFkaW5nQ29tbWVudHMyID0gbm9kZS5sZWFkaW5nQ29tbWVudHMpICE9IG51bGwgJiYgX25vZGUkbGVhZGluZ0NvbW1lbnRzMi5zb21lKGNvbW1lbnRJc05ld2xpbmUpIHx8IHRoaXMuZm9ybWF0LnJldGFpbkxpbmVzICYmIG5vZGUubG9jICYmIG5vZGUubG9jLnN0YXJ0LmxpbmUgPiB0aGlzLl9idWYuZ2V0Q3VycmVudExpbmUoKSkpIHtcbiAgICAgIHNob3VsZFByaW50UGFyZW5zID0gdHJ1ZTtcbiAgICAgIGluZGVudFBhcmVudGhlc2l6ZWQgPSB0cnVlO1xuICAgIH1cbiAgICBsZXQgb2xkTm9MaW5lVGVybWluYXRvckFmdGVyTm9kZTtcbiAgICBsZXQgb2xkVG9rZW5Db250ZXh0O1xuICAgIGlmICghc2hvdWxkUHJpbnRQYXJlbnMpIHtcbiAgICAgIG5vTGluZVRlcm1pbmF0b3JBZnRlciB8fCAobm9MaW5lVGVybWluYXRvckFmdGVyID0gISFwYXJlbnQgJiYgdGhpcy5fbm9MaW5lVGVybWluYXRvckFmdGVyTm9kZSA9PT0gcGFyZW50ICYmIG4uaXNMYXN0Q2hpbGQocGFyZW50LCBub2RlKSk7XG4gICAgICBpZiAobm9MaW5lVGVybWluYXRvckFmdGVyKSB7XG4gICAgICAgIHZhciBfbm9kZSR0cmFpbGluZ0NvbW1lbnQ7XG4gICAgICAgIGlmICgoX25vZGUkdHJhaWxpbmdDb21tZW50ID0gbm9kZS50cmFpbGluZ0NvbW1lbnRzKSAhPSBudWxsICYmIF9ub2RlJHRyYWlsaW5nQ29tbWVudC5zb21lKGNvbW1lbnRJc05ld2xpbmUpKSB7XG4gICAgICAgICAgaWYgKGlzRXhwcmVzc2lvbihub2RlKSkgc2hvdWxkUHJpbnRQYXJlbnMgPSB0cnVlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG9sZE5vTGluZVRlcm1pbmF0b3JBZnRlck5vZGUgPSB0aGlzLl9ub0xpbmVUZXJtaW5hdG9yQWZ0ZXJOb2RlO1xuICAgICAgICAgIHRoaXMuX25vTGluZVRlcm1pbmF0b3JBZnRlck5vZGUgPSBub2RlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChzaG91bGRQcmludFBhcmVucykge1xuICAgICAgdGhpcy50b2tlbkNoYXIoNDApO1xuICAgICAgaWYgKGluZGVudFBhcmVudGhlc2l6ZWQpIHRoaXMuaW5kZW50KCk7XG4gICAgICB0aGlzLl9lbmRzV2l0aElubmVyUmF3ID0gZmFsc2U7XG4gICAgICBpZiAodGhpcy50b2tlbkNvbnRleHQgJiBfaW5kZXguVG9rZW5Db250ZXh0LmZvckluT3JJbml0SGVhZEFjY3VtdWxhdGUpIHtcbiAgICAgICAgb2xkVG9rZW5Db250ZXh0ID0gdGhpcy50b2tlbkNvbnRleHQ7XG4gICAgICAgIHRoaXMudG9rZW5Db250ZXh0ID0gX2luZGV4LlRva2VuQ29udGV4dC5ub3JtYWw7XG4gICAgICB9XG4gICAgICBvbGROb0xpbmVUZXJtaW5hdG9yQWZ0ZXJOb2RlID0gdGhpcy5fbm9MaW5lVGVybWluYXRvckFmdGVyTm9kZTtcbiAgICAgIHRoaXMuX25vTGluZVRlcm1pbmF0b3JBZnRlck5vZGUgPSBudWxsO1xuICAgIH1cbiAgICB0aGlzLl9sYXN0Q29tbWVudExpbmUgPSAwO1xuICAgIHRoaXMuX3ByaW50TGVhZGluZ0NvbW1lbnRzKG5vZGUsIHBhcmVudCk7XG4gICAgY29uc3QgbG9jID0gbm9kZVR5cGUgPT09IFwiUHJvZ3JhbVwiIHx8IG5vZGVUeXBlID09PSBcIkZpbGVcIiA/IG51bGwgOiBub2RlLmxvYztcbiAgICB0aGlzLmV4YWN0U291cmNlKGxvYywgcHJpbnRNZXRob2QuYmluZCh0aGlzLCBub2RlLCBwYXJlbnQpKTtcbiAgICBpZiAoc2hvdWxkUHJpbnRQYXJlbnMpIHtcbiAgICAgIHRoaXMuX3ByaW50VHJhaWxpbmdDb21tZW50cyhub2RlLCBwYXJlbnQpO1xuICAgICAgaWYgKGluZGVudFBhcmVudGhlc2l6ZWQpIHtcbiAgICAgICAgdGhpcy5kZWRlbnQoKTtcbiAgICAgICAgdGhpcy5uZXdsaW5lKCk7XG4gICAgICB9XG4gICAgICB0aGlzLnRva2VuQ2hhcig0MSk7XG4gICAgICB0aGlzLl9ub0xpbmVUZXJtaW5hdG9yID0gbm9MaW5lVGVybWluYXRvckFmdGVyO1xuICAgICAgaWYgKG9sZFRva2VuQ29udGV4dCkgdGhpcy50b2tlbkNvbnRleHQgPSBvbGRUb2tlbkNvbnRleHQ7XG4gICAgfSBlbHNlIGlmIChub0xpbmVUZXJtaW5hdG9yQWZ0ZXIgJiYgIXRoaXMuX25vTGluZVRlcm1pbmF0b3IpIHtcbiAgICAgIHRoaXMuX25vTGluZVRlcm1pbmF0b3IgPSB0cnVlO1xuICAgICAgdGhpcy5fcHJpbnRUcmFpbGluZ0NvbW1lbnRzKG5vZGUsIHBhcmVudCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuX3ByaW50VHJhaWxpbmdDb21tZW50cyhub2RlLCBwYXJlbnQsIHRyYWlsaW5nQ29tbWVudHNMaW5lT2Zmc2V0KTtcbiAgICB9XG4gICAgdGhpcy5fY3VycmVudE5vZGUgPSBwYXJlbnQ7XG4gICAgZm9ybWF0LmNvbmNpc2UgPSBvbGRDb25jaXNlO1xuICAgIHRoaXMuX2luc2lkZUF1eCA9IG9sZEluQXV4O1xuICAgIGlmIChvbGROb0xpbmVUZXJtaW5hdG9yQWZ0ZXJOb2RlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHRoaXMuX25vTGluZVRlcm1pbmF0b3JBZnRlck5vZGUgPSBvbGROb0xpbmVUZXJtaW5hdG9yQWZ0ZXJOb2RlO1xuICAgIH1cbiAgICB0aGlzLl9lbmRzV2l0aElubmVyUmF3ID0gZmFsc2U7XG4gIH1cbiAgX21heWJlQWRkQXV4Q29tbWVudChlbnRlcmVkUG9zaXRpb25sZXNzTm9kZSkge1xuICAgIGlmIChlbnRlcmVkUG9zaXRpb25sZXNzTm9kZSkgdGhpcy5fcHJpbnRBdXhCZWZvcmVDb21tZW50KCk7XG4gICAgaWYgKCF0aGlzLl9pbnNpZGVBdXgpIHRoaXMuX3ByaW50QXV4QWZ0ZXJDb21tZW50KCk7XG4gIH1cbiAgX3ByaW50QXV4QmVmb3JlQ29tbWVudCgpIHtcbiAgICBpZiAodGhpcy5fcHJpbnRBdXhBZnRlck9uTmV4dFVzZXJOb2RlKSByZXR1cm47XG4gICAgdGhpcy5fcHJpbnRBdXhBZnRlck9uTmV4dFVzZXJOb2RlID0gdHJ1ZTtcbiAgICBjb25zdCBjb21tZW50ID0gdGhpcy5mb3JtYXQuYXV4aWxpYXJ5Q29tbWVudEJlZm9yZTtcbiAgICBpZiAoY29tbWVudCkge1xuICAgICAgdGhpcy5fcHJpbnRDb21tZW50KHtcbiAgICAgICAgdHlwZTogXCJDb21tZW50QmxvY2tcIixcbiAgICAgICAgdmFsdWU6IGNvbW1lbnRcbiAgICAgIH0sIDApO1xuICAgIH1cbiAgfVxuICBfcHJpbnRBdXhBZnRlckNvbW1lbnQoKSB7XG4gICAgaWYgKCF0aGlzLl9wcmludEF1eEFmdGVyT25OZXh0VXNlck5vZGUpIHJldHVybjtcbiAgICB0aGlzLl9wcmludEF1eEFmdGVyT25OZXh0VXNlck5vZGUgPSBmYWxzZTtcbiAgICBjb25zdCBjb21tZW50ID0gdGhpcy5mb3JtYXQuYXV4aWxpYXJ5Q29tbWVudEFmdGVyO1xuICAgIGlmIChjb21tZW50KSB7XG4gICAgICB0aGlzLl9wcmludENvbW1lbnQoe1xuICAgICAgICB0eXBlOiBcIkNvbW1lbnRCbG9ja1wiLFxuICAgICAgICB2YWx1ZTogY29tbWVudFxuICAgICAgfSwgMCk7XG4gICAgfVxuICB9XG4gIGdldFBvc3NpYmxlUmF3KG5vZGUpIHtcbiAgICBjb25zdCBleHRyYSA9IG5vZGUuZXh0cmE7XG4gICAgaWYgKChleHRyYSA9PSBudWxsID8gdm9pZCAwIDogZXh0cmEucmF3KSAhPSBudWxsICYmIGV4dHJhLnJhd1ZhbHVlICE9IG51bGwgJiYgbm9kZS52YWx1ZSA9PT0gZXh0cmEucmF3VmFsdWUpIHtcbiAgICAgIHJldHVybiBleHRyYS5yYXc7XG4gICAgfVxuICB9XG4gIHByaW50Sm9pbihub2Rlcywgc3RhdGVtZW50LCBpbmRlbnQsIHNlcGFyYXRvciwgcHJpbnRUcmFpbGluZ1NlcGFyYXRvciwgaXRlcmF0b3IsIHRyYWlsaW5nQ29tbWVudHNMaW5lT2Zmc2V0KSB7XG4gICAgaWYgKCEobm9kZXMgIT0gbnVsbCAmJiBub2Rlcy5sZW5ndGgpKSByZXR1cm47XG4gICAgaWYgKGluZGVudCA9PSBudWxsICYmIHRoaXMuZm9ybWF0LnJldGFpbkxpbmVzKSB7XG4gICAgICB2YXIgX25vZGVzJDAkbG9jO1xuICAgICAgY29uc3Qgc3RhcnRMaW5lID0gKF9ub2RlcyQwJGxvYyA9IG5vZGVzWzBdLmxvYykgPT0gbnVsbCA/IHZvaWQgMCA6IF9ub2RlcyQwJGxvYy5zdGFydC5saW5lO1xuICAgICAgaWYgKHN0YXJ0TGluZSAhPSBudWxsICYmIHN0YXJ0TGluZSAhPT0gdGhpcy5fYnVmLmdldEN1cnJlbnRMaW5lKCkpIHtcbiAgICAgICAgaW5kZW50ID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGluZGVudCkgdGhpcy5pbmRlbnQoKTtcbiAgICBjb25zdCBuZXdsaW5lT3B0cyA9IHtcbiAgICAgIG5leHROb2RlU3RhcnRMaW5lOiAwXG4gICAgfTtcbiAgICBjb25zdCBib3VuZFNlcGFyYXRvciA9IHNlcGFyYXRvciA9PSBudWxsID8gdm9pZCAwIDogc2VwYXJhdG9yLmJpbmQodGhpcyk7XG4gICAgY29uc3QgbGVuID0gbm9kZXMubGVuZ3RoO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgIGNvbnN0IG5vZGUgPSBub2Rlc1tpXTtcbiAgICAgIGlmICghbm9kZSkgY29udGludWU7XG4gICAgICBpZiAoc3RhdGVtZW50KSB0aGlzLl9wcmludE5ld2xpbmUoaSA9PT0gMCwgbmV3bGluZU9wdHMpO1xuICAgICAgdGhpcy5wcmludChub2RlLCB1bmRlZmluZWQsIHRyYWlsaW5nQ29tbWVudHNMaW5lT2Zmc2V0IHx8IDApO1xuICAgICAgaXRlcmF0b3IgPT0gbnVsbCB8fCBpdGVyYXRvcihub2RlLCBpKTtcbiAgICAgIGlmIChib3VuZFNlcGFyYXRvciAhPSBudWxsKSB7XG4gICAgICAgIGlmIChpIDwgbGVuIC0gMSkgYm91bmRTZXBhcmF0b3IoaSwgZmFsc2UpO2Vsc2UgaWYgKHByaW50VHJhaWxpbmdTZXBhcmF0b3IpIGJvdW5kU2VwYXJhdG9yKGksIHRydWUpO1xuICAgICAgfVxuICAgICAgaWYgKHN0YXRlbWVudCkge1xuICAgICAgICB2YXIgX25vZGUkdHJhaWxpbmdDb21tZW50MjtcbiAgICAgICAgaWYgKCEoKF9ub2RlJHRyYWlsaW5nQ29tbWVudDIgPSBub2RlLnRyYWlsaW5nQ29tbWVudHMpICE9IG51bGwgJiYgX25vZGUkdHJhaWxpbmdDb21tZW50Mi5sZW5ndGgpKSB7XG4gICAgICAgICAgdGhpcy5fbGFzdENvbW1lbnRMaW5lID0gMDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaSArIDEgPT09IGxlbikge1xuICAgICAgICAgIHRoaXMubmV3bGluZSgxKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2YXIgX25leHROb2RlJGxvYztcbiAgICAgICAgICBjb25zdCBuZXh0Tm9kZSA9IG5vZGVzW2kgKyAxXTtcbiAgICAgICAgICBuZXdsaW5lT3B0cy5uZXh0Tm9kZVN0YXJ0TGluZSA9ICgoX25leHROb2RlJGxvYyA9IG5leHROb2RlLmxvYykgPT0gbnVsbCA/IHZvaWQgMCA6IF9uZXh0Tm9kZSRsb2Muc3RhcnQubGluZSkgfHwgMDtcbiAgICAgICAgICB0aGlzLl9wcmludE5ld2xpbmUodHJ1ZSwgbmV3bGluZU9wdHMpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChpbmRlbnQpIHRoaXMuZGVkZW50KCk7XG4gIH1cbiAgcHJpbnRBbmRJbmRlbnRPbkNvbW1lbnRzKG5vZGUpIHtcbiAgICBjb25zdCBpbmRlbnQgPSBub2RlLmxlYWRpbmdDb21tZW50cyAmJiBub2RlLmxlYWRpbmdDb21tZW50cy5sZW5ndGggPiAwO1xuICAgIGlmIChpbmRlbnQpIHRoaXMuaW5kZW50KCk7XG4gICAgdGhpcy5wcmludChub2RlKTtcbiAgICBpZiAoaW5kZW50KSB0aGlzLmRlZGVudCgpO1xuICB9XG4gIHByaW50QmxvY2socGFyZW50KSB7XG4gICAgY29uc3Qgbm9kZSA9IHBhcmVudC5ib2R5O1xuICAgIGlmIChub2RlLnR5cGUgIT09IFwiRW1wdHlTdGF0ZW1lbnRcIikge1xuICAgICAgdGhpcy5zcGFjZSgpO1xuICAgIH1cbiAgICB0aGlzLnByaW50KG5vZGUpO1xuICB9XG4gIF9wcmludFRyYWlsaW5nQ29tbWVudHMobm9kZSwgcGFyZW50LCBsaW5lT2Zmc2V0KSB7XG4gICAgY29uc3Qge1xuICAgICAgaW5uZXJDb21tZW50cyxcbiAgICAgIHRyYWlsaW5nQ29tbWVudHNcbiAgICB9ID0gbm9kZTtcbiAgICBpZiAoaW5uZXJDb21tZW50cyAhPSBudWxsICYmIGlubmVyQ29tbWVudHMubGVuZ3RoKSB7XG4gICAgICB0aGlzLl9wcmludENvbW1lbnRzKDIsIGlubmVyQ29tbWVudHMsIG5vZGUsIHBhcmVudCwgbGluZU9mZnNldCk7XG4gICAgfVxuICAgIGlmICh0cmFpbGluZ0NvbW1lbnRzICE9IG51bGwgJiYgdHJhaWxpbmdDb21tZW50cy5sZW5ndGgpIHtcbiAgICAgIHRoaXMuX3ByaW50Q29tbWVudHMoMiwgdHJhaWxpbmdDb21tZW50cywgbm9kZSwgcGFyZW50LCBsaW5lT2Zmc2V0KTtcbiAgICB9XG4gIH1cbiAgX3ByaW50TGVhZGluZ0NvbW1lbnRzKG5vZGUsIHBhcmVudCkge1xuICAgIGNvbnN0IGNvbW1lbnRzID0gbm9kZS5sZWFkaW5nQ29tbWVudHM7XG4gICAgaWYgKCEoY29tbWVudHMgIT0gbnVsbCAmJiBjb21tZW50cy5sZW5ndGgpKSByZXR1cm47XG4gICAgdGhpcy5fcHJpbnRDb21tZW50cygwLCBjb21tZW50cywgbm9kZSwgcGFyZW50KTtcbiAgfVxuICBfbWF5YmVQcmludElubmVyQ29tbWVudHMobmV4dFRva2VuU3RyLCBuZXh0VG9rZW5PY2N1cnJlbmNlQ291bnQpIHtcbiAgICBpZiAodGhpcy5fZW5kc1dpdGhJbm5lclJhdykge1xuICAgICAgdmFyIF90aGlzJHRva2VuTWFwO1xuICAgICAgdGhpcy5wcmludElubmVyQ29tbWVudHMoKF90aGlzJHRva2VuTWFwID0gdGhpcy50b2tlbk1hcCkgPT0gbnVsbCA/IHZvaWQgMCA6IF90aGlzJHRva2VuTWFwLmZpbmRNYXRjaGluZyh0aGlzLl9jdXJyZW50Tm9kZSwgbmV4dFRva2VuU3RyLCBuZXh0VG9rZW5PY2N1cnJlbmNlQ291bnQpKTtcbiAgICB9XG4gICAgdGhpcy5fZW5kc1dpdGhJbm5lclJhdyA9IHRydWU7XG4gICAgdGhpcy5faW5kZW50SW5uZXJDb21tZW50cyA9IHRydWU7XG4gIH1cbiAgcHJpbnRJbm5lckNvbW1lbnRzKG5leHRUb2tlbikge1xuICAgIGNvbnN0IG5vZGUgPSB0aGlzLl9jdXJyZW50Tm9kZTtcbiAgICBjb25zdCBjb21tZW50cyA9IG5vZGUuaW5uZXJDb21tZW50cztcbiAgICBpZiAoIShjb21tZW50cyAhPSBudWxsICYmIGNvbW1lbnRzLmxlbmd0aCkpIHJldHVybjtcbiAgICBjb25zdCBoYXNTcGFjZSA9IHRoaXMuZW5kc1dpdGgoMzIpO1xuICAgIGNvbnN0IGluZGVudCA9IHRoaXMuX2luZGVudElubmVyQ29tbWVudHM7XG4gICAgY29uc3QgcHJpbnRlZENvbW1lbnRzQ291bnQgPSB0aGlzLl9wcmludGVkQ29tbWVudHMuc2l6ZTtcbiAgICBpZiAoaW5kZW50KSB0aGlzLmluZGVudCgpO1xuICAgIHRoaXMuX3ByaW50Q29tbWVudHMoMSwgY29tbWVudHMsIG5vZGUsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCBuZXh0VG9rZW4pO1xuICAgIGlmIChoYXNTcGFjZSAmJiBwcmludGVkQ29tbWVudHNDb3VudCAhPT0gdGhpcy5fcHJpbnRlZENvbW1lbnRzLnNpemUpIHtcbiAgICAgIHRoaXMuc3BhY2UoKTtcbiAgICB9XG4gICAgaWYgKGluZGVudCkgdGhpcy5kZWRlbnQoKTtcbiAgfVxuICBub0luZGVudElubmVyQ29tbWVudHNIZXJlKCkge1xuICAgIHRoaXMuX2luZGVudElubmVyQ29tbWVudHMgPSBmYWxzZTtcbiAgfVxuICBwcmludFNlcXVlbmNlKG5vZGVzLCBpbmRlbnQsIHRyYWlsaW5nQ29tbWVudHNMaW5lT2Zmc2V0KSB7XG4gICAgdGhpcy5wcmludEpvaW4obm9kZXMsIHRydWUsIGluZGVudCAhPSBudWxsID8gaW5kZW50IDogZmFsc2UsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCB1bmRlZmluZWQsIHRyYWlsaW5nQ29tbWVudHNMaW5lT2Zmc2V0KTtcbiAgfVxuICBwcmludExpc3QoaXRlbXMsIHByaW50VHJhaWxpbmdTZXBhcmF0b3IsIHN0YXRlbWVudCwgaW5kZW50LCBzZXBhcmF0b3IsIGl0ZXJhdG9yKSB7XG4gICAgdGhpcy5wcmludEpvaW4oaXRlbXMsIHN0YXRlbWVudCwgaW5kZW50LCBzZXBhcmF0b3IgIT0gbnVsbCA/IHNlcGFyYXRvciA6IGNvbW1hU2VwYXJhdG9yLCBwcmludFRyYWlsaW5nU2VwYXJhdG9yLCBpdGVyYXRvcik7XG4gIH1cbiAgc2hvdWxkUHJpbnRUcmFpbGluZ0NvbW1hKGxpc3RFbmQpIHtcbiAgICBpZiAoIXRoaXMudG9rZW5NYXApIHJldHVybiBudWxsO1xuICAgIGNvbnN0IGxpc3RFbmRJbmRleCA9IHRoaXMudG9rZW5NYXAuZmluZExhc3RJbmRleCh0aGlzLl9jdXJyZW50Tm9kZSwgdG9rZW4gPT4gdGhpcy50b2tlbk1hcC5tYXRjaGVzT3JpZ2luYWwodG9rZW4sIGxpc3RFbmQpKTtcbiAgICBpZiAobGlzdEVuZEluZGV4IDw9IDApIHJldHVybiBudWxsO1xuICAgIHJldHVybiB0aGlzLnRva2VuTWFwLm1hdGNoZXNPcmlnaW5hbCh0aGlzLl90b2tlbnNbbGlzdEVuZEluZGV4IC0gMV0sIFwiLFwiKTtcbiAgfVxuICBfcHJpbnROZXdsaW5lKG5ld0xpbmUsIG9wdHMpIHtcbiAgICBjb25zdCBmb3JtYXQgPSB0aGlzLmZvcm1hdDtcbiAgICBpZiAoZm9ybWF0LnJldGFpbkxpbmVzIHx8IGZvcm1hdC5jb21wYWN0KSByZXR1cm47XG4gICAgaWYgKGZvcm1hdC5jb25jaXNlKSB7XG4gICAgICB0aGlzLnNwYWNlKCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICghbmV3TGluZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBzdGFydExpbmUgPSBvcHRzLm5leHROb2RlU3RhcnRMaW5lO1xuICAgIGNvbnN0IGxhc3RDb21tZW50TGluZSA9IHRoaXMuX2xhc3RDb21tZW50TGluZTtcbiAgICBpZiAoc3RhcnRMaW5lID4gMCAmJiBsYXN0Q29tbWVudExpbmUgPiAwKSB7XG4gICAgICBjb25zdCBvZmZzZXQgPSBzdGFydExpbmUgLSBsYXN0Q29tbWVudExpbmU7XG4gICAgICBpZiAob2Zmc2V0ID49IDApIHtcbiAgICAgICAgdGhpcy5uZXdsaW5lKG9mZnNldCB8fCAxKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAodGhpcy5fYnVmLmhhc0NvbnRlbnQoKSkge1xuICAgICAgdGhpcy5uZXdsaW5lKDEpO1xuICAgIH1cbiAgfVxuICBfc2hvdWxkUHJpbnRDb21tZW50KGNvbW1lbnQsIG5leHRUb2tlbikge1xuICAgIGlmIChjb21tZW50Lmlnbm9yZSkgcmV0dXJuIDA7XG4gICAgaWYgKHRoaXMuX3ByaW50ZWRDb21tZW50cy5oYXMoY29tbWVudCkpIHJldHVybiAwO1xuICAgIGlmICh0aGlzLl9ub0xpbmVUZXJtaW5hdG9yICYmIEhBU19ORVdMSU5FX09SX0JsT0NLX0NPTU1FTlRfRU5ELnRlc3QoY29tbWVudC52YWx1ZSkpIHtcbiAgICAgIHJldHVybiAyO1xuICAgIH1cbiAgICBpZiAobmV4dFRva2VuICYmIHRoaXMudG9rZW5NYXApIHtcbiAgICAgIGNvbnN0IGNvbW1lbnRUb2sgPSB0aGlzLnRva2VuTWFwLmZpbmQodGhpcy5fY3VycmVudE5vZGUsIHRva2VuID0+IHRva2VuLnZhbHVlID09PSBjb21tZW50LnZhbHVlKTtcbiAgICAgIGlmIChjb21tZW50VG9rICYmIGNvbW1lbnRUb2suc3RhcnQgPiBuZXh0VG9rZW4uc3RhcnQpIHtcbiAgICAgICAgcmV0dXJuIDI7XG4gICAgICB9XG4gICAgfVxuICAgIHRoaXMuX3ByaW50ZWRDb21tZW50cy5hZGQoY29tbWVudCk7XG4gICAgaWYgKCF0aGlzLmZvcm1hdC5zaG91bGRQcmludENvbW1lbnQoY29tbWVudC52YWx1ZSkpIHtcbiAgICAgIHJldHVybiAwO1xuICAgIH1cbiAgICByZXR1cm4gMTtcbiAgfVxuICBfcHJpbnRDb21tZW50KGNvbW1lbnQsIHNraXBOZXdMaW5lcykge1xuICAgIGNvbnN0IG5vTGluZVRlcm1pbmF0b3IgPSB0aGlzLl9ub0xpbmVUZXJtaW5hdG9yO1xuICAgIGNvbnN0IGlzQmxvY2tDb21tZW50ID0gY29tbWVudC50eXBlID09PSBcIkNvbW1lbnRCbG9ja1wiO1xuICAgIGNvbnN0IHByaW50TmV3TGluZXMgPSBpc0Jsb2NrQ29tbWVudCAmJiBza2lwTmV3TGluZXMgIT09IDEgJiYgIXRoaXMuX25vTGluZVRlcm1pbmF0b3I7XG4gICAgaWYgKHByaW50TmV3TGluZXMgJiYgdGhpcy5fYnVmLmhhc0NvbnRlbnQoKSAmJiBza2lwTmV3TGluZXMgIT09IDIpIHtcbiAgICAgIHRoaXMubmV3bGluZSgxKTtcbiAgICB9XG4gICAgY29uc3QgbGFzdENoYXJDb2RlID0gdGhpcy5nZXRMYXN0Q2hhcigpO1xuICAgIGlmIChsYXN0Q2hhckNvZGUgIT09IDkxICYmIGxhc3RDaGFyQ29kZSAhPT0gMTIzICYmIGxhc3RDaGFyQ29kZSAhPT0gNDApIHtcbiAgICAgIHRoaXMuc3BhY2UoKTtcbiAgICB9XG4gICAgbGV0IHZhbDtcbiAgICBpZiAoaXNCbG9ja0NvbW1lbnQpIHtcbiAgICAgIHZhbCA9IGAvKiR7Y29tbWVudC52YWx1ZX0qL2A7XG4gICAgICBpZiAodGhpcy5mb3JtYXQuaW5kZW50LmFkanVzdE11bHRpbGluZUNvbW1lbnQpIHtcbiAgICAgICAgdmFyIF9jb21tZW50JGxvYztcbiAgICAgICAgY29uc3Qgb2Zmc2V0ID0gKF9jb21tZW50JGxvYyA9IGNvbW1lbnQubG9jKSA9PSBudWxsID8gdm9pZCAwIDogX2NvbW1lbnQkbG9jLnN0YXJ0LmNvbHVtbjtcbiAgICAgICAgaWYgKG9mZnNldCkge1xuICAgICAgICAgIGNvbnN0IG5ld2xpbmVSZWdleCA9IG5ldyBSZWdFeHAoXCJcXFxcblxcXFxzezEsXCIgKyBvZmZzZXQgKyBcIn1cIiwgXCJnXCIpO1xuICAgICAgICAgIHZhbCA9IHZhbC5yZXBsYWNlKG5ld2xpbmVSZWdleCwgXCJcXG5cIik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuZm9ybWF0LmNvbmNpc2UpIHtcbiAgICAgICAgICB2YWwgPSB2YWwucmVwbGFjZSgvXFxuKD8hJCkvZywgYFxcbmApO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGxldCBpbmRlbnRTaXplID0gdGhpcy5mb3JtYXQucmV0YWluTGluZXMgPyAwIDogdGhpcy5fYnVmLmdldEN1cnJlbnRDb2x1bW4oKTtcbiAgICAgICAgICBpZiAodGhpcy5fc2hvdWxkSW5kZW50KDQ3KSB8fCB0aGlzLmZvcm1hdC5yZXRhaW5MaW5lcykge1xuICAgICAgICAgICAgaW5kZW50U2l6ZSArPSB0aGlzLl9nZXRJbmRlbnQoKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdmFsID0gdmFsLnJlcGxhY2UoL1xcbig/ISQpL2csIGBcXG4ke1wiIFwiLnJlcGVhdChpbmRlbnRTaXplKX1gKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoIW5vTGluZVRlcm1pbmF0b3IpIHtcbiAgICAgIHZhbCA9IGAvLyR7Y29tbWVudC52YWx1ZX1gO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YWwgPSBgLyoke2NvbW1lbnQudmFsdWV9Ki9gO1xuICAgIH1cbiAgICBpZiAodGhpcy5fZW5kc1dpdGhEaXYpIHRoaXMuX3NwYWNlKCk7XG4gICAgaWYgKHRoaXMudG9rZW5NYXApIHtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgX3ByaW50U2VtaWNvbG9uQmVmb3JlTmV4dFRva2VuLFxuICAgICAgICBfcHJpbnRTZW1pY29sb25CZWZvcmVOZXh0Tm9kZVxuICAgICAgfSA9IHRoaXM7XG4gICAgICB0aGlzLl9wcmludFNlbWljb2xvbkJlZm9yZU5leHRUb2tlbiA9IC0xO1xuICAgICAgdGhpcy5fcHJpbnRTZW1pY29sb25CZWZvcmVOZXh0Tm9kZSA9IC0xO1xuICAgICAgdGhpcy5zb3VyY2UoXCJzdGFydFwiLCBjb21tZW50LmxvYyk7XG4gICAgICB0aGlzLl9hcHBlbmQodmFsLCBpc0Jsb2NrQ29tbWVudCk7XG4gICAgICB0aGlzLl9wcmludFNlbWljb2xvbkJlZm9yZU5leHROb2RlID0gX3ByaW50U2VtaWNvbG9uQmVmb3JlTmV4dE5vZGU7XG4gICAgICB0aGlzLl9wcmludFNlbWljb2xvbkJlZm9yZU5leHRUb2tlbiA9IF9wcmludFNlbWljb2xvbkJlZm9yZU5leHRUb2tlbjtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5zb3VyY2UoXCJzdGFydFwiLCBjb21tZW50LmxvYyk7XG4gICAgICB0aGlzLl9hcHBlbmQodmFsLCBpc0Jsb2NrQ29tbWVudCk7XG4gICAgfVxuICAgIGlmICghaXNCbG9ja0NvbW1lbnQgJiYgIW5vTGluZVRlcm1pbmF0b3IpIHtcbiAgICAgIHRoaXMubmV3bGluZSgxLCB0cnVlKTtcbiAgICB9XG4gICAgaWYgKHByaW50TmV3TGluZXMgJiYgc2tpcE5ld0xpbmVzICE9PSAzKSB7XG4gICAgICB0aGlzLm5ld2xpbmUoMSk7XG4gICAgfVxuICB9XG4gIF9wcmludENvbW1lbnRzKHR5cGUsIGNvbW1lbnRzLCBub2RlLCBwYXJlbnQsIGxpbmVPZmZzZXQgPSAwLCBuZXh0VG9rZW4pIHtcbiAgICBjb25zdCBub2RlTG9jID0gbm9kZS5sb2M7XG4gICAgY29uc3QgbGVuID0gY29tbWVudHMubGVuZ3RoO1xuICAgIGxldCBoYXNMb2MgPSAhIW5vZGVMb2M7XG4gICAgY29uc3Qgbm9kZVN0YXJ0TGluZSA9IGhhc0xvYyA/IG5vZGVMb2Muc3RhcnQubGluZSA6IDA7XG4gICAgY29uc3Qgbm9kZUVuZExpbmUgPSBoYXNMb2MgPyBub2RlTG9jLmVuZC5saW5lIDogMDtcbiAgICBsZXQgbGFzdExpbmUgPSAwO1xuICAgIGxldCBsZWFkaW5nQ29tbWVudE5ld2xpbmUgPSAwO1xuICAgIGNvbnN0IG1heWJlTmV3bGluZSA9IHRoaXMuX25vTGluZVRlcm1pbmF0b3IgPyBmdW5jdGlvbiAoKSB7fSA6IHRoaXMubmV3bGluZS5iaW5kKHRoaXMpO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgIGNvbnN0IGNvbW1lbnQgPSBjb21tZW50c1tpXTtcbiAgICAgIGNvbnN0IHNob3VsZFByaW50ID0gdGhpcy5fc2hvdWxkUHJpbnRDb21tZW50KGNvbW1lbnQsIG5leHRUb2tlbik7XG4gICAgICBpZiAoc2hvdWxkUHJpbnQgPT09IDIpIHtcbiAgICAgICAgaGFzTG9jID0gZmFsc2U7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgaWYgKGhhc0xvYyAmJiBjb21tZW50LmxvYyAmJiBzaG91bGRQcmludCA9PT0gMSkge1xuICAgICAgICBjb25zdCBjb21tZW50U3RhcnRMaW5lID0gY29tbWVudC5sb2Muc3RhcnQubGluZTtcbiAgICAgICAgY29uc3QgY29tbWVudEVuZExpbmUgPSBjb21tZW50LmxvYy5lbmQubGluZTtcbiAgICAgICAgaWYgKHR5cGUgPT09IDApIHtcbiAgICAgICAgICBsZXQgb2Zmc2V0ID0gMDtcbiAgICAgICAgICBpZiAoaSA9PT0gMCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuX2J1Zi5oYXNDb250ZW50KCkgJiYgKGNvbW1lbnQudHlwZSA9PT0gXCJDb21tZW50TGluZVwiIHx8IGNvbW1lbnRTdGFydExpbmUgIT09IGNvbW1lbnRFbmRMaW5lKSkge1xuICAgICAgICAgICAgICBvZmZzZXQgPSBsZWFkaW5nQ29tbWVudE5ld2xpbmUgPSAxO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBvZmZzZXQgPSBjb21tZW50U3RhcnRMaW5lIC0gbGFzdExpbmU7XG4gICAgICAgICAgfVxuICAgICAgICAgIGxhc3RMaW5lID0gY29tbWVudEVuZExpbmU7XG4gICAgICAgICAgbWF5YmVOZXdsaW5lKG9mZnNldCk7XG4gICAgICAgICAgdGhpcy5fcHJpbnRDb21tZW50KGNvbW1lbnQsIDEpO1xuICAgICAgICAgIGlmIChpICsgMSA9PT0gbGVuKSB7XG4gICAgICAgICAgICBtYXliZU5ld2xpbmUoTWF0aC5tYXgobm9kZVN0YXJ0TGluZSAtIGxhc3RMaW5lLCBsZWFkaW5nQ29tbWVudE5ld2xpbmUpKTtcbiAgICAgICAgICAgIGxhc3RMaW5lID0gbm9kZVN0YXJ0TGluZTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gMSkge1xuICAgICAgICAgIGNvbnN0IG9mZnNldCA9IGNvbW1lbnRTdGFydExpbmUgLSAoaSA9PT0gMCA/IG5vZGVTdGFydExpbmUgOiBsYXN0TGluZSk7XG4gICAgICAgICAgbGFzdExpbmUgPSBjb21tZW50RW5kTGluZTtcbiAgICAgICAgICBtYXliZU5ld2xpbmUob2Zmc2V0KTtcbiAgICAgICAgICB0aGlzLl9wcmludENvbW1lbnQoY29tbWVudCwgMSk7XG4gICAgICAgICAgaWYgKGkgKyAxID09PSBsZW4pIHtcbiAgICAgICAgICAgIG1heWJlTmV3bGluZShNYXRoLm1pbigxLCBub2RlRW5kTGluZSAtIGxhc3RMaW5lKSk7XG4gICAgICAgICAgICBsYXN0TGluZSA9IG5vZGVFbmRMaW5lO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjb25zdCBvZmZzZXQgPSBjb21tZW50U3RhcnRMaW5lIC0gKGkgPT09IDAgPyBub2RlRW5kTGluZSAtIGxpbmVPZmZzZXQgOiBsYXN0TGluZSk7XG4gICAgICAgICAgbGFzdExpbmUgPSBjb21tZW50RW5kTGluZTtcbiAgICAgICAgICBtYXliZU5ld2xpbmUob2Zmc2V0KTtcbiAgICAgICAgICB0aGlzLl9wcmludENvbW1lbnQoY29tbWVudCwgMSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGhhc0xvYyA9IGZhbHNlO1xuICAgICAgICBpZiAoc2hvdWxkUHJpbnQgIT09IDEpIHtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobGVuID09PSAxKSB7XG4gICAgICAgICAgY29uc3Qgc2luZ2xlTGluZSA9IGNvbW1lbnQubG9jID8gY29tbWVudC5sb2Muc3RhcnQubGluZSA9PT0gY29tbWVudC5sb2MuZW5kLmxpbmUgOiAhSEFTX05FV0xJTkUudGVzdChjb21tZW50LnZhbHVlKTtcbiAgICAgICAgICBjb25zdCBzaG91bGRTa2lwTmV3bGluZSA9IHNpbmdsZUxpbmUgJiYgIWlzU3RhdGVtZW50KG5vZGUpICYmICFpc0NsYXNzQm9keShwYXJlbnQpICYmICFpc1RTSW50ZXJmYWNlQm9keShwYXJlbnQpICYmICFpc1RTRW51bU1lbWJlcihub2RlKTtcbiAgICAgICAgICBpZiAodHlwZSA9PT0gMCkge1xuICAgICAgICAgICAgdGhpcy5fcHJpbnRDb21tZW50KGNvbW1lbnQsIHNob3VsZFNraXBOZXdsaW5lICYmIG5vZGUudHlwZSAhPT0gXCJPYmplY3RFeHByZXNzaW9uXCIgfHwgc2luZ2xlTGluZSAmJiBpc0Z1bmN0aW9uKHBhcmVudCwge1xuICAgICAgICAgICAgICBib2R5OiBub2RlXG4gICAgICAgICAgICB9KSA/IDEgOiAwKTtcbiAgICAgICAgICB9IGVsc2UgaWYgKHNob3VsZFNraXBOZXdsaW5lICYmIHR5cGUgPT09IDIpIHtcbiAgICAgICAgICAgIHRoaXMuX3ByaW50Q29tbWVudChjb21tZW50LCAxKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5fcHJpbnRDb21tZW50KGNvbW1lbnQsIDApO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmICh0eXBlID09PSAxICYmICEobm9kZS50eXBlID09PSBcIk9iamVjdEV4cHJlc3Npb25cIiAmJiBub2RlLnByb3BlcnRpZXMubGVuZ3RoID4gMSkgJiYgbm9kZS50eXBlICE9PSBcIkNsYXNzQm9keVwiICYmIG5vZGUudHlwZSAhPT0gXCJUU0ludGVyZmFjZUJvZHlcIikge1xuICAgICAgICAgIHRoaXMuX3ByaW50Q29tbWVudChjb21tZW50LCBpID09PSAwID8gMiA6IGkgPT09IGxlbiAtIDEgPyAzIDogMCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5fcHJpbnRDb21tZW50KGNvbW1lbnQsIDApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGlmICh0eXBlID09PSAyICYmIGhhc0xvYyAmJiBsYXN0TGluZSkge1xuICAgICAgdGhpcy5fbGFzdENvbW1lbnRMaW5lID0gbGFzdExpbmU7XG4gICAgfVxuICB9XG59XG5PYmplY3QuYXNzaWduKFByaW50ZXIucHJvdG90eXBlLCBnZW5lcmF0b3JGdW5jdGlvbnMpO1xuKDAsIF9kZXByZWNhdGVkLmFkZERlcHJlY2F0ZWRHZW5lcmF0b3JzKShQcmludGVyKTtcbnZhciBfZGVmYXVsdCA9IGV4cG9ydHMuZGVmYXVsdCA9IFByaW50ZXI7XG5mdW5jdGlvbiBjb21tYVNlcGFyYXRvcihvY2N1cnJlbmNlQ291bnQsIGxhc3QpIHtcbiAgdGhpcy50b2tlbihcIixcIiwgZmFsc2UsIG9jY3VycmVuY2VDb3VudCk7XG4gIGlmICghbGFzdCkgdGhpcy5zcGFjZSgpO1xufVxuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1wcmludGVyLmpzLm1hcFxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@babel/generator/lib/printer.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@babel/generator/lib/source-map.js":
/*!*********************************************************!*\
  !*** ./node_modules/@babel/generator/lib/source-map.js ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports[\"default\"] = void 0;\nvar _genMapping = __webpack_require__(/*! @jridgewell/gen-mapping */ \"(ssr)/./node_modules/@jridgewell/gen-mapping/dist/gen-mapping.umd.js\");\nvar _traceMapping = __webpack_require__(/*! @jridgewell/trace-mapping */ \"(ssr)/./node_modules/@jridgewell/trace-mapping/dist/trace-mapping.umd.js\");\nclass SourceMap {\n  constructor(opts, code) {\n    var _opts$sourceFileName;\n    this._map = void 0;\n    this._rawMappings = void 0;\n    this._sourceFileName = void 0;\n    this._lastGenLine = 0;\n    this._lastSourceLine = 0;\n    this._lastSourceColumn = 0;\n    this._inputMap = null;\n    const map = this._map = new _genMapping.GenMapping({\n      sourceRoot: opts.sourceRoot\n    });\n    this._sourceFileName = (_opts$sourceFileName = opts.sourceFileName) == null ? void 0 : _opts$sourceFileName.replace(/\\\\/g, \"/\");\n    this._rawMappings = undefined;\n    if (opts.inputSourceMap) {\n      this._inputMap = new _traceMapping.TraceMap(opts.inputSourceMap);\n      const resolvedSources = this._inputMap.resolvedSources;\n      if (resolvedSources.length) {\n        for (let i = 0; i < resolvedSources.length; i++) {\n          var _this$_inputMap$sourc;\n          (0, _genMapping.setSourceContent)(map, resolvedSources[i], (_this$_inputMap$sourc = this._inputMap.sourcesContent) == null ? void 0 : _this$_inputMap$sourc[i]);\n        }\n      }\n    }\n    if (typeof code === \"string\" && !opts.inputSourceMap) {\n      (0, _genMapping.setSourceContent)(map, this._sourceFileName, code);\n    } else if (typeof code === \"object\") {\n      for (const sourceFileName of Object.keys(code)) {\n        (0, _genMapping.setSourceContent)(map, sourceFileName.replace(/\\\\/g, \"/\"), code[sourceFileName]);\n      }\n    }\n  }\n  get() {\n    return (0, _genMapping.toEncodedMap)(this._map);\n  }\n  getDecoded() {\n    return (0, _genMapping.toDecodedMap)(this._map);\n  }\n  getRawMappings() {\n    return this._rawMappings || (this._rawMappings = (0, _genMapping.allMappings)(this._map));\n  }\n  mark(generated, line, column, identifierName, identifierNamePos, filename) {\n    var _originalMapping;\n    this._rawMappings = undefined;\n    let originalMapping;\n    if (line != null) {\n      if (this._inputMap) {\n        originalMapping = (0, _traceMapping.originalPositionFor)(this._inputMap, {\n          line,\n          column: column\n        });\n        if (!originalMapping.name && identifierNamePos) {\n          const originalIdentifierMapping = (0, _traceMapping.originalPositionFor)(this._inputMap, identifierNamePos);\n          if (originalIdentifierMapping.name) {\n            identifierName = originalIdentifierMapping.name;\n          }\n        }\n      } else {\n        originalMapping = {\n          name: null,\n          source: (filename == null ? void 0 : filename.replace(/\\\\/g, \"/\")) || this._sourceFileName,\n          line: line,\n          column: column\n        };\n      }\n    }\n    (0, _genMapping.maybeAddMapping)(this._map, {\n      name: identifierName,\n      generated,\n      source: (_originalMapping = originalMapping) == null ? void 0 : _originalMapping.source,\n      original: originalMapping\n    });\n  }\n}\nexports[\"default\"] = SourceMap;\n\n//# sourceMappingURL=source-map.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGJhYmVsL2dlbmVyYXRvci9saWIvc291cmNlLW1hcC5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYiw4Q0FBNkM7QUFDN0M7QUFDQSxDQUFDLEVBQUM7QUFDRixrQkFBZTtBQUNmLGtCQUFrQixtQkFBTyxDQUFDLHFHQUF5QjtBQUNuRCxvQkFBb0IsbUJBQU8sQ0FBQywyR0FBMkI7QUFDdkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3Qiw0QkFBNEI7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLGtCQUFlOztBQUVmIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcmVwby12aXN1YWxpemVyLy4vbm9kZV9tb2R1bGVzL0BiYWJlbC9nZW5lcmF0b3IvbGliL3NvdXJjZS1tYXAuanM/YzEyOCJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuZGVmYXVsdCA9IHZvaWQgMDtcbnZhciBfZ2VuTWFwcGluZyA9IHJlcXVpcmUoXCJAanJpZGdld2VsbC9nZW4tbWFwcGluZ1wiKTtcbnZhciBfdHJhY2VNYXBwaW5nID0gcmVxdWlyZShcIkBqcmlkZ2V3ZWxsL3RyYWNlLW1hcHBpbmdcIik7XG5jbGFzcyBTb3VyY2VNYXAge1xuICBjb25zdHJ1Y3RvcihvcHRzLCBjb2RlKSB7XG4gICAgdmFyIF9vcHRzJHNvdXJjZUZpbGVOYW1lO1xuICAgIHRoaXMuX21hcCA9IHZvaWQgMDtcbiAgICB0aGlzLl9yYXdNYXBwaW5ncyA9IHZvaWQgMDtcbiAgICB0aGlzLl9zb3VyY2VGaWxlTmFtZSA9IHZvaWQgMDtcbiAgICB0aGlzLl9sYXN0R2VuTGluZSA9IDA7XG4gICAgdGhpcy5fbGFzdFNvdXJjZUxpbmUgPSAwO1xuICAgIHRoaXMuX2xhc3RTb3VyY2VDb2x1bW4gPSAwO1xuICAgIHRoaXMuX2lucHV0TWFwID0gbnVsbDtcbiAgICBjb25zdCBtYXAgPSB0aGlzLl9tYXAgPSBuZXcgX2dlbk1hcHBpbmcuR2VuTWFwcGluZyh7XG4gICAgICBzb3VyY2VSb290OiBvcHRzLnNvdXJjZVJvb3RcbiAgICB9KTtcbiAgICB0aGlzLl9zb3VyY2VGaWxlTmFtZSA9IChfb3B0cyRzb3VyY2VGaWxlTmFtZSA9IG9wdHMuc291cmNlRmlsZU5hbWUpID09IG51bGwgPyB2b2lkIDAgOiBfb3B0cyRzb3VyY2VGaWxlTmFtZS5yZXBsYWNlKC9cXFxcL2csIFwiL1wiKTtcbiAgICB0aGlzLl9yYXdNYXBwaW5ncyA9IHVuZGVmaW5lZDtcbiAgICBpZiAob3B0cy5pbnB1dFNvdXJjZU1hcCkge1xuICAgICAgdGhpcy5faW5wdXRNYXAgPSBuZXcgX3RyYWNlTWFwcGluZy5UcmFjZU1hcChvcHRzLmlucHV0U291cmNlTWFwKTtcbiAgICAgIGNvbnN0IHJlc29sdmVkU291cmNlcyA9IHRoaXMuX2lucHV0TWFwLnJlc29sdmVkU291cmNlcztcbiAgICAgIGlmIChyZXNvbHZlZFNvdXJjZXMubGVuZ3RoKSB7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcmVzb2x2ZWRTb3VyY2VzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgdmFyIF90aGlzJF9pbnB1dE1hcCRzb3VyYztcbiAgICAgICAgICAoMCwgX2dlbk1hcHBpbmcuc2V0U291cmNlQ29udGVudCkobWFwLCByZXNvbHZlZFNvdXJjZXNbaV0sIChfdGhpcyRfaW5wdXRNYXAkc291cmMgPSB0aGlzLl9pbnB1dE1hcC5zb3VyY2VzQ29udGVudCkgPT0gbnVsbCA/IHZvaWQgMCA6IF90aGlzJF9pbnB1dE1hcCRzb3VyY1tpXSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHR5cGVvZiBjb2RlID09PSBcInN0cmluZ1wiICYmICFvcHRzLmlucHV0U291cmNlTWFwKSB7XG4gICAgICAoMCwgX2dlbk1hcHBpbmcuc2V0U291cmNlQ29udGVudCkobWFwLCB0aGlzLl9zb3VyY2VGaWxlTmFtZSwgY29kZSk7XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgY29kZSA9PT0gXCJvYmplY3RcIikge1xuICAgICAgZm9yIChjb25zdCBzb3VyY2VGaWxlTmFtZSBvZiBPYmplY3Qua2V5cyhjb2RlKSkge1xuICAgICAgICAoMCwgX2dlbk1hcHBpbmcuc2V0U291cmNlQ29udGVudCkobWFwLCBzb3VyY2VGaWxlTmFtZS5yZXBsYWNlKC9cXFxcL2csIFwiL1wiKSwgY29kZVtzb3VyY2VGaWxlTmFtZV0pO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBnZXQoKSB7XG4gICAgcmV0dXJuICgwLCBfZ2VuTWFwcGluZy50b0VuY29kZWRNYXApKHRoaXMuX21hcCk7XG4gIH1cbiAgZ2V0RGVjb2RlZCgpIHtcbiAgICByZXR1cm4gKDAsIF9nZW5NYXBwaW5nLnRvRGVjb2RlZE1hcCkodGhpcy5fbWFwKTtcbiAgfVxuICBnZXRSYXdNYXBwaW5ncygpIHtcbiAgICByZXR1cm4gdGhpcy5fcmF3TWFwcGluZ3MgfHwgKHRoaXMuX3Jhd01hcHBpbmdzID0gKDAsIF9nZW5NYXBwaW5nLmFsbE1hcHBpbmdzKSh0aGlzLl9tYXApKTtcbiAgfVxuICBtYXJrKGdlbmVyYXRlZCwgbGluZSwgY29sdW1uLCBpZGVudGlmaWVyTmFtZSwgaWRlbnRpZmllck5hbWVQb3MsIGZpbGVuYW1lKSB7XG4gICAgdmFyIF9vcmlnaW5hbE1hcHBpbmc7XG4gICAgdGhpcy5fcmF3TWFwcGluZ3MgPSB1bmRlZmluZWQ7XG4gICAgbGV0IG9yaWdpbmFsTWFwcGluZztcbiAgICBpZiAobGluZSAhPSBudWxsKSB7XG4gICAgICBpZiAodGhpcy5faW5wdXRNYXApIHtcbiAgICAgICAgb3JpZ2luYWxNYXBwaW5nID0gKDAsIF90cmFjZU1hcHBpbmcub3JpZ2luYWxQb3NpdGlvbkZvcikodGhpcy5faW5wdXRNYXAsIHtcbiAgICAgICAgICBsaW5lLFxuICAgICAgICAgIGNvbHVtbjogY29sdW1uXG4gICAgICAgIH0pO1xuICAgICAgICBpZiAoIW9yaWdpbmFsTWFwcGluZy5uYW1lICYmIGlkZW50aWZpZXJOYW1lUG9zKSB7XG4gICAgICAgICAgY29uc3Qgb3JpZ2luYWxJZGVudGlmaWVyTWFwcGluZyA9ICgwLCBfdHJhY2VNYXBwaW5nLm9yaWdpbmFsUG9zaXRpb25Gb3IpKHRoaXMuX2lucHV0TWFwLCBpZGVudGlmaWVyTmFtZVBvcyk7XG4gICAgICAgICAgaWYgKG9yaWdpbmFsSWRlbnRpZmllck1hcHBpbmcubmFtZSkge1xuICAgICAgICAgICAgaWRlbnRpZmllck5hbWUgPSBvcmlnaW5hbElkZW50aWZpZXJNYXBwaW5nLm5hbWU7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBvcmlnaW5hbE1hcHBpbmcgPSB7XG4gICAgICAgICAgbmFtZTogbnVsbCxcbiAgICAgICAgICBzb3VyY2U6IChmaWxlbmFtZSA9PSBudWxsID8gdm9pZCAwIDogZmlsZW5hbWUucmVwbGFjZSgvXFxcXC9nLCBcIi9cIikpIHx8IHRoaXMuX3NvdXJjZUZpbGVOYW1lLFxuICAgICAgICAgIGxpbmU6IGxpbmUsXG4gICAgICAgICAgY29sdW1uOiBjb2x1bW5cbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICB9XG4gICAgKDAsIF9nZW5NYXBwaW5nLm1heWJlQWRkTWFwcGluZykodGhpcy5fbWFwLCB7XG4gICAgICBuYW1lOiBpZGVudGlmaWVyTmFtZSxcbiAgICAgIGdlbmVyYXRlZCxcbiAgICAgIHNvdXJjZTogKF9vcmlnaW5hbE1hcHBpbmcgPSBvcmlnaW5hbE1hcHBpbmcpID09IG51bGwgPyB2b2lkIDAgOiBfb3JpZ2luYWxNYXBwaW5nLnNvdXJjZSxcbiAgICAgIG9yaWdpbmFsOiBvcmlnaW5hbE1hcHBpbmdcbiAgICB9KTtcbiAgfVxufVxuZXhwb3J0cy5kZWZhdWx0ID0gU291cmNlTWFwO1xuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1zb3VyY2UtbWFwLmpzLm1hcFxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@babel/generator/lib/source-map.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@babel/generator/lib/token-map.js":
/*!********************************************************!*\
  !*** ./node_modules/@babel/generator/lib/token-map.js ***!
  \********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports.TokenMap = void 0;\nvar _t = __webpack_require__(/*! @babel/types */ \"(ssr)/./node_modules/@babel/types/lib/index.js\");\nconst {\n  traverseFast,\n  VISITOR_KEYS\n} = _t;\nclass TokenMap {\n  constructor(ast, tokens, source) {\n    this._tokens = void 0;\n    this._source = void 0;\n    this._nodesToTokenIndexes = new Map();\n    this._nodesOccurrencesCountCache = new Map();\n    this._tokensCache = new Map();\n    this._tokens = tokens;\n    this._source = source;\n    traverseFast(ast, node => {\n      const indexes = this._getTokensIndexesOfNode(node);\n      if (indexes.length > 0) this._nodesToTokenIndexes.set(node, indexes);\n    });\n    this._tokensCache.clear();\n  }\n  has(node) {\n    return this._nodesToTokenIndexes.has(node);\n  }\n  getIndexes(node) {\n    return this._nodesToTokenIndexes.get(node);\n  }\n  find(node, condition) {\n    const indexes = this._nodesToTokenIndexes.get(node);\n    if (indexes) {\n      for (let k = 0; k < indexes.length; k++) {\n        const index = indexes[k];\n        const tok = this._tokens[index];\n        if (condition(tok, index)) return tok;\n      }\n    }\n    return null;\n  }\n  findLastIndex(node, condition) {\n    const indexes = this._nodesToTokenIndexes.get(node);\n    if (indexes) {\n      for (let k = indexes.length - 1; k >= 0; k--) {\n        const index = indexes[k];\n        const tok = this._tokens[index];\n        if (condition(tok, index)) return index;\n      }\n    }\n    return -1;\n  }\n  findMatching(node, test, occurrenceCount = 0) {\n    const indexes = this._nodesToTokenIndexes.get(node);\n    if (indexes) {\n      let i = 0;\n      const count = occurrenceCount;\n      if (count > 1) {\n        const cache = this._nodesOccurrencesCountCache.get(node);\n        if ((cache == null ? void 0 : cache.test) === test && cache.count < count) {\n          i = cache.i + 1;\n          occurrenceCount -= cache.count + 1;\n        }\n      }\n      for (; i < indexes.length; i++) {\n        const tok = this._tokens[indexes[i]];\n        if (this.matchesOriginal(tok, test)) {\n          if (occurrenceCount === 0) {\n            if (count > 0) {\n              this._nodesOccurrencesCountCache.set(node, {\n                test,\n                count,\n                i\n              });\n            }\n            return tok;\n          }\n          occurrenceCount--;\n        }\n      }\n    }\n    return null;\n  }\n  matchesOriginal(token, test) {\n    if (token.end - token.start !== test.length) return false;\n    if (token.value != null) return token.value === test;\n    return this._source.startsWith(test, token.start);\n  }\n  startMatches(node, test) {\n    const indexes = this._nodesToTokenIndexes.get(node);\n    if (!indexes) return false;\n    const tok = this._tokens[indexes[0]];\n    if (tok.start !== node.start) return false;\n    return this.matchesOriginal(tok, test);\n  }\n  endMatches(node, test) {\n    const indexes = this._nodesToTokenIndexes.get(node);\n    if (!indexes) return false;\n    const tok = this._tokens[indexes[indexes.length - 1]];\n    if (tok.end !== node.end) return false;\n    return this.matchesOriginal(tok, test);\n  }\n  _getTokensIndexesOfNode(node) {\n    var _node$declaration;\n    if (node.start == null || node.end == null) return [];\n    const {\n      first,\n      last\n    } = this._findTokensOfNode(node, 0, this._tokens.length - 1);\n    let low = first;\n    const children = childrenIterator(node);\n    if ((node.type === \"ExportNamedDeclaration\" || node.type === \"ExportDefaultDeclaration\") && ((_node$declaration = node.declaration) == null ? void 0 : _node$declaration.type) === \"ClassDeclaration\") {\n      children.next();\n    }\n    const indexes = [];\n    for (const child of children) {\n      if (child == null) continue;\n      if (child.start == null || child.end == null) continue;\n      const childTok = this._findTokensOfNode(child, low, last);\n      const high = childTok.first;\n      for (let k = low; k < high; k++) indexes.push(k);\n      low = childTok.last + 1;\n    }\n    for (let k = low; k <= last; k++) indexes.push(k);\n    return indexes;\n  }\n  _findTokensOfNode(node, low, high) {\n    const cached = this._tokensCache.get(node);\n    if (cached) return cached;\n    const first = this._findFirstTokenOfNode(node.start, low, high);\n    const last = this._findLastTokenOfNode(node.end, first, high);\n    this._tokensCache.set(node, {\n      first,\n      last\n    });\n    return {\n      first,\n      last\n    };\n  }\n  _findFirstTokenOfNode(start, low, high) {\n    while (low <= high) {\n      const mid = high + low >> 1;\n      if (start < this._tokens[mid].start) {\n        high = mid - 1;\n      } else if (start > this._tokens[mid].start) {\n        low = mid + 1;\n      } else {\n        return mid;\n      }\n    }\n    return low;\n  }\n  _findLastTokenOfNode(end, low, high) {\n    while (low <= high) {\n      const mid = high + low >> 1;\n      if (end < this._tokens[mid].end) {\n        high = mid - 1;\n      } else if (end > this._tokens[mid].end) {\n        low = mid + 1;\n      } else {\n        return mid;\n      }\n    }\n    return high;\n  }\n}\nexports.TokenMap = TokenMap;\nfunction* childrenIterator(node) {\n  if (node.type === \"TemplateLiteral\") {\n    yield node.quasis[0];\n    for (let i = 1; i < node.quasis.length; i++) {\n      yield node.expressions[i - 1];\n      yield node.quasis[i];\n    }\n    return;\n  }\n  const keys = VISITOR_KEYS[node.type];\n  for (const key of keys) {\n    const child = node[key];\n    if (!child) continue;\n    if (Array.isArray(child)) {\n      yield* child;\n    } else {\n      yield child;\n    }\n  }\n}\n\n//# sourceMappingURL=token-map.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGJhYmVsL2dlbmVyYXRvci9saWIvdG9rZW4tbWFwLmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViLDhDQUE2QztBQUM3QztBQUNBLENBQUMsRUFBQztBQUNGLGdCQUFnQjtBQUNoQixTQUFTLG1CQUFPLENBQUMsb0VBQWM7QUFDL0I7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLG9CQUFvQjtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1QyxRQUFRO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxvQkFBb0I7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLFVBQVU7QUFDbEM7QUFDQTtBQUNBLHNCQUFzQixXQUFXO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQSxvQkFBb0Isd0JBQXdCO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7O0FBRUEiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9yZXBvLXZpc3VhbGl6ZXIvLi9ub2RlX21vZHVsZXMvQGJhYmVsL2dlbmVyYXRvci9saWIvdG9rZW4tbWFwLmpzPzViNzAiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLlRva2VuTWFwID0gdm9pZCAwO1xudmFyIF90ID0gcmVxdWlyZShcIkBiYWJlbC90eXBlc1wiKTtcbmNvbnN0IHtcbiAgdHJhdmVyc2VGYXN0LFxuICBWSVNJVE9SX0tFWVNcbn0gPSBfdDtcbmNsYXNzIFRva2VuTWFwIHtcbiAgY29uc3RydWN0b3IoYXN0LCB0b2tlbnMsIHNvdXJjZSkge1xuICAgIHRoaXMuX3Rva2VucyA9IHZvaWQgMDtcbiAgICB0aGlzLl9zb3VyY2UgPSB2b2lkIDA7XG4gICAgdGhpcy5fbm9kZXNUb1Rva2VuSW5kZXhlcyA9IG5ldyBNYXAoKTtcbiAgICB0aGlzLl9ub2Rlc09jY3VycmVuY2VzQ291bnRDYWNoZSA9IG5ldyBNYXAoKTtcbiAgICB0aGlzLl90b2tlbnNDYWNoZSA9IG5ldyBNYXAoKTtcbiAgICB0aGlzLl90b2tlbnMgPSB0b2tlbnM7XG4gICAgdGhpcy5fc291cmNlID0gc291cmNlO1xuICAgIHRyYXZlcnNlRmFzdChhc3QsIG5vZGUgPT4ge1xuICAgICAgY29uc3QgaW5kZXhlcyA9IHRoaXMuX2dldFRva2Vuc0luZGV4ZXNPZk5vZGUobm9kZSk7XG4gICAgICBpZiAoaW5kZXhlcy5sZW5ndGggPiAwKSB0aGlzLl9ub2Rlc1RvVG9rZW5JbmRleGVzLnNldChub2RlLCBpbmRleGVzKTtcbiAgICB9KTtcbiAgICB0aGlzLl90b2tlbnNDYWNoZS5jbGVhcigpO1xuICB9XG4gIGhhcyhub2RlKSB7XG4gICAgcmV0dXJuIHRoaXMuX25vZGVzVG9Ub2tlbkluZGV4ZXMuaGFzKG5vZGUpO1xuICB9XG4gIGdldEluZGV4ZXMobm9kZSkge1xuICAgIHJldHVybiB0aGlzLl9ub2Rlc1RvVG9rZW5JbmRleGVzLmdldChub2RlKTtcbiAgfVxuICBmaW5kKG5vZGUsIGNvbmRpdGlvbikge1xuICAgIGNvbnN0IGluZGV4ZXMgPSB0aGlzLl9ub2Rlc1RvVG9rZW5JbmRleGVzLmdldChub2RlKTtcbiAgICBpZiAoaW5kZXhlcykge1xuICAgICAgZm9yIChsZXQgayA9IDA7IGsgPCBpbmRleGVzLmxlbmd0aDsgaysrKSB7XG4gICAgICAgIGNvbnN0IGluZGV4ID0gaW5kZXhlc1trXTtcbiAgICAgICAgY29uc3QgdG9rID0gdGhpcy5fdG9rZW5zW2luZGV4XTtcbiAgICAgICAgaWYgKGNvbmRpdGlvbih0b2ssIGluZGV4KSkgcmV0dXJuIHRvaztcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgZmluZExhc3RJbmRleChub2RlLCBjb25kaXRpb24pIHtcbiAgICBjb25zdCBpbmRleGVzID0gdGhpcy5fbm9kZXNUb1Rva2VuSW5kZXhlcy5nZXQobm9kZSk7XG4gICAgaWYgKGluZGV4ZXMpIHtcbiAgICAgIGZvciAobGV0IGsgPSBpbmRleGVzLmxlbmd0aCAtIDE7IGsgPj0gMDsgay0tKSB7XG4gICAgICAgIGNvbnN0IGluZGV4ID0gaW5kZXhlc1trXTtcbiAgICAgICAgY29uc3QgdG9rID0gdGhpcy5fdG9rZW5zW2luZGV4XTtcbiAgICAgICAgaWYgKGNvbmRpdGlvbih0b2ssIGluZGV4KSkgcmV0dXJuIGluZGV4O1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gLTE7XG4gIH1cbiAgZmluZE1hdGNoaW5nKG5vZGUsIHRlc3QsIG9jY3VycmVuY2VDb3VudCA9IDApIHtcbiAgICBjb25zdCBpbmRleGVzID0gdGhpcy5fbm9kZXNUb1Rva2VuSW5kZXhlcy5nZXQobm9kZSk7XG4gICAgaWYgKGluZGV4ZXMpIHtcbiAgICAgIGxldCBpID0gMDtcbiAgICAgIGNvbnN0IGNvdW50ID0gb2NjdXJyZW5jZUNvdW50O1xuICAgICAgaWYgKGNvdW50ID4gMSkge1xuICAgICAgICBjb25zdCBjYWNoZSA9IHRoaXMuX25vZGVzT2NjdXJyZW5jZXNDb3VudENhY2hlLmdldChub2RlKTtcbiAgICAgICAgaWYgKChjYWNoZSA9PSBudWxsID8gdm9pZCAwIDogY2FjaGUudGVzdCkgPT09IHRlc3QgJiYgY2FjaGUuY291bnQgPCBjb3VudCkge1xuICAgICAgICAgIGkgPSBjYWNoZS5pICsgMTtcbiAgICAgICAgICBvY2N1cnJlbmNlQ291bnQgLT0gY2FjaGUuY291bnQgKyAxO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBmb3IgKDsgaSA8IGluZGV4ZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY29uc3QgdG9rID0gdGhpcy5fdG9rZW5zW2luZGV4ZXNbaV1dO1xuICAgICAgICBpZiAodGhpcy5tYXRjaGVzT3JpZ2luYWwodG9rLCB0ZXN0KSkge1xuICAgICAgICAgIGlmIChvY2N1cnJlbmNlQ291bnQgPT09IDApIHtcbiAgICAgICAgICAgIGlmIChjb3VudCA+IDApIHtcbiAgICAgICAgICAgICAgdGhpcy5fbm9kZXNPY2N1cnJlbmNlc0NvdW50Q2FjaGUuc2V0KG5vZGUsIHtcbiAgICAgICAgICAgICAgICB0ZXN0LFxuICAgICAgICAgICAgICAgIGNvdW50LFxuICAgICAgICAgICAgICAgIGlcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdG9rO1xuICAgICAgICAgIH1cbiAgICAgICAgICBvY2N1cnJlbmNlQ291bnQtLTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICBtYXRjaGVzT3JpZ2luYWwodG9rZW4sIHRlc3QpIHtcbiAgICBpZiAodG9rZW4uZW5kIC0gdG9rZW4uc3RhcnQgIT09IHRlc3QubGVuZ3RoKSByZXR1cm4gZmFsc2U7XG4gICAgaWYgKHRva2VuLnZhbHVlICE9IG51bGwpIHJldHVybiB0b2tlbi52YWx1ZSA9PT0gdGVzdDtcbiAgICByZXR1cm4gdGhpcy5fc291cmNlLnN0YXJ0c1dpdGgodGVzdCwgdG9rZW4uc3RhcnQpO1xuICB9XG4gIHN0YXJ0TWF0Y2hlcyhub2RlLCB0ZXN0KSB7XG4gICAgY29uc3QgaW5kZXhlcyA9IHRoaXMuX25vZGVzVG9Ub2tlbkluZGV4ZXMuZ2V0KG5vZGUpO1xuICAgIGlmICghaW5kZXhlcykgcmV0dXJuIGZhbHNlO1xuICAgIGNvbnN0IHRvayA9IHRoaXMuX3Rva2Vuc1tpbmRleGVzWzBdXTtcbiAgICBpZiAodG9rLnN0YXJ0ICE9PSBub2RlLnN0YXJ0KSByZXR1cm4gZmFsc2U7XG4gICAgcmV0dXJuIHRoaXMubWF0Y2hlc09yaWdpbmFsKHRvaywgdGVzdCk7XG4gIH1cbiAgZW5kTWF0Y2hlcyhub2RlLCB0ZXN0KSB7XG4gICAgY29uc3QgaW5kZXhlcyA9IHRoaXMuX25vZGVzVG9Ub2tlbkluZGV4ZXMuZ2V0KG5vZGUpO1xuICAgIGlmICghaW5kZXhlcykgcmV0dXJuIGZhbHNlO1xuICAgIGNvbnN0IHRvayA9IHRoaXMuX3Rva2Vuc1tpbmRleGVzW2luZGV4ZXMubGVuZ3RoIC0gMV1dO1xuICAgIGlmICh0b2suZW5kICE9PSBub2RlLmVuZCkgcmV0dXJuIGZhbHNlO1xuICAgIHJldHVybiB0aGlzLm1hdGNoZXNPcmlnaW5hbCh0b2ssIHRlc3QpO1xuICB9XG4gIF9nZXRUb2tlbnNJbmRleGVzT2ZOb2RlKG5vZGUpIHtcbiAgICB2YXIgX25vZGUkZGVjbGFyYXRpb247XG4gICAgaWYgKG5vZGUuc3RhcnQgPT0gbnVsbCB8fCBub2RlLmVuZCA9PSBudWxsKSByZXR1cm4gW107XG4gICAgY29uc3Qge1xuICAgICAgZmlyc3QsXG4gICAgICBsYXN0XG4gICAgfSA9IHRoaXMuX2ZpbmRUb2tlbnNPZk5vZGUobm9kZSwgMCwgdGhpcy5fdG9rZW5zLmxlbmd0aCAtIDEpO1xuICAgIGxldCBsb3cgPSBmaXJzdDtcbiAgICBjb25zdCBjaGlsZHJlbiA9IGNoaWxkcmVuSXRlcmF0b3Iobm9kZSk7XG4gICAgaWYgKChub2RlLnR5cGUgPT09IFwiRXhwb3J0TmFtZWREZWNsYXJhdGlvblwiIHx8IG5vZGUudHlwZSA9PT0gXCJFeHBvcnREZWZhdWx0RGVjbGFyYXRpb25cIikgJiYgKChfbm9kZSRkZWNsYXJhdGlvbiA9IG5vZGUuZGVjbGFyYXRpb24pID09IG51bGwgPyB2b2lkIDAgOiBfbm9kZSRkZWNsYXJhdGlvbi50eXBlKSA9PT0gXCJDbGFzc0RlY2xhcmF0aW9uXCIpIHtcbiAgICAgIGNoaWxkcmVuLm5leHQoKTtcbiAgICB9XG4gICAgY29uc3QgaW5kZXhlcyA9IFtdO1xuICAgIGZvciAoY29uc3QgY2hpbGQgb2YgY2hpbGRyZW4pIHtcbiAgICAgIGlmIChjaGlsZCA9PSBudWxsKSBjb250aW51ZTtcbiAgICAgIGlmIChjaGlsZC5zdGFydCA9PSBudWxsIHx8IGNoaWxkLmVuZCA9PSBudWxsKSBjb250aW51ZTtcbiAgICAgIGNvbnN0IGNoaWxkVG9rID0gdGhpcy5fZmluZFRva2Vuc09mTm9kZShjaGlsZCwgbG93LCBsYXN0KTtcbiAgICAgIGNvbnN0IGhpZ2ggPSBjaGlsZFRvay5maXJzdDtcbiAgICAgIGZvciAobGV0IGsgPSBsb3c7IGsgPCBoaWdoOyBrKyspIGluZGV4ZXMucHVzaChrKTtcbiAgICAgIGxvdyA9IGNoaWxkVG9rLmxhc3QgKyAxO1xuICAgIH1cbiAgICBmb3IgKGxldCBrID0gbG93OyBrIDw9IGxhc3Q7IGsrKykgaW5kZXhlcy5wdXNoKGspO1xuICAgIHJldHVybiBpbmRleGVzO1xuICB9XG4gIF9maW5kVG9rZW5zT2ZOb2RlKG5vZGUsIGxvdywgaGlnaCkge1xuICAgIGNvbnN0IGNhY2hlZCA9IHRoaXMuX3Rva2Vuc0NhY2hlLmdldChub2RlKTtcbiAgICBpZiAoY2FjaGVkKSByZXR1cm4gY2FjaGVkO1xuICAgIGNvbnN0IGZpcnN0ID0gdGhpcy5fZmluZEZpcnN0VG9rZW5PZk5vZGUobm9kZS5zdGFydCwgbG93LCBoaWdoKTtcbiAgICBjb25zdCBsYXN0ID0gdGhpcy5fZmluZExhc3RUb2tlbk9mTm9kZShub2RlLmVuZCwgZmlyc3QsIGhpZ2gpO1xuICAgIHRoaXMuX3Rva2Vuc0NhY2hlLnNldChub2RlLCB7XG4gICAgICBmaXJzdCxcbiAgICAgIGxhc3RcbiAgICB9KTtcbiAgICByZXR1cm4ge1xuICAgICAgZmlyc3QsXG4gICAgICBsYXN0XG4gICAgfTtcbiAgfVxuICBfZmluZEZpcnN0VG9rZW5PZk5vZGUoc3RhcnQsIGxvdywgaGlnaCkge1xuICAgIHdoaWxlIChsb3cgPD0gaGlnaCkge1xuICAgICAgY29uc3QgbWlkID0gaGlnaCArIGxvdyA+PiAxO1xuICAgICAgaWYgKHN0YXJ0IDwgdGhpcy5fdG9rZW5zW21pZF0uc3RhcnQpIHtcbiAgICAgICAgaGlnaCA9IG1pZCAtIDE7XG4gICAgICB9IGVsc2UgaWYgKHN0YXJ0ID4gdGhpcy5fdG9rZW5zW21pZF0uc3RhcnQpIHtcbiAgICAgICAgbG93ID0gbWlkICsgMTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBtaWQ7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBsb3c7XG4gIH1cbiAgX2ZpbmRMYXN0VG9rZW5PZk5vZGUoZW5kLCBsb3csIGhpZ2gpIHtcbiAgICB3aGlsZSAobG93IDw9IGhpZ2gpIHtcbiAgICAgIGNvbnN0IG1pZCA9IGhpZ2ggKyBsb3cgPj4gMTtcbiAgICAgIGlmIChlbmQgPCB0aGlzLl90b2tlbnNbbWlkXS5lbmQpIHtcbiAgICAgICAgaGlnaCA9IG1pZCAtIDE7XG4gICAgICB9IGVsc2UgaWYgKGVuZCA+IHRoaXMuX3Rva2Vuc1ttaWRdLmVuZCkge1xuICAgICAgICBsb3cgPSBtaWQgKyAxO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIG1pZDtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGhpZ2g7XG4gIH1cbn1cbmV4cG9ydHMuVG9rZW5NYXAgPSBUb2tlbk1hcDtcbmZ1bmN0aW9uKiBjaGlsZHJlbkl0ZXJhdG9yKG5vZGUpIHtcbiAgaWYgKG5vZGUudHlwZSA9PT0gXCJUZW1wbGF0ZUxpdGVyYWxcIikge1xuICAgIHlpZWxkIG5vZGUucXVhc2lzWzBdO1xuICAgIGZvciAobGV0IGkgPSAxOyBpIDwgbm9kZS5xdWFzaXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHlpZWxkIG5vZGUuZXhwcmVzc2lvbnNbaSAtIDFdO1xuICAgICAgeWllbGQgbm9kZS5xdWFzaXNbaV07XG4gICAgfVxuICAgIHJldHVybjtcbiAgfVxuICBjb25zdCBrZXlzID0gVklTSVRPUl9LRVlTW25vZGUudHlwZV07XG4gIGZvciAoY29uc3Qga2V5IG9mIGtleXMpIHtcbiAgICBjb25zdCBjaGlsZCA9IG5vZGVba2V5XTtcbiAgICBpZiAoIWNoaWxkKSBjb250aW51ZTtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShjaGlsZCkpIHtcbiAgICAgIHlpZWxkKiBjaGlsZDtcbiAgICB9IGVsc2Uge1xuICAgICAgeWllbGQgY2hpbGQ7XG4gICAgfVxuICB9XG59XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXRva2VuLW1hcC5qcy5tYXBcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@babel/generator/lib/token-map.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@babel/helper-string-parser/lib/index.js":
/*!***************************************************************!*\
  !*** ./node_modules/@babel/helper-string-parser/lib/index.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports.readCodePoint = readCodePoint;\nexports.readInt = readInt;\nexports.readStringContents = readStringContents;\nvar _isDigit = function isDigit(code) {\n  return code >= 48 && code <= 57;\n};\nconst forbiddenNumericSeparatorSiblings = {\n  decBinOct: new Set([46, 66, 69, 79, 95, 98, 101, 111]),\n  hex: new Set([46, 88, 95, 120])\n};\nconst isAllowedNumericSeparatorSibling = {\n  bin: ch => ch === 48 || ch === 49,\n  oct: ch => ch >= 48 && ch <= 55,\n  dec: ch => ch >= 48 && ch <= 57,\n  hex: ch => ch >= 48 && ch <= 57 || ch >= 65 && ch <= 70 || ch >= 97 && ch <= 102\n};\nfunction readStringContents(type, input, pos, lineStart, curLine, errors) {\n  const initialPos = pos;\n  const initialLineStart = lineStart;\n  const initialCurLine = curLine;\n  let out = \"\";\n  let firstInvalidLoc = null;\n  let chunkStart = pos;\n  const {\n    length\n  } = input;\n  for (;;) {\n    if (pos >= length) {\n      errors.unterminated(initialPos, initialLineStart, initialCurLine);\n      out += input.slice(chunkStart, pos);\n      break;\n    }\n    const ch = input.charCodeAt(pos);\n    if (isStringEnd(type, ch, input, pos)) {\n      out += input.slice(chunkStart, pos);\n      break;\n    }\n    if (ch === 92) {\n      out += input.slice(chunkStart, pos);\n      const res = readEscapedChar(input, pos, lineStart, curLine, type === \"template\", errors);\n      if (res.ch === null && !firstInvalidLoc) {\n        firstInvalidLoc = {\n          pos,\n          lineStart,\n          curLine\n        };\n      } else {\n        out += res.ch;\n      }\n      ({\n        pos,\n        lineStart,\n        curLine\n      } = res);\n      chunkStart = pos;\n    } else if (ch === 8232 || ch === 8233) {\n      ++pos;\n      ++curLine;\n      lineStart = pos;\n    } else if (ch === 10 || ch === 13) {\n      if (type === \"template\") {\n        out += input.slice(chunkStart, pos) + \"\\n\";\n        ++pos;\n        if (ch === 13 && input.charCodeAt(pos) === 10) {\n          ++pos;\n        }\n        ++curLine;\n        chunkStart = lineStart = pos;\n      } else {\n        errors.unterminated(initialPos, initialLineStart, initialCurLine);\n      }\n    } else {\n      ++pos;\n    }\n  }\n  return {\n    pos,\n    str: out,\n    firstInvalidLoc,\n    lineStart,\n    curLine,\n    containsInvalid: !!firstInvalidLoc\n  };\n}\nfunction isStringEnd(type, ch, input, pos) {\n  if (type === \"template\") {\n    return ch === 96 || ch === 36 && input.charCodeAt(pos + 1) === 123;\n  }\n  return ch === (type === \"double\" ? 34 : 39);\n}\nfunction readEscapedChar(input, pos, lineStart, curLine, inTemplate, errors) {\n  const throwOnInvalid = !inTemplate;\n  pos++;\n  const res = ch => ({\n    pos,\n    ch,\n    lineStart,\n    curLine\n  });\n  const ch = input.charCodeAt(pos++);\n  switch (ch) {\n    case 110:\n      return res(\"\\n\");\n    case 114:\n      return res(\"\\r\");\n    case 120:\n      {\n        let code;\n        ({\n          code,\n          pos\n        } = readHexChar(input, pos, lineStart, curLine, 2, false, throwOnInvalid, errors));\n        return res(code === null ? null : String.fromCharCode(code));\n      }\n    case 117:\n      {\n        let code;\n        ({\n          code,\n          pos\n        } = readCodePoint(input, pos, lineStart, curLine, throwOnInvalid, errors));\n        return res(code === null ? null : String.fromCodePoint(code));\n      }\n    case 116:\n      return res(\"\\t\");\n    case 98:\n      return res(\"\\b\");\n    case 118:\n      return res(\"\\u000b\");\n    case 102:\n      return res(\"\\f\");\n    case 13:\n      if (input.charCodeAt(pos) === 10) {\n        ++pos;\n      }\n    case 10:\n      lineStart = pos;\n      ++curLine;\n    case 8232:\n    case 8233:\n      return res(\"\");\n    case 56:\n    case 57:\n      if (inTemplate) {\n        return res(null);\n      } else {\n        errors.strictNumericEscape(pos - 1, lineStart, curLine);\n      }\n    default:\n      if (ch >= 48 && ch <= 55) {\n        const startPos = pos - 1;\n        const match = /^[0-7]+/.exec(input.slice(startPos, pos + 2));\n        let octalStr = match[0];\n        let octal = parseInt(octalStr, 8);\n        if (octal > 255) {\n          octalStr = octalStr.slice(0, -1);\n          octal = parseInt(octalStr, 8);\n        }\n        pos += octalStr.length - 1;\n        const next = input.charCodeAt(pos);\n        if (octalStr !== \"0\" || next === 56 || next === 57) {\n          if (inTemplate) {\n            return res(null);\n          } else {\n            errors.strictNumericEscape(startPos, lineStart, curLine);\n          }\n        }\n        return res(String.fromCharCode(octal));\n      }\n      return res(String.fromCharCode(ch));\n  }\n}\nfunction readHexChar(input, pos, lineStart, curLine, len, forceLen, throwOnInvalid, errors) {\n  const initialPos = pos;\n  let n;\n  ({\n    n,\n    pos\n  } = readInt(input, pos, lineStart, curLine, 16, len, forceLen, false, errors, !throwOnInvalid));\n  if (n === null) {\n    if (throwOnInvalid) {\n      errors.invalidEscapeSequence(initialPos, lineStart, curLine);\n    } else {\n      pos = initialPos - 1;\n    }\n  }\n  return {\n    code: n,\n    pos\n  };\n}\nfunction readInt(input, pos, lineStart, curLine, radix, len, forceLen, allowNumSeparator, errors, bailOnError) {\n  const start = pos;\n  const forbiddenSiblings = radix === 16 ? forbiddenNumericSeparatorSiblings.hex : forbiddenNumericSeparatorSiblings.decBinOct;\n  const isAllowedSibling = radix === 16 ? isAllowedNumericSeparatorSibling.hex : radix === 10 ? isAllowedNumericSeparatorSibling.dec : radix === 8 ? isAllowedNumericSeparatorSibling.oct : isAllowedNumericSeparatorSibling.bin;\n  let invalid = false;\n  let total = 0;\n  for (let i = 0, e = len == null ? Infinity : len; i < e; ++i) {\n    const code = input.charCodeAt(pos);\n    let val;\n    if (code === 95 && allowNumSeparator !== \"bail\") {\n      const prev = input.charCodeAt(pos - 1);\n      const next = input.charCodeAt(pos + 1);\n      if (!allowNumSeparator) {\n        if (bailOnError) return {\n          n: null,\n          pos\n        };\n        errors.numericSeparatorInEscapeSequence(pos, lineStart, curLine);\n      } else if (Number.isNaN(next) || !isAllowedSibling(next) || forbiddenSiblings.has(prev) || forbiddenSiblings.has(next)) {\n        if (bailOnError) return {\n          n: null,\n          pos\n        };\n        errors.unexpectedNumericSeparator(pos, lineStart, curLine);\n      }\n      ++pos;\n      continue;\n    }\n    if (code >= 97) {\n      val = code - 97 + 10;\n    } else if (code >= 65) {\n      val = code - 65 + 10;\n    } else if (_isDigit(code)) {\n      val = code - 48;\n    } else {\n      val = Infinity;\n    }\n    if (val >= radix) {\n      if (val <= 9 && bailOnError) {\n        return {\n          n: null,\n          pos\n        };\n      } else if (val <= 9 && errors.invalidDigit(pos, lineStart, curLine, radix)) {\n        val = 0;\n      } else if (forceLen) {\n        val = 0;\n        invalid = true;\n      } else {\n        break;\n      }\n    }\n    ++pos;\n    total = total * radix + val;\n  }\n  if (pos === start || len != null && pos - start !== len || invalid) {\n    return {\n      n: null,\n      pos\n    };\n  }\n  return {\n    n: total,\n    pos\n  };\n}\nfunction readCodePoint(input, pos, lineStart, curLine, throwOnInvalid, errors) {\n  const ch = input.charCodeAt(pos);\n  let code;\n  if (ch === 123) {\n    ++pos;\n    ({\n      code,\n      pos\n    } = readHexChar(input, pos, lineStart, curLine, input.indexOf(\"}\", pos) - pos, true, throwOnInvalid, errors));\n    ++pos;\n    if (code !== null && code > 0x10ffff) {\n      if (throwOnInvalid) {\n        errors.invalidCodePoint(pos, lineStart, curLine);\n      } else {\n        return {\n          code: null,\n          pos\n        };\n      }\n    }\n  } else {\n    ({\n      code,\n      pos\n    } = readHexChar(input, pos, lineStart, curLine, 4, false, throwOnInvalid, errors));\n  }\n  return {\n    code,\n    pos\n  };\n}\n\n//# sourceMappingURL=index.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGJhYmVsL2hlbHBlci1zdHJpbmctcGFyc2VyL2xpYi9pbmRleC5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYiw4Q0FBNkM7QUFDN0M7QUFDQSxDQUFDLEVBQUM7QUFDRixxQkFBcUI7QUFDckIsZUFBZTtBQUNmLDBCQUEwQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0RBQW9ELE9BQU87QUFDM0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU0sOERBQThEO0FBQ3BFO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcmVwby12aXN1YWxpemVyLy4vbm9kZV9tb2R1bGVzL0BiYWJlbC9oZWxwZXItc3RyaW5nLXBhcnNlci9saWIvaW5kZXguanM/YTQ2YSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMucmVhZENvZGVQb2ludCA9IHJlYWRDb2RlUG9pbnQ7XG5leHBvcnRzLnJlYWRJbnQgPSByZWFkSW50O1xuZXhwb3J0cy5yZWFkU3RyaW5nQ29udGVudHMgPSByZWFkU3RyaW5nQ29udGVudHM7XG52YXIgX2lzRGlnaXQgPSBmdW5jdGlvbiBpc0RpZ2l0KGNvZGUpIHtcbiAgcmV0dXJuIGNvZGUgPj0gNDggJiYgY29kZSA8PSA1Nztcbn07XG5jb25zdCBmb3JiaWRkZW5OdW1lcmljU2VwYXJhdG9yU2libGluZ3MgPSB7XG4gIGRlY0Jpbk9jdDogbmV3IFNldChbNDYsIDY2LCA2OSwgNzksIDk1LCA5OCwgMTAxLCAxMTFdKSxcbiAgaGV4OiBuZXcgU2V0KFs0NiwgODgsIDk1LCAxMjBdKVxufTtcbmNvbnN0IGlzQWxsb3dlZE51bWVyaWNTZXBhcmF0b3JTaWJsaW5nID0ge1xuICBiaW46IGNoID0+IGNoID09PSA0OCB8fCBjaCA9PT0gNDksXG4gIG9jdDogY2ggPT4gY2ggPj0gNDggJiYgY2ggPD0gNTUsXG4gIGRlYzogY2ggPT4gY2ggPj0gNDggJiYgY2ggPD0gNTcsXG4gIGhleDogY2ggPT4gY2ggPj0gNDggJiYgY2ggPD0gNTcgfHwgY2ggPj0gNjUgJiYgY2ggPD0gNzAgfHwgY2ggPj0gOTcgJiYgY2ggPD0gMTAyXG59O1xuZnVuY3Rpb24gcmVhZFN0cmluZ0NvbnRlbnRzKHR5cGUsIGlucHV0LCBwb3MsIGxpbmVTdGFydCwgY3VyTGluZSwgZXJyb3JzKSB7XG4gIGNvbnN0IGluaXRpYWxQb3MgPSBwb3M7XG4gIGNvbnN0IGluaXRpYWxMaW5lU3RhcnQgPSBsaW5lU3RhcnQ7XG4gIGNvbnN0IGluaXRpYWxDdXJMaW5lID0gY3VyTGluZTtcbiAgbGV0IG91dCA9IFwiXCI7XG4gIGxldCBmaXJzdEludmFsaWRMb2MgPSBudWxsO1xuICBsZXQgY2h1bmtTdGFydCA9IHBvcztcbiAgY29uc3Qge1xuICAgIGxlbmd0aFxuICB9ID0gaW5wdXQ7XG4gIGZvciAoOzspIHtcbiAgICBpZiAocG9zID49IGxlbmd0aCkge1xuICAgICAgZXJyb3JzLnVudGVybWluYXRlZChpbml0aWFsUG9zLCBpbml0aWFsTGluZVN0YXJ0LCBpbml0aWFsQ3VyTGluZSk7XG4gICAgICBvdXQgKz0gaW5wdXQuc2xpY2UoY2h1bmtTdGFydCwgcG9zKTtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBjb25zdCBjaCA9IGlucHV0LmNoYXJDb2RlQXQocG9zKTtcbiAgICBpZiAoaXNTdHJpbmdFbmQodHlwZSwgY2gsIGlucHV0LCBwb3MpKSB7XG4gICAgICBvdXQgKz0gaW5wdXQuc2xpY2UoY2h1bmtTdGFydCwgcG9zKTtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBpZiAoY2ggPT09IDkyKSB7XG4gICAgICBvdXQgKz0gaW5wdXQuc2xpY2UoY2h1bmtTdGFydCwgcG9zKTtcbiAgICAgIGNvbnN0IHJlcyA9IHJlYWRFc2NhcGVkQ2hhcihpbnB1dCwgcG9zLCBsaW5lU3RhcnQsIGN1ckxpbmUsIHR5cGUgPT09IFwidGVtcGxhdGVcIiwgZXJyb3JzKTtcbiAgICAgIGlmIChyZXMuY2ggPT09IG51bGwgJiYgIWZpcnN0SW52YWxpZExvYykge1xuICAgICAgICBmaXJzdEludmFsaWRMb2MgPSB7XG4gICAgICAgICAgcG9zLFxuICAgICAgICAgIGxpbmVTdGFydCxcbiAgICAgICAgICBjdXJMaW5lXG4gICAgICAgIH07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBvdXQgKz0gcmVzLmNoO1xuICAgICAgfVxuICAgICAgKHtcbiAgICAgICAgcG9zLFxuICAgICAgICBsaW5lU3RhcnQsXG4gICAgICAgIGN1ckxpbmVcbiAgICAgIH0gPSByZXMpO1xuICAgICAgY2h1bmtTdGFydCA9IHBvcztcbiAgICB9IGVsc2UgaWYgKGNoID09PSA4MjMyIHx8IGNoID09PSA4MjMzKSB7XG4gICAgICArK3BvcztcbiAgICAgICsrY3VyTGluZTtcbiAgICAgIGxpbmVTdGFydCA9IHBvcztcbiAgICB9IGVsc2UgaWYgKGNoID09PSAxMCB8fCBjaCA9PT0gMTMpIHtcbiAgICAgIGlmICh0eXBlID09PSBcInRlbXBsYXRlXCIpIHtcbiAgICAgICAgb3V0ICs9IGlucHV0LnNsaWNlKGNodW5rU3RhcnQsIHBvcykgKyBcIlxcblwiO1xuICAgICAgICArK3BvcztcbiAgICAgICAgaWYgKGNoID09PSAxMyAmJiBpbnB1dC5jaGFyQ29kZUF0KHBvcykgPT09IDEwKSB7XG4gICAgICAgICAgKytwb3M7XG4gICAgICAgIH1cbiAgICAgICAgKytjdXJMaW5lO1xuICAgICAgICBjaHVua1N0YXJ0ID0gbGluZVN0YXJ0ID0gcG9zO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZXJyb3JzLnVudGVybWluYXRlZChpbml0aWFsUG9zLCBpbml0aWFsTGluZVN0YXJ0LCBpbml0aWFsQ3VyTGluZSk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgICsrcG9zO1xuICAgIH1cbiAgfVxuICByZXR1cm4ge1xuICAgIHBvcyxcbiAgICBzdHI6IG91dCxcbiAgICBmaXJzdEludmFsaWRMb2MsXG4gICAgbGluZVN0YXJ0LFxuICAgIGN1ckxpbmUsXG4gICAgY29udGFpbnNJbnZhbGlkOiAhIWZpcnN0SW52YWxpZExvY1xuICB9O1xufVxuZnVuY3Rpb24gaXNTdHJpbmdFbmQodHlwZSwgY2gsIGlucHV0LCBwb3MpIHtcbiAgaWYgKHR5cGUgPT09IFwidGVtcGxhdGVcIikge1xuICAgIHJldHVybiBjaCA9PT0gOTYgfHwgY2ggPT09IDM2ICYmIGlucHV0LmNoYXJDb2RlQXQocG9zICsgMSkgPT09IDEyMztcbiAgfVxuICByZXR1cm4gY2ggPT09ICh0eXBlID09PSBcImRvdWJsZVwiID8gMzQgOiAzOSk7XG59XG5mdW5jdGlvbiByZWFkRXNjYXBlZENoYXIoaW5wdXQsIHBvcywgbGluZVN0YXJ0LCBjdXJMaW5lLCBpblRlbXBsYXRlLCBlcnJvcnMpIHtcbiAgY29uc3QgdGhyb3dPbkludmFsaWQgPSAhaW5UZW1wbGF0ZTtcbiAgcG9zKys7XG4gIGNvbnN0IHJlcyA9IGNoID0+ICh7XG4gICAgcG9zLFxuICAgIGNoLFxuICAgIGxpbmVTdGFydCxcbiAgICBjdXJMaW5lXG4gIH0pO1xuICBjb25zdCBjaCA9IGlucHV0LmNoYXJDb2RlQXQocG9zKyspO1xuICBzd2l0Y2ggKGNoKSB7XG4gICAgY2FzZSAxMTA6XG4gICAgICByZXR1cm4gcmVzKFwiXFxuXCIpO1xuICAgIGNhc2UgMTE0OlxuICAgICAgcmV0dXJuIHJlcyhcIlxcclwiKTtcbiAgICBjYXNlIDEyMDpcbiAgICAgIHtcbiAgICAgICAgbGV0IGNvZGU7XG4gICAgICAgICh7XG4gICAgICAgICAgY29kZSxcbiAgICAgICAgICBwb3NcbiAgICAgICAgfSA9IHJlYWRIZXhDaGFyKGlucHV0LCBwb3MsIGxpbmVTdGFydCwgY3VyTGluZSwgMiwgZmFsc2UsIHRocm93T25JbnZhbGlkLCBlcnJvcnMpKTtcbiAgICAgICAgcmV0dXJuIHJlcyhjb2RlID09PSBudWxsID8gbnVsbCA6IFN0cmluZy5mcm9tQ2hhckNvZGUoY29kZSkpO1xuICAgICAgfVxuICAgIGNhc2UgMTE3OlxuICAgICAge1xuICAgICAgICBsZXQgY29kZTtcbiAgICAgICAgKHtcbiAgICAgICAgICBjb2RlLFxuICAgICAgICAgIHBvc1xuICAgICAgICB9ID0gcmVhZENvZGVQb2ludChpbnB1dCwgcG9zLCBsaW5lU3RhcnQsIGN1ckxpbmUsIHRocm93T25JbnZhbGlkLCBlcnJvcnMpKTtcbiAgICAgICAgcmV0dXJuIHJlcyhjb2RlID09PSBudWxsID8gbnVsbCA6IFN0cmluZy5mcm9tQ29kZVBvaW50KGNvZGUpKTtcbiAgICAgIH1cbiAgICBjYXNlIDExNjpcbiAgICAgIHJldHVybiByZXMoXCJcXHRcIik7XG4gICAgY2FzZSA5ODpcbiAgICAgIHJldHVybiByZXMoXCJcXGJcIik7XG4gICAgY2FzZSAxMTg6XG4gICAgICByZXR1cm4gcmVzKFwiXFx1MDAwYlwiKTtcbiAgICBjYXNlIDEwMjpcbiAgICAgIHJldHVybiByZXMoXCJcXGZcIik7XG4gICAgY2FzZSAxMzpcbiAgICAgIGlmIChpbnB1dC5jaGFyQ29kZUF0KHBvcykgPT09IDEwKSB7XG4gICAgICAgICsrcG9zO1xuICAgICAgfVxuICAgIGNhc2UgMTA6XG4gICAgICBsaW5lU3RhcnQgPSBwb3M7XG4gICAgICArK2N1ckxpbmU7XG4gICAgY2FzZSA4MjMyOlxuICAgIGNhc2UgODIzMzpcbiAgICAgIHJldHVybiByZXMoXCJcIik7XG4gICAgY2FzZSA1NjpcbiAgICBjYXNlIDU3OlxuICAgICAgaWYgKGluVGVtcGxhdGUpIHtcbiAgICAgICAgcmV0dXJuIHJlcyhudWxsKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGVycm9ycy5zdHJpY3ROdW1lcmljRXNjYXBlKHBvcyAtIDEsIGxpbmVTdGFydCwgY3VyTGluZSk7XG4gICAgICB9XG4gICAgZGVmYXVsdDpcbiAgICAgIGlmIChjaCA+PSA0OCAmJiBjaCA8PSA1NSkge1xuICAgICAgICBjb25zdCBzdGFydFBvcyA9IHBvcyAtIDE7XG4gICAgICAgIGNvbnN0IG1hdGNoID0gL15bMC03XSsvLmV4ZWMoaW5wdXQuc2xpY2Uoc3RhcnRQb3MsIHBvcyArIDIpKTtcbiAgICAgICAgbGV0IG9jdGFsU3RyID0gbWF0Y2hbMF07XG4gICAgICAgIGxldCBvY3RhbCA9IHBhcnNlSW50KG9jdGFsU3RyLCA4KTtcbiAgICAgICAgaWYgKG9jdGFsID4gMjU1KSB7XG4gICAgICAgICAgb2N0YWxTdHIgPSBvY3RhbFN0ci5zbGljZSgwLCAtMSk7XG4gICAgICAgICAgb2N0YWwgPSBwYXJzZUludChvY3RhbFN0ciwgOCk7XG4gICAgICAgIH1cbiAgICAgICAgcG9zICs9IG9jdGFsU3RyLmxlbmd0aCAtIDE7XG4gICAgICAgIGNvbnN0IG5leHQgPSBpbnB1dC5jaGFyQ29kZUF0KHBvcyk7XG4gICAgICAgIGlmIChvY3RhbFN0ciAhPT0gXCIwXCIgfHwgbmV4dCA9PT0gNTYgfHwgbmV4dCA9PT0gNTcpIHtcbiAgICAgICAgICBpZiAoaW5UZW1wbGF0ZSkge1xuICAgICAgICAgICAgcmV0dXJuIHJlcyhudWxsKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZXJyb3JzLnN0cmljdE51bWVyaWNFc2NhcGUoc3RhcnRQb3MsIGxpbmVTdGFydCwgY3VyTGluZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXMoU3RyaW5nLmZyb21DaGFyQ29kZShvY3RhbCkpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJlcyhTdHJpbmcuZnJvbUNoYXJDb2RlKGNoKSk7XG4gIH1cbn1cbmZ1bmN0aW9uIHJlYWRIZXhDaGFyKGlucHV0LCBwb3MsIGxpbmVTdGFydCwgY3VyTGluZSwgbGVuLCBmb3JjZUxlbiwgdGhyb3dPbkludmFsaWQsIGVycm9ycykge1xuICBjb25zdCBpbml0aWFsUG9zID0gcG9zO1xuICBsZXQgbjtcbiAgKHtcbiAgICBuLFxuICAgIHBvc1xuICB9ID0gcmVhZEludChpbnB1dCwgcG9zLCBsaW5lU3RhcnQsIGN1ckxpbmUsIDE2LCBsZW4sIGZvcmNlTGVuLCBmYWxzZSwgZXJyb3JzLCAhdGhyb3dPbkludmFsaWQpKTtcbiAgaWYgKG4gPT09IG51bGwpIHtcbiAgICBpZiAodGhyb3dPbkludmFsaWQpIHtcbiAgICAgIGVycm9ycy5pbnZhbGlkRXNjYXBlU2VxdWVuY2UoaW5pdGlhbFBvcywgbGluZVN0YXJ0LCBjdXJMaW5lKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcG9zID0gaW5pdGlhbFBvcyAtIDE7XG4gICAgfVxuICB9XG4gIHJldHVybiB7XG4gICAgY29kZTogbixcbiAgICBwb3NcbiAgfTtcbn1cbmZ1bmN0aW9uIHJlYWRJbnQoaW5wdXQsIHBvcywgbGluZVN0YXJ0LCBjdXJMaW5lLCByYWRpeCwgbGVuLCBmb3JjZUxlbiwgYWxsb3dOdW1TZXBhcmF0b3IsIGVycm9ycywgYmFpbE9uRXJyb3IpIHtcbiAgY29uc3Qgc3RhcnQgPSBwb3M7XG4gIGNvbnN0IGZvcmJpZGRlblNpYmxpbmdzID0gcmFkaXggPT09IDE2ID8gZm9yYmlkZGVuTnVtZXJpY1NlcGFyYXRvclNpYmxpbmdzLmhleCA6IGZvcmJpZGRlbk51bWVyaWNTZXBhcmF0b3JTaWJsaW5ncy5kZWNCaW5PY3Q7XG4gIGNvbnN0IGlzQWxsb3dlZFNpYmxpbmcgPSByYWRpeCA9PT0gMTYgPyBpc0FsbG93ZWROdW1lcmljU2VwYXJhdG9yU2libGluZy5oZXggOiByYWRpeCA9PT0gMTAgPyBpc0FsbG93ZWROdW1lcmljU2VwYXJhdG9yU2libGluZy5kZWMgOiByYWRpeCA9PT0gOCA/IGlzQWxsb3dlZE51bWVyaWNTZXBhcmF0b3JTaWJsaW5nLm9jdCA6IGlzQWxsb3dlZE51bWVyaWNTZXBhcmF0b3JTaWJsaW5nLmJpbjtcbiAgbGV0IGludmFsaWQgPSBmYWxzZTtcbiAgbGV0IHRvdGFsID0gMDtcbiAgZm9yIChsZXQgaSA9IDAsIGUgPSBsZW4gPT0gbnVsbCA/IEluZmluaXR5IDogbGVuOyBpIDwgZTsgKytpKSB7XG4gICAgY29uc3QgY29kZSA9IGlucHV0LmNoYXJDb2RlQXQocG9zKTtcbiAgICBsZXQgdmFsO1xuICAgIGlmIChjb2RlID09PSA5NSAmJiBhbGxvd051bVNlcGFyYXRvciAhPT0gXCJiYWlsXCIpIHtcbiAgICAgIGNvbnN0IHByZXYgPSBpbnB1dC5jaGFyQ29kZUF0KHBvcyAtIDEpO1xuICAgICAgY29uc3QgbmV4dCA9IGlucHV0LmNoYXJDb2RlQXQocG9zICsgMSk7XG4gICAgICBpZiAoIWFsbG93TnVtU2VwYXJhdG9yKSB7XG4gICAgICAgIGlmIChiYWlsT25FcnJvcikgcmV0dXJuIHtcbiAgICAgICAgICBuOiBudWxsLFxuICAgICAgICAgIHBvc1xuICAgICAgICB9O1xuICAgICAgICBlcnJvcnMubnVtZXJpY1NlcGFyYXRvckluRXNjYXBlU2VxdWVuY2UocG9zLCBsaW5lU3RhcnQsIGN1ckxpbmUpO1xuICAgICAgfSBlbHNlIGlmIChOdW1iZXIuaXNOYU4obmV4dCkgfHwgIWlzQWxsb3dlZFNpYmxpbmcobmV4dCkgfHwgZm9yYmlkZGVuU2libGluZ3MuaGFzKHByZXYpIHx8IGZvcmJpZGRlblNpYmxpbmdzLmhhcyhuZXh0KSkge1xuICAgICAgICBpZiAoYmFpbE9uRXJyb3IpIHJldHVybiB7XG4gICAgICAgICAgbjogbnVsbCxcbiAgICAgICAgICBwb3NcbiAgICAgICAgfTtcbiAgICAgICAgZXJyb3JzLnVuZXhwZWN0ZWROdW1lcmljU2VwYXJhdG9yKHBvcywgbGluZVN0YXJ0LCBjdXJMaW5lKTtcbiAgICAgIH1cbiAgICAgICsrcG9zO1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIGlmIChjb2RlID49IDk3KSB7XG4gICAgICB2YWwgPSBjb2RlIC0gOTcgKyAxMDtcbiAgICB9IGVsc2UgaWYgKGNvZGUgPj0gNjUpIHtcbiAgICAgIHZhbCA9IGNvZGUgLSA2NSArIDEwO1xuICAgIH0gZWxzZSBpZiAoX2lzRGlnaXQoY29kZSkpIHtcbiAgICAgIHZhbCA9IGNvZGUgLSA0ODtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFsID0gSW5maW5pdHk7XG4gICAgfVxuICAgIGlmICh2YWwgPj0gcmFkaXgpIHtcbiAgICAgIGlmICh2YWwgPD0gOSAmJiBiYWlsT25FcnJvcikge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIG46IG51bGwsXG4gICAgICAgICAgcG9zXG4gICAgICAgIH07XG4gICAgICB9IGVsc2UgaWYgKHZhbCA8PSA5ICYmIGVycm9ycy5pbnZhbGlkRGlnaXQocG9zLCBsaW5lU3RhcnQsIGN1ckxpbmUsIHJhZGl4KSkge1xuICAgICAgICB2YWwgPSAwO1xuICAgICAgfSBlbHNlIGlmIChmb3JjZUxlbikge1xuICAgICAgICB2YWwgPSAwO1xuICAgICAgICBpbnZhbGlkID0gdHJ1ZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgICArK3BvcztcbiAgICB0b3RhbCA9IHRvdGFsICogcmFkaXggKyB2YWw7XG4gIH1cbiAgaWYgKHBvcyA9PT0gc3RhcnQgfHwgbGVuICE9IG51bGwgJiYgcG9zIC0gc3RhcnQgIT09IGxlbiB8fCBpbnZhbGlkKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIG46IG51bGwsXG4gICAgICBwb3NcbiAgICB9O1xuICB9XG4gIHJldHVybiB7XG4gICAgbjogdG90YWwsXG4gICAgcG9zXG4gIH07XG59XG5mdW5jdGlvbiByZWFkQ29kZVBvaW50KGlucHV0LCBwb3MsIGxpbmVTdGFydCwgY3VyTGluZSwgdGhyb3dPbkludmFsaWQsIGVycm9ycykge1xuICBjb25zdCBjaCA9IGlucHV0LmNoYXJDb2RlQXQocG9zKTtcbiAgbGV0IGNvZGU7XG4gIGlmIChjaCA9PT0gMTIzKSB7XG4gICAgKytwb3M7XG4gICAgKHtcbiAgICAgIGNvZGUsXG4gICAgICBwb3NcbiAgICB9ID0gcmVhZEhleENoYXIoaW5wdXQsIHBvcywgbGluZVN0YXJ0LCBjdXJMaW5lLCBpbnB1dC5pbmRleE9mKFwifVwiLCBwb3MpIC0gcG9zLCB0cnVlLCB0aHJvd09uSW52YWxpZCwgZXJyb3JzKSk7XG4gICAgKytwb3M7XG4gICAgaWYgKGNvZGUgIT09IG51bGwgJiYgY29kZSA+IDB4MTBmZmZmKSB7XG4gICAgICBpZiAodGhyb3dPbkludmFsaWQpIHtcbiAgICAgICAgZXJyb3JzLmludmFsaWRDb2RlUG9pbnQocG9zLCBsaW5lU3RhcnQsIGN1ckxpbmUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBjb2RlOiBudWxsLFxuICAgICAgICAgIHBvc1xuICAgICAgICB9O1xuICAgICAgfVxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICAoe1xuICAgICAgY29kZSxcbiAgICAgIHBvc1xuICAgIH0gPSByZWFkSGV4Q2hhcihpbnB1dCwgcG9zLCBsaW5lU3RhcnQsIGN1ckxpbmUsIDQsIGZhbHNlLCB0aHJvd09uSW52YWxpZCwgZXJyb3JzKSk7XG4gIH1cbiAgcmV0dXJuIHtcbiAgICBjb2RlLFxuICAgIHBvc1xuICB9O1xufVxuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXBcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@babel/helper-string-parser/lib/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@babel/helper-validator-identifier/lib/identifier.js":
/*!***************************************************************************!*\
  !*** ./node_modules/@babel/helper-validator-identifier/lib/identifier.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports.isIdentifierChar = isIdentifierChar;\nexports.isIdentifierName = isIdentifierName;\nexports.isIdentifierStart = isIdentifierStart;\nlet nonASCIIidentifierStartChars = \"\\xaa\\xb5\\xba\\xc0-\\xd6\\xd8-\\xf6\\xf8-\\u02c1\\u02c6-\\u02d1\\u02e0-\\u02e4\\u02ec\\u02ee\\u0370-\\u0374\\u0376\\u0377\\u037a-\\u037d\\u037f\\u0386\\u0388-\\u038a\\u038c\\u038e-\\u03a1\\u03a3-\\u03f5\\u03f7-\\u0481\\u048a-\\u052f\\u0531-\\u0556\\u0559\\u0560-\\u0588\\u05d0-\\u05ea\\u05ef-\\u05f2\\u0620-\\u064a\\u066e\\u066f\\u0671-\\u06d3\\u06d5\\u06e5\\u06e6\\u06ee\\u06ef\\u06fa-\\u06fc\\u06ff\\u0710\\u0712-\\u072f\\u074d-\\u07a5\\u07b1\\u07ca-\\u07ea\\u07f4\\u07f5\\u07fa\\u0800-\\u0815\\u081a\\u0824\\u0828\\u0840-\\u0858\\u0860-\\u086a\\u0870-\\u0887\\u0889-\\u088f\\u08a0-\\u08c9\\u0904-\\u0939\\u093d\\u0950\\u0958-\\u0961\\u0971-\\u0980\\u0985-\\u098c\\u098f\\u0990\\u0993-\\u09a8\\u09aa-\\u09b0\\u09b2\\u09b6-\\u09b9\\u09bd\\u09ce\\u09dc\\u09dd\\u09df-\\u09e1\\u09f0\\u09f1\\u09fc\\u0a05-\\u0a0a\\u0a0f\\u0a10\\u0a13-\\u0a28\\u0a2a-\\u0a30\\u0a32\\u0a33\\u0a35\\u0a36\\u0a38\\u0a39\\u0a59-\\u0a5c\\u0a5e\\u0a72-\\u0a74\\u0a85-\\u0a8d\\u0a8f-\\u0a91\\u0a93-\\u0aa8\\u0aaa-\\u0ab0\\u0ab2\\u0ab3\\u0ab5-\\u0ab9\\u0abd\\u0ad0\\u0ae0\\u0ae1\\u0af9\\u0b05-\\u0b0c\\u0b0f\\u0b10\\u0b13-\\u0b28\\u0b2a-\\u0b30\\u0b32\\u0b33\\u0b35-\\u0b39\\u0b3d\\u0b5c\\u0b5d\\u0b5f-\\u0b61\\u0b71\\u0b83\\u0b85-\\u0b8a\\u0b8e-\\u0b90\\u0b92-\\u0b95\\u0b99\\u0b9a\\u0b9c\\u0b9e\\u0b9f\\u0ba3\\u0ba4\\u0ba8-\\u0baa\\u0bae-\\u0bb9\\u0bd0\\u0c05-\\u0c0c\\u0c0e-\\u0c10\\u0c12-\\u0c28\\u0c2a-\\u0c39\\u0c3d\\u0c58-\\u0c5a\\u0c5c\\u0c5d\\u0c60\\u0c61\\u0c80\\u0c85-\\u0c8c\\u0c8e-\\u0c90\\u0c92-\\u0ca8\\u0caa-\\u0cb3\\u0cb5-\\u0cb9\\u0cbd\\u0cdc-\\u0cde\\u0ce0\\u0ce1\\u0cf1\\u0cf2\\u0d04-\\u0d0c\\u0d0e-\\u0d10\\u0d12-\\u0d3a\\u0d3d\\u0d4e\\u0d54-\\u0d56\\u0d5f-\\u0d61\\u0d7a-\\u0d7f\\u0d85-\\u0d96\\u0d9a-\\u0db1\\u0db3-\\u0dbb\\u0dbd\\u0dc0-\\u0dc6\\u0e01-\\u0e30\\u0e32\\u0e33\\u0e40-\\u0e46\\u0e81\\u0e82\\u0e84\\u0e86-\\u0e8a\\u0e8c-\\u0ea3\\u0ea5\\u0ea7-\\u0eb0\\u0eb2\\u0eb3\\u0ebd\\u0ec0-\\u0ec4\\u0ec6\\u0edc-\\u0edf\\u0f00\\u0f40-\\u0f47\\u0f49-\\u0f6c\\u0f88-\\u0f8c\\u1000-\\u102a\\u103f\\u1050-\\u1055\\u105a-\\u105d\\u1061\\u1065\\u1066\\u106e-\\u1070\\u1075-\\u1081\\u108e\\u10a0-\\u10c5\\u10c7\\u10cd\\u10d0-\\u10fa\\u10fc-\\u1248\\u124a-\\u124d\\u1250-\\u1256\\u1258\\u125a-\\u125d\\u1260-\\u1288\\u128a-\\u128d\\u1290-\\u12b0\\u12b2-\\u12b5\\u12b8-\\u12be\\u12c0\\u12c2-\\u12c5\\u12c8-\\u12d6\\u12d8-\\u1310\\u1312-\\u1315\\u1318-\\u135a\\u1380-\\u138f\\u13a0-\\u13f5\\u13f8-\\u13fd\\u1401-\\u166c\\u166f-\\u167f\\u1681-\\u169a\\u16a0-\\u16ea\\u16ee-\\u16f8\\u1700-\\u1711\\u171f-\\u1731\\u1740-\\u1751\\u1760-\\u176c\\u176e-\\u1770\\u1780-\\u17b3\\u17d7\\u17dc\\u1820-\\u1878\\u1880-\\u18a8\\u18aa\\u18b0-\\u18f5\\u1900-\\u191e\\u1950-\\u196d\\u1970-\\u1974\\u1980-\\u19ab\\u19b0-\\u19c9\\u1a00-\\u1a16\\u1a20-\\u1a54\\u1aa7\\u1b05-\\u1b33\\u1b45-\\u1b4c\\u1b83-\\u1ba0\\u1bae\\u1baf\\u1bba-\\u1be5\\u1c00-\\u1c23\\u1c4d-\\u1c4f\\u1c5a-\\u1c7d\\u1c80-\\u1c8a\\u1c90-\\u1cba\\u1cbd-\\u1cbf\\u1ce9-\\u1cec\\u1cee-\\u1cf3\\u1cf5\\u1cf6\\u1cfa\\u1d00-\\u1dbf\\u1e00-\\u1f15\\u1f18-\\u1f1d\\u1f20-\\u1f45\\u1f48-\\u1f4d\\u1f50-\\u1f57\\u1f59\\u1f5b\\u1f5d\\u1f5f-\\u1f7d\\u1f80-\\u1fb4\\u1fb6-\\u1fbc\\u1fbe\\u1fc2-\\u1fc4\\u1fc6-\\u1fcc\\u1fd0-\\u1fd3\\u1fd6-\\u1fdb\\u1fe0-\\u1fec\\u1ff2-\\u1ff4\\u1ff6-\\u1ffc\\u2071\\u207f\\u2090-\\u209c\\u2102\\u2107\\u210a-\\u2113\\u2115\\u2118-\\u211d\\u2124\\u2126\\u2128\\u212a-\\u2139\\u213c-\\u213f\\u2145-\\u2149\\u214e\\u2160-\\u2188\\u2c00-\\u2ce4\\u2ceb-\\u2cee\\u2cf2\\u2cf3\\u2d00-\\u2d25\\u2d27\\u2d2d\\u2d30-\\u2d67\\u2d6f\\u2d80-\\u2d96\\u2da0-\\u2da6\\u2da8-\\u2dae\\u2db0-\\u2db6\\u2db8-\\u2dbe\\u2dc0-\\u2dc6\\u2dc8-\\u2dce\\u2dd0-\\u2dd6\\u2dd8-\\u2dde\\u3005-\\u3007\\u3021-\\u3029\\u3031-\\u3035\\u3038-\\u303c\\u3041-\\u3096\\u309b-\\u309f\\u30a1-\\u30fa\\u30fc-\\u30ff\\u3105-\\u312f\\u3131-\\u318e\\u31a0-\\u31bf\\u31f0-\\u31ff\\u3400-\\u4dbf\\u4e00-\\ua48c\\ua4d0-\\ua4fd\\ua500-\\ua60c\\ua610-\\ua61f\\ua62a\\ua62b\\ua640-\\ua66e\\ua67f-\\ua69d\\ua6a0-\\ua6ef\\ua717-\\ua71f\\ua722-\\ua788\\ua78b-\\ua7dc\\ua7f1-\\ua801\\ua803-\\ua805\\ua807-\\ua80a\\ua80c-\\ua822\\ua840-\\ua873\\ua882-\\ua8b3\\ua8f2-\\ua8f7\\ua8fb\\ua8fd\\ua8fe\\ua90a-\\ua925\\ua930-\\ua946\\ua960-\\ua97c\\ua984-\\ua9b2\\ua9cf\\ua9e0-\\ua9e4\\ua9e6-\\ua9ef\\ua9fa-\\ua9fe\\uaa00-\\uaa28\\uaa40-\\uaa42\\uaa44-\\uaa4b\\uaa60-\\uaa76\\uaa7a\\uaa7e-\\uaaaf\\uaab1\\uaab5\\uaab6\\uaab9-\\uaabd\\uaac0\\uaac2\\uaadb-\\uaadd\\uaae0-\\uaaea\\uaaf2-\\uaaf4\\uab01-\\uab06\\uab09-\\uab0e\\uab11-\\uab16\\uab20-\\uab26\\uab28-\\uab2e\\uab30-\\uab5a\\uab5c-\\uab69\\uab70-\\uabe2\\uac00-\\ud7a3\\ud7b0-\\ud7c6\\ud7cb-\\ud7fb\\uf900-\\ufa6d\\ufa70-\\ufad9\\ufb00-\\ufb06\\ufb13-\\ufb17\\ufb1d\\ufb1f-\\ufb28\\ufb2a-\\ufb36\\ufb38-\\ufb3c\\ufb3e\\ufb40\\ufb41\\ufb43\\ufb44\\ufb46-\\ufbb1\\ufbd3-\\ufd3d\\ufd50-\\ufd8f\\ufd92-\\ufdc7\\ufdf0-\\ufdfb\\ufe70-\\ufe74\\ufe76-\\ufefc\\uff21-\\uff3a\\uff41-\\uff5a\\uff66-\\uffbe\\uffc2-\\uffc7\\uffca-\\uffcf\\uffd2-\\uffd7\\uffda-\\uffdc\";\nlet nonASCIIidentifierChars = \"\\xb7\\u0300-\\u036f\\u0387\\u0483-\\u0487\\u0591-\\u05bd\\u05bf\\u05c1\\u05c2\\u05c4\\u05c5\\u05c7\\u0610-\\u061a\\u064b-\\u0669\\u0670\\u06d6-\\u06dc\\u06df-\\u06e4\\u06e7\\u06e8\\u06ea-\\u06ed\\u06f0-\\u06f9\\u0711\\u0730-\\u074a\\u07a6-\\u07b0\\u07c0-\\u07c9\\u07eb-\\u07f3\\u07fd\\u0816-\\u0819\\u081b-\\u0823\\u0825-\\u0827\\u0829-\\u082d\\u0859-\\u085b\\u0897-\\u089f\\u08ca-\\u08e1\\u08e3-\\u0903\\u093a-\\u093c\\u093e-\\u094f\\u0951-\\u0957\\u0962\\u0963\\u0966-\\u096f\\u0981-\\u0983\\u09bc\\u09be-\\u09c4\\u09c7\\u09c8\\u09cb-\\u09cd\\u09d7\\u09e2\\u09e3\\u09e6-\\u09ef\\u09fe\\u0a01-\\u0a03\\u0a3c\\u0a3e-\\u0a42\\u0a47\\u0a48\\u0a4b-\\u0a4d\\u0a51\\u0a66-\\u0a71\\u0a75\\u0a81-\\u0a83\\u0abc\\u0abe-\\u0ac5\\u0ac7-\\u0ac9\\u0acb-\\u0acd\\u0ae2\\u0ae3\\u0ae6-\\u0aef\\u0afa-\\u0aff\\u0b01-\\u0b03\\u0b3c\\u0b3e-\\u0b44\\u0b47\\u0b48\\u0b4b-\\u0b4d\\u0b55-\\u0b57\\u0b62\\u0b63\\u0b66-\\u0b6f\\u0b82\\u0bbe-\\u0bc2\\u0bc6-\\u0bc8\\u0bca-\\u0bcd\\u0bd7\\u0be6-\\u0bef\\u0c00-\\u0c04\\u0c3c\\u0c3e-\\u0c44\\u0c46-\\u0c48\\u0c4a-\\u0c4d\\u0c55\\u0c56\\u0c62\\u0c63\\u0c66-\\u0c6f\\u0c81-\\u0c83\\u0cbc\\u0cbe-\\u0cc4\\u0cc6-\\u0cc8\\u0cca-\\u0ccd\\u0cd5\\u0cd6\\u0ce2\\u0ce3\\u0ce6-\\u0cef\\u0cf3\\u0d00-\\u0d03\\u0d3b\\u0d3c\\u0d3e-\\u0d44\\u0d46-\\u0d48\\u0d4a-\\u0d4d\\u0d57\\u0d62\\u0d63\\u0d66-\\u0d6f\\u0d81-\\u0d83\\u0dca\\u0dcf-\\u0dd4\\u0dd6\\u0dd8-\\u0ddf\\u0de6-\\u0def\\u0df2\\u0df3\\u0e31\\u0e34-\\u0e3a\\u0e47-\\u0e4e\\u0e50-\\u0e59\\u0eb1\\u0eb4-\\u0ebc\\u0ec8-\\u0ece\\u0ed0-\\u0ed9\\u0f18\\u0f19\\u0f20-\\u0f29\\u0f35\\u0f37\\u0f39\\u0f3e\\u0f3f\\u0f71-\\u0f84\\u0f86\\u0f87\\u0f8d-\\u0f97\\u0f99-\\u0fbc\\u0fc6\\u102b-\\u103e\\u1040-\\u1049\\u1056-\\u1059\\u105e-\\u1060\\u1062-\\u1064\\u1067-\\u106d\\u1071-\\u1074\\u1082-\\u108d\\u108f-\\u109d\\u135d-\\u135f\\u1369-\\u1371\\u1712-\\u1715\\u1732-\\u1734\\u1752\\u1753\\u1772\\u1773\\u17b4-\\u17d3\\u17dd\\u17e0-\\u17e9\\u180b-\\u180d\\u180f-\\u1819\\u18a9\\u1920-\\u192b\\u1930-\\u193b\\u1946-\\u194f\\u19d0-\\u19da\\u1a17-\\u1a1b\\u1a55-\\u1a5e\\u1a60-\\u1a7c\\u1a7f-\\u1a89\\u1a90-\\u1a99\\u1ab0-\\u1abd\\u1abf-\\u1add\\u1ae0-\\u1aeb\\u1b00-\\u1b04\\u1b34-\\u1b44\\u1b50-\\u1b59\\u1b6b-\\u1b73\\u1b80-\\u1b82\\u1ba1-\\u1bad\\u1bb0-\\u1bb9\\u1be6-\\u1bf3\\u1c24-\\u1c37\\u1c40-\\u1c49\\u1c50-\\u1c59\\u1cd0-\\u1cd2\\u1cd4-\\u1ce8\\u1ced\\u1cf4\\u1cf7-\\u1cf9\\u1dc0-\\u1dff\\u200c\\u200d\\u203f\\u2040\\u2054\\u20d0-\\u20dc\\u20e1\\u20e5-\\u20f0\\u2cef-\\u2cf1\\u2d7f\\u2de0-\\u2dff\\u302a-\\u302f\\u3099\\u309a\\u30fb\\ua620-\\ua629\\ua66f\\ua674-\\ua67d\\ua69e\\ua69f\\ua6f0\\ua6f1\\ua802\\ua806\\ua80b\\ua823-\\ua827\\ua82c\\ua880\\ua881\\ua8b4-\\ua8c5\\ua8d0-\\ua8d9\\ua8e0-\\ua8f1\\ua8ff-\\ua909\\ua926-\\ua92d\\ua947-\\ua953\\ua980-\\ua983\\ua9b3-\\ua9c0\\ua9d0-\\ua9d9\\ua9e5\\ua9f0-\\ua9f9\\uaa29-\\uaa36\\uaa43\\uaa4c\\uaa4d\\uaa50-\\uaa59\\uaa7b-\\uaa7d\\uaab0\\uaab2-\\uaab4\\uaab7\\uaab8\\uaabe\\uaabf\\uaac1\\uaaeb-\\uaaef\\uaaf5\\uaaf6\\uabe3-\\uabea\\uabec\\uabed\\uabf0-\\uabf9\\ufb1e\\ufe00-\\ufe0f\\ufe20-\\ufe2f\\ufe33\\ufe34\\ufe4d-\\ufe4f\\uff10-\\uff19\\uff3f\\uff65\";\nconst nonASCIIidentifierStart = new RegExp(\"[\" + nonASCIIidentifierStartChars + \"]\");\nconst nonASCIIidentifier = new RegExp(\"[\" + nonASCIIidentifierStartChars + nonASCIIidentifierChars + \"]\");\nnonASCIIidentifierStartChars = nonASCIIidentifierChars = null;\nconst astralIdentifierStartCodes = [0, 11, 2, 25, 2, 18, 2, 1, 2, 14, 3, 13, 35, 122, 70, 52, 268, 28, 4, 48, 48, 31, 14, 29, 6, 37, 11, 29, 3, 35, 5, 7, 2, 4, 43, 157, 19, 35, 5, 35, 5, 39, 9, 51, 13, 10, 2, 14, 2, 6, 2, 1, 2, 10, 2, 14, 2, 6, 2, 1, 4, 51, 13, 310, 10, 21, 11, 7, 25, 5, 2, 41, 2, 8, 70, 5, 3, 0, 2, 43, 2, 1, 4, 0, 3, 22, 11, 22, 10, 30, 66, 18, 2, 1, 11, 21, 11, 25, 7, 25, 39, 55, 7, 1, 65, 0, 16, 3, 2, 2, 2, 28, 43, 28, 4, 28, 36, 7, 2, 27, 28, 53, 11, 21, 11, 18, 14, 17, 111, 72, 56, 50, 14, 50, 14, 35, 39, 27, 10, 22, 251, 41, 7, 1, 17, 5, 57, 28, 11, 0, 9, 21, 43, 17, 47, 20, 28, 22, 13, 52, 58, 1, 3, 0, 14, 44, 33, 24, 27, 35, 30, 0, 3, 0, 9, 34, 4, 0, 13, 47, 15, 3, 22, 0, 2, 0, 36, 17, 2, 24, 20, 1, 64, 6, 2, 0, 2, 3, 2, 14, 2, 9, 8, 46, 39, 7, 3, 1, 3, 21, 2, 6, 2, 1, 2, 4, 4, 0, 19, 0, 13, 4, 31, 9, 2, 0, 3, 0, 2, 37, 2, 0, 26, 0, 2, 0, 45, 52, 19, 3, 21, 2, 31, 47, 21, 1, 2, 0, 185, 46, 42, 3, 37, 47, 21, 0, 60, 42, 14, 0, 72, 26, 38, 6, 186, 43, 117, 63, 32, 7, 3, 0, 3, 7, 2, 1, 2, 23, 16, 0, 2, 0, 95, 7, 3, 38, 17, 0, 2, 0, 29, 0, 11, 39, 8, 0, 22, 0, 12, 45, 20, 0, 19, 72, 200, 32, 32, 8, 2, 36, 18, 0, 50, 29, 113, 6, 2, 1, 2, 37, 22, 0, 26, 5, 2, 1, 2, 31, 15, 0, 24, 43, 261, 18, 16, 0, 2, 12, 2, 33, 125, 0, 80, 921, 103, 110, 18, 195, 2637, 96, 16, 1071, 18, 5, 26, 3994, 6, 582, 6842, 29, 1763, 568, 8, 30, 18, 78, 18, 29, 19, 47, 17, 3, 32, 20, 6, 18, 433, 44, 212, 63, 33, 24, 3, 24, 45, 74, 6, 0, 67, 12, 65, 1, 2, 0, 15, 4, 10, 7381, 42, 31, 98, 114, 8702, 3, 2, 6, 2, 1, 2, 290, 16, 0, 30, 2, 3, 0, 15, 3, 9, 395, 2309, 106, 6, 12, 4, 8, 8, 9, 5991, 84, 2, 70, 2, 1, 3, 0, 3, 1, 3, 3, 2, 11, 2, 0, 2, 6, 2, 64, 2, 3, 3, 7, 2, 6, 2, 27, 2, 3, 2, 4, 2, 0, 4, 6, 2, 339, 3, 24, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 7, 1845, 30, 7, 5, 262, 61, 147, 44, 11, 6, 17, 0, 322, 29, 19, 43, 485, 27, 229, 29, 3, 0, 208, 30, 2, 2, 2, 1, 2, 6, 3, 4, 10, 1, 225, 6, 2, 3, 2, 1, 2, 14, 2, 196, 60, 67, 8, 0, 1205, 3, 2, 26, 2, 1, 2, 0, 3, 0, 2, 9, 2, 3, 2, 0, 2, 0, 7, 0, 5, 0, 2, 0, 2, 0, 2, 2, 2, 1, 2, 0, 3, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 1, 2, 0, 3, 3, 2, 6, 2, 3, 2, 3, 2, 0, 2, 9, 2, 16, 6, 2, 2, 4, 2, 16, 4421, 42719, 33, 4381, 3, 5773, 3, 7472, 16, 621, 2467, 541, 1507, 4938, 6, 8489];\nconst astralIdentifierCodes = [509, 0, 227, 0, 150, 4, 294, 9, 1368, 2, 2, 1, 6, 3, 41, 2, 5, 0, 166, 1, 574, 3, 9, 9, 7, 9, 32, 4, 318, 1, 78, 5, 71, 10, 50, 3, 123, 2, 54, 14, 32, 10, 3, 1, 11, 3, 46, 10, 8, 0, 46, 9, 7, 2, 37, 13, 2, 9, 6, 1, 45, 0, 13, 2, 49, 13, 9, 3, 2, 11, 83, 11, 7, 0, 3, 0, 158, 11, 6, 9, 7, 3, 56, 1, 2, 6, 3, 1, 3, 2, 10, 0, 11, 1, 3, 6, 4, 4, 68, 8, 2, 0, 3, 0, 2, 3, 2, 4, 2, 0, 15, 1, 83, 17, 10, 9, 5, 0, 82, 19, 13, 9, 214, 6, 3, 8, 28, 1, 83, 16, 16, 9, 82, 12, 9, 9, 7, 19, 58, 14, 5, 9, 243, 14, 166, 9, 71, 5, 2, 1, 3, 3, 2, 0, 2, 1, 13, 9, 120, 6, 3, 6, 4, 0, 29, 9, 41, 6, 2, 3, 9, 0, 10, 10, 47, 15, 199, 7, 137, 9, 54, 7, 2, 7, 17, 9, 57, 21, 2, 13, 123, 5, 4, 0, 2, 1, 2, 6, 2, 0, 9, 9, 49, 4, 2, 1, 2, 4, 9, 9, 55, 9, 266, 3, 10, 1, 2, 0, 49, 6, 4, 4, 14, 10, 5350, 0, 7, 14, 11465, 27, 2343, 9, 87, 9, 39, 4, 60, 6, 26, 9, 535, 9, 470, 0, 2, 54, 8, 3, 82, 0, 12, 1, 19628, 1, 4178, 9, 519, 45, 3, 22, 543, 4, 4, 5, 9, 7, 3, 6, 31, 3, 149, 2, 1418, 49, 513, 54, 5, 49, 9, 0, 15, 0, 23, 4, 2, 14, 1361, 6, 2, 16, 3, 6, 2, 1, 2, 4, 101, 0, 161, 6, 10, 9, 357, 0, 62, 13, 499, 13, 245, 1, 2, 9, 233, 0, 3, 0, 8, 1, 6, 0, 475, 6, 110, 6, 6, 9, 4759, 9, 787719, 239];\nfunction isInAstralSet(code, set) {\n  let pos = 0x10000;\n  for (let i = 0, length = set.length; i < length; i += 2) {\n    pos += set[i];\n    if (pos > code) return false;\n    pos += set[i + 1];\n    if (pos >= code) return true;\n  }\n  return false;\n}\nfunction isIdentifierStart(code) {\n  if (code < 65) return code === 36;\n  if (code <= 90) return true;\n  if (code < 97) return code === 95;\n  if (code <= 122) return true;\n  if (code <= 0xffff) {\n    return code >= 0xaa && nonASCIIidentifierStart.test(String.fromCharCode(code));\n  }\n  return isInAstralSet(code, astralIdentifierStartCodes);\n}\nfunction isIdentifierChar(code) {\n  if (code < 48) return code === 36;\n  if (code < 58) return true;\n  if (code < 65) return false;\n  if (code <= 90) return true;\n  if (code < 97) return code === 95;\n  if (code <= 122) return true;\n  if (code <= 0xffff) {\n    return code >= 0xaa && nonASCIIidentifier.test(String.fromCharCode(code));\n  }\n  return isInAstralSet(code, astralIdentifierStartCodes) || isInAstralSet(code, astralIdentifierCodes);\n}\nfunction isIdentifierName(name) {\n  let isFirst = true;\n  for (let i = 0; i < name.length; i++) {\n    let cp = name.charCodeAt(i);\n    if ((cp & 0xfc00) === 0xd800 && i + 1 < name.length) {\n      const trail = name.charCodeAt(++i);\n      if ((trail & 0xfc00) === 0xdc00) {\n        cp = 0x10000 + ((cp & 0x3ff) << 10) + (trail & 0x3ff);\n      }\n    }\n    if (isFirst) {\n      isFirst = false;\n      if (!isIdentifierStart(cp)) {\n        return false;\n      }\n    } else if (!isIdentifierChar(cp)) {\n      return false;\n    }\n  }\n  return !isFirst;\n}\n\n//# sourceMappingURL=identifier.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGJhYmVsL2hlbHBlci12YWxpZGF0b3ItaWRlbnRpZmllci9saWIvaWRlbnRpZmllci5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYiw4Q0FBNkM7QUFDN0M7QUFDQSxDQUFDLEVBQUM7QUFDRix3QkFBd0I7QUFDeEIsd0JBQXdCO0FBQ3hCLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUMsWUFBWTtBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixpQkFBaUI7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9yZXBvLXZpc3VhbGl6ZXIvLi9ub2RlX21vZHVsZXMvQGJhYmVsL2hlbHBlci12YWxpZGF0b3ItaWRlbnRpZmllci9saWIvaWRlbnRpZmllci5qcz9iNTdjIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5pc0lkZW50aWZpZXJDaGFyID0gaXNJZGVudGlmaWVyQ2hhcjtcbmV4cG9ydHMuaXNJZGVudGlmaWVyTmFtZSA9IGlzSWRlbnRpZmllck5hbWU7XG5leHBvcnRzLmlzSWRlbnRpZmllclN0YXJ0ID0gaXNJZGVudGlmaWVyU3RhcnQ7XG5sZXQgbm9uQVNDSUlpZGVudGlmaWVyU3RhcnRDaGFycyA9IFwiXFx4YWFcXHhiNVxceGJhXFx4YzAtXFx4ZDZcXHhkOC1cXHhmNlxceGY4LVxcdTAyYzFcXHUwMmM2LVxcdTAyZDFcXHUwMmUwLVxcdTAyZTRcXHUwMmVjXFx1MDJlZVxcdTAzNzAtXFx1MDM3NFxcdTAzNzZcXHUwMzc3XFx1MDM3YS1cXHUwMzdkXFx1MDM3ZlxcdTAzODZcXHUwMzg4LVxcdTAzOGFcXHUwMzhjXFx1MDM4ZS1cXHUwM2ExXFx1MDNhMy1cXHUwM2Y1XFx1MDNmNy1cXHUwNDgxXFx1MDQ4YS1cXHUwNTJmXFx1MDUzMS1cXHUwNTU2XFx1MDU1OVxcdTA1NjAtXFx1MDU4OFxcdTA1ZDAtXFx1MDVlYVxcdTA1ZWYtXFx1MDVmMlxcdTA2MjAtXFx1MDY0YVxcdTA2NmVcXHUwNjZmXFx1MDY3MS1cXHUwNmQzXFx1MDZkNVxcdTA2ZTVcXHUwNmU2XFx1MDZlZVxcdTA2ZWZcXHUwNmZhLVxcdTA2ZmNcXHUwNmZmXFx1MDcxMFxcdTA3MTItXFx1MDcyZlxcdTA3NGQtXFx1MDdhNVxcdTA3YjFcXHUwN2NhLVxcdTA3ZWFcXHUwN2Y0XFx1MDdmNVxcdTA3ZmFcXHUwODAwLVxcdTA4MTVcXHUwODFhXFx1MDgyNFxcdTA4MjhcXHUwODQwLVxcdTA4NThcXHUwODYwLVxcdTA4NmFcXHUwODcwLVxcdTA4ODdcXHUwODg5LVxcdTA4OGZcXHUwOGEwLVxcdTA4YzlcXHUwOTA0LVxcdTA5MzlcXHUwOTNkXFx1MDk1MFxcdTA5NTgtXFx1MDk2MVxcdTA5NzEtXFx1MDk4MFxcdTA5ODUtXFx1MDk4Y1xcdTA5OGZcXHUwOTkwXFx1MDk5My1cXHUwOWE4XFx1MDlhYS1cXHUwOWIwXFx1MDliMlxcdTA5YjYtXFx1MDliOVxcdTA5YmRcXHUwOWNlXFx1MDlkY1xcdTA5ZGRcXHUwOWRmLVxcdTA5ZTFcXHUwOWYwXFx1MDlmMVxcdTA5ZmNcXHUwYTA1LVxcdTBhMGFcXHUwYTBmXFx1MGExMFxcdTBhMTMtXFx1MGEyOFxcdTBhMmEtXFx1MGEzMFxcdTBhMzJcXHUwYTMzXFx1MGEzNVxcdTBhMzZcXHUwYTM4XFx1MGEzOVxcdTBhNTktXFx1MGE1Y1xcdTBhNWVcXHUwYTcyLVxcdTBhNzRcXHUwYTg1LVxcdTBhOGRcXHUwYThmLVxcdTBhOTFcXHUwYTkzLVxcdTBhYThcXHUwYWFhLVxcdTBhYjBcXHUwYWIyXFx1MGFiM1xcdTBhYjUtXFx1MGFiOVxcdTBhYmRcXHUwYWQwXFx1MGFlMFxcdTBhZTFcXHUwYWY5XFx1MGIwNS1cXHUwYjBjXFx1MGIwZlxcdTBiMTBcXHUwYjEzLVxcdTBiMjhcXHUwYjJhLVxcdTBiMzBcXHUwYjMyXFx1MGIzM1xcdTBiMzUtXFx1MGIzOVxcdTBiM2RcXHUwYjVjXFx1MGI1ZFxcdTBiNWYtXFx1MGI2MVxcdTBiNzFcXHUwYjgzXFx1MGI4NS1cXHUwYjhhXFx1MGI4ZS1cXHUwYjkwXFx1MGI5Mi1cXHUwYjk1XFx1MGI5OVxcdTBiOWFcXHUwYjljXFx1MGI5ZVxcdTBiOWZcXHUwYmEzXFx1MGJhNFxcdTBiYTgtXFx1MGJhYVxcdTBiYWUtXFx1MGJiOVxcdTBiZDBcXHUwYzA1LVxcdTBjMGNcXHUwYzBlLVxcdTBjMTBcXHUwYzEyLVxcdTBjMjhcXHUwYzJhLVxcdTBjMzlcXHUwYzNkXFx1MGM1OC1cXHUwYzVhXFx1MGM1Y1xcdTBjNWRcXHUwYzYwXFx1MGM2MVxcdTBjODBcXHUwYzg1LVxcdTBjOGNcXHUwYzhlLVxcdTBjOTBcXHUwYzkyLVxcdTBjYThcXHUwY2FhLVxcdTBjYjNcXHUwY2I1LVxcdTBjYjlcXHUwY2JkXFx1MGNkYy1cXHUwY2RlXFx1MGNlMFxcdTBjZTFcXHUwY2YxXFx1MGNmMlxcdTBkMDQtXFx1MGQwY1xcdTBkMGUtXFx1MGQxMFxcdTBkMTItXFx1MGQzYVxcdTBkM2RcXHUwZDRlXFx1MGQ1NC1cXHUwZDU2XFx1MGQ1Zi1cXHUwZDYxXFx1MGQ3YS1cXHUwZDdmXFx1MGQ4NS1cXHUwZDk2XFx1MGQ5YS1cXHUwZGIxXFx1MGRiMy1cXHUwZGJiXFx1MGRiZFxcdTBkYzAtXFx1MGRjNlxcdTBlMDEtXFx1MGUzMFxcdTBlMzJcXHUwZTMzXFx1MGU0MC1cXHUwZTQ2XFx1MGU4MVxcdTBlODJcXHUwZTg0XFx1MGU4Ni1cXHUwZThhXFx1MGU4Yy1cXHUwZWEzXFx1MGVhNVxcdTBlYTctXFx1MGViMFxcdTBlYjJcXHUwZWIzXFx1MGViZFxcdTBlYzAtXFx1MGVjNFxcdTBlYzZcXHUwZWRjLVxcdTBlZGZcXHUwZjAwXFx1MGY0MC1cXHUwZjQ3XFx1MGY0OS1cXHUwZjZjXFx1MGY4OC1cXHUwZjhjXFx1MTAwMC1cXHUxMDJhXFx1MTAzZlxcdTEwNTAtXFx1MTA1NVxcdTEwNWEtXFx1MTA1ZFxcdTEwNjFcXHUxMDY1XFx1MTA2NlxcdTEwNmUtXFx1MTA3MFxcdTEwNzUtXFx1MTA4MVxcdTEwOGVcXHUxMGEwLVxcdTEwYzVcXHUxMGM3XFx1MTBjZFxcdTEwZDAtXFx1MTBmYVxcdTEwZmMtXFx1MTI0OFxcdTEyNGEtXFx1MTI0ZFxcdTEyNTAtXFx1MTI1NlxcdTEyNThcXHUxMjVhLVxcdTEyNWRcXHUxMjYwLVxcdTEyODhcXHUxMjhhLVxcdTEyOGRcXHUxMjkwLVxcdTEyYjBcXHUxMmIyLVxcdTEyYjVcXHUxMmI4LVxcdTEyYmVcXHUxMmMwXFx1MTJjMi1cXHUxMmM1XFx1MTJjOC1cXHUxMmQ2XFx1MTJkOC1cXHUxMzEwXFx1MTMxMi1cXHUxMzE1XFx1MTMxOC1cXHUxMzVhXFx1MTM4MC1cXHUxMzhmXFx1MTNhMC1cXHUxM2Y1XFx1MTNmOC1cXHUxM2ZkXFx1MTQwMS1cXHUxNjZjXFx1MTY2Zi1cXHUxNjdmXFx1MTY4MS1cXHUxNjlhXFx1MTZhMC1cXHUxNmVhXFx1MTZlZS1cXHUxNmY4XFx1MTcwMC1cXHUxNzExXFx1MTcxZi1cXHUxNzMxXFx1MTc0MC1cXHUxNzUxXFx1MTc2MC1cXHUxNzZjXFx1MTc2ZS1cXHUxNzcwXFx1MTc4MC1cXHUxN2IzXFx1MTdkN1xcdTE3ZGNcXHUxODIwLVxcdTE4NzhcXHUxODgwLVxcdTE4YThcXHUxOGFhXFx1MThiMC1cXHUxOGY1XFx1MTkwMC1cXHUxOTFlXFx1MTk1MC1cXHUxOTZkXFx1MTk3MC1cXHUxOTc0XFx1MTk4MC1cXHUxOWFiXFx1MTliMC1cXHUxOWM5XFx1MWEwMC1cXHUxYTE2XFx1MWEyMC1cXHUxYTU0XFx1MWFhN1xcdTFiMDUtXFx1MWIzM1xcdTFiNDUtXFx1MWI0Y1xcdTFiODMtXFx1MWJhMFxcdTFiYWVcXHUxYmFmXFx1MWJiYS1cXHUxYmU1XFx1MWMwMC1cXHUxYzIzXFx1MWM0ZC1cXHUxYzRmXFx1MWM1YS1cXHUxYzdkXFx1MWM4MC1cXHUxYzhhXFx1MWM5MC1cXHUxY2JhXFx1MWNiZC1cXHUxY2JmXFx1MWNlOS1cXHUxY2VjXFx1MWNlZS1cXHUxY2YzXFx1MWNmNVxcdTFjZjZcXHUxY2ZhXFx1MWQwMC1cXHUxZGJmXFx1MWUwMC1cXHUxZjE1XFx1MWYxOC1cXHUxZjFkXFx1MWYyMC1cXHUxZjQ1XFx1MWY0OC1cXHUxZjRkXFx1MWY1MC1cXHUxZjU3XFx1MWY1OVxcdTFmNWJcXHUxZjVkXFx1MWY1Zi1cXHUxZjdkXFx1MWY4MC1cXHUxZmI0XFx1MWZiNi1cXHUxZmJjXFx1MWZiZVxcdTFmYzItXFx1MWZjNFxcdTFmYzYtXFx1MWZjY1xcdTFmZDAtXFx1MWZkM1xcdTFmZDYtXFx1MWZkYlxcdTFmZTAtXFx1MWZlY1xcdTFmZjItXFx1MWZmNFxcdTFmZjYtXFx1MWZmY1xcdTIwNzFcXHUyMDdmXFx1MjA5MC1cXHUyMDljXFx1MjEwMlxcdTIxMDdcXHUyMTBhLVxcdTIxMTNcXHUyMTE1XFx1MjExOC1cXHUyMTFkXFx1MjEyNFxcdTIxMjZcXHUyMTI4XFx1MjEyYS1cXHUyMTM5XFx1MjEzYy1cXHUyMTNmXFx1MjE0NS1cXHUyMTQ5XFx1MjE0ZVxcdTIxNjAtXFx1MjE4OFxcdTJjMDAtXFx1MmNlNFxcdTJjZWItXFx1MmNlZVxcdTJjZjJcXHUyY2YzXFx1MmQwMC1cXHUyZDI1XFx1MmQyN1xcdTJkMmRcXHUyZDMwLVxcdTJkNjdcXHUyZDZmXFx1MmQ4MC1cXHUyZDk2XFx1MmRhMC1cXHUyZGE2XFx1MmRhOC1cXHUyZGFlXFx1MmRiMC1cXHUyZGI2XFx1MmRiOC1cXHUyZGJlXFx1MmRjMC1cXHUyZGM2XFx1MmRjOC1cXHUyZGNlXFx1MmRkMC1cXHUyZGQ2XFx1MmRkOC1cXHUyZGRlXFx1MzAwNS1cXHUzMDA3XFx1MzAyMS1cXHUzMDI5XFx1MzAzMS1cXHUzMDM1XFx1MzAzOC1cXHUzMDNjXFx1MzA0MS1cXHUzMDk2XFx1MzA5Yi1cXHUzMDlmXFx1MzBhMS1cXHUzMGZhXFx1MzBmYy1cXHUzMGZmXFx1MzEwNS1cXHUzMTJmXFx1MzEzMS1cXHUzMThlXFx1MzFhMC1cXHUzMWJmXFx1MzFmMC1cXHUzMWZmXFx1MzQwMC1cXHU0ZGJmXFx1NGUwMC1cXHVhNDhjXFx1YTRkMC1cXHVhNGZkXFx1YTUwMC1cXHVhNjBjXFx1YTYxMC1cXHVhNjFmXFx1YTYyYVxcdWE2MmJcXHVhNjQwLVxcdWE2NmVcXHVhNjdmLVxcdWE2OWRcXHVhNmEwLVxcdWE2ZWZcXHVhNzE3LVxcdWE3MWZcXHVhNzIyLVxcdWE3ODhcXHVhNzhiLVxcdWE3ZGNcXHVhN2YxLVxcdWE4MDFcXHVhODAzLVxcdWE4MDVcXHVhODA3LVxcdWE4MGFcXHVhODBjLVxcdWE4MjJcXHVhODQwLVxcdWE4NzNcXHVhODgyLVxcdWE4YjNcXHVhOGYyLVxcdWE4ZjdcXHVhOGZiXFx1YThmZFxcdWE4ZmVcXHVhOTBhLVxcdWE5MjVcXHVhOTMwLVxcdWE5NDZcXHVhOTYwLVxcdWE5N2NcXHVhOTg0LVxcdWE5YjJcXHVhOWNmXFx1YTllMC1cXHVhOWU0XFx1YTllNi1cXHVhOWVmXFx1YTlmYS1cXHVhOWZlXFx1YWEwMC1cXHVhYTI4XFx1YWE0MC1cXHVhYTQyXFx1YWE0NC1cXHVhYTRiXFx1YWE2MC1cXHVhYTc2XFx1YWE3YVxcdWFhN2UtXFx1YWFhZlxcdWFhYjFcXHVhYWI1XFx1YWFiNlxcdWFhYjktXFx1YWFiZFxcdWFhYzBcXHVhYWMyXFx1YWFkYi1cXHVhYWRkXFx1YWFlMC1cXHVhYWVhXFx1YWFmMi1cXHVhYWY0XFx1YWIwMS1cXHVhYjA2XFx1YWIwOS1cXHVhYjBlXFx1YWIxMS1cXHVhYjE2XFx1YWIyMC1cXHVhYjI2XFx1YWIyOC1cXHVhYjJlXFx1YWIzMC1cXHVhYjVhXFx1YWI1Yy1cXHVhYjY5XFx1YWI3MC1cXHVhYmUyXFx1YWMwMC1cXHVkN2EzXFx1ZDdiMC1cXHVkN2M2XFx1ZDdjYi1cXHVkN2ZiXFx1ZjkwMC1cXHVmYTZkXFx1ZmE3MC1cXHVmYWQ5XFx1ZmIwMC1cXHVmYjA2XFx1ZmIxMy1cXHVmYjE3XFx1ZmIxZFxcdWZiMWYtXFx1ZmIyOFxcdWZiMmEtXFx1ZmIzNlxcdWZiMzgtXFx1ZmIzY1xcdWZiM2VcXHVmYjQwXFx1ZmI0MVxcdWZiNDNcXHVmYjQ0XFx1ZmI0Ni1cXHVmYmIxXFx1ZmJkMy1cXHVmZDNkXFx1ZmQ1MC1cXHVmZDhmXFx1ZmQ5Mi1cXHVmZGM3XFx1ZmRmMC1cXHVmZGZiXFx1ZmU3MC1cXHVmZTc0XFx1ZmU3Ni1cXHVmZWZjXFx1ZmYyMS1cXHVmZjNhXFx1ZmY0MS1cXHVmZjVhXFx1ZmY2Ni1cXHVmZmJlXFx1ZmZjMi1cXHVmZmM3XFx1ZmZjYS1cXHVmZmNmXFx1ZmZkMi1cXHVmZmQ3XFx1ZmZkYS1cXHVmZmRjXCI7XG5sZXQgbm9uQVNDSUlpZGVudGlmaWVyQ2hhcnMgPSBcIlxceGI3XFx1MDMwMC1cXHUwMzZmXFx1MDM4N1xcdTA0ODMtXFx1MDQ4N1xcdTA1OTEtXFx1MDViZFxcdTA1YmZcXHUwNWMxXFx1MDVjMlxcdTA1YzRcXHUwNWM1XFx1MDVjN1xcdTA2MTAtXFx1MDYxYVxcdTA2NGItXFx1MDY2OVxcdTA2NzBcXHUwNmQ2LVxcdTA2ZGNcXHUwNmRmLVxcdTA2ZTRcXHUwNmU3XFx1MDZlOFxcdTA2ZWEtXFx1MDZlZFxcdTA2ZjAtXFx1MDZmOVxcdTA3MTFcXHUwNzMwLVxcdTA3NGFcXHUwN2E2LVxcdTA3YjBcXHUwN2MwLVxcdTA3YzlcXHUwN2ViLVxcdTA3ZjNcXHUwN2ZkXFx1MDgxNi1cXHUwODE5XFx1MDgxYi1cXHUwODIzXFx1MDgyNS1cXHUwODI3XFx1MDgyOS1cXHUwODJkXFx1MDg1OS1cXHUwODViXFx1MDg5Ny1cXHUwODlmXFx1MDhjYS1cXHUwOGUxXFx1MDhlMy1cXHUwOTAzXFx1MDkzYS1cXHUwOTNjXFx1MDkzZS1cXHUwOTRmXFx1MDk1MS1cXHUwOTU3XFx1MDk2MlxcdTA5NjNcXHUwOTY2LVxcdTA5NmZcXHUwOTgxLVxcdTA5ODNcXHUwOWJjXFx1MDliZS1cXHUwOWM0XFx1MDljN1xcdTA5YzhcXHUwOWNiLVxcdTA5Y2RcXHUwOWQ3XFx1MDllMlxcdTA5ZTNcXHUwOWU2LVxcdTA5ZWZcXHUwOWZlXFx1MGEwMS1cXHUwYTAzXFx1MGEzY1xcdTBhM2UtXFx1MGE0MlxcdTBhNDdcXHUwYTQ4XFx1MGE0Yi1cXHUwYTRkXFx1MGE1MVxcdTBhNjYtXFx1MGE3MVxcdTBhNzVcXHUwYTgxLVxcdTBhODNcXHUwYWJjXFx1MGFiZS1cXHUwYWM1XFx1MGFjNy1cXHUwYWM5XFx1MGFjYi1cXHUwYWNkXFx1MGFlMlxcdTBhZTNcXHUwYWU2LVxcdTBhZWZcXHUwYWZhLVxcdTBhZmZcXHUwYjAxLVxcdTBiMDNcXHUwYjNjXFx1MGIzZS1cXHUwYjQ0XFx1MGI0N1xcdTBiNDhcXHUwYjRiLVxcdTBiNGRcXHUwYjU1LVxcdTBiNTdcXHUwYjYyXFx1MGI2M1xcdTBiNjYtXFx1MGI2ZlxcdTBiODJcXHUwYmJlLVxcdTBiYzJcXHUwYmM2LVxcdTBiYzhcXHUwYmNhLVxcdTBiY2RcXHUwYmQ3XFx1MGJlNi1cXHUwYmVmXFx1MGMwMC1cXHUwYzA0XFx1MGMzY1xcdTBjM2UtXFx1MGM0NFxcdTBjNDYtXFx1MGM0OFxcdTBjNGEtXFx1MGM0ZFxcdTBjNTVcXHUwYzU2XFx1MGM2MlxcdTBjNjNcXHUwYzY2LVxcdTBjNmZcXHUwYzgxLVxcdTBjODNcXHUwY2JjXFx1MGNiZS1cXHUwY2M0XFx1MGNjNi1cXHUwY2M4XFx1MGNjYS1cXHUwY2NkXFx1MGNkNVxcdTBjZDZcXHUwY2UyXFx1MGNlM1xcdTBjZTYtXFx1MGNlZlxcdTBjZjNcXHUwZDAwLVxcdTBkMDNcXHUwZDNiXFx1MGQzY1xcdTBkM2UtXFx1MGQ0NFxcdTBkNDYtXFx1MGQ0OFxcdTBkNGEtXFx1MGQ0ZFxcdTBkNTdcXHUwZDYyXFx1MGQ2M1xcdTBkNjYtXFx1MGQ2ZlxcdTBkODEtXFx1MGQ4M1xcdTBkY2FcXHUwZGNmLVxcdTBkZDRcXHUwZGQ2XFx1MGRkOC1cXHUwZGRmXFx1MGRlNi1cXHUwZGVmXFx1MGRmMlxcdTBkZjNcXHUwZTMxXFx1MGUzNC1cXHUwZTNhXFx1MGU0Ny1cXHUwZTRlXFx1MGU1MC1cXHUwZTU5XFx1MGViMVxcdTBlYjQtXFx1MGViY1xcdTBlYzgtXFx1MGVjZVxcdTBlZDAtXFx1MGVkOVxcdTBmMThcXHUwZjE5XFx1MGYyMC1cXHUwZjI5XFx1MGYzNVxcdTBmMzdcXHUwZjM5XFx1MGYzZVxcdTBmM2ZcXHUwZjcxLVxcdTBmODRcXHUwZjg2XFx1MGY4N1xcdTBmOGQtXFx1MGY5N1xcdTBmOTktXFx1MGZiY1xcdTBmYzZcXHUxMDJiLVxcdTEwM2VcXHUxMDQwLVxcdTEwNDlcXHUxMDU2LVxcdTEwNTlcXHUxMDVlLVxcdTEwNjBcXHUxMDYyLVxcdTEwNjRcXHUxMDY3LVxcdTEwNmRcXHUxMDcxLVxcdTEwNzRcXHUxMDgyLVxcdTEwOGRcXHUxMDhmLVxcdTEwOWRcXHUxMzVkLVxcdTEzNWZcXHUxMzY5LVxcdTEzNzFcXHUxNzEyLVxcdTE3MTVcXHUxNzMyLVxcdTE3MzRcXHUxNzUyXFx1MTc1M1xcdTE3NzJcXHUxNzczXFx1MTdiNC1cXHUxN2QzXFx1MTdkZFxcdTE3ZTAtXFx1MTdlOVxcdTE4MGItXFx1MTgwZFxcdTE4MGYtXFx1MTgxOVxcdTE4YTlcXHUxOTIwLVxcdTE5MmJcXHUxOTMwLVxcdTE5M2JcXHUxOTQ2LVxcdTE5NGZcXHUxOWQwLVxcdTE5ZGFcXHUxYTE3LVxcdTFhMWJcXHUxYTU1LVxcdTFhNWVcXHUxYTYwLVxcdTFhN2NcXHUxYTdmLVxcdTFhODlcXHUxYTkwLVxcdTFhOTlcXHUxYWIwLVxcdTFhYmRcXHUxYWJmLVxcdTFhZGRcXHUxYWUwLVxcdTFhZWJcXHUxYjAwLVxcdTFiMDRcXHUxYjM0LVxcdTFiNDRcXHUxYjUwLVxcdTFiNTlcXHUxYjZiLVxcdTFiNzNcXHUxYjgwLVxcdTFiODJcXHUxYmExLVxcdTFiYWRcXHUxYmIwLVxcdTFiYjlcXHUxYmU2LVxcdTFiZjNcXHUxYzI0LVxcdTFjMzdcXHUxYzQwLVxcdTFjNDlcXHUxYzUwLVxcdTFjNTlcXHUxY2QwLVxcdTFjZDJcXHUxY2Q0LVxcdTFjZThcXHUxY2VkXFx1MWNmNFxcdTFjZjctXFx1MWNmOVxcdTFkYzAtXFx1MWRmZlxcdTIwMGNcXHUyMDBkXFx1MjAzZlxcdTIwNDBcXHUyMDU0XFx1MjBkMC1cXHUyMGRjXFx1MjBlMVxcdTIwZTUtXFx1MjBmMFxcdTJjZWYtXFx1MmNmMVxcdTJkN2ZcXHUyZGUwLVxcdTJkZmZcXHUzMDJhLVxcdTMwMmZcXHUzMDk5XFx1MzA5YVxcdTMwZmJcXHVhNjIwLVxcdWE2MjlcXHVhNjZmXFx1YTY3NC1cXHVhNjdkXFx1YTY5ZVxcdWE2OWZcXHVhNmYwXFx1YTZmMVxcdWE4MDJcXHVhODA2XFx1YTgwYlxcdWE4MjMtXFx1YTgyN1xcdWE4MmNcXHVhODgwXFx1YTg4MVxcdWE4YjQtXFx1YThjNVxcdWE4ZDAtXFx1YThkOVxcdWE4ZTAtXFx1YThmMVxcdWE4ZmYtXFx1YTkwOVxcdWE5MjYtXFx1YTkyZFxcdWE5NDctXFx1YTk1M1xcdWE5ODAtXFx1YTk4M1xcdWE5YjMtXFx1YTljMFxcdWE5ZDAtXFx1YTlkOVxcdWE5ZTVcXHVhOWYwLVxcdWE5ZjlcXHVhYTI5LVxcdWFhMzZcXHVhYTQzXFx1YWE0Y1xcdWFhNGRcXHVhYTUwLVxcdWFhNTlcXHVhYTdiLVxcdWFhN2RcXHVhYWIwXFx1YWFiMi1cXHVhYWI0XFx1YWFiN1xcdWFhYjhcXHVhYWJlXFx1YWFiZlxcdWFhYzFcXHVhYWViLVxcdWFhZWZcXHVhYWY1XFx1YWFmNlxcdWFiZTMtXFx1YWJlYVxcdWFiZWNcXHVhYmVkXFx1YWJmMC1cXHVhYmY5XFx1ZmIxZVxcdWZlMDAtXFx1ZmUwZlxcdWZlMjAtXFx1ZmUyZlxcdWZlMzNcXHVmZTM0XFx1ZmU0ZC1cXHVmZTRmXFx1ZmYxMC1cXHVmZjE5XFx1ZmYzZlxcdWZmNjVcIjtcbmNvbnN0IG5vbkFTQ0lJaWRlbnRpZmllclN0YXJ0ID0gbmV3IFJlZ0V4cChcIltcIiArIG5vbkFTQ0lJaWRlbnRpZmllclN0YXJ0Q2hhcnMgKyBcIl1cIik7XG5jb25zdCBub25BU0NJSWlkZW50aWZpZXIgPSBuZXcgUmVnRXhwKFwiW1wiICsgbm9uQVNDSUlpZGVudGlmaWVyU3RhcnRDaGFycyArIG5vbkFTQ0lJaWRlbnRpZmllckNoYXJzICsgXCJdXCIpO1xubm9uQVNDSUlpZGVudGlmaWVyU3RhcnRDaGFycyA9IG5vbkFTQ0lJaWRlbnRpZmllckNoYXJzID0gbnVsbDtcbmNvbnN0IGFzdHJhbElkZW50aWZpZXJTdGFydENvZGVzID0gWzAsIDExLCAyLCAyNSwgMiwgMTgsIDIsIDEsIDIsIDE0LCAzLCAxMywgMzUsIDEyMiwgNzAsIDUyLCAyNjgsIDI4LCA0LCA0OCwgNDgsIDMxLCAxNCwgMjksIDYsIDM3LCAxMSwgMjksIDMsIDM1LCA1LCA3LCAyLCA0LCA0MywgMTU3LCAxOSwgMzUsIDUsIDM1LCA1LCAzOSwgOSwgNTEsIDEzLCAxMCwgMiwgMTQsIDIsIDYsIDIsIDEsIDIsIDEwLCAyLCAxNCwgMiwgNiwgMiwgMSwgNCwgNTEsIDEzLCAzMTAsIDEwLCAyMSwgMTEsIDcsIDI1LCA1LCAyLCA0MSwgMiwgOCwgNzAsIDUsIDMsIDAsIDIsIDQzLCAyLCAxLCA0LCAwLCAzLCAyMiwgMTEsIDIyLCAxMCwgMzAsIDY2LCAxOCwgMiwgMSwgMTEsIDIxLCAxMSwgMjUsIDcsIDI1LCAzOSwgNTUsIDcsIDEsIDY1LCAwLCAxNiwgMywgMiwgMiwgMiwgMjgsIDQzLCAyOCwgNCwgMjgsIDM2LCA3LCAyLCAyNywgMjgsIDUzLCAxMSwgMjEsIDExLCAxOCwgMTQsIDE3LCAxMTEsIDcyLCA1NiwgNTAsIDE0LCA1MCwgMTQsIDM1LCAzOSwgMjcsIDEwLCAyMiwgMjUxLCA0MSwgNywgMSwgMTcsIDUsIDU3LCAyOCwgMTEsIDAsIDksIDIxLCA0MywgMTcsIDQ3LCAyMCwgMjgsIDIyLCAxMywgNTIsIDU4LCAxLCAzLCAwLCAxNCwgNDQsIDMzLCAyNCwgMjcsIDM1LCAzMCwgMCwgMywgMCwgOSwgMzQsIDQsIDAsIDEzLCA0NywgMTUsIDMsIDIyLCAwLCAyLCAwLCAzNiwgMTcsIDIsIDI0LCAyMCwgMSwgNjQsIDYsIDIsIDAsIDIsIDMsIDIsIDE0LCAyLCA5LCA4LCA0NiwgMzksIDcsIDMsIDEsIDMsIDIxLCAyLCA2LCAyLCAxLCAyLCA0LCA0LCAwLCAxOSwgMCwgMTMsIDQsIDMxLCA5LCAyLCAwLCAzLCAwLCAyLCAzNywgMiwgMCwgMjYsIDAsIDIsIDAsIDQ1LCA1MiwgMTksIDMsIDIxLCAyLCAzMSwgNDcsIDIxLCAxLCAyLCAwLCAxODUsIDQ2LCA0MiwgMywgMzcsIDQ3LCAyMSwgMCwgNjAsIDQyLCAxNCwgMCwgNzIsIDI2LCAzOCwgNiwgMTg2LCA0MywgMTE3LCA2MywgMzIsIDcsIDMsIDAsIDMsIDcsIDIsIDEsIDIsIDIzLCAxNiwgMCwgMiwgMCwgOTUsIDcsIDMsIDM4LCAxNywgMCwgMiwgMCwgMjksIDAsIDExLCAzOSwgOCwgMCwgMjIsIDAsIDEyLCA0NSwgMjAsIDAsIDE5LCA3MiwgMjAwLCAzMiwgMzIsIDgsIDIsIDM2LCAxOCwgMCwgNTAsIDI5LCAxMTMsIDYsIDIsIDEsIDIsIDM3LCAyMiwgMCwgMjYsIDUsIDIsIDEsIDIsIDMxLCAxNSwgMCwgMjQsIDQzLCAyNjEsIDE4LCAxNiwgMCwgMiwgMTIsIDIsIDMzLCAxMjUsIDAsIDgwLCA5MjEsIDEwMywgMTEwLCAxOCwgMTk1LCAyNjM3LCA5NiwgMTYsIDEwNzEsIDE4LCA1LCAyNiwgMzk5NCwgNiwgNTgyLCA2ODQyLCAyOSwgMTc2MywgNTY4LCA4LCAzMCwgMTgsIDc4LCAxOCwgMjksIDE5LCA0NywgMTcsIDMsIDMyLCAyMCwgNiwgMTgsIDQzMywgNDQsIDIxMiwgNjMsIDMzLCAyNCwgMywgMjQsIDQ1LCA3NCwgNiwgMCwgNjcsIDEyLCA2NSwgMSwgMiwgMCwgMTUsIDQsIDEwLCA3MzgxLCA0MiwgMzEsIDk4LCAxMTQsIDg3MDIsIDMsIDIsIDYsIDIsIDEsIDIsIDI5MCwgMTYsIDAsIDMwLCAyLCAzLCAwLCAxNSwgMywgOSwgMzk1LCAyMzA5LCAxMDYsIDYsIDEyLCA0LCA4LCA4LCA5LCA1OTkxLCA4NCwgMiwgNzAsIDIsIDEsIDMsIDAsIDMsIDEsIDMsIDMsIDIsIDExLCAyLCAwLCAyLCA2LCAyLCA2NCwgMiwgMywgMywgNywgMiwgNiwgMiwgMjcsIDIsIDMsIDIsIDQsIDIsIDAsIDQsIDYsIDIsIDMzOSwgMywgMjQsIDIsIDI0LCAyLCAzMCwgMiwgMjQsIDIsIDMwLCAyLCAyNCwgMiwgMzAsIDIsIDI0LCAyLCAzMCwgMiwgMjQsIDIsIDcsIDE4NDUsIDMwLCA3LCA1LCAyNjIsIDYxLCAxNDcsIDQ0LCAxMSwgNiwgMTcsIDAsIDMyMiwgMjksIDE5LCA0MywgNDg1LCAyNywgMjI5LCAyOSwgMywgMCwgMjA4LCAzMCwgMiwgMiwgMiwgMSwgMiwgNiwgMywgNCwgMTAsIDEsIDIyNSwgNiwgMiwgMywgMiwgMSwgMiwgMTQsIDIsIDE5NiwgNjAsIDY3LCA4LCAwLCAxMjA1LCAzLCAyLCAyNiwgMiwgMSwgMiwgMCwgMywgMCwgMiwgOSwgMiwgMywgMiwgMCwgMiwgMCwgNywgMCwgNSwgMCwgMiwgMCwgMiwgMCwgMiwgMiwgMiwgMSwgMiwgMCwgMywgMCwgMiwgMCwgMiwgMCwgMiwgMCwgMiwgMCwgMiwgMSwgMiwgMCwgMywgMywgMiwgNiwgMiwgMywgMiwgMywgMiwgMCwgMiwgOSwgMiwgMTYsIDYsIDIsIDIsIDQsIDIsIDE2LCA0NDIxLCA0MjcxOSwgMzMsIDQzODEsIDMsIDU3NzMsIDMsIDc0NzIsIDE2LCA2MjEsIDI0NjcsIDU0MSwgMTUwNywgNDkzOCwgNiwgODQ4OV07XG5jb25zdCBhc3RyYWxJZGVudGlmaWVyQ29kZXMgPSBbNTA5LCAwLCAyMjcsIDAsIDE1MCwgNCwgMjk0LCA5LCAxMzY4LCAyLCAyLCAxLCA2LCAzLCA0MSwgMiwgNSwgMCwgMTY2LCAxLCA1NzQsIDMsIDksIDksIDcsIDksIDMyLCA0LCAzMTgsIDEsIDc4LCA1LCA3MSwgMTAsIDUwLCAzLCAxMjMsIDIsIDU0LCAxNCwgMzIsIDEwLCAzLCAxLCAxMSwgMywgNDYsIDEwLCA4LCAwLCA0NiwgOSwgNywgMiwgMzcsIDEzLCAyLCA5LCA2LCAxLCA0NSwgMCwgMTMsIDIsIDQ5LCAxMywgOSwgMywgMiwgMTEsIDgzLCAxMSwgNywgMCwgMywgMCwgMTU4LCAxMSwgNiwgOSwgNywgMywgNTYsIDEsIDIsIDYsIDMsIDEsIDMsIDIsIDEwLCAwLCAxMSwgMSwgMywgNiwgNCwgNCwgNjgsIDgsIDIsIDAsIDMsIDAsIDIsIDMsIDIsIDQsIDIsIDAsIDE1LCAxLCA4MywgMTcsIDEwLCA5LCA1LCAwLCA4MiwgMTksIDEzLCA5LCAyMTQsIDYsIDMsIDgsIDI4LCAxLCA4MywgMTYsIDE2LCA5LCA4MiwgMTIsIDksIDksIDcsIDE5LCA1OCwgMTQsIDUsIDksIDI0MywgMTQsIDE2NiwgOSwgNzEsIDUsIDIsIDEsIDMsIDMsIDIsIDAsIDIsIDEsIDEzLCA5LCAxMjAsIDYsIDMsIDYsIDQsIDAsIDI5LCA5LCA0MSwgNiwgMiwgMywgOSwgMCwgMTAsIDEwLCA0NywgMTUsIDE5OSwgNywgMTM3LCA5LCA1NCwgNywgMiwgNywgMTcsIDksIDU3LCAyMSwgMiwgMTMsIDEyMywgNSwgNCwgMCwgMiwgMSwgMiwgNiwgMiwgMCwgOSwgOSwgNDksIDQsIDIsIDEsIDIsIDQsIDksIDksIDU1LCA5LCAyNjYsIDMsIDEwLCAxLCAyLCAwLCA0OSwgNiwgNCwgNCwgMTQsIDEwLCA1MzUwLCAwLCA3LCAxNCwgMTE0NjUsIDI3LCAyMzQzLCA5LCA4NywgOSwgMzksIDQsIDYwLCA2LCAyNiwgOSwgNTM1LCA5LCA0NzAsIDAsIDIsIDU0LCA4LCAzLCA4MiwgMCwgMTIsIDEsIDE5NjI4LCAxLCA0MTc4LCA5LCA1MTksIDQ1LCAzLCAyMiwgNTQzLCA0LCA0LCA1LCA5LCA3LCAzLCA2LCAzMSwgMywgMTQ5LCAyLCAxNDE4LCA0OSwgNTEzLCA1NCwgNSwgNDksIDksIDAsIDE1LCAwLCAyMywgNCwgMiwgMTQsIDEzNjEsIDYsIDIsIDE2LCAzLCA2LCAyLCAxLCAyLCA0LCAxMDEsIDAsIDE2MSwgNiwgMTAsIDksIDM1NywgMCwgNjIsIDEzLCA0OTksIDEzLCAyNDUsIDEsIDIsIDksIDIzMywgMCwgMywgMCwgOCwgMSwgNiwgMCwgNDc1LCA2LCAxMTAsIDYsIDYsIDksIDQ3NTksIDksIDc4NzcxOSwgMjM5XTtcbmZ1bmN0aW9uIGlzSW5Bc3RyYWxTZXQoY29kZSwgc2V0KSB7XG4gIGxldCBwb3MgPSAweDEwMDAwO1xuICBmb3IgKGxldCBpID0gMCwgbGVuZ3RoID0gc2V0Lmxlbmd0aDsgaSA8IGxlbmd0aDsgaSArPSAyKSB7XG4gICAgcG9zICs9IHNldFtpXTtcbiAgICBpZiAocG9zID4gY29kZSkgcmV0dXJuIGZhbHNlO1xuICAgIHBvcyArPSBzZXRbaSArIDFdO1xuICAgIGlmIChwb3MgPj0gY29kZSkgcmV0dXJuIHRydWU7XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufVxuZnVuY3Rpb24gaXNJZGVudGlmaWVyU3RhcnQoY29kZSkge1xuICBpZiAoY29kZSA8IDY1KSByZXR1cm4gY29kZSA9PT0gMzY7XG4gIGlmIChjb2RlIDw9IDkwKSByZXR1cm4gdHJ1ZTtcbiAgaWYgKGNvZGUgPCA5NykgcmV0dXJuIGNvZGUgPT09IDk1O1xuICBpZiAoY29kZSA8PSAxMjIpIHJldHVybiB0cnVlO1xuICBpZiAoY29kZSA8PSAweGZmZmYpIHtcbiAgICByZXR1cm4gY29kZSA+PSAweGFhICYmIG5vbkFTQ0lJaWRlbnRpZmllclN0YXJ0LnRlc3QoU3RyaW5nLmZyb21DaGFyQ29kZShjb2RlKSk7XG4gIH1cbiAgcmV0dXJuIGlzSW5Bc3RyYWxTZXQoY29kZSwgYXN0cmFsSWRlbnRpZmllclN0YXJ0Q29kZXMpO1xufVxuZnVuY3Rpb24gaXNJZGVudGlmaWVyQ2hhcihjb2RlKSB7XG4gIGlmIChjb2RlIDwgNDgpIHJldHVybiBjb2RlID09PSAzNjtcbiAgaWYgKGNvZGUgPCA1OCkgcmV0dXJuIHRydWU7XG4gIGlmIChjb2RlIDwgNjUpIHJldHVybiBmYWxzZTtcbiAgaWYgKGNvZGUgPD0gOTApIHJldHVybiB0cnVlO1xuICBpZiAoY29kZSA8IDk3KSByZXR1cm4gY29kZSA9PT0gOTU7XG4gIGlmIChjb2RlIDw9IDEyMikgcmV0dXJuIHRydWU7XG4gIGlmIChjb2RlIDw9IDB4ZmZmZikge1xuICAgIHJldHVybiBjb2RlID49IDB4YWEgJiYgbm9uQVNDSUlpZGVudGlmaWVyLnRlc3QoU3RyaW5nLmZyb21DaGFyQ29kZShjb2RlKSk7XG4gIH1cbiAgcmV0dXJuIGlzSW5Bc3RyYWxTZXQoY29kZSwgYXN0cmFsSWRlbnRpZmllclN0YXJ0Q29kZXMpIHx8IGlzSW5Bc3RyYWxTZXQoY29kZSwgYXN0cmFsSWRlbnRpZmllckNvZGVzKTtcbn1cbmZ1bmN0aW9uIGlzSWRlbnRpZmllck5hbWUobmFtZSkge1xuICBsZXQgaXNGaXJzdCA9IHRydWU7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgbmFtZS5sZW5ndGg7IGkrKykge1xuICAgIGxldCBjcCA9IG5hbWUuY2hhckNvZGVBdChpKTtcbiAgICBpZiAoKGNwICYgMHhmYzAwKSA9PT0gMHhkODAwICYmIGkgKyAxIDwgbmFtZS5sZW5ndGgpIHtcbiAgICAgIGNvbnN0IHRyYWlsID0gbmFtZS5jaGFyQ29kZUF0KCsraSk7XG4gICAgICBpZiAoKHRyYWlsICYgMHhmYzAwKSA9PT0gMHhkYzAwKSB7XG4gICAgICAgIGNwID0gMHgxMDAwMCArICgoY3AgJiAweDNmZikgPDwgMTApICsgKHRyYWlsICYgMHgzZmYpO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoaXNGaXJzdCkge1xuICAgICAgaXNGaXJzdCA9IGZhbHNlO1xuICAgICAgaWYgKCFpc0lkZW50aWZpZXJTdGFydChjcCkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoIWlzSWRlbnRpZmllckNoYXIoY3ApKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG4gIHJldHVybiAhaXNGaXJzdDtcbn1cblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aWRlbnRpZmllci5qcy5tYXBcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@babel/helper-validator-identifier/lib/identifier.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@babel/helper-validator-identifier/lib/index.js":
/*!**********************************************************************!*\
  !*** ./node_modules/@babel/helper-validator-identifier/lib/index.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nObject.defineProperty(exports, \"isIdentifierChar\", ({\n  enumerable: true,\n  get: function () {\n    return _identifier.isIdentifierChar;\n  }\n}));\nObject.defineProperty(exports, \"isIdentifierName\", ({\n  enumerable: true,\n  get: function () {\n    return _identifier.isIdentifierName;\n  }\n}));\nObject.defineProperty(exports, \"isIdentifierStart\", ({\n  enumerable: true,\n  get: function () {\n    return _identifier.isIdentifierStart;\n  }\n}));\nObject.defineProperty(exports, \"isKeyword\", ({\n  enumerable: true,\n  get: function () {\n    return _keyword.isKeyword;\n  }\n}));\nObject.defineProperty(exports, \"isReservedWord\", ({\n  enumerable: true,\n  get: function () {\n    return _keyword.isReservedWord;\n  }\n}));\nObject.defineProperty(exports, \"isStrictBindOnlyReservedWord\", ({\n  enumerable: true,\n  get: function () {\n    return _keyword.isStrictBindOnlyReservedWord;\n  }\n}));\nObject.defineProperty(exports, \"isStrictBindReservedWord\", ({\n  enumerable: true,\n  get: function () {\n    return _keyword.isStrictBindReservedWord;\n  }\n}));\nObject.defineProperty(exports, \"isStrictReservedWord\", ({\n  enumerable: true,\n  get: function () {\n    return _keyword.isStrictReservedWord;\n  }\n}));\nvar _identifier = __webpack_require__(/*! ./identifier.js */ \"(ssr)/./node_modules/@babel/helper-validator-identifier/lib/identifier.js\");\nvar _keyword = __webpack_require__(/*! ./keyword.js */ \"(ssr)/./node_modules/@babel/helper-validator-identifier/lib/keyword.js\");\n\n//# sourceMappingURL=index.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGJhYmVsL2hlbHBlci12YWxpZGF0b3ItaWRlbnRpZmllci9saWIvaW5kZXguanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWIsOENBQTZDO0FBQzdDO0FBQ0EsQ0FBQyxFQUFDO0FBQ0Ysb0RBQW1EO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxFQUFDO0FBQ0Ysb0RBQW1EO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxFQUFDO0FBQ0YscURBQW9EO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxFQUFDO0FBQ0YsNkNBQTRDO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxFQUFDO0FBQ0Ysa0RBQWlEO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxFQUFDO0FBQ0YsZ0VBQStEO0FBQy9EO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxFQUFDO0FBQ0YsNERBQTJEO0FBQzNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxFQUFDO0FBQ0Ysd0RBQXVEO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxFQUFDO0FBQ0Ysa0JBQWtCLG1CQUFPLENBQUMsa0dBQWlCO0FBQzNDLGVBQWUsbUJBQU8sQ0FBQyw0RkFBYzs7QUFFckMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9yZXBvLXZpc3VhbGl6ZXIvLi9ub2RlX21vZHVsZXMvQGJhYmVsL2hlbHBlci12YWxpZGF0b3ItaWRlbnRpZmllci9saWIvaW5kZXguanM/MGMxYiJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImlzSWRlbnRpZmllckNoYXJcIiwge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gX2lkZW50aWZpZXIuaXNJZGVudGlmaWVyQ2hhcjtcbiAgfVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJpc0lkZW50aWZpZXJOYW1lXCIsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIF9pZGVudGlmaWVyLmlzSWRlbnRpZmllck5hbWU7XG4gIH1cbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiaXNJZGVudGlmaWVyU3RhcnRcIiwge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gX2lkZW50aWZpZXIuaXNJZGVudGlmaWVyU3RhcnQ7XG4gIH1cbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiaXNLZXl3b3JkXCIsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIF9rZXl3b3JkLmlzS2V5d29yZDtcbiAgfVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJpc1Jlc2VydmVkV29yZFwiLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBfa2V5d29yZC5pc1Jlc2VydmVkV29yZDtcbiAgfVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJpc1N0cmljdEJpbmRPbmx5UmVzZXJ2ZWRXb3JkXCIsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIF9rZXl3b3JkLmlzU3RyaWN0QmluZE9ubHlSZXNlcnZlZFdvcmQ7XG4gIH1cbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiaXNTdHJpY3RCaW5kUmVzZXJ2ZWRXb3JkXCIsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIF9rZXl3b3JkLmlzU3RyaWN0QmluZFJlc2VydmVkV29yZDtcbiAgfVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJpc1N0cmljdFJlc2VydmVkV29yZFwiLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBfa2V5d29yZC5pc1N0cmljdFJlc2VydmVkV29yZDtcbiAgfVxufSk7XG52YXIgX2lkZW50aWZpZXIgPSByZXF1aXJlKFwiLi9pZGVudGlmaWVyLmpzXCIpO1xudmFyIF9rZXl3b3JkID0gcmVxdWlyZShcIi4va2V5d29yZC5qc1wiKTtcblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@babel/helper-validator-identifier/lib/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@babel/helper-validator-identifier/lib/keyword.js":
/*!************************************************************************!*\
  !*** ./node_modules/@babel/helper-validator-identifier/lib/keyword.js ***!
  \************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports.isKeyword = isKeyword;\nexports.isReservedWord = isReservedWord;\nexports.isStrictBindOnlyReservedWord = isStrictBindOnlyReservedWord;\nexports.isStrictBindReservedWord = isStrictBindReservedWord;\nexports.isStrictReservedWord = isStrictReservedWord;\nconst reservedWords = {\n  keyword: [\"break\", \"case\", \"catch\", \"continue\", \"debugger\", \"default\", \"do\", \"else\", \"finally\", \"for\", \"function\", \"if\", \"return\", \"switch\", \"throw\", \"try\", \"var\", \"const\", \"while\", \"with\", \"new\", \"this\", \"super\", \"class\", \"extends\", \"export\", \"import\", \"null\", \"true\", \"false\", \"in\", \"instanceof\", \"typeof\", \"void\", \"delete\"],\n  strict: [\"implements\", \"interface\", \"let\", \"package\", \"private\", \"protected\", \"public\", \"static\", \"yield\"],\n  strictBind: [\"eval\", \"arguments\"]\n};\nconst keywords = new Set(reservedWords.keyword);\nconst reservedWordsStrictSet = new Set(reservedWords.strict);\nconst reservedWordsStrictBindSet = new Set(reservedWords.strictBind);\nfunction isReservedWord(word, inModule) {\n  return inModule && word === \"await\" || word === \"enum\";\n}\nfunction isStrictReservedWord(word, inModule) {\n  return isReservedWord(word, inModule) || reservedWordsStrictSet.has(word);\n}\nfunction isStrictBindOnlyReservedWord(word) {\n  return reservedWordsStrictBindSet.has(word);\n}\nfunction isStrictBindReservedWord(word, inModule) {\n  return isStrictReservedWord(word, inModule) || isStrictBindOnlyReservedWord(word);\n}\nfunction isKeyword(word) {\n  return keywords.has(word);\n}\n\n//# sourceMappingURL=keyword.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGJhYmVsL2hlbHBlci12YWxpZGF0b3ItaWRlbnRpZmllci9saWIva2V5d29yZC5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYiw4Q0FBNkM7QUFDN0M7QUFDQSxDQUFDLEVBQUM7QUFDRixpQkFBaUI7QUFDakIsc0JBQXNCO0FBQ3RCLG9DQUFvQztBQUNwQyxnQ0FBZ0M7QUFDaEMsNEJBQTRCO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9yZXBvLXZpc3VhbGl6ZXIvLi9ub2RlX21vZHVsZXMvQGJhYmVsL2hlbHBlci12YWxpZGF0b3ItaWRlbnRpZmllci9saWIva2V5d29yZC5qcz83Nzg4Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5pc0tleXdvcmQgPSBpc0tleXdvcmQ7XG5leHBvcnRzLmlzUmVzZXJ2ZWRXb3JkID0gaXNSZXNlcnZlZFdvcmQ7XG5leHBvcnRzLmlzU3RyaWN0QmluZE9ubHlSZXNlcnZlZFdvcmQgPSBpc1N0cmljdEJpbmRPbmx5UmVzZXJ2ZWRXb3JkO1xuZXhwb3J0cy5pc1N0cmljdEJpbmRSZXNlcnZlZFdvcmQgPSBpc1N0cmljdEJpbmRSZXNlcnZlZFdvcmQ7XG5leHBvcnRzLmlzU3RyaWN0UmVzZXJ2ZWRXb3JkID0gaXNTdHJpY3RSZXNlcnZlZFdvcmQ7XG5jb25zdCByZXNlcnZlZFdvcmRzID0ge1xuICBrZXl3b3JkOiBbXCJicmVha1wiLCBcImNhc2VcIiwgXCJjYXRjaFwiLCBcImNvbnRpbnVlXCIsIFwiZGVidWdnZXJcIiwgXCJkZWZhdWx0XCIsIFwiZG9cIiwgXCJlbHNlXCIsIFwiZmluYWxseVwiLCBcImZvclwiLCBcImZ1bmN0aW9uXCIsIFwiaWZcIiwgXCJyZXR1cm5cIiwgXCJzd2l0Y2hcIiwgXCJ0aHJvd1wiLCBcInRyeVwiLCBcInZhclwiLCBcImNvbnN0XCIsIFwid2hpbGVcIiwgXCJ3aXRoXCIsIFwibmV3XCIsIFwidGhpc1wiLCBcInN1cGVyXCIsIFwiY2xhc3NcIiwgXCJleHRlbmRzXCIsIFwiZXhwb3J0XCIsIFwiaW1wb3J0XCIsIFwibnVsbFwiLCBcInRydWVcIiwgXCJmYWxzZVwiLCBcImluXCIsIFwiaW5zdGFuY2VvZlwiLCBcInR5cGVvZlwiLCBcInZvaWRcIiwgXCJkZWxldGVcIl0sXG4gIHN0cmljdDogW1wiaW1wbGVtZW50c1wiLCBcImludGVyZmFjZVwiLCBcImxldFwiLCBcInBhY2thZ2VcIiwgXCJwcml2YXRlXCIsIFwicHJvdGVjdGVkXCIsIFwicHVibGljXCIsIFwic3RhdGljXCIsIFwieWllbGRcIl0sXG4gIHN0cmljdEJpbmQ6IFtcImV2YWxcIiwgXCJhcmd1bWVudHNcIl1cbn07XG5jb25zdCBrZXl3b3JkcyA9IG5ldyBTZXQocmVzZXJ2ZWRXb3Jkcy5rZXl3b3JkKTtcbmNvbnN0IHJlc2VydmVkV29yZHNTdHJpY3RTZXQgPSBuZXcgU2V0KHJlc2VydmVkV29yZHMuc3RyaWN0KTtcbmNvbnN0IHJlc2VydmVkV29yZHNTdHJpY3RCaW5kU2V0ID0gbmV3IFNldChyZXNlcnZlZFdvcmRzLnN0cmljdEJpbmQpO1xuZnVuY3Rpb24gaXNSZXNlcnZlZFdvcmQod29yZCwgaW5Nb2R1bGUpIHtcbiAgcmV0dXJuIGluTW9kdWxlICYmIHdvcmQgPT09IFwiYXdhaXRcIiB8fCB3b3JkID09PSBcImVudW1cIjtcbn1cbmZ1bmN0aW9uIGlzU3RyaWN0UmVzZXJ2ZWRXb3JkKHdvcmQsIGluTW9kdWxlKSB7XG4gIHJldHVybiBpc1Jlc2VydmVkV29yZCh3b3JkLCBpbk1vZHVsZSkgfHwgcmVzZXJ2ZWRXb3Jkc1N0cmljdFNldC5oYXMod29yZCk7XG59XG5mdW5jdGlvbiBpc1N0cmljdEJpbmRPbmx5UmVzZXJ2ZWRXb3JkKHdvcmQpIHtcbiAgcmV0dXJuIHJlc2VydmVkV29yZHNTdHJpY3RCaW5kU2V0Lmhhcyh3b3JkKTtcbn1cbmZ1bmN0aW9uIGlzU3RyaWN0QmluZFJlc2VydmVkV29yZCh3b3JkLCBpbk1vZHVsZSkge1xuICByZXR1cm4gaXNTdHJpY3RSZXNlcnZlZFdvcmQod29yZCwgaW5Nb2R1bGUpIHx8IGlzU3RyaWN0QmluZE9ubHlSZXNlcnZlZFdvcmQod29yZCk7XG59XG5mdW5jdGlvbiBpc0tleXdvcmQod29yZCkge1xuICByZXR1cm4ga2V5d29yZHMuaGFzKHdvcmQpO1xufVxuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1rZXl3b3JkLmpzLm1hcFxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@babel/helper-validator-identifier/lib/keyword.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@babel/parser/lib/index.js":
/*!*************************************************!*\
  !*** ./node_modules/@babel/parser/lib/index.js ***!
  \*************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nfunction _objectWithoutPropertiesLoose(r, e) {\n  if (null == r) return {};\n  var t = {};\n  for (var n in r) if ({}.hasOwnProperty.call(r, n)) {\n    if (-1 !== e.indexOf(n)) continue;\n    t[n] = r[n];\n  }\n  return t;\n}\nclass Position {\n  constructor(line, col, index) {\n    this.line = void 0;\n    this.column = void 0;\n    this.index = void 0;\n    this.line = line;\n    this.column = col;\n    this.index = index;\n  }\n}\nclass SourceLocation {\n  constructor(start, end) {\n    this.start = void 0;\n    this.end = void 0;\n    this.filename = void 0;\n    this.identifierName = void 0;\n    this.start = start;\n    this.end = end;\n  }\n}\nfunction createPositionWithColumnOffset(position, columnOffset) {\n  const {\n    line,\n    column,\n    index\n  } = position;\n  return new Position(line, column + columnOffset, index + columnOffset);\n}\nconst code = \"BABEL_PARSER_SOURCETYPE_MODULE_REQUIRED\";\nvar ModuleErrors = {\n  ImportMetaOutsideModule: {\n    message: `import.meta may appear only with 'sourceType: \"module\"'`,\n    code\n  },\n  ImportOutsideModule: {\n    message: `'import' and 'export' may appear only with 'sourceType: \"module\"'`,\n    code\n  }\n};\nconst NodeDescriptions = {\n  ArrayPattern: \"array destructuring pattern\",\n  AssignmentExpression: \"assignment expression\",\n  AssignmentPattern: \"assignment expression\",\n  ArrowFunctionExpression: \"arrow function expression\",\n  ConditionalExpression: \"conditional expression\",\n  CatchClause: \"catch clause\",\n  ForOfStatement: \"for-of statement\",\n  ForInStatement: \"for-in statement\",\n  ForStatement: \"for-loop\",\n  FormalParameters: \"function parameter list\",\n  Identifier: \"identifier\",\n  ImportSpecifier: \"import specifier\",\n  ImportDefaultSpecifier: \"import default specifier\",\n  ImportNamespaceSpecifier: \"import namespace specifier\",\n  ObjectPattern: \"object destructuring pattern\",\n  ParenthesizedExpression: \"parenthesized expression\",\n  RestElement: \"rest element\",\n  UpdateExpression: {\n    true: \"prefix operation\",\n    false: \"postfix operation\"\n  },\n  VariableDeclarator: \"variable declaration\",\n  YieldExpression: \"yield expression\"\n};\nconst toNodeDescription = node => node.type === \"UpdateExpression\" ? NodeDescriptions.UpdateExpression[`${node.prefix}`] : NodeDescriptions[node.type];\nvar StandardErrors = {\n  AccessorIsGenerator: ({\n    kind\n  }) => `A ${kind}ter cannot be a generator.`,\n  ArgumentsInClass: \"'arguments' is only allowed in functions and class methods.\",\n  AsyncFunctionInSingleStatementContext: \"Async functions can only be declared at the top level or inside a block.\",\n  AwaitBindingIdentifier: \"Can not use 'await' as identifier inside an async function.\",\n  AwaitBindingIdentifierInStaticBlock: \"Can not use 'await' as identifier inside a static block.\",\n  AwaitExpressionFormalParameter: \"'await' is not allowed in async function parameters.\",\n  AwaitUsingNotInAsyncContext: \"'await using' is only allowed within async functions and at the top levels of modules.\",\n  AwaitNotInAsyncContext: \"'await' is only allowed within async functions and at the top levels of modules.\",\n  BadGetterArity: \"A 'get' accessor must not have any formal parameters.\",\n  BadSetterArity: \"A 'set' accessor must have exactly one formal parameter.\",\n  BadSetterRestParameter: \"A 'set' accessor function argument must not be a rest parameter.\",\n  ConstructorClassField: \"Classes may not have a field named 'constructor'.\",\n  ConstructorClassPrivateField: \"Classes may not have a private field named '#constructor'.\",\n  ConstructorIsAccessor: \"Class constructor may not be an accessor.\",\n  ConstructorIsAsync: \"Constructor can't be an async function.\",\n  ConstructorIsGenerator: \"Constructor can't be a generator.\",\n  DeclarationMissingInitializer: ({\n    kind\n  }) => `Missing initializer in ${kind} declaration.`,\n  DecoratorArgumentsOutsideParentheses: \"Decorator arguments must be moved inside parentheses: use '@(decorator(args))' instead of '@(decorator)(args)'.\",\n  DecoratorBeforeExport: \"Decorators must be placed *before* the 'export' keyword. Remove the 'decoratorsBeforeExport: true' option to use the 'export @decorator class {}' syntax.\",\n  DecoratorsBeforeAfterExport: \"Decorators can be placed *either* before or after the 'export' keyword, but not in both locations at the same time.\",\n  DecoratorConstructor: \"Decorators can't be used with a constructor. Did you mean '@dec class { ... }'?\",\n  DecoratorExportClass: \"Decorators must be placed *after* the 'export' keyword. Remove the 'decoratorsBeforeExport: false' option to use the '@decorator export class {}' syntax.\",\n  DecoratorSemicolon: \"Decorators must not be followed by a semicolon.\",\n  DecoratorStaticBlock: \"Decorators can't be used with a static block.\",\n  DeferImportRequiresNamespace: 'Only `import defer * as x from \"./module\"` is valid.',\n  DeletePrivateField: \"Deleting a private field is not allowed.\",\n  DestructureNamedImport: \"ES2015 named imports do not destructure. Use another statement for destructuring after the import.\",\n  DuplicateConstructor: \"Duplicate constructor in the same class.\",\n  DuplicateDefaultExport: \"Only one default export allowed per module.\",\n  DuplicateExport: ({\n    exportName\n  }) => `\\`${exportName}\\` has already been exported. Exported identifiers must be unique.`,\n  DuplicateProto: \"Redefinition of __proto__ property.\",\n  DuplicateRegExpFlags: \"Duplicate regular expression flag.\",\n  ElementAfterRest: \"Rest element must be last element.\",\n  EscapedCharNotAnIdentifier: \"Invalid Unicode escape.\",\n  ExportBindingIsString: ({\n    localName,\n    exportName\n  }) => `A string literal cannot be used as an exported binding without \\`from\\`.\\n- Did you mean \\`export { '${localName}' as '${exportName}' } from 'some-module'\\`?`,\n  ExportDefaultFromAsIdentifier: \"'from' is not allowed as an identifier after 'export default'.\",\n  ForInOfLoopInitializer: ({\n    type\n  }) => `'${type === \"ForInStatement\" ? \"for-in\" : \"for-of\"}' loop variable declaration may not have an initializer.`,\n  ForInUsing: \"For-in loop may not start with 'using' declaration.\",\n  ForOfAsync: \"The left-hand side of a for-of loop may not be 'async'.\",\n  ForOfLet: \"The left-hand side of a for-of loop may not start with 'let'.\",\n  GeneratorInSingleStatementContext: \"Generators can only be declared at the top level or inside a block.\",\n  IllegalBreakContinue: ({\n    type\n  }) => `Unsyntactic ${type === \"BreakStatement\" ? \"break\" : \"continue\"}.`,\n  IllegalLanguageModeDirective: \"Illegal 'use strict' directive in function with non-simple parameter list.\",\n  IllegalReturn: \"'return' outside of function.\",\n  ImportAttributesUseAssert: \"The `assert` keyword in import attributes is deprecated and it has been replaced by the `with` keyword. You can enable the `deprecatedImportAssert` parser plugin to suppress this error.\",\n  ImportBindingIsString: ({\n    importName\n  }) => `A string literal cannot be used as an imported binding.\\n- Did you mean \\`import { \"${importName}\" as foo }\\`?`,\n  ImportCallArity: `\\`import()\\` requires exactly one or two arguments.`,\n  ImportCallNotNewExpression: \"Cannot use new with import(...).\",\n  ImportCallSpreadArgument: \"`...` is not allowed in `import()`.\",\n  ImportJSONBindingNotDefault: \"A JSON module can only be imported with `default`.\",\n  ImportReflectionHasAssertion: \"`import module x` cannot have assertions.\",\n  ImportReflectionNotBinding: 'Only `import module x from \"./module\"` is valid.',\n  IncompatibleRegExpUVFlags: \"The 'u' and 'v' regular expression flags cannot be enabled at the same time.\",\n  InvalidBigIntLiteral: \"Invalid BigIntLiteral.\",\n  InvalidCodePoint: \"Code point out of bounds.\",\n  InvalidCoverDiscardElement: \"'void' must be followed by an expression when not used in a binding position.\",\n  InvalidCoverInitializedName: \"Invalid shorthand property initializer.\",\n  InvalidDecimal: \"Invalid decimal.\",\n  InvalidDigit: ({\n    radix\n  }) => `Expected number in radix ${radix}.`,\n  InvalidEscapeSequence: \"Bad character escape sequence.\",\n  InvalidEscapeSequenceTemplate: \"Invalid escape sequence in template.\",\n  InvalidEscapedReservedWord: ({\n    reservedWord\n  }) => `Escape sequence in keyword ${reservedWord}.`,\n  InvalidIdentifier: ({\n    identifierName\n  }) => `Invalid identifier ${identifierName}.`,\n  InvalidLhs: ({\n    ancestor\n  }) => `Invalid left-hand side in ${toNodeDescription(ancestor)}.`,\n  InvalidLhsBinding: ({\n    ancestor\n  }) => `Binding invalid left-hand side in ${toNodeDescription(ancestor)}.`,\n  InvalidLhsOptionalChaining: ({\n    ancestor\n  }) => `Invalid optional chaining in the left-hand side of ${toNodeDescription(ancestor)}.`,\n  InvalidNumber: \"Invalid number.\",\n  InvalidOrMissingExponent: \"Floating-point numbers require a valid exponent after the 'e'.\",\n  InvalidOrUnexpectedToken: ({\n    unexpected\n  }) => `Unexpected character '${unexpected}'.`,\n  InvalidParenthesizedAssignment: \"Invalid parenthesized assignment pattern.\",\n  InvalidPrivateFieldResolution: ({\n    identifierName\n  }) => `Private name #${identifierName} is not defined.`,\n  InvalidPropertyBindingPattern: \"Binding member expression.\",\n  InvalidRecordProperty: \"Only properties and spread elements are allowed in record definitions.\",\n  InvalidRestAssignmentPattern: \"Invalid rest operator's argument.\",\n  LabelRedeclaration: ({\n    labelName\n  }) => `Label '${labelName}' is already declared.`,\n  LetInLexicalBinding: \"'let' is disallowed as a lexically bound name.\",\n  LineTerminatorBeforeArrow: \"No line break is allowed before '=>'.\",\n  MalformedRegExpFlags: \"Invalid regular expression flag.\",\n  MissingClassName: \"A class name is required.\",\n  MissingEqInAssignment: \"Only '=' operator can be used for specifying default value.\",\n  MissingSemicolon: \"Missing semicolon.\",\n  MissingPlugin: ({\n    missingPlugin\n  }) => `This experimental syntax requires enabling the parser plugin: ${missingPlugin.map(name => JSON.stringify(name)).join(\", \")}.`,\n  MissingOneOfPlugins: ({\n    missingPlugin\n  }) => `This experimental syntax requires enabling one of the following parser plugin(s): ${missingPlugin.map(name => JSON.stringify(name)).join(\", \")}.`,\n  MissingUnicodeEscape: \"Expecting Unicode escape sequence \\\\uXXXX.\",\n  MixingCoalesceWithLogical: \"Nullish coalescing operator(??) requires parens when mixing with logical operators.\",\n  ModuleAttributeDifferentFromType: \"The only accepted module attribute is `type`.\",\n  ModuleAttributeInvalidValue: \"Only string literals are allowed as module attribute values.\",\n  ModuleAttributesWithDuplicateKeys: ({\n    key\n  }) => `Duplicate key \"${key}\" is not allowed in module attributes.`,\n  ModuleExportNameHasLoneSurrogate: ({\n    surrogateCharCode\n  }) => `An export name cannot include a lone surrogate, found '\\\\u${surrogateCharCode.toString(16)}'.`,\n  ModuleExportUndefined: ({\n    localName\n  }) => `Export '${localName}' is not defined.`,\n  MultipleDefaultsInSwitch: \"Multiple default clauses.\",\n  NewlineAfterThrow: \"Illegal newline after throw.\",\n  NoCatchOrFinally: \"Missing catch or finally clause.\",\n  NumberIdentifier: \"Identifier directly after number.\",\n  NumericSeparatorInEscapeSequence: \"Numeric separators are not allowed inside unicode escape sequences or hex escape sequences.\",\n  ObsoleteAwaitStar: \"'await*' has been removed from the async functions proposal. Use Promise.all() instead.\",\n  OptionalChainingNoNew: \"Constructors in/after an Optional Chain are not allowed.\",\n  OptionalChainingNoTemplate: \"Tagged Template Literals are not allowed in optionalChain.\",\n  OverrideOnConstructor: \"'override' modifier cannot appear on a constructor declaration.\",\n  ParamDupe: \"Argument name clash.\",\n  PatternHasAccessor: \"Object pattern can't contain getter or setter.\",\n  PatternHasMethod: \"Object pattern can't contain methods.\",\n  PrivateInExpectedIn: ({\n    identifierName\n  }) => `Private names are only allowed in property accesses (\\`obj.#${identifierName}\\`) or in \\`in\\` expressions (\\`#${identifierName} in obj\\`).`,\n  PrivateNameRedeclaration: ({\n    identifierName\n  }) => `Duplicate private name #${identifierName}.`,\n  RecordExpressionBarIncorrectEndSyntaxType: \"Record expressions ending with '|}' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'bar'.\",\n  RecordExpressionBarIncorrectStartSyntaxType: \"Record expressions starting with '{|' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'bar'.\",\n  RecordExpressionHashIncorrectStartSyntaxType: \"Record expressions starting with '#{' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'hash'.\",\n  RecordNoProto: \"'__proto__' is not allowed in Record expressions.\",\n  RestTrailingComma: \"Unexpected trailing comma after rest element.\",\n  SloppyFunction: \"In non-strict mode code, functions can only be declared at top level or inside a block.\",\n  SloppyFunctionAnnexB: \"In non-strict mode code, functions can only be declared at top level, inside a block, or as the body of an if statement.\",\n  SourcePhaseImportRequiresDefault: 'Only `import source x from \"./module\"` is valid.',\n  StaticPrototype: \"Classes may not have static property named prototype.\",\n  SuperNotAllowed: \"`super()` is only valid inside a class constructor of a subclass. Maybe a typo in the method name ('constructor') or not extending another class?\",\n  SuperPrivateField: \"Private fields can't be accessed on super.\",\n  TrailingDecorator: \"Decorators must be attached to a class element.\",\n  TupleExpressionBarIncorrectEndSyntaxType: \"Tuple expressions ending with '|]' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'bar'.\",\n  TupleExpressionBarIncorrectStartSyntaxType: \"Tuple expressions starting with '[|' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'bar'.\",\n  TupleExpressionHashIncorrectStartSyntaxType: \"Tuple expressions starting with '#[' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'hash'.\",\n  UnexpectedArgumentPlaceholder: \"Unexpected argument placeholder.\",\n  UnexpectedAwaitAfterPipelineBody: 'Unexpected \"await\" after pipeline body; await must have parentheses in minimal proposal.',\n  UnexpectedDigitAfterHash: \"Unexpected digit after hash token.\",\n  UnexpectedImportExport: \"'import' and 'export' may only appear at the top level.\",\n  UnexpectedKeyword: ({\n    keyword\n  }) => `Unexpected keyword '${keyword}'.`,\n  UnexpectedLeadingDecorator: \"Leading decorators must be attached to a class declaration.\",\n  UnexpectedLexicalDeclaration: \"Lexical declaration cannot appear in a single-statement context.\",\n  UnexpectedNewTarget: \"`new.target` can only be used in functions or class properties.\",\n  UnexpectedNumericSeparator: \"A numeric separator is only allowed between two digits.\",\n  UnexpectedPrivateField: \"Unexpected private name.\",\n  UnexpectedReservedWord: ({\n    reservedWord\n  }) => `Unexpected reserved word '${reservedWord}'.`,\n  UnexpectedSuper: \"'super' is only allowed in object methods and classes.\",\n  UnexpectedToken: ({\n    expected,\n    unexpected\n  }) => `Unexpected token${unexpected ? ` '${unexpected}'.` : \"\"}${expected ? `, expected \"${expected}\"` : \"\"}`,\n  UnexpectedTokenUnaryExponentiation: \"Illegal expression. Wrap left hand side or entire exponentiation in parentheses.\",\n  UnexpectedUsingDeclaration: \"Using declaration cannot appear in the top level when source type is `script` or in the bare case statement.\",\n  UnexpectedVoidPattern: \"Unexpected void binding.\",\n  UnsupportedBind: \"Binding should be performed on object property.\",\n  UnsupportedDecoratorExport: \"A decorated export must export a class declaration.\",\n  UnsupportedDefaultExport: \"Only expressions, functions or classes are allowed as the `default` export.\",\n  UnsupportedImport: \"`import` can only be used in `import()` or `import.meta`.\",\n  UnsupportedMetaProperty: ({\n    target,\n    onlyValidPropertyName\n  }) => `The only valid meta property for ${target} is ${target}.${onlyValidPropertyName}.`,\n  UnsupportedParameterDecorator: \"Decorators cannot be used to decorate parameters.\",\n  UnsupportedPropertyDecorator: \"Decorators cannot be used to decorate object literal properties.\",\n  UnsupportedSuper: \"'super' can only be used with function calls (i.e. super()) or in property accesses (i.e. super.prop or super[prop]).\",\n  UnterminatedComment: \"Unterminated comment.\",\n  UnterminatedRegExp: \"Unterminated regular expression.\",\n  UnterminatedString: \"Unterminated string constant.\",\n  UnterminatedTemplate: \"Unterminated template.\",\n  UsingDeclarationExport: \"Using declaration cannot be exported.\",\n  UsingDeclarationHasBindingPattern: \"Using declaration cannot have destructuring patterns.\",\n  VarRedeclaration: ({\n    identifierName\n  }) => `Identifier '${identifierName}' has already been declared.`,\n  VoidPatternCatchClauseParam: \"A void binding can not be the catch clause parameter. Use `try { ... } catch { ... }` if you want to discard the caught error.\",\n  VoidPatternInitializer: \"A void binding may not have an initializer.\",\n  YieldBindingIdentifier: \"Can not use 'yield' as identifier inside a generator.\",\n  YieldInParameter: \"Yield expression is not allowed in formal parameters.\",\n  YieldNotInGeneratorFunction: \"'yield' is only allowed within generator functions.\",\n  ZeroDigitNumericSeparator: \"Numeric separator can not be used after leading 0.\"\n};\nvar StrictModeErrors = {\n  StrictDelete: \"Deleting local variable in strict mode.\",\n  StrictEvalArguments: ({\n    referenceName\n  }) => `Assigning to '${referenceName}' in strict mode.`,\n  StrictEvalArgumentsBinding: ({\n    bindingName\n  }) => `Binding '${bindingName}' in strict mode.`,\n  StrictFunction: \"In strict mode code, functions can only be declared at top level or inside a block.\",\n  StrictNumericEscape: \"The only valid numeric escape in strict mode is '\\\\0'.\",\n  StrictOctalLiteral: \"Legacy octal literals are not allowed in strict mode.\",\n  StrictWith: \"'with' in strict mode.\"\n};\nvar ParseExpressionErrors = {\n  ParseExpressionEmptyInput: \"Unexpected parseExpression() input: The input is empty or contains only comments.\",\n  ParseExpressionExpectsEOF: ({\n    unexpected\n  }) => `Unexpected parseExpression() input: The input should contain exactly one expression, but the first expression is followed by the unexpected character \\`${String.fromCodePoint(unexpected)}\\`.`\n};\nconst UnparenthesizedPipeBodyDescriptions = new Set([\"ArrowFunctionExpression\", \"AssignmentExpression\", \"ConditionalExpression\", \"YieldExpression\"]);\nvar PipelineOperatorErrors = Object.assign({\n  PipeBodyIsTighter: \"Unexpected yield after pipeline body; any yield expression acting as Hack-style pipe body must be parenthesized due to its loose operator precedence.\",\n  PipeTopicRequiresHackPipes: 'Topic reference is used, but the pipelineOperator plugin was not passed a \"proposal\": \"hack\" or \"smart\" option.',\n  PipeTopicUnbound: \"Topic reference is unbound; it must be inside a pipe body.\",\n  PipeTopicUnconfiguredToken: ({\n    token\n  }) => `Invalid topic token ${token}. In order to use ${token} as a topic reference, the pipelineOperator plugin must be configured with { \"proposal\": \"hack\", \"topicToken\": \"${token}\" }.`,\n  PipeTopicUnused: \"Hack-style pipe body does not contain a topic reference; Hack-style pipes must use topic at least once.\",\n  PipeUnparenthesizedBody: ({\n    type\n  }) => `Hack-style pipe body cannot be an unparenthesized ${toNodeDescription({\n    type\n  })}; please wrap it in parentheses.`\n}, {\n  PipelineBodyNoArrow: 'Unexpected arrow \"=>\" after pipeline body; arrow function in pipeline body must be parenthesized.',\n  PipelineBodySequenceExpression: \"Pipeline body may not be a comma-separated sequence expression.\",\n  PipelineHeadSequenceExpression: \"Pipeline head should not be a comma-separated sequence expression.\",\n  PipelineTopicUnused: \"Pipeline is in topic style but does not use topic reference.\",\n  PrimaryTopicNotAllowed: \"Topic reference was used in a lexical context without topic binding.\",\n  PrimaryTopicRequiresSmartPipeline: 'Topic reference is used, but the pipelineOperator plugin was not passed a \"proposal\": \"hack\" or \"smart\" option.'\n});\nconst _excluded = [\"message\"];\nfunction defineHidden(obj, key, value) {\n  Object.defineProperty(obj, key, {\n    enumerable: false,\n    configurable: true,\n    value\n  });\n}\nfunction toParseErrorConstructor({\n  toMessage,\n  code,\n  reasonCode,\n  syntaxPlugin\n}) {\n  const hasMissingPlugin = reasonCode === \"MissingPlugin\" || reasonCode === \"MissingOneOfPlugins\";\n  const oldReasonCodes = {\n    AccessorCannotDeclareThisParameter: \"AccesorCannotDeclareThisParameter\",\n    AccessorCannotHaveTypeParameters: \"AccesorCannotHaveTypeParameters\",\n    ConstInitializerMustBeStringOrNumericLiteralOrLiteralEnumReference: \"ConstInitiailizerMustBeStringOrNumericLiteralOrLiteralEnumReference\",\n    SetAccessorCannotHaveOptionalParameter: \"SetAccesorCannotHaveOptionalParameter\",\n    SetAccessorCannotHaveRestParameter: \"SetAccesorCannotHaveRestParameter\",\n    SetAccessorCannotHaveReturnType: \"SetAccesorCannotHaveReturnType\"\n  };\n  if (oldReasonCodes[reasonCode]) {\n    reasonCode = oldReasonCodes[reasonCode];\n  }\n  return function constructor(loc, details) {\n    const error = new SyntaxError();\n    error.code = code;\n    error.reasonCode = reasonCode;\n    error.loc = loc;\n    error.pos = loc.index;\n    error.syntaxPlugin = syntaxPlugin;\n    if (hasMissingPlugin) {\n      error.missingPlugin = details.missingPlugin;\n    }\n    defineHidden(error, \"clone\", function clone(overrides = {}) {\n      var _overrides$loc;\n      const {\n        line,\n        column,\n        index\n      } = (_overrides$loc = overrides.loc) != null ? _overrides$loc : loc;\n      return constructor(new Position(line, column, index), Object.assign({}, details, overrides.details));\n    });\n    defineHidden(error, \"details\", details);\n    Object.defineProperty(error, \"message\", {\n      configurable: true,\n      get() {\n        const message = `${toMessage(details)} (${loc.line}:${loc.column})`;\n        this.message = message;\n        return message;\n      },\n      set(value) {\n        Object.defineProperty(this, \"message\", {\n          value,\n          writable: true\n        });\n      }\n    });\n    return error;\n  };\n}\nfunction ParseErrorEnum(argument, syntaxPlugin) {\n  if (Array.isArray(argument)) {\n    return parseErrorTemplates => ParseErrorEnum(parseErrorTemplates, argument[0]);\n  }\n  const ParseErrorConstructors = {};\n  for (const reasonCode of Object.keys(argument)) {\n    const template = argument[reasonCode];\n    const _ref = typeof template === \"string\" ? {\n        message: () => template\n      } : typeof template === \"function\" ? {\n        message: template\n      } : template,\n      {\n        message\n      } = _ref,\n      rest = _objectWithoutPropertiesLoose(_ref, _excluded);\n    const toMessage = typeof message === \"string\" ? () => message : message;\n    ParseErrorConstructors[reasonCode] = toParseErrorConstructor(Object.assign({\n      code: \"BABEL_PARSER_SYNTAX_ERROR\",\n      reasonCode,\n      toMessage\n    }, syntaxPlugin ? {\n      syntaxPlugin\n    } : {}, rest));\n  }\n  return ParseErrorConstructors;\n}\nconst Errors = Object.assign({}, ParseErrorEnum(ModuleErrors), ParseErrorEnum(StandardErrors), ParseErrorEnum(StrictModeErrors), ParseErrorEnum(ParseExpressionErrors), ParseErrorEnum`pipelineOperator`(PipelineOperatorErrors));\nfunction createDefaultOptions() {\n  return {\n    sourceType: \"script\",\n    sourceFilename: undefined,\n    startIndex: 0,\n    startColumn: 0,\n    startLine: 1,\n    allowAwaitOutsideFunction: false,\n    allowReturnOutsideFunction: false,\n    allowNewTargetOutsideFunction: false,\n    allowImportExportEverywhere: false,\n    allowSuperOutsideMethod: false,\n    allowUndeclaredExports: false,\n    allowYieldOutsideFunction: false,\n    plugins: [],\n    strictMode: undefined,\n    ranges: false,\n    tokens: false,\n    createImportExpressions: false,\n    createParenthesizedExpressions: false,\n    errorRecovery: false,\n    attachComment: true,\n    annexB: true\n  };\n}\nfunction getOptions(opts) {\n  const options = createDefaultOptions();\n  if (opts == null) {\n    return options;\n  }\n  if (opts.annexB != null && opts.annexB !== false) {\n    throw new Error(\"The `annexB` option can only be set to `false`.\");\n  }\n  for (const key of Object.keys(options)) {\n    if (opts[key] != null) options[key] = opts[key];\n  }\n  if (options.startLine === 1) {\n    if (opts.startIndex == null && options.startColumn > 0) {\n      options.startIndex = options.startColumn;\n    } else if (opts.startColumn == null && options.startIndex > 0) {\n      options.startColumn = options.startIndex;\n    }\n  } else if (opts.startColumn == null || opts.startIndex == null) {\n    if (opts.startIndex != null) {\n      throw new Error(\"With a `startLine > 1` you must also specify `startIndex` and `startColumn`.\");\n    }\n  }\n  if (options.sourceType === \"commonjs\") {\n    if (opts.allowAwaitOutsideFunction != null) {\n      throw new Error(\"The `allowAwaitOutsideFunction` option cannot be used with `sourceType: 'commonjs'`.\");\n    }\n    if (opts.allowReturnOutsideFunction != null) {\n      throw new Error(\"`sourceType: 'commonjs'` implies `allowReturnOutsideFunction: true`, please remove the `allowReturnOutsideFunction` option or use `sourceType: 'script'`.\");\n    }\n    if (opts.allowNewTargetOutsideFunction != null) {\n      throw new Error(\"`sourceType: 'commonjs'` implies `allowNewTargetOutsideFunction: true`, please remove the `allowNewTargetOutsideFunction` option or use `sourceType: 'script'`.\");\n    }\n  }\n  return options;\n}\nconst {\n  defineProperty\n} = Object;\nconst toUnenumerable = (object, key) => {\n  if (object) {\n    defineProperty(object, key, {\n      enumerable: false,\n      value: object[key]\n    });\n  }\n};\nfunction toESTreeLocation(node) {\n  toUnenumerable(node.loc.start, \"index\");\n  toUnenumerable(node.loc.end, \"index\");\n  return node;\n}\nvar estree = superClass => class ESTreeParserMixin extends superClass {\n  parse() {\n    const file = toESTreeLocation(super.parse());\n    if (this.optionFlags & 256) {\n      file.tokens = file.tokens.map(toESTreeLocation);\n    }\n    return file;\n  }\n  parseRegExpLiteral({\n    pattern,\n    flags\n  }) {\n    let regex = null;\n    try {\n      regex = new RegExp(pattern, flags);\n    } catch (_) {}\n    const node = this.estreeParseLiteral(regex);\n    node.regex = {\n      pattern,\n      flags\n    };\n    return node;\n  }\n  parseBigIntLiteral(value) {\n    let bigInt;\n    try {\n      bigInt = BigInt(value);\n    } catch (_unused) {\n      bigInt = null;\n    }\n    const node = this.estreeParseLiteral(bigInt);\n    node.bigint = String(node.value || value);\n    return node;\n  }\n  parseDecimalLiteral(value) {\n    const decimal = null;\n    const node = this.estreeParseLiteral(decimal);\n    node.decimal = String(node.value || value);\n    return node;\n  }\n  estreeParseLiteral(value) {\n    return this.parseLiteral(value, \"Literal\");\n  }\n  parseStringLiteral(value) {\n    return this.estreeParseLiteral(value);\n  }\n  parseNumericLiteral(value) {\n    return this.estreeParseLiteral(value);\n  }\n  parseNullLiteral() {\n    return this.estreeParseLiteral(null);\n  }\n  parseBooleanLiteral(value) {\n    return this.estreeParseLiteral(value);\n  }\n  estreeParseChainExpression(node, endLoc) {\n    const chain = this.startNodeAtNode(node);\n    chain.expression = node;\n    return this.finishNodeAt(chain, \"ChainExpression\", endLoc);\n  }\n  directiveToStmt(directive) {\n    const expression = directive.value;\n    delete directive.value;\n    this.castNodeTo(expression, \"Literal\");\n    expression.raw = expression.extra.raw;\n    expression.value = expression.extra.expressionValue;\n    const stmt = this.castNodeTo(directive, \"ExpressionStatement\");\n    stmt.expression = expression;\n    stmt.directive = expression.extra.rawValue;\n    delete expression.extra;\n    return stmt;\n  }\n  fillOptionalPropertiesForTSESLint(node) {}\n  cloneEstreeStringLiteral(node) {\n    const {\n      start,\n      end,\n      loc,\n      range,\n      raw,\n      value\n    } = node;\n    const cloned = Object.create(node.constructor.prototype);\n    cloned.type = \"Literal\";\n    cloned.start = start;\n    cloned.end = end;\n    cloned.loc = loc;\n    cloned.range = range;\n    cloned.raw = raw;\n    cloned.value = value;\n    return cloned;\n  }\n  initFunction(node, isAsync) {\n    super.initFunction(node, isAsync);\n    node.expression = false;\n  }\n  checkDeclaration(node) {\n    if (node != null && this.isObjectProperty(node)) {\n      this.checkDeclaration(node.value);\n    } else {\n      super.checkDeclaration(node);\n    }\n  }\n  getObjectOrClassMethodParams(method) {\n    return method.value.params;\n  }\n  isValidDirective(stmt) {\n    var _stmt$expression$extr;\n    return stmt.type === \"ExpressionStatement\" && stmt.expression.type === \"Literal\" && typeof stmt.expression.value === \"string\" && !((_stmt$expression$extr = stmt.expression.extra) != null && _stmt$expression$extr.parenthesized);\n  }\n  parseBlockBody(node, allowDirectives, topLevel, end, afterBlockParse) {\n    super.parseBlockBody(node, allowDirectives, topLevel, end, afterBlockParse);\n    const directiveStatements = node.directives.map(d => this.directiveToStmt(d));\n    node.body = directiveStatements.concat(node.body);\n    delete node.directives;\n  }\n  parsePrivateName() {\n    const node = super.parsePrivateName();\n    if (!this.getPluginOption(\"estree\", \"classFeatures\")) {\n      return node;\n    }\n    return this.convertPrivateNameToPrivateIdentifier(node);\n  }\n  convertPrivateNameToPrivateIdentifier(node) {\n    const name = super.getPrivateNameSV(node);\n    delete node.id;\n    node.name = name;\n    return this.castNodeTo(node, \"PrivateIdentifier\");\n  }\n  isPrivateName(node) {\n    if (!this.getPluginOption(\"estree\", \"classFeatures\")) {\n      return super.isPrivateName(node);\n    }\n    return node.type === \"PrivateIdentifier\";\n  }\n  getPrivateNameSV(node) {\n    if (!this.getPluginOption(\"estree\", \"classFeatures\")) {\n      return super.getPrivateNameSV(node);\n    }\n    return node.name;\n  }\n  parseLiteral(value, type) {\n    const node = super.parseLiteral(value, type);\n    node.raw = node.extra.raw;\n    delete node.extra;\n    return node;\n  }\n  parseFunctionBody(node, allowExpression, isMethod = false) {\n    super.parseFunctionBody(node, allowExpression, isMethod);\n    node.expression = node.body.type !== \"BlockStatement\";\n  }\n  parseMethod(node, isGenerator, isAsync, isConstructor, allowDirectSuper, type, inClassScope = false) {\n    let funcNode = this.startNode();\n    funcNode.kind = node.kind;\n    funcNode = super.parseMethod(funcNode, isGenerator, isAsync, isConstructor, allowDirectSuper, type, inClassScope);\n    delete funcNode.kind;\n    const {\n      typeParameters\n    } = node;\n    if (typeParameters) {\n      delete node.typeParameters;\n      funcNode.typeParameters = typeParameters;\n      this.resetStartLocationFromNode(funcNode, typeParameters);\n    }\n    const valueNode = this.castNodeTo(funcNode, \"FunctionExpression\");\n    node.value = valueNode;\n    if (type === \"ClassPrivateMethod\") {\n      node.computed = false;\n    }\n    if (type === \"ObjectMethod\") {\n      if (node.kind === \"method\") {\n        node.kind = \"init\";\n      }\n      node.shorthand = false;\n      return this.finishNode(node, \"Property\");\n    } else {\n      return this.finishNode(node, \"MethodDefinition\");\n    }\n  }\n  nameIsConstructor(key) {\n    if (key.type === \"Literal\") return key.value === \"constructor\";\n    return super.nameIsConstructor(key);\n  }\n  parseClassProperty(...args) {\n    const propertyNode = super.parseClassProperty(...args);\n    if (!this.getPluginOption(\"estree\", \"classFeatures\")) {\n      return propertyNode;\n    }\n    this.castNodeTo(propertyNode, \"PropertyDefinition\");\n    return propertyNode;\n  }\n  parseClassPrivateProperty(...args) {\n    const propertyNode = super.parseClassPrivateProperty(...args);\n    if (!this.getPluginOption(\"estree\", \"classFeatures\")) {\n      return propertyNode;\n    }\n    this.castNodeTo(propertyNode, \"PropertyDefinition\");\n    propertyNode.computed = false;\n    return propertyNode;\n  }\n  parseClassAccessorProperty(node) {\n    const accessorPropertyNode = super.parseClassAccessorProperty(node);\n    if (!this.getPluginOption(\"estree\", \"classFeatures\")) {\n      return accessorPropertyNode;\n    }\n    if (accessorPropertyNode.abstract && this.hasPlugin(\"typescript\")) {\n      delete accessorPropertyNode.abstract;\n      this.castNodeTo(accessorPropertyNode, \"TSAbstractAccessorProperty\");\n    } else {\n      this.castNodeTo(accessorPropertyNode, \"AccessorProperty\");\n    }\n    return accessorPropertyNode;\n  }\n  parseObjectProperty(prop, startLoc, isPattern, refExpressionErrors) {\n    const node = super.parseObjectProperty(prop, startLoc, isPattern, refExpressionErrors);\n    if (node) {\n      node.kind = \"init\";\n      this.castNodeTo(node, \"Property\");\n    }\n    return node;\n  }\n  finishObjectProperty(node) {\n    node.kind = \"init\";\n    return this.finishNode(node, \"Property\");\n  }\n  isValidLVal(type, disallowCallExpression, isUnparenthesizedInAssign, binding) {\n    return type === \"Property\" ? \"value\" : super.isValidLVal(type, disallowCallExpression, isUnparenthesizedInAssign, binding);\n  }\n  isAssignable(node, isBinding) {\n    if (node != null && this.isObjectProperty(node)) {\n      return this.isAssignable(node.value, isBinding);\n    }\n    return super.isAssignable(node, isBinding);\n  }\n  toAssignable(node, isLHS = false) {\n    if (node != null && this.isObjectProperty(node)) {\n      const {\n        key,\n        value\n      } = node;\n      if (this.isPrivateName(key)) {\n        this.classScope.usePrivateName(this.getPrivateNameSV(key), key.loc.start);\n      }\n      this.toAssignable(value, isLHS);\n    } else {\n      super.toAssignable(node, isLHS);\n    }\n  }\n  toAssignableObjectExpressionProp(prop, isLast, isLHS) {\n    if (prop.type === \"Property\" && (prop.kind === \"get\" || prop.kind === \"set\")) {\n      this.raise(Errors.PatternHasAccessor, prop.key);\n    } else if (prop.type === \"Property\" && prop.method) {\n      this.raise(Errors.PatternHasMethod, prop.key);\n    } else {\n      super.toAssignableObjectExpressionProp(prop, isLast, isLHS);\n    }\n  }\n  finishCallExpression(unfinished, optional) {\n    const node = super.finishCallExpression(unfinished, optional);\n    if (node.callee.type === \"Import\") {\n      var _ref, _ref2;\n      this.castNodeTo(node, \"ImportExpression\");\n      node.source = node.arguments[0];\n      node.options = (_ref = node.arguments[1]) != null ? _ref : null;\n      node.attributes = (_ref2 = node.arguments[1]) != null ? _ref2 : null;\n      delete node.arguments;\n      delete node.callee;\n    } else if (node.type === \"OptionalCallExpression\") {\n      this.castNodeTo(node, \"CallExpression\");\n    } else {\n      node.optional = false;\n    }\n    return node;\n  }\n  toReferencedArguments(node) {\n    if (node.type === \"ImportExpression\") {\n      return;\n    }\n    super.toReferencedArguments(node);\n  }\n  parseExport(unfinished, decorators) {\n    const exportStartLoc = this.state.lastTokStartLoc;\n    const node = super.parseExport(unfinished, decorators);\n    switch (node.type) {\n      case \"ExportAllDeclaration\":\n        node.exported = null;\n        break;\n      case \"ExportNamedDeclaration\":\n        if (node.specifiers.length === 1 && node.specifiers[0].type === \"ExportNamespaceSpecifier\") {\n          this.castNodeTo(node, \"ExportAllDeclaration\");\n          node.exported = node.specifiers[0].exported;\n          delete node.specifiers;\n        }\n      case \"ExportDefaultDeclaration\":\n        {\n          var _declaration$decorato;\n          const {\n            declaration\n          } = node;\n          if ((declaration == null ? void 0 : declaration.type) === \"ClassDeclaration\" && ((_declaration$decorato = declaration.decorators) == null ? void 0 : _declaration$decorato.length) > 0 && declaration.start === node.start) {\n            this.resetStartLocation(node, exportStartLoc);\n          }\n        }\n        break;\n    }\n    return node;\n  }\n  stopParseSubscript(base, state) {\n    const node = super.stopParseSubscript(base, state);\n    if (state.optionalChainMember) {\n      return this.estreeParseChainExpression(node, base.loc.end);\n    }\n    return node;\n  }\n  parseMember(base, startLoc, state, computed, optional) {\n    const node = super.parseMember(base, startLoc, state, computed, optional);\n    if (node.type === \"OptionalMemberExpression\") {\n      this.castNodeTo(node, \"MemberExpression\");\n    } else {\n      node.optional = false;\n    }\n    return node;\n  }\n  isOptionalMemberExpression(node) {\n    if (node.type === \"ChainExpression\") {\n      return node.expression.type === \"MemberExpression\";\n    }\n    return super.isOptionalMemberExpression(node);\n  }\n  hasPropertyAsPrivateName(node) {\n    if (node.type === \"ChainExpression\") {\n      node = node.expression;\n    }\n    return super.hasPropertyAsPrivateName(node);\n  }\n  isObjectProperty(node) {\n    return node.type === \"Property\" && node.kind === \"init\" && !node.method;\n  }\n  isObjectMethod(node) {\n    return node.type === \"Property\" && (node.method || node.kind === \"get\" || node.kind === \"set\");\n  }\n  castNodeTo(node, type) {\n    const result = super.castNodeTo(node, type);\n    this.fillOptionalPropertiesForTSESLint(result);\n    return result;\n  }\n  cloneIdentifier(node) {\n    const cloned = super.cloneIdentifier(node);\n    this.fillOptionalPropertiesForTSESLint(cloned);\n    return cloned;\n  }\n  cloneStringLiteral(node) {\n    if (node.type === \"Literal\") {\n      return this.cloneEstreeStringLiteral(node);\n    }\n    return super.cloneStringLiteral(node);\n  }\n  finishNodeAt(node, type, endLoc) {\n    return toESTreeLocation(super.finishNodeAt(node, type, endLoc));\n  }\n  finishNode(node, type) {\n    const result = super.finishNode(node, type);\n    this.fillOptionalPropertiesForTSESLint(result);\n    return result;\n  }\n  resetStartLocation(node, startLoc) {\n    super.resetStartLocation(node, startLoc);\n    toESTreeLocation(node);\n  }\n  resetEndLocation(node, endLoc = this.state.lastTokEndLoc) {\n    super.resetEndLocation(node, endLoc);\n    toESTreeLocation(node);\n  }\n};\nclass TokContext {\n  constructor(token, preserveSpace) {\n    this.token = void 0;\n    this.preserveSpace = void 0;\n    this.token = token;\n    this.preserveSpace = !!preserveSpace;\n  }\n}\nconst types = {\n  brace: new TokContext(\"{\"),\n  j_oTag: new TokContext(\"<tag\"),\n  j_cTag: new TokContext(\"</tag\"),\n  j_expr: new TokContext(\"<tag>...</tag>\", true)\n};\ntypes.template = new TokContext(\"`\", true);\nconst beforeExpr = true;\nconst startsExpr = true;\nconst isLoop = true;\nconst isAssign = true;\nconst prefix = true;\nconst postfix = true;\nclass ExportedTokenType {\n  constructor(label, conf = {}) {\n    this.label = void 0;\n    this.keyword = void 0;\n    this.beforeExpr = void 0;\n    this.startsExpr = void 0;\n    this.rightAssociative = void 0;\n    this.isLoop = void 0;\n    this.isAssign = void 0;\n    this.prefix = void 0;\n    this.postfix = void 0;\n    this.binop = void 0;\n    this.label = label;\n    this.keyword = conf.keyword;\n    this.beforeExpr = !!conf.beforeExpr;\n    this.startsExpr = !!conf.startsExpr;\n    this.rightAssociative = !!conf.rightAssociative;\n    this.isLoop = !!conf.isLoop;\n    this.isAssign = !!conf.isAssign;\n    this.prefix = !!conf.prefix;\n    this.postfix = !!conf.postfix;\n    this.binop = conf.binop != null ? conf.binop : null;\n    this.updateContext = null;\n  }\n}\nconst keywords$1 = new Map();\nfunction createKeyword(name, options = {}) {\n  options.keyword = name;\n  const token = createToken(name, options);\n  keywords$1.set(name, token);\n  return token;\n}\nfunction createBinop(name, binop) {\n  return createToken(name, {\n    beforeExpr,\n    binop\n  });\n}\nlet tokenTypeCounter = -1;\nconst tokenTypes = [];\nconst tokenLabels = [];\nconst tokenBinops = [];\nconst tokenBeforeExprs = [];\nconst tokenStartsExprs = [];\nconst tokenPrefixes = [];\nfunction createToken(name, options = {}) {\n  var _options$binop, _options$beforeExpr, _options$startsExpr, _options$prefix;\n  ++tokenTypeCounter;\n  tokenLabels.push(name);\n  tokenBinops.push((_options$binop = options.binop) != null ? _options$binop : -1);\n  tokenBeforeExprs.push((_options$beforeExpr = options.beforeExpr) != null ? _options$beforeExpr : false);\n  tokenStartsExprs.push((_options$startsExpr = options.startsExpr) != null ? _options$startsExpr : false);\n  tokenPrefixes.push((_options$prefix = options.prefix) != null ? _options$prefix : false);\n  tokenTypes.push(new ExportedTokenType(name, options));\n  return tokenTypeCounter;\n}\nfunction createKeywordLike(name, options = {}) {\n  var _options$binop2, _options$beforeExpr2, _options$startsExpr2, _options$prefix2;\n  ++tokenTypeCounter;\n  keywords$1.set(name, tokenTypeCounter);\n  tokenLabels.push(name);\n  tokenBinops.push((_options$binop2 = options.binop) != null ? _options$binop2 : -1);\n  tokenBeforeExprs.push((_options$beforeExpr2 = options.beforeExpr) != null ? _options$beforeExpr2 : false);\n  tokenStartsExprs.push((_options$startsExpr2 = options.startsExpr) != null ? _options$startsExpr2 : false);\n  tokenPrefixes.push((_options$prefix2 = options.prefix) != null ? _options$prefix2 : false);\n  tokenTypes.push(new ExportedTokenType(\"name\", options));\n  return tokenTypeCounter;\n}\nconst tt = {\n  bracketL: createToken(\"[\", {\n    beforeExpr,\n    startsExpr\n  }),\n  bracketHashL: createToken(\"#[\", {\n    beforeExpr,\n    startsExpr\n  }),\n  bracketBarL: createToken(\"[|\", {\n    beforeExpr,\n    startsExpr\n  }),\n  bracketR: createToken(\"]\"),\n  bracketBarR: createToken(\"|]\"),\n  braceL: createToken(\"{\", {\n    beforeExpr,\n    startsExpr\n  }),\n  braceBarL: createToken(\"{|\", {\n    beforeExpr,\n    startsExpr\n  }),\n  braceHashL: createToken(\"#{\", {\n    beforeExpr,\n    startsExpr\n  }),\n  braceR: createToken(\"}\"),\n  braceBarR: createToken(\"|}\"),\n  parenL: createToken(\"(\", {\n    beforeExpr,\n    startsExpr\n  }),\n  parenR: createToken(\")\"),\n  comma: createToken(\",\", {\n    beforeExpr\n  }),\n  semi: createToken(\";\", {\n    beforeExpr\n  }),\n  colon: createToken(\":\", {\n    beforeExpr\n  }),\n  doubleColon: createToken(\"::\", {\n    beforeExpr\n  }),\n  dot: createToken(\".\"),\n  question: createToken(\"?\", {\n    beforeExpr\n  }),\n  questionDot: createToken(\"?.\"),\n  arrow: createToken(\"=>\", {\n    beforeExpr\n  }),\n  template: createToken(\"template\"),\n  ellipsis: createToken(\"...\", {\n    beforeExpr\n  }),\n  backQuote: createToken(\"`\", {\n    startsExpr\n  }),\n  dollarBraceL: createToken(\"${\", {\n    beforeExpr,\n    startsExpr\n  }),\n  templateTail: createToken(\"...`\", {\n    startsExpr\n  }),\n  templateNonTail: createToken(\"...${\", {\n    beforeExpr,\n    startsExpr\n  }),\n  at: createToken(\"@\"),\n  hash: createToken(\"#\", {\n    startsExpr\n  }),\n  interpreterDirective: createToken(\"#!...\"),\n  eq: createToken(\"=\", {\n    beforeExpr,\n    isAssign\n  }),\n  assign: createToken(\"_=\", {\n    beforeExpr,\n    isAssign\n  }),\n  slashAssign: createToken(\"_=\", {\n    beforeExpr,\n    isAssign\n  }),\n  xorAssign: createToken(\"_=\", {\n    beforeExpr,\n    isAssign\n  }),\n  moduloAssign: createToken(\"_=\", {\n    beforeExpr,\n    isAssign\n  }),\n  incDec: createToken(\"++/--\", {\n    prefix,\n    postfix,\n    startsExpr\n  }),\n  bang: createToken(\"!\", {\n    beforeExpr,\n    prefix,\n    startsExpr\n  }),\n  tilde: createToken(\"~\", {\n    beforeExpr,\n    prefix,\n    startsExpr\n  }),\n  doubleCaret: createToken(\"^^\", {\n    startsExpr\n  }),\n  doubleAt: createToken(\"@@\", {\n    startsExpr\n  }),\n  pipeline: createBinop(\"|>\", 0),\n  nullishCoalescing: createBinop(\"??\", 1),\n  logicalOR: createBinop(\"||\", 1),\n  logicalAND: createBinop(\"&&\", 2),\n  bitwiseOR: createBinop(\"|\", 3),\n  bitwiseXOR: createBinop(\"^\", 4),\n  bitwiseAND: createBinop(\"&\", 5),\n  equality: createBinop(\"==/!=/===/!==\", 6),\n  lt: createBinop(\"</>/<=/>=\", 7),\n  gt: createBinop(\"</>/<=/>=\", 7),\n  relational: createBinop(\"</>/<=/>=\", 7),\n  bitShift: createBinop(\"<</>>/>>>\", 8),\n  bitShiftL: createBinop(\"<</>>/>>>\", 8),\n  bitShiftR: createBinop(\"<</>>/>>>\", 8),\n  plusMin: createToken(\"+/-\", {\n    beforeExpr,\n    binop: 9,\n    prefix,\n    startsExpr\n  }),\n  modulo: createToken(\"%\", {\n    binop: 10,\n    startsExpr\n  }),\n  star: createToken(\"*\", {\n    binop: 10\n  }),\n  slash: createBinop(\"/\", 10),\n  exponent: createToken(\"**\", {\n    beforeExpr,\n    binop: 11,\n    rightAssociative: true\n  }),\n  _in: createKeyword(\"in\", {\n    beforeExpr,\n    binop: 7\n  }),\n  _instanceof: createKeyword(\"instanceof\", {\n    beforeExpr,\n    binop: 7\n  }),\n  _break: createKeyword(\"break\"),\n  _case: createKeyword(\"case\", {\n    beforeExpr\n  }),\n  _catch: createKeyword(\"catch\"),\n  _continue: createKeyword(\"continue\"),\n  _debugger: createKeyword(\"debugger\"),\n  _default: createKeyword(\"default\", {\n    beforeExpr\n  }),\n  _else: createKeyword(\"else\", {\n    beforeExpr\n  }),\n  _finally: createKeyword(\"finally\"),\n  _function: createKeyword(\"function\", {\n    startsExpr\n  }),\n  _if: createKeyword(\"if\"),\n  _return: createKeyword(\"return\", {\n    beforeExpr\n  }),\n  _switch: createKeyword(\"switch\"),\n  _throw: createKeyword(\"throw\", {\n    beforeExpr,\n    prefix,\n    startsExpr\n  }),\n  _try: createKeyword(\"try\"),\n  _var: createKeyword(\"var\"),\n  _const: createKeyword(\"const\"),\n  _with: createKeyword(\"with\"),\n  _new: createKeyword(\"new\", {\n    beforeExpr,\n    startsExpr\n  }),\n  _this: createKeyword(\"this\", {\n    startsExpr\n  }),\n  _super: createKeyword(\"super\", {\n    startsExpr\n  }),\n  _class: createKeyword(\"class\", {\n    startsExpr\n  }),\n  _extends: createKeyword(\"extends\", {\n    beforeExpr\n  }),\n  _export: createKeyword(\"export\"),\n  _import: createKeyword(\"import\", {\n    startsExpr\n  }),\n  _null: createKeyword(\"null\", {\n    startsExpr\n  }),\n  _true: createKeyword(\"true\", {\n    startsExpr\n  }),\n  _false: createKeyword(\"false\", {\n    startsExpr\n  }),\n  _typeof: createKeyword(\"typeof\", {\n    beforeExpr,\n    prefix,\n    startsExpr\n  }),\n  _void: createKeyword(\"void\", {\n    beforeExpr,\n    prefix,\n    startsExpr\n  }),\n  _delete: createKeyword(\"delete\", {\n    beforeExpr,\n    prefix,\n    startsExpr\n  }),\n  _do: createKeyword(\"do\", {\n    isLoop,\n    beforeExpr\n  }),\n  _for: createKeyword(\"for\", {\n    isLoop\n  }),\n  _while: createKeyword(\"while\", {\n    isLoop\n  }),\n  _as: createKeywordLike(\"as\", {\n    startsExpr\n  }),\n  _assert: createKeywordLike(\"assert\", {\n    startsExpr\n  }),\n  _async: createKeywordLike(\"async\", {\n    startsExpr\n  }),\n  _await: createKeywordLike(\"await\", {\n    startsExpr\n  }),\n  _defer: createKeywordLike(\"defer\", {\n    startsExpr\n  }),\n  _from: createKeywordLike(\"from\", {\n    startsExpr\n  }),\n  _get: createKeywordLike(\"get\", {\n    startsExpr\n  }),\n  _let: createKeywordLike(\"let\", {\n    startsExpr\n  }),\n  _meta: createKeywordLike(\"meta\", {\n    startsExpr\n  }),\n  _of: createKeywordLike(\"of\", {\n    startsExpr\n  }),\n  _sent: createKeywordLike(\"sent\", {\n    startsExpr\n  }),\n  _set: createKeywordLike(\"set\", {\n    startsExpr\n  }),\n  _source: createKeywordLike(\"source\", {\n    startsExpr\n  }),\n  _static: createKeywordLike(\"static\", {\n    startsExpr\n  }),\n  _using: createKeywordLike(\"using\", {\n    startsExpr\n  }),\n  _yield: createKeywordLike(\"yield\", {\n    startsExpr\n  }),\n  _asserts: createKeywordLike(\"asserts\", {\n    startsExpr\n  }),\n  _checks: createKeywordLike(\"checks\", {\n    startsExpr\n  }),\n  _exports: createKeywordLike(\"exports\", {\n    startsExpr\n  }),\n  _global: createKeywordLike(\"global\", {\n    startsExpr\n  }),\n  _implements: createKeywordLike(\"implements\", {\n    startsExpr\n  }),\n  _intrinsic: createKeywordLike(\"intrinsic\", {\n    startsExpr\n  }),\n  _infer: createKeywordLike(\"infer\", {\n    startsExpr\n  }),\n  _is: createKeywordLike(\"is\", {\n    startsExpr\n  }),\n  _mixins: createKeywordLike(\"mixins\", {\n    startsExpr\n  }),\n  _proto: createKeywordLike(\"proto\", {\n    startsExpr\n  }),\n  _require: createKeywordLike(\"require\", {\n    startsExpr\n  }),\n  _satisfies: createKeywordLike(\"satisfies\", {\n    startsExpr\n  }),\n  _keyof: createKeywordLike(\"keyof\", {\n    startsExpr\n  }),\n  _readonly: createKeywordLike(\"readonly\", {\n    startsExpr\n  }),\n  _unique: createKeywordLike(\"unique\", {\n    startsExpr\n  }),\n  _abstract: createKeywordLike(\"abstract\", {\n    startsExpr\n  }),\n  _declare: createKeywordLike(\"declare\", {\n    startsExpr\n  }),\n  _enum: createKeywordLike(\"enum\", {\n    startsExpr\n  }),\n  _module: createKeywordLike(\"module\", {\n    startsExpr\n  }),\n  _namespace: createKeywordLike(\"namespace\", {\n    startsExpr\n  }),\n  _interface: createKeywordLike(\"interface\", {\n    startsExpr\n  }),\n  _type: createKeywordLike(\"type\", {\n    startsExpr\n  }),\n  _opaque: createKeywordLike(\"opaque\", {\n    startsExpr\n  }),\n  name: createToken(\"name\", {\n    startsExpr\n  }),\n  placeholder: createToken(\"%%\", {\n    startsExpr\n  }),\n  string: createToken(\"string\", {\n    startsExpr\n  }),\n  num: createToken(\"num\", {\n    startsExpr\n  }),\n  bigint: createToken(\"bigint\", {\n    startsExpr\n  }),\n  decimal: createToken(\"decimal\", {\n    startsExpr\n  }),\n  regexp: createToken(\"regexp\", {\n    startsExpr\n  }),\n  privateName: createToken(\"#name\", {\n    startsExpr\n  }),\n  eof: createToken(\"eof\"),\n  jsxName: createToken(\"jsxName\"),\n  jsxText: createToken(\"jsxText\", {\n    beforeExpr\n  }),\n  jsxTagStart: createToken(\"jsxTagStart\", {\n    startsExpr\n  }),\n  jsxTagEnd: createToken(\"jsxTagEnd\")\n};\nfunction tokenIsIdentifier(token) {\n  return token >= 93 && token <= 133;\n}\nfunction tokenKeywordOrIdentifierIsKeyword(token) {\n  return token <= 92;\n}\nfunction tokenIsKeywordOrIdentifier(token) {\n  return token >= 58 && token <= 133;\n}\nfunction tokenIsLiteralPropertyName(token) {\n  return token >= 58 && token <= 137;\n}\nfunction tokenComesBeforeExpression(token) {\n  return tokenBeforeExprs[token];\n}\nfunction tokenCanStartExpression(token) {\n  return tokenStartsExprs[token];\n}\nfunction tokenIsAssignment(token) {\n  return token >= 29 && token <= 33;\n}\nfunction tokenIsFlowInterfaceOrTypeOrOpaque(token) {\n  return token >= 129 && token <= 131;\n}\nfunction tokenIsLoop(token) {\n  return token >= 90 && token <= 92;\n}\nfunction tokenIsKeyword(token) {\n  return token >= 58 && token <= 92;\n}\nfunction tokenIsOperator(token) {\n  return token >= 39 && token <= 59;\n}\nfunction tokenIsPostfix(token) {\n  return token === 34;\n}\nfunction tokenIsPrefix(token) {\n  return tokenPrefixes[token];\n}\nfunction tokenIsTSTypeOperator(token) {\n  return token >= 121 && token <= 123;\n}\nfunction tokenIsTSDeclarationStart(token) {\n  return token >= 124 && token <= 130;\n}\nfunction tokenLabelName(token) {\n  return tokenLabels[token];\n}\nfunction tokenOperatorPrecedence(token) {\n  return tokenBinops[token];\n}\nfunction tokenIsRightAssociative(token) {\n  return token === 57;\n}\nfunction tokenIsTemplate(token) {\n  return token >= 24 && token <= 25;\n}\nfunction getExportedToken(token) {\n  return tokenTypes[token];\n}\ntokenTypes[8].updateContext = context => {\n  context.pop();\n};\ntokenTypes[5].updateContext = tokenTypes[7].updateContext = tokenTypes[23].updateContext = context => {\n  context.push(types.brace);\n};\ntokenTypes[22].updateContext = context => {\n  if (context[context.length - 1] === types.template) {\n    context.pop();\n  } else {\n    context.push(types.template);\n  }\n};\ntokenTypes[143].updateContext = context => {\n  context.push(types.j_expr, types.j_oTag);\n};\nlet nonASCIIidentifierStartChars = \"\\xaa\\xb5\\xba\\xc0-\\xd6\\xd8-\\xf6\\xf8-\\u02c1\\u02c6-\\u02d1\\u02e0-\\u02e4\\u02ec\\u02ee\\u0370-\\u0374\\u0376\\u0377\\u037a-\\u037d\\u037f\\u0386\\u0388-\\u038a\\u038c\\u038e-\\u03a1\\u03a3-\\u03f5\\u03f7-\\u0481\\u048a-\\u052f\\u0531-\\u0556\\u0559\\u0560-\\u0588\\u05d0-\\u05ea\\u05ef-\\u05f2\\u0620-\\u064a\\u066e\\u066f\\u0671-\\u06d3\\u06d5\\u06e5\\u06e6\\u06ee\\u06ef\\u06fa-\\u06fc\\u06ff\\u0710\\u0712-\\u072f\\u074d-\\u07a5\\u07b1\\u07ca-\\u07ea\\u07f4\\u07f5\\u07fa\\u0800-\\u0815\\u081a\\u0824\\u0828\\u0840-\\u0858\\u0860-\\u086a\\u0870-\\u0887\\u0889-\\u088f\\u08a0-\\u08c9\\u0904-\\u0939\\u093d\\u0950\\u0958-\\u0961\\u0971-\\u0980\\u0985-\\u098c\\u098f\\u0990\\u0993-\\u09a8\\u09aa-\\u09b0\\u09b2\\u09b6-\\u09b9\\u09bd\\u09ce\\u09dc\\u09dd\\u09df-\\u09e1\\u09f0\\u09f1\\u09fc\\u0a05-\\u0a0a\\u0a0f\\u0a10\\u0a13-\\u0a28\\u0a2a-\\u0a30\\u0a32\\u0a33\\u0a35\\u0a36\\u0a38\\u0a39\\u0a59-\\u0a5c\\u0a5e\\u0a72-\\u0a74\\u0a85-\\u0a8d\\u0a8f-\\u0a91\\u0a93-\\u0aa8\\u0aaa-\\u0ab0\\u0ab2\\u0ab3\\u0ab5-\\u0ab9\\u0abd\\u0ad0\\u0ae0\\u0ae1\\u0af9\\u0b05-\\u0b0c\\u0b0f\\u0b10\\u0b13-\\u0b28\\u0b2a-\\u0b30\\u0b32\\u0b33\\u0b35-\\u0b39\\u0b3d\\u0b5c\\u0b5d\\u0b5f-\\u0b61\\u0b71\\u0b83\\u0b85-\\u0b8a\\u0b8e-\\u0b90\\u0b92-\\u0b95\\u0b99\\u0b9a\\u0b9c\\u0b9e\\u0b9f\\u0ba3\\u0ba4\\u0ba8-\\u0baa\\u0bae-\\u0bb9\\u0bd0\\u0c05-\\u0c0c\\u0c0e-\\u0c10\\u0c12-\\u0c28\\u0c2a-\\u0c39\\u0c3d\\u0c58-\\u0c5a\\u0c5c\\u0c5d\\u0c60\\u0c61\\u0c80\\u0c85-\\u0c8c\\u0c8e-\\u0c90\\u0c92-\\u0ca8\\u0caa-\\u0cb3\\u0cb5-\\u0cb9\\u0cbd\\u0cdc-\\u0cde\\u0ce0\\u0ce1\\u0cf1\\u0cf2\\u0d04-\\u0d0c\\u0d0e-\\u0d10\\u0d12-\\u0d3a\\u0d3d\\u0d4e\\u0d54-\\u0d56\\u0d5f-\\u0d61\\u0d7a-\\u0d7f\\u0d85-\\u0d96\\u0d9a-\\u0db1\\u0db3-\\u0dbb\\u0dbd\\u0dc0-\\u0dc6\\u0e01-\\u0e30\\u0e32\\u0e33\\u0e40-\\u0e46\\u0e81\\u0e82\\u0e84\\u0e86-\\u0e8a\\u0e8c-\\u0ea3\\u0ea5\\u0ea7-\\u0eb0\\u0eb2\\u0eb3\\u0ebd\\u0ec0-\\u0ec4\\u0ec6\\u0edc-\\u0edf\\u0f00\\u0f40-\\u0f47\\u0f49-\\u0f6c\\u0f88-\\u0f8c\\u1000-\\u102a\\u103f\\u1050-\\u1055\\u105a-\\u105d\\u1061\\u1065\\u1066\\u106e-\\u1070\\u1075-\\u1081\\u108e\\u10a0-\\u10c5\\u10c7\\u10cd\\u10d0-\\u10fa\\u10fc-\\u1248\\u124a-\\u124d\\u1250-\\u1256\\u1258\\u125a-\\u125d\\u1260-\\u1288\\u128a-\\u128d\\u1290-\\u12b0\\u12b2-\\u12b5\\u12b8-\\u12be\\u12c0\\u12c2-\\u12c5\\u12c8-\\u12d6\\u12d8-\\u1310\\u1312-\\u1315\\u1318-\\u135a\\u1380-\\u138f\\u13a0-\\u13f5\\u13f8-\\u13fd\\u1401-\\u166c\\u166f-\\u167f\\u1681-\\u169a\\u16a0-\\u16ea\\u16ee-\\u16f8\\u1700-\\u1711\\u171f-\\u1731\\u1740-\\u1751\\u1760-\\u176c\\u176e-\\u1770\\u1780-\\u17b3\\u17d7\\u17dc\\u1820-\\u1878\\u1880-\\u18a8\\u18aa\\u18b0-\\u18f5\\u1900-\\u191e\\u1950-\\u196d\\u1970-\\u1974\\u1980-\\u19ab\\u19b0-\\u19c9\\u1a00-\\u1a16\\u1a20-\\u1a54\\u1aa7\\u1b05-\\u1b33\\u1b45-\\u1b4c\\u1b83-\\u1ba0\\u1bae\\u1baf\\u1bba-\\u1be5\\u1c00-\\u1c23\\u1c4d-\\u1c4f\\u1c5a-\\u1c7d\\u1c80-\\u1c8a\\u1c90-\\u1cba\\u1cbd-\\u1cbf\\u1ce9-\\u1cec\\u1cee-\\u1cf3\\u1cf5\\u1cf6\\u1cfa\\u1d00-\\u1dbf\\u1e00-\\u1f15\\u1f18-\\u1f1d\\u1f20-\\u1f45\\u1f48-\\u1f4d\\u1f50-\\u1f57\\u1f59\\u1f5b\\u1f5d\\u1f5f-\\u1f7d\\u1f80-\\u1fb4\\u1fb6-\\u1fbc\\u1fbe\\u1fc2-\\u1fc4\\u1fc6-\\u1fcc\\u1fd0-\\u1fd3\\u1fd6-\\u1fdb\\u1fe0-\\u1fec\\u1ff2-\\u1ff4\\u1ff6-\\u1ffc\\u2071\\u207f\\u2090-\\u209c\\u2102\\u2107\\u210a-\\u2113\\u2115\\u2118-\\u211d\\u2124\\u2126\\u2128\\u212a-\\u2139\\u213c-\\u213f\\u2145-\\u2149\\u214e\\u2160-\\u2188\\u2c00-\\u2ce4\\u2ceb-\\u2cee\\u2cf2\\u2cf3\\u2d00-\\u2d25\\u2d27\\u2d2d\\u2d30-\\u2d67\\u2d6f\\u2d80-\\u2d96\\u2da0-\\u2da6\\u2da8-\\u2dae\\u2db0-\\u2db6\\u2db8-\\u2dbe\\u2dc0-\\u2dc6\\u2dc8-\\u2dce\\u2dd0-\\u2dd6\\u2dd8-\\u2dde\\u3005-\\u3007\\u3021-\\u3029\\u3031-\\u3035\\u3038-\\u303c\\u3041-\\u3096\\u309b-\\u309f\\u30a1-\\u30fa\\u30fc-\\u30ff\\u3105-\\u312f\\u3131-\\u318e\\u31a0-\\u31bf\\u31f0-\\u31ff\\u3400-\\u4dbf\\u4e00-\\ua48c\\ua4d0-\\ua4fd\\ua500-\\ua60c\\ua610-\\ua61f\\ua62a\\ua62b\\ua640-\\ua66e\\ua67f-\\ua69d\\ua6a0-\\ua6ef\\ua717-\\ua71f\\ua722-\\ua788\\ua78b-\\ua7dc\\ua7f1-\\ua801\\ua803-\\ua805\\ua807-\\ua80a\\ua80c-\\ua822\\ua840-\\ua873\\ua882-\\ua8b3\\ua8f2-\\ua8f7\\ua8fb\\ua8fd\\ua8fe\\ua90a-\\ua925\\ua930-\\ua946\\ua960-\\ua97c\\ua984-\\ua9b2\\ua9cf\\ua9e0-\\ua9e4\\ua9e6-\\ua9ef\\ua9fa-\\ua9fe\\uaa00-\\uaa28\\uaa40-\\uaa42\\uaa44-\\uaa4b\\uaa60-\\uaa76\\uaa7a\\uaa7e-\\uaaaf\\uaab1\\uaab5\\uaab6\\uaab9-\\uaabd\\uaac0\\uaac2\\uaadb-\\uaadd\\uaae0-\\uaaea\\uaaf2-\\uaaf4\\uab01-\\uab06\\uab09-\\uab0e\\uab11-\\uab16\\uab20-\\uab26\\uab28-\\uab2e\\uab30-\\uab5a\\uab5c-\\uab69\\uab70-\\uabe2\\uac00-\\ud7a3\\ud7b0-\\ud7c6\\ud7cb-\\ud7fb\\uf900-\\ufa6d\\ufa70-\\ufad9\\ufb00-\\ufb06\\ufb13-\\ufb17\\ufb1d\\ufb1f-\\ufb28\\ufb2a-\\ufb36\\ufb38-\\ufb3c\\ufb3e\\ufb40\\ufb41\\ufb43\\ufb44\\ufb46-\\ufbb1\\ufbd3-\\ufd3d\\ufd50-\\ufd8f\\ufd92-\\ufdc7\\ufdf0-\\ufdfb\\ufe70-\\ufe74\\ufe76-\\ufefc\\uff21-\\uff3a\\uff41-\\uff5a\\uff66-\\uffbe\\uffc2-\\uffc7\\uffca-\\uffcf\\uffd2-\\uffd7\\uffda-\\uffdc\";\nlet nonASCIIidentifierChars = \"\\xb7\\u0300-\\u036f\\u0387\\u0483-\\u0487\\u0591-\\u05bd\\u05bf\\u05c1\\u05c2\\u05c4\\u05c5\\u05c7\\u0610-\\u061a\\u064b-\\u0669\\u0670\\u06d6-\\u06dc\\u06df-\\u06e4\\u06e7\\u06e8\\u06ea-\\u06ed\\u06f0-\\u06f9\\u0711\\u0730-\\u074a\\u07a6-\\u07b0\\u07c0-\\u07c9\\u07eb-\\u07f3\\u07fd\\u0816-\\u0819\\u081b-\\u0823\\u0825-\\u0827\\u0829-\\u082d\\u0859-\\u085b\\u0897-\\u089f\\u08ca-\\u08e1\\u08e3-\\u0903\\u093a-\\u093c\\u093e-\\u094f\\u0951-\\u0957\\u0962\\u0963\\u0966-\\u096f\\u0981-\\u0983\\u09bc\\u09be-\\u09c4\\u09c7\\u09c8\\u09cb-\\u09cd\\u09d7\\u09e2\\u09e3\\u09e6-\\u09ef\\u09fe\\u0a01-\\u0a03\\u0a3c\\u0a3e-\\u0a42\\u0a47\\u0a48\\u0a4b-\\u0a4d\\u0a51\\u0a66-\\u0a71\\u0a75\\u0a81-\\u0a83\\u0abc\\u0abe-\\u0ac5\\u0ac7-\\u0ac9\\u0acb-\\u0acd\\u0ae2\\u0ae3\\u0ae6-\\u0aef\\u0afa-\\u0aff\\u0b01-\\u0b03\\u0b3c\\u0b3e-\\u0b44\\u0b47\\u0b48\\u0b4b-\\u0b4d\\u0b55-\\u0b57\\u0b62\\u0b63\\u0b66-\\u0b6f\\u0b82\\u0bbe-\\u0bc2\\u0bc6-\\u0bc8\\u0bca-\\u0bcd\\u0bd7\\u0be6-\\u0bef\\u0c00-\\u0c04\\u0c3c\\u0c3e-\\u0c44\\u0c46-\\u0c48\\u0c4a-\\u0c4d\\u0c55\\u0c56\\u0c62\\u0c63\\u0c66-\\u0c6f\\u0c81-\\u0c83\\u0cbc\\u0cbe-\\u0cc4\\u0cc6-\\u0cc8\\u0cca-\\u0ccd\\u0cd5\\u0cd6\\u0ce2\\u0ce3\\u0ce6-\\u0cef\\u0cf3\\u0d00-\\u0d03\\u0d3b\\u0d3c\\u0d3e-\\u0d44\\u0d46-\\u0d48\\u0d4a-\\u0d4d\\u0d57\\u0d62\\u0d63\\u0d66-\\u0d6f\\u0d81-\\u0d83\\u0dca\\u0dcf-\\u0dd4\\u0dd6\\u0dd8-\\u0ddf\\u0de6-\\u0def\\u0df2\\u0df3\\u0e31\\u0e34-\\u0e3a\\u0e47-\\u0e4e\\u0e50-\\u0e59\\u0eb1\\u0eb4-\\u0ebc\\u0ec8-\\u0ece\\u0ed0-\\u0ed9\\u0f18\\u0f19\\u0f20-\\u0f29\\u0f35\\u0f37\\u0f39\\u0f3e\\u0f3f\\u0f71-\\u0f84\\u0f86\\u0f87\\u0f8d-\\u0f97\\u0f99-\\u0fbc\\u0fc6\\u102b-\\u103e\\u1040-\\u1049\\u1056-\\u1059\\u105e-\\u1060\\u1062-\\u1064\\u1067-\\u106d\\u1071-\\u1074\\u1082-\\u108d\\u108f-\\u109d\\u135d-\\u135f\\u1369-\\u1371\\u1712-\\u1715\\u1732-\\u1734\\u1752\\u1753\\u1772\\u1773\\u17b4-\\u17d3\\u17dd\\u17e0-\\u17e9\\u180b-\\u180d\\u180f-\\u1819\\u18a9\\u1920-\\u192b\\u1930-\\u193b\\u1946-\\u194f\\u19d0-\\u19da\\u1a17-\\u1a1b\\u1a55-\\u1a5e\\u1a60-\\u1a7c\\u1a7f-\\u1a89\\u1a90-\\u1a99\\u1ab0-\\u1abd\\u1abf-\\u1add\\u1ae0-\\u1aeb\\u1b00-\\u1b04\\u1b34-\\u1b44\\u1b50-\\u1b59\\u1b6b-\\u1b73\\u1b80-\\u1b82\\u1ba1-\\u1bad\\u1bb0-\\u1bb9\\u1be6-\\u1bf3\\u1c24-\\u1c37\\u1c40-\\u1c49\\u1c50-\\u1c59\\u1cd0-\\u1cd2\\u1cd4-\\u1ce8\\u1ced\\u1cf4\\u1cf7-\\u1cf9\\u1dc0-\\u1dff\\u200c\\u200d\\u203f\\u2040\\u2054\\u20d0-\\u20dc\\u20e1\\u20e5-\\u20f0\\u2cef-\\u2cf1\\u2d7f\\u2de0-\\u2dff\\u302a-\\u302f\\u3099\\u309a\\u30fb\\ua620-\\ua629\\ua66f\\ua674-\\ua67d\\ua69e\\ua69f\\ua6f0\\ua6f1\\ua802\\ua806\\ua80b\\ua823-\\ua827\\ua82c\\ua880\\ua881\\ua8b4-\\ua8c5\\ua8d0-\\ua8d9\\ua8e0-\\ua8f1\\ua8ff-\\ua909\\ua926-\\ua92d\\ua947-\\ua953\\ua980-\\ua983\\ua9b3-\\ua9c0\\ua9d0-\\ua9d9\\ua9e5\\ua9f0-\\ua9f9\\uaa29-\\uaa36\\uaa43\\uaa4c\\uaa4d\\uaa50-\\uaa59\\uaa7b-\\uaa7d\\uaab0\\uaab2-\\uaab4\\uaab7\\uaab8\\uaabe\\uaabf\\uaac1\\uaaeb-\\uaaef\\uaaf5\\uaaf6\\uabe3-\\uabea\\uabec\\uabed\\uabf0-\\uabf9\\ufb1e\\ufe00-\\ufe0f\\ufe20-\\ufe2f\\ufe33\\ufe34\\ufe4d-\\ufe4f\\uff10-\\uff19\\uff3f\\uff65\";\nconst nonASCIIidentifierStart = new RegExp(\"[\" + nonASCIIidentifierStartChars + \"]\");\nconst nonASCIIidentifier = new RegExp(\"[\" + nonASCIIidentifierStartChars + nonASCIIidentifierChars + \"]\");\nnonASCIIidentifierStartChars = nonASCIIidentifierChars = null;\nconst astralIdentifierStartCodes = [0, 11, 2, 25, 2, 18, 2, 1, 2, 14, 3, 13, 35, 122, 70, 52, 268, 28, 4, 48, 48, 31, 14, 29, 6, 37, 11, 29, 3, 35, 5, 7, 2, 4, 43, 157, 19, 35, 5, 35, 5, 39, 9, 51, 13, 10, 2, 14, 2, 6, 2, 1, 2, 10, 2, 14, 2, 6, 2, 1, 4, 51, 13, 310, 10, 21, 11, 7, 25, 5, 2, 41, 2, 8, 70, 5, 3, 0, 2, 43, 2, 1, 4, 0, 3, 22, 11, 22, 10, 30, 66, 18, 2, 1, 11, 21, 11, 25, 7, 25, 39, 55, 7, 1, 65, 0, 16, 3, 2, 2, 2, 28, 43, 28, 4, 28, 36, 7, 2, 27, 28, 53, 11, 21, 11, 18, 14, 17, 111, 72, 56, 50, 14, 50, 14, 35, 39, 27, 10, 22, 251, 41, 7, 1, 17, 5, 57, 28, 11, 0, 9, 21, 43, 17, 47, 20, 28, 22, 13, 52, 58, 1, 3, 0, 14, 44, 33, 24, 27, 35, 30, 0, 3, 0, 9, 34, 4, 0, 13, 47, 15, 3, 22, 0, 2, 0, 36, 17, 2, 24, 20, 1, 64, 6, 2, 0, 2, 3, 2, 14, 2, 9, 8, 46, 39, 7, 3, 1, 3, 21, 2, 6, 2, 1, 2, 4, 4, 0, 19, 0, 13, 4, 31, 9, 2, 0, 3, 0, 2, 37, 2, 0, 26, 0, 2, 0, 45, 52, 19, 3, 21, 2, 31, 47, 21, 1, 2, 0, 185, 46, 42, 3, 37, 47, 21, 0, 60, 42, 14, 0, 72, 26, 38, 6, 186, 43, 117, 63, 32, 7, 3, 0, 3, 7, 2, 1, 2, 23, 16, 0, 2, 0, 95, 7, 3, 38, 17, 0, 2, 0, 29, 0, 11, 39, 8, 0, 22, 0, 12, 45, 20, 0, 19, 72, 200, 32, 32, 8, 2, 36, 18, 0, 50, 29, 113, 6, 2, 1, 2, 37, 22, 0, 26, 5, 2, 1, 2, 31, 15, 0, 24, 43, 261, 18, 16, 0, 2, 12, 2, 33, 125, 0, 80, 921, 103, 110, 18, 195, 2637, 96, 16, 1071, 18, 5, 26, 3994, 6, 582, 6842, 29, 1763, 568, 8, 30, 18, 78, 18, 29, 19, 47, 17, 3, 32, 20, 6, 18, 433, 44, 212, 63, 33, 24, 3, 24, 45, 74, 6, 0, 67, 12, 65, 1, 2, 0, 15, 4, 10, 7381, 42, 31, 98, 114, 8702, 3, 2, 6, 2, 1, 2, 290, 16, 0, 30, 2, 3, 0, 15, 3, 9, 395, 2309, 106, 6, 12, 4, 8, 8, 9, 5991, 84, 2, 70, 2, 1, 3, 0, 3, 1, 3, 3, 2, 11, 2, 0, 2, 6, 2, 64, 2, 3, 3, 7, 2, 6, 2, 27, 2, 3, 2, 4, 2, 0, 4, 6, 2, 339, 3, 24, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 7, 1845, 30, 7, 5, 262, 61, 147, 44, 11, 6, 17, 0, 322, 29, 19, 43, 485, 27, 229, 29, 3, 0, 208, 30, 2, 2, 2, 1, 2, 6, 3, 4, 10, 1, 225, 6, 2, 3, 2, 1, 2, 14, 2, 196, 60, 67, 8, 0, 1205, 3, 2, 26, 2, 1, 2, 0, 3, 0, 2, 9, 2, 3, 2, 0, 2, 0, 7, 0, 5, 0, 2, 0, 2, 0, 2, 2, 2, 1, 2, 0, 3, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 1, 2, 0, 3, 3, 2, 6, 2, 3, 2, 3, 2, 0, 2, 9, 2, 16, 6, 2, 2, 4, 2, 16, 4421, 42719, 33, 4381, 3, 5773, 3, 7472, 16, 621, 2467, 541, 1507, 4938, 6, 8489];\nconst astralIdentifierCodes = [509, 0, 227, 0, 150, 4, 294, 9, 1368, 2, 2, 1, 6, 3, 41, 2, 5, 0, 166, 1, 574, 3, 9, 9, 7, 9, 32, 4, 318, 1, 78, 5, 71, 10, 50, 3, 123, 2, 54, 14, 32, 10, 3, 1, 11, 3, 46, 10, 8, 0, 46, 9, 7, 2, 37, 13, 2, 9, 6, 1, 45, 0, 13, 2, 49, 13, 9, 3, 2, 11, 83, 11, 7, 0, 3, 0, 158, 11, 6, 9, 7, 3, 56, 1, 2, 6, 3, 1, 3, 2, 10, 0, 11, 1, 3, 6, 4, 4, 68, 8, 2, 0, 3, 0, 2, 3, 2, 4, 2, 0, 15, 1, 83, 17, 10, 9, 5, 0, 82, 19, 13, 9, 214, 6, 3, 8, 28, 1, 83, 16, 16, 9, 82, 12, 9, 9, 7, 19, 58, 14, 5, 9, 243, 14, 166, 9, 71, 5, 2, 1, 3, 3, 2, 0, 2, 1, 13, 9, 120, 6, 3, 6, 4, 0, 29, 9, 41, 6, 2, 3, 9, 0, 10, 10, 47, 15, 199, 7, 137, 9, 54, 7, 2, 7, 17, 9, 57, 21, 2, 13, 123, 5, 4, 0, 2, 1, 2, 6, 2, 0, 9, 9, 49, 4, 2, 1, 2, 4, 9, 9, 55, 9, 266, 3, 10, 1, 2, 0, 49, 6, 4, 4, 14, 10, 5350, 0, 7, 14, 11465, 27, 2343, 9, 87, 9, 39, 4, 60, 6, 26, 9, 535, 9, 470, 0, 2, 54, 8, 3, 82, 0, 12, 1, 19628, 1, 4178, 9, 519, 45, 3, 22, 543, 4, 4, 5, 9, 7, 3, 6, 31, 3, 149, 2, 1418, 49, 513, 54, 5, 49, 9, 0, 15, 0, 23, 4, 2, 14, 1361, 6, 2, 16, 3, 6, 2, 1, 2, 4, 101, 0, 161, 6, 10, 9, 357, 0, 62, 13, 499, 13, 245, 1, 2, 9, 233, 0, 3, 0, 8, 1, 6, 0, 475, 6, 110, 6, 6, 9, 4759, 9, 787719, 239];\nfunction isInAstralSet(code, set) {\n  let pos = 0x10000;\n  for (let i = 0, length = set.length; i < length; i += 2) {\n    pos += set[i];\n    if (pos > code) return false;\n    pos += set[i + 1];\n    if (pos >= code) return true;\n  }\n  return false;\n}\nfunction isIdentifierStart(code) {\n  if (code < 65) return code === 36;\n  if (code <= 90) return true;\n  if (code < 97) return code === 95;\n  if (code <= 122) return true;\n  if (code <= 0xffff) {\n    return code >= 0xaa && nonASCIIidentifierStart.test(String.fromCharCode(code));\n  }\n  return isInAstralSet(code, astralIdentifierStartCodes);\n}\nfunction isIdentifierChar(code) {\n  if (code < 48) return code === 36;\n  if (code < 58) return true;\n  if (code < 65) return false;\n  if (code <= 90) return true;\n  if (code < 97) return code === 95;\n  if (code <= 122) return true;\n  if (code <= 0xffff) {\n    return code >= 0xaa && nonASCIIidentifier.test(String.fromCharCode(code));\n  }\n  return isInAstralSet(code, astralIdentifierStartCodes) || isInAstralSet(code, astralIdentifierCodes);\n}\nconst reservedWords = {\n  keyword: [\"break\", \"case\", \"catch\", \"continue\", \"debugger\", \"default\", \"do\", \"else\", \"finally\", \"for\", \"function\", \"if\", \"return\", \"switch\", \"throw\", \"try\", \"var\", \"const\", \"while\", \"with\", \"new\", \"this\", \"super\", \"class\", \"extends\", \"export\", \"import\", \"null\", \"true\", \"false\", \"in\", \"instanceof\", \"typeof\", \"void\", \"delete\"],\n  strict: [\"implements\", \"interface\", \"let\", \"package\", \"private\", \"protected\", \"public\", \"static\", \"yield\"],\n  strictBind: [\"eval\", \"arguments\"]\n};\nconst keywords = new Set(reservedWords.keyword);\nconst reservedWordsStrictSet = new Set(reservedWords.strict);\nconst reservedWordsStrictBindSet = new Set(reservedWords.strictBind);\nfunction isReservedWord(word, inModule) {\n  return inModule && word === \"await\" || word === \"enum\";\n}\nfunction isStrictReservedWord(word, inModule) {\n  return isReservedWord(word, inModule) || reservedWordsStrictSet.has(word);\n}\nfunction isStrictBindOnlyReservedWord(word) {\n  return reservedWordsStrictBindSet.has(word);\n}\nfunction isStrictBindReservedWord(word, inModule) {\n  return isStrictReservedWord(word, inModule) || isStrictBindOnlyReservedWord(word);\n}\nfunction isKeyword(word) {\n  return keywords.has(word);\n}\nfunction isIteratorStart(current, next, next2) {\n  return current === 64 && next === 64 && isIdentifierStart(next2);\n}\nconst reservedWordLikeSet = new Set([\"break\", \"case\", \"catch\", \"continue\", \"debugger\", \"default\", \"do\", \"else\", \"finally\", \"for\", \"function\", \"if\", \"return\", \"switch\", \"throw\", \"try\", \"var\", \"const\", \"while\", \"with\", \"new\", \"this\", \"super\", \"class\", \"extends\", \"export\", \"import\", \"null\", \"true\", \"false\", \"in\", \"instanceof\", \"typeof\", \"void\", \"delete\", \"implements\", \"interface\", \"let\", \"package\", \"private\", \"protected\", \"public\", \"static\", \"yield\", \"eval\", \"arguments\", \"enum\", \"await\"]);\nfunction canBeReservedWord(word) {\n  return reservedWordLikeSet.has(word);\n}\nclass Scope {\n  constructor(flags) {\n    this.flags = 0;\n    this.names = new Map();\n    this.firstLexicalName = \"\";\n    this.flags = flags;\n  }\n}\nclass ScopeHandler {\n  constructor(parser, inModule) {\n    this.parser = void 0;\n    this.scopeStack = [];\n    this.inModule = void 0;\n    this.undefinedExports = new Map();\n    this.parser = parser;\n    this.inModule = inModule;\n  }\n  get inTopLevel() {\n    return (this.currentScope().flags & 1) > 0;\n  }\n  get inFunction() {\n    return (this.currentVarScopeFlags() & 2) > 0;\n  }\n  get allowSuper() {\n    return (this.currentThisScopeFlags() & 16) > 0;\n  }\n  get allowDirectSuper() {\n    return (this.currentThisScopeFlags() & 32) > 0;\n  }\n  get allowNewTarget() {\n    return (this.currentThisScopeFlags() & 512) > 0;\n  }\n  get inClass() {\n    return (this.currentThisScopeFlags() & 64) > 0;\n  }\n  get inClassAndNotInNonArrowFunction() {\n    const flags = this.currentThisScopeFlags();\n    return (flags & 64) > 0 && (flags & 2) === 0;\n  }\n  get inStaticBlock() {\n    for (let i = this.scopeStack.length - 1;; i--) {\n      const {\n        flags\n      } = this.scopeStack[i];\n      if (flags & 128) {\n        return true;\n      }\n      if (flags & (1667 | 64)) {\n        return false;\n      }\n    }\n  }\n  get inNonArrowFunction() {\n    return (this.currentThisScopeFlags() & 2) > 0;\n  }\n  get inBareCaseStatement() {\n    return (this.currentScope().flags & 256) > 0;\n  }\n  get treatFunctionsAsVar() {\n    return this.treatFunctionsAsVarInScope(this.currentScope());\n  }\n  createScope(flags) {\n    return new Scope(flags);\n  }\n  enter(flags) {\n    this.scopeStack.push(this.createScope(flags));\n  }\n  exit() {\n    const scope = this.scopeStack.pop();\n    return scope.flags;\n  }\n  treatFunctionsAsVarInScope(scope) {\n    return !!(scope.flags & (2 | 128) || !this.parser.inModule && scope.flags & 1);\n  }\n  declareName(name, bindingType, loc) {\n    let scope = this.currentScope();\n    if (bindingType & 8 || bindingType & 16) {\n      this.checkRedeclarationInScope(scope, name, bindingType, loc);\n      let type = scope.names.get(name) || 0;\n      if (bindingType & 16) {\n        type = type | 4;\n      } else {\n        if (!scope.firstLexicalName) {\n          scope.firstLexicalName = name;\n        }\n        type = type | 2;\n      }\n      scope.names.set(name, type);\n      if (bindingType & 8) {\n        this.maybeExportDefined(scope, name);\n      }\n    } else if (bindingType & 4) {\n      for (let i = this.scopeStack.length - 1; i >= 0; --i) {\n        scope = this.scopeStack[i];\n        this.checkRedeclarationInScope(scope, name, bindingType, loc);\n        scope.names.set(name, (scope.names.get(name) || 0) | 1);\n        this.maybeExportDefined(scope, name);\n        if (scope.flags & 1667) break;\n      }\n    }\n    if (this.parser.inModule && scope.flags & 1) {\n      this.undefinedExports.delete(name);\n    }\n  }\n  maybeExportDefined(scope, name) {\n    if (this.parser.inModule && scope.flags & 1) {\n      this.undefinedExports.delete(name);\n    }\n  }\n  checkRedeclarationInScope(scope, name, bindingType, loc) {\n    if (this.isRedeclaredInScope(scope, name, bindingType)) {\n      this.parser.raise(Errors.VarRedeclaration, loc, {\n        identifierName: name\n      });\n    }\n  }\n  isRedeclaredInScope(scope, name, bindingType) {\n    if (!(bindingType & 1)) return false;\n    if (bindingType & 8) {\n      return scope.names.has(name);\n    }\n    const type = scope.names.get(name) || 0;\n    if (bindingType & 16) {\n      return (type & 2) > 0 || !this.treatFunctionsAsVarInScope(scope) && (type & 1) > 0;\n    }\n    return (type & 2) > 0 && !(scope.flags & 8 && scope.firstLexicalName === name) || !this.treatFunctionsAsVarInScope(scope) && (type & 4) > 0;\n  }\n  checkLocalExport(id) {\n    const {\n      name\n    } = id;\n    const topLevelScope = this.scopeStack[0];\n    if (!topLevelScope.names.has(name)) {\n      this.undefinedExports.set(name, id.loc.start);\n    }\n  }\n  currentScope() {\n    return this.scopeStack[this.scopeStack.length - 1];\n  }\n  currentVarScopeFlags() {\n    for (let i = this.scopeStack.length - 1;; i--) {\n      const {\n        flags\n      } = this.scopeStack[i];\n      if (flags & 1667) {\n        return flags;\n      }\n    }\n  }\n  currentThisScopeFlags() {\n    for (let i = this.scopeStack.length - 1;; i--) {\n      const {\n        flags\n      } = this.scopeStack[i];\n      if (flags & (1667 | 64) && !(flags & 4)) {\n        return flags;\n      }\n    }\n  }\n}\nclass FlowScope extends Scope {\n  constructor(...args) {\n    super(...args);\n    this.declareFunctions = new Set();\n  }\n}\nclass FlowScopeHandler extends ScopeHandler {\n  createScope(flags) {\n    return new FlowScope(flags);\n  }\n  declareName(name, bindingType, loc) {\n    const scope = this.currentScope();\n    if (bindingType & 2048) {\n      this.checkRedeclarationInScope(scope, name, bindingType, loc);\n      this.maybeExportDefined(scope, name);\n      scope.declareFunctions.add(name);\n      return;\n    }\n    super.declareName(name, bindingType, loc);\n  }\n  isRedeclaredInScope(scope, name, bindingType) {\n    if (super.isRedeclaredInScope(scope, name, bindingType)) return true;\n    if (bindingType & 2048 && !scope.declareFunctions.has(name)) {\n      const type = scope.names.get(name);\n      return (type & 4) > 0 || (type & 2) > 0;\n    }\n    return false;\n  }\n  checkLocalExport(id) {\n    if (!this.scopeStack[0].declareFunctions.has(id.name)) {\n      super.checkLocalExport(id);\n    }\n  }\n}\nconst reservedTypes = new Set([\"_\", \"any\", \"bool\", \"boolean\", \"empty\", \"extends\", \"false\", \"interface\", \"mixed\", \"null\", \"number\", \"static\", \"string\", \"true\", \"typeof\", \"void\"]);\nconst FlowErrors = ParseErrorEnum`flow`({\n  AmbiguousConditionalArrow: \"Ambiguous expression: wrap the arrow functions in parentheses to disambiguate.\",\n  AmbiguousDeclareModuleKind: \"Found both `declare module.exports` and `declare export` in the same module. Modules can only have 1 since they are either an ES module or they are a CommonJS module.\",\n  AssignReservedType: ({\n    reservedType\n  }) => `Cannot overwrite reserved type ${reservedType}.`,\n  DeclareClassElement: \"The `declare` modifier can only appear on class fields.\",\n  DeclareClassFieldInitializer: \"Initializers are not allowed in fields with the `declare` modifier.\",\n  DuplicateDeclareModuleExports: \"Duplicate `declare module.exports` statement.\",\n  EnumBooleanMemberNotInitialized: ({\n    memberName,\n    enumName\n  }) => `Boolean enum members need to be initialized. Use either \\`${memberName} = true,\\` or \\`${memberName} = false,\\` in enum \\`${enumName}\\`.`,\n  EnumDuplicateMemberName: ({\n    memberName,\n    enumName\n  }) => `Enum member names need to be unique, but the name \\`${memberName}\\` has already been used before in enum \\`${enumName}\\`.`,\n  EnumInconsistentMemberValues: ({\n    enumName\n  }) => `Enum \\`${enumName}\\` has inconsistent member initializers. Either use no initializers, or consistently use literals (either booleans, numbers, or strings) for all member initializers.`,\n  EnumInvalidExplicitType: ({\n    invalidEnumType,\n    enumName\n  }) => `Enum type \\`${invalidEnumType}\\` is not valid. Use one of \\`boolean\\`, \\`number\\`, \\`string\\`, or \\`symbol\\` in enum \\`${enumName}\\`.`,\n  EnumInvalidExplicitTypeUnknownSupplied: ({\n    enumName\n  }) => `Supplied enum type is not valid. Use one of \\`boolean\\`, \\`number\\`, \\`string\\`, or \\`symbol\\` in enum \\`${enumName}\\`.`,\n  EnumInvalidMemberInitializerPrimaryType: ({\n    enumName,\n    memberName,\n    explicitType\n  }) => `Enum \\`${enumName}\\` has type \\`${explicitType}\\`, so the initializer of \\`${memberName}\\` needs to be a ${explicitType} literal.`,\n  EnumInvalidMemberInitializerSymbolType: ({\n    enumName,\n    memberName\n  }) => `Symbol enum members cannot be initialized. Use \\`${memberName},\\` in enum \\`${enumName}\\`.`,\n  EnumInvalidMemberInitializerUnknownType: ({\n    enumName,\n    memberName\n  }) => `The enum member initializer for \\`${memberName}\\` needs to be a literal (either a boolean, number, or string) in enum \\`${enumName}\\`.`,\n  EnumInvalidMemberName: ({\n    enumName,\n    memberName,\n    suggestion\n  }) => `Enum member names cannot start with lowercase 'a' through 'z'. Instead of using \\`${memberName}\\`, consider using \\`${suggestion}\\`, in enum \\`${enumName}\\`.`,\n  EnumNumberMemberNotInitialized: ({\n    enumName,\n    memberName\n  }) => `Number enum members need to be initialized, e.g. \\`${memberName} = 1\\` in enum \\`${enumName}\\`.`,\n  EnumStringMemberInconsistentlyInitialized: ({\n    enumName\n  }) => `String enum members need to consistently either all use initializers, or use no initializers, in enum \\`${enumName}\\`.`,\n  GetterMayNotHaveThisParam: \"A getter cannot have a `this` parameter.\",\n  ImportReflectionHasImportType: \"An `import module` declaration can not use `type` or `typeof` keyword.\",\n  ImportTypeShorthandOnlyInPureImport: \"The `type` and `typeof` keywords on named imports can only be used on regular `import` statements. It cannot be used with `import type` or `import typeof` statements.\",\n  InexactInsideExact: \"Explicit inexact syntax cannot appear inside an explicit exact object type.\",\n  InexactInsideNonObject: \"Explicit inexact syntax cannot appear in class or interface definitions.\",\n  InexactVariance: \"Explicit inexact syntax cannot have variance.\",\n  InvalidNonTypeImportInDeclareModule: \"Imports within a `declare module` body must always be `import type` or `import typeof`.\",\n  MissingTypeParamDefault: \"Type parameter declaration needs a default, since a preceding type parameter declaration has a default.\",\n  NestedDeclareModule: \"`declare module` cannot be used inside another `declare module`.\",\n  NestedFlowComment: \"Cannot have a flow comment inside another flow comment.\",\n  PatternIsOptional: Object.assign({\n    message: \"A binding pattern parameter cannot be optional in an implementation signature.\"\n  }, {\n    reasonCode: \"OptionalBindingPattern\"\n  }),\n  SetterMayNotHaveThisParam: \"A setter cannot have a `this` parameter.\",\n  SpreadVariance: \"Spread properties cannot have variance.\",\n  ThisParamAnnotationRequired: \"A type annotation is required for the `this` parameter.\",\n  ThisParamBannedInConstructor: \"Constructors cannot have a `this` parameter; constructors don't bind `this` like other functions.\",\n  ThisParamMayNotBeOptional: \"The `this` parameter cannot be optional.\",\n  ThisParamMustBeFirst: \"The `this` parameter must be the first function parameter.\",\n  ThisParamNoDefault: \"The `this` parameter may not have a default value.\",\n  TypeBeforeInitializer: \"Type annotations must come before default assignments, e.g. instead of `age = 25: number` use `age: number = 25`.\",\n  TypeCastInPattern: \"The type cast expression is expected to be wrapped with parenthesis.\",\n  UnexpectedExplicitInexactInObject: \"Explicit inexact syntax must appear at the end of an inexact object.\",\n  UnexpectedReservedType: ({\n    reservedType\n  }) => `Unexpected reserved type ${reservedType}.`,\n  UnexpectedReservedUnderscore: \"`_` is only allowed as a type argument to call or new.\",\n  UnexpectedSpaceBetweenModuloChecks: \"Spaces between `%` and `checks` are not allowed here.\",\n  UnexpectedSpreadType: \"Spread operator cannot appear in class or interface definitions.\",\n  UnexpectedSubtractionOperand: 'Unexpected token, expected \"number\" or \"bigint\".',\n  UnexpectedTokenAfterTypeParameter: \"Expected an arrow function after this type parameter declaration.\",\n  UnexpectedTypeParameterBeforeAsyncArrowFunction: \"Type parameters must come after the async keyword, e.g. instead of `<T> async () => {}`, use `async <T>() => {}`.\",\n  UnsupportedDeclareExportKind: ({\n    unsupportedExportKind,\n    suggestion\n  }) => `\\`declare export ${unsupportedExportKind}\\` is not supported. Use \\`${suggestion}\\` instead.`,\n  UnsupportedStatementInDeclareModule: \"Only declares and type imports are allowed inside declare module.\",\n  UnterminatedFlowComment: \"Unterminated flow-comment.\"\n});\nfunction isEsModuleType(bodyElement) {\n  return bodyElement.type === \"DeclareExportAllDeclaration\" || bodyElement.type === \"DeclareExportDeclaration\" && (!bodyElement.declaration || bodyElement.declaration.type !== \"TypeAlias\" && bodyElement.declaration.type !== \"InterfaceDeclaration\");\n}\nfunction hasTypeImportKind(node) {\n  return node.importKind === \"type\" || node.importKind === \"typeof\";\n}\nconst exportSuggestions = {\n  const: \"declare export var\",\n  let: \"declare export var\",\n  type: \"export type\",\n  interface: \"export interface\"\n};\nfunction partition(list, test) {\n  const list1 = [];\n  const list2 = [];\n  for (let i = 0; i < list.length; i++) {\n    (test(list[i], i, list) ? list1 : list2).push(list[i]);\n  }\n  return [list1, list2];\n}\nconst FLOW_PRAGMA_REGEX = /\\*?\\s*@((?:no)?flow)\\b/;\nvar flow = superClass => class FlowParserMixin extends superClass {\n  constructor(...args) {\n    super(...args);\n    this.flowPragma = undefined;\n  }\n  getScopeHandler() {\n    return FlowScopeHandler;\n  }\n  shouldParseTypes() {\n    return this.getPluginOption(\"flow\", \"all\") || this.flowPragma === \"flow\";\n  }\n  finishToken(type, val) {\n    if (type !== 134 && type !== 13 && type !== 28) {\n      if (this.flowPragma === undefined) {\n        this.flowPragma = null;\n      }\n    }\n    super.finishToken(type, val);\n  }\n  addComment(comment) {\n    if (this.flowPragma === undefined) {\n      const matches = FLOW_PRAGMA_REGEX.exec(comment.value);\n      if (!matches) ;else if (matches[1] === \"flow\") {\n        this.flowPragma = \"flow\";\n      } else if (matches[1] === \"noflow\") {\n        this.flowPragma = \"noflow\";\n      } else {\n        throw new Error(\"Unexpected flow pragma\");\n      }\n    }\n    super.addComment(comment);\n  }\n  flowParseTypeInitialiser(tok) {\n    const oldInType = this.state.inType;\n    this.state.inType = true;\n    this.expect(tok || 14);\n    const type = this.flowParseType();\n    this.state.inType = oldInType;\n    return type;\n  }\n  flowParsePredicate() {\n    const node = this.startNode();\n    const moduloLoc = this.state.startLoc;\n    this.next();\n    this.expectContextual(110);\n    if (this.state.lastTokStartLoc.index > moduloLoc.index + 1) {\n      this.raise(FlowErrors.UnexpectedSpaceBetweenModuloChecks, moduloLoc);\n    }\n    if (this.eat(10)) {\n      node.value = super.parseExpression();\n      this.expect(11);\n      return this.finishNode(node, \"DeclaredPredicate\");\n    } else {\n      return this.finishNode(node, \"InferredPredicate\");\n    }\n  }\n  flowParseTypeAndPredicateInitialiser() {\n    const oldInType = this.state.inType;\n    this.state.inType = true;\n    this.expect(14);\n    let type = null;\n    let predicate = null;\n    if (this.match(54)) {\n      this.state.inType = oldInType;\n      predicate = this.flowParsePredicate();\n    } else {\n      type = this.flowParseType();\n      this.state.inType = oldInType;\n      if (this.match(54)) {\n        predicate = this.flowParsePredicate();\n      }\n    }\n    return [type, predicate];\n  }\n  flowParseDeclareClass(node) {\n    this.next();\n    this.flowParseInterfaceish(node, true);\n    return this.finishNode(node, \"DeclareClass\");\n  }\n  flowParseDeclareFunction(node) {\n    this.next();\n    const id = node.id = this.parseIdentifier();\n    const typeNode = this.startNode();\n    const typeContainer = this.startNode();\n    if (this.match(47)) {\n      typeNode.typeParameters = this.flowParseTypeParameterDeclaration();\n    } else {\n      typeNode.typeParameters = null;\n    }\n    this.expect(10);\n    const tmp = this.flowParseFunctionTypeParams();\n    typeNode.params = tmp.params;\n    typeNode.rest = tmp.rest;\n    typeNode.this = tmp._this;\n    this.expect(11);\n    [typeNode.returnType, node.predicate] = this.flowParseTypeAndPredicateInitialiser();\n    typeContainer.typeAnnotation = this.finishNode(typeNode, \"FunctionTypeAnnotation\");\n    id.typeAnnotation = this.finishNode(typeContainer, \"TypeAnnotation\");\n    this.resetEndLocation(id);\n    this.semicolon();\n    this.scope.declareName(node.id.name, 2048, node.id.loc.start);\n    return this.finishNode(node, \"DeclareFunction\");\n  }\n  flowParseDeclare(node, insideModule) {\n    if (this.match(80)) {\n      return this.flowParseDeclareClass(node);\n    } else if (this.match(68)) {\n      return this.flowParseDeclareFunction(node);\n    } else if (this.match(74)) {\n      return this.flowParseDeclareVariable(node);\n    } else if (this.eatContextual(127)) {\n      if (this.match(16)) {\n        return this.flowParseDeclareModuleExports(node);\n      } else {\n        if (insideModule) {\n          this.raise(FlowErrors.NestedDeclareModule, this.state.lastTokStartLoc);\n        }\n        return this.flowParseDeclareModule(node);\n      }\n    } else if (this.isContextual(130)) {\n      return this.flowParseDeclareTypeAlias(node);\n    } else if (this.isContextual(131)) {\n      return this.flowParseDeclareOpaqueType(node);\n    } else if (this.isContextual(129)) {\n      return this.flowParseDeclareInterface(node);\n    } else if (this.match(82)) {\n      return this.flowParseDeclareExportDeclaration(node, insideModule);\n    }\n    throw this.unexpected();\n  }\n  flowParseDeclareVariable(node) {\n    this.next();\n    node.id = this.flowParseTypeAnnotatableIdentifier(true);\n    this.scope.declareName(node.id.name, 5, node.id.loc.start);\n    this.semicolon();\n    return this.finishNode(node, \"DeclareVariable\");\n  }\n  flowParseDeclareModule(node) {\n    this.scope.enter(0);\n    if (this.match(134)) {\n      node.id = super.parseExprAtom();\n    } else {\n      node.id = this.parseIdentifier();\n    }\n    const bodyNode = node.body = this.startNode();\n    const body = bodyNode.body = [];\n    this.expect(5);\n    while (!this.match(8)) {\n      const bodyNode = this.startNode();\n      if (this.match(83)) {\n        this.next();\n        if (!this.isContextual(130) && !this.match(87)) {\n          this.raise(FlowErrors.InvalidNonTypeImportInDeclareModule, this.state.lastTokStartLoc);\n        }\n        body.push(super.parseImport(bodyNode));\n      } else {\n        this.expectContextual(125, FlowErrors.UnsupportedStatementInDeclareModule);\n        body.push(this.flowParseDeclare(bodyNode, true));\n      }\n    }\n    this.scope.exit();\n    this.expect(8);\n    this.finishNode(bodyNode, \"BlockStatement\");\n    let kind = null;\n    let hasModuleExport = false;\n    body.forEach(bodyElement => {\n      if (isEsModuleType(bodyElement)) {\n        if (kind === \"CommonJS\") {\n          this.raise(FlowErrors.AmbiguousDeclareModuleKind, bodyElement);\n        }\n        kind = \"ES\";\n      } else if (bodyElement.type === \"DeclareModuleExports\") {\n        if (hasModuleExport) {\n          this.raise(FlowErrors.DuplicateDeclareModuleExports, bodyElement);\n        }\n        if (kind === \"ES\") {\n          this.raise(FlowErrors.AmbiguousDeclareModuleKind, bodyElement);\n        }\n        kind = \"CommonJS\";\n        hasModuleExport = true;\n      }\n    });\n    node.kind = kind || \"CommonJS\";\n    return this.finishNode(node, \"DeclareModule\");\n  }\n  flowParseDeclareExportDeclaration(node, insideModule) {\n    this.expect(82);\n    if (this.eat(65)) {\n      if (this.match(68) || this.match(80)) {\n        node.declaration = this.flowParseDeclare(this.startNode());\n      } else {\n        node.declaration = this.flowParseType();\n        this.semicolon();\n      }\n      node.default = true;\n      return this.finishNode(node, \"DeclareExportDeclaration\");\n    } else {\n      if (this.match(75) || this.isLet() || (this.isContextual(130) || this.isContextual(129)) && !insideModule) {\n        const label = this.state.value;\n        throw this.raise(FlowErrors.UnsupportedDeclareExportKind, this.state.startLoc, {\n          unsupportedExportKind: label,\n          suggestion: exportSuggestions[label]\n        });\n      }\n      if (this.match(74) || this.match(68) || this.match(80) || this.isContextual(131)) {\n        node.declaration = this.flowParseDeclare(this.startNode());\n        node.default = false;\n        return this.finishNode(node, \"DeclareExportDeclaration\");\n      } else if (this.match(55) || this.match(5) || this.isContextual(129) || this.isContextual(130) || this.isContextual(131)) {\n        node = this.parseExport(node, null);\n        if (node.type === \"ExportNamedDeclaration\") {\n          node.default = false;\n          delete node.exportKind;\n          return this.castNodeTo(node, \"DeclareExportDeclaration\");\n        } else {\n          return this.castNodeTo(node, \"DeclareExportAllDeclaration\");\n        }\n      }\n    }\n    throw this.unexpected();\n  }\n  flowParseDeclareModuleExports(node) {\n    this.next();\n    this.expectContextual(111);\n    node.typeAnnotation = this.flowParseTypeAnnotation();\n    this.semicolon();\n    return this.finishNode(node, \"DeclareModuleExports\");\n  }\n  flowParseDeclareTypeAlias(node) {\n    this.next();\n    const finished = this.flowParseTypeAlias(node);\n    this.castNodeTo(finished, \"DeclareTypeAlias\");\n    return finished;\n  }\n  flowParseDeclareOpaqueType(node) {\n    this.next();\n    const finished = this.flowParseOpaqueType(node, true);\n    this.castNodeTo(finished, \"DeclareOpaqueType\");\n    return finished;\n  }\n  flowParseDeclareInterface(node) {\n    this.next();\n    this.flowParseInterfaceish(node, false);\n    return this.finishNode(node, \"DeclareInterface\");\n  }\n  flowParseInterfaceish(node, isClass) {\n    node.id = this.flowParseRestrictedIdentifier(!isClass, true);\n    this.scope.declareName(node.id.name, isClass ? 17 : 8201, node.id.loc.start);\n    if (this.match(47)) {\n      node.typeParameters = this.flowParseTypeParameterDeclaration();\n    } else {\n      node.typeParameters = null;\n    }\n    node.extends = [];\n    if (this.eat(81)) {\n      do {\n        node.extends.push(this.flowParseInterfaceExtends());\n      } while (!isClass && this.eat(12));\n    }\n    if (isClass) {\n      node.implements = [];\n      node.mixins = [];\n      if (this.eatContextual(117)) {\n        do {\n          node.mixins.push(this.flowParseInterfaceExtends());\n        } while (this.eat(12));\n      }\n      if (this.eatContextual(113)) {\n        do {\n          node.implements.push(this.flowParseInterfaceExtends());\n        } while (this.eat(12));\n      }\n    }\n    node.body = this.flowParseObjectType({\n      allowStatic: isClass,\n      allowExact: false,\n      allowSpread: false,\n      allowProto: isClass,\n      allowInexact: false\n    });\n  }\n  flowParseInterfaceExtends() {\n    const node = this.startNode();\n    node.id = this.flowParseQualifiedTypeIdentifier();\n    if (this.match(47)) {\n      node.typeParameters = this.flowParseTypeParameterInstantiation();\n    } else {\n      node.typeParameters = null;\n    }\n    return this.finishNode(node, \"InterfaceExtends\");\n  }\n  flowParseInterface(node) {\n    this.flowParseInterfaceish(node, false);\n    return this.finishNode(node, \"InterfaceDeclaration\");\n  }\n  checkNotUnderscore(word) {\n    if (word === \"_\") {\n      this.raise(FlowErrors.UnexpectedReservedUnderscore, this.state.startLoc);\n    }\n  }\n  checkReservedType(word, startLoc, declaration) {\n    if (!reservedTypes.has(word)) return;\n    this.raise(declaration ? FlowErrors.AssignReservedType : FlowErrors.UnexpectedReservedType, startLoc, {\n      reservedType: word\n    });\n  }\n  flowParseRestrictedIdentifier(liberal, declaration) {\n    this.checkReservedType(this.state.value, this.state.startLoc, declaration);\n    return this.parseIdentifier(liberal);\n  }\n  flowParseTypeAlias(node) {\n    node.id = this.flowParseRestrictedIdentifier(false, true);\n    this.scope.declareName(node.id.name, 8201, node.id.loc.start);\n    if (this.match(47)) {\n      node.typeParameters = this.flowParseTypeParameterDeclaration();\n    } else {\n      node.typeParameters = null;\n    }\n    node.right = this.flowParseTypeInitialiser(29);\n    this.semicolon();\n    return this.finishNode(node, \"TypeAlias\");\n  }\n  flowParseOpaqueType(node, declare) {\n    this.expectContextual(130);\n    node.id = this.flowParseRestrictedIdentifier(true, true);\n    this.scope.declareName(node.id.name, 8201, node.id.loc.start);\n    if (this.match(47)) {\n      node.typeParameters = this.flowParseTypeParameterDeclaration();\n    } else {\n      node.typeParameters = null;\n    }\n    node.supertype = null;\n    if (this.match(14)) {\n      node.supertype = this.flowParseTypeInitialiser(14);\n    }\n    node.impltype = null;\n    if (!declare) {\n      node.impltype = this.flowParseTypeInitialiser(29);\n    }\n    this.semicolon();\n    return this.finishNode(node, \"OpaqueType\");\n  }\n  flowParseTypeParameter(requireDefault = false) {\n    const nodeStartLoc = this.state.startLoc;\n    const node = this.startNode();\n    const variance = this.flowParseVariance();\n    const ident = this.flowParseTypeAnnotatableIdentifier();\n    node.name = ident.name;\n    node.variance = variance;\n    node.bound = ident.typeAnnotation;\n    if (this.match(29)) {\n      this.eat(29);\n      node.default = this.flowParseType();\n    } else {\n      if (requireDefault) {\n        this.raise(FlowErrors.MissingTypeParamDefault, nodeStartLoc);\n      }\n    }\n    return this.finishNode(node, \"TypeParameter\");\n  }\n  flowParseTypeParameterDeclaration() {\n    const oldInType = this.state.inType;\n    const node = this.startNode();\n    node.params = [];\n    this.state.inType = true;\n    if (this.match(47) || this.match(143)) {\n      this.next();\n    } else {\n      this.unexpected();\n    }\n    let defaultRequired = false;\n    do {\n      const typeParameter = this.flowParseTypeParameter(defaultRequired);\n      node.params.push(typeParameter);\n      if (typeParameter.default) {\n        defaultRequired = true;\n      }\n      if (!this.match(48)) {\n        this.expect(12);\n      }\n    } while (!this.match(48));\n    this.expect(48);\n    this.state.inType = oldInType;\n    return this.finishNode(node, \"TypeParameterDeclaration\");\n  }\n  flowInTopLevelContext(cb) {\n    if (this.curContext() !== types.brace) {\n      const oldContext = this.state.context;\n      this.state.context = [oldContext[0]];\n      try {\n        return cb();\n      } finally {\n        this.state.context = oldContext;\n      }\n    } else {\n      return cb();\n    }\n  }\n  flowParseTypeParameterInstantiationInExpression() {\n    if (this.reScan_lt() !== 47) return;\n    return this.flowParseTypeParameterInstantiation();\n  }\n  flowParseTypeParameterInstantiation() {\n    const node = this.startNode();\n    const oldInType = this.state.inType;\n    this.state.inType = true;\n    node.params = [];\n    this.flowInTopLevelContext(() => {\n      this.expect(47);\n      const oldNoAnonFunctionType = this.state.noAnonFunctionType;\n      this.state.noAnonFunctionType = false;\n      while (!this.match(48)) {\n        node.params.push(this.flowParseType());\n        if (!this.match(48)) {\n          this.expect(12);\n        }\n      }\n      this.state.noAnonFunctionType = oldNoAnonFunctionType;\n    });\n    this.state.inType = oldInType;\n    if (!this.state.inType && this.curContext() === types.brace) {\n      this.reScan_lt_gt();\n    }\n    this.expect(48);\n    return this.finishNode(node, \"TypeParameterInstantiation\");\n  }\n  flowParseTypeParameterInstantiationCallOrNew() {\n    if (this.reScan_lt() !== 47) return null;\n    const node = this.startNode();\n    const oldInType = this.state.inType;\n    node.params = [];\n    this.state.inType = true;\n    this.expect(47);\n    while (!this.match(48)) {\n      node.params.push(this.flowParseTypeOrImplicitInstantiation());\n      if (!this.match(48)) {\n        this.expect(12);\n      }\n    }\n    this.expect(48);\n    this.state.inType = oldInType;\n    return this.finishNode(node, \"TypeParameterInstantiation\");\n  }\n  flowParseInterfaceType() {\n    const node = this.startNode();\n    this.expectContextual(129);\n    node.extends = [];\n    if (this.eat(81)) {\n      do {\n        node.extends.push(this.flowParseInterfaceExtends());\n      } while (this.eat(12));\n    }\n    node.body = this.flowParseObjectType({\n      allowStatic: false,\n      allowExact: false,\n      allowSpread: false,\n      allowProto: false,\n      allowInexact: false\n    });\n    return this.finishNode(node, \"InterfaceTypeAnnotation\");\n  }\n  flowParseObjectPropertyKey() {\n    return this.match(135) || this.match(134) ? super.parseExprAtom() : this.parseIdentifier(true);\n  }\n  flowParseObjectTypeIndexer(node, isStatic, variance) {\n    node.static = isStatic;\n    if (this.lookahead().type === 14) {\n      node.id = this.flowParseObjectPropertyKey();\n      node.key = this.flowParseTypeInitialiser();\n    } else {\n      node.id = null;\n      node.key = this.flowParseType();\n    }\n    this.expect(3);\n    node.value = this.flowParseTypeInitialiser();\n    node.variance = variance;\n    return this.finishNode(node, \"ObjectTypeIndexer\");\n  }\n  flowParseObjectTypeInternalSlot(node, isStatic) {\n    node.static = isStatic;\n    node.id = this.flowParseObjectPropertyKey();\n    this.expect(3);\n    this.expect(3);\n    if (this.match(47) || this.match(10)) {\n      node.method = true;\n      node.optional = false;\n      node.value = this.flowParseObjectTypeMethodish(this.startNodeAt(node.loc.start));\n    } else {\n      node.method = false;\n      if (this.eat(17)) {\n        node.optional = true;\n      }\n      node.value = this.flowParseTypeInitialiser();\n    }\n    return this.finishNode(node, \"ObjectTypeInternalSlot\");\n  }\n  flowParseObjectTypeMethodish(node) {\n    node.params = [];\n    node.rest = null;\n    node.typeParameters = null;\n    node.this = null;\n    if (this.match(47)) {\n      node.typeParameters = this.flowParseTypeParameterDeclaration();\n    }\n    this.expect(10);\n    if (this.match(78)) {\n      node.this = this.flowParseFunctionTypeParam(true);\n      node.this.name = null;\n      if (!this.match(11)) {\n        this.expect(12);\n      }\n    }\n    while (!this.match(11) && !this.match(21)) {\n      node.params.push(this.flowParseFunctionTypeParam(false));\n      if (!this.match(11)) {\n        this.expect(12);\n      }\n    }\n    if (this.eat(21)) {\n      node.rest = this.flowParseFunctionTypeParam(false);\n    }\n    this.expect(11);\n    node.returnType = this.flowParseTypeInitialiser();\n    return this.finishNode(node, \"FunctionTypeAnnotation\");\n  }\n  flowParseObjectTypeCallProperty(node, isStatic) {\n    const valueNode = this.startNode();\n    node.static = isStatic;\n    node.value = this.flowParseObjectTypeMethodish(valueNode);\n    return this.finishNode(node, \"ObjectTypeCallProperty\");\n  }\n  flowParseObjectType({\n    allowStatic,\n    allowExact,\n    allowSpread,\n    allowProto,\n    allowInexact\n  }) {\n    const oldInType = this.state.inType;\n    this.state.inType = true;\n    const nodeStart = this.startNode();\n    nodeStart.callProperties = [];\n    nodeStart.properties = [];\n    nodeStart.indexers = [];\n    nodeStart.internalSlots = [];\n    let endDelim;\n    let exact;\n    let inexact = false;\n    if (allowExact && this.match(6)) {\n      this.expect(6);\n      endDelim = 9;\n      exact = true;\n    } else {\n      this.expect(5);\n      endDelim = 8;\n      exact = false;\n    }\n    nodeStart.exact = exact;\n    while (!this.match(endDelim)) {\n      let isStatic = false;\n      let protoStartLoc = null;\n      let inexactStartLoc = null;\n      const node = this.startNode();\n      if (allowProto && this.isContextual(118)) {\n        const lookahead = this.lookahead();\n        if (lookahead.type !== 14 && lookahead.type !== 17) {\n          this.next();\n          protoStartLoc = this.state.startLoc;\n          allowStatic = false;\n        }\n      }\n      if (allowStatic && this.isContextual(106)) {\n        const lookahead = this.lookahead();\n        if (lookahead.type !== 14 && lookahead.type !== 17) {\n          this.next();\n          isStatic = true;\n        }\n      }\n      const variance = this.flowParseVariance();\n      if (this.eat(0)) {\n        if (protoStartLoc != null) {\n          this.unexpected(protoStartLoc);\n        }\n        if (this.eat(0)) {\n          if (variance) {\n            this.unexpected(variance.loc.start);\n          }\n          nodeStart.internalSlots.push(this.flowParseObjectTypeInternalSlot(node, isStatic));\n        } else {\n          nodeStart.indexers.push(this.flowParseObjectTypeIndexer(node, isStatic, variance));\n        }\n      } else if (this.match(10) || this.match(47)) {\n        if (protoStartLoc != null) {\n          this.unexpected(protoStartLoc);\n        }\n        if (variance) {\n          this.unexpected(variance.loc.start);\n        }\n        nodeStart.callProperties.push(this.flowParseObjectTypeCallProperty(node, isStatic));\n      } else {\n        let kind = \"init\";\n        if (this.isContextual(99) || this.isContextual(104)) {\n          const lookahead = this.lookahead();\n          if (tokenIsLiteralPropertyName(lookahead.type)) {\n            kind = this.state.value;\n            this.next();\n          }\n        }\n        const propOrInexact = this.flowParseObjectTypeProperty(node, isStatic, protoStartLoc, variance, kind, allowSpread, allowInexact != null ? allowInexact : !exact);\n        if (propOrInexact === null) {\n          inexact = true;\n          inexactStartLoc = this.state.lastTokStartLoc;\n        } else {\n          nodeStart.properties.push(propOrInexact);\n        }\n      }\n      this.flowObjectTypeSemicolon();\n      if (inexactStartLoc && !this.match(8) && !this.match(9)) {\n        this.raise(FlowErrors.UnexpectedExplicitInexactInObject, inexactStartLoc);\n      }\n    }\n    this.expect(endDelim);\n    if (allowSpread) {\n      nodeStart.inexact = inexact;\n    }\n    const out = this.finishNode(nodeStart, \"ObjectTypeAnnotation\");\n    this.state.inType = oldInType;\n    return out;\n  }\n  flowParseObjectTypeProperty(node, isStatic, protoStartLoc, variance, kind, allowSpread, allowInexact) {\n    if (this.eat(21)) {\n      const isInexactToken = this.match(12) || this.match(13) || this.match(8) || this.match(9);\n      if (isInexactToken) {\n        if (!allowSpread) {\n          this.raise(FlowErrors.InexactInsideNonObject, this.state.lastTokStartLoc);\n        } else if (!allowInexact) {\n          this.raise(FlowErrors.InexactInsideExact, this.state.lastTokStartLoc);\n        }\n        if (variance) {\n          this.raise(FlowErrors.InexactVariance, variance);\n        }\n        return null;\n      }\n      if (!allowSpread) {\n        this.raise(FlowErrors.UnexpectedSpreadType, this.state.lastTokStartLoc);\n      }\n      if (protoStartLoc != null) {\n        this.unexpected(protoStartLoc);\n      }\n      if (variance) {\n        this.raise(FlowErrors.SpreadVariance, variance);\n      }\n      node.argument = this.flowParseType();\n      return this.finishNode(node, \"ObjectTypeSpreadProperty\");\n    } else {\n      node.key = this.flowParseObjectPropertyKey();\n      node.static = isStatic;\n      node.proto = protoStartLoc != null;\n      node.kind = kind;\n      let optional = false;\n      if (this.match(47) || this.match(10)) {\n        node.method = true;\n        if (protoStartLoc != null) {\n          this.unexpected(protoStartLoc);\n        }\n        if (variance) {\n          this.unexpected(variance.loc.start);\n        }\n        node.value = this.flowParseObjectTypeMethodish(this.startNodeAt(node.loc.start));\n        if (kind === \"get\" || kind === \"set\") {\n          this.flowCheckGetterSetterParams(node);\n        }\n        if (!allowSpread && node.key.name === \"constructor\" && node.value.this) {\n          this.raise(FlowErrors.ThisParamBannedInConstructor, node.value.this);\n        }\n      } else {\n        if (kind !== \"init\") this.unexpected();\n        node.method = false;\n        if (this.eat(17)) {\n          optional = true;\n        }\n        node.value = this.flowParseTypeInitialiser();\n        node.variance = variance;\n      }\n      node.optional = optional;\n      return this.finishNode(node, \"ObjectTypeProperty\");\n    }\n  }\n  flowCheckGetterSetterParams(property) {\n    const paramCount = property.kind === \"get\" ? 0 : 1;\n    const length = property.value.params.length + (property.value.rest ? 1 : 0);\n    if (property.value.this) {\n      this.raise(property.kind === \"get\" ? FlowErrors.GetterMayNotHaveThisParam : FlowErrors.SetterMayNotHaveThisParam, property.value.this);\n    }\n    if (length !== paramCount) {\n      this.raise(property.kind === \"get\" ? Errors.BadGetterArity : Errors.BadSetterArity, property);\n    }\n    if (property.kind === \"set\" && property.value.rest) {\n      this.raise(Errors.BadSetterRestParameter, property);\n    }\n  }\n  flowObjectTypeSemicolon() {\n    if (!this.eat(13) && !this.eat(12) && !this.match(8) && !this.match(9)) {\n      this.unexpected();\n    }\n  }\n  flowParseQualifiedTypeIdentifier(startLoc, id) {\n    startLoc != null ? startLoc : startLoc = this.state.startLoc;\n    let node = id || this.flowParseRestrictedIdentifier(true);\n    while (this.eat(16)) {\n      const node2 = this.startNodeAt(startLoc);\n      node2.qualification = node;\n      node2.id = this.flowParseRestrictedIdentifier(true);\n      node = this.finishNode(node2, \"QualifiedTypeIdentifier\");\n    }\n    return node;\n  }\n  flowParseGenericType(startLoc, id) {\n    const node = this.startNodeAt(startLoc);\n    node.typeParameters = null;\n    node.id = this.flowParseQualifiedTypeIdentifier(startLoc, id);\n    if (this.match(47)) {\n      node.typeParameters = this.flowParseTypeParameterInstantiation();\n    }\n    return this.finishNode(node, \"GenericTypeAnnotation\");\n  }\n  flowParseTypeofType() {\n    const node = this.startNode();\n    this.expect(87);\n    node.argument = this.flowParsePrimaryType();\n    return this.finishNode(node, \"TypeofTypeAnnotation\");\n  }\n  flowParseTupleType() {\n    const node = this.startNode();\n    node.types = [];\n    this.expect(0);\n    while (this.state.pos < this.length && !this.match(3)) {\n      node.types.push(this.flowParseType());\n      if (this.match(3)) break;\n      this.expect(12);\n    }\n    this.expect(3);\n    return this.finishNode(node, \"TupleTypeAnnotation\");\n  }\n  flowParseFunctionTypeParam(first) {\n    let name = null;\n    let optional = false;\n    let typeAnnotation = null;\n    const node = this.startNode();\n    const lh = this.lookahead();\n    const isThis = this.state.type === 78;\n    if (lh.type === 14 || lh.type === 17) {\n      if (isThis && !first) {\n        this.raise(FlowErrors.ThisParamMustBeFirst, node);\n      }\n      name = this.parseIdentifier(isThis);\n      if (this.eat(17)) {\n        optional = true;\n        if (isThis) {\n          this.raise(FlowErrors.ThisParamMayNotBeOptional, node);\n        }\n      }\n      typeAnnotation = this.flowParseTypeInitialiser();\n    } else {\n      typeAnnotation = this.flowParseType();\n    }\n    node.name = name;\n    node.optional = optional;\n    node.typeAnnotation = typeAnnotation;\n    return this.finishNode(node, \"FunctionTypeParam\");\n  }\n  reinterpretTypeAsFunctionTypeParam(type) {\n    const node = this.startNodeAt(type.loc.start);\n    node.name = null;\n    node.optional = false;\n    node.typeAnnotation = type;\n    return this.finishNode(node, \"FunctionTypeParam\");\n  }\n  flowParseFunctionTypeParams(params = []) {\n    let rest = null;\n    let _this = null;\n    if (this.match(78)) {\n      _this = this.flowParseFunctionTypeParam(true);\n      _this.name = null;\n      if (!this.match(11)) {\n        this.expect(12);\n      }\n    }\n    while (!this.match(11) && !this.match(21)) {\n      params.push(this.flowParseFunctionTypeParam(false));\n      if (!this.match(11)) {\n        this.expect(12);\n      }\n    }\n    if (this.eat(21)) {\n      rest = this.flowParseFunctionTypeParam(false);\n    }\n    return {\n      params,\n      rest,\n      _this\n    };\n  }\n  flowIdentToTypeAnnotation(startLoc, node, id) {\n    switch (id.name) {\n      case \"any\":\n        return this.finishNode(node, \"AnyTypeAnnotation\");\n      case \"bool\":\n      case \"boolean\":\n        return this.finishNode(node, \"BooleanTypeAnnotation\");\n      case \"mixed\":\n        return this.finishNode(node, \"MixedTypeAnnotation\");\n      case \"empty\":\n        return this.finishNode(node, \"EmptyTypeAnnotation\");\n      case \"number\":\n        return this.finishNode(node, \"NumberTypeAnnotation\");\n      case \"string\":\n        return this.finishNode(node, \"StringTypeAnnotation\");\n      case \"symbol\":\n        return this.finishNode(node, \"SymbolTypeAnnotation\");\n      default:\n        this.checkNotUnderscore(id.name);\n        return this.flowParseGenericType(startLoc, id);\n    }\n  }\n  flowParsePrimaryType() {\n    const startLoc = this.state.startLoc;\n    const node = this.startNode();\n    let tmp;\n    let type;\n    let isGroupedType = false;\n    const oldNoAnonFunctionType = this.state.noAnonFunctionType;\n    switch (this.state.type) {\n      case 5:\n        return this.flowParseObjectType({\n          allowStatic: false,\n          allowExact: false,\n          allowSpread: true,\n          allowProto: false,\n          allowInexact: true\n        });\n      case 6:\n        return this.flowParseObjectType({\n          allowStatic: false,\n          allowExact: true,\n          allowSpread: true,\n          allowProto: false,\n          allowInexact: false\n        });\n      case 0:\n        this.state.noAnonFunctionType = false;\n        type = this.flowParseTupleType();\n        this.state.noAnonFunctionType = oldNoAnonFunctionType;\n        return type;\n      case 47:\n        {\n          const node = this.startNode();\n          node.typeParameters = this.flowParseTypeParameterDeclaration();\n          this.expect(10);\n          tmp = this.flowParseFunctionTypeParams();\n          node.params = tmp.params;\n          node.rest = tmp.rest;\n          node.this = tmp._this;\n          this.expect(11);\n          this.expect(19);\n          node.returnType = this.flowParseType();\n          return this.finishNode(node, \"FunctionTypeAnnotation\");\n        }\n      case 10:\n        {\n          const node = this.startNode();\n          this.next();\n          if (!this.match(11) && !this.match(21)) {\n            if (tokenIsIdentifier(this.state.type) || this.match(78)) {\n              const token = this.lookahead().type;\n              isGroupedType = token !== 17 && token !== 14;\n            } else {\n              isGroupedType = true;\n            }\n          }\n          if (isGroupedType) {\n            this.state.noAnonFunctionType = false;\n            type = this.flowParseType();\n            this.state.noAnonFunctionType = oldNoAnonFunctionType;\n            if (this.state.noAnonFunctionType || !(this.match(12) || this.match(11) && this.lookahead().type === 19)) {\n              this.expect(11);\n              return type;\n            } else {\n              this.eat(12);\n            }\n          }\n          if (type) {\n            tmp = this.flowParseFunctionTypeParams([this.reinterpretTypeAsFunctionTypeParam(type)]);\n          } else {\n            tmp = this.flowParseFunctionTypeParams();\n          }\n          node.params = tmp.params;\n          node.rest = tmp.rest;\n          node.this = tmp._this;\n          this.expect(11);\n          this.expect(19);\n          node.returnType = this.flowParseType();\n          node.typeParameters = null;\n          return this.finishNode(node, \"FunctionTypeAnnotation\");\n        }\n      case 134:\n        return this.parseLiteral(this.state.value, \"StringLiteralTypeAnnotation\");\n      case 85:\n      case 86:\n        node.value = this.match(85);\n        this.next();\n        return this.finishNode(node, \"BooleanLiteralTypeAnnotation\");\n      case 53:\n        if (this.state.value === \"-\") {\n          this.next();\n          if (this.match(135)) {\n            return this.parseLiteralAtNode(-this.state.value, \"NumberLiteralTypeAnnotation\", node);\n          }\n          if (this.match(136)) {\n            return this.parseLiteralAtNode(-this.state.value, \"BigIntLiteralTypeAnnotation\", node);\n          }\n          throw this.raise(FlowErrors.UnexpectedSubtractionOperand, this.state.startLoc);\n        }\n        throw this.unexpected();\n      case 135:\n        return this.parseLiteral(this.state.value, \"NumberLiteralTypeAnnotation\");\n      case 136:\n        return this.parseLiteral(this.state.value, \"BigIntLiteralTypeAnnotation\");\n      case 88:\n        this.next();\n        return this.finishNode(node, \"VoidTypeAnnotation\");\n      case 84:\n        this.next();\n        return this.finishNode(node, \"NullLiteralTypeAnnotation\");\n      case 78:\n        this.next();\n        return this.finishNode(node, \"ThisTypeAnnotation\");\n      case 55:\n        this.next();\n        return this.finishNode(node, \"ExistsTypeAnnotation\");\n      case 87:\n        return this.flowParseTypeofType();\n      default:\n        if (tokenIsKeyword(this.state.type)) {\n          const label = tokenLabelName(this.state.type);\n          this.next();\n          return super.createIdentifier(node, label);\n        } else if (tokenIsIdentifier(this.state.type)) {\n          if (this.isContextual(129)) {\n            return this.flowParseInterfaceType();\n          }\n          return this.flowIdentToTypeAnnotation(startLoc, node, this.parseIdentifier());\n        }\n    }\n    throw this.unexpected();\n  }\n  flowParsePostfixType() {\n    const startLoc = this.state.startLoc;\n    let type = this.flowParsePrimaryType();\n    let seenOptionalIndexedAccess = false;\n    while ((this.match(0) || this.match(18)) && !this.canInsertSemicolon()) {\n      const node = this.startNodeAt(startLoc);\n      const optional = this.eat(18);\n      seenOptionalIndexedAccess = seenOptionalIndexedAccess || optional;\n      this.expect(0);\n      if (!optional && this.match(3)) {\n        node.elementType = type;\n        this.next();\n        type = this.finishNode(node, \"ArrayTypeAnnotation\");\n      } else {\n        node.objectType = type;\n        node.indexType = this.flowParseType();\n        this.expect(3);\n        if (seenOptionalIndexedAccess) {\n          node.optional = optional;\n          type = this.finishNode(node, \"OptionalIndexedAccessType\");\n        } else {\n          type = this.finishNode(node, \"IndexedAccessType\");\n        }\n      }\n    }\n    return type;\n  }\n  flowParsePrefixType() {\n    const node = this.startNode();\n    if (this.eat(17)) {\n      node.typeAnnotation = this.flowParsePrefixType();\n      return this.finishNode(node, \"NullableTypeAnnotation\");\n    } else {\n      return this.flowParsePostfixType();\n    }\n  }\n  flowParseAnonFunctionWithoutParens() {\n    const param = this.flowParsePrefixType();\n    if (!this.state.noAnonFunctionType && this.eat(19)) {\n      const node = this.startNodeAt(param.loc.start);\n      node.params = [this.reinterpretTypeAsFunctionTypeParam(param)];\n      node.rest = null;\n      node.this = null;\n      node.returnType = this.flowParseType();\n      node.typeParameters = null;\n      return this.finishNode(node, \"FunctionTypeAnnotation\");\n    }\n    return param;\n  }\n  flowParseIntersectionType() {\n    const node = this.startNode();\n    this.eat(45);\n    const type = this.flowParseAnonFunctionWithoutParens();\n    node.types = [type];\n    while (this.eat(45)) {\n      node.types.push(this.flowParseAnonFunctionWithoutParens());\n    }\n    return node.types.length === 1 ? type : this.finishNode(node, \"IntersectionTypeAnnotation\");\n  }\n  flowParseUnionType() {\n    const node = this.startNode();\n    this.eat(43);\n    const type = this.flowParseIntersectionType();\n    node.types = [type];\n    while (this.eat(43)) {\n      node.types.push(this.flowParseIntersectionType());\n    }\n    return node.types.length === 1 ? type : this.finishNode(node, \"UnionTypeAnnotation\");\n  }\n  flowParseType() {\n    const oldInType = this.state.inType;\n    this.state.inType = true;\n    const type = this.flowParseUnionType();\n    this.state.inType = oldInType;\n    return type;\n  }\n  flowParseTypeOrImplicitInstantiation() {\n    if (this.state.type === 132 && this.state.value === \"_\") {\n      const startLoc = this.state.startLoc;\n      const node = this.parseIdentifier();\n      return this.flowParseGenericType(startLoc, node);\n    } else {\n      return this.flowParseType();\n    }\n  }\n  flowParseTypeAnnotation() {\n    const node = this.startNode();\n    node.typeAnnotation = this.flowParseTypeInitialiser();\n    return this.finishNode(node, \"TypeAnnotation\");\n  }\n  flowParseTypeAnnotatableIdentifier(allowPrimitiveOverride) {\n    const ident = allowPrimitiveOverride ? this.parseIdentifier() : this.flowParseRestrictedIdentifier();\n    if (this.match(14)) {\n      ident.typeAnnotation = this.flowParseTypeAnnotation();\n      this.resetEndLocation(ident);\n    }\n    return ident;\n  }\n  typeCastToParameter(node) {\n    node.expression.typeAnnotation = node.typeAnnotation;\n    this.resetEndLocation(node.expression, node.typeAnnotation.loc.end);\n    return node.expression;\n  }\n  flowParseVariance() {\n    let variance = null;\n    if (this.match(53)) {\n      variance = this.startNode();\n      if (this.state.value === \"+\") {\n        variance.kind = \"plus\";\n      } else {\n        variance.kind = \"minus\";\n      }\n      this.next();\n      return this.finishNode(variance, \"Variance\");\n    }\n    return variance;\n  }\n  parseFunctionBody(node, allowExpressionBody, isMethod = false) {\n    if (allowExpressionBody) {\n      this.forwardNoArrowParamsConversionAt(node, () => super.parseFunctionBody(node, true, isMethod));\n      return;\n    }\n    super.parseFunctionBody(node, false, isMethod);\n  }\n  parseFunctionBodyAndFinish(node, type, isMethod = false) {\n    if (this.match(14)) {\n      const typeNode = this.startNode();\n      [typeNode.typeAnnotation, node.predicate] = this.flowParseTypeAndPredicateInitialiser();\n      node.returnType = typeNode.typeAnnotation ? this.finishNode(typeNode, \"TypeAnnotation\") : null;\n    }\n    return super.parseFunctionBodyAndFinish(node, type, isMethod);\n  }\n  parseStatementLike(flags) {\n    if (this.state.strict && this.isContextual(129)) {\n      const lookahead = this.lookahead();\n      if (tokenIsKeywordOrIdentifier(lookahead.type)) {\n        const node = this.startNode();\n        this.next();\n        return this.flowParseInterface(node);\n      }\n    } else if (this.isContextual(126)) {\n      const node = this.startNode();\n      this.next();\n      return this.flowParseEnumDeclaration(node);\n    }\n    const stmt = super.parseStatementLike(flags);\n    if (this.flowPragma === undefined && !this.isValidDirective(stmt)) {\n      this.flowPragma = null;\n    }\n    return stmt;\n  }\n  parseExpressionStatement(node, expr, decorators) {\n    if (expr.type === \"Identifier\") {\n      if (expr.name === \"declare\") {\n        if (this.match(80) || tokenIsIdentifier(this.state.type) || this.match(68) || this.match(74) || this.match(82)) {\n          return this.flowParseDeclare(node);\n        }\n      } else if (tokenIsIdentifier(this.state.type)) {\n        if (expr.name === \"interface\") {\n          return this.flowParseInterface(node);\n        } else if (expr.name === \"type\") {\n          return this.flowParseTypeAlias(node);\n        } else if (expr.name === \"opaque\") {\n          return this.flowParseOpaqueType(node, false);\n        }\n      }\n    }\n    return super.parseExpressionStatement(node, expr, decorators);\n  }\n  shouldParseExportDeclaration() {\n    const {\n      type\n    } = this.state;\n    if (type === 126 || tokenIsFlowInterfaceOrTypeOrOpaque(type)) {\n      return !this.state.containsEsc;\n    }\n    return super.shouldParseExportDeclaration();\n  }\n  isExportDefaultSpecifier() {\n    const {\n      type\n    } = this.state;\n    if (type === 126 || tokenIsFlowInterfaceOrTypeOrOpaque(type)) {\n      return this.state.containsEsc;\n    }\n    return super.isExportDefaultSpecifier();\n  }\n  parseExportDefaultExpression() {\n    if (this.isContextual(126)) {\n      const node = this.startNode();\n      this.next();\n      return this.flowParseEnumDeclaration(node);\n    }\n    return super.parseExportDefaultExpression();\n  }\n  parseConditional(expr, startLoc, refExpressionErrors) {\n    if (!this.match(17)) return expr;\n    if (this.state.maybeInArrowParameters) {\n      const nextCh = this.lookaheadCharCode();\n      if (nextCh === 44 || nextCh === 61 || nextCh === 58 || nextCh === 41) {\n        this.setOptionalParametersError(refExpressionErrors);\n        return expr;\n      }\n    }\n    this.expect(17);\n    const state = this.state.clone();\n    const originalNoArrowAt = this.state.noArrowAt;\n    const node = this.startNodeAt(startLoc);\n    let {\n      consequent,\n      failed\n    } = this.tryParseConditionalConsequent();\n    let [valid, invalid] = this.getArrowLikeExpressions(consequent);\n    if (failed || invalid.length > 0) {\n      const noArrowAt = [...originalNoArrowAt];\n      if (invalid.length > 0) {\n        this.state = state;\n        this.state.noArrowAt = noArrowAt;\n        for (let i = 0; i < invalid.length; i++) {\n          noArrowAt.push(invalid[i].start);\n        }\n        ({\n          consequent,\n          failed\n        } = this.tryParseConditionalConsequent());\n        [valid, invalid] = this.getArrowLikeExpressions(consequent);\n      }\n      if (failed && valid.length > 1) {\n        this.raise(FlowErrors.AmbiguousConditionalArrow, state.startLoc);\n      }\n      if (failed && valid.length === 1) {\n        this.state = state;\n        noArrowAt.push(valid[0].start);\n        this.state.noArrowAt = noArrowAt;\n        ({\n          consequent,\n          failed\n        } = this.tryParseConditionalConsequent());\n      }\n    }\n    this.getArrowLikeExpressions(consequent, true);\n    this.state.noArrowAt = originalNoArrowAt;\n    this.expect(14);\n    node.test = expr;\n    node.consequent = consequent;\n    node.alternate = this.forwardNoArrowParamsConversionAt(node, () => this.parseMaybeAssign(undefined, undefined));\n    return this.finishNode(node, \"ConditionalExpression\");\n  }\n  tryParseConditionalConsequent() {\n    this.state.noArrowParamsConversionAt.push(this.state.start);\n    const consequent = this.parseMaybeAssignAllowIn();\n    const failed = !this.match(14);\n    this.state.noArrowParamsConversionAt.pop();\n    return {\n      consequent,\n      failed\n    };\n  }\n  getArrowLikeExpressions(node, disallowInvalid) {\n    const stack = [node];\n    const arrows = [];\n    while (stack.length !== 0) {\n      const node = stack.pop();\n      if (node.type === \"ArrowFunctionExpression\" && node.body.type !== \"BlockStatement\") {\n        if (node.typeParameters || !node.returnType) {\n          this.finishArrowValidation(node);\n        } else {\n          arrows.push(node);\n        }\n        stack.push(node.body);\n      } else if (node.type === \"ConditionalExpression\") {\n        stack.push(node.consequent);\n        stack.push(node.alternate);\n      }\n    }\n    if (disallowInvalid) {\n      arrows.forEach(node => this.finishArrowValidation(node));\n      return [arrows, []];\n    }\n    return partition(arrows, node => node.params.every(param => this.isAssignable(param, true)));\n  }\n  finishArrowValidation(node) {\n    var _node$extra;\n    this.toAssignableList(node.params, (_node$extra = node.extra) == null ? void 0 : _node$extra.trailingCommaLoc, false);\n    this.scope.enter(514 | 4);\n    super.checkParams(node, false, true);\n    this.scope.exit();\n  }\n  forwardNoArrowParamsConversionAt(node, parse) {\n    let result;\n    if (this.state.noArrowParamsConversionAt.includes(this.offsetToSourcePos(node.start))) {\n      this.state.noArrowParamsConversionAt.push(this.state.start);\n      result = parse();\n      this.state.noArrowParamsConversionAt.pop();\n    } else {\n      result = parse();\n    }\n    return result;\n  }\n  parseParenItem(node, startLoc) {\n    const newNode = super.parseParenItem(node, startLoc);\n    if (this.eat(17)) {\n      newNode.optional = true;\n      this.resetEndLocation(node);\n    }\n    if (this.match(14)) {\n      const typeCastNode = this.startNodeAt(startLoc);\n      typeCastNode.expression = newNode;\n      typeCastNode.typeAnnotation = this.flowParseTypeAnnotation();\n      return this.finishNode(typeCastNode, \"TypeCastExpression\");\n    }\n    return newNode;\n  }\n  assertModuleNodeAllowed(node) {\n    if (node.type === \"ImportDeclaration\" && (node.importKind === \"type\" || node.importKind === \"typeof\") || node.type === \"ExportNamedDeclaration\" && node.exportKind === \"type\" || node.type === \"ExportAllDeclaration\" && node.exportKind === \"type\") {\n      return;\n    }\n    super.assertModuleNodeAllowed(node);\n  }\n  parseExportDeclaration(node) {\n    if (this.isContextual(130)) {\n      node.exportKind = \"type\";\n      const declarationNode = this.startNode();\n      this.next();\n      if (this.match(5)) {\n        node.specifiers = this.parseExportSpecifiers(true);\n        super.parseExportFrom(node);\n        return null;\n      } else {\n        return this.flowParseTypeAlias(declarationNode);\n      }\n    } else if (this.isContextual(131)) {\n      node.exportKind = \"type\";\n      const declarationNode = this.startNode();\n      this.next();\n      return this.flowParseOpaqueType(declarationNode, false);\n    } else if (this.isContextual(129)) {\n      node.exportKind = \"type\";\n      const declarationNode = this.startNode();\n      this.next();\n      return this.flowParseInterface(declarationNode);\n    } else if (this.isContextual(126)) {\n      node.exportKind = \"value\";\n      const declarationNode = this.startNode();\n      this.next();\n      return this.flowParseEnumDeclaration(declarationNode);\n    } else {\n      return super.parseExportDeclaration(node);\n    }\n  }\n  eatExportStar(node) {\n    if (super.eatExportStar(node)) return true;\n    if (this.isContextual(130) && this.lookahead().type === 55) {\n      node.exportKind = \"type\";\n      this.next();\n      this.next();\n      return true;\n    }\n    return false;\n  }\n  maybeParseExportNamespaceSpecifier(node) {\n    const {\n      startLoc\n    } = this.state;\n    const hasNamespace = super.maybeParseExportNamespaceSpecifier(node);\n    if (hasNamespace && node.exportKind === \"type\") {\n      this.unexpected(startLoc);\n    }\n    return hasNamespace;\n  }\n  parseClassId(node, isStatement, optionalId) {\n    super.parseClassId(node, isStatement, optionalId);\n    if (this.match(47)) {\n      node.typeParameters = this.flowParseTypeParameterDeclaration();\n    }\n  }\n  parseClassMember(classBody, member, state) {\n    const {\n      startLoc\n    } = this.state;\n    if (this.isContextual(125)) {\n      if (super.parseClassMemberFromModifier(classBody, member)) {\n        return;\n      }\n      member.declare = true;\n    }\n    super.parseClassMember(classBody, member, state);\n    if (member.declare) {\n      if (member.type !== \"ClassProperty\" && member.type !== \"ClassPrivateProperty\" && member.type !== \"PropertyDefinition\") {\n        this.raise(FlowErrors.DeclareClassElement, startLoc);\n      } else if (member.value) {\n        this.raise(FlowErrors.DeclareClassFieldInitializer, member.value);\n      }\n    }\n  }\n  isIterator(word) {\n    return word === \"iterator\" || word === \"asyncIterator\";\n  }\n  readIterator() {\n    const word = super.readWord1();\n    const fullWord = \"@@\" + word;\n    if (!this.isIterator(word) || !this.state.inType) {\n      this.raise(Errors.InvalidIdentifier, this.state.curPosition(), {\n        identifierName: fullWord\n      });\n    }\n    this.finishToken(132, fullWord);\n  }\n  getTokenFromCode(code) {\n    const next = this.input.charCodeAt(this.state.pos + 1);\n    if (code === 123 && next === 124) {\n      this.finishOp(6, 2);\n    } else if (this.state.inType && (code === 62 || code === 60)) {\n      this.finishOp(code === 62 ? 48 : 47, 1);\n    } else if (this.state.inType && code === 63) {\n      if (next === 46) {\n        this.finishOp(18, 2);\n      } else {\n        this.finishOp(17, 1);\n      }\n    } else if (isIteratorStart(code, next, this.input.charCodeAt(this.state.pos + 2))) {\n      this.state.pos += 2;\n      this.readIterator();\n    } else {\n      super.getTokenFromCode(code);\n    }\n  }\n  isAssignable(node, isBinding) {\n    if (node.type === \"TypeCastExpression\") {\n      return this.isAssignable(node.expression, isBinding);\n    } else {\n      return super.isAssignable(node, isBinding);\n    }\n  }\n  toAssignable(node, isLHS = false) {\n    if (!isLHS && node.type === \"AssignmentExpression\" && node.left.type === \"TypeCastExpression\") {\n      node.left = this.typeCastToParameter(node.left);\n    }\n    super.toAssignable(node, isLHS);\n  }\n  toAssignableList(exprList, trailingCommaLoc, isLHS) {\n    for (let i = 0; i < exprList.length; i++) {\n      const expr = exprList[i];\n      if ((expr == null ? void 0 : expr.type) === \"TypeCastExpression\") {\n        exprList[i] = this.typeCastToParameter(expr);\n      }\n    }\n    super.toAssignableList(exprList, trailingCommaLoc, isLHS);\n  }\n  toReferencedList(exprList, isParenthesizedExpr) {\n    for (let i = 0; i < exprList.length; i++) {\n      var _expr$extra;\n      const expr = exprList[i];\n      if (expr && expr.type === \"TypeCastExpression\" && !((_expr$extra = expr.extra) != null && _expr$extra.parenthesized) && (exprList.length > 1 || !isParenthesizedExpr)) {\n        this.raise(FlowErrors.TypeCastInPattern, expr.typeAnnotation);\n      }\n    }\n    return exprList;\n  }\n  parseArrayLike(close, isTuple, refExpressionErrors) {\n    const node = super.parseArrayLike(close, isTuple, refExpressionErrors);\n    if (refExpressionErrors != null && !this.state.maybeInArrowParameters) {\n      this.toReferencedList(node.elements);\n    }\n    return node;\n  }\n  isValidLVal(type, disallowCallExpression, isParenthesized, binding) {\n    return type === \"TypeCastExpression\" || super.isValidLVal(type, disallowCallExpression, isParenthesized, binding);\n  }\n  parseClassProperty(node) {\n    if (this.match(14)) {\n      node.typeAnnotation = this.flowParseTypeAnnotation();\n    }\n    return super.parseClassProperty(node);\n  }\n  parseClassPrivateProperty(node) {\n    if (this.match(14)) {\n      node.typeAnnotation = this.flowParseTypeAnnotation();\n    }\n    return super.parseClassPrivateProperty(node);\n  }\n  isClassMethod() {\n    return this.match(47) || super.isClassMethod();\n  }\n  isClassProperty() {\n    return this.match(14) || super.isClassProperty();\n  }\n  isNonstaticConstructor(method) {\n    return !this.match(14) && super.isNonstaticConstructor(method);\n  }\n  pushClassMethod(classBody, method, isGenerator, isAsync, isConstructor, allowsDirectSuper) {\n    if (method.variance) {\n      this.unexpected(method.variance.loc.start);\n    }\n    delete method.variance;\n    if (this.match(47)) {\n      method.typeParameters = this.flowParseTypeParameterDeclaration();\n    }\n    super.pushClassMethod(classBody, method, isGenerator, isAsync, isConstructor, allowsDirectSuper);\n    if (method.params && isConstructor) {\n      const params = method.params;\n      if (params.length > 0 && this.isThisParam(params[0])) {\n        this.raise(FlowErrors.ThisParamBannedInConstructor, method);\n      }\n    } else if (method.type === \"MethodDefinition\" && isConstructor && method.value.params) {\n      const params = method.value.params;\n      if (params.length > 0 && this.isThisParam(params[0])) {\n        this.raise(FlowErrors.ThisParamBannedInConstructor, method);\n      }\n    }\n  }\n  pushClassPrivateMethod(classBody, method, isGenerator, isAsync) {\n    if (method.variance) {\n      this.unexpected(method.variance.loc.start);\n    }\n    delete method.variance;\n    if (this.match(47)) {\n      method.typeParameters = this.flowParseTypeParameterDeclaration();\n    }\n    super.pushClassPrivateMethod(classBody, method, isGenerator, isAsync);\n  }\n  parseClassSuper(node) {\n    super.parseClassSuper(node);\n    if (node.superClass && (this.match(47) || this.match(51))) {\n      node.superTypeParameters = this.flowParseTypeParameterInstantiationInExpression();\n    }\n    if (this.isContextual(113)) {\n      this.next();\n      const implemented = node.implements = [];\n      do {\n        const node = this.startNode();\n        node.id = this.flowParseRestrictedIdentifier(true);\n        if (this.match(47)) {\n          node.typeParameters = this.flowParseTypeParameterInstantiation();\n        } else {\n          node.typeParameters = null;\n        }\n        implemented.push(this.finishNode(node, \"ClassImplements\"));\n      } while (this.eat(12));\n    }\n  }\n  checkGetterSetterParams(method) {\n    super.checkGetterSetterParams(method);\n    const params = this.getObjectOrClassMethodParams(method);\n    if (params.length > 0) {\n      const param = params[0];\n      if (this.isThisParam(param) && method.kind === \"get\") {\n        this.raise(FlowErrors.GetterMayNotHaveThisParam, param);\n      } else if (this.isThisParam(param)) {\n        this.raise(FlowErrors.SetterMayNotHaveThisParam, param);\n      }\n    }\n  }\n  parsePropertyNamePrefixOperator(node) {\n    node.variance = this.flowParseVariance();\n  }\n  parseObjPropValue(prop, startLoc, isGenerator, isAsync, isPattern, isAccessor, refExpressionErrors) {\n    if (prop.variance) {\n      this.unexpected(prop.variance.loc.start);\n    }\n    delete prop.variance;\n    let typeParameters;\n    if (this.match(47) && !isAccessor) {\n      typeParameters = this.flowParseTypeParameterDeclaration();\n      if (!this.match(10)) this.unexpected();\n    }\n    const result = super.parseObjPropValue(prop, startLoc, isGenerator, isAsync, isPattern, isAccessor, refExpressionErrors);\n    if (typeParameters) {\n      (result.value || result).typeParameters = typeParameters;\n    }\n    return result;\n  }\n  parseFunctionParamType(param) {\n    if (this.eat(17)) {\n      if (param.type !== \"Identifier\") {\n        this.raise(FlowErrors.PatternIsOptional, param);\n      }\n      if (this.isThisParam(param)) {\n        this.raise(FlowErrors.ThisParamMayNotBeOptional, param);\n      }\n      param.optional = true;\n    }\n    if (this.match(14)) {\n      param.typeAnnotation = this.flowParseTypeAnnotation();\n    } else if (this.isThisParam(param)) {\n      this.raise(FlowErrors.ThisParamAnnotationRequired, param);\n    }\n    if (this.match(29) && this.isThisParam(param)) {\n      this.raise(FlowErrors.ThisParamNoDefault, param);\n    }\n    this.resetEndLocation(param);\n    return param;\n  }\n  parseMaybeDefault(startLoc, left) {\n    const node = super.parseMaybeDefault(startLoc, left);\n    if (node.type === \"AssignmentPattern\" && node.typeAnnotation && node.right.start < node.typeAnnotation.start) {\n      this.raise(FlowErrors.TypeBeforeInitializer, node.typeAnnotation);\n    }\n    return node;\n  }\n  checkImportReflection(node) {\n    super.checkImportReflection(node);\n    if (node.module && node.importKind !== \"value\") {\n      this.raise(FlowErrors.ImportReflectionHasImportType, node.specifiers[0].loc.start);\n    }\n  }\n  parseImportSpecifierLocal(node, specifier, type) {\n    specifier.local = hasTypeImportKind(node) ? this.flowParseRestrictedIdentifier(true, true) : this.parseIdentifier();\n    node.specifiers.push(this.finishImportSpecifier(specifier, type));\n  }\n  isPotentialImportPhase(isExport) {\n    if (super.isPotentialImportPhase(isExport)) return true;\n    if (this.isContextual(130)) {\n      if (!isExport) return true;\n      const ch = this.lookaheadCharCode();\n      return ch === 123 || ch === 42;\n    }\n    return !isExport && this.isContextual(87);\n  }\n  applyImportPhase(node, isExport, phase, loc) {\n    super.applyImportPhase(node, isExport, phase, loc);\n    if (isExport) {\n      if (!phase && this.match(65)) {\n        return;\n      }\n      node.exportKind = phase === \"type\" ? phase : \"value\";\n    } else {\n      if (phase === \"type\" && this.match(55)) this.unexpected();\n      node.importKind = phase === \"type\" || phase === \"typeof\" ? phase : \"value\";\n    }\n  }\n  parseImportSpecifier(specifier, importedIsString, isInTypeOnlyImport, isMaybeTypeOnly, bindingType) {\n    const firstIdent = specifier.imported;\n    let specifierTypeKind = null;\n    if (firstIdent.type === \"Identifier\") {\n      if (firstIdent.name === \"type\") {\n        specifierTypeKind = \"type\";\n      } else if (firstIdent.name === \"typeof\") {\n        specifierTypeKind = \"typeof\";\n      }\n    }\n    let isBinding = false;\n    if (this.isContextual(93) && !this.isLookaheadContextual(\"as\")) {\n      const as_ident = this.parseIdentifier(true);\n      if (specifierTypeKind !== null && !tokenIsKeywordOrIdentifier(this.state.type)) {\n        specifier.imported = as_ident;\n        specifier.importKind = specifierTypeKind;\n        specifier.local = this.cloneIdentifier(as_ident);\n      } else {\n        specifier.imported = firstIdent;\n        specifier.importKind = null;\n        specifier.local = this.parseIdentifier();\n      }\n    } else {\n      if (specifierTypeKind !== null && tokenIsKeywordOrIdentifier(this.state.type)) {\n        specifier.imported = this.parseIdentifier(true);\n        specifier.importKind = specifierTypeKind;\n      } else {\n        if (importedIsString) {\n          throw this.raise(Errors.ImportBindingIsString, specifier, {\n            importName: firstIdent.value\n          });\n        }\n        specifier.imported = firstIdent;\n        specifier.importKind = null;\n      }\n      if (this.eatContextual(93)) {\n        specifier.local = this.parseIdentifier();\n      } else {\n        isBinding = true;\n        specifier.local = this.cloneIdentifier(specifier.imported);\n      }\n    }\n    const specifierIsTypeImport = hasTypeImportKind(specifier);\n    if (isInTypeOnlyImport && specifierIsTypeImport) {\n      this.raise(FlowErrors.ImportTypeShorthandOnlyInPureImport, specifier);\n    }\n    if (isInTypeOnlyImport || specifierIsTypeImport) {\n      this.checkReservedType(specifier.local.name, specifier.local.loc.start, true);\n    }\n    if (isBinding && !isInTypeOnlyImport && !specifierIsTypeImport) {\n      this.checkReservedWord(specifier.local.name, specifier.loc.start, true, true);\n    }\n    return this.finishImportSpecifier(specifier, \"ImportSpecifier\");\n  }\n  parseBindingAtom() {\n    switch (this.state.type) {\n      case 78:\n        return this.parseIdentifier(true);\n      default:\n        return super.parseBindingAtom();\n    }\n  }\n  parseFunctionParams(node, isConstructor) {\n    const kind = node.kind;\n    if (kind !== \"get\" && kind !== \"set\" && this.match(47)) {\n      node.typeParameters = this.flowParseTypeParameterDeclaration();\n    }\n    super.parseFunctionParams(node, isConstructor);\n  }\n  parseVarId(decl, kind) {\n    super.parseVarId(decl, kind);\n    if (this.match(14)) {\n      decl.id.typeAnnotation = this.flowParseTypeAnnotation();\n      this.resetEndLocation(decl.id);\n    }\n  }\n  parseAsyncArrowFromCallExpression(node, call) {\n    if (this.match(14)) {\n      const oldNoAnonFunctionType = this.state.noAnonFunctionType;\n      this.state.noAnonFunctionType = true;\n      node.returnType = this.flowParseTypeAnnotation();\n      this.state.noAnonFunctionType = oldNoAnonFunctionType;\n    }\n    return super.parseAsyncArrowFromCallExpression(node, call);\n  }\n  shouldParseAsyncArrow() {\n    return this.match(14) || super.shouldParseAsyncArrow();\n  }\n  parseMaybeAssign(refExpressionErrors, afterLeftParse) {\n    var _jsx;\n    let state = null;\n    let jsx;\n    if (this.hasPlugin(\"jsx\") && (this.match(143) || this.match(47))) {\n      state = this.state.clone();\n      jsx = this.tryParse(() => super.parseMaybeAssign(refExpressionErrors, afterLeftParse), state);\n      if (!jsx.error) return jsx.node;\n      const {\n        context\n      } = this.state;\n      const currentContext = context[context.length - 1];\n      if (currentContext === types.j_oTag || currentContext === types.j_expr) {\n        context.pop();\n      }\n    }\n    if ((_jsx = jsx) != null && _jsx.error || this.match(47)) {\n      var _jsx2, _jsx3;\n      state = state || this.state.clone();\n      let typeParameters;\n      const arrow = this.tryParse(abort => {\n        var _arrowExpression$extr;\n        typeParameters = this.flowParseTypeParameterDeclaration();\n        const arrowExpression = this.forwardNoArrowParamsConversionAt(typeParameters, () => {\n          const result = super.parseMaybeAssign(refExpressionErrors, afterLeftParse);\n          this.resetStartLocationFromNode(result, typeParameters);\n          return result;\n        });\n        if ((_arrowExpression$extr = arrowExpression.extra) != null && _arrowExpression$extr.parenthesized) abort();\n        const expr = this.maybeUnwrapTypeCastExpression(arrowExpression);\n        if (expr.type !== \"ArrowFunctionExpression\") abort();\n        expr.typeParameters = typeParameters;\n        this.resetStartLocationFromNode(expr, typeParameters);\n        return arrowExpression;\n      }, state);\n      let arrowExpression = null;\n      if (arrow.node && this.maybeUnwrapTypeCastExpression(arrow.node).type === \"ArrowFunctionExpression\") {\n        if (!arrow.error && !arrow.aborted) {\n          if (arrow.node.async) {\n            this.raise(FlowErrors.UnexpectedTypeParameterBeforeAsyncArrowFunction, typeParameters);\n          }\n          return arrow.node;\n        }\n        arrowExpression = arrow.node;\n      }\n      if ((_jsx2 = jsx) != null && _jsx2.node) {\n        this.state = jsx.failState;\n        return jsx.node;\n      }\n      if (arrowExpression) {\n        this.state = arrow.failState;\n        return arrowExpression;\n      }\n      if ((_jsx3 = jsx) != null && _jsx3.thrown) throw jsx.error;\n      if (arrow.thrown) throw arrow.error;\n      throw this.raise(FlowErrors.UnexpectedTokenAfterTypeParameter, typeParameters);\n    }\n    return super.parseMaybeAssign(refExpressionErrors, afterLeftParse);\n  }\n  parseArrow(node) {\n    if (this.match(14)) {\n      const result = this.tryParse(() => {\n        const oldNoAnonFunctionType = this.state.noAnonFunctionType;\n        this.state.noAnonFunctionType = true;\n        const typeNode = this.startNode();\n        [typeNode.typeAnnotation, node.predicate] = this.flowParseTypeAndPredicateInitialiser();\n        this.state.noAnonFunctionType = oldNoAnonFunctionType;\n        if (this.canInsertSemicolon()) this.unexpected();\n        if (!this.match(19)) this.unexpected();\n        return typeNode;\n      });\n      if (result.thrown) return null;\n      if (result.error) this.state = result.failState;\n      node.returnType = result.node.typeAnnotation ? this.finishNode(result.node, \"TypeAnnotation\") : null;\n    }\n    return super.parseArrow(node);\n  }\n  shouldParseArrow(params) {\n    return this.match(14) || super.shouldParseArrow(params);\n  }\n  setArrowFunctionParameters(node, params) {\n    if (this.state.noArrowParamsConversionAt.includes(this.offsetToSourcePos(node.start))) {\n      node.params = params;\n    } else {\n      super.setArrowFunctionParameters(node, params);\n    }\n  }\n  checkParams(node, allowDuplicates, isArrowFunction, strictModeChanged = true) {\n    if (isArrowFunction && this.state.noArrowParamsConversionAt.includes(this.offsetToSourcePos(node.start))) {\n      return;\n    }\n    for (let i = 0; i < node.params.length; i++) {\n      if (this.isThisParam(node.params[i]) && i > 0) {\n        this.raise(FlowErrors.ThisParamMustBeFirst, node.params[i]);\n      }\n    }\n    super.checkParams(node, allowDuplicates, isArrowFunction, strictModeChanged);\n  }\n  parseParenAndDistinguishExpression(canBeArrow) {\n    return super.parseParenAndDistinguishExpression(canBeArrow && !this.state.noArrowAt.includes(this.sourceToOffsetPos(this.state.start)));\n  }\n  parseSubscripts(base, startLoc, noCalls) {\n    if (base.type === \"Identifier\" && base.name === \"async\" && this.state.noArrowAt.includes(startLoc.index)) {\n      this.next();\n      const node = this.startNodeAt(startLoc);\n      node.callee = base;\n      node.arguments = super.parseCallExpressionArguments();\n      base = this.finishNode(node, \"CallExpression\");\n    } else if (base.type === \"Identifier\" && base.name === \"async\" && this.match(47)) {\n      const state = this.state.clone();\n      const arrow = this.tryParse(abort => this.parseAsyncArrowWithTypeParameters(startLoc) || abort(), state);\n      if (!arrow.error && !arrow.aborted) return arrow.node;\n      const result = this.tryParse(() => super.parseSubscripts(base, startLoc, noCalls), state);\n      if (result.node && !result.error) return result.node;\n      if (arrow.node) {\n        this.state = arrow.failState;\n        return arrow.node;\n      }\n      if (result.node) {\n        this.state = result.failState;\n        return result.node;\n      }\n      throw arrow.error || result.error;\n    }\n    return super.parseSubscripts(base, startLoc, noCalls);\n  }\n  parseSubscript(base, startLoc, noCalls, subscriptState) {\n    if (this.match(18) && this.isLookaheadToken_lt()) {\n      subscriptState.optionalChainMember = true;\n      if (noCalls) {\n        subscriptState.stop = true;\n        return base;\n      }\n      this.next();\n      const node = this.startNodeAt(startLoc);\n      node.callee = base;\n      node.typeArguments = this.flowParseTypeParameterInstantiationInExpression();\n      this.expect(10);\n      node.arguments = this.parseCallExpressionArguments();\n      node.optional = true;\n      return this.finishCallExpression(node, true);\n    } else if (!noCalls && this.shouldParseTypes() && (this.match(47) || this.match(51))) {\n      const node = this.startNodeAt(startLoc);\n      node.callee = base;\n      const result = this.tryParse(() => {\n        node.typeArguments = this.flowParseTypeParameterInstantiationCallOrNew();\n        this.expect(10);\n        node.arguments = super.parseCallExpressionArguments();\n        if (subscriptState.optionalChainMember) {\n          node.optional = false;\n        }\n        return this.finishCallExpression(node, subscriptState.optionalChainMember);\n      });\n      if (result.node) {\n        if (result.error) this.state = result.failState;\n        return result.node;\n      }\n    }\n    return super.parseSubscript(base, startLoc, noCalls, subscriptState);\n  }\n  parseNewCallee(node) {\n    super.parseNewCallee(node);\n    let targs = null;\n    if (this.shouldParseTypes() && this.match(47)) {\n      targs = this.tryParse(() => this.flowParseTypeParameterInstantiationCallOrNew()).node;\n    }\n    node.typeArguments = targs;\n  }\n  parseAsyncArrowWithTypeParameters(startLoc) {\n    const node = this.startNodeAt(startLoc);\n    this.parseFunctionParams(node, false);\n    if (!this.parseArrow(node)) return;\n    return super.parseArrowExpression(node, undefined, true);\n  }\n  readToken_mult_modulo(code) {\n    const next = this.input.charCodeAt(this.state.pos + 1);\n    if (code === 42 && next === 47 && this.state.hasFlowComment) {\n      this.state.hasFlowComment = false;\n      this.state.pos += 2;\n      this.nextToken();\n      return;\n    }\n    super.readToken_mult_modulo(code);\n  }\n  readToken_pipe_amp(code) {\n    const next = this.input.charCodeAt(this.state.pos + 1);\n    if (code === 124 && next === 125) {\n      this.finishOp(9, 2);\n      return;\n    }\n    super.readToken_pipe_amp(code);\n  }\n  parseTopLevel(file, program) {\n    const fileNode = super.parseTopLevel(file, program);\n    if (this.state.hasFlowComment) {\n      this.raise(FlowErrors.UnterminatedFlowComment, this.state.curPosition());\n    }\n    return fileNode;\n  }\n  skipBlockComment() {\n    if (this.hasPlugin(\"flowComments\") && this.skipFlowComment()) {\n      if (this.state.hasFlowComment) {\n        throw this.raise(FlowErrors.NestedFlowComment, this.state.startLoc);\n      }\n      this.hasFlowCommentCompletion();\n      const commentSkip = this.skipFlowComment();\n      if (commentSkip) {\n        this.state.pos += commentSkip;\n        this.state.hasFlowComment = true;\n      }\n      return;\n    }\n    return super.skipBlockComment(this.state.hasFlowComment ? \"*-/\" : \"*/\");\n  }\n  skipFlowComment() {\n    const {\n      pos\n    } = this.state;\n    let shiftToFirstNonWhiteSpace = 2;\n    while ([32, 9].includes(this.input.charCodeAt(pos + shiftToFirstNonWhiteSpace))) {\n      shiftToFirstNonWhiteSpace++;\n    }\n    const ch2 = this.input.charCodeAt(shiftToFirstNonWhiteSpace + pos);\n    const ch3 = this.input.charCodeAt(shiftToFirstNonWhiteSpace + pos + 1);\n    if (ch2 === 58 && ch3 === 58) {\n      return shiftToFirstNonWhiteSpace + 2;\n    }\n    if (this.input.slice(shiftToFirstNonWhiteSpace + pos, shiftToFirstNonWhiteSpace + pos + 12) === \"flow-include\") {\n      return shiftToFirstNonWhiteSpace + 12;\n    }\n    if (ch2 === 58 && ch3 !== 58) {\n      return shiftToFirstNonWhiteSpace;\n    }\n    return false;\n  }\n  hasFlowCommentCompletion() {\n    const end = this.input.indexOf(\"*/\", this.state.pos);\n    if (end === -1) {\n      throw this.raise(Errors.UnterminatedComment, this.state.curPosition());\n    }\n  }\n  flowEnumErrorBooleanMemberNotInitialized(loc, {\n    enumName,\n    memberName\n  }) {\n    this.raise(FlowErrors.EnumBooleanMemberNotInitialized, loc, {\n      memberName,\n      enumName\n    });\n  }\n  flowEnumErrorInvalidMemberInitializer(loc, enumContext) {\n    return this.raise(!enumContext.explicitType ? FlowErrors.EnumInvalidMemberInitializerUnknownType : enumContext.explicitType === \"symbol\" ? FlowErrors.EnumInvalidMemberInitializerSymbolType : FlowErrors.EnumInvalidMemberInitializerPrimaryType, loc, enumContext);\n  }\n  flowEnumErrorNumberMemberNotInitialized(loc, details) {\n    this.raise(FlowErrors.EnumNumberMemberNotInitialized, loc, details);\n  }\n  flowEnumErrorStringMemberInconsistentlyInitialized(node, details) {\n    this.raise(FlowErrors.EnumStringMemberInconsistentlyInitialized, node, details);\n  }\n  flowEnumMemberInit() {\n    const startLoc = this.state.startLoc;\n    const endOfInit = () => this.match(12) || this.match(8);\n    switch (this.state.type) {\n      case 135:\n        {\n          const literal = this.parseNumericLiteral(this.state.value);\n          if (endOfInit()) {\n            return {\n              type: \"number\",\n              loc: literal.loc.start,\n              value: literal\n            };\n          }\n          return {\n            type: \"invalid\",\n            loc: startLoc\n          };\n        }\n      case 134:\n        {\n          const literal = this.parseStringLiteral(this.state.value);\n          if (endOfInit()) {\n            return {\n              type: \"string\",\n              loc: literal.loc.start,\n              value: literal\n            };\n          }\n          return {\n            type: \"invalid\",\n            loc: startLoc\n          };\n        }\n      case 85:\n      case 86:\n        {\n          const literal = this.parseBooleanLiteral(this.match(85));\n          if (endOfInit()) {\n            return {\n              type: \"boolean\",\n              loc: literal.loc.start,\n              value: literal\n            };\n          }\n          return {\n            type: \"invalid\",\n            loc: startLoc\n          };\n        }\n      default:\n        return {\n          type: \"invalid\",\n          loc: startLoc\n        };\n    }\n  }\n  flowEnumMemberRaw() {\n    const loc = this.state.startLoc;\n    const id = this.parseIdentifier(true);\n    const init = this.eat(29) ? this.flowEnumMemberInit() : {\n      type: \"none\",\n      loc\n    };\n    return {\n      id,\n      init\n    };\n  }\n  flowEnumCheckExplicitTypeMismatch(loc, context, expectedType) {\n    const {\n      explicitType\n    } = context;\n    if (explicitType === null) {\n      return;\n    }\n    if (explicitType !== expectedType) {\n      this.flowEnumErrorInvalidMemberInitializer(loc, context);\n    }\n  }\n  flowEnumMembers({\n    enumName,\n    explicitType\n  }) {\n    const seenNames = new Set();\n    const members = {\n      booleanMembers: [],\n      numberMembers: [],\n      stringMembers: [],\n      defaultedMembers: []\n    };\n    let hasUnknownMembers = false;\n    while (!this.match(8)) {\n      if (this.eat(21)) {\n        hasUnknownMembers = true;\n        break;\n      }\n      const memberNode = this.startNode();\n      const {\n        id,\n        init\n      } = this.flowEnumMemberRaw();\n      const memberName = id.name;\n      if (memberName === \"\") {\n        continue;\n      }\n      if (/^[a-z]/.test(memberName)) {\n        this.raise(FlowErrors.EnumInvalidMemberName, id, {\n          memberName,\n          suggestion: memberName[0].toUpperCase() + memberName.slice(1),\n          enumName\n        });\n      }\n      if (seenNames.has(memberName)) {\n        this.raise(FlowErrors.EnumDuplicateMemberName, id, {\n          memberName,\n          enumName\n        });\n      }\n      seenNames.add(memberName);\n      const context = {\n        enumName,\n        explicitType,\n        memberName\n      };\n      memberNode.id = id;\n      switch (init.type) {\n        case \"boolean\":\n          {\n            this.flowEnumCheckExplicitTypeMismatch(init.loc, context, \"boolean\");\n            memberNode.init = init.value;\n            members.booleanMembers.push(this.finishNode(memberNode, \"EnumBooleanMember\"));\n            break;\n          }\n        case \"number\":\n          {\n            this.flowEnumCheckExplicitTypeMismatch(init.loc, context, \"number\");\n            memberNode.init = init.value;\n            members.numberMembers.push(this.finishNode(memberNode, \"EnumNumberMember\"));\n            break;\n          }\n        case \"string\":\n          {\n            this.flowEnumCheckExplicitTypeMismatch(init.loc, context, \"string\");\n            memberNode.init = init.value;\n            members.stringMembers.push(this.finishNode(memberNode, \"EnumStringMember\"));\n            break;\n          }\n        case \"invalid\":\n          {\n            throw this.flowEnumErrorInvalidMemberInitializer(init.loc, context);\n          }\n        case \"none\":\n          {\n            switch (explicitType) {\n              case \"boolean\":\n                this.flowEnumErrorBooleanMemberNotInitialized(init.loc, context);\n                break;\n              case \"number\":\n                this.flowEnumErrorNumberMemberNotInitialized(init.loc, context);\n                break;\n              default:\n                members.defaultedMembers.push(this.finishNode(memberNode, \"EnumDefaultedMember\"));\n            }\n          }\n      }\n      if (!this.match(8)) {\n        this.expect(12);\n      }\n    }\n    return {\n      members,\n      hasUnknownMembers\n    };\n  }\n  flowEnumStringMembers(initializedMembers, defaultedMembers, {\n    enumName\n  }) {\n    if (initializedMembers.length === 0) {\n      return defaultedMembers;\n    } else if (defaultedMembers.length === 0) {\n      return initializedMembers;\n    } else if (defaultedMembers.length > initializedMembers.length) {\n      for (const member of initializedMembers) {\n        this.flowEnumErrorStringMemberInconsistentlyInitialized(member, {\n          enumName\n        });\n      }\n      return defaultedMembers;\n    } else {\n      for (const member of defaultedMembers) {\n        this.flowEnumErrorStringMemberInconsistentlyInitialized(member, {\n          enumName\n        });\n      }\n      return initializedMembers;\n    }\n  }\n  flowEnumParseExplicitType({\n    enumName\n  }) {\n    if (!this.eatContextual(102)) return null;\n    if (!tokenIsIdentifier(this.state.type)) {\n      throw this.raise(FlowErrors.EnumInvalidExplicitTypeUnknownSupplied, this.state.startLoc, {\n        enumName\n      });\n    }\n    const {\n      value\n    } = this.state;\n    this.next();\n    if (value !== \"boolean\" && value !== \"number\" && value !== \"string\" && value !== \"symbol\") {\n      this.raise(FlowErrors.EnumInvalidExplicitType, this.state.startLoc, {\n        enumName,\n        invalidEnumType: value\n      });\n    }\n    return value;\n  }\n  flowEnumBody(node, id) {\n    const enumName = id.name;\n    const nameLoc = id.loc.start;\n    const explicitType = this.flowEnumParseExplicitType({\n      enumName\n    });\n    this.expect(5);\n    const {\n      members,\n      hasUnknownMembers\n    } = this.flowEnumMembers({\n      enumName,\n      explicitType\n    });\n    node.hasUnknownMembers = hasUnknownMembers;\n    switch (explicitType) {\n      case \"boolean\":\n        node.explicitType = true;\n        node.members = members.booleanMembers;\n        this.expect(8);\n        return this.finishNode(node, \"EnumBooleanBody\");\n      case \"number\":\n        node.explicitType = true;\n        node.members = members.numberMembers;\n        this.expect(8);\n        return this.finishNode(node, \"EnumNumberBody\");\n      case \"string\":\n        node.explicitType = true;\n        node.members = this.flowEnumStringMembers(members.stringMembers, members.defaultedMembers, {\n          enumName\n        });\n        this.expect(8);\n        return this.finishNode(node, \"EnumStringBody\");\n      case \"symbol\":\n        node.members = members.defaultedMembers;\n        this.expect(8);\n        return this.finishNode(node, \"EnumSymbolBody\");\n      default:\n        {\n          const empty = () => {\n            node.members = [];\n            this.expect(8);\n            return this.finishNode(node, \"EnumStringBody\");\n          };\n          node.explicitType = false;\n          const boolsLen = members.booleanMembers.length;\n          const numsLen = members.numberMembers.length;\n          const strsLen = members.stringMembers.length;\n          const defaultedLen = members.defaultedMembers.length;\n          if (!boolsLen && !numsLen && !strsLen && !defaultedLen) {\n            return empty();\n          } else if (!boolsLen && !numsLen) {\n            node.members = this.flowEnumStringMembers(members.stringMembers, members.defaultedMembers, {\n              enumName\n            });\n            this.expect(8);\n            return this.finishNode(node, \"EnumStringBody\");\n          } else if (!numsLen && !strsLen && boolsLen >= defaultedLen) {\n            for (const member of members.defaultedMembers) {\n              this.flowEnumErrorBooleanMemberNotInitialized(member.loc.start, {\n                enumName,\n                memberName: member.id.name\n              });\n            }\n            node.members = members.booleanMembers;\n            this.expect(8);\n            return this.finishNode(node, \"EnumBooleanBody\");\n          } else if (!boolsLen && !strsLen && numsLen >= defaultedLen) {\n            for (const member of members.defaultedMembers) {\n              this.flowEnumErrorNumberMemberNotInitialized(member.loc.start, {\n                enumName,\n                memberName: member.id.name\n              });\n            }\n            node.members = members.numberMembers;\n            this.expect(8);\n            return this.finishNode(node, \"EnumNumberBody\");\n          } else {\n            this.raise(FlowErrors.EnumInconsistentMemberValues, nameLoc, {\n              enumName\n            });\n            return empty();\n          }\n        }\n    }\n  }\n  flowParseEnumDeclaration(node) {\n    const id = this.parseIdentifier();\n    node.id = id;\n    node.body = this.flowEnumBody(this.startNode(), id);\n    return this.finishNode(node, \"EnumDeclaration\");\n  }\n  jsxParseOpeningElementAfterName(node) {\n    if (this.shouldParseTypes()) {\n      if (this.match(47) || this.match(51)) {\n        node.typeArguments = this.flowParseTypeParameterInstantiationInExpression();\n      }\n    }\n    return super.jsxParseOpeningElementAfterName(node);\n  }\n  isLookaheadToken_lt() {\n    const next = this.nextTokenStart();\n    if (this.input.charCodeAt(next) === 60) {\n      const afterNext = this.input.charCodeAt(next + 1);\n      return afterNext !== 60 && afterNext !== 61;\n    }\n    return false;\n  }\n  reScan_lt_gt() {\n    const {\n      type\n    } = this.state;\n    if (type === 47) {\n      this.state.pos -= 1;\n      this.readToken_lt();\n    } else if (type === 48) {\n      this.state.pos -= 1;\n      this.readToken_gt();\n    }\n  }\n  reScan_lt() {\n    const {\n      type\n    } = this.state;\n    if (type === 51) {\n      this.state.pos -= 2;\n      this.finishOp(47, 1);\n      return 47;\n    }\n    return type;\n  }\n  maybeUnwrapTypeCastExpression(node) {\n    return node.type === \"TypeCastExpression\" ? node.expression : node;\n  }\n};\nconst entities = {\n  __proto__: null,\n  quot: \"\\u0022\",\n  amp: \"&\",\n  apos: \"\\u0027\",\n  lt: \"<\",\n  gt: \">\",\n  nbsp: \"\\u00A0\",\n  iexcl: \"\\u00A1\",\n  cent: \"\\u00A2\",\n  pound: \"\\u00A3\",\n  curren: \"\\u00A4\",\n  yen: \"\\u00A5\",\n  brvbar: \"\\u00A6\",\n  sect: \"\\u00A7\",\n  uml: \"\\u00A8\",\n  copy: \"\\u00A9\",\n  ordf: \"\\u00AA\",\n  laquo: \"\\u00AB\",\n  not: \"\\u00AC\",\n  shy: \"\\u00AD\",\n  reg: \"\\u00AE\",\n  macr: \"\\u00AF\",\n  deg: \"\\u00B0\",\n  plusmn: \"\\u00B1\",\n  sup2: \"\\u00B2\",\n  sup3: \"\\u00B3\",\n  acute: \"\\u00B4\",\n  micro: \"\\u00B5\",\n  para: \"\\u00B6\",\n  middot: \"\\u00B7\",\n  cedil: \"\\u00B8\",\n  sup1: \"\\u00B9\",\n  ordm: \"\\u00BA\",\n  raquo: \"\\u00BB\",\n  frac14: \"\\u00BC\",\n  frac12: \"\\u00BD\",\n  frac34: \"\\u00BE\",\n  iquest: \"\\u00BF\",\n  Agrave: \"\\u00C0\",\n  Aacute: \"\\u00C1\",\n  Acirc: \"\\u00C2\",\n  Atilde: \"\\u00C3\",\n  Auml: \"\\u00C4\",\n  Aring: \"\\u00C5\",\n  AElig: \"\\u00C6\",\n  Ccedil: \"\\u00C7\",\n  Egrave: \"\\u00C8\",\n  Eacute: \"\\u00C9\",\n  Ecirc: \"\\u00CA\",\n  Euml: \"\\u00CB\",\n  Igrave: \"\\u00CC\",\n  Iacute: \"\\u00CD\",\n  Icirc: \"\\u00CE\",\n  Iuml: \"\\u00CF\",\n  ETH: \"\\u00D0\",\n  Ntilde: \"\\u00D1\",\n  Ograve: \"\\u00D2\",\n  Oacute: \"\\u00D3\",\n  Ocirc: \"\\u00D4\",\n  Otilde: \"\\u00D5\",\n  Ouml: \"\\u00D6\",\n  times: \"\\u00D7\",\n  Oslash: \"\\u00D8\",\n  Ugrave: \"\\u00D9\",\n  Uacute: \"\\u00DA\",\n  Ucirc: \"\\u00DB\",\n  Uuml: \"\\u00DC\",\n  Yacute: \"\\u00DD\",\n  THORN: \"\\u00DE\",\n  szlig: \"\\u00DF\",\n  agrave: \"\\u00E0\",\n  aacute: \"\\u00E1\",\n  acirc: \"\\u00E2\",\n  atilde: \"\\u00E3\",\n  auml: \"\\u00E4\",\n  aring: \"\\u00E5\",\n  aelig: \"\\u00E6\",\n  ccedil: \"\\u00E7\",\n  egrave: \"\\u00E8\",\n  eacute: \"\\u00E9\",\n  ecirc: \"\\u00EA\",\n  euml: \"\\u00EB\",\n  igrave: \"\\u00EC\",\n  iacute: \"\\u00ED\",\n  icirc: \"\\u00EE\",\n  iuml: \"\\u00EF\",\n  eth: \"\\u00F0\",\n  ntilde: \"\\u00F1\",\n  ograve: \"\\u00F2\",\n  oacute: \"\\u00F3\",\n  ocirc: \"\\u00F4\",\n  otilde: \"\\u00F5\",\n  ouml: \"\\u00F6\",\n  divide: \"\\u00F7\",\n  oslash: \"\\u00F8\",\n  ugrave: \"\\u00F9\",\n  uacute: \"\\u00FA\",\n  ucirc: \"\\u00FB\",\n  uuml: \"\\u00FC\",\n  yacute: \"\\u00FD\",\n  thorn: \"\\u00FE\",\n  yuml: \"\\u00FF\",\n  OElig: \"\\u0152\",\n  oelig: \"\\u0153\",\n  Scaron: \"\\u0160\",\n  scaron: \"\\u0161\",\n  Yuml: \"\\u0178\",\n  fnof: \"\\u0192\",\n  circ: \"\\u02C6\",\n  tilde: \"\\u02DC\",\n  Alpha: \"\\u0391\",\n  Beta: \"\\u0392\",\n  Gamma: \"\\u0393\",\n  Delta: \"\\u0394\",\n  Epsilon: \"\\u0395\",\n  Zeta: \"\\u0396\",\n  Eta: \"\\u0397\",\n  Theta: \"\\u0398\",\n  Iota: \"\\u0399\",\n  Kappa: \"\\u039A\",\n  Lambda: \"\\u039B\",\n  Mu: \"\\u039C\",\n  Nu: \"\\u039D\",\n  Xi: \"\\u039E\",\n  Omicron: \"\\u039F\",\n  Pi: \"\\u03A0\",\n  Rho: \"\\u03A1\",\n  Sigma: \"\\u03A3\",\n  Tau: \"\\u03A4\",\n  Upsilon: \"\\u03A5\",\n  Phi: \"\\u03A6\",\n  Chi: \"\\u03A7\",\n  Psi: \"\\u03A8\",\n  Omega: \"\\u03A9\",\n  alpha: \"\\u03B1\",\n  beta: \"\\u03B2\",\n  gamma: \"\\u03B3\",\n  delta: \"\\u03B4\",\n  epsilon: \"\\u03B5\",\n  zeta: \"\\u03B6\",\n  eta: \"\\u03B7\",\n  theta: \"\\u03B8\",\n  iota: \"\\u03B9\",\n  kappa: \"\\u03BA\",\n  lambda: \"\\u03BB\",\n  mu: \"\\u03BC\",\n  nu: \"\\u03BD\",\n  xi: \"\\u03BE\",\n  omicron: \"\\u03BF\",\n  pi: \"\\u03C0\",\n  rho: \"\\u03C1\",\n  sigmaf: \"\\u03C2\",\n  sigma: \"\\u03C3\",\n  tau: \"\\u03C4\",\n  upsilon: \"\\u03C5\",\n  phi: \"\\u03C6\",\n  chi: \"\\u03C7\",\n  psi: \"\\u03C8\",\n  omega: \"\\u03C9\",\n  thetasym: \"\\u03D1\",\n  upsih: \"\\u03D2\",\n  piv: \"\\u03D6\",\n  ensp: \"\\u2002\",\n  emsp: \"\\u2003\",\n  thinsp: \"\\u2009\",\n  zwnj: \"\\u200C\",\n  zwj: \"\\u200D\",\n  lrm: \"\\u200E\",\n  rlm: \"\\u200F\",\n  ndash: \"\\u2013\",\n  mdash: \"\\u2014\",\n  lsquo: \"\\u2018\",\n  rsquo: \"\\u2019\",\n  sbquo: \"\\u201A\",\n  ldquo: \"\\u201C\",\n  rdquo: \"\\u201D\",\n  bdquo: \"\\u201E\",\n  dagger: \"\\u2020\",\n  Dagger: \"\\u2021\",\n  bull: \"\\u2022\",\n  hellip: \"\\u2026\",\n  permil: \"\\u2030\",\n  prime: \"\\u2032\",\n  Prime: \"\\u2033\",\n  lsaquo: \"\\u2039\",\n  rsaquo: \"\\u203A\",\n  oline: \"\\u203E\",\n  frasl: \"\\u2044\",\n  euro: \"\\u20AC\",\n  image: \"\\u2111\",\n  weierp: \"\\u2118\",\n  real: \"\\u211C\",\n  trade: \"\\u2122\",\n  alefsym: \"\\u2135\",\n  larr: \"\\u2190\",\n  uarr: \"\\u2191\",\n  rarr: \"\\u2192\",\n  darr: \"\\u2193\",\n  harr: \"\\u2194\",\n  crarr: \"\\u21B5\",\n  lArr: \"\\u21D0\",\n  uArr: \"\\u21D1\",\n  rArr: \"\\u21D2\",\n  dArr: \"\\u21D3\",\n  hArr: \"\\u21D4\",\n  forall: \"\\u2200\",\n  part: \"\\u2202\",\n  exist: \"\\u2203\",\n  empty: \"\\u2205\",\n  nabla: \"\\u2207\",\n  isin: \"\\u2208\",\n  notin: \"\\u2209\",\n  ni: \"\\u220B\",\n  prod: \"\\u220F\",\n  sum: \"\\u2211\",\n  minus: \"\\u2212\",\n  lowast: \"\\u2217\",\n  radic: \"\\u221A\",\n  prop: \"\\u221D\",\n  infin: \"\\u221E\",\n  ang: \"\\u2220\",\n  and: \"\\u2227\",\n  or: \"\\u2228\",\n  cap: \"\\u2229\",\n  cup: \"\\u222A\",\n  int: \"\\u222B\",\n  there4: \"\\u2234\",\n  sim: \"\\u223C\",\n  cong: \"\\u2245\",\n  asymp: \"\\u2248\",\n  ne: \"\\u2260\",\n  equiv: \"\\u2261\",\n  le: \"\\u2264\",\n  ge: \"\\u2265\",\n  sub: \"\\u2282\",\n  sup: \"\\u2283\",\n  nsub: \"\\u2284\",\n  sube: \"\\u2286\",\n  supe: \"\\u2287\",\n  oplus: \"\\u2295\",\n  otimes: \"\\u2297\",\n  perp: \"\\u22A5\",\n  sdot: \"\\u22C5\",\n  lceil: \"\\u2308\",\n  rceil: \"\\u2309\",\n  lfloor: \"\\u230A\",\n  rfloor: \"\\u230B\",\n  lang: \"\\u2329\",\n  rang: \"\\u232A\",\n  loz: \"\\u25CA\",\n  spades: \"\\u2660\",\n  clubs: \"\\u2663\",\n  hearts: \"\\u2665\",\n  diams: \"\\u2666\"\n};\nconst lineBreak = /\\r\\n|[\\r\\n\\u2028\\u2029]/;\nconst lineBreakG = new RegExp(lineBreak.source, \"g\");\nfunction isNewLine(code) {\n  switch (code) {\n    case 10:\n    case 13:\n    case 8232:\n    case 8233:\n      return true;\n    default:\n      return false;\n  }\n}\nfunction hasNewLine(input, start, end) {\n  for (let i = start; i < end; i++) {\n    if (isNewLine(input.charCodeAt(i))) {\n      return true;\n    }\n  }\n  return false;\n}\nconst skipWhiteSpace = /(?:\\s|\\/\\/.*|\\/\\*[^]*?\\*\\/)*/g;\nconst skipWhiteSpaceInLine = /(?:[^\\S\\n\\r\\u2028\\u2029]|\\/\\/.*|\\/\\*.*?\\*\\/)*/g;\nfunction isWhitespace(code) {\n  switch (code) {\n    case 0x0009:\n    case 0x000b:\n    case 0x000c:\n    case 32:\n    case 160:\n    case 5760:\n    case 0x2000:\n    case 0x2001:\n    case 0x2002:\n    case 0x2003:\n    case 0x2004:\n    case 0x2005:\n    case 0x2006:\n    case 0x2007:\n    case 0x2008:\n    case 0x2009:\n    case 0x200a:\n    case 0x202f:\n    case 0x205f:\n    case 0x3000:\n    case 0xfeff:\n      return true;\n    default:\n      return false;\n  }\n}\nconst JsxErrors = ParseErrorEnum`jsx`({\n  AttributeIsEmpty: \"JSX attributes must only be assigned a non-empty expression.\",\n  MissingClosingTagElement: ({\n    openingTagName\n  }) => `Expected corresponding JSX closing tag for <${openingTagName}>.`,\n  MissingClosingTagFragment: \"Expected corresponding JSX closing tag for <>.\",\n  UnexpectedSequenceExpression: \"Sequence expressions cannot be directly nested inside JSX. Did you mean to wrap it in parentheses (...)?\",\n  UnexpectedToken: ({\n    unexpected,\n    HTMLEntity\n  }) => `Unexpected token \\`${unexpected}\\`. Did you mean \\`${HTMLEntity}\\` or \\`{'${unexpected}'}\\`?`,\n  UnsupportedJsxValue: \"JSX value should be either an expression or a quoted JSX text.\",\n  UnterminatedJsxContent: \"Unterminated JSX contents.\",\n  UnwrappedAdjacentJSXElements: \"Adjacent JSX elements must be wrapped in an enclosing tag. Did you want a JSX fragment <>...</>?\"\n});\nfunction isFragment(object) {\n  return object ? object.type === \"JSXOpeningFragment\" || object.type === \"JSXClosingFragment\" : false;\n}\nfunction getQualifiedJSXName(object) {\n  if (object.type === \"JSXIdentifier\") {\n    return object.name;\n  }\n  if (object.type === \"JSXNamespacedName\") {\n    return object.namespace.name + \":\" + object.name.name;\n  }\n  if (object.type === \"JSXMemberExpression\") {\n    return getQualifiedJSXName(object.object) + \".\" + getQualifiedJSXName(object.property);\n  }\n  throw new Error(\"Node had unexpected type: \" + object.type);\n}\nvar jsx = superClass => class JSXParserMixin extends superClass {\n  jsxReadToken() {\n    let out = \"\";\n    let chunkStart = this.state.pos;\n    for (;;) {\n      if (this.state.pos >= this.length) {\n        throw this.raise(JsxErrors.UnterminatedJsxContent, this.state.startLoc);\n      }\n      const ch = this.input.charCodeAt(this.state.pos);\n      switch (ch) {\n        case 60:\n        case 123:\n          if (this.state.pos === this.state.start) {\n            if (ch === 60 && this.state.canStartJSXElement) {\n              ++this.state.pos;\n              this.finishToken(143);\n            } else {\n              super.getTokenFromCode(ch);\n            }\n            return;\n          }\n          out += this.input.slice(chunkStart, this.state.pos);\n          this.finishToken(142, out);\n          return;\n        case 38:\n          out += this.input.slice(chunkStart, this.state.pos);\n          out += this.jsxReadEntity();\n          chunkStart = this.state.pos;\n          break;\n        case 62:\n        case 125:\n        default:\n          if (isNewLine(ch)) {\n            out += this.input.slice(chunkStart, this.state.pos);\n            out += this.jsxReadNewLine(true);\n            chunkStart = this.state.pos;\n          } else {\n            ++this.state.pos;\n          }\n      }\n    }\n  }\n  jsxReadNewLine(normalizeCRLF) {\n    const ch = this.input.charCodeAt(this.state.pos);\n    let out;\n    ++this.state.pos;\n    if (ch === 13 && this.input.charCodeAt(this.state.pos) === 10) {\n      ++this.state.pos;\n      out = normalizeCRLF ? \"\\n\" : \"\\r\\n\";\n    } else {\n      out = String.fromCharCode(ch);\n    }\n    ++this.state.curLine;\n    this.state.lineStart = this.state.pos;\n    return out;\n  }\n  jsxReadString(quote) {\n    let out = \"\";\n    let chunkStart = ++this.state.pos;\n    for (;;) {\n      if (this.state.pos >= this.length) {\n        throw this.raise(Errors.UnterminatedString, this.state.startLoc);\n      }\n      const ch = this.input.charCodeAt(this.state.pos);\n      if (ch === quote) break;\n      if (ch === 38) {\n        out += this.input.slice(chunkStart, this.state.pos);\n        out += this.jsxReadEntity();\n        chunkStart = this.state.pos;\n      } else if (isNewLine(ch)) {\n        out += this.input.slice(chunkStart, this.state.pos);\n        out += this.jsxReadNewLine(false);\n        chunkStart = this.state.pos;\n      } else {\n        ++this.state.pos;\n      }\n    }\n    out += this.input.slice(chunkStart, this.state.pos++);\n    this.finishToken(134, out);\n  }\n  jsxReadEntity() {\n    const startPos = ++this.state.pos;\n    if (this.codePointAtPos(this.state.pos) === 35) {\n      ++this.state.pos;\n      let radix = 10;\n      if (this.codePointAtPos(this.state.pos) === 120) {\n        radix = 16;\n        ++this.state.pos;\n      }\n      const codePoint = this.readInt(radix, undefined, false, \"bail\");\n      if (codePoint !== null && this.codePointAtPos(this.state.pos) === 59) {\n        ++this.state.pos;\n        return String.fromCodePoint(codePoint);\n      }\n    } else {\n      let count = 0;\n      let semi = false;\n      while (count++ < 10 && this.state.pos < this.length && !(semi = this.codePointAtPos(this.state.pos) === 59)) {\n        ++this.state.pos;\n      }\n      if (semi) {\n        const desc = this.input.slice(startPos, this.state.pos);\n        const entity = entities[desc];\n        ++this.state.pos;\n        if (entity) {\n          return entity;\n        }\n      }\n    }\n    this.state.pos = startPos;\n    return \"&\";\n  }\n  jsxReadWord() {\n    let ch;\n    const start = this.state.pos;\n    do {\n      ch = this.input.charCodeAt(++this.state.pos);\n    } while (isIdentifierChar(ch) || ch === 45);\n    this.finishToken(141, this.input.slice(start, this.state.pos));\n  }\n  jsxParseIdentifier() {\n    const node = this.startNode();\n    if (this.match(141)) {\n      node.name = this.state.value;\n    } else if (tokenIsKeyword(this.state.type)) {\n      node.name = tokenLabelName(this.state.type);\n    } else {\n      this.unexpected();\n    }\n    this.next();\n    return this.finishNode(node, \"JSXIdentifier\");\n  }\n  jsxParseNamespacedName() {\n    const startLoc = this.state.startLoc;\n    const name = this.jsxParseIdentifier();\n    if (!this.eat(14)) return name;\n    const node = this.startNodeAt(startLoc);\n    node.namespace = name;\n    node.name = this.jsxParseIdentifier();\n    return this.finishNode(node, \"JSXNamespacedName\");\n  }\n  jsxParseElementName() {\n    const startLoc = this.state.startLoc;\n    let node = this.jsxParseNamespacedName();\n    if (node.type === \"JSXNamespacedName\") {\n      return node;\n    }\n    while (this.eat(16)) {\n      const newNode = this.startNodeAt(startLoc);\n      newNode.object = node;\n      newNode.property = this.jsxParseIdentifier();\n      node = this.finishNode(newNode, \"JSXMemberExpression\");\n    }\n    return node;\n  }\n  jsxParseAttributeValue() {\n    let node;\n    switch (this.state.type) {\n      case 5:\n        node = this.startNode();\n        this.setContext(types.brace);\n        this.next();\n        node = this.jsxParseExpressionContainer(node, types.j_oTag);\n        if (node.expression.type === \"JSXEmptyExpression\") {\n          this.raise(JsxErrors.AttributeIsEmpty, node);\n        }\n        return node;\n      case 143:\n      case 134:\n        return this.parseExprAtom();\n      default:\n        throw this.raise(JsxErrors.UnsupportedJsxValue, this.state.startLoc);\n    }\n  }\n  jsxParseEmptyExpression() {\n    const node = this.startNodeAt(this.state.lastTokEndLoc);\n    return this.finishNodeAt(node, \"JSXEmptyExpression\", this.state.startLoc);\n  }\n  jsxParseSpreadChild(node) {\n    this.next();\n    node.expression = this.parseExpression();\n    this.setContext(types.j_expr);\n    this.state.canStartJSXElement = true;\n    this.expect(8);\n    return this.finishNode(node, \"JSXSpreadChild\");\n  }\n  jsxParseExpressionContainer(node, previousContext) {\n    if (this.match(8)) {\n      node.expression = this.jsxParseEmptyExpression();\n    } else {\n      const expression = this.parseExpression();\n      node.expression = expression;\n    }\n    this.setContext(previousContext);\n    this.state.canStartJSXElement = true;\n    this.expect(8);\n    return this.finishNode(node, \"JSXExpressionContainer\");\n  }\n  jsxParseAttribute() {\n    const node = this.startNode();\n    if (this.match(5)) {\n      this.setContext(types.brace);\n      this.next();\n      this.expect(21);\n      node.argument = this.parseMaybeAssignAllowIn();\n      this.setContext(types.j_oTag);\n      this.state.canStartJSXElement = true;\n      this.expect(8);\n      return this.finishNode(node, \"JSXSpreadAttribute\");\n    }\n    node.name = this.jsxParseNamespacedName();\n    node.value = this.eat(29) ? this.jsxParseAttributeValue() : null;\n    return this.finishNode(node, \"JSXAttribute\");\n  }\n  jsxParseOpeningElementAt(startLoc) {\n    const node = this.startNodeAt(startLoc);\n    if (this.eat(144)) {\n      return this.finishNode(node, \"JSXOpeningFragment\");\n    }\n    node.name = this.jsxParseElementName();\n    return this.jsxParseOpeningElementAfterName(node);\n  }\n  jsxParseOpeningElementAfterName(node) {\n    const attributes = [];\n    while (!this.match(56) && !this.match(144)) {\n      attributes.push(this.jsxParseAttribute());\n    }\n    node.attributes = attributes;\n    node.selfClosing = this.eat(56);\n    this.expect(144);\n    return this.finishNode(node, \"JSXOpeningElement\");\n  }\n  jsxParseClosingElementAt(startLoc) {\n    const node = this.startNodeAt(startLoc);\n    if (this.eat(144)) {\n      return this.finishNode(node, \"JSXClosingFragment\");\n    }\n    node.name = this.jsxParseElementName();\n    this.expect(144);\n    return this.finishNode(node, \"JSXClosingElement\");\n  }\n  jsxParseElementAt(startLoc) {\n    const node = this.startNodeAt(startLoc);\n    const children = [];\n    const openingElement = this.jsxParseOpeningElementAt(startLoc);\n    let closingElement = null;\n    if (!openingElement.selfClosing) {\n      contents: for (;;) {\n        switch (this.state.type) {\n          case 143:\n            startLoc = this.state.startLoc;\n            this.next();\n            if (this.eat(56)) {\n              closingElement = this.jsxParseClosingElementAt(startLoc);\n              break contents;\n            }\n            children.push(this.jsxParseElementAt(startLoc));\n            break;\n          case 142:\n            children.push(this.parseLiteral(this.state.value, \"JSXText\"));\n            break;\n          case 5:\n            {\n              const node = this.startNode();\n              this.setContext(types.brace);\n              this.next();\n              if (this.match(21)) {\n                children.push(this.jsxParseSpreadChild(node));\n              } else {\n                children.push(this.jsxParseExpressionContainer(node, types.j_expr));\n              }\n              break;\n            }\n          default:\n            this.unexpected();\n        }\n      }\n      if (isFragment(openingElement) && !isFragment(closingElement) && closingElement !== null) {\n        this.raise(JsxErrors.MissingClosingTagFragment, closingElement);\n      } else if (!isFragment(openingElement) && isFragment(closingElement)) {\n        this.raise(JsxErrors.MissingClosingTagElement, closingElement, {\n          openingTagName: getQualifiedJSXName(openingElement.name)\n        });\n      } else if (!isFragment(openingElement) && !isFragment(closingElement)) {\n        if (getQualifiedJSXName(closingElement.name) !== getQualifiedJSXName(openingElement.name)) {\n          this.raise(JsxErrors.MissingClosingTagElement, closingElement, {\n            openingTagName: getQualifiedJSXName(openingElement.name)\n          });\n        }\n      }\n    }\n    if (isFragment(openingElement)) {\n      node.openingFragment = openingElement;\n      node.closingFragment = closingElement;\n    } else {\n      node.openingElement = openingElement;\n      node.closingElement = closingElement;\n    }\n    node.children = children;\n    if (this.match(47)) {\n      throw this.raise(JsxErrors.UnwrappedAdjacentJSXElements, this.state.startLoc);\n    }\n    return isFragment(openingElement) ? this.finishNode(node, \"JSXFragment\") : this.finishNode(node, \"JSXElement\");\n  }\n  jsxParseElement() {\n    const startLoc = this.state.startLoc;\n    this.next();\n    return this.jsxParseElementAt(startLoc);\n  }\n  setContext(newContext) {\n    const {\n      context\n    } = this.state;\n    context[context.length - 1] = newContext;\n  }\n  parseExprAtom(refExpressionErrors) {\n    if (this.match(143)) {\n      return this.jsxParseElement();\n    } else if (this.match(47) && this.input.charCodeAt(this.state.pos) !== 33) {\n      this.replaceToken(143);\n      return this.jsxParseElement();\n    } else {\n      return super.parseExprAtom(refExpressionErrors);\n    }\n  }\n  skipSpace() {\n    const curContext = this.curContext();\n    if (!curContext.preserveSpace) super.skipSpace();\n  }\n  getTokenFromCode(code) {\n    const context = this.curContext();\n    if (context === types.j_expr) {\n      this.jsxReadToken();\n      return;\n    }\n    if (context === types.j_oTag || context === types.j_cTag) {\n      if (isIdentifierStart(code)) {\n        this.jsxReadWord();\n        return;\n      }\n      if (code === 62) {\n        ++this.state.pos;\n        this.finishToken(144);\n        return;\n      }\n      if ((code === 34 || code === 39) && context === types.j_oTag) {\n        this.jsxReadString(code);\n        return;\n      }\n    }\n    if (code === 60 && this.state.canStartJSXElement && this.input.charCodeAt(this.state.pos + 1) !== 33) {\n      ++this.state.pos;\n      this.finishToken(143);\n      return;\n    }\n    super.getTokenFromCode(code);\n  }\n  updateContext(prevType) {\n    const {\n      context,\n      type\n    } = this.state;\n    if (type === 56 && prevType === 143) {\n      context.splice(-2, 2, types.j_cTag);\n      this.state.canStartJSXElement = false;\n    } else if (type === 143) {\n      context.push(types.j_oTag);\n    } else if (type === 144) {\n      const out = context[context.length - 1];\n      if (out === types.j_oTag && prevType === 56 || out === types.j_cTag) {\n        context.pop();\n        this.state.canStartJSXElement = context[context.length - 1] === types.j_expr;\n      } else {\n        this.setContext(types.j_expr);\n        this.state.canStartJSXElement = true;\n      }\n    } else {\n      this.state.canStartJSXElement = tokenComesBeforeExpression(type);\n    }\n  }\n};\nclass TypeScriptScope extends Scope {\n  constructor(...args) {\n    super(...args);\n    this.tsNames = new Map();\n  }\n}\nclass TypeScriptScopeHandler extends ScopeHandler {\n  constructor(...args) {\n    super(...args);\n    this.importsStack = [];\n  }\n  createScope(flags) {\n    this.importsStack.push(new Set());\n    return new TypeScriptScope(flags);\n  }\n  enter(flags) {\n    if (flags === 1024) {\n      this.importsStack.push(new Set());\n    }\n    super.enter(flags);\n  }\n  exit() {\n    const flags = super.exit();\n    if (flags === 1024) {\n      this.importsStack.pop();\n    }\n    return flags;\n  }\n  hasImport(name, allowShadow) {\n    const len = this.importsStack.length;\n    if (this.importsStack[len - 1].has(name)) {\n      return true;\n    }\n    if (!allowShadow && len > 1) {\n      for (let i = 0; i < len - 1; i++) {\n        if (this.importsStack[i].has(name)) return true;\n      }\n    }\n    return false;\n  }\n  declareName(name, bindingType, loc) {\n    if (bindingType & 4096) {\n      if (this.hasImport(name, true)) {\n        this.parser.raise(Errors.VarRedeclaration, loc, {\n          identifierName: name\n        });\n      }\n      this.importsStack[this.importsStack.length - 1].add(name);\n      return;\n    }\n    const scope = this.currentScope();\n    let type = scope.tsNames.get(name) || 0;\n    if (bindingType & 1024) {\n      this.maybeExportDefined(scope, name);\n      scope.tsNames.set(name, type | 16);\n      return;\n    }\n    super.declareName(name, bindingType, loc);\n    if (bindingType & 2) {\n      if (!(bindingType & 1)) {\n        this.checkRedeclarationInScope(scope, name, bindingType, loc);\n        this.maybeExportDefined(scope, name);\n      }\n      type = type | 1;\n    }\n    if (bindingType & 256) {\n      type = type | 2;\n    }\n    if (bindingType & 512) {\n      type = type | 4;\n    }\n    if (bindingType & 128) {\n      type = type | 8;\n    }\n    if (type) scope.tsNames.set(name, type);\n  }\n  isRedeclaredInScope(scope, name, bindingType) {\n    const type = scope.tsNames.get(name);\n    if ((type & 2) > 0) {\n      if (bindingType & 256) {\n        const isConst = !!(bindingType & 512);\n        const wasConst = (type & 4) > 0;\n        return isConst !== wasConst;\n      }\n      return true;\n    }\n    if (bindingType & 128 && (type & 8) > 0) {\n      if (scope.names.get(name) & 2) {\n        return !!(bindingType & 1);\n      } else {\n        return false;\n      }\n    }\n    if (bindingType & 2 && (type & 1) > 0) {\n      return true;\n    }\n    return super.isRedeclaredInScope(scope, name, bindingType);\n  }\n  checkLocalExport(id) {\n    const {\n      name\n    } = id;\n    if (this.hasImport(name)) return;\n    const len = this.scopeStack.length;\n    for (let i = len - 1; i >= 0; i--) {\n      const scope = this.scopeStack[i];\n      const type = scope.tsNames.get(name);\n      if ((type & 1) > 0 || (type & 16) > 0) {\n        return;\n      }\n    }\n    super.checkLocalExport(id);\n  }\n}\nclass ProductionParameterHandler {\n  constructor() {\n    this.stacks = [];\n  }\n  enter(flags) {\n    this.stacks.push(flags);\n  }\n  exit() {\n    this.stacks.pop();\n  }\n  currentFlags() {\n    return this.stacks[this.stacks.length - 1];\n  }\n  get hasAwait() {\n    return (this.currentFlags() & 2) > 0;\n  }\n  get hasYield() {\n    return (this.currentFlags() & 1) > 0;\n  }\n  get hasReturn() {\n    return (this.currentFlags() & 4) > 0;\n  }\n  get hasIn() {\n    return (this.currentFlags() & 8) > 0;\n  }\n}\nfunction functionFlags(isAsync, isGenerator) {\n  return (isAsync ? 2 : 0) | (isGenerator ? 1 : 0);\n}\nclass BaseParser {\n  constructor() {\n    this.sawUnambiguousESM = false;\n    this.ambiguousScriptDifferentAst = false;\n  }\n  sourceToOffsetPos(sourcePos) {\n    return sourcePos + this.startIndex;\n  }\n  offsetToSourcePos(offsetPos) {\n    return offsetPos - this.startIndex;\n  }\n  hasPlugin(pluginConfig) {\n    if (typeof pluginConfig === \"string\") {\n      return this.plugins.has(pluginConfig);\n    } else {\n      const [pluginName, pluginOptions] = pluginConfig;\n      if (!this.hasPlugin(pluginName)) {\n        return false;\n      }\n      const actualOptions = this.plugins.get(pluginName);\n      for (const key of Object.keys(pluginOptions)) {\n        if ((actualOptions == null ? void 0 : actualOptions[key]) !== pluginOptions[key]) {\n          return false;\n        }\n      }\n      return true;\n    }\n  }\n  getPluginOption(plugin, name) {\n    var _this$plugins$get;\n    return (_this$plugins$get = this.plugins.get(plugin)) == null ? void 0 : _this$plugins$get[name];\n  }\n}\nfunction setTrailingComments(node, comments) {\n  if (node.trailingComments === undefined) {\n    node.trailingComments = comments;\n  } else {\n    node.trailingComments.unshift(...comments);\n  }\n}\nfunction setLeadingComments(node, comments) {\n  if (node.leadingComments === undefined) {\n    node.leadingComments = comments;\n  } else {\n    node.leadingComments.unshift(...comments);\n  }\n}\nfunction setInnerComments(node, comments) {\n  if (node.innerComments === undefined) {\n    node.innerComments = comments;\n  } else {\n    node.innerComments.unshift(...comments);\n  }\n}\nfunction adjustInnerComments(node, elements, commentWS) {\n  let lastElement = null;\n  let i = elements.length;\n  while (lastElement === null && i > 0) {\n    lastElement = elements[--i];\n  }\n  if (lastElement === null || lastElement.start > commentWS.start) {\n    setInnerComments(node, commentWS.comments);\n  } else {\n    setTrailingComments(lastElement, commentWS.comments);\n  }\n}\nclass CommentsParser extends BaseParser {\n  addComment(comment) {\n    if (this.filename) comment.loc.filename = this.filename;\n    const {\n      commentsLen\n    } = this.state;\n    if (this.comments.length !== commentsLen) {\n      this.comments.length = commentsLen;\n    }\n    this.comments.push(comment);\n    this.state.commentsLen++;\n  }\n  processComment(node) {\n    const {\n      commentStack\n    } = this.state;\n    const commentStackLength = commentStack.length;\n    if (commentStackLength === 0) return;\n    let i = commentStackLength - 1;\n    const lastCommentWS = commentStack[i];\n    if (lastCommentWS.start === node.end) {\n      lastCommentWS.leadingNode = node;\n      i--;\n    }\n    const {\n      start: nodeStart\n    } = node;\n    for (; i >= 0; i--) {\n      const commentWS = commentStack[i];\n      const commentEnd = commentWS.end;\n      if (commentEnd > nodeStart) {\n        commentWS.containingNode = node;\n        this.finalizeComment(commentWS);\n        commentStack.splice(i, 1);\n      } else {\n        if (commentEnd === nodeStart) {\n          commentWS.trailingNode = node;\n        }\n        break;\n      }\n    }\n  }\n  finalizeComment(commentWS) {\n    var _node$options;\n    const {\n      comments\n    } = commentWS;\n    if (commentWS.leadingNode !== null || commentWS.trailingNode !== null) {\n      if (commentWS.leadingNode !== null) {\n        setTrailingComments(commentWS.leadingNode, comments);\n      }\n      if (commentWS.trailingNode !== null) {\n        setLeadingComments(commentWS.trailingNode, comments);\n      }\n    } else {\n      const node = commentWS.containingNode;\n      const commentStart = commentWS.start;\n      if (this.input.charCodeAt(this.offsetToSourcePos(commentStart) - 1) === 44) {\n        switch (node.type) {\n          case \"ObjectExpression\":\n          case \"ObjectPattern\":\n            adjustInnerComments(node, node.properties, commentWS);\n            break;\n          case \"CallExpression\":\n          case \"OptionalCallExpression\":\n            adjustInnerComments(node, node.arguments, commentWS);\n            break;\n          case \"ImportExpression\":\n            adjustInnerComments(node, [node.source, (_node$options = node.options) != null ? _node$options : null], commentWS);\n            break;\n          case \"FunctionDeclaration\":\n          case \"FunctionExpression\":\n          case \"ArrowFunctionExpression\":\n          case \"ObjectMethod\":\n          case \"ClassMethod\":\n          case \"ClassPrivateMethod\":\n            adjustInnerComments(node, node.params, commentWS);\n            break;\n          case \"ArrayExpression\":\n          case \"ArrayPattern\":\n            adjustInnerComments(node, node.elements, commentWS);\n            break;\n          case \"ExportNamedDeclaration\":\n          case \"ImportDeclaration\":\n            adjustInnerComments(node, node.specifiers, commentWS);\n            break;\n          case \"TSEnumDeclaration\":\n            adjustInnerComments(node, node.members, commentWS);\n            break;\n          case \"TSEnumBody\":\n            adjustInnerComments(node, node.members, commentWS);\n            break;\n          default:\n            {\n              if (node.type === \"RecordExpression\") {\n                adjustInnerComments(node, node.properties, commentWS);\n                break;\n              }\n              if (node.type === \"TupleExpression\") {\n                adjustInnerComments(node, node.elements, commentWS);\n                break;\n              }\n              setInnerComments(node, comments);\n            }\n        }\n      } else {\n        setInnerComments(node, comments);\n      }\n    }\n  }\n  finalizeRemainingComments() {\n    const {\n      commentStack\n    } = this.state;\n    for (let i = commentStack.length - 1; i >= 0; i--) {\n      this.finalizeComment(commentStack[i]);\n    }\n    this.state.commentStack = [];\n  }\n  resetPreviousNodeTrailingComments(node) {\n    const {\n      commentStack\n    } = this.state;\n    const {\n      length\n    } = commentStack;\n    if (length === 0) return;\n    const commentWS = commentStack[length - 1];\n    if (commentWS.leadingNode === node) {\n      commentWS.leadingNode = null;\n    }\n  }\n  takeSurroundingComments(node, start, end) {\n    const {\n      commentStack\n    } = this.state;\n    const commentStackLength = commentStack.length;\n    if (commentStackLength === 0) return;\n    let i = commentStackLength - 1;\n    for (; i >= 0; i--) {\n      const commentWS = commentStack[i];\n      const commentEnd = commentWS.end;\n      const commentStart = commentWS.start;\n      if (commentStart === end) {\n        commentWS.leadingNode = node;\n      } else if (commentEnd === start) {\n        commentWS.trailingNode = node;\n      } else if (commentEnd < start) {\n        break;\n      }\n    }\n  }\n}\nclass State {\n  constructor() {\n    this.flags = 1024;\n    this.startIndex = void 0;\n    this.curLine = void 0;\n    this.lineStart = void 0;\n    this.startLoc = void 0;\n    this.endLoc = void 0;\n    this.errors = [];\n    this.potentialArrowAt = -1;\n    this.noArrowAt = [];\n    this.noArrowParamsConversionAt = [];\n    this.topicContext = {\n      maxNumOfResolvableTopics: 0,\n      maxTopicIndex: null\n    };\n    this.labels = [];\n    this.commentsLen = 0;\n    this.commentStack = [];\n    this.pos = 0;\n    this.type = 140;\n    this.value = null;\n    this.start = 0;\n    this.end = 0;\n    this.lastTokEndLoc = null;\n    this.lastTokStartLoc = null;\n    this.context = [types.brace];\n    this.firstInvalidTemplateEscapePos = null;\n    this.strictErrors = new Map();\n    this.tokensLength = 0;\n  }\n  get strict() {\n    return (this.flags & 1) > 0;\n  }\n  set strict(v) {\n    if (v) this.flags |= 1;else this.flags &= -2;\n  }\n  init({\n    strictMode,\n    sourceType,\n    startIndex,\n    startLine,\n    startColumn\n  }) {\n    this.strict = strictMode === false ? false : strictMode === true ? true : sourceType === \"module\";\n    this.startIndex = startIndex;\n    this.curLine = startLine;\n    this.lineStart = -startColumn;\n    this.startLoc = this.endLoc = new Position(startLine, startColumn, startIndex);\n  }\n  get maybeInArrowParameters() {\n    return (this.flags & 2) > 0;\n  }\n  set maybeInArrowParameters(v) {\n    if (v) this.flags |= 2;else this.flags &= -3;\n  }\n  get inType() {\n    return (this.flags & 4) > 0;\n  }\n  set inType(v) {\n    if (v) this.flags |= 4;else this.flags &= -5;\n  }\n  get noAnonFunctionType() {\n    return (this.flags & 8) > 0;\n  }\n  set noAnonFunctionType(v) {\n    if (v) this.flags |= 8;else this.flags &= -9;\n  }\n  get hasFlowComment() {\n    return (this.flags & 16) > 0;\n  }\n  set hasFlowComment(v) {\n    if (v) this.flags |= 16;else this.flags &= -17;\n  }\n  get isAmbientContext() {\n    return (this.flags & 32) > 0;\n  }\n  set isAmbientContext(v) {\n    if (v) this.flags |= 32;else this.flags &= -33;\n  }\n  get inAbstractClass() {\n    return (this.flags & 64) > 0;\n  }\n  set inAbstractClass(v) {\n    if (v) this.flags |= 64;else this.flags &= -65;\n  }\n  get inDisallowConditionalTypesContext() {\n    return (this.flags & 128) > 0;\n  }\n  set inDisallowConditionalTypesContext(v) {\n    if (v) this.flags |= 128;else this.flags &= -129;\n  }\n  get soloAwait() {\n    return (this.flags & 256) > 0;\n  }\n  set soloAwait(v) {\n    if (v) this.flags |= 256;else this.flags &= -257;\n  }\n  get inFSharpPipelineDirectBody() {\n    return (this.flags & 512) > 0;\n  }\n  set inFSharpPipelineDirectBody(v) {\n    if (v) this.flags |= 512;else this.flags &= -513;\n  }\n  get canStartJSXElement() {\n    return (this.flags & 1024) > 0;\n  }\n  set canStartJSXElement(v) {\n    if (v) this.flags |= 1024;else this.flags &= -1025;\n  }\n  get containsEsc() {\n    return (this.flags & 2048) > 0;\n  }\n  set containsEsc(v) {\n    if (v) this.flags |= 2048;else this.flags &= -2049;\n  }\n  get hasTopLevelAwait() {\n    return (this.flags & 4096) > 0;\n  }\n  set hasTopLevelAwait(v) {\n    if (v) this.flags |= 4096;else this.flags &= -4097;\n  }\n  curPosition() {\n    return new Position(this.curLine, this.pos - this.lineStart, this.pos + this.startIndex);\n  }\n  clone() {\n    const state = new State();\n    state.flags = this.flags;\n    state.startIndex = this.startIndex;\n    state.curLine = this.curLine;\n    state.lineStart = this.lineStart;\n    state.startLoc = this.startLoc;\n    state.endLoc = this.endLoc;\n    state.errors = this.errors.slice();\n    state.potentialArrowAt = this.potentialArrowAt;\n    state.noArrowAt = this.noArrowAt.slice();\n    state.noArrowParamsConversionAt = this.noArrowParamsConversionAt.slice();\n    state.topicContext = this.topicContext;\n    state.labels = this.labels.slice();\n    state.commentsLen = this.commentsLen;\n    state.commentStack = this.commentStack.slice();\n    state.pos = this.pos;\n    state.type = this.type;\n    state.value = this.value;\n    state.start = this.start;\n    state.end = this.end;\n    state.lastTokEndLoc = this.lastTokEndLoc;\n    state.lastTokStartLoc = this.lastTokStartLoc;\n    state.context = this.context.slice();\n    state.firstInvalidTemplateEscapePos = this.firstInvalidTemplateEscapePos;\n    state.strictErrors = this.strictErrors;\n    state.tokensLength = this.tokensLength;\n    return state;\n  }\n}\nvar _isDigit = function isDigit(code) {\n  return code >= 48 && code <= 57;\n};\nconst forbiddenNumericSeparatorSiblings = {\n  decBinOct: new Set([46, 66, 69, 79, 95, 98, 101, 111]),\n  hex: new Set([46, 88, 95, 120])\n};\nconst isAllowedNumericSeparatorSibling = {\n  bin: ch => ch === 48 || ch === 49,\n  oct: ch => ch >= 48 && ch <= 55,\n  dec: ch => ch >= 48 && ch <= 57,\n  hex: ch => ch >= 48 && ch <= 57 || ch >= 65 && ch <= 70 || ch >= 97 && ch <= 102\n};\nfunction readStringContents(type, input, pos, lineStart, curLine, errors) {\n  const initialPos = pos;\n  const initialLineStart = lineStart;\n  const initialCurLine = curLine;\n  let out = \"\";\n  let firstInvalidLoc = null;\n  let chunkStart = pos;\n  const {\n    length\n  } = input;\n  for (;;) {\n    if (pos >= length) {\n      errors.unterminated(initialPos, initialLineStart, initialCurLine);\n      out += input.slice(chunkStart, pos);\n      break;\n    }\n    const ch = input.charCodeAt(pos);\n    if (isStringEnd(type, ch, input, pos)) {\n      out += input.slice(chunkStart, pos);\n      break;\n    }\n    if (ch === 92) {\n      out += input.slice(chunkStart, pos);\n      const res = readEscapedChar(input, pos, lineStart, curLine, type === \"template\", errors);\n      if (res.ch === null && !firstInvalidLoc) {\n        firstInvalidLoc = {\n          pos,\n          lineStart,\n          curLine\n        };\n      } else {\n        out += res.ch;\n      }\n      ({\n        pos,\n        lineStart,\n        curLine\n      } = res);\n      chunkStart = pos;\n    } else if (ch === 8232 || ch === 8233) {\n      ++pos;\n      ++curLine;\n      lineStart = pos;\n    } else if (ch === 10 || ch === 13) {\n      if (type === \"template\") {\n        out += input.slice(chunkStart, pos) + \"\\n\";\n        ++pos;\n        if (ch === 13 && input.charCodeAt(pos) === 10) {\n          ++pos;\n        }\n        ++curLine;\n        chunkStart = lineStart = pos;\n      } else {\n        errors.unterminated(initialPos, initialLineStart, initialCurLine);\n      }\n    } else {\n      ++pos;\n    }\n  }\n  return {\n    pos,\n    str: out,\n    firstInvalidLoc,\n    lineStart,\n    curLine,\n    containsInvalid: !!firstInvalidLoc\n  };\n}\nfunction isStringEnd(type, ch, input, pos) {\n  if (type === \"template\") {\n    return ch === 96 || ch === 36 && input.charCodeAt(pos + 1) === 123;\n  }\n  return ch === (type === \"double\" ? 34 : 39);\n}\nfunction readEscapedChar(input, pos, lineStart, curLine, inTemplate, errors) {\n  const throwOnInvalid = !inTemplate;\n  pos++;\n  const res = ch => ({\n    pos,\n    ch,\n    lineStart,\n    curLine\n  });\n  const ch = input.charCodeAt(pos++);\n  switch (ch) {\n    case 110:\n      return res(\"\\n\");\n    case 114:\n      return res(\"\\r\");\n    case 120:\n      {\n        let code;\n        ({\n          code,\n          pos\n        } = readHexChar(input, pos, lineStart, curLine, 2, false, throwOnInvalid, errors));\n        return res(code === null ? null : String.fromCharCode(code));\n      }\n    case 117:\n      {\n        let code;\n        ({\n          code,\n          pos\n        } = readCodePoint(input, pos, lineStart, curLine, throwOnInvalid, errors));\n        return res(code === null ? null : String.fromCodePoint(code));\n      }\n    case 116:\n      return res(\"\\t\");\n    case 98:\n      return res(\"\\b\");\n    case 118:\n      return res(\"\\u000b\");\n    case 102:\n      return res(\"\\f\");\n    case 13:\n      if (input.charCodeAt(pos) === 10) {\n        ++pos;\n      }\n    case 10:\n      lineStart = pos;\n      ++curLine;\n    case 8232:\n    case 8233:\n      return res(\"\");\n    case 56:\n    case 57:\n      if (inTemplate) {\n        return res(null);\n      } else {\n        errors.strictNumericEscape(pos - 1, lineStart, curLine);\n      }\n    default:\n      if (ch >= 48 && ch <= 55) {\n        const startPos = pos - 1;\n        const match = /^[0-7]+/.exec(input.slice(startPos, pos + 2));\n        let octalStr = match[0];\n        let octal = parseInt(octalStr, 8);\n        if (octal > 255) {\n          octalStr = octalStr.slice(0, -1);\n          octal = parseInt(octalStr, 8);\n        }\n        pos += octalStr.length - 1;\n        const next = input.charCodeAt(pos);\n        if (octalStr !== \"0\" || next === 56 || next === 57) {\n          if (inTemplate) {\n            return res(null);\n          } else {\n            errors.strictNumericEscape(startPos, lineStart, curLine);\n          }\n        }\n        return res(String.fromCharCode(octal));\n      }\n      return res(String.fromCharCode(ch));\n  }\n}\nfunction readHexChar(input, pos, lineStart, curLine, len, forceLen, throwOnInvalid, errors) {\n  const initialPos = pos;\n  let n;\n  ({\n    n,\n    pos\n  } = readInt(input, pos, lineStart, curLine, 16, len, forceLen, false, errors, !throwOnInvalid));\n  if (n === null) {\n    if (throwOnInvalid) {\n      errors.invalidEscapeSequence(initialPos, lineStart, curLine);\n    } else {\n      pos = initialPos - 1;\n    }\n  }\n  return {\n    code: n,\n    pos\n  };\n}\nfunction readInt(input, pos, lineStart, curLine, radix, len, forceLen, allowNumSeparator, errors, bailOnError) {\n  const start = pos;\n  const forbiddenSiblings = radix === 16 ? forbiddenNumericSeparatorSiblings.hex : forbiddenNumericSeparatorSiblings.decBinOct;\n  const isAllowedSibling = radix === 16 ? isAllowedNumericSeparatorSibling.hex : radix === 10 ? isAllowedNumericSeparatorSibling.dec : radix === 8 ? isAllowedNumericSeparatorSibling.oct : isAllowedNumericSeparatorSibling.bin;\n  let invalid = false;\n  let total = 0;\n  for (let i = 0, e = len == null ? Infinity : len; i < e; ++i) {\n    const code = input.charCodeAt(pos);\n    let val;\n    if (code === 95 && allowNumSeparator !== \"bail\") {\n      const prev = input.charCodeAt(pos - 1);\n      const next = input.charCodeAt(pos + 1);\n      if (!allowNumSeparator) {\n        if (bailOnError) return {\n          n: null,\n          pos\n        };\n        errors.numericSeparatorInEscapeSequence(pos, lineStart, curLine);\n      } else if (Number.isNaN(next) || !isAllowedSibling(next) || forbiddenSiblings.has(prev) || forbiddenSiblings.has(next)) {\n        if (bailOnError) return {\n          n: null,\n          pos\n        };\n        errors.unexpectedNumericSeparator(pos, lineStart, curLine);\n      }\n      ++pos;\n      continue;\n    }\n    if (code >= 97) {\n      val = code - 97 + 10;\n    } else if (code >= 65) {\n      val = code - 65 + 10;\n    } else if (_isDigit(code)) {\n      val = code - 48;\n    } else {\n      val = Infinity;\n    }\n    if (val >= radix) {\n      if (val <= 9 && bailOnError) {\n        return {\n          n: null,\n          pos\n        };\n      } else if (val <= 9 && errors.invalidDigit(pos, lineStart, curLine, radix)) {\n        val = 0;\n      } else if (forceLen) {\n        val = 0;\n        invalid = true;\n      } else {\n        break;\n      }\n    }\n    ++pos;\n    total = total * radix + val;\n  }\n  if (pos === start || len != null && pos - start !== len || invalid) {\n    return {\n      n: null,\n      pos\n    };\n  }\n  return {\n    n: total,\n    pos\n  };\n}\nfunction readCodePoint(input, pos, lineStart, curLine, throwOnInvalid, errors) {\n  const ch = input.charCodeAt(pos);\n  let code;\n  if (ch === 123) {\n    ++pos;\n    ({\n      code,\n      pos\n    } = readHexChar(input, pos, lineStart, curLine, input.indexOf(\"}\", pos) - pos, true, throwOnInvalid, errors));\n    ++pos;\n    if (code !== null && code > 0x10ffff) {\n      if (throwOnInvalid) {\n        errors.invalidCodePoint(pos, lineStart, curLine);\n      } else {\n        return {\n          code: null,\n          pos\n        };\n      }\n    }\n  } else {\n    ({\n      code,\n      pos\n    } = readHexChar(input, pos, lineStart, curLine, 4, false, throwOnInvalid, errors));\n  }\n  return {\n    code,\n    pos\n  };\n}\nfunction buildPosition(pos, lineStart, curLine) {\n  return new Position(curLine, pos - lineStart, pos);\n}\nconst VALID_REGEX_FLAGS = new Set([103, 109, 115, 105, 121, 117, 100, 118]);\nclass Token {\n  constructor(state) {\n    const startIndex = state.startIndex || 0;\n    this.type = state.type;\n    this.value = state.value;\n    this.start = startIndex + state.start;\n    this.end = startIndex + state.end;\n    this.loc = new SourceLocation(state.startLoc, state.endLoc);\n  }\n}\nclass Tokenizer extends CommentsParser {\n  constructor(options, input) {\n    super();\n    this.isLookahead = void 0;\n    this.tokens = [];\n    this.errorHandlers_readInt = {\n      invalidDigit: (pos, lineStart, curLine, radix) => {\n        if (!(this.optionFlags & 2048)) return false;\n        this.raise(Errors.InvalidDigit, buildPosition(pos, lineStart, curLine), {\n          radix\n        });\n        return true;\n      },\n      numericSeparatorInEscapeSequence: this.errorBuilder(Errors.NumericSeparatorInEscapeSequence),\n      unexpectedNumericSeparator: this.errorBuilder(Errors.UnexpectedNumericSeparator)\n    };\n    this.errorHandlers_readCodePoint = Object.assign({}, this.errorHandlers_readInt, {\n      invalidEscapeSequence: this.errorBuilder(Errors.InvalidEscapeSequence),\n      invalidCodePoint: this.errorBuilder(Errors.InvalidCodePoint)\n    });\n    this.errorHandlers_readStringContents_string = Object.assign({}, this.errorHandlers_readCodePoint, {\n      strictNumericEscape: (pos, lineStart, curLine) => {\n        this.recordStrictModeErrors(Errors.StrictNumericEscape, buildPosition(pos, lineStart, curLine));\n      },\n      unterminated: (pos, lineStart, curLine) => {\n        throw this.raise(Errors.UnterminatedString, buildPosition(pos - 1, lineStart, curLine));\n      }\n    });\n    this.errorHandlers_readStringContents_template = Object.assign({}, this.errorHandlers_readCodePoint, {\n      strictNumericEscape: this.errorBuilder(Errors.StrictNumericEscape),\n      unterminated: (pos, lineStart, curLine) => {\n        throw this.raise(Errors.UnterminatedTemplate, buildPosition(pos, lineStart, curLine));\n      }\n    });\n    this.state = new State();\n    this.state.init(options);\n    this.input = input;\n    this.length = input.length;\n    this.comments = [];\n    this.isLookahead = false;\n  }\n  pushToken(token) {\n    this.tokens.length = this.state.tokensLength;\n    this.tokens.push(token);\n    ++this.state.tokensLength;\n  }\n  next() {\n    this.checkKeywordEscapes();\n    if (this.optionFlags & 256) {\n      this.pushToken(new Token(this.state));\n    }\n    this.state.lastTokEndLoc = this.state.endLoc;\n    this.state.lastTokStartLoc = this.state.startLoc;\n    this.nextToken();\n  }\n  eat(type) {\n    if (this.match(type)) {\n      this.next();\n      return true;\n    } else {\n      return false;\n    }\n  }\n  match(type) {\n    return this.state.type === type;\n  }\n  createLookaheadState(state) {\n    return {\n      pos: state.pos,\n      value: null,\n      type: state.type,\n      start: state.start,\n      end: state.end,\n      context: [this.curContext()],\n      inType: state.inType,\n      startLoc: state.startLoc,\n      lastTokEndLoc: state.lastTokEndLoc,\n      curLine: state.curLine,\n      lineStart: state.lineStart,\n      curPosition: state.curPosition\n    };\n  }\n  lookahead() {\n    const old = this.state;\n    this.state = this.createLookaheadState(old);\n    this.isLookahead = true;\n    this.nextToken();\n    this.isLookahead = false;\n    const curr = this.state;\n    this.state = old;\n    return curr;\n  }\n  nextTokenStart() {\n    return this.nextTokenStartSince(this.state.pos);\n  }\n  nextTokenStartSince(pos) {\n    skipWhiteSpace.lastIndex = pos;\n    return skipWhiteSpace.test(this.input) ? skipWhiteSpace.lastIndex : pos;\n  }\n  lookaheadCharCode() {\n    return this.lookaheadCharCodeSince(this.state.pos);\n  }\n  lookaheadCharCodeSince(pos) {\n    return this.input.charCodeAt(this.nextTokenStartSince(pos));\n  }\n  nextTokenInLineStart() {\n    return this.nextTokenInLineStartSince(this.state.pos);\n  }\n  nextTokenInLineStartSince(pos) {\n    skipWhiteSpaceInLine.lastIndex = pos;\n    return skipWhiteSpaceInLine.test(this.input) ? skipWhiteSpaceInLine.lastIndex : pos;\n  }\n  lookaheadInLineCharCode() {\n    return this.input.charCodeAt(this.nextTokenInLineStart());\n  }\n  codePointAtPos(pos) {\n    let cp = this.input.charCodeAt(pos);\n    if ((cp & 0xfc00) === 0xd800 && ++pos < this.input.length) {\n      const trail = this.input.charCodeAt(pos);\n      if ((trail & 0xfc00) === 0xdc00) {\n        cp = 0x10000 + ((cp & 0x3ff) << 10) + (trail & 0x3ff);\n      }\n    }\n    return cp;\n  }\n  setStrict(strict) {\n    this.state.strict = strict;\n    if (strict) {\n      this.state.strictErrors.forEach(([toParseError, at]) => this.raise(toParseError, at));\n      this.state.strictErrors.clear();\n    }\n  }\n  curContext() {\n    return this.state.context[this.state.context.length - 1];\n  }\n  nextToken() {\n    this.skipSpace();\n    this.state.start = this.state.pos;\n    if (!this.isLookahead) this.state.startLoc = this.state.curPosition();\n    if (this.state.pos >= this.length) {\n      this.finishToken(140);\n      return;\n    }\n    this.getTokenFromCode(this.codePointAtPos(this.state.pos));\n  }\n  skipBlockComment(commentEnd) {\n    let startLoc;\n    if (!this.isLookahead) startLoc = this.state.curPosition();\n    const start = this.state.pos;\n    const end = this.input.indexOf(commentEnd, start + 2);\n    if (end === -1) {\n      throw this.raise(Errors.UnterminatedComment, this.state.curPosition());\n    }\n    this.state.pos = end + commentEnd.length;\n    lineBreakG.lastIndex = start + 2;\n    while (lineBreakG.test(this.input) && lineBreakG.lastIndex <= end) {\n      ++this.state.curLine;\n      this.state.lineStart = lineBreakG.lastIndex;\n    }\n    if (this.isLookahead) return;\n    const comment = {\n      type: \"CommentBlock\",\n      value: this.input.slice(start + 2, end),\n      start: this.sourceToOffsetPos(start),\n      end: this.sourceToOffsetPos(end + commentEnd.length),\n      loc: new SourceLocation(startLoc, this.state.curPosition())\n    };\n    if (this.optionFlags & 256) this.pushToken(comment);\n    return comment;\n  }\n  skipLineComment(startSkip) {\n    const start = this.state.pos;\n    let startLoc;\n    if (!this.isLookahead) startLoc = this.state.curPosition();\n    let ch = this.input.charCodeAt(this.state.pos += startSkip);\n    if (this.state.pos < this.length) {\n      while (!isNewLine(ch) && ++this.state.pos < this.length) {\n        ch = this.input.charCodeAt(this.state.pos);\n      }\n    }\n    if (this.isLookahead) return;\n    const end = this.state.pos;\n    const value = this.input.slice(start + startSkip, end);\n    const comment = {\n      type: \"CommentLine\",\n      value,\n      start: this.sourceToOffsetPos(start),\n      end: this.sourceToOffsetPos(end),\n      loc: new SourceLocation(startLoc, this.state.curPosition())\n    };\n    if (this.optionFlags & 256) this.pushToken(comment);\n    return comment;\n  }\n  skipSpace() {\n    const spaceStart = this.state.pos;\n    const comments = this.optionFlags & 4096 ? [] : null;\n    loop: while (this.state.pos < this.length) {\n      const ch = this.input.charCodeAt(this.state.pos);\n      switch (ch) {\n        case 32:\n        case 160:\n        case 9:\n          ++this.state.pos;\n          break;\n        case 13:\n          if (this.input.charCodeAt(this.state.pos + 1) === 10) {\n            ++this.state.pos;\n          }\n        case 10:\n        case 8232:\n        case 8233:\n          ++this.state.pos;\n          ++this.state.curLine;\n          this.state.lineStart = this.state.pos;\n          break;\n        case 47:\n          switch (this.input.charCodeAt(this.state.pos + 1)) {\n            case 42:\n              {\n                const comment = this.skipBlockComment(\"*/\");\n                if (comment !== undefined) {\n                  this.addComment(comment);\n                  comments == null || comments.push(comment);\n                }\n                break;\n              }\n            case 47:\n              {\n                const comment = this.skipLineComment(2);\n                if (comment !== undefined) {\n                  this.addComment(comment);\n                  comments == null || comments.push(comment);\n                }\n                break;\n              }\n            default:\n              break loop;\n          }\n          break;\n        default:\n          if (isWhitespace(ch)) {\n            ++this.state.pos;\n          } else if (ch === 45 && !this.inModule && this.optionFlags & 8192) {\n            const pos = this.state.pos;\n            if (this.input.charCodeAt(pos + 1) === 45 && this.input.charCodeAt(pos + 2) === 62 && (spaceStart === 0 || this.state.lineStart > spaceStart)) {\n              const comment = this.skipLineComment(3);\n              if (comment !== undefined) {\n                this.addComment(comment);\n                comments == null || comments.push(comment);\n              }\n            } else {\n              break loop;\n            }\n          } else if (ch === 60 && !this.inModule && this.optionFlags & 8192) {\n            const pos = this.state.pos;\n            if (this.input.charCodeAt(pos + 1) === 33 && this.input.charCodeAt(pos + 2) === 45 && this.input.charCodeAt(pos + 3) === 45) {\n              const comment = this.skipLineComment(4);\n              if (comment !== undefined) {\n                this.addComment(comment);\n                comments == null || comments.push(comment);\n              }\n            } else {\n              break loop;\n            }\n          } else {\n            break loop;\n          }\n      }\n    }\n    if ((comments == null ? void 0 : comments.length) > 0) {\n      const end = this.state.pos;\n      const commentWhitespace = {\n        start: this.sourceToOffsetPos(spaceStart),\n        end: this.sourceToOffsetPos(end),\n        comments: comments,\n        leadingNode: null,\n        trailingNode: null,\n        containingNode: null\n      };\n      this.state.commentStack.push(commentWhitespace);\n    }\n  }\n  finishToken(type, val) {\n    this.state.end = this.state.pos;\n    this.state.endLoc = this.state.curPosition();\n    const prevType = this.state.type;\n    this.state.type = type;\n    this.state.value = val;\n    if (!this.isLookahead) {\n      this.updateContext(prevType);\n    }\n  }\n  replaceToken(type) {\n    this.state.type = type;\n    this.updateContext();\n  }\n  readToken_numberSign() {\n    if (this.state.pos === 0 && this.readToken_interpreter()) {\n      return;\n    }\n    const nextPos = this.state.pos + 1;\n    const next = this.codePointAtPos(nextPos);\n    if (next >= 48 && next <= 57) {\n      throw this.raise(Errors.UnexpectedDigitAfterHash, this.state.curPosition());\n    }\n    if (next === 123 || next === 91 && this.hasPlugin(\"recordAndTuple\")) {\n      this.expectPlugin(\"recordAndTuple\");\n      if (this.getPluginOption(\"recordAndTuple\", \"syntaxType\") === \"bar\") {\n        throw this.raise(next === 123 ? Errors.RecordExpressionHashIncorrectStartSyntaxType : Errors.TupleExpressionHashIncorrectStartSyntaxType, this.state.curPosition());\n      }\n      this.state.pos += 2;\n      if (next === 123) {\n        this.finishToken(7);\n      } else {\n        this.finishToken(1);\n      }\n    } else if (isIdentifierStart(next)) {\n      ++this.state.pos;\n      this.finishToken(139, this.readWord1(next));\n    } else if (next === 92) {\n      ++this.state.pos;\n      this.finishToken(139, this.readWord1());\n    } else {\n      this.finishOp(27, 1);\n    }\n  }\n  readToken_dot() {\n    const next = this.input.charCodeAt(this.state.pos + 1);\n    if (next >= 48 && next <= 57) {\n      this.readNumber(true);\n      return;\n    }\n    if (next === 46 && this.input.charCodeAt(this.state.pos + 2) === 46) {\n      this.state.pos += 3;\n      this.finishToken(21);\n    } else {\n      ++this.state.pos;\n      this.finishToken(16);\n    }\n  }\n  readToken_slash() {\n    const next = this.input.charCodeAt(this.state.pos + 1);\n    if (next === 61) {\n      this.finishOp(31, 2);\n    } else {\n      this.finishOp(56, 1);\n    }\n  }\n  readToken_interpreter() {\n    if (this.state.pos !== 0 || this.length < 2) return false;\n    let ch = this.input.charCodeAt(this.state.pos + 1);\n    if (ch !== 33) return false;\n    const start = this.state.pos;\n    this.state.pos += 1;\n    while (!isNewLine(ch) && ++this.state.pos < this.length) {\n      ch = this.input.charCodeAt(this.state.pos);\n    }\n    const value = this.input.slice(start + 2, this.state.pos);\n    this.finishToken(28, value);\n    return true;\n  }\n  readToken_mult_modulo(code) {\n    let type = code === 42 ? 55 : 54;\n    let width = 1;\n    let next = this.input.charCodeAt(this.state.pos + 1);\n    if (code === 42 && next === 42) {\n      width++;\n      next = this.input.charCodeAt(this.state.pos + 2);\n      type = 57;\n    }\n    if (next === 61 && !this.state.inType) {\n      width++;\n      type = code === 37 ? 33 : 30;\n    }\n    this.finishOp(type, width);\n  }\n  readToken_pipe_amp(code) {\n    const next = this.input.charCodeAt(this.state.pos + 1);\n    if (next === code) {\n      if (this.input.charCodeAt(this.state.pos + 2) === 61) {\n        this.finishOp(30, 3);\n      } else {\n        this.finishOp(code === 124 ? 41 : 42, 2);\n      }\n      return;\n    }\n    if (code === 124) {\n      if (next === 62) {\n        this.finishOp(39, 2);\n        return;\n      }\n      if (this.hasPlugin(\"recordAndTuple\") && next === 125) {\n        if (this.getPluginOption(\"recordAndTuple\", \"syntaxType\") !== \"bar\") {\n          throw this.raise(Errors.RecordExpressionBarIncorrectEndSyntaxType, this.state.curPosition());\n        }\n        this.state.pos += 2;\n        this.finishToken(9);\n        return;\n      }\n      if (this.hasPlugin(\"recordAndTuple\") && next === 93) {\n        if (this.getPluginOption(\"recordAndTuple\", \"syntaxType\") !== \"bar\") {\n          throw this.raise(Errors.TupleExpressionBarIncorrectEndSyntaxType, this.state.curPosition());\n        }\n        this.state.pos += 2;\n        this.finishToken(4);\n        return;\n      }\n    }\n    if (next === 61) {\n      this.finishOp(30, 2);\n      return;\n    }\n    this.finishOp(code === 124 ? 43 : 45, 1);\n  }\n  readToken_caret() {\n    const next = this.input.charCodeAt(this.state.pos + 1);\n    if (next === 61 && !this.state.inType) {\n      this.finishOp(32, 2);\n    } else if (next === 94 && this.hasPlugin([\"pipelineOperator\", {\n      proposal: \"hack\",\n      topicToken: \"^^\"\n    }])) {\n      this.finishOp(37, 2);\n      const lookaheadCh = this.input.codePointAt(this.state.pos);\n      if (lookaheadCh === 94) {\n        this.unexpected();\n      }\n    } else {\n      this.finishOp(44, 1);\n    }\n  }\n  readToken_atSign() {\n    const next = this.input.charCodeAt(this.state.pos + 1);\n    if (next === 64 && this.hasPlugin([\"pipelineOperator\", {\n      proposal: \"hack\",\n      topicToken: \"@@\"\n    }])) {\n      this.finishOp(38, 2);\n    } else {\n      this.finishOp(26, 1);\n    }\n  }\n  readToken_plus_min(code) {\n    const next = this.input.charCodeAt(this.state.pos + 1);\n    if (next === code) {\n      this.finishOp(34, 2);\n      return;\n    }\n    if (next === 61) {\n      this.finishOp(30, 2);\n    } else {\n      this.finishOp(53, 1);\n    }\n  }\n  readToken_lt() {\n    const {\n      pos\n    } = this.state;\n    const next = this.input.charCodeAt(pos + 1);\n    if (next === 60) {\n      if (this.input.charCodeAt(pos + 2) === 61) {\n        this.finishOp(30, 3);\n        return;\n      }\n      this.finishOp(51, 2);\n      return;\n    }\n    if (next === 61) {\n      this.finishOp(49, 2);\n      return;\n    }\n    this.finishOp(47, 1);\n  }\n  readToken_gt() {\n    const {\n      pos\n    } = this.state;\n    const next = this.input.charCodeAt(pos + 1);\n    if (next === 62) {\n      const size = this.input.charCodeAt(pos + 2) === 62 ? 3 : 2;\n      if (this.input.charCodeAt(pos + size) === 61) {\n        this.finishOp(30, size + 1);\n        return;\n      }\n      this.finishOp(52, size);\n      return;\n    }\n    if (next === 61) {\n      this.finishOp(49, 2);\n      return;\n    }\n    this.finishOp(48, 1);\n  }\n  readToken_eq_excl(code) {\n    const next = this.input.charCodeAt(this.state.pos + 1);\n    if (next === 61) {\n      this.finishOp(46, this.input.charCodeAt(this.state.pos + 2) === 61 ? 3 : 2);\n      return;\n    }\n    if (code === 61 && next === 62) {\n      this.state.pos += 2;\n      this.finishToken(19);\n      return;\n    }\n    this.finishOp(code === 61 ? 29 : 35, 1);\n  }\n  readToken_question() {\n    const next = this.input.charCodeAt(this.state.pos + 1);\n    const next2 = this.input.charCodeAt(this.state.pos + 2);\n    if (next === 63) {\n      if (next2 === 61) {\n        this.finishOp(30, 3);\n      } else {\n        this.finishOp(40, 2);\n      }\n    } else if (next === 46 && !(next2 >= 48 && next2 <= 57)) {\n      this.state.pos += 2;\n      this.finishToken(18);\n    } else {\n      ++this.state.pos;\n      this.finishToken(17);\n    }\n  }\n  getTokenFromCode(code) {\n    switch (code) {\n      case 46:\n        this.readToken_dot();\n        return;\n      case 40:\n        ++this.state.pos;\n        this.finishToken(10);\n        return;\n      case 41:\n        ++this.state.pos;\n        this.finishToken(11);\n        return;\n      case 59:\n        ++this.state.pos;\n        this.finishToken(13);\n        return;\n      case 44:\n        ++this.state.pos;\n        this.finishToken(12);\n        return;\n      case 91:\n        if (this.hasPlugin(\"recordAndTuple\") && this.input.charCodeAt(this.state.pos + 1) === 124) {\n          if (this.getPluginOption(\"recordAndTuple\", \"syntaxType\") !== \"bar\") {\n            throw this.raise(Errors.TupleExpressionBarIncorrectStartSyntaxType, this.state.curPosition());\n          }\n          this.state.pos += 2;\n          this.finishToken(2);\n        } else {\n          ++this.state.pos;\n          this.finishToken(0);\n        }\n        return;\n      case 93:\n        ++this.state.pos;\n        this.finishToken(3);\n        return;\n      case 123:\n        if (this.hasPlugin(\"recordAndTuple\") && this.input.charCodeAt(this.state.pos + 1) === 124) {\n          if (this.getPluginOption(\"recordAndTuple\", \"syntaxType\") !== \"bar\") {\n            throw this.raise(Errors.RecordExpressionBarIncorrectStartSyntaxType, this.state.curPosition());\n          }\n          this.state.pos += 2;\n          this.finishToken(6);\n        } else {\n          ++this.state.pos;\n          this.finishToken(5);\n        }\n        return;\n      case 125:\n        ++this.state.pos;\n        this.finishToken(8);\n        return;\n      case 58:\n        if (this.hasPlugin(\"functionBind\") && this.input.charCodeAt(this.state.pos + 1) === 58) {\n          this.finishOp(15, 2);\n        } else {\n          ++this.state.pos;\n          this.finishToken(14);\n        }\n        return;\n      case 63:\n        this.readToken_question();\n        return;\n      case 96:\n        this.readTemplateToken();\n        return;\n      case 48:\n        {\n          const next = this.input.charCodeAt(this.state.pos + 1);\n          if (next === 120 || next === 88) {\n            this.readRadixNumber(16);\n            return;\n          }\n          if (next === 111 || next === 79) {\n            this.readRadixNumber(8);\n            return;\n          }\n          if (next === 98 || next === 66) {\n            this.readRadixNumber(2);\n            return;\n          }\n        }\n      case 49:\n      case 50:\n      case 51:\n      case 52:\n      case 53:\n      case 54:\n      case 55:\n      case 56:\n      case 57:\n        this.readNumber(false);\n        return;\n      case 34:\n      case 39:\n        this.readString(code);\n        return;\n      case 47:\n        this.readToken_slash();\n        return;\n      case 37:\n      case 42:\n        this.readToken_mult_modulo(code);\n        return;\n      case 124:\n      case 38:\n        this.readToken_pipe_amp(code);\n        return;\n      case 94:\n        this.readToken_caret();\n        return;\n      case 43:\n      case 45:\n        this.readToken_plus_min(code);\n        return;\n      case 60:\n        this.readToken_lt();\n        return;\n      case 62:\n        this.readToken_gt();\n        return;\n      case 61:\n      case 33:\n        this.readToken_eq_excl(code);\n        return;\n      case 126:\n        this.finishOp(36, 1);\n        return;\n      case 64:\n        this.readToken_atSign();\n        return;\n      case 35:\n        this.readToken_numberSign();\n        return;\n      case 92:\n        this.readWord();\n        return;\n      default:\n        if (isIdentifierStart(code)) {\n          this.readWord(code);\n          return;\n        }\n    }\n    throw this.raise(Errors.InvalidOrUnexpectedToken, this.state.curPosition(), {\n      unexpected: String.fromCodePoint(code)\n    });\n  }\n  finishOp(type, size) {\n    const str = this.input.slice(this.state.pos, this.state.pos + size);\n    this.state.pos += size;\n    this.finishToken(type, str);\n  }\n  readRegexp() {\n    const startLoc = this.state.startLoc;\n    const start = this.state.start + 1;\n    let escaped, inClass;\n    let {\n      pos\n    } = this.state;\n    for (;; ++pos) {\n      if (pos >= this.length) {\n        throw this.raise(Errors.UnterminatedRegExp, createPositionWithColumnOffset(startLoc, 1));\n      }\n      const ch = this.input.charCodeAt(pos);\n      if (isNewLine(ch)) {\n        throw this.raise(Errors.UnterminatedRegExp, createPositionWithColumnOffset(startLoc, 1));\n      }\n      if (escaped) {\n        escaped = false;\n      } else {\n        if (ch === 91) {\n          inClass = true;\n        } else if (ch === 93 && inClass) {\n          inClass = false;\n        } else if (ch === 47 && !inClass) {\n          break;\n        }\n        escaped = ch === 92;\n      }\n    }\n    const content = this.input.slice(start, pos);\n    ++pos;\n    let mods = \"\";\n    const nextPos = () => createPositionWithColumnOffset(startLoc, pos + 2 - start);\n    while (pos < this.length) {\n      const cp = this.codePointAtPos(pos);\n      const char = String.fromCharCode(cp);\n      if (VALID_REGEX_FLAGS.has(cp)) {\n        if (cp === 118) {\n          if (mods.includes(\"u\")) {\n            this.raise(Errors.IncompatibleRegExpUVFlags, nextPos());\n          }\n        } else if (cp === 117) {\n          if (mods.includes(\"v\")) {\n            this.raise(Errors.IncompatibleRegExpUVFlags, nextPos());\n          }\n        }\n        if (mods.includes(char)) {\n          this.raise(Errors.DuplicateRegExpFlags, nextPos());\n        }\n      } else if (isIdentifierChar(cp) || cp === 92) {\n        this.raise(Errors.MalformedRegExpFlags, nextPos());\n      } else {\n        break;\n      }\n      ++pos;\n      mods += char;\n    }\n    this.state.pos = pos;\n    this.finishToken(138, {\n      pattern: content,\n      flags: mods\n    });\n  }\n  readInt(radix, len, forceLen = false, allowNumSeparator = true) {\n    const {\n      n,\n      pos\n    } = readInt(this.input, this.state.pos, this.state.lineStart, this.state.curLine, radix, len, forceLen, allowNumSeparator, this.errorHandlers_readInt, false);\n    this.state.pos = pos;\n    return n;\n  }\n  readRadixNumber(radix) {\n    const start = this.state.pos;\n    const startLoc = this.state.curPosition();\n    let isBigInt = false;\n    this.state.pos += 2;\n    const val = this.readInt(radix);\n    if (val == null) {\n      this.raise(Errors.InvalidDigit, createPositionWithColumnOffset(startLoc, 2), {\n        radix\n      });\n    }\n    const next = this.input.charCodeAt(this.state.pos);\n    if (next === 110) {\n      ++this.state.pos;\n      isBigInt = true;\n    } else if (next === 109) {\n      throw this.raise(Errors.InvalidDecimal, startLoc);\n    }\n    if (isIdentifierStart(this.codePointAtPos(this.state.pos))) {\n      throw this.raise(Errors.NumberIdentifier, this.state.curPosition());\n    }\n    if (isBigInt) {\n      const str = this.input.slice(start, this.state.pos).replace(/[_n]/g, \"\");\n      this.finishToken(136, str);\n      return;\n    }\n    this.finishToken(135, val);\n  }\n  readNumber(startsWithDot) {\n    const start = this.state.pos;\n    const startLoc = this.state.curPosition();\n    let isFloat = false;\n    let isBigInt = false;\n    let hasExponent = false;\n    let isOctal = false;\n    if (!startsWithDot && this.readInt(10) === null) {\n      this.raise(Errors.InvalidNumber, this.state.curPosition());\n    }\n    const hasLeadingZero = this.state.pos - start >= 2 && this.input.charCodeAt(start) === 48;\n    if (hasLeadingZero) {\n      const integer = this.input.slice(start, this.state.pos);\n      this.recordStrictModeErrors(Errors.StrictOctalLiteral, startLoc);\n      if (!this.state.strict) {\n        const underscorePos = integer.indexOf(\"_\");\n        if (underscorePos > 0) {\n          this.raise(Errors.ZeroDigitNumericSeparator, createPositionWithColumnOffset(startLoc, underscorePos));\n        }\n      }\n      isOctal = hasLeadingZero && !/[89]/.test(integer);\n    }\n    let next = this.input.charCodeAt(this.state.pos);\n    if (next === 46 && !isOctal) {\n      ++this.state.pos;\n      this.readInt(10);\n      isFloat = true;\n      next = this.input.charCodeAt(this.state.pos);\n    }\n    if ((next === 69 || next === 101) && !isOctal) {\n      next = this.input.charCodeAt(++this.state.pos);\n      if (next === 43 || next === 45) {\n        ++this.state.pos;\n      }\n      if (this.readInt(10) === null) {\n        this.raise(Errors.InvalidOrMissingExponent, startLoc);\n      }\n      isFloat = true;\n      hasExponent = true;\n      next = this.input.charCodeAt(this.state.pos);\n    }\n    if (next === 110) {\n      if (isFloat || hasLeadingZero) {\n        this.raise(Errors.InvalidBigIntLiteral, startLoc);\n      }\n      ++this.state.pos;\n      isBigInt = true;\n    }\n    if (next === 109) {\n      this.expectPlugin(\"decimal\", this.state.curPosition());\n      if (hasExponent || hasLeadingZero) {\n        this.raise(Errors.InvalidDecimal, startLoc);\n      }\n      ++this.state.pos;\n      var isDecimal = true;\n    }\n    if (isIdentifierStart(this.codePointAtPos(this.state.pos))) {\n      throw this.raise(Errors.NumberIdentifier, this.state.curPosition());\n    }\n    const str = this.input.slice(start, this.state.pos).replace(/[_mn]/g, \"\");\n    if (isBigInt) {\n      this.finishToken(136, str);\n      return;\n    }\n    if (isDecimal) {\n      this.finishToken(137, str);\n      return;\n    }\n    const val = isOctal ? parseInt(str, 8) : parseFloat(str);\n    this.finishToken(135, val);\n  }\n  readCodePoint(throwOnInvalid) {\n    const {\n      code,\n      pos\n    } = readCodePoint(this.input, this.state.pos, this.state.lineStart, this.state.curLine, throwOnInvalid, this.errorHandlers_readCodePoint);\n    this.state.pos = pos;\n    return code;\n  }\n  readString(quote) {\n    const {\n      str,\n      pos,\n      curLine,\n      lineStart\n    } = readStringContents(quote === 34 ? \"double\" : \"single\", this.input, this.state.pos + 1, this.state.lineStart, this.state.curLine, this.errorHandlers_readStringContents_string);\n    this.state.pos = pos + 1;\n    this.state.lineStart = lineStart;\n    this.state.curLine = curLine;\n    this.finishToken(134, str);\n  }\n  readTemplateContinuation() {\n    if (!this.match(8)) {\n      this.unexpected(null, 8);\n    }\n    this.state.pos--;\n    this.readTemplateToken();\n  }\n  readTemplateToken() {\n    const opening = this.input[this.state.pos];\n    const {\n      str,\n      firstInvalidLoc,\n      pos,\n      curLine,\n      lineStart\n    } = readStringContents(\"template\", this.input, this.state.pos + 1, this.state.lineStart, this.state.curLine, this.errorHandlers_readStringContents_template);\n    this.state.pos = pos + 1;\n    this.state.lineStart = lineStart;\n    this.state.curLine = curLine;\n    if (firstInvalidLoc) {\n      this.state.firstInvalidTemplateEscapePos = new Position(firstInvalidLoc.curLine, firstInvalidLoc.pos - firstInvalidLoc.lineStart, this.sourceToOffsetPos(firstInvalidLoc.pos));\n    }\n    if (this.input.codePointAt(pos) === 96) {\n      this.finishToken(24, firstInvalidLoc ? null : opening + str + \"`\");\n    } else {\n      this.state.pos++;\n      this.finishToken(25, firstInvalidLoc ? null : opening + str + \"${\");\n    }\n  }\n  recordStrictModeErrors(toParseError, at) {\n    const index = at.index;\n    if (this.state.strict && !this.state.strictErrors.has(index)) {\n      this.raise(toParseError, at);\n    } else {\n      this.state.strictErrors.set(index, [toParseError, at]);\n    }\n  }\n  readWord1(firstCode) {\n    this.state.containsEsc = false;\n    let word = \"\";\n    const start = this.state.pos;\n    let chunkStart = this.state.pos;\n    if (firstCode !== undefined) {\n      this.state.pos += firstCode <= 0xffff ? 1 : 2;\n    }\n    while (this.state.pos < this.length) {\n      const ch = this.codePointAtPos(this.state.pos);\n      if (isIdentifierChar(ch)) {\n        this.state.pos += ch <= 0xffff ? 1 : 2;\n      } else if (ch === 92) {\n        this.state.containsEsc = true;\n        word += this.input.slice(chunkStart, this.state.pos);\n        const escStart = this.state.curPosition();\n        const identifierCheck = this.state.pos === start ? isIdentifierStart : isIdentifierChar;\n        if (this.input.charCodeAt(++this.state.pos) !== 117) {\n          this.raise(Errors.MissingUnicodeEscape, this.state.curPosition());\n          chunkStart = this.state.pos - 1;\n          continue;\n        }\n        ++this.state.pos;\n        const esc = this.readCodePoint(true);\n        if (esc !== null) {\n          if (!identifierCheck(esc)) {\n            this.raise(Errors.EscapedCharNotAnIdentifier, escStart);\n          }\n          word += String.fromCodePoint(esc);\n        }\n        chunkStart = this.state.pos;\n      } else {\n        break;\n      }\n    }\n    return word + this.input.slice(chunkStart, this.state.pos);\n  }\n  readWord(firstCode) {\n    const word = this.readWord1(firstCode);\n    const type = keywords$1.get(word);\n    if (type !== undefined) {\n      this.finishToken(type, tokenLabelName(type));\n    } else {\n      this.finishToken(132, word);\n    }\n  }\n  checkKeywordEscapes() {\n    const {\n      type\n    } = this.state;\n    if (tokenIsKeyword(type) && this.state.containsEsc) {\n      this.raise(Errors.InvalidEscapedReservedWord, this.state.startLoc, {\n        reservedWord: tokenLabelName(type)\n      });\n    }\n  }\n  raise(toParseError, at, details = {}) {\n    const loc = at instanceof Position ? at : at.loc.start;\n    const error = toParseError(loc, details);\n    if (!(this.optionFlags & 2048)) throw error;\n    if (!this.isLookahead) this.state.errors.push(error);\n    return error;\n  }\n  raiseOverwrite(toParseError, at, details = {}) {\n    const loc = at instanceof Position ? at : at.loc.start;\n    const pos = loc.index;\n    const errors = this.state.errors;\n    for (let i = errors.length - 1; i >= 0; i--) {\n      const error = errors[i];\n      if (error.loc.index === pos) {\n        return errors[i] = toParseError(loc, details);\n      }\n      if (error.loc.index < pos) break;\n    }\n    return this.raise(toParseError, at, details);\n  }\n  updateContext(prevType) {}\n  unexpected(loc, type) {\n    throw this.raise(Errors.UnexpectedToken, loc != null ? loc : this.state.startLoc, {\n      expected: type ? tokenLabelName(type) : null\n    });\n  }\n  expectPlugin(pluginName, loc) {\n    if (this.hasPlugin(pluginName)) {\n      return true;\n    }\n    throw this.raise(Errors.MissingPlugin, loc != null ? loc : this.state.startLoc, {\n      missingPlugin: [pluginName]\n    });\n  }\n  expectOnePlugin(pluginNames) {\n    if (!pluginNames.some(name => this.hasPlugin(name))) {\n      throw this.raise(Errors.MissingOneOfPlugins, this.state.startLoc, {\n        missingPlugin: pluginNames\n      });\n    }\n  }\n  errorBuilder(error) {\n    return (pos, lineStart, curLine) => {\n      this.raise(error, buildPosition(pos, lineStart, curLine));\n    };\n  }\n}\nclass ClassScope {\n  constructor() {\n    this.privateNames = new Set();\n    this.loneAccessors = new Map();\n    this.undefinedPrivateNames = new Map();\n  }\n}\nclass ClassScopeHandler {\n  constructor(parser) {\n    this.parser = void 0;\n    this.stack = [];\n    this.undefinedPrivateNames = new Map();\n    this.parser = parser;\n  }\n  current() {\n    return this.stack[this.stack.length - 1];\n  }\n  enter() {\n    this.stack.push(new ClassScope());\n  }\n  exit() {\n    const oldClassScope = this.stack.pop();\n    const current = this.current();\n    for (const [name, loc] of Array.from(oldClassScope.undefinedPrivateNames)) {\n      if (current) {\n        if (!current.undefinedPrivateNames.has(name)) {\n          current.undefinedPrivateNames.set(name, loc);\n        }\n      } else {\n        this.parser.raise(Errors.InvalidPrivateFieldResolution, loc, {\n          identifierName: name\n        });\n      }\n    }\n  }\n  declarePrivateName(name, elementType, loc) {\n    const {\n      privateNames,\n      loneAccessors,\n      undefinedPrivateNames\n    } = this.current();\n    let redefined = privateNames.has(name);\n    if (elementType & 3) {\n      const accessor = redefined && loneAccessors.get(name);\n      if (accessor) {\n        const oldStatic = accessor & 4;\n        const newStatic = elementType & 4;\n        const oldKind = accessor & 3;\n        const newKind = elementType & 3;\n        redefined = oldKind === newKind || oldStatic !== newStatic;\n        if (!redefined) loneAccessors.delete(name);\n      } else if (!redefined) {\n        loneAccessors.set(name, elementType);\n      }\n    }\n    if (redefined) {\n      this.parser.raise(Errors.PrivateNameRedeclaration, loc, {\n        identifierName: name\n      });\n    }\n    privateNames.add(name);\n    undefinedPrivateNames.delete(name);\n  }\n  usePrivateName(name, loc) {\n    let classScope;\n    for (classScope of this.stack) {\n      if (classScope.privateNames.has(name)) return;\n    }\n    if (classScope) {\n      classScope.undefinedPrivateNames.set(name, loc);\n    } else {\n      this.parser.raise(Errors.InvalidPrivateFieldResolution, loc, {\n        identifierName: name\n      });\n    }\n  }\n}\nclass ExpressionScope {\n  constructor(type = 0) {\n    this.type = type;\n  }\n  canBeArrowParameterDeclaration() {\n    return this.type === 2 || this.type === 1;\n  }\n  isCertainlyParameterDeclaration() {\n    return this.type === 3;\n  }\n}\nclass ArrowHeadParsingScope extends ExpressionScope {\n  constructor(type) {\n    super(type);\n    this.declarationErrors = new Map();\n  }\n  recordDeclarationError(ParsingErrorClass, at) {\n    const index = at.index;\n    this.declarationErrors.set(index, [ParsingErrorClass, at]);\n  }\n  clearDeclarationError(index) {\n    this.declarationErrors.delete(index);\n  }\n  iterateErrors(iterator) {\n    this.declarationErrors.forEach(iterator);\n  }\n}\nclass ExpressionScopeHandler {\n  constructor(parser) {\n    this.parser = void 0;\n    this.stack = [new ExpressionScope()];\n    this.parser = parser;\n  }\n  enter(scope) {\n    this.stack.push(scope);\n  }\n  exit() {\n    this.stack.pop();\n  }\n  recordParameterInitializerError(toParseError, node) {\n    const origin = node.loc.start;\n    const {\n      stack\n    } = this;\n    let i = stack.length - 1;\n    let scope = stack[i];\n    while (!scope.isCertainlyParameterDeclaration()) {\n      if (scope.canBeArrowParameterDeclaration()) {\n        scope.recordDeclarationError(toParseError, origin);\n      } else {\n        return;\n      }\n      scope = stack[--i];\n    }\n    this.parser.raise(toParseError, origin);\n  }\n  recordArrowParameterBindingError(error, node) {\n    const {\n      stack\n    } = this;\n    const scope = stack[stack.length - 1];\n    const origin = node.loc.start;\n    if (scope.isCertainlyParameterDeclaration()) {\n      this.parser.raise(error, origin);\n    } else if (scope.canBeArrowParameterDeclaration()) {\n      scope.recordDeclarationError(error, origin);\n    } else {\n      return;\n    }\n  }\n  recordAsyncArrowParametersError(at) {\n    const {\n      stack\n    } = this;\n    let i = stack.length - 1;\n    let scope = stack[i];\n    while (scope.canBeArrowParameterDeclaration()) {\n      if (scope.type === 2) {\n        scope.recordDeclarationError(Errors.AwaitBindingIdentifier, at);\n      }\n      scope = stack[--i];\n    }\n  }\n  validateAsPattern() {\n    const {\n      stack\n    } = this;\n    const currentScope = stack[stack.length - 1];\n    if (!currentScope.canBeArrowParameterDeclaration()) return;\n    currentScope.iterateErrors(([toParseError, loc]) => {\n      this.parser.raise(toParseError, loc);\n      let i = stack.length - 2;\n      let scope = stack[i];\n      while (scope.canBeArrowParameterDeclaration()) {\n        scope.clearDeclarationError(loc.index);\n        scope = stack[--i];\n      }\n    });\n  }\n}\nfunction newParameterDeclarationScope() {\n  return new ExpressionScope(3);\n}\nfunction newArrowHeadScope() {\n  return new ArrowHeadParsingScope(1);\n}\nfunction newAsyncArrowScope() {\n  return new ArrowHeadParsingScope(2);\n}\nfunction newExpressionScope() {\n  return new ExpressionScope();\n}\nclass UtilParser extends Tokenizer {\n  addExtra(node, key, value, enumerable = true) {\n    if (!node) return;\n    let {\n      extra\n    } = node;\n    if (extra == null) {\n      extra = {};\n      node.extra = extra;\n    }\n    if (enumerable) {\n      extra[key] = value;\n    } else {\n      Object.defineProperty(extra, key, {\n        enumerable,\n        value\n      });\n    }\n  }\n  isContextual(token) {\n    return this.state.type === token && !this.state.containsEsc;\n  }\n  isUnparsedContextual(nameStart, name) {\n    if (this.input.startsWith(name, nameStart)) {\n      const nextCh = this.input.charCodeAt(nameStart + name.length);\n      return !(isIdentifierChar(nextCh) || (nextCh & 0xfc00) === 0xd800);\n    }\n    return false;\n  }\n  isLookaheadContextual(name) {\n    const next = this.nextTokenStart();\n    return this.isUnparsedContextual(next, name);\n  }\n  eatContextual(token) {\n    if (this.isContextual(token)) {\n      this.next();\n      return true;\n    }\n    return false;\n  }\n  expectContextual(token, toParseError) {\n    if (!this.eatContextual(token)) {\n      if (toParseError != null) {\n        throw this.raise(toParseError, this.state.startLoc);\n      }\n      this.unexpected(null, token);\n    }\n  }\n  canInsertSemicolon() {\n    return this.match(140) || this.match(8) || this.hasPrecedingLineBreak();\n  }\n  hasPrecedingLineBreak() {\n    return hasNewLine(this.input, this.offsetToSourcePos(this.state.lastTokEndLoc.index), this.state.start);\n  }\n  hasFollowingLineBreak() {\n    return hasNewLine(this.input, this.state.end, this.nextTokenStart());\n  }\n  isLineTerminator() {\n    return this.eat(13) || this.canInsertSemicolon();\n  }\n  semicolon(allowAsi = true) {\n    if (allowAsi ? this.isLineTerminator() : this.eat(13)) return;\n    this.raise(Errors.MissingSemicolon, this.state.lastTokEndLoc);\n  }\n  expect(type, loc) {\n    if (!this.eat(type)) {\n      this.unexpected(loc, type);\n    }\n  }\n  tryParse(fn, oldState = this.state.clone()) {\n    const abortSignal = {\n      node: null\n    };\n    try {\n      const node = fn((node = null) => {\n        abortSignal.node = node;\n        throw abortSignal;\n      });\n      if (this.state.errors.length > oldState.errors.length) {\n        const failState = this.state;\n        this.state = oldState;\n        this.state.tokensLength = failState.tokensLength;\n        return {\n          node,\n          error: failState.errors[oldState.errors.length],\n          thrown: false,\n          aborted: false,\n          failState\n        };\n      }\n      return {\n        node: node,\n        error: null,\n        thrown: false,\n        aborted: false,\n        failState: null\n      };\n    } catch (error) {\n      const failState = this.state;\n      this.state = oldState;\n      if (error instanceof SyntaxError) {\n        return {\n          node: null,\n          error,\n          thrown: true,\n          aborted: false,\n          failState\n        };\n      }\n      if (error === abortSignal) {\n        return {\n          node: abortSignal.node,\n          error: null,\n          thrown: false,\n          aborted: true,\n          failState\n        };\n      }\n      throw error;\n    }\n  }\n  checkExpressionErrors(refExpressionErrors, andThrow) {\n    if (!refExpressionErrors) return false;\n    const {\n      shorthandAssignLoc,\n      doubleProtoLoc,\n      privateKeyLoc,\n      optionalParametersLoc,\n      voidPatternLoc\n    } = refExpressionErrors;\n    const hasErrors = !!shorthandAssignLoc || !!doubleProtoLoc || !!optionalParametersLoc || !!privateKeyLoc || !!voidPatternLoc;\n    if (!andThrow) {\n      return hasErrors;\n    }\n    if (shorthandAssignLoc != null) {\n      this.raise(Errors.InvalidCoverInitializedName, shorthandAssignLoc);\n    }\n    if (doubleProtoLoc != null) {\n      this.raise(Errors.DuplicateProto, doubleProtoLoc);\n    }\n    if (privateKeyLoc != null) {\n      this.raise(Errors.UnexpectedPrivateField, privateKeyLoc);\n    }\n    if (optionalParametersLoc != null) {\n      this.unexpected(optionalParametersLoc);\n    }\n    if (voidPatternLoc != null) {\n      this.raise(Errors.InvalidCoverDiscardElement, voidPatternLoc);\n    }\n  }\n  isLiteralPropertyName() {\n    return tokenIsLiteralPropertyName(this.state.type);\n  }\n  isPrivateName(node) {\n    return node.type === \"PrivateName\";\n  }\n  getPrivateNameSV(node) {\n    return node.id.name;\n  }\n  hasPropertyAsPrivateName(node) {\n    return (node.type === \"MemberExpression\" || node.type === \"OptionalMemberExpression\") && this.isPrivateName(node.property);\n  }\n  isObjectProperty(node) {\n    return node.type === \"ObjectProperty\";\n  }\n  isObjectMethod(node) {\n    return node.type === \"ObjectMethod\";\n  }\n  initializeScopes(inModule = this.options.sourceType === \"module\") {\n    const oldLabels = this.state.labels;\n    this.state.labels = [];\n    const oldExportedIdentifiers = this.exportedIdentifiers;\n    this.exportedIdentifiers = new Set();\n    const oldInModule = this.inModule;\n    this.inModule = inModule;\n    const oldScope = this.scope;\n    const ScopeHandler = this.getScopeHandler();\n    this.scope = new ScopeHandler(this, inModule);\n    const oldProdParam = this.prodParam;\n    this.prodParam = new ProductionParameterHandler();\n    const oldClassScope = this.classScope;\n    this.classScope = new ClassScopeHandler(this);\n    const oldExpressionScope = this.expressionScope;\n    this.expressionScope = new ExpressionScopeHandler(this);\n    return () => {\n      this.state.labels = oldLabels;\n      this.exportedIdentifiers = oldExportedIdentifiers;\n      this.inModule = oldInModule;\n      this.scope = oldScope;\n      this.prodParam = oldProdParam;\n      this.classScope = oldClassScope;\n      this.expressionScope = oldExpressionScope;\n    };\n  }\n  enterInitialScopes() {\n    let paramFlags = 0;\n    if (this.inModule || this.optionFlags & 1) {\n      paramFlags |= 2;\n    }\n    if (this.optionFlags & 32) {\n      paramFlags |= 1;\n    }\n    const isCommonJS = !this.inModule && this.options.sourceType === \"commonjs\";\n    if (isCommonJS || this.optionFlags & 2) {\n      paramFlags |= 4;\n    }\n    this.prodParam.enter(paramFlags);\n    let scopeFlags = isCommonJS ? 514 : 1;\n    if (this.optionFlags & 4) {\n      scopeFlags |= 512;\n    }\n    this.scope.enter(scopeFlags);\n  }\n  checkDestructuringPrivate(refExpressionErrors) {\n    const {\n      privateKeyLoc\n    } = refExpressionErrors;\n    if (privateKeyLoc !== null) {\n      this.expectPlugin(\"destructuringPrivate\", privateKeyLoc);\n    }\n  }\n}\nclass ExpressionErrors {\n  constructor() {\n    this.shorthandAssignLoc = null;\n    this.doubleProtoLoc = null;\n    this.privateKeyLoc = null;\n    this.optionalParametersLoc = null;\n    this.voidPatternLoc = null;\n  }\n}\nclass Node {\n  constructor(parser, pos, loc) {\n    this.type = \"\";\n    this.start = pos;\n    this.end = 0;\n    this.loc = new SourceLocation(loc);\n    if ((parser == null ? void 0 : parser.optionFlags) & 128) this.range = [pos, 0];\n    if (parser != null && parser.filename) this.loc.filename = parser.filename;\n  }\n}\nconst NodePrototype = Node.prototype;\nNodePrototype.__clone = function () {\n  const newNode = new Node(undefined, this.start, this.loc.start);\n  const keys = Object.keys(this);\n  for (let i = 0, length = keys.length; i < length; i++) {\n    const key = keys[i];\n    if (key !== \"leadingComments\" && key !== \"trailingComments\" && key !== \"innerComments\") {\n      newNode[key] = this[key];\n    }\n  }\n  return newNode;\n};\nclass NodeUtils extends UtilParser {\n  startNode() {\n    const loc = this.state.startLoc;\n    return new Node(this, loc.index, loc);\n  }\n  startNodeAt(loc) {\n    return new Node(this, loc.index, loc);\n  }\n  startNodeAtNode(type) {\n    return this.startNodeAt(type.loc.start);\n  }\n  finishNode(node, type) {\n    return this.finishNodeAt(node, type, this.state.lastTokEndLoc);\n  }\n  finishNodeAt(node, type, endLoc) {\n    node.type = type;\n    node.end = endLoc.index;\n    node.loc.end = endLoc;\n    if (this.optionFlags & 128) node.range[1] = endLoc.index;\n    if (this.optionFlags & 4096) {\n      this.processComment(node);\n    }\n    return node;\n  }\n  resetStartLocation(node, startLoc) {\n    node.start = startLoc.index;\n    node.loc.start = startLoc;\n    if (this.optionFlags & 128) node.range[0] = startLoc.index;\n  }\n  resetEndLocation(node, endLoc = this.state.lastTokEndLoc) {\n    node.end = endLoc.index;\n    node.loc.end = endLoc;\n    if (this.optionFlags & 128) node.range[1] = endLoc.index;\n  }\n  resetStartLocationFromNode(node, locationNode) {\n    this.resetStartLocation(node, locationNode.loc.start);\n  }\n  castNodeTo(node, type) {\n    node.type = type;\n    return node;\n  }\n  cloneIdentifier(node) {\n    const {\n      type,\n      start,\n      end,\n      loc,\n      range,\n      name\n    } = node;\n    const cloned = Object.create(NodePrototype);\n    cloned.type = type;\n    cloned.start = start;\n    cloned.end = end;\n    cloned.loc = loc;\n    cloned.range = range;\n    cloned.name = name;\n    if (node.extra) cloned.extra = node.extra;\n    return cloned;\n  }\n  cloneStringLiteral(node) {\n    const {\n      type,\n      start,\n      end,\n      loc,\n      range,\n      extra\n    } = node;\n    const cloned = Object.create(NodePrototype);\n    cloned.type = type;\n    cloned.start = start;\n    cloned.end = end;\n    cloned.loc = loc;\n    cloned.range = range;\n    cloned.extra = extra;\n    cloned.value = node.value;\n    return cloned;\n  }\n}\nconst unwrapParenthesizedExpression = node => {\n  return node.type === \"ParenthesizedExpression\" ? unwrapParenthesizedExpression(node.expression) : node;\n};\nclass LValParser extends NodeUtils {\n  toAssignable(node, isLHS = false) {\n    var _node$extra, _node$extra3;\n    let parenthesized = undefined;\n    if (node.type === \"ParenthesizedExpression\" || (_node$extra = node.extra) != null && _node$extra.parenthesized) {\n      parenthesized = unwrapParenthesizedExpression(node);\n      if (isLHS) {\n        if (parenthesized.type === \"Identifier\") {\n          this.expressionScope.recordArrowParameterBindingError(Errors.InvalidParenthesizedAssignment, node);\n        } else if (parenthesized.type !== \"CallExpression\" && parenthesized.type !== \"MemberExpression\" && !this.isOptionalMemberExpression(parenthesized)) {\n          this.raise(Errors.InvalidParenthesizedAssignment, node);\n        }\n      } else {\n        this.raise(Errors.InvalidParenthesizedAssignment, node);\n      }\n    }\n    switch (node.type) {\n      case \"Identifier\":\n      case \"ObjectPattern\":\n      case \"ArrayPattern\":\n      case \"AssignmentPattern\":\n      case \"RestElement\":\n      case \"VoidPattern\":\n        break;\n      case \"ObjectExpression\":\n        this.castNodeTo(node, \"ObjectPattern\");\n        for (let i = 0, length = node.properties.length, last = length - 1; i < length; i++) {\n          var _node$extra2;\n          const prop = node.properties[i];\n          const isLast = i === last;\n          this.toAssignableObjectExpressionProp(prop, isLast, isLHS);\n          if (isLast && prop.type === \"RestElement\" && (_node$extra2 = node.extra) != null && _node$extra2.trailingCommaLoc) {\n            this.raise(Errors.RestTrailingComma, node.extra.trailingCommaLoc);\n          }\n        }\n        break;\n      case \"ObjectProperty\":\n        {\n          const {\n            key,\n            value\n          } = node;\n          if (this.isPrivateName(key)) {\n            this.classScope.usePrivateName(this.getPrivateNameSV(key), key.loc.start);\n          }\n          this.toAssignable(value, isLHS);\n          break;\n        }\n      case \"SpreadElement\":\n        {\n          throw new Error(\"Internal @babel/parser error (this is a bug, please report it).\" + \" SpreadElement should be converted by .toAssignable's caller.\");\n        }\n      case \"ArrayExpression\":\n        this.castNodeTo(node, \"ArrayPattern\");\n        this.toAssignableList(node.elements, (_node$extra3 = node.extra) == null ? void 0 : _node$extra3.trailingCommaLoc, isLHS);\n        break;\n      case \"AssignmentExpression\":\n        if (node.operator !== \"=\") {\n          this.raise(Errors.MissingEqInAssignment, node.left.loc.end);\n        }\n        this.castNodeTo(node, \"AssignmentPattern\");\n        delete node.operator;\n        if (node.left.type === \"VoidPattern\") {\n          this.raise(Errors.VoidPatternInitializer, node.left);\n        }\n        this.toAssignable(node.left, isLHS);\n        break;\n      case \"ParenthesizedExpression\":\n        this.toAssignable(parenthesized, isLHS);\n        break;\n    }\n  }\n  toAssignableObjectExpressionProp(prop, isLast, isLHS) {\n    if (prop.type === \"ObjectMethod\") {\n      this.raise(prop.kind === \"get\" || prop.kind === \"set\" ? Errors.PatternHasAccessor : Errors.PatternHasMethod, prop.key);\n    } else if (prop.type === \"SpreadElement\") {\n      this.castNodeTo(prop, \"RestElement\");\n      const arg = prop.argument;\n      this.checkToRestConversion(arg, false);\n      this.toAssignable(arg, isLHS);\n      if (!isLast) {\n        this.raise(Errors.RestTrailingComma, prop);\n      }\n    } else {\n      this.toAssignable(prop, isLHS);\n    }\n  }\n  toAssignableList(exprList, trailingCommaLoc, isLHS) {\n    const end = exprList.length - 1;\n    for (let i = 0; i <= end; i++) {\n      const elt = exprList[i];\n      if (!elt) continue;\n      this.toAssignableListItem(exprList, i, isLHS);\n      if (elt.type === \"RestElement\") {\n        if (i < end) {\n          this.raise(Errors.RestTrailingComma, elt);\n        } else if (trailingCommaLoc) {\n          this.raise(Errors.RestTrailingComma, trailingCommaLoc);\n        }\n      }\n    }\n  }\n  toAssignableListItem(exprList, index, isLHS) {\n    const node = exprList[index];\n    if (node.type === \"SpreadElement\") {\n      this.castNodeTo(node, \"RestElement\");\n      const arg = node.argument;\n      this.checkToRestConversion(arg, true);\n      this.toAssignable(arg, isLHS);\n    } else {\n      this.toAssignable(node, isLHS);\n    }\n  }\n  isAssignable(node, isBinding) {\n    switch (node.type) {\n      case \"Identifier\":\n      case \"ObjectPattern\":\n      case \"ArrayPattern\":\n      case \"AssignmentPattern\":\n      case \"RestElement\":\n      case \"VoidPattern\":\n        return true;\n      case \"ObjectExpression\":\n        {\n          const last = node.properties.length - 1;\n          return node.properties.every((prop, i) => {\n            return prop.type !== \"ObjectMethod\" && (i === last || prop.type !== \"SpreadElement\") && this.isAssignable(prop);\n          });\n        }\n      case \"ObjectProperty\":\n        return this.isAssignable(node.value);\n      case \"SpreadElement\":\n        return this.isAssignable(node.argument);\n      case \"ArrayExpression\":\n        return node.elements.every(element => element === null || this.isAssignable(element));\n      case \"AssignmentExpression\":\n        return node.operator === \"=\";\n      case \"ParenthesizedExpression\":\n        return this.isAssignable(node.expression);\n      case \"MemberExpression\":\n      case \"OptionalMemberExpression\":\n        return !isBinding;\n      default:\n        return false;\n    }\n  }\n  toReferencedList(exprList, isParenthesizedExpr) {\n    return exprList;\n  }\n  toReferencedListDeep(exprList, isParenthesizedExpr) {\n    this.toReferencedList(exprList, isParenthesizedExpr);\n    for (const expr of exprList) {\n      if ((expr == null ? void 0 : expr.type) === \"ArrayExpression\") {\n        this.toReferencedListDeep(expr.elements);\n      }\n    }\n  }\n  parseSpread(refExpressionErrors) {\n    const node = this.startNode();\n    this.next();\n    node.argument = this.parseMaybeAssignAllowIn(refExpressionErrors, undefined);\n    return this.finishNode(node, \"SpreadElement\");\n  }\n  parseRestBinding() {\n    const node = this.startNode();\n    this.next();\n    const argument = this.parseBindingAtom();\n    if (argument.type === \"VoidPattern\") {\n      this.raise(Errors.UnexpectedVoidPattern, argument);\n    }\n    node.argument = argument;\n    return this.finishNode(node, \"RestElement\");\n  }\n  parseBindingAtom() {\n    switch (this.state.type) {\n      case 0:\n        {\n          const node = this.startNode();\n          this.next();\n          node.elements = this.parseBindingList(3, 93, 1);\n          return this.finishNode(node, \"ArrayPattern\");\n        }\n      case 5:\n        return this.parseObjectLike(8, true);\n      case 88:\n        return this.parseVoidPattern(null);\n    }\n    return this.parseIdentifier();\n  }\n  parseBindingList(close, closeCharCode, flags) {\n    const allowEmpty = flags & 1;\n    const elts = [];\n    let first = true;\n    while (!this.eat(close)) {\n      if (first) {\n        first = false;\n      } else {\n        this.expect(12);\n      }\n      if (allowEmpty && this.match(12)) {\n        elts.push(null);\n      } else if (this.eat(close)) {\n        break;\n      } else if (this.match(21)) {\n        let rest = this.parseRestBinding();\n        if (this.hasPlugin(\"flow\") || flags & 2) {\n          rest = this.parseFunctionParamType(rest);\n        }\n        elts.push(rest);\n        if (!this.checkCommaAfterRest(closeCharCode)) {\n          this.expect(close);\n          break;\n        }\n      } else {\n        const decorators = [];\n        if (flags & 2) {\n          if (this.match(26) && this.hasPlugin(\"decorators\")) {\n            this.raise(Errors.UnsupportedParameterDecorator, this.state.startLoc);\n          }\n          while (this.match(26)) {\n            decorators.push(this.parseDecorator());\n          }\n        }\n        elts.push(this.parseBindingElement(flags, decorators));\n      }\n    }\n    return elts;\n  }\n  parseBindingRestProperty(prop) {\n    this.next();\n    if (this.hasPlugin(\"discardBinding\") && this.match(88)) {\n      prop.argument = this.parseVoidPattern(null);\n      this.raise(Errors.UnexpectedVoidPattern, prop.argument);\n    } else {\n      prop.argument = this.parseIdentifier();\n    }\n    this.checkCommaAfterRest(125);\n    return this.finishNode(prop, \"RestElement\");\n  }\n  parseBindingProperty() {\n    const {\n      type,\n      startLoc\n    } = this.state;\n    if (type === 21) {\n      return this.parseBindingRestProperty(this.startNode());\n    }\n    const prop = this.startNode();\n    if (type === 139) {\n      this.expectPlugin(\"destructuringPrivate\", startLoc);\n      this.classScope.usePrivateName(this.state.value, startLoc);\n      prop.key = this.parsePrivateName();\n    } else {\n      this.parsePropertyName(prop);\n    }\n    prop.method = false;\n    return this.parseObjPropValue(prop, startLoc, false, false, true, false);\n  }\n  parseBindingElement(flags, decorators) {\n    const left = this.parseMaybeDefault();\n    if (this.hasPlugin(\"flow\") || flags & 2) {\n      this.parseFunctionParamType(left);\n    }\n    if (decorators.length) {\n      left.decorators = decorators;\n      this.resetStartLocationFromNode(left, decorators[0]);\n    }\n    const elt = this.parseMaybeDefault(left.loc.start, left);\n    return elt;\n  }\n  parseFunctionParamType(param) {\n    return param;\n  }\n  parseMaybeDefault(startLoc, left) {\n    startLoc != null ? startLoc : startLoc = this.state.startLoc;\n    left = left != null ? left : this.parseBindingAtom();\n    if (!this.eat(29)) return left;\n    const node = this.startNodeAt(startLoc);\n    if (left.type === \"VoidPattern\") {\n      this.raise(Errors.VoidPatternInitializer, left);\n    }\n    node.left = left;\n    node.right = this.parseMaybeAssignAllowIn();\n    return this.finishNode(node, \"AssignmentPattern\");\n  }\n  isValidLVal(type, disallowCallExpression, isUnparenthesizedInAssign, binding) {\n    switch (type) {\n      case \"AssignmentPattern\":\n        return \"left\";\n      case \"RestElement\":\n        return \"argument\";\n      case \"ObjectProperty\":\n        return \"value\";\n      case \"ParenthesizedExpression\":\n        return \"expression\";\n      case \"ArrayPattern\":\n        return \"elements\";\n      case \"ObjectPattern\":\n        return \"properties\";\n      case \"VoidPattern\":\n        return true;\n      case \"CallExpression\":\n        if (!disallowCallExpression && !this.state.strict && this.optionFlags & 8192) {\n          return true;\n        }\n    }\n    return false;\n  }\n  isOptionalMemberExpression(expression) {\n    return expression.type === \"OptionalMemberExpression\";\n  }\n  checkLVal(expression, ancestor, binding = 64, checkClashes = false, strictModeChanged = false, hasParenthesizedAncestor = false, disallowCallExpression = false) {\n    var _expression$extra;\n    const type = expression.type;\n    if (this.isObjectMethod(expression)) return;\n    const isOptionalMemberExpression = this.isOptionalMemberExpression(expression);\n    if (isOptionalMemberExpression || type === \"MemberExpression\") {\n      if (isOptionalMemberExpression) {\n        this.expectPlugin(\"optionalChainingAssign\", expression.loc.start);\n        if (ancestor.type !== \"AssignmentExpression\") {\n          this.raise(Errors.InvalidLhsOptionalChaining, expression, {\n            ancestor\n          });\n        }\n      }\n      if (binding !== 64) {\n        this.raise(Errors.InvalidPropertyBindingPattern, expression);\n      }\n      return;\n    }\n    if (type === \"Identifier\") {\n      this.checkIdentifier(expression, binding, strictModeChanged);\n      const {\n        name\n      } = expression;\n      if (checkClashes) {\n        if (checkClashes.has(name)) {\n          this.raise(Errors.ParamDupe, expression);\n        } else {\n          checkClashes.add(name);\n        }\n      }\n      return;\n    } else if (type === \"VoidPattern\" && ancestor.type === \"CatchClause\") {\n      this.raise(Errors.VoidPatternCatchClauseParam, expression);\n    }\n    const unwrappedExpression = unwrapParenthesizedExpression(expression);\n    disallowCallExpression || (disallowCallExpression = unwrappedExpression.type === \"CallExpression\" && (unwrappedExpression.callee.type === \"Import\" || unwrappedExpression.callee.type === \"Super\"));\n    const validity = this.isValidLVal(type, disallowCallExpression, !(hasParenthesizedAncestor || (_expression$extra = expression.extra) != null && _expression$extra.parenthesized) && ancestor.type === \"AssignmentExpression\", binding);\n    if (validity === true) return;\n    if (validity === false) {\n      const ParseErrorClass = binding === 64 ? Errors.InvalidLhs : Errors.InvalidLhsBinding;\n      this.raise(ParseErrorClass, expression, {\n        ancestor\n      });\n      return;\n    }\n    let key, isParenthesizedExpression;\n    if (typeof validity === \"string\") {\n      key = validity;\n      isParenthesizedExpression = type === \"ParenthesizedExpression\";\n    } else {\n      [key, isParenthesizedExpression] = validity;\n    }\n    const nextAncestor = type === \"ArrayPattern\" || type === \"ObjectPattern\" ? {\n      type\n    } : ancestor;\n    const val = expression[key];\n    if (Array.isArray(val)) {\n      for (const child of val) {\n        if (child) {\n          this.checkLVal(child, nextAncestor, binding, checkClashes, strictModeChanged, isParenthesizedExpression, true);\n        }\n      }\n    } else if (val) {\n      this.checkLVal(val, nextAncestor, binding, checkClashes, strictModeChanged, isParenthesizedExpression, disallowCallExpression);\n    }\n  }\n  checkIdentifier(at, bindingType, strictModeChanged = false) {\n    if (this.state.strict && (strictModeChanged ? isStrictBindReservedWord(at.name, this.inModule) : isStrictBindOnlyReservedWord(at.name))) {\n      if (bindingType === 64) {\n        this.raise(Errors.StrictEvalArguments, at, {\n          referenceName: at.name\n        });\n      } else {\n        this.raise(Errors.StrictEvalArgumentsBinding, at, {\n          bindingName: at.name\n        });\n      }\n    }\n    if (bindingType & 8192 && at.name === \"let\") {\n      this.raise(Errors.LetInLexicalBinding, at);\n    }\n    if (!(bindingType & 64)) {\n      this.declareNameFromIdentifier(at, bindingType);\n    }\n  }\n  declareNameFromIdentifier(identifier, binding) {\n    this.scope.declareName(identifier.name, binding, identifier.loc.start);\n  }\n  checkToRestConversion(node, allowPattern) {\n    switch (node.type) {\n      case \"ParenthesizedExpression\":\n        this.checkToRestConversion(node.expression, allowPattern);\n        break;\n      case \"Identifier\":\n      case \"MemberExpression\":\n        break;\n      case \"ArrayExpression\":\n      case \"ObjectExpression\":\n        if (allowPattern) break;\n      default:\n        this.raise(Errors.InvalidRestAssignmentPattern, node);\n    }\n  }\n  checkCommaAfterRest(close) {\n    if (!this.match(12)) {\n      return false;\n    }\n    this.raise(this.lookaheadCharCode() === close ? Errors.RestTrailingComma : Errors.ElementAfterRest, this.state.startLoc);\n    return true;\n  }\n}\nconst keywordAndTSRelationalOperator = /in(?:stanceof)?|as|satisfies/y;\nfunction nonNull(x) {\n  if (x == null) {\n    throw new Error(`Unexpected ${x} value.`);\n  }\n  return x;\n}\nfunction assert(x) {\n  if (!x) {\n    throw new Error(\"Assert fail\");\n  }\n}\nconst TSErrors = ParseErrorEnum`typescript`({\n  AbstractMethodHasImplementation: ({\n    methodName\n  }) => `Method '${methodName}' cannot have an implementation because it is marked abstract.`,\n  AbstractPropertyHasInitializer: ({\n    propertyName\n  }) => `Property '${propertyName}' cannot have an initializer because it is marked abstract.`,\n  AccessorCannotBeOptional: \"An 'accessor' property cannot be declared optional.\",\n  AccessorCannotDeclareThisParameter: \"'get' and 'set' accessors cannot declare 'this' parameters.\",\n  AccessorCannotHaveTypeParameters: \"An accessor cannot have type parameters.\",\n  ClassMethodHasDeclare: \"Class methods cannot have the 'declare' modifier.\",\n  ClassMethodHasReadonly: \"Class methods cannot have the 'readonly' modifier.\",\n  ConstInitializerMustBeStringOrNumericLiteralOrLiteralEnumReference: \"A 'const' initializer in an ambient context must be a string or numeric literal or literal enum reference.\",\n  ConstructorHasTypeParameters: \"Type parameters cannot appear on a constructor declaration.\",\n  DeclareAccessor: ({\n    kind\n  }) => `'declare' is not allowed in ${kind}ters.`,\n  DeclareClassFieldHasInitializer: \"Initializers are not allowed in ambient contexts.\",\n  DeclareFunctionHasImplementation: \"An implementation cannot be declared in ambient contexts.\",\n  DuplicateAccessibilityModifier: ({\n    modifier\n  }) => `Accessibility modifier already seen: '${modifier}'.`,\n  DuplicateModifier: ({\n    modifier\n  }) => `Duplicate modifier: '${modifier}'.`,\n  EmptyHeritageClauseType: ({\n    token\n  }) => `'${token}' list cannot be empty.`,\n  EmptyTypeArguments: \"Type argument list cannot be empty.\",\n  EmptyTypeParameters: \"Type parameter list cannot be empty.\",\n  ExpectedAmbientAfterExportDeclare: \"'export declare' must be followed by an ambient declaration.\",\n  ImportAliasHasImportType: \"An import alias can not use 'import type'.\",\n  ImportReflectionHasImportType: \"An `import module` declaration can not use `type` modifier\",\n  IncompatibleModifiers: ({\n    modifiers\n  }) => `'${modifiers[0]}' modifier cannot be used with '${modifiers[1]}' modifier.`,\n  IndexSignatureHasAbstract: \"Index signatures cannot have the 'abstract' modifier.\",\n  IndexSignatureHasAccessibility: ({\n    modifier\n  }) => `Index signatures cannot have an accessibility modifier ('${modifier}').`,\n  IndexSignatureHasDeclare: \"Index signatures cannot have the 'declare' modifier.\",\n  IndexSignatureHasOverride: \"'override' modifier cannot appear on an index signature.\",\n  IndexSignatureHasStatic: \"Index signatures cannot have the 'static' modifier.\",\n  InitializerNotAllowedInAmbientContext: \"Initializers are not allowed in ambient contexts.\",\n  InvalidHeritageClauseType: ({\n    token\n  }) => `'${token}' list can only include identifiers or qualified-names with optional type arguments.`,\n  InvalidModifierOnAwaitUsingDeclaration: modifier => `'${modifier}' modifier cannot appear on an await using declaration.`,\n  InvalidModifierOnTypeMember: ({\n    modifier\n  }) => `'${modifier}' modifier cannot appear on a type member.`,\n  InvalidModifierOnTypeParameter: ({\n    modifier\n  }) => `'${modifier}' modifier cannot appear on a type parameter.`,\n  InvalidModifierOnTypeParameterPositions: ({\n    modifier\n  }) => `'${modifier}' modifier can only appear on a type parameter of a class, interface or type alias.`,\n  InvalidModifierOnUsingDeclaration: modifier => `'${modifier}' modifier cannot appear on a using declaration.`,\n  InvalidModifiersOrder: ({\n    orderedModifiers\n  }) => `'${orderedModifiers[0]}' modifier must precede '${orderedModifiers[1]}' modifier.`,\n  InvalidPropertyAccessAfterInstantiationExpression: \"Invalid property access after an instantiation expression. \" + \"You can either wrap the instantiation expression in parentheses, or delete the type arguments.\",\n  InvalidTupleMemberLabel: \"Tuple members must be labeled with a simple identifier.\",\n  MissingInterfaceName: \"'interface' declarations must be followed by an identifier.\",\n  NonAbstractClassHasAbstractMethod: \"Abstract methods can only appear within an abstract class.\",\n  NonClassMethodPropertyHasAbstractModifier: \"'abstract' modifier can only appear on a class, method, or property declaration.\",\n  OptionalTypeBeforeRequired: \"A required element cannot follow an optional element.\",\n  OverrideNotInSubClass: \"This member cannot have an 'override' modifier because its containing class does not extend another class.\",\n  PatternIsOptional: \"A binding pattern parameter cannot be optional in an implementation signature.\",\n  PrivateElementHasAbstract: \"Private elements cannot have the 'abstract' modifier.\",\n  PrivateElementHasAccessibility: ({\n    modifier\n  }) => `Private elements cannot have an accessibility modifier ('${modifier}').`,\n  ReadonlyForMethodSignature: \"'readonly' modifier can only appear on a property declaration or index signature.\",\n  ReservedArrowTypeParam: \"This syntax is reserved in files with the .mts or .cts extension. Add a trailing comma, as in `<T,>() => ...`.\",\n  ReservedTypeAssertion: \"This syntax is reserved in files with the .mts or .cts extension. Use an `as` expression instead.\",\n  SetAccessorCannotHaveOptionalParameter: \"A 'set' accessor cannot have an optional parameter.\",\n  SetAccessorCannotHaveRestParameter: \"A 'set' accessor cannot have rest parameter.\",\n  SetAccessorCannotHaveReturnType: \"A 'set' accessor cannot have a return type annotation.\",\n  SingleTypeParameterWithoutTrailingComma: ({\n    typeParameterName\n  }) => `Single type parameter ${typeParameterName} should have a trailing comma. Example usage: <${typeParameterName},>.`,\n  StaticBlockCannotHaveModifier: \"Static class blocks cannot have any modifier.\",\n  TupleOptionalAfterType: \"A labeled tuple optional element must be declared using a question mark after the name and before the colon (`name?: type`), rather than after the type (`name: type?`).\",\n  TypeAnnotationAfterAssign: \"Type annotations must come before default assignments, e.g. instead of `age = 25: number` use `age: number = 25`.\",\n  TypeImportCannotSpecifyDefaultAndNamed: \"A type-only import can specify a default import or named bindings, but not both.\",\n  TypeModifierIsUsedInTypeExports: \"The 'type' modifier cannot be used on a named export when 'export type' is used on its export statement.\",\n  TypeModifierIsUsedInTypeImports: \"The 'type' modifier cannot be used on a named import when 'import type' is used on its import statement.\",\n  UnexpectedParameterModifier: \"A parameter property is only allowed in a constructor implementation.\",\n  UnexpectedReadonly: \"'readonly' type modifier is only permitted on array and tuple literal types.\",\n  UnexpectedTypeAnnotation: \"Did not expect a type annotation here.\",\n  UnexpectedTypeCastInParameter: \"Unexpected type cast in parameter position.\",\n  UnsupportedImportTypeArgument: \"Argument in a type import must be a string literal.\",\n  UnsupportedParameterPropertyKind: \"A parameter property may not be declared using a binding pattern.\",\n  UnsupportedSignatureParameterKind: ({\n    type\n  }) => `Name in a signature must be an Identifier, ObjectPattern or ArrayPattern, instead got ${type}.`,\n  UsingDeclarationInAmbientContext: kind => `'${kind}' declarations are not allowed in ambient contexts.`\n});\nfunction keywordTypeFromName(value) {\n  switch (value) {\n    case \"any\":\n      return \"TSAnyKeyword\";\n    case \"boolean\":\n      return \"TSBooleanKeyword\";\n    case \"bigint\":\n      return \"TSBigIntKeyword\";\n    case \"never\":\n      return \"TSNeverKeyword\";\n    case \"number\":\n      return \"TSNumberKeyword\";\n    case \"object\":\n      return \"TSObjectKeyword\";\n    case \"string\":\n      return \"TSStringKeyword\";\n    case \"symbol\":\n      return \"TSSymbolKeyword\";\n    case \"undefined\":\n      return \"TSUndefinedKeyword\";\n    case \"unknown\":\n      return \"TSUnknownKeyword\";\n    default:\n      return undefined;\n  }\n}\nfunction tsIsAccessModifier(modifier) {\n  return modifier === \"private\" || modifier === \"public\" || modifier === \"protected\";\n}\nfunction tsIsVarianceAnnotations(modifier) {\n  return modifier === \"in\" || modifier === \"out\";\n}\nvar typescript = superClass => class TypeScriptParserMixin extends superClass {\n  constructor(...args) {\n    super(...args);\n    this.tsParseInOutModifiers = this.tsParseModifiers.bind(this, {\n      allowedModifiers: [\"in\", \"out\"],\n      disallowedModifiers: [\"const\", \"public\", \"private\", \"protected\", \"readonly\", \"declare\", \"abstract\", \"override\"],\n      errorTemplate: TSErrors.InvalidModifierOnTypeParameter\n    });\n    this.tsParseConstModifier = this.tsParseModifiers.bind(this, {\n      allowedModifiers: [\"const\"],\n      disallowedModifiers: [\"in\", \"out\"],\n      errorTemplate: TSErrors.InvalidModifierOnTypeParameterPositions\n    });\n    this.tsParseInOutConstModifiers = this.tsParseModifiers.bind(this, {\n      allowedModifiers: [\"in\", \"out\", \"const\"],\n      disallowedModifiers: [\"public\", \"private\", \"protected\", \"readonly\", \"declare\", \"abstract\", \"override\"],\n      errorTemplate: TSErrors.InvalidModifierOnTypeParameter\n    });\n  }\n  getScopeHandler() {\n    return TypeScriptScopeHandler;\n  }\n  tsIsIdentifier() {\n    return tokenIsIdentifier(this.state.type);\n  }\n  tsTokenCanFollowModifier() {\n    return this.match(0) || this.match(5) || this.match(55) || this.match(21) || this.match(139) || this.isLiteralPropertyName();\n  }\n  tsNextTokenOnSameLineAndCanFollowModifier() {\n    this.next();\n    if (this.hasPrecedingLineBreak()) {\n      return false;\n    }\n    return this.tsTokenCanFollowModifier();\n  }\n  tsNextTokenCanFollowModifier() {\n    if (this.match(106)) {\n      this.next();\n      return this.tsTokenCanFollowModifier();\n    }\n    return this.tsNextTokenOnSameLineAndCanFollowModifier();\n  }\n  tsParseModifier(allowedModifiers, stopOnStartOfClassStaticBlock, hasSeenStaticModifier) {\n    if (!tokenIsIdentifier(this.state.type) && this.state.type !== 58 && this.state.type !== 75) {\n      return undefined;\n    }\n    const modifier = this.state.value;\n    if (allowedModifiers.includes(modifier)) {\n      if (hasSeenStaticModifier && this.match(106)) {\n        return undefined;\n      }\n      if (stopOnStartOfClassStaticBlock && this.tsIsStartOfStaticBlocks()) {\n        return undefined;\n      }\n      if (this.tsTryParse(this.tsNextTokenCanFollowModifier.bind(this))) {\n        return modifier;\n      }\n    }\n    return undefined;\n  }\n  tsParseModifiers({\n    allowedModifiers,\n    disallowedModifiers,\n    stopOnStartOfClassStaticBlock,\n    errorTemplate = TSErrors.InvalidModifierOnTypeMember\n  }, modified) {\n    const enforceOrder = (loc, modifier, before, after) => {\n      if (modifier === before && modified[after]) {\n        this.raise(TSErrors.InvalidModifiersOrder, loc, {\n          orderedModifiers: [before, after]\n        });\n      }\n    };\n    const incompatible = (loc, modifier, mod1, mod2) => {\n      if (modified[mod1] && modifier === mod2 || modified[mod2] && modifier === mod1) {\n        this.raise(TSErrors.IncompatibleModifiers, loc, {\n          modifiers: [mod1, mod2]\n        });\n      }\n    };\n    for (;;) {\n      const {\n        startLoc\n      } = this.state;\n      const modifier = this.tsParseModifier(allowedModifiers.concat(disallowedModifiers != null ? disallowedModifiers : []), stopOnStartOfClassStaticBlock, modified.static);\n      if (!modifier) break;\n      if (tsIsAccessModifier(modifier)) {\n        if (modified.accessibility) {\n          this.raise(TSErrors.DuplicateAccessibilityModifier, startLoc, {\n            modifier\n          });\n        } else {\n          enforceOrder(startLoc, modifier, modifier, \"override\");\n          enforceOrder(startLoc, modifier, modifier, \"static\");\n          enforceOrder(startLoc, modifier, modifier, \"readonly\");\n          modified.accessibility = modifier;\n        }\n      } else if (tsIsVarianceAnnotations(modifier)) {\n        if (modified[modifier]) {\n          this.raise(TSErrors.DuplicateModifier, startLoc, {\n            modifier\n          });\n        }\n        modified[modifier] = true;\n        enforceOrder(startLoc, modifier, \"in\", \"out\");\n      } else {\n        if (hasOwnProperty.call(modified, modifier)) {\n          this.raise(TSErrors.DuplicateModifier, startLoc, {\n            modifier\n          });\n        } else {\n          enforceOrder(startLoc, modifier, \"static\", \"readonly\");\n          enforceOrder(startLoc, modifier, \"static\", \"override\");\n          enforceOrder(startLoc, modifier, \"override\", \"readonly\");\n          enforceOrder(startLoc, modifier, \"abstract\", \"override\");\n          incompatible(startLoc, modifier, \"declare\", \"override\");\n          incompatible(startLoc, modifier, \"static\", \"abstract\");\n        }\n        modified[modifier] = true;\n      }\n      if (disallowedModifiers != null && disallowedModifiers.includes(modifier)) {\n        this.raise(errorTemplate, startLoc, {\n          modifier\n        });\n      }\n    }\n  }\n  tsIsListTerminator(kind) {\n    switch (kind) {\n      case \"EnumMembers\":\n      case \"TypeMembers\":\n        return this.match(8);\n      case \"HeritageClauseElement\":\n        return this.match(5);\n      case \"TupleElementTypes\":\n        return this.match(3);\n      case \"TypeParametersOrArguments\":\n        return this.match(48);\n    }\n  }\n  tsParseList(kind, parseElement) {\n    const result = [];\n    while (!this.tsIsListTerminator(kind)) {\n      result.push(parseElement());\n    }\n    return result;\n  }\n  tsParseDelimitedList(kind, parseElement, refTrailingCommaPos) {\n    return nonNull(this.tsParseDelimitedListWorker(kind, parseElement, true, refTrailingCommaPos));\n  }\n  tsParseDelimitedListWorker(kind, parseElement, expectSuccess, refTrailingCommaPos) {\n    const result = [];\n    let trailingCommaPos = -1;\n    for (;;) {\n      if (this.tsIsListTerminator(kind)) {\n        break;\n      }\n      trailingCommaPos = -1;\n      const element = parseElement();\n      if (element == null) {\n        return undefined;\n      }\n      result.push(element);\n      if (this.eat(12)) {\n        trailingCommaPos = this.state.lastTokStartLoc.index;\n        continue;\n      }\n      if (this.tsIsListTerminator(kind)) {\n        break;\n      }\n      if (expectSuccess) {\n        this.expect(12);\n      }\n      return undefined;\n    }\n    if (refTrailingCommaPos) {\n      refTrailingCommaPos.value = trailingCommaPos;\n    }\n    return result;\n  }\n  tsParseBracketedList(kind, parseElement, bracket, skipFirstToken, refTrailingCommaPos) {\n    if (!skipFirstToken) {\n      if (bracket) {\n        this.expect(0);\n      } else {\n        this.expect(47);\n      }\n    }\n    const result = this.tsParseDelimitedList(kind, parseElement, refTrailingCommaPos);\n    if (bracket) {\n      this.expect(3);\n    } else {\n      this.expect(48);\n    }\n    return result;\n  }\n  tsParseImportType() {\n    const node = this.startNode();\n    this.expect(83);\n    this.expect(10);\n    if (!this.match(134)) {\n      this.raise(TSErrors.UnsupportedImportTypeArgument, this.state.startLoc);\n      node.argument = super.parseExprAtom();\n    } else {\n      node.argument = this.parseStringLiteral(this.state.value);\n    }\n    if (this.eat(12)) {\n      node.options = this.tsParseImportTypeOptions();\n    } else {\n      node.options = null;\n    }\n    this.expect(11);\n    if (this.eat(16)) {\n      node.qualifier = this.tsParseEntityName(1 | 2);\n    }\n    if (this.match(47)) {\n      node.typeParameters = this.tsParseTypeArguments();\n    }\n    return this.finishNode(node, \"TSImportType\");\n  }\n  tsParseImportTypeOptions() {\n    const node = this.startNode();\n    this.expect(5);\n    const withProperty = this.startNode();\n    if (this.isContextual(76)) {\n      withProperty.method = false;\n      withProperty.key = this.parseIdentifier(true);\n      withProperty.computed = false;\n      withProperty.shorthand = false;\n    } else {\n      this.unexpected(null, 76);\n    }\n    this.expect(14);\n    withProperty.value = this.tsParseImportTypeWithPropertyValue();\n    node.properties = [this.finishObjectProperty(withProperty)];\n    this.eat(12);\n    this.expect(8);\n    return this.finishNode(node, \"ObjectExpression\");\n  }\n  tsParseImportTypeWithPropertyValue() {\n    const node = this.startNode();\n    const properties = [];\n    this.expect(5);\n    while (!this.match(8)) {\n      const type = this.state.type;\n      if (tokenIsIdentifier(type) || type === 134) {\n        properties.push(super.parsePropertyDefinition(null));\n      } else {\n        this.unexpected();\n      }\n      this.eat(12);\n    }\n    node.properties = properties;\n    this.next();\n    return this.finishNode(node, \"ObjectExpression\");\n  }\n  tsParseEntityName(flags) {\n    let entity;\n    if (flags & 1 && this.match(78)) {\n      if (flags & 2) {\n        entity = this.parseIdentifier(true);\n      } else {\n        const node = this.startNode();\n        this.next();\n        entity = this.finishNode(node, \"ThisExpression\");\n      }\n    } else {\n      entity = this.parseIdentifier(!!(flags & 1));\n    }\n    while (this.eat(16)) {\n      const node = this.startNodeAtNode(entity);\n      node.left = entity;\n      node.right = this.parseIdentifier(!!(flags & 1));\n      entity = this.finishNode(node, \"TSQualifiedName\");\n    }\n    return entity;\n  }\n  tsParseTypeReference() {\n    const node = this.startNode();\n    node.typeName = this.tsParseEntityName(1);\n    if (!this.hasPrecedingLineBreak() && this.match(47)) {\n      node.typeParameters = this.tsParseTypeArguments();\n    }\n    return this.finishNode(node, \"TSTypeReference\");\n  }\n  tsParseThisTypePredicate(lhs) {\n    this.next();\n    const node = this.startNodeAtNode(lhs);\n    node.parameterName = lhs;\n    node.typeAnnotation = this.tsParseTypeAnnotation(false);\n    node.asserts = false;\n    return this.finishNode(node, \"TSTypePredicate\");\n  }\n  tsParseThisTypeNode() {\n    const node = this.startNode();\n    this.next();\n    return this.finishNode(node, \"TSThisType\");\n  }\n  tsParseTypeQuery() {\n    const node = this.startNode();\n    this.expect(87);\n    if (this.match(83)) {\n      node.exprName = this.tsParseImportType();\n    } else {\n      node.exprName = this.tsParseEntityName(1 | 2);\n    }\n    if (!this.hasPrecedingLineBreak() && this.match(47)) {\n      node.typeParameters = this.tsParseTypeArguments();\n    }\n    return this.finishNode(node, \"TSTypeQuery\");\n  }\n  tsParseTypeParameter(parseModifiers) {\n    const node = this.startNode();\n    parseModifiers(node);\n    node.name = this.tsParseTypeParameterName();\n    node.constraint = this.tsEatThenParseType(81);\n    node.default = this.tsEatThenParseType(29);\n    return this.finishNode(node, \"TSTypeParameter\");\n  }\n  tsTryParseTypeParameters(parseModifiers) {\n    if (this.match(47)) {\n      return this.tsParseTypeParameters(parseModifiers);\n    }\n  }\n  tsParseTypeParameters(parseModifiers) {\n    const node = this.startNode();\n    if (this.match(47) || this.match(143)) {\n      this.next();\n    } else {\n      this.unexpected();\n    }\n    const refTrailingCommaPos = {\n      value: -1\n    };\n    node.params = this.tsParseBracketedList(\"TypeParametersOrArguments\", this.tsParseTypeParameter.bind(this, parseModifiers), false, true, refTrailingCommaPos);\n    if (node.params.length === 0) {\n      this.raise(TSErrors.EmptyTypeParameters, node);\n    }\n    if (refTrailingCommaPos.value !== -1) {\n      this.addExtra(node, \"trailingComma\", refTrailingCommaPos.value);\n    }\n    return this.finishNode(node, \"TSTypeParameterDeclaration\");\n  }\n  tsFillSignature(returnToken, signature) {\n    const returnTokenRequired = returnToken === 19;\n    const paramsKey = \"parameters\";\n    const returnTypeKey = \"typeAnnotation\";\n    signature.typeParameters = this.tsTryParseTypeParameters(this.tsParseConstModifier);\n    this.expect(10);\n    signature[paramsKey] = this.tsParseBindingListForSignature();\n    if (returnTokenRequired) {\n      signature[returnTypeKey] = this.tsParseTypeOrTypePredicateAnnotation(returnToken);\n    } else if (this.match(returnToken)) {\n      signature[returnTypeKey] = this.tsParseTypeOrTypePredicateAnnotation(returnToken);\n    }\n  }\n  tsParseBindingListForSignature() {\n    const list = super.parseBindingList(11, 41, 2);\n    for (const pattern of list) {\n      const {\n        type\n      } = pattern;\n      if (type === \"AssignmentPattern\" || type === \"TSParameterProperty\") {\n        this.raise(TSErrors.UnsupportedSignatureParameterKind, pattern, {\n          type\n        });\n      }\n    }\n    return list;\n  }\n  tsParseTypeMemberSemicolon() {\n    if (!this.eat(12) && !this.isLineTerminator()) {\n      this.expect(13);\n    }\n  }\n  tsParseSignatureMember(kind, node) {\n    this.tsFillSignature(14, node);\n    this.tsParseTypeMemberSemicolon();\n    return this.finishNode(node, kind);\n  }\n  tsIsUnambiguouslyIndexSignature() {\n    this.next();\n    if (tokenIsIdentifier(this.state.type)) {\n      this.next();\n      return this.match(14);\n    }\n    return false;\n  }\n  tsTryParseIndexSignature(node) {\n    if (!(this.match(0) && this.tsLookAhead(this.tsIsUnambiguouslyIndexSignature.bind(this)))) {\n      return;\n    }\n    this.expect(0);\n    const id = this.parseIdentifier();\n    id.typeAnnotation = this.tsParseTypeAnnotation();\n    this.resetEndLocation(id);\n    this.expect(3);\n    node.parameters = [id];\n    const type = this.tsTryParseTypeAnnotation();\n    if (type) node.typeAnnotation = type;\n    this.tsParseTypeMemberSemicolon();\n    return this.finishNode(node, \"TSIndexSignature\");\n  }\n  tsParsePropertyOrMethodSignature(node, readonly) {\n    if (this.eat(17)) node.optional = true;\n    if (this.match(10) || this.match(47)) {\n      if (readonly) {\n        this.raise(TSErrors.ReadonlyForMethodSignature, node);\n      }\n      const method = node;\n      if (method.kind && this.match(47)) {\n        this.raise(TSErrors.AccessorCannotHaveTypeParameters, this.state.curPosition());\n      }\n      this.tsFillSignature(14, method);\n      this.tsParseTypeMemberSemicolon();\n      const paramsKey = \"parameters\";\n      const returnTypeKey = \"typeAnnotation\";\n      if (method.kind === \"get\") {\n        if (method[paramsKey].length > 0) {\n          this.raise(Errors.BadGetterArity, this.state.curPosition());\n          if (this.isThisParam(method[paramsKey][0])) {\n            this.raise(TSErrors.AccessorCannotDeclareThisParameter, this.state.curPosition());\n          }\n        }\n      } else if (method.kind === \"set\") {\n        if (method[paramsKey].length !== 1) {\n          this.raise(Errors.BadSetterArity, this.state.curPosition());\n        } else {\n          const firstParameter = method[paramsKey][0];\n          if (this.isThisParam(firstParameter)) {\n            this.raise(TSErrors.AccessorCannotDeclareThisParameter, this.state.curPosition());\n          }\n          if (firstParameter.type === \"Identifier\" && firstParameter.optional) {\n            this.raise(TSErrors.SetAccessorCannotHaveOptionalParameter, this.state.curPosition());\n          }\n          if (firstParameter.type === \"RestElement\") {\n            this.raise(TSErrors.SetAccessorCannotHaveRestParameter, this.state.curPosition());\n          }\n        }\n        if (method[returnTypeKey]) {\n          this.raise(TSErrors.SetAccessorCannotHaveReturnType, method[returnTypeKey]);\n        }\n      } else {\n        method.kind = \"method\";\n      }\n      return this.finishNode(method, \"TSMethodSignature\");\n    } else {\n      const property = node;\n      if (readonly) property.readonly = true;\n      const type = this.tsTryParseTypeAnnotation();\n      if (type) property.typeAnnotation = type;\n      this.tsParseTypeMemberSemicolon();\n      return this.finishNode(property, \"TSPropertySignature\");\n    }\n  }\n  tsParseTypeMember() {\n    const node = this.startNode();\n    if (this.match(10) || this.match(47)) {\n      return this.tsParseSignatureMember(\"TSCallSignatureDeclaration\", node);\n    }\n    if (this.match(77)) {\n      const id = this.startNode();\n      this.next();\n      if (this.match(10) || this.match(47)) {\n        return this.tsParseSignatureMember(\"TSConstructSignatureDeclaration\", node);\n      } else {\n        node.key = this.createIdentifier(id, \"new\");\n        return this.tsParsePropertyOrMethodSignature(node, false);\n      }\n    }\n    this.tsParseModifiers({\n      allowedModifiers: [\"readonly\"],\n      disallowedModifiers: [\"declare\", \"abstract\", \"private\", \"protected\", \"public\", \"static\", \"override\"]\n    }, node);\n    const idx = this.tsTryParseIndexSignature(node);\n    if (idx) {\n      return idx;\n    }\n    super.parsePropertyName(node);\n    if (!node.computed && node.key.type === \"Identifier\" && (node.key.name === \"get\" || node.key.name === \"set\") && this.tsTokenCanFollowModifier()) {\n      node.kind = node.key.name;\n      super.parsePropertyName(node);\n      if (!this.match(10) && !this.match(47)) {\n        this.unexpected(null, 10);\n      }\n    }\n    return this.tsParsePropertyOrMethodSignature(node, !!node.readonly);\n  }\n  tsParseTypeLiteral() {\n    const node = this.startNode();\n    node.members = this.tsParseObjectTypeMembers();\n    return this.finishNode(node, \"TSTypeLiteral\");\n  }\n  tsParseObjectTypeMembers() {\n    this.expect(5);\n    const members = this.tsParseList(\"TypeMembers\", this.tsParseTypeMember.bind(this));\n    this.expect(8);\n    return members;\n  }\n  tsIsStartOfMappedType() {\n    this.next();\n    if (this.eat(53)) {\n      return this.isContextual(122);\n    }\n    if (this.isContextual(122)) {\n      this.next();\n    }\n    if (!this.match(0)) {\n      return false;\n    }\n    this.next();\n    if (!this.tsIsIdentifier()) {\n      return false;\n    }\n    this.next();\n    return this.match(58);\n  }\n  tsParseMappedType() {\n    const node = this.startNode();\n    this.expect(5);\n    if (this.match(53)) {\n      node.readonly = this.state.value;\n      this.next();\n      this.expectContextual(122);\n    } else if (this.eatContextual(122)) {\n      node.readonly = true;\n    }\n    this.expect(0);\n    const typeParameter = this.startNode();\n    typeParameter.name = this.tsParseTypeParameterName();\n    typeParameter.constraint = this.tsExpectThenParseType(58);\n    node.typeParameter = this.finishNode(typeParameter, \"TSTypeParameter\");\n    node.nameType = this.eatContextual(93) ? this.tsParseType() : null;\n    this.expect(3);\n    if (this.match(53)) {\n      node.optional = this.state.value;\n      this.next();\n      this.expect(17);\n    } else if (this.eat(17)) {\n      node.optional = true;\n    }\n    node.typeAnnotation = this.tsTryParseType();\n    this.semicolon();\n    this.expect(8);\n    return this.finishNode(node, \"TSMappedType\");\n  }\n  tsParseTupleType() {\n    const node = this.startNode();\n    node.elementTypes = this.tsParseBracketedList(\"TupleElementTypes\", this.tsParseTupleElementType.bind(this), true, false);\n    let seenOptionalElement = false;\n    node.elementTypes.forEach(elementNode => {\n      const {\n        type\n      } = elementNode;\n      if (seenOptionalElement && type !== \"TSRestType\" && type !== \"TSOptionalType\" && !(type === \"TSNamedTupleMember\" && elementNode.optional)) {\n        this.raise(TSErrors.OptionalTypeBeforeRequired, elementNode);\n      }\n      seenOptionalElement || (seenOptionalElement = type === \"TSNamedTupleMember\" && elementNode.optional || type === \"TSOptionalType\");\n    });\n    return this.finishNode(node, \"TSTupleType\");\n  }\n  tsParseTupleElementType() {\n    const restStartLoc = this.state.startLoc;\n    const rest = this.eat(21);\n    const {\n      startLoc\n    } = this.state;\n    let labeled;\n    let label;\n    let optional;\n    let type;\n    const isWord = tokenIsKeywordOrIdentifier(this.state.type);\n    const chAfterWord = isWord ? this.lookaheadCharCode() : null;\n    if (chAfterWord === 58) {\n      labeled = true;\n      optional = false;\n      label = this.parseIdentifier(true);\n      this.expect(14);\n      type = this.tsParseType();\n    } else if (chAfterWord === 63) {\n      optional = true;\n      const wordName = this.state.value;\n      const typeOrLabel = this.tsParseNonArrayType();\n      if (this.lookaheadCharCode() === 58) {\n        labeled = true;\n        label = this.createIdentifier(this.startNodeAt(startLoc), wordName);\n        this.expect(17);\n        this.expect(14);\n        type = this.tsParseType();\n      } else {\n        labeled = false;\n        type = typeOrLabel;\n        this.expect(17);\n      }\n    } else {\n      type = this.tsParseType();\n      optional = this.eat(17);\n      labeled = this.eat(14);\n    }\n    if (labeled) {\n      let labeledNode;\n      if (label) {\n        labeledNode = this.startNodeAt(startLoc);\n        labeledNode.optional = optional;\n        labeledNode.label = label;\n        labeledNode.elementType = type;\n        if (this.eat(17)) {\n          labeledNode.optional = true;\n          this.raise(TSErrors.TupleOptionalAfterType, this.state.lastTokStartLoc);\n        }\n      } else {\n        labeledNode = this.startNodeAt(startLoc);\n        labeledNode.optional = optional;\n        this.raise(TSErrors.InvalidTupleMemberLabel, type);\n        labeledNode.label = type;\n        labeledNode.elementType = this.tsParseType();\n      }\n      type = this.finishNode(labeledNode, \"TSNamedTupleMember\");\n    } else if (optional) {\n      const optionalTypeNode = this.startNodeAt(startLoc);\n      optionalTypeNode.typeAnnotation = type;\n      type = this.finishNode(optionalTypeNode, \"TSOptionalType\");\n    }\n    if (rest) {\n      const restNode = this.startNodeAt(restStartLoc);\n      restNode.typeAnnotation = type;\n      type = this.finishNode(restNode, \"TSRestType\");\n    }\n    return type;\n  }\n  tsParseParenthesizedType() {\n    const node = this.startNode();\n    this.expect(10);\n    node.typeAnnotation = this.tsParseType();\n    this.expect(11);\n    return this.finishNode(node, \"TSParenthesizedType\");\n  }\n  tsParseFunctionOrConstructorType(type, abstract) {\n    const node = this.startNode();\n    if (type === \"TSConstructorType\") {\n      node.abstract = !!abstract;\n      if (abstract) this.next();\n      this.next();\n    }\n    this.tsInAllowConditionalTypesContext(() => this.tsFillSignature(19, node));\n    return this.finishNode(node, type);\n  }\n  tsParseLiteralTypeNode() {\n    const node = this.startNode();\n    switch (this.state.type) {\n      case 135:\n      case 136:\n      case 134:\n      case 85:\n      case 86:\n        node.literal = super.parseExprAtom();\n        break;\n      default:\n        this.unexpected();\n    }\n    return this.finishNode(node, \"TSLiteralType\");\n  }\n  tsParseTemplateLiteralType() {\n    const node = this.startNode();\n    node.literal = super.parseTemplate(false);\n    return this.finishNode(node, \"TSLiteralType\");\n  }\n  parseTemplateSubstitution() {\n    if (this.state.inType) return this.tsParseType();\n    return super.parseTemplateSubstitution();\n  }\n  tsParseThisTypeOrThisTypePredicate() {\n    const thisKeyword = this.tsParseThisTypeNode();\n    if (this.isContextual(116) && !this.hasPrecedingLineBreak()) {\n      return this.tsParseThisTypePredicate(thisKeyword);\n    } else {\n      return thisKeyword;\n    }\n  }\n  tsParseNonArrayType() {\n    switch (this.state.type) {\n      case 134:\n      case 135:\n      case 136:\n      case 85:\n      case 86:\n        return this.tsParseLiteralTypeNode();\n      case 53:\n        if (this.state.value === \"-\") {\n          const node = this.startNode();\n          const nextToken = this.lookahead();\n          if (nextToken.type !== 135 && nextToken.type !== 136) {\n            this.unexpected();\n          }\n          node.literal = this.parseMaybeUnary();\n          return this.finishNode(node, \"TSLiteralType\");\n        }\n        break;\n      case 78:\n        return this.tsParseThisTypeOrThisTypePredicate();\n      case 87:\n        return this.tsParseTypeQuery();\n      case 83:\n        return this.tsParseImportType();\n      case 5:\n        return this.tsLookAhead(this.tsIsStartOfMappedType.bind(this)) ? this.tsParseMappedType() : this.tsParseTypeLiteral();\n      case 0:\n        return this.tsParseTupleType();\n      case 10:\n        return this.tsParseParenthesizedType();\n      case 25:\n      case 24:\n        return this.tsParseTemplateLiteralType();\n      default:\n        {\n          const {\n            type\n          } = this.state;\n          if (tokenIsIdentifier(type) || type === 88 || type === 84) {\n            const nodeType = type === 88 ? \"TSVoidKeyword\" : type === 84 ? \"TSNullKeyword\" : keywordTypeFromName(this.state.value);\n            if (nodeType !== undefined && this.lookaheadCharCode() !== 46) {\n              const node = this.startNode();\n              this.next();\n              return this.finishNode(node, nodeType);\n            }\n            return this.tsParseTypeReference();\n          }\n        }\n    }\n    throw this.unexpected();\n  }\n  tsParseArrayTypeOrHigher() {\n    const {\n      startLoc\n    } = this.state;\n    let type = this.tsParseNonArrayType();\n    while (!this.hasPrecedingLineBreak() && this.eat(0)) {\n      if (this.match(3)) {\n        const node = this.startNodeAt(startLoc);\n        node.elementType = type;\n        this.expect(3);\n        type = this.finishNode(node, \"TSArrayType\");\n      } else {\n        const node = this.startNodeAt(startLoc);\n        node.objectType = type;\n        node.indexType = this.tsParseType();\n        this.expect(3);\n        type = this.finishNode(node, \"TSIndexedAccessType\");\n      }\n    }\n    return type;\n  }\n  tsParseTypeOperator() {\n    const node = this.startNode();\n    const operator = this.state.value;\n    this.next();\n    node.operator = operator;\n    node.typeAnnotation = this.tsParseTypeOperatorOrHigher();\n    if (operator === \"readonly\") {\n      this.tsCheckTypeAnnotationForReadOnly(node);\n    }\n    return this.finishNode(node, \"TSTypeOperator\");\n  }\n  tsCheckTypeAnnotationForReadOnly(node) {\n    switch (node.typeAnnotation.type) {\n      case \"TSTupleType\":\n      case \"TSArrayType\":\n        return;\n      default:\n        this.raise(TSErrors.UnexpectedReadonly, node);\n    }\n  }\n  tsParseInferType() {\n    const node = this.startNode();\n    this.expectContextual(115);\n    const typeParameter = this.startNode();\n    typeParameter.name = this.tsParseTypeParameterName();\n    typeParameter.constraint = this.tsTryParse(() => this.tsParseConstraintForInferType());\n    node.typeParameter = this.finishNode(typeParameter, \"TSTypeParameter\");\n    return this.finishNode(node, \"TSInferType\");\n  }\n  tsParseConstraintForInferType() {\n    if (this.eat(81)) {\n      const constraint = this.tsInDisallowConditionalTypesContext(() => this.tsParseType());\n      if (this.state.inDisallowConditionalTypesContext || !this.match(17)) {\n        return constraint;\n      }\n    }\n  }\n  tsParseTypeOperatorOrHigher() {\n    const isTypeOperator = tokenIsTSTypeOperator(this.state.type) && !this.state.containsEsc;\n    return isTypeOperator ? this.tsParseTypeOperator() : this.isContextual(115) ? this.tsParseInferType() : this.tsInAllowConditionalTypesContext(() => this.tsParseArrayTypeOrHigher());\n  }\n  tsParseUnionOrIntersectionType(kind, parseConstituentType, operator) {\n    const node = this.startNode();\n    const hasLeadingOperator = this.eat(operator);\n    const types = [];\n    do {\n      types.push(parseConstituentType());\n    } while (this.eat(operator));\n    if (types.length === 1 && !hasLeadingOperator) {\n      return types[0];\n    }\n    node.types = types;\n    return this.finishNode(node, kind);\n  }\n  tsParseIntersectionTypeOrHigher() {\n    return this.tsParseUnionOrIntersectionType(\"TSIntersectionType\", this.tsParseTypeOperatorOrHigher.bind(this), 45);\n  }\n  tsParseUnionTypeOrHigher() {\n    return this.tsParseUnionOrIntersectionType(\"TSUnionType\", this.tsParseIntersectionTypeOrHigher.bind(this), 43);\n  }\n  tsIsStartOfFunctionType() {\n    if (this.match(47)) {\n      return true;\n    }\n    return this.match(10) && this.tsLookAhead(this.tsIsUnambiguouslyStartOfFunctionType.bind(this));\n  }\n  tsSkipParameterStart() {\n    if (tokenIsIdentifier(this.state.type) || this.match(78)) {\n      this.next();\n      return true;\n    }\n    if (this.match(5)) {\n      const {\n        errors\n      } = this.state;\n      const previousErrorCount = errors.length;\n      try {\n        this.parseObjectLike(8, true);\n        return errors.length === previousErrorCount;\n      } catch (_unused) {\n        return false;\n      }\n    }\n    if (this.match(0)) {\n      this.next();\n      const {\n        errors\n      } = this.state;\n      const previousErrorCount = errors.length;\n      try {\n        super.parseBindingList(3, 93, 1);\n        return errors.length === previousErrorCount;\n      } catch (_unused2) {\n        return false;\n      }\n    }\n    return false;\n  }\n  tsIsUnambiguouslyStartOfFunctionType() {\n    this.next();\n    if (this.match(11) || this.match(21)) {\n      return true;\n    }\n    if (this.tsSkipParameterStart()) {\n      if (this.match(14) || this.match(12) || this.match(17) || this.match(29)) {\n        return true;\n      }\n      if (this.match(11)) {\n        this.next();\n        if (this.match(19)) {\n          return true;\n        }\n      }\n    }\n    return false;\n  }\n  tsParseTypeOrTypePredicateAnnotation(returnToken) {\n    return this.tsInType(() => {\n      const t = this.startNode();\n      this.expect(returnToken);\n      const node = this.startNode();\n      const asserts = !!this.tsTryParse(this.tsParseTypePredicateAsserts.bind(this));\n      if (asserts && this.match(78)) {\n        let thisTypePredicate = this.tsParseThisTypeOrThisTypePredicate();\n        if (thisTypePredicate.type === \"TSThisType\") {\n          node.parameterName = thisTypePredicate;\n          node.asserts = true;\n          node.typeAnnotation = null;\n          thisTypePredicate = this.finishNode(node, \"TSTypePredicate\");\n        } else {\n          this.resetStartLocationFromNode(thisTypePredicate, node);\n          thisTypePredicate.asserts = true;\n        }\n        t.typeAnnotation = thisTypePredicate;\n        return this.finishNode(t, \"TSTypeAnnotation\");\n      }\n      const typePredicateVariable = this.tsIsIdentifier() && this.tsTryParse(this.tsParseTypePredicatePrefix.bind(this));\n      if (!typePredicateVariable) {\n        if (!asserts) {\n          return this.tsParseTypeAnnotation(false, t);\n        }\n        node.parameterName = this.parseIdentifier();\n        node.asserts = asserts;\n        node.typeAnnotation = null;\n        t.typeAnnotation = this.finishNode(node, \"TSTypePredicate\");\n        return this.finishNode(t, \"TSTypeAnnotation\");\n      }\n      const type = this.tsParseTypeAnnotation(false);\n      node.parameterName = typePredicateVariable;\n      node.typeAnnotation = type;\n      node.asserts = asserts;\n      t.typeAnnotation = this.finishNode(node, \"TSTypePredicate\");\n      return this.finishNode(t, \"TSTypeAnnotation\");\n    });\n  }\n  tsTryParseTypeOrTypePredicateAnnotation() {\n    if (this.match(14)) {\n      return this.tsParseTypeOrTypePredicateAnnotation(14);\n    }\n  }\n  tsTryParseTypeAnnotation() {\n    if (this.match(14)) {\n      return this.tsParseTypeAnnotation();\n    }\n  }\n  tsTryParseType() {\n    return this.tsEatThenParseType(14);\n  }\n  tsParseTypePredicatePrefix() {\n    const id = this.parseIdentifier();\n    if (this.isContextual(116) && !this.hasPrecedingLineBreak()) {\n      this.next();\n      return id;\n    }\n  }\n  tsParseTypePredicateAsserts() {\n    if (this.state.type !== 109) {\n      return false;\n    }\n    const containsEsc = this.state.containsEsc;\n    this.next();\n    if (!tokenIsIdentifier(this.state.type) && !this.match(78)) {\n      return false;\n    }\n    if (containsEsc) {\n      this.raise(Errors.InvalidEscapedReservedWord, this.state.lastTokStartLoc, {\n        reservedWord: \"asserts\"\n      });\n    }\n    return true;\n  }\n  tsParseTypeAnnotation(eatColon = true, t = this.startNode()) {\n    this.tsInType(() => {\n      if (eatColon) this.expect(14);\n      t.typeAnnotation = this.tsParseType();\n    });\n    return this.finishNode(t, \"TSTypeAnnotation\");\n  }\n  tsParseType() {\n    assert(this.state.inType);\n    const type = this.tsParseNonConditionalType();\n    if (this.state.inDisallowConditionalTypesContext || this.hasPrecedingLineBreak() || !this.eat(81)) {\n      return type;\n    }\n    const node = this.startNodeAtNode(type);\n    node.checkType = type;\n    node.extendsType = this.tsInDisallowConditionalTypesContext(() => this.tsParseNonConditionalType());\n    this.expect(17);\n    node.trueType = this.tsInAllowConditionalTypesContext(() => this.tsParseType());\n    this.expect(14);\n    node.falseType = this.tsInAllowConditionalTypesContext(() => this.tsParseType());\n    return this.finishNode(node, \"TSConditionalType\");\n  }\n  isAbstractConstructorSignature() {\n    return this.isContextual(124) && this.isLookaheadContextual(\"new\");\n  }\n  tsParseNonConditionalType() {\n    if (this.tsIsStartOfFunctionType()) {\n      return this.tsParseFunctionOrConstructorType(\"TSFunctionType\");\n    }\n    if (this.match(77)) {\n      return this.tsParseFunctionOrConstructorType(\"TSConstructorType\");\n    } else if (this.isAbstractConstructorSignature()) {\n      return this.tsParseFunctionOrConstructorType(\"TSConstructorType\", true);\n    }\n    return this.tsParseUnionTypeOrHigher();\n  }\n  tsParseTypeAssertion() {\n    if (this.getPluginOption(\"typescript\", \"disallowAmbiguousJSXLike\")) {\n      this.raise(TSErrors.ReservedTypeAssertion, this.state.startLoc);\n    }\n    const node = this.startNode();\n    node.typeAnnotation = this.tsInType(() => {\n      this.next();\n      return this.match(75) ? this.tsParseTypeReference() : this.tsParseType();\n    });\n    this.expect(48);\n    node.expression = this.parseMaybeUnary();\n    return this.finishNode(node, \"TSTypeAssertion\");\n  }\n  tsParseHeritageClause(token) {\n    const originalStartLoc = this.state.startLoc;\n    const delimitedList = this.tsParseDelimitedList(\"HeritageClauseElement\", () => {\n      const node = this.startNode();\n      node.expression = this.tsParseEntityName(1 | 2);\n      if (this.match(47)) {\n        node.typeParameters = this.tsParseTypeArguments();\n      }\n      return this.finishNode(node, \"TSExpressionWithTypeArguments\");\n    });\n    if (!delimitedList.length) {\n      this.raise(TSErrors.EmptyHeritageClauseType, originalStartLoc, {\n        token\n      });\n    }\n    return delimitedList;\n  }\n  tsParseInterfaceDeclaration(node, properties = {}) {\n    if (this.hasFollowingLineBreak()) return null;\n    this.expectContextual(129);\n    if (properties.declare) node.declare = true;\n    if (tokenIsIdentifier(this.state.type)) {\n      node.id = this.parseIdentifier();\n      this.checkIdentifier(node.id, 130);\n    } else {\n      node.id = null;\n      this.raise(TSErrors.MissingInterfaceName, this.state.startLoc);\n    }\n    node.typeParameters = this.tsTryParseTypeParameters(this.tsParseInOutConstModifiers);\n    if (this.eat(81)) {\n      node.extends = this.tsParseHeritageClause(\"extends\");\n    }\n    const body = this.startNode();\n    body.body = this.tsInType(this.tsParseObjectTypeMembers.bind(this));\n    node.body = this.finishNode(body, \"TSInterfaceBody\");\n    return this.finishNode(node, \"TSInterfaceDeclaration\");\n  }\n  tsParseTypeAliasDeclaration(node) {\n    node.id = this.parseIdentifier();\n    this.checkIdentifier(node.id, 2);\n    node.typeAnnotation = this.tsInType(() => {\n      node.typeParameters = this.tsTryParseTypeParameters(this.tsParseInOutModifiers);\n      this.expect(29);\n      if (this.isContextual(114) && this.lookaheadCharCode() !== 46) {\n        const node = this.startNode();\n        this.next();\n        return this.finishNode(node, \"TSIntrinsicKeyword\");\n      }\n      return this.tsParseType();\n    });\n    this.semicolon();\n    return this.finishNode(node, \"TSTypeAliasDeclaration\");\n  }\n  tsInTopLevelContext(cb) {\n    if (this.curContext() !== types.brace) {\n      const oldContext = this.state.context;\n      this.state.context = [oldContext[0]];\n      try {\n        return cb();\n      } finally {\n        this.state.context = oldContext;\n      }\n    } else {\n      return cb();\n    }\n  }\n  tsInType(cb) {\n    const oldInType = this.state.inType;\n    this.state.inType = true;\n    try {\n      return cb();\n    } finally {\n      this.state.inType = oldInType;\n    }\n  }\n  tsInDisallowConditionalTypesContext(cb) {\n    const oldInDisallowConditionalTypesContext = this.state.inDisallowConditionalTypesContext;\n    this.state.inDisallowConditionalTypesContext = true;\n    try {\n      return cb();\n    } finally {\n      this.state.inDisallowConditionalTypesContext = oldInDisallowConditionalTypesContext;\n    }\n  }\n  tsInAllowConditionalTypesContext(cb) {\n    const oldInDisallowConditionalTypesContext = this.state.inDisallowConditionalTypesContext;\n    this.state.inDisallowConditionalTypesContext = false;\n    try {\n      return cb();\n    } finally {\n      this.state.inDisallowConditionalTypesContext = oldInDisallowConditionalTypesContext;\n    }\n  }\n  tsEatThenParseType(token) {\n    if (this.match(token)) {\n      return this.tsNextThenParseType();\n    }\n  }\n  tsExpectThenParseType(token) {\n    return this.tsInType(() => {\n      this.expect(token);\n      return this.tsParseType();\n    });\n  }\n  tsNextThenParseType() {\n    return this.tsInType(() => {\n      this.next();\n      return this.tsParseType();\n    });\n  }\n  tsParseEnumMember() {\n    const node = this.startNode();\n    node.id = this.match(134) ? super.parseStringLiteral(this.state.value) : this.parseIdentifier(true);\n    if (this.eat(29)) {\n      node.initializer = super.parseMaybeAssignAllowIn();\n    }\n    return this.finishNode(node, \"TSEnumMember\");\n  }\n  tsParseEnumDeclaration(node, properties = {}) {\n    if (properties.const) node.const = true;\n    if (properties.declare) node.declare = true;\n    this.expectContextual(126);\n    node.id = this.parseIdentifier();\n    this.checkIdentifier(node.id, node.const ? 8971 : 8459);\n    this.expect(5);\n    node.members = this.tsParseDelimitedList(\"EnumMembers\", this.tsParseEnumMember.bind(this));\n    this.expect(8);\n    return this.finishNode(node, \"TSEnumDeclaration\");\n  }\n  tsParseEnumBody() {\n    const node = this.startNode();\n    this.expect(5);\n    node.members = this.tsParseDelimitedList(\"EnumMembers\", this.tsParseEnumMember.bind(this));\n    this.expect(8);\n    return this.finishNode(node, \"TSEnumBody\");\n  }\n  tsParseModuleBlock() {\n    const node = this.startNode();\n    this.scope.enter(0);\n    this.expect(5);\n    super.parseBlockOrModuleBlockBody(node.body = [], undefined, true, 8);\n    this.scope.exit();\n    return this.finishNode(node, \"TSModuleBlock\");\n  }\n  tsParseModuleOrNamespaceDeclaration(node, nested = false) {\n    node.id = this.parseIdentifier();\n    if (!nested) {\n      this.checkIdentifier(node.id, 1024);\n    }\n    if (this.eat(16)) {\n      const inner = this.startNode();\n      this.tsParseModuleOrNamespaceDeclaration(inner, true);\n      node.body = inner;\n    } else {\n      this.scope.enter(1024);\n      this.prodParam.enter(0);\n      node.body = this.tsParseModuleBlock();\n      this.prodParam.exit();\n      this.scope.exit();\n    }\n    return this.finishNode(node, \"TSModuleDeclaration\");\n  }\n  tsParseAmbientExternalModuleDeclaration(node) {\n    if (this.isContextual(112)) {\n      node.kind = \"global\";\n      node.global = true;\n      node.id = this.parseIdentifier();\n    } else if (this.match(134)) {\n      node.kind = \"module\";\n      node.id = super.parseStringLiteral(this.state.value);\n    } else {\n      this.unexpected();\n    }\n    if (this.match(5)) {\n      this.scope.enter(1024);\n      this.prodParam.enter(0);\n      node.body = this.tsParseModuleBlock();\n      this.prodParam.exit();\n      this.scope.exit();\n    } else {\n      this.semicolon();\n    }\n    return this.finishNode(node, \"TSModuleDeclaration\");\n  }\n  tsParseImportEqualsDeclaration(node, maybeDefaultIdentifier, isExport) {\n    node.isExport = isExport || false;\n    node.id = maybeDefaultIdentifier || this.parseIdentifier();\n    this.checkIdentifier(node.id, 4096);\n    this.expect(29);\n    const moduleReference = this.tsParseModuleReference();\n    if (node.importKind === \"type\" && moduleReference.type !== \"TSExternalModuleReference\") {\n      this.raise(TSErrors.ImportAliasHasImportType, moduleReference);\n    }\n    node.moduleReference = moduleReference;\n    this.semicolon();\n    return this.finishNode(node, \"TSImportEqualsDeclaration\");\n  }\n  tsIsExternalModuleReference() {\n    return this.isContextual(119) && this.lookaheadCharCode() === 40;\n  }\n  tsParseModuleReference() {\n    return this.tsIsExternalModuleReference() ? this.tsParseExternalModuleReference() : this.tsParseEntityName(0);\n  }\n  tsParseExternalModuleReference() {\n    const node = this.startNode();\n    this.expectContextual(119);\n    this.expect(10);\n    if (!this.match(134)) {\n      this.unexpected();\n    }\n    node.expression = super.parseExprAtom();\n    this.expect(11);\n    this.sawUnambiguousESM = true;\n    return this.finishNode(node, \"TSExternalModuleReference\");\n  }\n  tsLookAhead(f) {\n    const state = this.state.clone();\n    const res = f();\n    this.state = state;\n    return res;\n  }\n  tsTryParseAndCatch(f) {\n    const result = this.tryParse(abort => f() || abort());\n    if (result.aborted || !result.node) return;\n    if (result.error) this.state = result.failState;\n    return result.node;\n  }\n  tsTryParse(f) {\n    const state = this.state.clone();\n    const result = f();\n    if (result !== undefined && result !== false) {\n      return result;\n    }\n    this.state = state;\n  }\n  tsTryParseDeclare(node) {\n    if (this.isLineTerminator()) {\n      return;\n    }\n    const startType = this.state.type;\n    return this.tsInAmbientContext(() => {\n      switch (startType) {\n        case 68:\n          node.declare = true;\n          return super.parseFunctionStatement(node, false, false);\n        case 80:\n          node.declare = true;\n          return this.parseClass(node, true, false);\n        case 126:\n          return this.tsParseEnumDeclaration(node, {\n            declare: true\n          });\n        case 112:\n          return this.tsParseAmbientExternalModuleDeclaration(node);\n        case 100:\n          if (this.state.containsEsc) {\n            return;\n          }\n        case 75:\n        case 74:\n          if (!this.match(75) || !this.isLookaheadContextual(\"enum\")) {\n            node.declare = true;\n            return this.parseVarStatement(node, this.state.value, true);\n          }\n          this.expect(75);\n          return this.tsParseEnumDeclaration(node, {\n            const: true,\n            declare: true\n          });\n        case 107:\n          if (this.isUsing()) {\n            this.raise(TSErrors.InvalidModifierOnUsingDeclaration, this.state.startLoc, \"declare\");\n            node.declare = true;\n            return this.parseVarStatement(node, \"using\", true);\n          }\n          break;\n        case 96:\n          if (this.isAwaitUsing()) {\n            this.raise(TSErrors.InvalidModifierOnAwaitUsingDeclaration, this.state.startLoc, \"declare\");\n            node.declare = true;\n            this.next();\n            return this.parseVarStatement(node, \"await using\", true);\n          }\n          break;\n        case 129:\n          {\n            const result = this.tsParseInterfaceDeclaration(node, {\n              declare: true\n            });\n            if (result) return result;\n          }\n        default:\n          if (tokenIsIdentifier(startType)) {\n            return this.tsParseDeclaration(node, this.state.type, true, null);\n          }\n      }\n    });\n  }\n  tsTryParseExportDeclaration() {\n    return this.tsParseDeclaration(this.startNode(), this.state.type, true, null);\n  }\n  tsParseDeclaration(node, type, next, decorators) {\n    switch (type) {\n      case 124:\n        if (this.tsCheckLineTerminator(next) && (this.match(80) || tokenIsIdentifier(this.state.type))) {\n          return this.tsParseAbstractDeclaration(node, decorators);\n        }\n        break;\n      case 127:\n        if (this.tsCheckLineTerminator(next)) {\n          if (this.match(134)) {\n            return this.tsParseAmbientExternalModuleDeclaration(node);\n          } else if (tokenIsIdentifier(this.state.type)) {\n            node.kind = \"module\";\n            return this.tsParseModuleOrNamespaceDeclaration(node);\n          }\n        }\n        break;\n      case 128:\n        if (this.tsCheckLineTerminator(next) && tokenIsIdentifier(this.state.type)) {\n          node.kind = \"namespace\";\n          return this.tsParseModuleOrNamespaceDeclaration(node);\n        }\n        break;\n      case 130:\n        if (this.tsCheckLineTerminator(next) && tokenIsIdentifier(this.state.type)) {\n          return this.tsParseTypeAliasDeclaration(node);\n        }\n        break;\n    }\n  }\n  tsCheckLineTerminator(next) {\n    if (next) {\n      if (this.hasFollowingLineBreak()) return false;\n      this.next();\n      return true;\n    }\n    return !this.isLineTerminator();\n  }\n  tsTryParseGenericAsyncArrowFunction(startLoc) {\n    if (!this.match(47)) return;\n    const oldMaybeInArrowParameters = this.state.maybeInArrowParameters;\n    this.state.maybeInArrowParameters = true;\n    const res = this.tsTryParseAndCatch(() => {\n      const node = this.startNodeAt(startLoc);\n      node.typeParameters = this.tsParseTypeParameters(this.tsParseConstModifier);\n      super.parseFunctionParams(node);\n      node.returnType = this.tsTryParseTypeOrTypePredicateAnnotation();\n      this.expect(19);\n      return node;\n    });\n    this.state.maybeInArrowParameters = oldMaybeInArrowParameters;\n    if (!res) return;\n    return super.parseArrowExpression(res, null, true);\n  }\n  tsParseTypeArgumentsInExpression() {\n    if (this.reScan_lt() !== 47) return;\n    return this.tsParseTypeArguments();\n  }\n  tsParseTypeArguments() {\n    const node = this.startNode();\n    node.params = this.tsInType(() => this.tsInTopLevelContext(() => {\n      this.expect(47);\n      return this.tsParseDelimitedList(\"TypeParametersOrArguments\", this.tsParseType.bind(this));\n    }));\n    if (node.params.length === 0) {\n      this.raise(TSErrors.EmptyTypeArguments, node);\n    } else if (!this.state.inType && this.curContext() === types.brace) {\n      this.reScan_lt_gt();\n    }\n    this.expect(48);\n    return this.finishNode(node, \"TSTypeParameterInstantiation\");\n  }\n  tsIsDeclarationStart() {\n    return tokenIsTSDeclarationStart(this.state.type);\n  }\n  isExportDefaultSpecifier() {\n    if (this.tsIsDeclarationStart()) return false;\n    return super.isExportDefaultSpecifier();\n  }\n  parseBindingElement(flags, decorators) {\n    const startLoc = decorators.length ? decorators[0].loc.start : this.state.startLoc;\n    const modified = {};\n    this.tsParseModifiers({\n      allowedModifiers: [\"public\", \"private\", \"protected\", \"override\", \"readonly\"]\n    }, modified);\n    const accessibility = modified.accessibility;\n    const override = modified.override;\n    const readonly = modified.readonly;\n    if (!(flags & 4) && (accessibility || readonly || override)) {\n      this.raise(TSErrors.UnexpectedParameterModifier, startLoc);\n    }\n    const left = this.parseMaybeDefault();\n    if (flags & 2) {\n      this.parseFunctionParamType(left);\n    }\n    const elt = this.parseMaybeDefault(left.loc.start, left);\n    if (accessibility || readonly || override) {\n      const pp = this.startNodeAt(startLoc);\n      if (decorators.length) {\n        pp.decorators = decorators;\n      }\n      if (accessibility) pp.accessibility = accessibility;\n      if (readonly) pp.readonly = readonly;\n      if (override) pp.override = override;\n      if (elt.type !== \"Identifier\" && elt.type !== \"AssignmentPattern\") {\n        this.raise(TSErrors.UnsupportedParameterPropertyKind, pp);\n      }\n      pp.parameter = elt;\n      return this.finishNode(pp, \"TSParameterProperty\");\n    }\n    if (decorators.length) {\n      left.decorators = decorators;\n    }\n    return elt;\n  }\n  isSimpleParameter(node) {\n    return node.type === \"TSParameterProperty\" && super.isSimpleParameter(node.parameter) || super.isSimpleParameter(node);\n  }\n  tsDisallowOptionalPattern(node) {\n    for (const param of node.params) {\n      if (param.type !== \"Identifier\" && param.optional && !this.state.isAmbientContext) {\n        this.raise(TSErrors.PatternIsOptional, param);\n      }\n    }\n  }\n  setArrowFunctionParameters(node, params, trailingCommaLoc) {\n    super.setArrowFunctionParameters(node, params, trailingCommaLoc);\n    this.tsDisallowOptionalPattern(node);\n  }\n  parseFunctionBodyAndFinish(node, type, isMethod = false) {\n    if (this.match(14)) {\n      node.returnType = this.tsParseTypeOrTypePredicateAnnotation(14);\n    }\n    const bodilessType = type === \"FunctionDeclaration\" ? \"TSDeclareFunction\" : type === \"ClassMethod\" || type === \"ClassPrivateMethod\" ? \"TSDeclareMethod\" : undefined;\n    if (bodilessType && !this.match(5) && this.isLineTerminator()) {\n      return this.finishNode(node, bodilessType);\n    }\n    if (bodilessType === \"TSDeclareFunction\" && this.state.isAmbientContext) {\n      this.raise(TSErrors.DeclareFunctionHasImplementation, node);\n      if (node.declare) {\n        return super.parseFunctionBodyAndFinish(node, bodilessType, isMethod);\n      }\n    }\n    this.tsDisallowOptionalPattern(node);\n    return super.parseFunctionBodyAndFinish(node, type, isMethod);\n  }\n  registerFunctionStatementId(node) {\n    if (!node.body && node.id) {\n      this.checkIdentifier(node.id, 1024);\n    } else {\n      super.registerFunctionStatementId(node);\n    }\n  }\n  tsCheckForInvalidTypeCasts(items) {\n    items.forEach(node => {\n      if ((node == null ? void 0 : node.type) === \"TSTypeCastExpression\") {\n        this.raise(TSErrors.UnexpectedTypeAnnotation, node.typeAnnotation);\n      }\n    });\n  }\n  toReferencedList(exprList, isInParens) {\n    this.tsCheckForInvalidTypeCasts(exprList);\n    return exprList;\n  }\n  parseArrayLike(close, isTuple, refExpressionErrors) {\n    const node = super.parseArrayLike(close, isTuple, refExpressionErrors);\n    if (node.type === \"ArrayExpression\") {\n      this.tsCheckForInvalidTypeCasts(node.elements);\n    }\n    return node;\n  }\n  parseSubscript(base, startLoc, noCalls, state) {\n    if (!this.hasPrecedingLineBreak() && this.match(35)) {\n      this.state.canStartJSXElement = false;\n      this.next();\n      const nonNullExpression = this.startNodeAt(startLoc);\n      nonNullExpression.expression = base;\n      return this.finishNode(nonNullExpression, \"TSNonNullExpression\");\n    }\n    let isOptionalCall = false;\n    if (this.match(18) && this.lookaheadCharCode() === 60) {\n      if (noCalls) {\n        state.stop = true;\n        return base;\n      }\n      state.optionalChainMember = isOptionalCall = true;\n      this.next();\n    }\n    if (this.match(47) || this.match(51)) {\n      let missingParenErrorLoc;\n      const result = this.tsTryParseAndCatch(() => {\n        if (!noCalls && this.atPossibleAsyncArrow(base)) {\n          const asyncArrowFn = this.tsTryParseGenericAsyncArrowFunction(startLoc);\n          if (asyncArrowFn) {\n            state.stop = true;\n            return asyncArrowFn;\n          }\n        }\n        const typeArguments = this.tsParseTypeArgumentsInExpression();\n        if (!typeArguments) return;\n        if (isOptionalCall && !this.match(10)) {\n          missingParenErrorLoc = this.state.curPosition();\n          return;\n        }\n        if (tokenIsTemplate(this.state.type)) {\n          const result = super.parseTaggedTemplateExpression(base, startLoc, state);\n          result.typeParameters = typeArguments;\n          return result;\n        }\n        if (!noCalls && this.eat(10)) {\n          const node = this.startNodeAt(startLoc);\n          node.callee = base;\n          node.arguments = this.parseCallExpressionArguments();\n          this.tsCheckForInvalidTypeCasts(node.arguments);\n          node.typeParameters = typeArguments;\n          if (state.optionalChainMember) {\n            node.optional = isOptionalCall;\n          }\n          return this.finishCallExpression(node, state.optionalChainMember);\n        }\n        const tokenType = this.state.type;\n        if (tokenType === 48 || tokenType === 52 || tokenType !== 10 && tokenCanStartExpression(tokenType) && !this.hasPrecedingLineBreak()) {\n          return;\n        }\n        const node = this.startNodeAt(startLoc);\n        node.expression = base;\n        node.typeParameters = typeArguments;\n        return this.finishNode(node, \"TSInstantiationExpression\");\n      });\n      if (missingParenErrorLoc) {\n        this.unexpected(missingParenErrorLoc, 10);\n      }\n      if (result) {\n        if (result.type === \"TSInstantiationExpression\") {\n          if (this.match(16) || this.match(18) && this.lookaheadCharCode() !== 40) {\n            this.raise(TSErrors.InvalidPropertyAccessAfterInstantiationExpression, this.state.startLoc);\n          }\n          if (!this.match(16) && !this.match(18)) {\n            result.expression = super.stopParseSubscript(base, state);\n          }\n        }\n        return result;\n      }\n    }\n    return super.parseSubscript(base, startLoc, noCalls, state);\n  }\n  parseNewCallee(node) {\n    var _callee$extra;\n    super.parseNewCallee(node);\n    const {\n      callee\n    } = node;\n    if (callee.type === \"TSInstantiationExpression\" && !((_callee$extra = callee.extra) != null && _callee$extra.parenthesized)) {\n      node.typeParameters = callee.typeParameters;\n      node.callee = callee.expression;\n    }\n  }\n  parseExprOp(left, leftStartLoc, minPrec) {\n    let isSatisfies;\n    if (tokenOperatorPrecedence(58) > minPrec && !this.hasPrecedingLineBreak() && (this.isContextual(93) || (isSatisfies = this.isContextual(120)))) {\n      const node = this.startNodeAt(leftStartLoc);\n      node.expression = left;\n      node.typeAnnotation = this.tsInType(() => {\n        this.next();\n        if (this.match(75)) {\n          if (isSatisfies) {\n            this.raise(Errors.UnexpectedKeyword, this.state.startLoc, {\n              keyword: \"const\"\n            });\n          }\n          return this.tsParseTypeReference();\n        }\n        return this.tsParseType();\n      });\n      this.finishNode(node, isSatisfies ? \"TSSatisfiesExpression\" : \"TSAsExpression\");\n      this.reScan_lt_gt();\n      return this.parseExprOp(node, leftStartLoc, minPrec);\n    }\n    return super.parseExprOp(left, leftStartLoc, minPrec);\n  }\n  checkReservedWord(word, startLoc, checkKeywords, isBinding) {\n    if (!this.state.isAmbientContext) {\n      super.checkReservedWord(word, startLoc, checkKeywords, isBinding);\n    }\n  }\n  checkImportReflection(node) {\n    super.checkImportReflection(node);\n    if (node.module && node.importKind !== \"value\") {\n      this.raise(TSErrors.ImportReflectionHasImportType, node.specifiers[0].loc.start);\n    }\n  }\n  checkDuplicateExports() {}\n  isPotentialImportPhase(isExport) {\n    if (super.isPotentialImportPhase(isExport)) return true;\n    if (this.isContextual(130)) {\n      const ch = this.lookaheadCharCode();\n      return isExport ? ch === 123 || ch === 42 : ch !== 61;\n    }\n    return !isExport && this.isContextual(87);\n  }\n  applyImportPhase(node, isExport, phase, loc) {\n    super.applyImportPhase(node, isExport, phase, loc);\n    if (isExport) {\n      node.exportKind = phase === \"type\" ? \"type\" : \"value\";\n    } else {\n      node.importKind = phase === \"type\" || phase === \"typeof\" ? phase : \"value\";\n    }\n  }\n  parseImport(node) {\n    if (this.match(134)) {\n      node.importKind = \"value\";\n      return super.parseImport(node);\n    }\n    let importNode;\n    if (tokenIsIdentifier(this.state.type) && this.lookaheadCharCode() === 61) {\n      node.importKind = \"value\";\n      return this.tsParseImportEqualsDeclaration(node);\n    } else if (this.isContextual(130)) {\n      const maybeDefaultIdentifier = this.parseMaybeImportPhase(node, false);\n      if (this.lookaheadCharCode() === 61) {\n        return this.tsParseImportEqualsDeclaration(node, maybeDefaultIdentifier);\n      } else {\n        importNode = super.parseImportSpecifiersAndAfter(node, maybeDefaultIdentifier);\n      }\n    } else {\n      importNode = super.parseImport(node);\n    }\n    if (importNode.importKind === \"type\" && importNode.specifiers.length > 1 && importNode.specifiers[0].type === \"ImportDefaultSpecifier\") {\n      this.raise(TSErrors.TypeImportCannotSpecifyDefaultAndNamed, importNode);\n    }\n    return importNode;\n  }\n  parseExport(node, decorators) {\n    if (this.match(83)) {\n      const nodeImportEquals = node;\n      this.next();\n      let maybeDefaultIdentifier = null;\n      if (this.isContextual(130) && this.isPotentialImportPhase(false)) {\n        maybeDefaultIdentifier = this.parseMaybeImportPhase(nodeImportEquals, false);\n      } else {\n        nodeImportEquals.importKind = \"value\";\n      }\n      const declaration = this.tsParseImportEqualsDeclaration(nodeImportEquals, maybeDefaultIdentifier, true);\n      return declaration;\n    } else if (this.eat(29)) {\n      const assign = node;\n      assign.expression = super.parseExpression();\n      this.semicolon();\n      this.sawUnambiguousESM = true;\n      return this.finishNode(assign, \"TSExportAssignment\");\n    } else if (this.eatContextual(93)) {\n      const decl = node;\n      this.expectContextual(128);\n      decl.id = this.parseIdentifier();\n      this.semicolon();\n      return this.finishNode(decl, \"TSNamespaceExportDeclaration\");\n    } else {\n      return super.parseExport(node, decorators);\n    }\n  }\n  isAbstractClass() {\n    return this.isContextual(124) && this.isLookaheadContextual(\"class\");\n  }\n  parseExportDefaultExpression() {\n    if (this.isAbstractClass()) {\n      const cls = this.startNode();\n      this.next();\n      cls.abstract = true;\n      return this.parseClass(cls, true, true);\n    }\n    if (this.match(129)) {\n      const result = this.tsParseInterfaceDeclaration(this.startNode());\n      if (result) return result;\n    }\n    return super.parseExportDefaultExpression();\n  }\n  parseVarStatement(node, kind, allowMissingInitializer = false) {\n    const {\n      isAmbientContext\n    } = this.state;\n    const declaration = super.parseVarStatement(node, kind, allowMissingInitializer || isAmbientContext);\n    if (!isAmbientContext) return declaration;\n    if (!node.declare && (kind === \"using\" || kind === \"await using\")) {\n      this.raiseOverwrite(TSErrors.UsingDeclarationInAmbientContext, node, kind);\n      return declaration;\n    }\n    for (const {\n      id,\n      init\n    } of declaration.declarations) {\n      if (!init) continue;\n      if (kind === \"var\" || kind === \"let\" || !!id.typeAnnotation) {\n        this.raise(TSErrors.InitializerNotAllowedInAmbientContext, init);\n      } else if (!isValidAmbientConstInitializer(init, this.hasPlugin(\"estree\"))) {\n        this.raise(TSErrors.ConstInitializerMustBeStringOrNumericLiteralOrLiteralEnumReference, init);\n      }\n    }\n    return declaration;\n  }\n  parseStatementContent(flags, decorators) {\n    if (!this.state.containsEsc) {\n      switch (this.state.type) {\n        case 75:\n          {\n            if (this.isLookaheadContextual(\"enum\")) {\n              const node = this.startNode();\n              this.expect(75);\n              return this.tsParseEnumDeclaration(node, {\n                const: true\n              });\n            }\n            break;\n          }\n        case 124:\n        case 125:\n          {\n            if (this.nextTokenIsIdentifierAndNotTSRelationalOperatorOnSameLine()) {\n              const token = this.state.type;\n              const node = this.startNode();\n              this.next();\n              const declaration = token === 125 ? this.tsTryParseDeclare(node) : this.tsParseAbstractDeclaration(node, decorators);\n              if (declaration) {\n                if (token === 125) {\n                  declaration.declare = true;\n                }\n                return declaration;\n              } else {\n                node.expression = this.createIdentifier(this.startNodeAt(node.loc.start), token === 125 ? \"declare\" : \"abstract\");\n                this.semicolon(false);\n                return this.finishNode(node, \"ExpressionStatement\");\n              }\n            }\n            break;\n          }\n        case 126:\n          return this.tsParseEnumDeclaration(this.startNode());\n        case 112:\n          {\n            const nextCh = this.lookaheadCharCode();\n            if (nextCh === 123) {\n              const node = this.startNode();\n              return this.tsParseAmbientExternalModuleDeclaration(node);\n            }\n            break;\n          }\n        case 129:\n          {\n            const result = this.tsParseInterfaceDeclaration(this.startNode());\n            if (result) return result;\n            break;\n          }\n        case 127:\n          {\n            if (this.nextTokenIsIdentifierOrStringLiteralOnSameLine()) {\n              const node = this.startNode();\n              this.next();\n              return this.tsParseDeclaration(node, 127, false, decorators);\n            }\n            break;\n          }\n        case 128:\n          {\n            if (this.nextTokenIsIdentifierOnSameLine()) {\n              const node = this.startNode();\n              this.next();\n              return this.tsParseDeclaration(node, 128, false, decorators);\n            }\n            break;\n          }\n        case 130:\n          {\n            if (this.nextTokenIsIdentifierOnSameLine()) {\n              const node = this.startNode();\n              this.next();\n              return this.tsParseTypeAliasDeclaration(node);\n            }\n            break;\n          }\n      }\n    }\n    return super.parseStatementContent(flags, decorators);\n  }\n  parseAccessModifier() {\n    return this.tsParseModifier([\"public\", \"protected\", \"private\"]);\n  }\n  tsHasSomeModifiers(member, modifiers) {\n    return modifiers.some(modifier => {\n      if (tsIsAccessModifier(modifier)) {\n        return member.accessibility === modifier;\n      }\n      return !!member[modifier];\n    });\n  }\n  tsIsStartOfStaticBlocks() {\n    return this.isContextual(106) && this.lookaheadCharCode() === 123;\n  }\n  parseClassMember(classBody, member, state) {\n    const modifiers = [\"declare\", \"private\", \"public\", \"protected\", \"override\", \"abstract\", \"readonly\", \"static\"];\n    this.tsParseModifiers({\n      allowedModifiers: modifiers,\n      disallowedModifiers: [\"in\", \"out\"],\n      stopOnStartOfClassStaticBlock: true,\n      errorTemplate: TSErrors.InvalidModifierOnTypeParameterPositions\n    }, member);\n    const callParseClassMemberWithIsStatic = () => {\n      if (this.tsIsStartOfStaticBlocks()) {\n        this.next();\n        this.next();\n        if (this.tsHasSomeModifiers(member, modifiers)) {\n          this.raise(TSErrors.StaticBlockCannotHaveModifier, this.state.curPosition());\n        }\n        super.parseClassStaticBlock(classBody, member);\n      } else {\n        this.parseClassMemberWithIsStatic(classBody, member, state, !!member.static);\n      }\n    };\n    if (member.declare) {\n      this.tsInAmbientContext(callParseClassMemberWithIsStatic);\n    } else {\n      callParseClassMemberWithIsStatic();\n    }\n  }\n  parseClassMemberWithIsStatic(classBody, member, state, isStatic) {\n    const idx = this.tsTryParseIndexSignature(member);\n    if (idx) {\n      classBody.body.push(idx);\n      if (member.abstract) {\n        this.raise(TSErrors.IndexSignatureHasAbstract, member);\n      }\n      if (member.accessibility) {\n        this.raise(TSErrors.IndexSignatureHasAccessibility, member, {\n          modifier: member.accessibility\n        });\n      }\n      if (member.declare) {\n        this.raise(TSErrors.IndexSignatureHasDeclare, member);\n      }\n      if (member.override) {\n        this.raise(TSErrors.IndexSignatureHasOverride, member);\n      }\n      return;\n    }\n    if (!this.state.inAbstractClass && member.abstract) {\n      this.raise(TSErrors.NonAbstractClassHasAbstractMethod, member);\n    }\n    if (member.override) {\n      if (!state.hadSuperClass) {\n        this.raise(TSErrors.OverrideNotInSubClass, member);\n      }\n    }\n    super.parseClassMemberWithIsStatic(classBody, member, state, isStatic);\n  }\n  parsePostMemberNameModifiers(methodOrProp) {\n    const optional = this.eat(17);\n    if (optional) methodOrProp.optional = true;\n    if (methodOrProp.readonly && this.match(10)) {\n      this.raise(TSErrors.ClassMethodHasReadonly, methodOrProp);\n    }\n    if (methodOrProp.declare && this.match(10)) {\n      this.raise(TSErrors.ClassMethodHasDeclare, methodOrProp);\n    }\n  }\n  shouldParseExportDeclaration() {\n    if (this.tsIsDeclarationStart()) return true;\n    return super.shouldParseExportDeclaration();\n  }\n  parseConditional(expr, startLoc, refExpressionErrors) {\n    if (!this.match(17)) return expr;\n    if (this.state.maybeInArrowParameters) {\n      const nextCh = this.lookaheadCharCode();\n      if (nextCh === 44 || nextCh === 61 || nextCh === 58 || nextCh === 41) {\n        this.setOptionalParametersError(refExpressionErrors);\n        return expr;\n      }\n    }\n    return super.parseConditional(expr, startLoc, refExpressionErrors);\n  }\n  parseParenItem(node, startLoc) {\n    const newNode = super.parseParenItem(node, startLoc);\n    if (this.eat(17)) {\n      newNode.optional = true;\n      this.resetEndLocation(node);\n    }\n    if (this.match(14)) {\n      const typeCastNode = this.startNodeAt(startLoc);\n      typeCastNode.expression = node;\n      typeCastNode.typeAnnotation = this.tsParseTypeAnnotation();\n      return this.finishNode(typeCastNode, \"TSTypeCastExpression\");\n    }\n    return node;\n  }\n  parseExportDeclaration(node) {\n    if (!this.state.isAmbientContext && this.isContextual(125)) {\n      return this.tsInAmbientContext(() => this.parseExportDeclaration(node));\n    }\n    const startLoc = this.state.startLoc;\n    const isDeclare = this.eatContextual(125);\n    if (isDeclare && (this.isContextual(125) || !this.shouldParseExportDeclaration())) {\n      throw this.raise(TSErrors.ExpectedAmbientAfterExportDeclare, this.state.startLoc);\n    }\n    const isIdentifier = tokenIsIdentifier(this.state.type);\n    const declaration = isIdentifier && this.tsTryParseExportDeclaration() || super.parseExportDeclaration(node);\n    if (!declaration) return null;\n    if (declaration.type === \"TSInterfaceDeclaration\" || declaration.type === \"TSTypeAliasDeclaration\" || isDeclare) {\n      node.exportKind = \"type\";\n    }\n    if (isDeclare && declaration.type !== \"TSImportEqualsDeclaration\") {\n      this.resetStartLocation(declaration, startLoc);\n      declaration.declare = true;\n    }\n    return declaration;\n  }\n  parseClassId(node, isStatement, optionalId, bindingType) {\n    if ((!isStatement || optionalId) && this.isContextual(113)) {\n      return;\n    }\n    super.parseClassId(node, isStatement, optionalId, node.declare ? 1024 : 8331);\n    const typeParameters = this.tsTryParseTypeParameters(this.tsParseInOutConstModifiers);\n    if (typeParameters) node.typeParameters = typeParameters;\n  }\n  parseClassPropertyAnnotation(node) {\n    if (!node.optional) {\n      if (this.eat(35)) {\n        node.definite = true;\n      } else if (this.eat(17)) {\n        node.optional = true;\n      }\n    }\n    const type = this.tsTryParseTypeAnnotation();\n    if (type) node.typeAnnotation = type;\n  }\n  parseClassProperty(node) {\n    this.parseClassPropertyAnnotation(node);\n    if (this.state.isAmbientContext && !(node.readonly && !node.typeAnnotation) && this.match(29)) {\n      this.raise(TSErrors.DeclareClassFieldHasInitializer, this.state.startLoc);\n    }\n    if (node.abstract && this.match(29)) {\n      const {\n        key\n      } = node;\n      this.raise(TSErrors.AbstractPropertyHasInitializer, this.state.startLoc, {\n        propertyName: key.type === \"Identifier\" && !node.computed ? key.name : `[${this.input.slice(this.offsetToSourcePos(key.start), this.offsetToSourcePos(key.end))}]`\n      });\n    }\n    return super.parseClassProperty(node);\n  }\n  parseClassPrivateProperty(node) {\n    if (node.abstract) {\n      this.raise(TSErrors.PrivateElementHasAbstract, node);\n    }\n    if (node.accessibility) {\n      this.raise(TSErrors.PrivateElementHasAccessibility, node, {\n        modifier: node.accessibility\n      });\n    }\n    this.parseClassPropertyAnnotation(node);\n    return super.parseClassPrivateProperty(node);\n  }\n  parseClassAccessorProperty(node) {\n    this.parseClassPropertyAnnotation(node);\n    if (node.optional) {\n      this.raise(TSErrors.AccessorCannotBeOptional, node);\n    }\n    return super.parseClassAccessorProperty(node);\n  }\n  pushClassMethod(classBody, method, isGenerator, isAsync, isConstructor, allowsDirectSuper) {\n    const typeParameters = this.tsTryParseTypeParameters(this.tsParseConstModifier);\n    if (typeParameters && isConstructor) {\n      this.raise(TSErrors.ConstructorHasTypeParameters, typeParameters);\n    }\n    const {\n      declare = false,\n      kind\n    } = method;\n    if (declare && (kind === \"get\" || kind === \"set\")) {\n      this.raise(TSErrors.DeclareAccessor, method, {\n        kind\n      });\n    }\n    if (typeParameters) method.typeParameters = typeParameters;\n    super.pushClassMethod(classBody, method, isGenerator, isAsync, isConstructor, allowsDirectSuper);\n  }\n  pushClassPrivateMethod(classBody, method, isGenerator, isAsync) {\n    const typeParameters = this.tsTryParseTypeParameters(this.tsParseConstModifier);\n    if (typeParameters) method.typeParameters = typeParameters;\n    super.pushClassPrivateMethod(classBody, method, isGenerator, isAsync);\n  }\n  declareClassPrivateMethodInScope(node, kind) {\n    if (node.type === \"TSDeclareMethod\") return;\n    if (node.type === \"MethodDefinition\" && node.value.body == null) {\n      return;\n    }\n    super.declareClassPrivateMethodInScope(node, kind);\n  }\n  parseClassSuper(node) {\n    super.parseClassSuper(node);\n    if (node.superClass && (this.match(47) || this.match(51))) {\n      node.superTypeParameters = this.tsParseTypeArgumentsInExpression();\n    }\n    if (this.eatContextual(113)) {\n      node.implements = this.tsParseHeritageClause(\"implements\");\n    }\n  }\n  parseObjPropValue(prop, startLoc, isGenerator, isAsync, isPattern, isAccessor, refExpressionErrors) {\n    const typeParameters = this.tsTryParseTypeParameters(this.tsParseConstModifier);\n    if (typeParameters) prop.typeParameters = typeParameters;\n    return super.parseObjPropValue(prop, startLoc, isGenerator, isAsync, isPattern, isAccessor, refExpressionErrors);\n  }\n  parseFunctionParams(node, isConstructor) {\n    const typeParameters = this.tsTryParseTypeParameters(this.tsParseConstModifier);\n    if (typeParameters) node.typeParameters = typeParameters;\n    super.parseFunctionParams(node, isConstructor);\n  }\n  parseVarId(decl, kind) {\n    super.parseVarId(decl, kind);\n    if (decl.id.type === \"Identifier\" && !this.hasPrecedingLineBreak() && this.eat(35)) {\n      decl.definite = true;\n    }\n    const type = this.tsTryParseTypeAnnotation();\n    if (type) {\n      decl.id.typeAnnotation = type;\n      this.resetEndLocation(decl.id);\n    }\n  }\n  parseAsyncArrowFromCallExpression(node, call) {\n    if (this.match(14)) {\n      node.returnType = this.tsParseTypeAnnotation();\n    }\n    return super.parseAsyncArrowFromCallExpression(node, call);\n  }\n  parseMaybeAssign(refExpressionErrors, afterLeftParse) {\n    var _jsx, _jsx2, _typeCast, _jsx3, _typeCast2;\n    let state;\n    let jsx;\n    let typeCast;\n    if (this.hasPlugin(\"jsx\") && (this.match(143) || this.match(47))) {\n      state = this.state.clone();\n      jsx = this.tryParse(() => super.parseMaybeAssign(refExpressionErrors, afterLeftParse), state);\n      if (!jsx.error) return jsx.node;\n      const {\n        context\n      } = this.state;\n      const currentContext = context[context.length - 1];\n      if (currentContext === types.j_oTag || currentContext === types.j_expr) {\n        context.pop();\n      }\n    }\n    if (!((_jsx = jsx) != null && _jsx.error) && !this.match(47)) {\n      return super.parseMaybeAssign(refExpressionErrors, afterLeftParse);\n    }\n    if (!state || state === this.state) state = this.state.clone();\n    let typeParameters;\n    const arrow = this.tryParse(abort => {\n      var _expr$extra, _typeParameters;\n      typeParameters = this.tsParseTypeParameters(this.tsParseConstModifier);\n      const expr = super.parseMaybeAssign(refExpressionErrors, afterLeftParse);\n      if (expr.type !== \"ArrowFunctionExpression\" || (_expr$extra = expr.extra) != null && _expr$extra.parenthesized) {\n        abort();\n      }\n      if (((_typeParameters = typeParameters) == null ? void 0 : _typeParameters.params.length) !== 0) {\n        this.resetStartLocationFromNode(expr, typeParameters);\n      }\n      expr.typeParameters = typeParameters;\n      return expr;\n    }, state);\n    if (!arrow.error && !arrow.aborted) {\n      if (typeParameters) this.reportReservedArrowTypeParam(typeParameters);\n      return arrow.node;\n    }\n    if (!jsx) {\n      assert(!this.hasPlugin(\"jsx\"));\n      typeCast = this.tryParse(() => super.parseMaybeAssign(refExpressionErrors, afterLeftParse), state);\n      if (!typeCast.error) return typeCast.node;\n    }\n    if ((_jsx2 = jsx) != null && _jsx2.node) {\n      this.state = jsx.failState;\n      return jsx.node;\n    }\n    if (arrow.node) {\n      this.state = arrow.failState;\n      if (typeParameters) this.reportReservedArrowTypeParam(typeParameters);\n      return arrow.node;\n    }\n    if ((_typeCast = typeCast) != null && _typeCast.node) {\n      this.state = typeCast.failState;\n      return typeCast.node;\n    }\n    throw ((_jsx3 = jsx) == null ? void 0 : _jsx3.error) || arrow.error || ((_typeCast2 = typeCast) == null ? void 0 : _typeCast2.error);\n  }\n  reportReservedArrowTypeParam(node) {\n    var _node$extra2;\n    if (node.params.length === 1 && !node.params[0].constraint && !((_node$extra2 = node.extra) != null && _node$extra2.trailingComma) && this.getPluginOption(\"typescript\", \"disallowAmbiguousJSXLike\")) {\n      this.raise(TSErrors.ReservedArrowTypeParam, node);\n    }\n  }\n  parseMaybeUnary(refExpressionErrors, sawUnary) {\n    if (!this.hasPlugin(\"jsx\") && this.match(47)) {\n      return this.tsParseTypeAssertion();\n    }\n    return super.parseMaybeUnary(refExpressionErrors, sawUnary);\n  }\n  parseArrow(node) {\n    if (this.match(14)) {\n      const result = this.tryParse(abort => {\n        const returnType = this.tsParseTypeOrTypePredicateAnnotation(14);\n        if (this.canInsertSemicolon() || !this.match(19)) abort();\n        return returnType;\n      });\n      if (result.aborted) return;\n      if (!result.thrown) {\n        if (result.error) this.state = result.failState;\n        node.returnType = result.node;\n      }\n    }\n    return super.parseArrow(node);\n  }\n  parseFunctionParamType(param) {\n    if (this.eat(17)) {\n      param.optional = true;\n    }\n    const type = this.tsTryParseTypeAnnotation();\n    if (type) param.typeAnnotation = type;\n    this.resetEndLocation(param);\n    return param;\n  }\n  isAssignable(node, isBinding) {\n    switch (node.type) {\n      case \"TSTypeCastExpression\":\n        return this.isAssignable(node.expression, isBinding);\n      case \"TSParameterProperty\":\n        return true;\n      default:\n        return super.isAssignable(node, isBinding);\n    }\n  }\n  toAssignable(node, isLHS = false) {\n    switch (node.type) {\n      case \"ParenthesizedExpression\":\n        this.toAssignableParenthesizedExpression(node, isLHS);\n        break;\n      case \"TSAsExpression\":\n      case \"TSSatisfiesExpression\":\n      case \"TSNonNullExpression\":\n      case \"TSTypeAssertion\":\n        if (isLHS) {\n          this.expressionScope.recordArrowParameterBindingError(TSErrors.UnexpectedTypeCastInParameter, node);\n        } else {\n          this.raise(TSErrors.UnexpectedTypeCastInParameter, node);\n        }\n        this.toAssignable(node.expression, isLHS);\n        break;\n      case \"AssignmentExpression\":\n        if (!isLHS && node.left.type === \"TSTypeCastExpression\") {\n          node.left = this.typeCastToParameter(node.left);\n        }\n      default:\n        super.toAssignable(node, isLHS);\n    }\n  }\n  toAssignableParenthesizedExpression(node, isLHS) {\n    switch (node.expression.type) {\n      case \"TSAsExpression\":\n      case \"TSSatisfiesExpression\":\n      case \"TSNonNullExpression\":\n      case \"TSTypeAssertion\":\n      case \"ParenthesizedExpression\":\n        this.toAssignable(node.expression, isLHS);\n        break;\n      default:\n        super.toAssignable(node, isLHS);\n    }\n  }\n  checkToRestConversion(node, allowPattern) {\n    switch (node.type) {\n      case \"TSAsExpression\":\n      case \"TSSatisfiesExpression\":\n      case \"TSTypeAssertion\":\n      case \"TSNonNullExpression\":\n        this.checkToRestConversion(node.expression, false);\n        break;\n      default:\n        super.checkToRestConversion(node, allowPattern);\n    }\n  }\n  isValidLVal(type, disallowCallExpression, isUnparenthesizedInAssign, binding) {\n    switch (type) {\n      case \"TSTypeCastExpression\":\n        return true;\n      case \"TSParameterProperty\":\n        return \"parameter\";\n      case \"TSNonNullExpression\":\n        return \"expression\";\n      case \"TSAsExpression\":\n      case \"TSSatisfiesExpression\":\n      case \"TSTypeAssertion\":\n        return (binding !== 64 || !isUnparenthesizedInAssign) && [\"expression\", true];\n      default:\n        return super.isValidLVal(type, disallowCallExpression, isUnparenthesizedInAssign, binding);\n    }\n  }\n  parseBindingAtom() {\n    if (this.state.type === 78) {\n      return this.parseIdentifier(true);\n    }\n    return super.parseBindingAtom();\n  }\n  parseMaybeDecoratorArguments(expr, startLoc) {\n    if (this.match(47) || this.match(51)) {\n      const typeArguments = this.tsParseTypeArgumentsInExpression();\n      if (this.match(10)) {\n        const call = super.parseMaybeDecoratorArguments(expr, startLoc);\n        call.typeParameters = typeArguments;\n        return call;\n      }\n      this.unexpected(null, 10);\n    }\n    return super.parseMaybeDecoratorArguments(expr, startLoc);\n  }\n  checkCommaAfterRest(close) {\n    if (this.state.isAmbientContext && this.match(12) && this.lookaheadCharCode() === close) {\n      this.next();\n      return false;\n    }\n    return super.checkCommaAfterRest(close);\n  }\n  isClassMethod() {\n    return this.match(47) || super.isClassMethod();\n  }\n  isClassProperty() {\n    return this.match(35) || this.match(14) || super.isClassProperty();\n  }\n  parseMaybeDefault(startLoc, left) {\n    const node = super.parseMaybeDefault(startLoc, left);\n    if (node.type === \"AssignmentPattern\" && node.typeAnnotation && node.right.start < node.typeAnnotation.start) {\n      this.raise(TSErrors.TypeAnnotationAfterAssign, node.typeAnnotation);\n    }\n    return node;\n  }\n  getTokenFromCode(code) {\n    if (this.state.inType) {\n      if (code === 62) {\n        this.finishOp(48, 1);\n        return;\n      }\n      if (code === 60) {\n        this.finishOp(47, 1);\n        return;\n      }\n    }\n    super.getTokenFromCode(code);\n  }\n  reScan_lt_gt() {\n    const {\n      type\n    } = this.state;\n    if (type === 47) {\n      this.state.pos -= 1;\n      this.readToken_lt();\n    } else if (type === 48) {\n      this.state.pos -= 1;\n      this.readToken_gt();\n    }\n  }\n  reScan_lt() {\n    const {\n      type\n    } = this.state;\n    if (type === 51) {\n      this.state.pos -= 2;\n      this.finishOp(47, 1);\n      return 47;\n    }\n    return type;\n  }\n  toAssignableListItem(exprList, index, isLHS) {\n    const node = exprList[index];\n    if (node.type === \"TSTypeCastExpression\") {\n      exprList[index] = this.typeCastToParameter(node);\n    }\n    super.toAssignableListItem(exprList, index, isLHS);\n  }\n  typeCastToParameter(node) {\n    node.expression.typeAnnotation = node.typeAnnotation;\n    this.resetEndLocation(node.expression, node.typeAnnotation.loc.end);\n    return node.expression;\n  }\n  shouldParseArrow(params) {\n    if (this.match(14)) {\n      return params.every(expr => this.isAssignable(expr, true));\n    }\n    return super.shouldParseArrow(params);\n  }\n  shouldParseAsyncArrow() {\n    return this.match(14) || super.shouldParseAsyncArrow();\n  }\n  canHaveLeadingDecorator() {\n    return super.canHaveLeadingDecorator() || this.isAbstractClass();\n  }\n  jsxParseOpeningElementAfterName(node) {\n    if (this.match(47) || this.match(51)) {\n      const typeArguments = this.tsTryParseAndCatch(() => this.tsParseTypeArgumentsInExpression());\n      if (typeArguments) {\n        node.typeParameters = typeArguments;\n      }\n    }\n    return super.jsxParseOpeningElementAfterName(node);\n  }\n  getGetterSetterExpectedParamCount(method) {\n    const baseCount = super.getGetterSetterExpectedParamCount(method);\n    const params = this.getObjectOrClassMethodParams(method);\n    const firstParam = params[0];\n    const hasContextParam = firstParam && this.isThisParam(firstParam);\n    return hasContextParam ? baseCount + 1 : baseCount;\n  }\n  parseCatchClauseParam() {\n    const param = super.parseCatchClauseParam();\n    const type = this.tsTryParseTypeAnnotation();\n    if (type) {\n      param.typeAnnotation = type;\n      this.resetEndLocation(param);\n    }\n    return param;\n  }\n  tsInAmbientContext(cb) {\n    const {\n      isAmbientContext: oldIsAmbientContext,\n      strict: oldStrict\n    } = this.state;\n    this.state.isAmbientContext = true;\n    this.state.strict = false;\n    try {\n      return cb();\n    } finally {\n      this.state.isAmbientContext = oldIsAmbientContext;\n      this.state.strict = oldStrict;\n    }\n  }\n  parseClass(node, isStatement, optionalId) {\n    const oldInAbstractClass = this.state.inAbstractClass;\n    this.state.inAbstractClass = !!node.abstract;\n    try {\n      return super.parseClass(node, isStatement, optionalId);\n    } finally {\n      this.state.inAbstractClass = oldInAbstractClass;\n    }\n  }\n  tsParseAbstractDeclaration(node, decorators) {\n    if (this.match(80)) {\n      node.abstract = true;\n      return this.maybeTakeDecorators(decorators, this.parseClass(node, true, false));\n    } else if (this.isContextual(129)) {\n      if (!this.hasFollowingLineBreak()) {\n        node.abstract = true;\n        this.raise(TSErrors.NonClassMethodPropertyHasAbstractModifier, node);\n        return this.tsParseInterfaceDeclaration(node);\n      } else {\n        return null;\n      }\n    }\n    throw this.unexpected(null, 80);\n  }\n  parseMethod(node, isGenerator, isAsync, isConstructor, allowDirectSuper, type, inClassScope) {\n    const method = super.parseMethod(node, isGenerator, isAsync, isConstructor, allowDirectSuper, type, inClassScope);\n    if (method.abstract || method.type === \"TSAbstractMethodDefinition\") {\n      const hasEstreePlugin = this.hasPlugin(\"estree\");\n      const methodFn = hasEstreePlugin ? method.value : method;\n      if (methodFn.body) {\n        const {\n          key\n        } = method;\n        this.raise(TSErrors.AbstractMethodHasImplementation, method, {\n          methodName: key.type === \"Identifier\" && !method.computed ? key.name : `[${this.input.slice(this.offsetToSourcePos(key.start), this.offsetToSourcePos(key.end))}]`\n        });\n      }\n    }\n    return method;\n  }\n  tsParseTypeParameterName() {\n    const typeName = this.parseIdentifier();\n    return typeName.name;\n  }\n  shouldParseAsAmbientContext() {\n    return !!this.getPluginOption(\"typescript\", \"dts\");\n  }\n  parse() {\n    if (this.shouldParseAsAmbientContext()) {\n      this.state.isAmbientContext = true;\n    }\n    return super.parse();\n  }\n  getExpression() {\n    if (this.shouldParseAsAmbientContext()) {\n      this.state.isAmbientContext = true;\n    }\n    return super.getExpression();\n  }\n  parseExportSpecifier(node, isString, isInTypeExport, isMaybeTypeOnly) {\n    if (!isString && isMaybeTypeOnly) {\n      this.parseTypeOnlyImportExportSpecifier(node, false, isInTypeExport);\n      return this.finishNode(node, \"ExportSpecifier\");\n    }\n    node.exportKind = \"value\";\n    return super.parseExportSpecifier(node, isString, isInTypeExport, isMaybeTypeOnly);\n  }\n  parseImportSpecifier(specifier, importedIsString, isInTypeOnlyImport, isMaybeTypeOnly, bindingType) {\n    if (!importedIsString && isMaybeTypeOnly) {\n      this.parseTypeOnlyImportExportSpecifier(specifier, true, isInTypeOnlyImport);\n      return this.finishNode(specifier, \"ImportSpecifier\");\n    }\n    specifier.importKind = \"value\";\n    return super.parseImportSpecifier(specifier, importedIsString, isInTypeOnlyImport, isMaybeTypeOnly, isInTypeOnlyImport ? 4098 : 4096);\n  }\n  parseTypeOnlyImportExportSpecifier(node, isImport, isInTypeOnlyImportExport) {\n    const leftOfAsKey = isImport ? \"imported\" : \"local\";\n    const rightOfAsKey = isImport ? \"local\" : \"exported\";\n    let leftOfAs = node[leftOfAsKey];\n    let rightOfAs;\n    let hasTypeSpecifier = false;\n    let canParseAsKeyword = true;\n    const loc = leftOfAs.loc.start;\n    if (this.isContextual(93)) {\n      const firstAs = this.parseIdentifier();\n      if (this.isContextual(93)) {\n        const secondAs = this.parseIdentifier();\n        if (tokenIsKeywordOrIdentifier(this.state.type)) {\n          hasTypeSpecifier = true;\n          leftOfAs = firstAs;\n          rightOfAs = isImport ? this.parseIdentifier() : this.parseModuleExportName();\n          canParseAsKeyword = false;\n        } else {\n          rightOfAs = secondAs;\n          canParseAsKeyword = false;\n        }\n      } else if (tokenIsKeywordOrIdentifier(this.state.type)) {\n        canParseAsKeyword = false;\n        rightOfAs = isImport ? this.parseIdentifier() : this.parseModuleExportName();\n      } else {\n        hasTypeSpecifier = true;\n        leftOfAs = firstAs;\n      }\n    } else if (tokenIsKeywordOrIdentifier(this.state.type)) {\n      hasTypeSpecifier = true;\n      if (isImport) {\n        leftOfAs = this.parseIdentifier(true);\n        if (!this.isContextual(93)) {\n          this.checkReservedWord(leftOfAs.name, leftOfAs.loc.start, true, true);\n        }\n      } else {\n        leftOfAs = this.parseModuleExportName();\n      }\n    }\n    if (hasTypeSpecifier && isInTypeOnlyImportExport) {\n      this.raise(isImport ? TSErrors.TypeModifierIsUsedInTypeImports : TSErrors.TypeModifierIsUsedInTypeExports, loc);\n    }\n    node[leftOfAsKey] = leftOfAs;\n    node[rightOfAsKey] = rightOfAs;\n    const kindKey = isImport ? \"importKind\" : \"exportKind\";\n    node[kindKey] = hasTypeSpecifier ? \"type\" : \"value\";\n    if (canParseAsKeyword && this.eatContextual(93)) {\n      node[rightOfAsKey] = isImport ? this.parseIdentifier() : this.parseModuleExportName();\n    }\n    if (!node[rightOfAsKey]) {\n      node[rightOfAsKey] = this.cloneIdentifier(node[leftOfAsKey]);\n    }\n    if (isImport) {\n      this.checkIdentifier(node[rightOfAsKey], hasTypeSpecifier ? 4098 : 4096);\n    }\n  }\n  fillOptionalPropertiesForTSESLint(node) {\n    var _node$directive, _node$decorators, _node$optional, _node$typeAnnotation, _node$accessibility, _node$decorators2, _node$override, _node$readonly, _node$static, _node$declare, _node$returnType, _node$typeParameters, _node$optional2, _node$optional3, _node$accessibility2, _node$readonly2, _node$static2, _node$declare2, _node$definite, _node$readonly3, _node$typeAnnotation2, _node$accessibility3, _node$decorators3, _node$override2, _node$optional4, _node$id, _node$abstract, _node$declare3, _node$decorators4, _node$implements, _node$superTypeArgume, _node$typeParameters2, _node$declare4, _node$definite2, _node$const, _node$declare5, _node$computed, _node$qualifier, _node$options, _node$declare6, _node$extends, _node$optional5, _node$readonly4, _node$declare7, _node$global, _node$const2, _node$in, _node$out;\n    switch (node.type) {\n      case \"ExpressionStatement\":\n        (_node$directive = node.directive) != null ? _node$directive : node.directive = undefined;\n        return;\n      case \"RestElement\":\n        node.value = undefined;\n      case \"Identifier\":\n      case \"ArrayPattern\":\n      case \"AssignmentPattern\":\n      case \"ObjectPattern\":\n        (_node$decorators = node.decorators) != null ? _node$decorators : node.decorators = [];\n        (_node$optional = node.optional) != null ? _node$optional : node.optional = false;\n        (_node$typeAnnotation = node.typeAnnotation) != null ? _node$typeAnnotation : node.typeAnnotation = undefined;\n        return;\n      case \"TSParameterProperty\":\n        (_node$accessibility = node.accessibility) != null ? _node$accessibility : node.accessibility = undefined;\n        (_node$decorators2 = node.decorators) != null ? _node$decorators2 : node.decorators = [];\n        (_node$override = node.override) != null ? _node$override : node.override = false;\n        (_node$readonly = node.readonly) != null ? _node$readonly : node.readonly = false;\n        (_node$static = node.static) != null ? _node$static : node.static = false;\n        return;\n      case \"TSEmptyBodyFunctionExpression\":\n        node.body = null;\n      case \"TSDeclareFunction\":\n      case \"FunctionDeclaration\":\n      case \"FunctionExpression\":\n      case \"ClassMethod\":\n      case \"ClassPrivateMethod\":\n        (_node$declare = node.declare) != null ? _node$declare : node.declare = false;\n        (_node$returnType = node.returnType) != null ? _node$returnType : node.returnType = undefined;\n        (_node$typeParameters = node.typeParameters) != null ? _node$typeParameters : node.typeParameters = undefined;\n        return;\n      case \"Property\":\n        (_node$optional2 = node.optional) != null ? _node$optional2 : node.optional = false;\n        return;\n      case \"TSMethodSignature\":\n      case \"TSPropertySignature\":\n        (_node$optional3 = node.optional) != null ? _node$optional3 : node.optional = false;\n      case \"TSIndexSignature\":\n        (_node$accessibility2 = node.accessibility) != null ? _node$accessibility2 : node.accessibility = undefined;\n        (_node$readonly2 = node.readonly) != null ? _node$readonly2 : node.readonly = false;\n        (_node$static2 = node.static) != null ? _node$static2 : node.static = false;\n        return;\n      case \"TSAbstractPropertyDefinition\":\n      case \"PropertyDefinition\":\n      case \"TSAbstractAccessorProperty\":\n      case \"AccessorProperty\":\n        (_node$declare2 = node.declare) != null ? _node$declare2 : node.declare = false;\n        (_node$definite = node.definite) != null ? _node$definite : node.definite = false;\n        (_node$readonly3 = node.readonly) != null ? _node$readonly3 : node.readonly = false;\n        (_node$typeAnnotation2 = node.typeAnnotation) != null ? _node$typeAnnotation2 : node.typeAnnotation = undefined;\n      case \"TSAbstractMethodDefinition\":\n      case \"MethodDefinition\":\n        (_node$accessibility3 = node.accessibility) != null ? _node$accessibility3 : node.accessibility = undefined;\n        (_node$decorators3 = node.decorators) != null ? _node$decorators3 : node.decorators = [];\n        (_node$override2 = node.override) != null ? _node$override2 : node.override = false;\n        (_node$optional4 = node.optional) != null ? _node$optional4 : node.optional = false;\n        return;\n      case \"ClassExpression\":\n        (_node$id = node.id) != null ? _node$id : node.id = null;\n      case \"ClassDeclaration\":\n        (_node$abstract = node.abstract) != null ? _node$abstract : node.abstract = false;\n        (_node$declare3 = node.declare) != null ? _node$declare3 : node.declare = false;\n        (_node$decorators4 = node.decorators) != null ? _node$decorators4 : node.decorators = [];\n        (_node$implements = node.implements) != null ? _node$implements : node.implements = [];\n        (_node$superTypeArgume = node.superTypeArguments) != null ? _node$superTypeArgume : node.superTypeArguments = undefined;\n        (_node$typeParameters2 = node.typeParameters) != null ? _node$typeParameters2 : node.typeParameters = undefined;\n        return;\n      case \"TSTypeAliasDeclaration\":\n      case \"VariableDeclaration\":\n        (_node$declare4 = node.declare) != null ? _node$declare4 : node.declare = false;\n        return;\n      case \"VariableDeclarator\":\n        (_node$definite2 = node.definite) != null ? _node$definite2 : node.definite = false;\n        return;\n      case \"TSEnumDeclaration\":\n        (_node$const = node.const) != null ? _node$const : node.const = false;\n        (_node$declare5 = node.declare) != null ? _node$declare5 : node.declare = false;\n        return;\n      case \"TSEnumMember\":\n        (_node$computed = node.computed) != null ? _node$computed : node.computed = false;\n        return;\n      case \"TSImportType\":\n        (_node$qualifier = node.qualifier) != null ? _node$qualifier : node.qualifier = null;\n        (_node$options = node.options) != null ? _node$options : node.options = null;\n        return;\n      case \"TSInterfaceDeclaration\":\n        (_node$declare6 = node.declare) != null ? _node$declare6 : node.declare = false;\n        (_node$extends = node.extends) != null ? _node$extends : node.extends = [];\n        return;\n      case \"TSMappedType\":\n        (_node$optional5 = node.optional) != null ? _node$optional5 : node.optional = false;\n        (_node$readonly4 = node.readonly) != null ? _node$readonly4 : node.readonly = undefined;\n        return;\n      case \"TSModuleDeclaration\":\n        (_node$declare7 = node.declare) != null ? _node$declare7 : node.declare = false;\n        (_node$global = node.global) != null ? _node$global : node.global = node.kind === \"global\";\n        return;\n      case \"TSTypeParameter\":\n        (_node$const2 = node.const) != null ? _node$const2 : node.const = false;\n        (_node$in = node.in) != null ? _node$in : node.in = false;\n        (_node$out = node.out) != null ? _node$out : node.out = false;\n        return;\n    }\n  }\n  chStartsBindingIdentifierAndNotRelationalOperator(ch, pos) {\n    if (isIdentifierStart(ch)) {\n      keywordAndTSRelationalOperator.lastIndex = pos;\n      if (keywordAndTSRelationalOperator.test(this.input)) {\n        const endCh = this.codePointAtPos(keywordAndTSRelationalOperator.lastIndex);\n        if (!isIdentifierChar(endCh) && endCh !== 92) {\n          return false;\n        }\n      }\n      return true;\n    } else if (ch === 92) {\n      return true;\n    } else {\n      return false;\n    }\n  }\n  nextTokenIsIdentifierAndNotTSRelationalOperatorOnSameLine() {\n    const next = this.nextTokenInLineStart();\n    const nextCh = this.codePointAtPos(next);\n    return this.chStartsBindingIdentifierAndNotRelationalOperator(nextCh, next);\n  }\n  nextTokenIsIdentifierOrStringLiteralOnSameLine() {\n    const next = this.nextTokenInLineStart();\n    const nextCh = this.codePointAtPos(next);\n    return this.chStartsBindingIdentifier(nextCh, next) || nextCh === 34 || nextCh === 39;\n  }\n};\nfunction isPossiblyLiteralEnum(expression) {\n  if (expression.type !== \"MemberExpression\") return false;\n  const {\n    computed,\n    property\n  } = expression;\n  if (computed && property.type !== \"StringLiteral\" && (property.type !== \"TemplateLiteral\" || property.expressions.length > 0)) {\n    return false;\n  }\n  return isUncomputedMemberExpressionChain(expression.object);\n}\nfunction isValidAmbientConstInitializer(expression, estree) {\n  var _expression$extra;\n  const {\n    type\n  } = expression;\n  if ((_expression$extra = expression.extra) != null && _expression$extra.parenthesized) {\n    return false;\n  }\n  if (estree) {\n    if (type === \"Literal\") {\n      const {\n        value\n      } = expression;\n      if (typeof value === \"string\" || typeof value === \"boolean\") {\n        return true;\n      }\n    }\n  } else {\n    if (type === \"StringLiteral\" || type === \"BooleanLiteral\") {\n      return true;\n    }\n  }\n  if (isNumber(expression, estree) || isNegativeNumber(expression, estree)) {\n    return true;\n  }\n  if (type === \"TemplateLiteral\" && expression.expressions.length === 0) {\n    return true;\n  }\n  if (isPossiblyLiteralEnum(expression)) {\n    return true;\n  }\n  return false;\n}\nfunction isNumber(expression, estree) {\n  if (estree) {\n    return expression.type === \"Literal\" && (typeof expression.value === \"number\" || \"bigint\" in expression);\n  }\n  return expression.type === \"NumericLiteral\" || expression.type === \"BigIntLiteral\";\n}\nfunction isNegativeNumber(expression, estree) {\n  if (expression.type === \"UnaryExpression\") {\n    const {\n      operator,\n      argument\n    } = expression;\n    if (operator === \"-\" && isNumber(argument, estree)) {\n      return true;\n    }\n  }\n  return false;\n}\nfunction isUncomputedMemberExpressionChain(expression) {\n  if (expression.type === \"Identifier\") return true;\n  if (expression.type !== \"MemberExpression\" || expression.computed) {\n    return false;\n  }\n  return isUncomputedMemberExpressionChain(expression.object);\n}\nconst PlaceholderErrors = ParseErrorEnum`placeholders`({\n  ClassNameIsRequired: \"A class name is required.\",\n  UnexpectedSpace: \"Unexpected space in placeholder.\"\n});\nvar placeholders = superClass => class PlaceholdersParserMixin extends superClass {\n  parsePlaceholder(expectedNode) {\n    if (this.match(133)) {\n      const node = this.startNode();\n      this.next();\n      this.assertNoSpace();\n      node.name = super.parseIdentifier(true);\n      this.assertNoSpace();\n      this.expect(133);\n      return this.finishPlaceholder(node, expectedNode);\n    }\n  }\n  finishPlaceholder(node, expectedNode) {\n    let placeholder = node;\n    if (!placeholder.expectedNode || !placeholder.type) {\n      placeholder = this.finishNode(placeholder, \"Placeholder\");\n    }\n    placeholder.expectedNode = expectedNode;\n    return placeholder;\n  }\n  getTokenFromCode(code) {\n    if (code === 37 && this.input.charCodeAt(this.state.pos + 1) === 37) {\n      this.finishOp(133, 2);\n    } else {\n      super.getTokenFromCode(code);\n    }\n  }\n  parseExprAtom(refExpressionErrors) {\n    return this.parsePlaceholder(\"Expression\") || super.parseExprAtom(refExpressionErrors);\n  }\n  parseIdentifier(liberal) {\n    return this.parsePlaceholder(\"Identifier\") || super.parseIdentifier(liberal);\n  }\n  checkReservedWord(word, startLoc, checkKeywords, isBinding) {\n    if (word !== undefined) {\n      super.checkReservedWord(word, startLoc, checkKeywords, isBinding);\n    }\n  }\n  cloneIdentifier(node) {\n    const cloned = super.cloneIdentifier(node);\n    if (cloned.type === \"Placeholder\") {\n      cloned.expectedNode = node.expectedNode;\n    }\n    return cloned;\n  }\n  cloneStringLiteral(node) {\n    if (node.type === \"Placeholder\") {\n      return this.cloneIdentifier(node);\n    }\n    return super.cloneStringLiteral(node);\n  }\n  parseBindingAtom() {\n    return this.parsePlaceholder(\"Pattern\") || super.parseBindingAtom();\n  }\n  isValidLVal(type, disallowCallExpression, isParenthesized, binding) {\n    return type === \"Placeholder\" || super.isValidLVal(type, disallowCallExpression, isParenthesized, binding);\n  }\n  toAssignable(node, isLHS) {\n    if (node && node.type === \"Placeholder\" && node.expectedNode === \"Expression\") {\n      node.expectedNode = \"Pattern\";\n    } else {\n      super.toAssignable(node, isLHS);\n    }\n  }\n  chStartsBindingIdentifier(ch, pos) {\n    if (super.chStartsBindingIdentifier(ch, pos)) {\n      return true;\n    }\n    const next = this.nextTokenStart();\n    if (this.input.charCodeAt(next) === 37 && this.input.charCodeAt(next + 1) === 37) {\n      return true;\n    }\n    return false;\n  }\n  verifyBreakContinue(node, isBreak) {\n    var _node$label;\n    if (((_node$label = node.label) == null ? void 0 : _node$label.type) === \"Placeholder\") return;\n    super.verifyBreakContinue(node, isBreak);\n  }\n  parseExpressionStatement(node, expr) {\n    var _expr$extra;\n    if (expr.type !== \"Placeholder\" || (_expr$extra = expr.extra) != null && _expr$extra.parenthesized) {\n      return super.parseExpressionStatement(node, expr);\n    }\n    if (this.match(14)) {\n      const stmt = node;\n      stmt.label = this.finishPlaceholder(expr, \"Identifier\");\n      this.next();\n      stmt.body = super.parseStatementOrSloppyAnnexBFunctionDeclaration();\n      return this.finishNode(stmt, \"LabeledStatement\");\n    }\n    this.semicolon();\n    const stmtPlaceholder = node;\n    stmtPlaceholder.name = expr.name;\n    return this.finishPlaceholder(stmtPlaceholder, \"Statement\");\n  }\n  parseBlock(allowDirectives, createNewLexicalScope, afterBlockParse) {\n    return this.parsePlaceholder(\"BlockStatement\") || super.parseBlock(allowDirectives, createNewLexicalScope, afterBlockParse);\n  }\n  parseFunctionId(requireId) {\n    return this.parsePlaceholder(\"Identifier\") || super.parseFunctionId(requireId);\n  }\n  parseClass(node, isStatement, optionalId) {\n    const type = isStatement ? \"ClassDeclaration\" : \"ClassExpression\";\n    this.next();\n    const oldStrict = this.state.strict;\n    const placeholder = this.parsePlaceholder(\"Identifier\");\n    if (placeholder) {\n      if (this.match(81) || this.match(133) || this.match(5)) {\n        node.id = placeholder;\n      } else if (optionalId || !isStatement) {\n        node.id = null;\n        node.body = this.finishPlaceholder(placeholder, \"ClassBody\");\n        return this.finishNode(node, type);\n      } else {\n        throw this.raise(PlaceholderErrors.ClassNameIsRequired, this.state.startLoc);\n      }\n    } else {\n      this.parseClassId(node, isStatement, optionalId);\n    }\n    super.parseClassSuper(node);\n    node.body = this.parsePlaceholder(\"ClassBody\") || super.parseClassBody(!!node.superClass, oldStrict);\n    return this.finishNode(node, type);\n  }\n  parseExport(node, decorators) {\n    const placeholder = this.parsePlaceholder(\"Identifier\");\n    if (!placeholder) return super.parseExport(node, decorators);\n    const node2 = node;\n    if (!this.isContextual(98) && !this.match(12)) {\n      node2.specifiers = [];\n      node2.source = null;\n      node2.declaration = this.finishPlaceholder(placeholder, \"Declaration\");\n      return this.finishNode(node2, \"ExportNamedDeclaration\");\n    }\n    this.expectPlugin(\"exportDefaultFrom\");\n    const specifier = this.startNode();\n    specifier.exported = placeholder;\n    node2.specifiers = [this.finishNode(specifier, \"ExportDefaultSpecifier\")];\n    return super.parseExport(node2, decorators);\n  }\n  isExportDefaultSpecifier() {\n    if (this.match(65)) {\n      const next = this.nextTokenStart();\n      if (this.isUnparsedContextual(next, \"from\")) {\n        if (this.input.startsWith(tokenLabelName(133), this.nextTokenStartSince(next + 4))) {\n          return true;\n        }\n      }\n    }\n    return super.isExportDefaultSpecifier();\n  }\n  maybeParseExportDefaultSpecifier(node, maybeDefaultIdentifier) {\n    var _specifiers;\n    if ((_specifiers = node.specifiers) != null && _specifiers.length) {\n      return true;\n    }\n    return super.maybeParseExportDefaultSpecifier(node, maybeDefaultIdentifier);\n  }\n  checkExport(node) {\n    const {\n      specifiers\n    } = node;\n    if (specifiers != null && specifiers.length) {\n      node.specifiers = specifiers.filter(node => node.exported.type === \"Placeholder\");\n    }\n    super.checkExport(node);\n    node.specifiers = specifiers;\n  }\n  parseImport(node) {\n    const placeholder = this.parsePlaceholder(\"Identifier\");\n    if (!placeholder) return super.parseImport(node);\n    node.specifiers = [];\n    if (!this.isContextual(98) && !this.match(12)) {\n      node.source = this.finishPlaceholder(placeholder, \"StringLiteral\");\n      this.semicolon();\n      return this.finishNode(node, \"ImportDeclaration\");\n    }\n    const specifier = this.startNodeAtNode(placeholder);\n    specifier.local = placeholder;\n    node.specifiers.push(this.finishNode(specifier, \"ImportDefaultSpecifier\"));\n    if (this.eat(12)) {\n      const hasStarImport = this.maybeParseStarImportSpecifier(node);\n      if (!hasStarImport) this.parseNamedImportSpecifiers(node);\n    }\n    this.expectContextual(98);\n    node.source = this.parseImportSource();\n    this.semicolon();\n    return this.finishNode(node, \"ImportDeclaration\");\n  }\n  parseImportSource() {\n    return this.parsePlaceholder(\"StringLiteral\") || super.parseImportSource();\n  }\n  assertNoSpace() {\n    if (this.state.start > this.offsetToSourcePos(this.state.lastTokEndLoc.index)) {\n      this.raise(PlaceholderErrors.UnexpectedSpace, this.state.lastTokEndLoc);\n    }\n  }\n};\nvar v8intrinsic = superClass => class V8IntrinsicMixin extends superClass {\n  parseV8Intrinsic() {\n    if (this.match(54)) {\n      const v8IntrinsicStartLoc = this.state.startLoc;\n      const node = this.startNode();\n      this.next();\n      if (tokenIsIdentifier(this.state.type)) {\n        const name = this.parseIdentifierName();\n        const identifier = this.createIdentifier(node, name);\n        this.castNodeTo(identifier, \"V8IntrinsicIdentifier\");\n        if (this.match(10)) {\n          return identifier;\n        }\n      }\n      this.unexpected(v8IntrinsicStartLoc);\n    }\n  }\n  parseExprAtom(refExpressionErrors) {\n    return this.parseV8Intrinsic() || super.parseExprAtom(refExpressionErrors);\n  }\n};\nconst PIPELINE_PROPOSALS = [\"minimal\", \"fsharp\", \"hack\", \"smart\"];\nconst TOPIC_TOKENS = [\"^^\", \"@@\", \"^\", \"%\", \"#\"];\nfunction validatePlugins(pluginsMap) {\n  if (pluginsMap.has(\"decorators\")) {\n    if (pluginsMap.has(\"decorators-legacy\")) {\n      throw new Error(\"Cannot use the decorators and decorators-legacy plugin together\");\n    }\n    const decoratorsBeforeExport = pluginsMap.get(\"decorators\").decoratorsBeforeExport;\n    if (decoratorsBeforeExport != null && typeof decoratorsBeforeExport !== \"boolean\") {\n      throw new Error(\"'decoratorsBeforeExport' must be a boolean, if specified.\");\n    }\n    const allowCallParenthesized = pluginsMap.get(\"decorators\").allowCallParenthesized;\n    if (allowCallParenthesized != null && typeof allowCallParenthesized !== \"boolean\") {\n      throw new Error(\"'allowCallParenthesized' must be a boolean.\");\n    }\n  }\n  if (pluginsMap.has(\"flow\") && pluginsMap.has(\"typescript\")) {\n    throw new Error(\"Cannot combine flow and typescript plugins.\");\n  }\n  if (pluginsMap.has(\"placeholders\") && pluginsMap.has(\"v8intrinsic\")) {\n    throw new Error(\"Cannot combine placeholders and v8intrinsic plugins.\");\n  }\n  if (pluginsMap.has(\"pipelineOperator\")) {\n    var _pluginsMap$get2;\n    const proposal = pluginsMap.get(\"pipelineOperator\").proposal;\n    if (!PIPELINE_PROPOSALS.includes(proposal)) {\n      const proposalList = PIPELINE_PROPOSALS.map(p => `\"${p}\"`).join(\", \");\n      throw new Error(`\"pipelineOperator\" requires \"proposal\" option whose value must be one of: ${proposalList}.`);\n    }\n    if (proposal === \"hack\") {\n      var _pluginsMap$get;\n      if (pluginsMap.has(\"placeholders\")) {\n        throw new Error(\"Cannot combine placeholders plugin and Hack-style pipes.\");\n      }\n      if (pluginsMap.has(\"v8intrinsic\")) {\n        throw new Error(\"Cannot combine v8intrinsic plugin and Hack-style pipes.\");\n      }\n      const topicToken = pluginsMap.get(\"pipelineOperator\").topicToken;\n      if (!TOPIC_TOKENS.includes(topicToken)) {\n        const tokenList = TOPIC_TOKENS.map(t => `\"${t}\"`).join(\", \");\n        throw new Error(`\"pipelineOperator\" in \"proposal\": \"hack\" mode also requires a \"topicToken\" option whose value must be one of: ${tokenList}.`);\n      }\n      if (topicToken === \"#\" && ((_pluginsMap$get = pluginsMap.get(\"recordAndTuple\")) == null ? void 0 : _pluginsMap$get.syntaxType) === \"hash\") {\n        throw new Error(`Plugin conflict between \\`[\"pipelineOperator\", { proposal: \"hack\", topicToken: \"#\" }]\\` and \\`${JSON.stringify([\"recordAndTuple\", pluginsMap.get(\"recordAndTuple\")])}\\`.`);\n      }\n    } else if (proposal === \"smart\" && ((_pluginsMap$get2 = pluginsMap.get(\"recordAndTuple\")) == null ? void 0 : _pluginsMap$get2.syntaxType) === \"hash\") {\n      throw new Error(`Plugin conflict between \\`[\"pipelineOperator\", { proposal: \"smart\" }]\\` and \\`${JSON.stringify([\"recordAndTuple\", pluginsMap.get(\"recordAndTuple\")])}\\`.`);\n    }\n  }\n  if (pluginsMap.has(\"moduleAttributes\")) {\n    if (pluginsMap.has(\"deprecatedImportAssert\") || pluginsMap.has(\"importAssertions\")) {\n      throw new Error(\"Cannot combine importAssertions, deprecatedImportAssert and moduleAttributes plugins.\");\n    }\n    const moduleAttributesVersionPluginOption = pluginsMap.get(\"moduleAttributes\").version;\n    if (moduleAttributesVersionPluginOption !== \"may-2020\") {\n      throw new Error(\"The 'moduleAttributes' plugin requires a 'version' option,\" + \" representing the last proposal update. Currently, the\" + \" only supported value is 'may-2020'.\");\n    }\n  }\n  if (pluginsMap.has(\"importAssertions\")) {\n    if (pluginsMap.has(\"deprecatedImportAssert\")) {\n      throw new Error(\"Cannot combine importAssertions and deprecatedImportAssert plugins.\");\n    }\n  }\n  if (pluginsMap.has(\"deprecatedImportAssert\")) ;else if (pluginsMap.has(\"importAttributes\") && pluginsMap.get(\"importAttributes\").deprecatedAssertSyntax) {\n    pluginsMap.set(\"deprecatedImportAssert\", {});\n  }\n  if (pluginsMap.has(\"recordAndTuple\")) {\n    const syntaxType = pluginsMap.get(\"recordAndTuple\").syntaxType;\n    if (syntaxType != null) {\n      const RECORD_AND_TUPLE_SYNTAX_TYPES = [\"hash\", \"bar\"];\n      if (!RECORD_AND_TUPLE_SYNTAX_TYPES.includes(syntaxType)) {\n        throw new Error(\"The 'syntaxType' option of the 'recordAndTuple' plugin must be one of: \" + RECORD_AND_TUPLE_SYNTAX_TYPES.map(p => `'${p}'`).join(\", \"));\n      }\n    }\n  }\n  if (pluginsMap.has(\"asyncDoExpressions\") && !pluginsMap.has(\"doExpressions\")) {\n    const error = new Error(\"'asyncDoExpressions' requires 'doExpressions', please add 'doExpressions' to parser plugins.\");\n    error.missingPlugins = \"doExpressions\";\n    throw error;\n  }\n  if (pluginsMap.has(\"optionalChainingAssign\") && pluginsMap.get(\"optionalChainingAssign\").version !== \"2023-07\") {\n    throw new Error(\"The 'optionalChainingAssign' plugin requires a 'version' option,\" + \" representing the last proposal update. Currently, the\" + \" only supported value is '2023-07'.\");\n  }\n  if (pluginsMap.has(\"discardBinding\") && pluginsMap.get(\"discardBinding\").syntaxType !== \"void\") {\n    throw new Error(\"The 'discardBinding' plugin requires a 'syntaxType' option. Currently the only supported value is 'void'.\");\n  }\n}\nconst mixinPlugins = {\n  estree,\n  jsx,\n  flow,\n  typescript,\n  v8intrinsic,\n  placeholders\n};\nconst mixinPluginNames = Object.keys(mixinPlugins);\nclass ExpressionParser extends LValParser {\n  checkProto(prop, isRecord, sawProto, refExpressionErrors) {\n    if (prop.type === \"SpreadElement\" || this.isObjectMethod(prop) || prop.computed || prop.shorthand) {\n      return sawProto;\n    }\n    const key = prop.key;\n    const name = key.type === \"Identifier\" ? key.name : key.value;\n    if (name === \"__proto__\") {\n      if (isRecord) {\n        this.raise(Errors.RecordNoProto, key);\n        return true;\n      }\n      if (sawProto) {\n        if (refExpressionErrors) {\n          if (refExpressionErrors.doubleProtoLoc === null) {\n            refExpressionErrors.doubleProtoLoc = key.loc.start;\n          }\n        } else {\n          this.raise(Errors.DuplicateProto, key);\n        }\n      }\n      return true;\n    }\n    return sawProto;\n  }\n  shouldExitDescending(expr, potentialArrowAt) {\n    return expr.type === \"ArrowFunctionExpression\" && this.offsetToSourcePos(expr.start) === potentialArrowAt;\n  }\n  getExpression() {\n    this.enterInitialScopes();\n    this.nextToken();\n    if (this.match(140)) {\n      throw this.raise(Errors.ParseExpressionEmptyInput, this.state.startLoc);\n    }\n    const expr = this.parseExpression();\n    if (!this.match(140)) {\n      throw this.raise(Errors.ParseExpressionExpectsEOF, this.state.startLoc, {\n        unexpected: this.input.codePointAt(this.state.start)\n      });\n    }\n    this.finalizeRemainingComments();\n    expr.comments = this.comments;\n    expr.errors = this.state.errors;\n    if (this.optionFlags & 256) {\n      expr.tokens = this.tokens;\n    }\n    return expr;\n  }\n  parseExpression(disallowIn, refExpressionErrors) {\n    if (disallowIn) {\n      return this.disallowInAnd(() => this.parseExpressionBase(refExpressionErrors));\n    }\n    return this.allowInAnd(() => this.parseExpressionBase(refExpressionErrors));\n  }\n  parseExpressionBase(refExpressionErrors) {\n    const startLoc = this.state.startLoc;\n    const expr = this.parseMaybeAssign(refExpressionErrors);\n    if (this.match(12)) {\n      const node = this.startNodeAt(startLoc);\n      node.expressions = [expr];\n      while (this.eat(12)) {\n        node.expressions.push(this.parseMaybeAssign(refExpressionErrors));\n      }\n      this.toReferencedList(node.expressions);\n      return this.finishNode(node, \"SequenceExpression\");\n    }\n    return expr;\n  }\n  parseMaybeAssignDisallowIn(refExpressionErrors, afterLeftParse) {\n    return this.disallowInAnd(() => this.parseMaybeAssign(refExpressionErrors, afterLeftParse));\n  }\n  parseMaybeAssignAllowIn(refExpressionErrors, afterLeftParse) {\n    return this.allowInAnd(() => this.parseMaybeAssign(refExpressionErrors, afterLeftParse));\n  }\n  setOptionalParametersError(refExpressionErrors) {\n    refExpressionErrors.optionalParametersLoc = this.state.startLoc;\n  }\n  parseMaybeAssign(refExpressionErrors, afterLeftParse) {\n    const startLoc = this.state.startLoc;\n    const isYield = this.isContextual(108);\n    if (isYield) {\n      if (this.prodParam.hasYield) {\n        this.next();\n        let left = this.parseYield(startLoc);\n        if (afterLeftParse) {\n          left = afterLeftParse.call(this, left, startLoc);\n        }\n        return left;\n      }\n    }\n    let ownExpressionErrors;\n    if (refExpressionErrors) {\n      ownExpressionErrors = false;\n    } else {\n      refExpressionErrors = new ExpressionErrors();\n      ownExpressionErrors = true;\n    }\n    const {\n      type\n    } = this.state;\n    if (type === 10 || tokenIsIdentifier(type)) {\n      this.state.potentialArrowAt = this.state.start;\n    }\n    let left = this.parseMaybeConditional(refExpressionErrors);\n    if (afterLeftParse) {\n      left = afterLeftParse.call(this, left, startLoc);\n    }\n    if (tokenIsAssignment(this.state.type)) {\n      const node = this.startNodeAt(startLoc);\n      const operator = this.state.value;\n      node.operator = operator;\n      if (this.match(29)) {\n        this.toAssignable(left, true);\n        node.left = left;\n        const startIndex = startLoc.index;\n        if (refExpressionErrors.doubleProtoLoc != null && refExpressionErrors.doubleProtoLoc.index >= startIndex) {\n          refExpressionErrors.doubleProtoLoc = null;\n        }\n        if (refExpressionErrors.shorthandAssignLoc != null && refExpressionErrors.shorthandAssignLoc.index >= startIndex) {\n          refExpressionErrors.shorthandAssignLoc = null;\n        }\n        if (refExpressionErrors.privateKeyLoc != null && refExpressionErrors.privateKeyLoc.index >= startIndex) {\n          this.checkDestructuringPrivate(refExpressionErrors);\n          refExpressionErrors.privateKeyLoc = null;\n        }\n        if (refExpressionErrors.voidPatternLoc != null && refExpressionErrors.voidPatternLoc.index >= startIndex) {\n          refExpressionErrors.voidPatternLoc = null;\n        }\n      } else {\n        node.left = left;\n      }\n      this.next();\n      node.right = this.parseMaybeAssign();\n      this.checkLVal(left, this.finishNode(node, \"AssignmentExpression\"), undefined, undefined, undefined, undefined, operator === \"||=\" || operator === \"&&=\" || operator === \"??=\");\n      return node;\n    } else if (ownExpressionErrors) {\n      this.checkExpressionErrors(refExpressionErrors, true);\n    }\n    if (isYield) {\n      const {\n        type\n      } = this.state;\n      const startsExpr = this.hasPlugin(\"v8intrinsic\") ? tokenCanStartExpression(type) : tokenCanStartExpression(type) && !this.match(54);\n      if (startsExpr && !this.isAmbiguousPrefixOrIdentifier()) {\n        this.raiseOverwrite(Errors.YieldNotInGeneratorFunction, startLoc);\n        return this.parseYield(startLoc);\n      }\n    }\n    return left;\n  }\n  parseMaybeConditional(refExpressionErrors) {\n    const startLoc = this.state.startLoc;\n    const potentialArrowAt = this.state.potentialArrowAt;\n    const expr = this.parseExprOps(refExpressionErrors);\n    if (this.shouldExitDescending(expr, potentialArrowAt)) {\n      return expr;\n    }\n    return this.parseConditional(expr, startLoc, refExpressionErrors);\n  }\n  parseConditional(expr, startLoc, refExpressionErrors) {\n    if (this.eat(17)) {\n      const node = this.startNodeAt(startLoc);\n      node.test = expr;\n      node.consequent = this.parseMaybeAssignAllowIn();\n      this.expect(14);\n      node.alternate = this.parseMaybeAssign();\n      return this.finishNode(node, \"ConditionalExpression\");\n    }\n    return expr;\n  }\n  parseMaybeUnaryOrPrivate(refExpressionErrors) {\n    return this.match(139) ? this.parsePrivateName() : this.parseMaybeUnary(refExpressionErrors);\n  }\n  parseExprOps(refExpressionErrors) {\n    const startLoc = this.state.startLoc;\n    const potentialArrowAt = this.state.potentialArrowAt;\n    const expr = this.parseMaybeUnaryOrPrivate(refExpressionErrors);\n    if (this.shouldExitDescending(expr, potentialArrowAt)) {\n      return expr;\n    }\n    return this.parseExprOp(expr, startLoc, -1);\n  }\n  parseExprOp(left, leftStartLoc, minPrec) {\n    if (this.isPrivateName(left)) {\n      const value = this.getPrivateNameSV(left);\n      if (minPrec >= tokenOperatorPrecedence(58) || !this.prodParam.hasIn || !this.match(58)) {\n        this.raise(Errors.PrivateInExpectedIn, left, {\n          identifierName: value\n        });\n      }\n      this.classScope.usePrivateName(value, left.loc.start);\n    }\n    const op = this.state.type;\n    if (tokenIsOperator(op) && (this.prodParam.hasIn || !this.match(58))) {\n      let prec = tokenOperatorPrecedence(op);\n      if (prec > minPrec) {\n        if (op === 39) {\n          this.expectPlugin(\"pipelineOperator\");\n          if (this.state.inFSharpPipelineDirectBody) {\n            return left;\n          }\n          this.checkPipelineAtInfixOperator(left, leftStartLoc);\n        }\n        const node = this.startNodeAt(leftStartLoc);\n        node.left = left;\n        node.operator = this.state.value;\n        const logical = op === 41 || op === 42;\n        const coalesce = op === 40;\n        if (coalesce) {\n          prec = tokenOperatorPrecedence(42);\n        }\n        this.next();\n        if (op === 39 && this.hasPlugin([\"pipelineOperator\", {\n          proposal: \"minimal\"\n        }])) {\n          if (this.state.type === 96 && this.prodParam.hasAwait) {\n            throw this.raise(Errors.UnexpectedAwaitAfterPipelineBody, this.state.startLoc);\n          }\n        }\n        node.right = this.parseExprOpRightExpr(op, prec);\n        const finishedNode = this.finishNode(node, logical || coalesce ? \"LogicalExpression\" : \"BinaryExpression\");\n        const nextOp = this.state.type;\n        if (coalesce && (nextOp === 41 || nextOp === 42) || logical && nextOp === 40) {\n          throw this.raise(Errors.MixingCoalesceWithLogical, this.state.startLoc);\n        }\n        return this.parseExprOp(finishedNode, leftStartLoc, minPrec);\n      }\n    }\n    return left;\n  }\n  parseExprOpRightExpr(op, prec) {\n    const startLoc = this.state.startLoc;\n    switch (op) {\n      case 39:\n        switch (this.getPluginOption(\"pipelineOperator\", \"proposal\")) {\n          case \"hack\":\n            return this.withTopicBindingContext(() => {\n              return this.parseHackPipeBody();\n            });\n          case \"fsharp\":\n            return this.withSoloAwaitPermittingContext(() => {\n              return this.parseFSharpPipelineBody(prec);\n            });\n        }\n        if (this.getPluginOption(\"pipelineOperator\", \"proposal\") === \"smart\") {\n          return this.withTopicBindingContext(() => {\n            if (this.prodParam.hasYield && this.isContextual(108)) {\n              throw this.raise(Errors.PipeBodyIsTighter, this.state.startLoc);\n            }\n            return this.parseSmartPipelineBodyInStyle(this.parseExprOpBaseRightExpr(op, prec), startLoc);\n          });\n        }\n      default:\n        return this.parseExprOpBaseRightExpr(op, prec);\n    }\n  }\n  parseExprOpBaseRightExpr(op, prec) {\n    const startLoc = this.state.startLoc;\n    return this.parseExprOp(this.parseMaybeUnaryOrPrivate(), startLoc, tokenIsRightAssociative(op) ? prec - 1 : prec);\n  }\n  parseHackPipeBody() {\n    var _body$extra;\n    const {\n      startLoc\n    } = this.state;\n    const body = this.parseMaybeAssign();\n    const requiredParentheses = UnparenthesizedPipeBodyDescriptions.has(body.type);\n    if (requiredParentheses && !((_body$extra = body.extra) != null && _body$extra.parenthesized)) {\n      this.raise(Errors.PipeUnparenthesizedBody, startLoc, {\n        type: body.type\n      });\n    }\n    if (!this.topicReferenceWasUsedInCurrentContext()) {\n      this.raise(Errors.PipeTopicUnused, startLoc);\n    }\n    return body;\n  }\n  checkExponentialAfterUnary(node) {\n    if (this.match(57)) {\n      this.raise(Errors.UnexpectedTokenUnaryExponentiation, node.argument);\n    }\n  }\n  parseMaybeUnary(refExpressionErrors, sawUnary) {\n    const startLoc = this.state.startLoc;\n    const isAwait = this.isContextual(96);\n    if (isAwait && this.recordAwaitIfAllowed()) {\n      this.next();\n      const expr = this.parseAwait(startLoc);\n      if (!sawUnary) this.checkExponentialAfterUnary(expr);\n      return expr;\n    }\n    const update = this.match(34);\n    const node = this.startNode();\n    if (tokenIsPrefix(this.state.type)) {\n      node.operator = this.state.value;\n      node.prefix = true;\n      if (this.match(72)) {\n        this.expectPlugin(\"throwExpressions\");\n      }\n      const isDelete = this.match(89);\n      this.next();\n      node.argument = this.parseMaybeUnary(null, true);\n      this.checkExpressionErrors(refExpressionErrors, true);\n      if (this.state.strict && isDelete) {\n        const arg = node.argument;\n        if (arg.type === \"Identifier\") {\n          this.raise(Errors.StrictDelete, node);\n        } else if (this.hasPropertyAsPrivateName(arg)) {\n          this.raise(Errors.DeletePrivateField, node);\n        }\n      }\n      if (!update) {\n        if (!sawUnary) {\n          this.checkExponentialAfterUnary(node);\n        }\n        return this.finishNode(node, \"UnaryExpression\");\n      }\n    }\n    const expr = this.parseUpdate(node, update, refExpressionErrors);\n    if (isAwait) {\n      const {\n        type\n      } = this.state;\n      const startsExpr = this.hasPlugin(\"v8intrinsic\") ? tokenCanStartExpression(type) : tokenCanStartExpression(type) && !this.match(54);\n      if (startsExpr && !this.isAmbiguousPrefixOrIdentifier()) {\n        this.raiseOverwrite(Errors.AwaitNotInAsyncContext, startLoc);\n        return this.parseAwait(startLoc);\n      }\n    }\n    return expr;\n  }\n  parseUpdate(node, update, refExpressionErrors) {\n    if (update) {\n      const updateExpressionNode = node;\n      this.checkLVal(updateExpressionNode.argument, this.finishNode(updateExpressionNode, \"UpdateExpression\"));\n      return node;\n    }\n    const startLoc = this.state.startLoc;\n    let expr = this.parseExprSubscripts(refExpressionErrors);\n    if (this.checkExpressionErrors(refExpressionErrors, false)) return expr;\n    while (tokenIsPostfix(this.state.type) && !this.canInsertSemicolon()) {\n      const node = this.startNodeAt(startLoc);\n      node.operator = this.state.value;\n      node.prefix = false;\n      node.argument = expr;\n      this.next();\n      this.checkLVal(expr, expr = this.finishNode(node, \"UpdateExpression\"));\n    }\n    return expr;\n  }\n  parseExprSubscripts(refExpressionErrors) {\n    const startLoc = this.state.startLoc;\n    const potentialArrowAt = this.state.potentialArrowAt;\n    const expr = this.parseExprAtom(refExpressionErrors);\n    if (this.shouldExitDescending(expr, potentialArrowAt)) {\n      return expr;\n    }\n    return this.parseSubscripts(expr, startLoc);\n  }\n  parseSubscripts(base, startLoc, noCalls) {\n    const state = {\n      optionalChainMember: false,\n      maybeAsyncArrow: this.atPossibleAsyncArrow(base),\n      stop: false\n    };\n    do {\n      base = this.parseSubscript(base, startLoc, noCalls, state);\n      state.maybeAsyncArrow = false;\n    } while (!state.stop);\n    return base;\n  }\n  parseSubscript(base, startLoc, noCalls, state) {\n    const {\n      type\n    } = this.state;\n    if (!noCalls && type === 15) {\n      return this.parseBind(base, startLoc, noCalls, state);\n    } else if (tokenIsTemplate(type)) {\n      return this.parseTaggedTemplateExpression(base, startLoc, state);\n    }\n    let optional = false;\n    if (type === 18) {\n      if (noCalls) {\n        this.raise(Errors.OptionalChainingNoNew, this.state.startLoc);\n        if (this.lookaheadCharCode() === 40) {\n          return this.stopParseSubscript(base, state);\n        }\n      }\n      state.optionalChainMember = optional = true;\n      this.next();\n    }\n    if (!noCalls && this.match(10)) {\n      return this.parseCoverCallAndAsyncArrowHead(base, startLoc, state, optional);\n    } else {\n      const computed = this.eat(0);\n      if (computed || optional || this.eat(16)) {\n        return this.parseMember(base, startLoc, state, computed, optional);\n      } else {\n        return this.stopParseSubscript(base, state);\n      }\n    }\n  }\n  stopParseSubscript(base, state) {\n    state.stop = true;\n    return base;\n  }\n  parseMember(base, startLoc, state, computed, optional) {\n    const node = this.startNodeAt(startLoc);\n    node.object = base;\n    node.computed = computed;\n    if (computed) {\n      node.property = this.parseExpression();\n      this.expect(3);\n    } else if (this.match(139)) {\n      if (base.type === \"Super\") {\n        this.raise(Errors.SuperPrivateField, startLoc);\n      }\n      this.classScope.usePrivateName(this.state.value, this.state.startLoc);\n      node.property = this.parsePrivateName();\n    } else {\n      node.property = this.parseIdentifier(true);\n    }\n    if (state.optionalChainMember) {\n      node.optional = optional;\n      return this.finishNode(node, \"OptionalMemberExpression\");\n    } else {\n      return this.finishNode(node, \"MemberExpression\");\n    }\n  }\n  parseBind(base, startLoc, noCalls, state) {\n    const node = this.startNodeAt(startLoc);\n    node.object = base;\n    this.next();\n    node.callee = this.parseNoCallExpr();\n    state.stop = true;\n    return this.parseSubscripts(this.finishNode(node, \"BindExpression\"), startLoc, noCalls);\n  }\n  parseCoverCallAndAsyncArrowHead(base, startLoc, state, optional) {\n    const oldMaybeInArrowParameters = this.state.maybeInArrowParameters;\n    let refExpressionErrors = null;\n    this.state.maybeInArrowParameters = true;\n    this.next();\n    const node = this.startNodeAt(startLoc);\n    node.callee = base;\n    const {\n      maybeAsyncArrow,\n      optionalChainMember\n    } = state;\n    if (maybeAsyncArrow) {\n      this.expressionScope.enter(newAsyncArrowScope());\n      refExpressionErrors = new ExpressionErrors();\n    }\n    if (optionalChainMember) {\n      node.optional = optional;\n    }\n    if (optional) {\n      node.arguments = this.parseCallExpressionArguments();\n    } else {\n      node.arguments = this.parseCallExpressionArguments(base.type !== \"Super\", node, refExpressionErrors);\n    }\n    let finishedNode = this.finishCallExpression(node, optionalChainMember);\n    if (maybeAsyncArrow && this.shouldParseAsyncArrow() && !optional) {\n      state.stop = true;\n      this.checkDestructuringPrivate(refExpressionErrors);\n      this.expressionScope.validateAsPattern();\n      this.expressionScope.exit();\n      finishedNode = this.parseAsyncArrowFromCallExpression(this.startNodeAt(startLoc), finishedNode);\n    } else {\n      if (maybeAsyncArrow) {\n        this.checkExpressionErrors(refExpressionErrors, true);\n        this.expressionScope.exit();\n      }\n      this.toReferencedArguments(finishedNode);\n    }\n    this.state.maybeInArrowParameters = oldMaybeInArrowParameters;\n    return finishedNode;\n  }\n  toReferencedArguments(node, isParenthesizedExpr) {\n    this.toReferencedListDeep(node.arguments, isParenthesizedExpr);\n  }\n  parseTaggedTemplateExpression(base, startLoc, state) {\n    const node = this.startNodeAt(startLoc);\n    node.tag = base;\n    node.quasi = this.parseTemplate(true);\n    if (state.optionalChainMember) {\n      this.raise(Errors.OptionalChainingNoTemplate, startLoc);\n    }\n    return this.finishNode(node, \"TaggedTemplateExpression\");\n  }\n  atPossibleAsyncArrow(base) {\n    return base.type === \"Identifier\" && base.name === \"async\" && this.state.lastTokEndLoc.index === base.end && !this.canInsertSemicolon() && base.end - base.start === 5 && this.offsetToSourcePos(base.start) === this.state.potentialArrowAt;\n  }\n  finishCallExpression(node, optional) {\n    if (node.callee.type === \"Import\") {\n      if (node.arguments.length === 0 || node.arguments.length > 2) {\n        this.raise(Errors.ImportCallArity, node);\n      } else {\n        for (const arg of node.arguments) {\n          if (arg.type === \"SpreadElement\") {\n            this.raise(Errors.ImportCallSpreadArgument, arg);\n          }\n        }\n      }\n    }\n    return this.finishNode(node, optional ? \"OptionalCallExpression\" : \"CallExpression\");\n  }\n  parseCallExpressionArguments(allowPlaceholder, nodeForExtra, refExpressionErrors) {\n    const elts = [];\n    let first = true;\n    const oldInFSharpPipelineDirectBody = this.state.inFSharpPipelineDirectBody;\n    this.state.inFSharpPipelineDirectBody = false;\n    while (!this.eat(11)) {\n      if (first) {\n        first = false;\n      } else {\n        this.expect(12);\n        if (this.match(11)) {\n          if (nodeForExtra) {\n            this.addTrailingCommaExtraToNode(nodeForExtra);\n          }\n          this.next();\n          break;\n        }\n      }\n      elts.push(this.parseExprListItem(11, false, refExpressionErrors, allowPlaceholder));\n    }\n    this.state.inFSharpPipelineDirectBody = oldInFSharpPipelineDirectBody;\n    return elts;\n  }\n  shouldParseAsyncArrow() {\n    return this.match(19) && !this.canInsertSemicolon();\n  }\n  parseAsyncArrowFromCallExpression(node, call) {\n    var _call$extra;\n    this.resetPreviousNodeTrailingComments(call);\n    this.expect(19);\n    this.parseArrowExpression(node, call.arguments, true, (_call$extra = call.extra) == null ? void 0 : _call$extra.trailingCommaLoc);\n    if (call.innerComments) {\n      setInnerComments(node, call.innerComments);\n    }\n    if (call.callee.trailingComments) {\n      setInnerComments(node, call.callee.trailingComments);\n    }\n    return node;\n  }\n  parseNoCallExpr() {\n    const startLoc = this.state.startLoc;\n    return this.parseSubscripts(this.parseExprAtom(), startLoc, true);\n  }\n  parseExprAtom(refExpressionErrors) {\n    let node;\n    let decorators = null;\n    const {\n      type\n    } = this.state;\n    switch (type) {\n      case 79:\n        return this.parseSuper();\n      case 83:\n        node = this.startNode();\n        this.next();\n        if (this.match(16)) {\n          return this.parseImportMetaPropertyOrPhaseCall(node);\n        }\n        if (this.match(10)) {\n          if (this.optionFlags & 512) {\n            return this.parseImportCall(node);\n          } else {\n            return this.finishNode(node, \"Import\");\n          }\n        } else {\n          this.raise(Errors.UnsupportedImport, this.state.lastTokStartLoc);\n          return this.finishNode(node, \"Import\");\n        }\n      case 78:\n        node = this.startNode();\n        this.next();\n        return this.finishNode(node, \"ThisExpression\");\n      case 90:\n        {\n          return this.parseDo(this.startNode(), false);\n        }\n      case 56:\n      case 31:\n        {\n          this.readRegexp();\n          return this.parseRegExpLiteral(this.state.value);\n        }\n      case 135:\n        return this.parseNumericLiteral(this.state.value);\n      case 136:\n        return this.parseBigIntLiteral(this.state.value);\n      case 134:\n        return this.parseStringLiteral(this.state.value);\n      case 84:\n        return this.parseNullLiteral();\n      case 85:\n        return this.parseBooleanLiteral(true);\n      case 86:\n        return this.parseBooleanLiteral(false);\n      case 10:\n        {\n          const canBeArrow = this.state.potentialArrowAt === this.state.start;\n          return this.parseParenAndDistinguishExpression(canBeArrow);\n        }\n      case 0:\n        {\n          return this.parseArrayLike(3, false, refExpressionErrors);\n        }\n      case 5:\n        {\n          return this.parseObjectLike(8, false, false, refExpressionErrors);\n        }\n      case 68:\n        return this.parseFunctionOrFunctionSent();\n      case 26:\n        decorators = this.parseDecorators();\n      case 80:\n        return this.parseClass(this.maybeTakeDecorators(decorators, this.startNode()), false);\n      case 77:\n        return this.parseNewOrNewTarget();\n      case 25:\n      case 24:\n        return this.parseTemplate(false);\n      case 15:\n        {\n          node = this.startNode();\n          this.next();\n          node.object = null;\n          const callee = node.callee = this.parseNoCallExpr();\n          if (callee.type === \"MemberExpression\") {\n            return this.finishNode(node, \"BindExpression\");\n          } else {\n            throw this.raise(Errors.UnsupportedBind, callee);\n          }\n        }\n      case 139:\n        {\n          this.raise(Errors.PrivateInExpectedIn, this.state.startLoc, {\n            identifierName: this.state.value\n          });\n          return this.parsePrivateName();\n        }\n      case 33:\n        {\n          return this.parseTopicReferenceThenEqualsSign(54, \"%\");\n        }\n      case 32:\n        {\n          return this.parseTopicReferenceThenEqualsSign(44, \"^\");\n        }\n      case 37:\n      case 38:\n        {\n          return this.parseTopicReference(\"hack\");\n        }\n      case 44:\n      case 54:\n      case 27:\n        {\n          const pipeProposal = this.getPluginOption(\"pipelineOperator\", \"proposal\");\n          if (pipeProposal) {\n            return this.parseTopicReference(pipeProposal);\n          }\n          throw this.unexpected();\n        }\n      case 47:\n        {\n          const lookaheadCh = this.input.codePointAt(this.nextTokenStart());\n          if (isIdentifierStart(lookaheadCh) || lookaheadCh === 62) {\n            throw this.expectOnePlugin([\"jsx\", \"flow\", \"typescript\"]);\n          }\n          throw this.unexpected();\n        }\n      default:\n        if (type === 137) {\n          return this.parseDecimalLiteral(this.state.value);\n        } else if (type === 2 || type === 1) {\n          return this.parseArrayLike(this.state.type === 2 ? 4 : 3, true);\n        } else if (type === 6 || type === 7) {\n          return this.parseObjectLike(this.state.type === 6 ? 9 : 8, false, true);\n        }\n        if (tokenIsIdentifier(type)) {\n          if (this.isContextual(127) && this.lookaheadInLineCharCode() === 123) {\n            return this.parseModuleExpression();\n          }\n          const canBeArrow = this.state.potentialArrowAt === this.state.start;\n          const containsEsc = this.state.containsEsc;\n          const id = this.parseIdentifier();\n          if (!containsEsc && id.name === \"async\" && !this.canInsertSemicolon()) {\n            const {\n              type\n            } = this.state;\n            if (type === 68) {\n              this.resetPreviousNodeTrailingComments(id);\n              this.next();\n              return this.parseAsyncFunctionExpression(this.startNodeAtNode(id));\n            } else if (tokenIsIdentifier(type)) {\n              if (this.lookaheadCharCode() === 61) {\n                return this.parseAsyncArrowUnaryFunction(this.startNodeAtNode(id));\n              } else {\n                return id;\n              }\n            } else if (type === 90) {\n              this.resetPreviousNodeTrailingComments(id);\n              return this.parseDo(this.startNodeAtNode(id), true);\n            }\n          }\n          if (canBeArrow && this.match(19) && !this.canInsertSemicolon()) {\n            this.next();\n            return this.parseArrowExpression(this.startNodeAtNode(id), [id], false);\n          }\n          return id;\n        } else {\n          throw this.unexpected();\n        }\n    }\n  }\n  parseTopicReferenceThenEqualsSign(topicTokenType, topicTokenValue) {\n    const pipeProposal = this.getPluginOption(\"pipelineOperator\", \"proposal\");\n    if (pipeProposal) {\n      this.state.type = topicTokenType;\n      this.state.value = topicTokenValue;\n      this.state.pos--;\n      this.state.end--;\n      this.state.endLoc = createPositionWithColumnOffset(this.state.endLoc, -1);\n      return this.parseTopicReference(pipeProposal);\n    }\n    throw this.unexpected();\n  }\n  parseTopicReference(pipeProposal) {\n    const node = this.startNode();\n    const startLoc = this.state.startLoc;\n    const tokenType = this.state.type;\n    this.next();\n    return this.finishTopicReference(node, startLoc, pipeProposal, tokenType);\n  }\n  finishTopicReference(node, startLoc, pipeProposal, tokenType) {\n    if (this.testTopicReferenceConfiguration(pipeProposal, startLoc, tokenType)) {\n      if (pipeProposal === \"hack\") {\n        if (!this.topicReferenceIsAllowedInCurrentContext()) {\n          this.raise(Errors.PipeTopicUnbound, startLoc);\n        }\n        this.registerTopicReference();\n        return this.finishNode(node, \"TopicReference\");\n      } else {\n        if (!this.topicReferenceIsAllowedInCurrentContext()) {\n          this.raise(Errors.PrimaryTopicNotAllowed, startLoc);\n        }\n        this.registerTopicReference();\n        return this.finishNode(node, \"PipelinePrimaryTopicReference\");\n      }\n    } else {\n      throw this.raise(Errors.PipeTopicUnconfiguredToken, startLoc, {\n        token: tokenLabelName(tokenType)\n      });\n    }\n  }\n  testTopicReferenceConfiguration(pipeProposal, startLoc, tokenType) {\n    switch (pipeProposal) {\n      case \"hack\":\n        {\n          return this.hasPlugin([\"pipelineOperator\", {\n            topicToken: tokenLabelName(tokenType)\n          }]);\n        }\n      case \"smart\":\n        return tokenType === 27;\n      default:\n        throw this.raise(Errors.PipeTopicRequiresHackPipes, startLoc);\n    }\n  }\n  parseAsyncArrowUnaryFunction(node) {\n    this.prodParam.enter(functionFlags(true, this.prodParam.hasYield));\n    const params = [this.parseIdentifier()];\n    this.prodParam.exit();\n    if (this.hasPrecedingLineBreak()) {\n      this.raise(Errors.LineTerminatorBeforeArrow, this.state.curPosition());\n    }\n    this.expect(19);\n    return this.parseArrowExpression(node, params, true);\n  }\n  parseDo(node, isAsync) {\n    this.expectPlugin(\"doExpressions\");\n    if (isAsync) {\n      this.expectPlugin(\"asyncDoExpressions\");\n    }\n    node.async = isAsync;\n    this.next();\n    const oldLabels = this.state.labels;\n    this.state.labels = [];\n    if (isAsync) {\n      this.prodParam.enter(2);\n      node.body = this.parseBlock();\n      this.prodParam.exit();\n    } else {\n      node.body = this.parseBlock();\n    }\n    this.state.labels = oldLabels;\n    return this.finishNode(node, \"DoExpression\");\n  }\n  parseSuper() {\n    const node = this.startNode();\n    this.next();\n    if (this.match(10) && !this.scope.allowDirectSuper) {\n      if (!(this.optionFlags & 16)) {\n        this.raise(Errors.SuperNotAllowed, node);\n      }\n    } else if (!this.scope.allowSuper) {\n      if (!(this.optionFlags & 16)) {\n        this.raise(Errors.UnexpectedSuper, node);\n      }\n    }\n    if (!this.match(10) && !this.match(0) && !this.match(16)) {\n      this.raise(Errors.UnsupportedSuper, node);\n    }\n    return this.finishNode(node, \"Super\");\n  }\n  parsePrivateName() {\n    const node = this.startNode();\n    const id = this.startNodeAt(createPositionWithColumnOffset(this.state.startLoc, 1));\n    const name = this.state.value;\n    this.next();\n    node.id = this.createIdentifier(id, name);\n    return this.finishNode(node, \"PrivateName\");\n  }\n  parseFunctionOrFunctionSent() {\n    const node = this.startNode();\n    this.next();\n    if (this.prodParam.hasYield && this.match(16)) {\n      const meta = this.createIdentifier(this.startNodeAtNode(node), \"function\");\n      this.next();\n      if (this.match(103)) {\n        this.expectPlugin(\"functionSent\");\n      } else if (!this.hasPlugin(\"functionSent\")) {\n        this.unexpected();\n      }\n      return this.parseMetaProperty(node, meta, \"sent\");\n    }\n    return this.parseFunction(node);\n  }\n  parseMetaProperty(node, meta, propertyName) {\n    node.meta = meta;\n    const containsEsc = this.state.containsEsc;\n    node.property = this.parseIdentifier(true);\n    if (node.property.name !== propertyName || containsEsc) {\n      this.raise(Errors.UnsupportedMetaProperty, node.property, {\n        target: meta.name,\n        onlyValidPropertyName: propertyName\n      });\n    }\n    return this.finishNode(node, \"MetaProperty\");\n  }\n  parseImportMetaPropertyOrPhaseCall(node) {\n    this.next();\n    if (this.isContextual(105) || this.isContextual(97)) {\n      const isSource = this.isContextual(105);\n      this.expectPlugin(isSource ? \"sourcePhaseImports\" : \"deferredImportEvaluation\");\n      this.next();\n      node.phase = isSource ? \"source\" : \"defer\";\n      return this.parseImportCall(node);\n    } else {\n      const id = this.createIdentifierAt(this.startNodeAtNode(node), \"import\", this.state.lastTokStartLoc);\n      if (this.isContextual(101)) {\n        if (!this.inModule) {\n          this.raise(Errors.ImportMetaOutsideModule, id);\n        }\n        this.sawUnambiguousESM = true;\n      }\n      return this.parseMetaProperty(node, id, \"meta\");\n    }\n  }\n  parseLiteralAtNode(value, type, node) {\n    this.addExtra(node, \"rawValue\", value);\n    this.addExtra(node, \"raw\", this.input.slice(this.offsetToSourcePos(node.start), this.state.end));\n    node.value = value;\n    this.next();\n    return this.finishNode(node, type);\n  }\n  parseLiteral(value, type) {\n    const node = this.startNode();\n    return this.parseLiteralAtNode(value, type, node);\n  }\n  parseStringLiteral(value) {\n    return this.parseLiteral(value, \"StringLiteral\");\n  }\n  parseNumericLiteral(value) {\n    return this.parseLiteral(value, \"NumericLiteral\");\n  }\n  parseBigIntLiteral(value) {\n    return this.parseLiteral(value, \"BigIntLiteral\");\n  }\n  parseDecimalLiteral(value) {\n    return this.parseLiteral(value, \"DecimalLiteral\");\n  }\n  parseRegExpLiteral(value) {\n    const node = this.startNode();\n    this.addExtra(node, \"raw\", this.input.slice(this.offsetToSourcePos(node.start), this.state.end));\n    node.pattern = value.pattern;\n    node.flags = value.flags;\n    this.next();\n    return this.finishNode(node, \"RegExpLiteral\");\n  }\n  parseBooleanLiteral(value) {\n    const node = this.startNode();\n    node.value = value;\n    this.next();\n    return this.finishNode(node, \"BooleanLiteral\");\n  }\n  parseNullLiteral() {\n    const node = this.startNode();\n    this.next();\n    return this.finishNode(node, \"NullLiteral\");\n  }\n  parseParenAndDistinguishExpression(canBeArrow) {\n    const startLoc = this.state.startLoc;\n    let val;\n    this.next();\n    this.expressionScope.enter(newArrowHeadScope());\n    const oldMaybeInArrowParameters = this.state.maybeInArrowParameters;\n    const oldInFSharpPipelineDirectBody = this.state.inFSharpPipelineDirectBody;\n    this.state.maybeInArrowParameters = true;\n    this.state.inFSharpPipelineDirectBody = false;\n    const innerStartLoc = this.state.startLoc;\n    const exprList = [];\n    const refExpressionErrors = new ExpressionErrors();\n    let first = true;\n    let spreadStartLoc;\n    let optionalCommaStartLoc;\n    while (!this.match(11)) {\n      if (first) {\n        first = false;\n      } else {\n        this.expect(12, refExpressionErrors.optionalParametersLoc === null ? null : refExpressionErrors.optionalParametersLoc);\n        if (this.match(11)) {\n          optionalCommaStartLoc = this.state.startLoc;\n          break;\n        }\n      }\n      if (this.match(21)) {\n        const spreadNodeStartLoc = this.state.startLoc;\n        spreadStartLoc = this.state.startLoc;\n        exprList.push(this.parseParenItem(this.parseRestBinding(), spreadNodeStartLoc));\n        if (!this.checkCommaAfterRest(41)) {\n          break;\n        }\n      } else {\n        exprList.push(this.parseMaybeAssignAllowInOrVoidPattern(11, refExpressionErrors, this.parseParenItem));\n      }\n    }\n    const innerEndLoc = this.state.lastTokEndLoc;\n    this.expect(11);\n    this.state.maybeInArrowParameters = oldMaybeInArrowParameters;\n    this.state.inFSharpPipelineDirectBody = oldInFSharpPipelineDirectBody;\n    let arrowNode = this.startNodeAt(startLoc);\n    if (canBeArrow && this.shouldParseArrow(exprList) && (arrowNode = this.parseArrow(arrowNode))) {\n      this.checkDestructuringPrivate(refExpressionErrors);\n      this.expressionScope.validateAsPattern();\n      this.expressionScope.exit();\n      this.parseArrowExpression(arrowNode, exprList, false);\n      return arrowNode;\n    }\n    this.expressionScope.exit();\n    if (!exprList.length) {\n      this.unexpected(this.state.lastTokStartLoc);\n    }\n    if (optionalCommaStartLoc) this.unexpected(optionalCommaStartLoc);\n    if (spreadStartLoc) this.unexpected(spreadStartLoc);\n    this.checkExpressionErrors(refExpressionErrors, true);\n    this.toReferencedListDeep(exprList, true);\n    if (exprList.length > 1) {\n      val = this.startNodeAt(innerStartLoc);\n      val.expressions = exprList;\n      this.finishNode(val, \"SequenceExpression\");\n      this.resetEndLocation(val, innerEndLoc);\n    } else {\n      val = exprList[0];\n    }\n    return this.wrapParenthesis(startLoc, val);\n  }\n  wrapParenthesis(startLoc, expression) {\n    if (!(this.optionFlags & 1024)) {\n      this.addExtra(expression, \"parenthesized\", true);\n      this.addExtra(expression, \"parenStart\", startLoc.index);\n      this.takeSurroundingComments(expression, startLoc.index, this.state.lastTokEndLoc.index);\n      return expression;\n    }\n    const parenExpression = this.startNodeAt(startLoc);\n    parenExpression.expression = expression;\n    return this.finishNode(parenExpression, \"ParenthesizedExpression\");\n  }\n  shouldParseArrow(params) {\n    return !this.canInsertSemicolon();\n  }\n  parseArrow(node) {\n    if (this.eat(19)) {\n      return node;\n    }\n  }\n  parseParenItem(node, startLoc) {\n    return node;\n  }\n  parseNewOrNewTarget() {\n    const node = this.startNode();\n    this.next();\n    if (this.match(16)) {\n      const meta = this.createIdentifier(this.startNodeAtNode(node), \"new\");\n      this.next();\n      const metaProp = this.parseMetaProperty(node, meta, \"target\");\n      if (!this.scope.allowNewTarget) {\n        this.raise(Errors.UnexpectedNewTarget, metaProp);\n      }\n      return metaProp;\n    }\n    return this.parseNew(node);\n  }\n  parseNew(node) {\n    this.parseNewCallee(node);\n    if (this.eat(10)) {\n      const args = this.parseExprList(11);\n      this.toReferencedList(args);\n      node.arguments = args;\n    } else {\n      node.arguments = [];\n    }\n    return this.finishNode(node, \"NewExpression\");\n  }\n  parseNewCallee(node) {\n    const isImport = this.match(83);\n    const callee = this.parseNoCallExpr();\n    node.callee = callee;\n    if (isImport && (callee.type === \"Import\" || callee.type === \"ImportExpression\")) {\n      this.raise(Errors.ImportCallNotNewExpression, callee);\n    }\n  }\n  parseTemplateElement(isTagged) {\n    const {\n      start,\n      startLoc,\n      end,\n      value\n    } = this.state;\n    const elemStart = start + 1;\n    const elem = this.startNodeAt(createPositionWithColumnOffset(startLoc, 1));\n    if (value === null) {\n      if (!isTagged) {\n        this.raise(Errors.InvalidEscapeSequenceTemplate, createPositionWithColumnOffset(this.state.firstInvalidTemplateEscapePos, 1));\n      }\n    }\n    const isTail = this.match(24);\n    const endOffset = isTail ? -1 : -2;\n    const elemEnd = end + endOffset;\n    elem.value = {\n      raw: this.input.slice(elemStart, elemEnd).replace(/\\r\\n?/g, \"\\n\"),\n      cooked: value === null ? null : value.slice(1, endOffset)\n    };\n    elem.tail = isTail;\n    this.next();\n    const finishedNode = this.finishNode(elem, \"TemplateElement\");\n    this.resetEndLocation(finishedNode, createPositionWithColumnOffset(this.state.lastTokEndLoc, endOffset));\n    return finishedNode;\n  }\n  parseTemplate(isTagged) {\n    const node = this.startNode();\n    let curElt = this.parseTemplateElement(isTagged);\n    const quasis = [curElt];\n    const substitutions = [];\n    while (!curElt.tail) {\n      substitutions.push(this.parseTemplateSubstitution());\n      this.readTemplateContinuation();\n      quasis.push(curElt = this.parseTemplateElement(isTagged));\n    }\n    node.expressions = substitutions;\n    node.quasis = quasis;\n    return this.finishNode(node, \"TemplateLiteral\");\n  }\n  parseTemplateSubstitution() {\n    return this.parseExpression();\n  }\n  parseObjectLike(close, isPattern, isRecord, refExpressionErrors) {\n    if (isRecord) {\n      this.expectPlugin(\"recordAndTuple\");\n    }\n    const oldInFSharpPipelineDirectBody = this.state.inFSharpPipelineDirectBody;\n    this.state.inFSharpPipelineDirectBody = false;\n    let sawProto = false;\n    let first = true;\n    const node = this.startNode();\n    node.properties = [];\n    this.next();\n    while (!this.match(close)) {\n      if (first) {\n        first = false;\n      } else {\n        this.expect(12);\n        if (this.match(close)) {\n          this.addTrailingCommaExtraToNode(node);\n          break;\n        }\n      }\n      let prop;\n      if (isPattern) {\n        prop = this.parseBindingProperty();\n      } else {\n        prop = this.parsePropertyDefinition(refExpressionErrors);\n        sawProto = this.checkProto(prop, isRecord, sawProto, refExpressionErrors);\n      }\n      if (isRecord && !this.isObjectProperty(prop) && prop.type !== \"SpreadElement\") {\n        this.raise(Errors.InvalidRecordProperty, prop);\n      }\n      if (prop.shorthand) {\n        this.addExtra(prop, \"shorthand\", true);\n      }\n      node.properties.push(prop);\n    }\n    this.next();\n    this.state.inFSharpPipelineDirectBody = oldInFSharpPipelineDirectBody;\n    let type = \"ObjectExpression\";\n    if (isPattern) {\n      type = \"ObjectPattern\";\n    } else if (isRecord) {\n      type = \"RecordExpression\";\n    }\n    return this.finishNode(node, type);\n  }\n  addTrailingCommaExtraToNode(node) {\n    this.addExtra(node, \"trailingComma\", this.state.lastTokStartLoc.index);\n    this.addExtra(node, \"trailingCommaLoc\", this.state.lastTokStartLoc, false);\n  }\n  maybeAsyncOrAccessorProp(prop) {\n    return !prop.computed && prop.key.type === \"Identifier\" && (this.isLiteralPropertyName() || this.match(0) || this.match(55));\n  }\n  parsePropertyDefinition(refExpressionErrors) {\n    let decorators = [];\n    if (this.match(26)) {\n      if (this.hasPlugin(\"decorators\")) {\n        this.raise(Errors.UnsupportedPropertyDecorator, this.state.startLoc);\n      }\n      while (this.match(26)) {\n        decorators.push(this.parseDecorator());\n      }\n    }\n    const prop = this.startNode();\n    let isAsync = false;\n    let isAccessor = false;\n    let startLoc;\n    if (this.match(21)) {\n      if (decorators.length) this.unexpected();\n      return this.parseSpread();\n    }\n    if (decorators.length) {\n      prop.decorators = decorators;\n      decorators = [];\n    }\n    prop.method = false;\n    if (refExpressionErrors) {\n      startLoc = this.state.startLoc;\n    }\n    let isGenerator = this.eat(55);\n    this.parsePropertyNamePrefixOperator(prop);\n    const containsEsc = this.state.containsEsc;\n    this.parsePropertyName(prop, refExpressionErrors);\n    if (!isGenerator && !containsEsc && this.maybeAsyncOrAccessorProp(prop)) {\n      const {\n        key\n      } = prop;\n      const keyName = key.name;\n      if (keyName === \"async\" && !this.hasPrecedingLineBreak()) {\n        isAsync = true;\n        this.resetPreviousNodeTrailingComments(key);\n        isGenerator = this.eat(55);\n        this.parsePropertyName(prop);\n      }\n      if (keyName === \"get\" || keyName === \"set\") {\n        isAccessor = true;\n        this.resetPreviousNodeTrailingComments(key);\n        prop.kind = keyName;\n        if (this.match(55)) {\n          isGenerator = true;\n          this.raise(Errors.AccessorIsGenerator, this.state.curPosition(), {\n            kind: keyName\n          });\n          this.next();\n        }\n        this.parsePropertyName(prop);\n      }\n    }\n    return this.parseObjPropValue(prop, startLoc, isGenerator, isAsync, false, isAccessor, refExpressionErrors);\n  }\n  getGetterSetterExpectedParamCount(method) {\n    return method.kind === \"get\" ? 0 : 1;\n  }\n  getObjectOrClassMethodParams(method) {\n    return method.params;\n  }\n  checkGetterSetterParams(method) {\n    var _params;\n    const paramCount = this.getGetterSetterExpectedParamCount(method);\n    const params = this.getObjectOrClassMethodParams(method);\n    if (params.length !== paramCount) {\n      this.raise(method.kind === \"get\" ? Errors.BadGetterArity : Errors.BadSetterArity, method);\n    }\n    if (method.kind === \"set\" && ((_params = params[params.length - 1]) == null ? void 0 : _params.type) === \"RestElement\") {\n      this.raise(Errors.BadSetterRestParameter, method);\n    }\n  }\n  parseObjectMethod(prop, isGenerator, isAsync, isPattern, isAccessor) {\n    if (isAccessor) {\n      const finishedProp = this.parseMethod(prop, isGenerator, false, false, false, \"ObjectMethod\");\n      this.checkGetterSetterParams(finishedProp);\n      return finishedProp;\n    }\n    if (isAsync || isGenerator || this.match(10)) {\n      if (isPattern) this.unexpected();\n      prop.kind = \"method\";\n      prop.method = true;\n      return this.parseMethod(prop, isGenerator, isAsync, false, false, \"ObjectMethod\");\n    }\n  }\n  parseObjectProperty(prop, startLoc, isPattern, refExpressionErrors) {\n    prop.shorthand = false;\n    if (this.eat(14)) {\n      prop.value = isPattern ? this.parseMaybeDefault(this.state.startLoc) : this.parseMaybeAssignAllowInOrVoidPattern(8, refExpressionErrors);\n      return this.finishObjectProperty(prop);\n    }\n    if (!prop.computed && prop.key.type === \"Identifier\") {\n      this.checkReservedWord(prop.key.name, prop.key.loc.start, true, false);\n      if (isPattern) {\n        prop.value = this.parseMaybeDefault(startLoc, this.cloneIdentifier(prop.key));\n      } else if (this.match(29)) {\n        const shorthandAssignLoc = this.state.startLoc;\n        if (refExpressionErrors != null) {\n          if (refExpressionErrors.shorthandAssignLoc === null) {\n            refExpressionErrors.shorthandAssignLoc = shorthandAssignLoc;\n          }\n        } else {\n          this.raise(Errors.InvalidCoverInitializedName, shorthandAssignLoc);\n        }\n        prop.value = this.parseMaybeDefault(startLoc, this.cloneIdentifier(prop.key));\n      } else {\n        prop.value = this.cloneIdentifier(prop.key);\n      }\n      prop.shorthand = true;\n      return this.finishObjectProperty(prop);\n    }\n  }\n  finishObjectProperty(node) {\n    return this.finishNode(node, \"ObjectProperty\");\n  }\n  parseObjPropValue(prop, startLoc, isGenerator, isAsync, isPattern, isAccessor, refExpressionErrors) {\n    const node = this.parseObjectMethod(prop, isGenerator, isAsync, isPattern, isAccessor) || this.parseObjectProperty(prop, startLoc, isPattern, refExpressionErrors);\n    if (!node) this.unexpected();\n    return node;\n  }\n  parsePropertyName(prop, refExpressionErrors) {\n    if (this.eat(0)) {\n      prop.computed = true;\n      prop.key = this.parseMaybeAssignAllowIn();\n      this.expect(3);\n    } else {\n      const {\n        type,\n        value\n      } = this.state;\n      let key;\n      if (tokenIsKeywordOrIdentifier(type)) {\n        key = this.parseIdentifier(true);\n      } else {\n        switch (type) {\n          case 135:\n            key = this.parseNumericLiteral(value);\n            break;\n          case 134:\n            key = this.parseStringLiteral(value);\n            break;\n          case 136:\n            key = this.parseBigIntLiteral(value);\n            break;\n          case 139:\n            {\n              const privateKeyLoc = this.state.startLoc;\n              if (refExpressionErrors != null) {\n                if (refExpressionErrors.privateKeyLoc === null) {\n                  refExpressionErrors.privateKeyLoc = privateKeyLoc;\n                }\n              } else {\n                this.raise(Errors.UnexpectedPrivateField, privateKeyLoc);\n              }\n              key = this.parsePrivateName();\n              break;\n            }\n          default:\n            if (type === 137) {\n              key = this.parseDecimalLiteral(value);\n              break;\n            }\n            this.unexpected();\n        }\n      }\n      prop.key = key;\n      if (type !== 139) {\n        prop.computed = false;\n      }\n    }\n  }\n  initFunction(node, isAsync) {\n    node.id = null;\n    node.generator = false;\n    node.async = isAsync;\n  }\n  parseMethod(node, isGenerator, isAsync, isConstructor, allowDirectSuper, type, inClassScope = false) {\n    this.initFunction(node, isAsync);\n    node.generator = isGenerator;\n    this.scope.enter(514 | 16 | (inClassScope ? 576 : 0) | (allowDirectSuper ? 32 : 0));\n    this.prodParam.enter(functionFlags(isAsync, node.generator));\n    this.parseFunctionParams(node, isConstructor);\n    const finishedNode = this.parseFunctionBodyAndFinish(node, type, true);\n    this.prodParam.exit();\n    this.scope.exit();\n    return finishedNode;\n  }\n  parseArrayLike(close, isTuple, refExpressionErrors) {\n    if (isTuple) {\n      this.expectPlugin(\"recordAndTuple\");\n    }\n    const oldInFSharpPipelineDirectBody = this.state.inFSharpPipelineDirectBody;\n    this.state.inFSharpPipelineDirectBody = false;\n    const node = this.startNode();\n    this.next();\n    node.elements = this.parseExprList(close, !isTuple, refExpressionErrors, node);\n    this.state.inFSharpPipelineDirectBody = oldInFSharpPipelineDirectBody;\n    return this.finishNode(node, isTuple ? \"TupleExpression\" : \"ArrayExpression\");\n  }\n  parseArrowExpression(node, params, isAsync, trailingCommaLoc) {\n    this.scope.enter(514 | 4);\n    let flags = functionFlags(isAsync, false);\n    if (!this.match(5) && this.prodParam.hasIn) {\n      flags |= 8;\n    }\n    this.prodParam.enter(flags);\n    this.initFunction(node, isAsync);\n    const oldMaybeInArrowParameters = this.state.maybeInArrowParameters;\n    if (params) {\n      this.state.maybeInArrowParameters = true;\n      this.setArrowFunctionParameters(node, params, trailingCommaLoc);\n    }\n    this.state.maybeInArrowParameters = false;\n    this.parseFunctionBody(node, true);\n    this.prodParam.exit();\n    this.scope.exit();\n    this.state.maybeInArrowParameters = oldMaybeInArrowParameters;\n    return this.finishNode(node, \"ArrowFunctionExpression\");\n  }\n  setArrowFunctionParameters(node, params, trailingCommaLoc) {\n    this.toAssignableList(params, trailingCommaLoc, false);\n    node.params = params;\n  }\n  parseFunctionBodyAndFinish(node, type, isMethod = false) {\n    this.parseFunctionBody(node, false, isMethod);\n    return this.finishNode(node, type);\n  }\n  parseFunctionBody(node, allowExpression, isMethod = false) {\n    const isExpression = allowExpression && !this.match(5);\n    this.expressionScope.enter(newExpressionScope());\n    if (isExpression) {\n      node.body = this.parseMaybeAssign();\n      this.checkParams(node, false, allowExpression, false);\n    } else {\n      const oldStrict = this.state.strict;\n      const oldLabels = this.state.labels;\n      this.state.labels = [];\n      this.prodParam.enter(this.prodParam.currentFlags() | 4);\n      node.body = this.parseBlock(true, false, hasStrictModeDirective => {\n        const nonSimple = !this.isSimpleParamList(node.params);\n        if (hasStrictModeDirective && nonSimple) {\n          this.raise(Errors.IllegalLanguageModeDirective, (node.kind === \"method\" || node.kind === \"constructor\") && !!node.key ? node.key.loc.end : node);\n        }\n        const strictModeChanged = !oldStrict && this.state.strict;\n        this.checkParams(node, !this.state.strict && !allowExpression && !isMethod && !nonSimple, allowExpression, strictModeChanged);\n        if (this.state.strict && node.id) {\n          this.checkIdentifier(node.id, 65, strictModeChanged);\n        }\n      });\n      this.prodParam.exit();\n      this.state.labels = oldLabels;\n    }\n    this.expressionScope.exit();\n  }\n  isSimpleParameter(node) {\n    return node.type === \"Identifier\";\n  }\n  isSimpleParamList(params) {\n    for (let i = 0, len = params.length; i < len; i++) {\n      if (!this.isSimpleParameter(params[i])) return false;\n    }\n    return true;\n  }\n  checkParams(node, allowDuplicates, isArrowFunction, strictModeChanged = true) {\n    const checkClashes = !allowDuplicates && new Set();\n    const formalParameters = {\n      type: \"FormalParameters\"\n    };\n    for (const param of node.params) {\n      this.checkLVal(param, formalParameters, 5, checkClashes, strictModeChanged);\n    }\n  }\n  parseExprList(close, allowEmpty, refExpressionErrors, nodeForExtra) {\n    const elts = [];\n    let first = true;\n    while (!this.eat(close)) {\n      if (first) {\n        first = false;\n      } else {\n        this.expect(12);\n        if (this.match(close)) {\n          if (nodeForExtra) {\n            this.addTrailingCommaExtraToNode(nodeForExtra);\n          }\n          this.next();\n          break;\n        }\n      }\n      elts.push(this.parseExprListItem(close, allowEmpty, refExpressionErrors));\n    }\n    return elts;\n  }\n  parseExprListItem(close, allowEmpty, refExpressionErrors, allowPlaceholder) {\n    let elt;\n    if (this.match(12)) {\n      if (!allowEmpty) {\n        this.raise(Errors.UnexpectedToken, this.state.curPosition(), {\n          unexpected: \",\"\n        });\n      }\n      elt = null;\n    } else if (this.match(21)) {\n      const spreadNodeStartLoc = this.state.startLoc;\n      elt = this.parseParenItem(this.parseSpread(refExpressionErrors), spreadNodeStartLoc);\n    } else if (this.match(17)) {\n      this.expectPlugin(\"partialApplication\");\n      if (!allowPlaceholder) {\n        this.raise(Errors.UnexpectedArgumentPlaceholder, this.state.startLoc);\n      }\n      const node = this.startNode();\n      this.next();\n      elt = this.finishNode(node, \"ArgumentPlaceholder\");\n    } else {\n      elt = this.parseMaybeAssignAllowInOrVoidPattern(close, refExpressionErrors, this.parseParenItem);\n    }\n    return elt;\n  }\n  parseIdentifier(liberal) {\n    const node = this.startNode();\n    const name = this.parseIdentifierName(liberal);\n    return this.createIdentifier(node, name);\n  }\n  createIdentifier(node, name) {\n    node.name = name;\n    node.loc.identifierName = name;\n    return this.finishNode(node, \"Identifier\");\n  }\n  createIdentifierAt(node, name, endLoc) {\n    node.name = name;\n    node.loc.identifierName = name;\n    return this.finishNodeAt(node, \"Identifier\", endLoc);\n  }\n  parseIdentifierName(liberal) {\n    let name;\n    const {\n      startLoc,\n      type\n    } = this.state;\n    if (tokenIsKeywordOrIdentifier(type)) {\n      name = this.state.value;\n    } else {\n      this.unexpected();\n    }\n    const tokenIsKeyword = tokenKeywordOrIdentifierIsKeyword(type);\n    if (liberal) {\n      if (tokenIsKeyword) {\n        this.replaceToken(132);\n      }\n    } else {\n      this.checkReservedWord(name, startLoc, tokenIsKeyword, false);\n    }\n    this.next();\n    return name;\n  }\n  checkReservedWord(word, startLoc, checkKeywords, isBinding) {\n    if (word.length > 10) {\n      return;\n    }\n    if (!canBeReservedWord(word)) {\n      return;\n    }\n    if (checkKeywords && isKeyword(word)) {\n      this.raise(Errors.UnexpectedKeyword, startLoc, {\n        keyword: word\n      });\n      return;\n    }\n    const reservedTest = !this.state.strict ? isReservedWord : isBinding ? isStrictBindReservedWord : isStrictReservedWord;\n    if (reservedTest(word, this.inModule)) {\n      this.raise(Errors.UnexpectedReservedWord, startLoc, {\n        reservedWord: word\n      });\n      return;\n    } else if (word === \"yield\") {\n      if (this.prodParam.hasYield) {\n        this.raise(Errors.YieldBindingIdentifier, startLoc);\n        return;\n      }\n    } else if (word === \"await\") {\n      if (this.prodParam.hasAwait) {\n        this.raise(Errors.AwaitBindingIdentifier, startLoc);\n        return;\n      }\n      if (this.scope.inStaticBlock) {\n        this.raise(Errors.AwaitBindingIdentifierInStaticBlock, startLoc);\n        return;\n      }\n      this.expressionScope.recordAsyncArrowParametersError(startLoc);\n    } else if (word === \"arguments\") {\n      if (this.scope.inClassAndNotInNonArrowFunction) {\n        this.raise(Errors.ArgumentsInClass, startLoc);\n        return;\n      }\n    }\n  }\n  recordAwaitIfAllowed() {\n    const isAwaitAllowed = this.prodParam.hasAwait;\n    if (isAwaitAllowed && !this.scope.inFunction) {\n      this.state.hasTopLevelAwait = true;\n    }\n    return isAwaitAllowed;\n  }\n  parseAwait(startLoc) {\n    const node = this.startNodeAt(startLoc);\n    this.expressionScope.recordParameterInitializerError(Errors.AwaitExpressionFormalParameter, node);\n    if (this.eat(55)) {\n      this.raise(Errors.ObsoleteAwaitStar, node);\n    }\n    if (!this.scope.inFunction && !(this.optionFlags & 1)) {\n      if (this.isAmbiguousPrefixOrIdentifier()) {\n        this.ambiguousScriptDifferentAst = true;\n      } else {\n        this.sawUnambiguousESM = true;\n      }\n    }\n    if (!this.state.soloAwait) {\n      node.argument = this.parseMaybeUnary(null, true);\n    }\n    return this.finishNode(node, \"AwaitExpression\");\n  }\n  isAmbiguousPrefixOrIdentifier() {\n    if (this.hasPrecedingLineBreak()) return true;\n    const {\n      type\n    } = this.state;\n    return type === 53 || type === 10 || type === 0 || tokenIsTemplate(type) || type === 102 && !this.state.containsEsc || type === 138 || type === 56 || this.hasPlugin(\"v8intrinsic\") && type === 54;\n  }\n  parseYield(startLoc) {\n    const node = this.startNodeAt(startLoc);\n    this.expressionScope.recordParameterInitializerError(Errors.YieldInParameter, node);\n    let delegating = false;\n    let argument = null;\n    if (!this.hasPrecedingLineBreak()) {\n      delegating = this.eat(55);\n      switch (this.state.type) {\n        case 13:\n        case 140:\n        case 8:\n        case 11:\n        case 3:\n        case 9:\n        case 14:\n        case 12:\n          if (!delegating) break;\n        default:\n          argument = this.parseMaybeAssign();\n      }\n    }\n    node.delegate = delegating;\n    node.argument = argument;\n    return this.finishNode(node, \"YieldExpression\");\n  }\n  parseImportCall(node) {\n    this.next();\n    node.source = this.parseMaybeAssignAllowIn();\n    node.options = null;\n    if (this.eat(12)) {\n      if (!this.match(11)) {\n        node.options = this.parseMaybeAssignAllowIn();\n        if (this.eat(12)) {\n          this.addTrailingCommaExtraToNode(node.options);\n          if (!this.match(11)) {\n            do {\n              this.parseMaybeAssignAllowIn();\n            } while (this.eat(12) && !this.match(11));\n            this.raise(Errors.ImportCallArity, node);\n          }\n        }\n      } else {\n        this.addTrailingCommaExtraToNode(node.source);\n      }\n    }\n    this.expect(11);\n    return this.finishNode(node, \"ImportExpression\");\n  }\n  checkPipelineAtInfixOperator(left, leftStartLoc) {\n    if (this.hasPlugin([\"pipelineOperator\", {\n      proposal: \"smart\"\n    }])) {\n      if (left.type === \"SequenceExpression\") {\n        this.raise(Errors.PipelineHeadSequenceExpression, leftStartLoc);\n      }\n    }\n  }\n  parseSmartPipelineBodyInStyle(childExpr, startLoc) {\n    if (this.isSimpleReference(childExpr)) {\n      const bodyNode = this.startNodeAt(startLoc);\n      bodyNode.callee = childExpr;\n      return this.finishNode(bodyNode, \"PipelineBareFunction\");\n    } else {\n      const bodyNode = this.startNodeAt(startLoc);\n      this.checkSmartPipeTopicBodyEarlyErrors(startLoc);\n      bodyNode.expression = childExpr;\n      return this.finishNode(bodyNode, \"PipelineTopicExpression\");\n    }\n  }\n  isSimpleReference(expression) {\n    switch (expression.type) {\n      case \"MemberExpression\":\n        return !expression.computed && this.isSimpleReference(expression.object);\n      case \"Identifier\":\n        return true;\n      default:\n        return false;\n    }\n  }\n  checkSmartPipeTopicBodyEarlyErrors(startLoc) {\n    if (this.match(19)) {\n      throw this.raise(Errors.PipelineBodyNoArrow, this.state.startLoc);\n    }\n    if (!this.topicReferenceWasUsedInCurrentContext()) {\n      this.raise(Errors.PipelineTopicUnused, startLoc);\n    }\n  }\n  withTopicBindingContext(callback) {\n    const outerContextTopicState = this.state.topicContext;\n    this.state.topicContext = {\n      maxNumOfResolvableTopics: 1,\n      maxTopicIndex: null\n    };\n    try {\n      return callback();\n    } finally {\n      this.state.topicContext = outerContextTopicState;\n    }\n  }\n  withSmartMixTopicForbiddingContext(callback) {\n    if (this.hasPlugin([\"pipelineOperator\", {\n      proposal: \"smart\"\n    }])) {\n      const outerContextTopicState = this.state.topicContext;\n      this.state.topicContext = {\n        maxNumOfResolvableTopics: 0,\n        maxTopicIndex: null\n      };\n      try {\n        return callback();\n      } finally {\n        this.state.topicContext = outerContextTopicState;\n      }\n    } else {\n      return callback();\n    }\n  }\n  withSoloAwaitPermittingContext(callback) {\n    const outerContextSoloAwaitState = this.state.soloAwait;\n    this.state.soloAwait = true;\n    try {\n      return callback();\n    } finally {\n      this.state.soloAwait = outerContextSoloAwaitState;\n    }\n  }\n  allowInAnd(callback) {\n    const flags = this.prodParam.currentFlags();\n    const prodParamToSet = 8 & ~flags;\n    if (prodParamToSet) {\n      this.prodParam.enter(flags | 8);\n      try {\n        return callback();\n      } finally {\n        this.prodParam.exit();\n      }\n    }\n    return callback();\n  }\n  disallowInAnd(callback) {\n    const flags = this.prodParam.currentFlags();\n    const prodParamToClear = 8 & flags;\n    if (prodParamToClear) {\n      this.prodParam.enter(flags & ~8);\n      try {\n        return callback();\n      } finally {\n        this.prodParam.exit();\n      }\n    }\n    return callback();\n  }\n  registerTopicReference() {\n    this.state.topicContext.maxTopicIndex = 0;\n  }\n  topicReferenceIsAllowedInCurrentContext() {\n    return this.state.topicContext.maxNumOfResolvableTopics >= 1;\n  }\n  topicReferenceWasUsedInCurrentContext() {\n    return this.state.topicContext.maxTopicIndex != null && this.state.topicContext.maxTopicIndex >= 0;\n  }\n  parseFSharpPipelineBody(prec) {\n    const startLoc = this.state.startLoc;\n    this.state.potentialArrowAt = this.state.start;\n    const oldInFSharpPipelineDirectBody = this.state.inFSharpPipelineDirectBody;\n    this.state.inFSharpPipelineDirectBody = true;\n    const ret = this.parseExprOp(this.parseMaybeUnaryOrPrivate(), startLoc, prec);\n    this.state.inFSharpPipelineDirectBody = oldInFSharpPipelineDirectBody;\n    return ret;\n  }\n  parseModuleExpression() {\n    this.expectPlugin(\"moduleBlocks\");\n    const node = this.startNode();\n    this.next();\n    if (!this.match(5)) {\n      this.unexpected(null, 5);\n    }\n    const program = this.startNodeAt(this.state.endLoc);\n    this.next();\n    const revertScopes = this.initializeScopes(true);\n    this.enterInitialScopes();\n    try {\n      node.body = this.parseProgram(program, 8, \"module\");\n    } finally {\n      revertScopes();\n    }\n    return this.finishNode(node, \"ModuleExpression\");\n  }\n  parseVoidPattern(refExpressionErrors) {\n    this.expectPlugin(\"discardBinding\");\n    const node = this.startNode();\n    if (refExpressionErrors != null) {\n      refExpressionErrors.voidPatternLoc = this.state.startLoc;\n    }\n    this.next();\n    return this.finishNode(node, \"VoidPattern\");\n  }\n  parseMaybeAssignAllowInOrVoidPattern(close, refExpressionErrors, afterLeftParse) {\n    if (refExpressionErrors != null && this.match(88)) {\n      const nextCode = this.lookaheadCharCode();\n      if (nextCode === 44 || nextCode === (close === 3 ? 93 : close === 8 ? 125 : 41) || nextCode === 61) {\n        return this.parseMaybeDefault(this.state.startLoc, this.parseVoidPattern(refExpressionErrors));\n      }\n    }\n    return this.parseMaybeAssignAllowIn(refExpressionErrors, afterLeftParse);\n  }\n  parsePropertyNamePrefixOperator(prop) {}\n}\nconst loopLabel = {\n    kind: 1\n  },\n  switchLabel = {\n    kind: 2\n  };\nconst loneSurrogate = /[\\uD800-\\uDFFF]/u;\nconst keywordRelationalOperator = /in(?:stanceof)?/y;\nfunction babel7CompatTokens(tokens, input, startIndex) {\n  for (let i = 0; i < tokens.length; i++) {\n    const token = tokens[i];\n    const {\n      type\n    } = token;\n    if (typeof type === \"number\") {\n      if (type === 139) {\n        const {\n          loc,\n          start,\n          value,\n          end\n        } = token;\n        const hashEndPos = start + 1;\n        const hashEndLoc = createPositionWithColumnOffset(loc.start, 1);\n        tokens.splice(i, 1, new Token({\n          type: getExportedToken(27),\n          value: \"#\",\n          start: start,\n          end: hashEndPos,\n          startLoc: loc.start,\n          endLoc: hashEndLoc\n        }), new Token({\n          type: getExportedToken(132),\n          value: value,\n          start: hashEndPos,\n          end: end,\n          startLoc: hashEndLoc,\n          endLoc: loc.end\n        }));\n        i++;\n        continue;\n      }\n      if (tokenIsTemplate(type)) {\n        const {\n          loc,\n          start,\n          value,\n          end\n        } = token;\n        const backquoteEnd = start + 1;\n        const backquoteEndLoc = createPositionWithColumnOffset(loc.start, 1);\n        let startToken;\n        if (input.charCodeAt(start - startIndex) === 96) {\n          startToken = new Token({\n            type: getExportedToken(22),\n            value: \"`\",\n            start: start,\n            end: backquoteEnd,\n            startLoc: loc.start,\n            endLoc: backquoteEndLoc\n          });\n        } else {\n          startToken = new Token({\n            type: getExportedToken(8),\n            value: \"}\",\n            start: start,\n            end: backquoteEnd,\n            startLoc: loc.start,\n            endLoc: backquoteEndLoc\n          });\n        }\n        let templateValue, templateElementEnd, templateElementEndLoc, endToken;\n        if (type === 24) {\n          templateElementEnd = end - 1;\n          templateElementEndLoc = createPositionWithColumnOffset(loc.end, -1);\n          templateValue = value === null ? null : value.slice(1, -1);\n          endToken = new Token({\n            type: getExportedToken(22),\n            value: \"`\",\n            start: templateElementEnd,\n            end: end,\n            startLoc: templateElementEndLoc,\n            endLoc: loc.end\n          });\n        } else {\n          templateElementEnd = end - 2;\n          templateElementEndLoc = createPositionWithColumnOffset(loc.end, -2);\n          templateValue = value === null ? null : value.slice(1, -2);\n          endToken = new Token({\n            type: getExportedToken(23),\n            value: \"${\",\n            start: templateElementEnd,\n            end: end,\n            startLoc: templateElementEndLoc,\n            endLoc: loc.end\n          });\n        }\n        tokens.splice(i, 1, startToken, new Token({\n          type: getExportedToken(20),\n          value: templateValue,\n          start: backquoteEnd,\n          end: templateElementEnd,\n          startLoc: backquoteEndLoc,\n          endLoc: templateElementEndLoc\n        }), endToken);\n        i += 2;\n        continue;\n      }\n      token.type = getExportedToken(type);\n    }\n  }\n  return tokens;\n}\nclass StatementParser extends ExpressionParser {\n  parseTopLevel(file, program) {\n    file.program = this.parseProgram(program, 140, this.options.sourceType === \"module\" ? \"module\" : \"script\");\n    file.comments = this.comments;\n    if (this.optionFlags & 256) {\n      file.tokens = babel7CompatTokens(this.tokens, this.input, this.startIndex);\n    }\n    return this.finishNode(file, \"File\");\n  }\n  parseProgram(program, end, sourceType) {\n    program.sourceType = sourceType;\n    program.interpreter = this.parseInterpreterDirective();\n    this.parseBlockBody(program, true, true, end);\n    if (this.inModule) {\n      if (!(this.optionFlags & 64) && this.scope.undefinedExports.size > 0) {\n        for (const [localName, at] of Array.from(this.scope.undefinedExports)) {\n          this.raise(Errors.ModuleExportUndefined, at, {\n            localName\n          });\n        }\n      }\n      this.addExtra(program, \"topLevelAwait\", this.state.hasTopLevelAwait);\n    }\n    let finishedProgram;\n    if (end === 140) {\n      finishedProgram = this.finishNode(program, \"Program\");\n    } else {\n      finishedProgram = this.finishNodeAt(program, \"Program\", createPositionWithColumnOffset(this.state.startLoc, -1));\n    }\n    return finishedProgram;\n  }\n  stmtToDirective(stmt) {\n    const directive = this.castNodeTo(stmt, \"Directive\");\n    const directiveLiteral = this.castNodeTo(stmt.expression, \"DirectiveLiteral\");\n    const expressionValue = directiveLiteral.value;\n    const raw = this.input.slice(this.offsetToSourcePos(directiveLiteral.start), this.offsetToSourcePos(directiveLiteral.end));\n    const val = directiveLiteral.value = raw.slice(1, -1);\n    this.addExtra(directiveLiteral, \"raw\", raw);\n    this.addExtra(directiveLiteral, \"rawValue\", val);\n    this.addExtra(directiveLiteral, \"expressionValue\", expressionValue);\n    directive.value = directiveLiteral;\n    delete stmt.expression;\n    return directive;\n  }\n  parseInterpreterDirective() {\n    if (!this.match(28)) {\n      return null;\n    }\n    const node = this.startNode();\n    node.value = this.state.value;\n    this.next();\n    return this.finishNode(node, \"InterpreterDirective\");\n  }\n  isLet() {\n    if (!this.isContextual(100)) {\n      return false;\n    }\n    return this.hasFollowingBindingAtom();\n  }\n  isUsing() {\n    if (!this.isContextual(107)) {\n      return false;\n    }\n    return this.nextTokenIsIdentifierOnSameLine();\n  }\n  isForUsing() {\n    if (!this.isContextual(107)) {\n      return false;\n    }\n    const next = this.nextTokenInLineStart();\n    const nextCh = this.codePointAtPos(next);\n    if (this.isUnparsedContextual(next, \"of\")) {\n      const nextCharAfterOf = this.lookaheadCharCodeSince(next + 2);\n      if (nextCharAfterOf !== 61 && nextCharAfterOf !== 58 && nextCharAfterOf !== 59) {\n        return false;\n      }\n    }\n    if (this.chStartsBindingIdentifier(nextCh, next) || this.isUnparsedContextual(next, \"void\")) {\n      return true;\n    }\n    return false;\n  }\n  nextTokenIsIdentifierOnSameLine() {\n    const next = this.nextTokenInLineStart();\n    const nextCh = this.codePointAtPos(next);\n    return this.chStartsBindingIdentifier(nextCh, next);\n  }\n  isAwaitUsing() {\n    if (!this.isContextual(96)) {\n      return false;\n    }\n    let next = this.nextTokenInLineStart();\n    if (this.isUnparsedContextual(next, \"using\")) {\n      next = this.nextTokenInLineStartSince(next + 5);\n      const nextCh = this.codePointAtPos(next);\n      if (this.chStartsBindingIdentifier(nextCh, next)) {\n        return true;\n      }\n    }\n    return false;\n  }\n  chStartsBindingIdentifier(ch, pos) {\n    if (isIdentifierStart(ch)) {\n      keywordRelationalOperator.lastIndex = pos;\n      if (keywordRelationalOperator.test(this.input)) {\n        const endCh = this.codePointAtPos(keywordRelationalOperator.lastIndex);\n        if (!isIdentifierChar(endCh) && endCh !== 92) {\n          return false;\n        }\n      }\n      return true;\n    } else if (ch === 92) {\n      return true;\n    } else {\n      return false;\n    }\n  }\n  chStartsBindingPattern(ch) {\n    return ch === 91 || ch === 123;\n  }\n  hasFollowingBindingAtom() {\n    const next = this.nextTokenStart();\n    const nextCh = this.codePointAtPos(next);\n    return this.chStartsBindingPattern(nextCh) || this.chStartsBindingIdentifier(nextCh, next);\n  }\n  hasInLineFollowingBindingIdentifierOrBrace() {\n    const next = this.nextTokenInLineStart();\n    const nextCh = this.codePointAtPos(next);\n    return nextCh === 123 || this.chStartsBindingIdentifier(nextCh, next);\n  }\n  allowsUsing() {\n    return (this.scope.inModule || !this.scope.inTopLevel) && !this.scope.inBareCaseStatement;\n  }\n  parseModuleItem() {\n    return this.parseStatementLike(1 | 2 | 4 | 8);\n  }\n  parseStatementListItem() {\n    return this.parseStatementLike(2 | 4 | (!this.options.annexB || this.state.strict ? 0 : 8));\n  }\n  parseStatementOrSloppyAnnexBFunctionDeclaration(allowLabeledFunction = false) {\n    let flags = 0;\n    if (this.options.annexB && !this.state.strict) {\n      flags |= 4;\n      if (allowLabeledFunction) {\n        flags |= 8;\n      }\n    }\n    return this.parseStatementLike(flags);\n  }\n  parseStatement() {\n    return this.parseStatementLike(0);\n  }\n  parseStatementLike(flags) {\n    let decorators = null;\n    if (this.match(26)) {\n      decorators = this.parseDecorators(true);\n    }\n    return this.parseStatementContent(flags, decorators);\n  }\n  parseStatementContent(flags, decorators) {\n    const startType = this.state.type;\n    const node = this.startNode();\n    const allowDeclaration = !!(flags & 2);\n    const allowFunctionDeclaration = !!(flags & 4);\n    const topLevel = flags & 1;\n    switch (startType) {\n      case 60:\n        return this.parseBreakContinueStatement(node, true);\n      case 63:\n        return this.parseBreakContinueStatement(node, false);\n      case 64:\n        return this.parseDebuggerStatement(node);\n      case 90:\n        return this.parseDoWhileStatement(node);\n      case 91:\n        return this.parseForStatement(node);\n      case 68:\n        if (this.lookaheadCharCode() === 46) break;\n        if (!allowFunctionDeclaration) {\n          this.raise(this.state.strict ? Errors.StrictFunction : this.options.annexB ? Errors.SloppyFunctionAnnexB : Errors.SloppyFunction, this.state.startLoc);\n        }\n        return this.parseFunctionStatement(node, false, !allowDeclaration && allowFunctionDeclaration);\n      case 80:\n        if (!allowDeclaration) this.unexpected();\n        return this.parseClass(this.maybeTakeDecorators(decorators, node), true);\n      case 69:\n        return this.parseIfStatement(node);\n      case 70:\n        return this.parseReturnStatement(node);\n      case 71:\n        return this.parseSwitchStatement(node);\n      case 72:\n        return this.parseThrowStatement(node);\n      case 73:\n        return this.parseTryStatement(node);\n      case 96:\n        if (this.isAwaitUsing()) {\n          if (!this.allowsUsing()) {\n            this.raise(Errors.UnexpectedUsingDeclaration, node);\n          } else if (!allowDeclaration) {\n            this.raise(Errors.UnexpectedLexicalDeclaration, node);\n          } else if (!this.recordAwaitIfAllowed()) {\n            this.raise(Errors.AwaitUsingNotInAsyncContext, node);\n          }\n          this.next();\n          return this.parseVarStatement(node, \"await using\");\n        }\n        break;\n      case 107:\n        if (this.state.containsEsc || !this.hasInLineFollowingBindingIdentifierOrBrace()) {\n          break;\n        }\n        if (!this.allowsUsing()) {\n          this.raise(Errors.UnexpectedUsingDeclaration, this.state.startLoc);\n        } else if (!allowDeclaration) {\n          this.raise(Errors.UnexpectedLexicalDeclaration, this.state.startLoc);\n        }\n        return this.parseVarStatement(node, \"using\");\n      case 100:\n        {\n          if (this.state.containsEsc) {\n            break;\n          }\n          const next = this.nextTokenStart();\n          const nextCh = this.codePointAtPos(next);\n          if (nextCh !== 91) {\n            if (!allowDeclaration && this.hasFollowingLineBreak()) break;\n            if (!this.chStartsBindingIdentifier(nextCh, next) && nextCh !== 123) {\n              break;\n            }\n          }\n        }\n      case 75:\n        {\n          if (!allowDeclaration) {\n            this.raise(Errors.UnexpectedLexicalDeclaration, this.state.startLoc);\n          }\n        }\n      case 74:\n        {\n          const kind = this.state.value;\n          return this.parseVarStatement(node, kind);\n        }\n      case 92:\n        return this.parseWhileStatement(node);\n      case 76:\n        return this.parseWithStatement(node);\n      case 5:\n        return this.parseBlock();\n      case 13:\n        return this.parseEmptyStatement(node);\n      case 83:\n        {\n          const nextTokenCharCode = this.lookaheadCharCode();\n          if (nextTokenCharCode === 40 || nextTokenCharCode === 46) {\n            break;\n          }\n        }\n      case 82:\n        {\n          if (!(this.optionFlags & 8) && !topLevel) {\n            this.raise(Errors.UnexpectedImportExport, this.state.startLoc);\n          }\n          this.next();\n          let result;\n          if (startType === 83) {\n            result = this.parseImport(node);\n          } else {\n            result = this.parseExport(node, decorators);\n          }\n          this.assertModuleNodeAllowed(result);\n          return result;\n        }\n      default:\n        {\n          if (this.isAsyncFunction()) {\n            if (!allowDeclaration) {\n              this.raise(Errors.AsyncFunctionInSingleStatementContext, this.state.startLoc);\n            }\n            this.next();\n            return this.parseFunctionStatement(node, true, !allowDeclaration && allowFunctionDeclaration);\n          }\n        }\n    }\n    const maybeName = this.state.value;\n    const expr = this.parseExpression();\n    if (tokenIsIdentifier(startType) && expr.type === \"Identifier\" && this.eat(14)) {\n      return this.parseLabeledStatement(node, maybeName, expr, flags);\n    } else {\n      return this.parseExpressionStatement(node, expr, decorators);\n    }\n  }\n  assertModuleNodeAllowed(node) {\n    if (!(this.optionFlags & 8) && !this.inModule) {\n      this.raise(Errors.ImportOutsideModule, node);\n    }\n  }\n  decoratorsEnabledBeforeExport() {\n    if (this.hasPlugin(\"decorators-legacy\")) return true;\n    return this.hasPlugin(\"decorators\") && this.getPluginOption(\"decorators\", \"decoratorsBeforeExport\") !== false;\n  }\n  maybeTakeDecorators(maybeDecorators, classNode, exportNode) {\n    if (maybeDecorators) {\n      var _classNode$decorators;\n      if ((_classNode$decorators = classNode.decorators) != null && _classNode$decorators.length) {\n        if (typeof this.getPluginOption(\"decorators\", \"decoratorsBeforeExport\") !== \"boolean\") {\n          this.raise(Errors.DecoratorsBeforeAfterExport, classNode.decorators[0]);\n        }\n        classNode.decorators.unshift(...maybeDecorators);\n      } else {\n        classNode.decorators = maybeDecorators;\n      }\n      this.resetStartLocationFromNode(classNode, maybeDecorators[0]);\n      if (exportNode) this.resetStartLocationFromNode(exportNode, classNode);\n    }\n    return classNode;\n  }\n  canHaveLeadingDecorator() {\n    return this.match(80);\n  }\n  parseDecorators(allowExport) {\n    const decorators = [];\n    do {\n      decorators.push(this.parseDecorator());\n    } while (this.match(26));\n    if (this.match(82)) {\n      if (!allowExport) {\n        this.unexpected();\n      }\n      if (!this.decoratorsEnabledBeforeExport()) {\n        this.raise(Errors.DecoratorExportClass, this.state.startLoc);\n      }\n    } else if (!this.canHaveLeadingDecorator()) {\n      throw this.raise(Errors.UnexpectedLeadingDecorator, this.state.startLoc);\n    }\n    return decorators;\n  }\n  parseDecorator() {\n    this.expectOnePlugin([\"decorators\", \"decorators-legacy\"]);\n    const node = this.startNode();\n    this.next();\n    if (this.hasPlugin(\"decorators\")) {\n      const startLoc = this.state.startLoc;\n      let expr;\n      if (this.match(10)) {\n        const startLoc = this.state.startLoc;\n        this.next();\n        expr = this.parseExpression();\n        this.expect(11);\n        expr = this.wrapParenthesis(startLoc, expr);\n        const paramsStartLoc = this.state.startLoc;\n        node.expression = this.parseMaybeDecoratorArguments(expr, startLoc);\n        if (this.getPluginOption(\"decorators\", \"allowCallParenthesized\") === false && node.expression !== expr) {\n          this.raise(Errors.DecoratorArgumentsOutsideParentheses, paramsStartLoc);\n        }\n      } else {\n        expr = this.parseIdentifier(false);\n        while (this.eat(16)) {\n          const node = this.startNodeAt(startLoc);\n          node.object = expr;\n          if (this.match(139)) {\n            this.classScope.usePrivateName(this.state.value, this.state.startLoc);\n            node.property = this.parsePrivateName();\n          } else {\n            node.property = this.parseIdentifier(true);\n          }\n          node.computed = false;\n          expr = this.finishNode(node, \"MemberExpression\");\n        }\n        node.expression = this.parseMaybeDecoratorArguments(expr, startLoc);\n      }\n    } else {\n      node.expression = this.parseExprSubscripts();\n    }\n    return this.finishNode(node, \"Decorator\");\n  }\n  parseMaybeDecoratorArguments(expr, startLoc) {\n    if (this.eat(10)) {\n      const node = this.startNodeAt(startLoc);\n      node.callee = expr;\n      node.arguments = this.parseCallExpressionArguments();\n      this.toReferencedList(node.arguments);\n      return this.finishNode(node, \"CallExpression\");\n    }\n    return expr;\n  }\n  parseBreakContinueStatement(node, isBreak) {\n    this.next();\n    if (this.isLineTerminator()) {\n      node.label = null;\n    } else {\n      node.label = this.parseIdentifier();\n      this.semicolon();\n    }\n    this.verifyBreakContinue(node, isBreak);\n    return this.finishNode(node, isBreak ? \"BreakStatement\" : \"ContinueStatement\");\n  }\n  verifyBreakContinue(node, isBreak) {\n    let i;\n    for (i = 0; i < this.state.labels.length; ++i) {\n      const lab = this.state.labels[i];\n      if (node.label == null || lab.name === node.label.name) {\n        if (lab.kind != null && (isBreak || lab.kind === 1)) {\n          break;\n        }\n        if (node.label && isBreak) break;\n      }\n    }\n    if (i === this.state.labels.length) {\n      const type = isBreak ? \"BreakStatement\" : \"ContinueStatement\";\n      this.raise(Errors.IllegalBreakContinue, node, {\n        type\n      });\n    }\n  }\n  parseDebuggerStatement(node) {\n    this.next();\n    this.semicolon();\n    return this.finishNode(node, \"DebuggerStatement\");\n  }\n  parseHeaderExpression() {\n    this.expect(10);\n    const val = this.parseExpression();\n    this.expect(11);\n    return val;\n  }\n  parseDoWhileStatement(node) {\n    this.next();\n    this.state.labels.push(loopLabel);\n    node.body = this.withSmartMixTopicForbiddingContext(() => this.parseStatement());\n    this.state.labels.pop();\n    this.expect(92);\n    node.test = this.parseHeaderExpression();\n    this.eat(13);\n    return this.finishNode(node, \"DoWhileStatement\");\n  }\n  parseForStatement(node) {\n    this.next();\n    this.state.labels.push(loopLabel);\n    let awaitAt = null;\n    if (this.isContextual(96) && this.recordAwaitIfAllowed()) {\n      awaitAt = this.state.startLoc;\n      this.next();\n    }\n    this.scope.enter(0);\n    this.expect(10);\n    if (this.match(13)) {\n      if (awaitAt !== null) {\n        this.unexpected(awaitAt);\n      }\n      return this.parseFor(node, null);\n    }\n    const startsWithLet = this.isContextual(100);\n    {\n      const startsWithAwaitUsing = this.isAwaitUsing();\n      const starsWithUsingDeclaration = startsWithAwaitUsing || this.isForUsing();\n      const isLetOrUsing = startsWithLet && this.hasFollowingBindingAtom() || starsWithUsingDeclaration;\n      if (this.match(74) || this.match(75) || isLetOrUsing) {\n        const initNode = this.startNode();\n        let kind;\n        if (startsWithAwaitUsing) {\n          kind = \"await using\";\n          if (!this.recordAwaitIfAllowed()) {\n            this.raise(Errors.AwaitUsingNotInAsyncContext, this.state.startLoc);\n          }\n          this.next();\n        } else {\n          kind = this.state.value;\n        }\n        this.next();\n        this.parseVar(initNode, true, kind);\n        const init = this.finishNode(initNode, \"VariableDeclaration\");\n        const isForIn = this.match(58);\n        if (isForIn && starsWithUsingDeclaration) {\n          this.raise(Errors.ForInUsing, init);\n        }\n        if ((isForIn || this.isContextual(102)) && init.declarations.length === 1) {\n          return this.parseForIn(node, init, awaitAt);\n        }\n        if (awaitAt !== null) {\n          this.unexpected(awaitAt);\n        }\n        return this.parseFor(node, init);\n      }\n    }\n    const startsWithAsync = this.isContextual(95);\n    const refExpressionErrors = new ExpressionErrors();\n    const init = this.parseExpression(true, refExpressionErrors);\n    const isForOf = this.isContextual(102);\n    if (isForOf) {\n      if (startsWithLet) {\n        this.raise(Errors.ForOfLet, init);\n      }\n      if (awaitAt === null && startsWithAsync && init.type === \"Identifier\") {\n        this.raise(Errors.ForOfAsync, init);\n      }\n    }\n    if (isForOf || this.match(58)) {\n      this.checkDestructuringPrivate(refExpressionErrors);\n      this.toAssignable(init, true);\n      const type = isForOf ? \"ForOfStatement\" : \"ForInStatement\";\n      this.checkLVal(init, {\n        type\n      });\n      return this.parseForIn(node, init, awaitAt);\n    } else {\n      this.checkExpressionErrors(refExpressionErrors, true);\n    }\n    if (awaitAt !== null) {\n      this.unexpected(awaitAt);\n    }\n    return this.parseFor(node, init);\n  }\n  parseFunctionStatement(node, isAsync, isHangingDeclaration) {\n    this.next();\n    return this.parseFunction(node, 1 | (isHangingDeclaration ? 2 : 0) | (isAsync ? 8 : 0));\n  }\n  parseIfStatement(node) {\n    this.next();\n    node.test = this.parseHeaderExpression();\n    node.consequent = this.parseStatementOrSloppyAnnexBFunctionDeclaration();\n    node.alternate = this.eat(66) ? this.parseStatementOrSloppyAnnexBFunctionDeclaration() : null;\n    return this.finishNode(node, \"IfStatement\");\n  }\n  parseReturnStatement(node) {\n    if (!this.prodParam.hasReturn) {\n      this.raise(Errors.IllegalReturn, this.state.startLoc);\n    }\n    this.next();\n    if (this.isLineTerminator()) {\n      node.argument = null;\n    } else {\n      node.argument = this.parseExpression();\n      this.semicolon();\n    }\n    return this.finishNode(node, \"ReturnStatement\");\n  }\n  parseSwitchStatement(node) {\n    this.next();\n    node.discriminant = this.parseHeaderExpression();\n    const cases = node.cases = [];\n    this.expect(5);\n    this.state.labels.push(switchLabel);\n    this.scope.enter(256);\n    let cur;\n    for (let sawDefault; !this.match(8);) {\n      if (this.match(61) || this.match(65)) {\n        const isCase = this.match(61);\n        if (cur) this.finishNode(cur, \"SwitchCase\");\n        cases.push(cur = this.startNode());\n        cur.consequent = [];\n        this.next();\n        if (isCase) {\n          cur.test = this.parseExpression();\n        } else {\n          if (sawDefault) {\n            this.raise(Errors.MultipleDefaultsInSwitch, this.state.lastTokStartLoc);\n          }\n          sawDefault = true;\n          cur.test = null;\n        }\n        this.expect(14);\n      } else {\n        if (cur) {\n          cur.consequent.push(this.parseStatementListItem());\n        } else {\n          this.unexpected();\n        }\n      }\n    }\n    this.scope.exit();\n    if (cur) this.finishNode(cur, \"SwitchCase\");\n    this.next();\n    this.state.labels.pop();\n    return this.finishNode(node, \"SwitchStatement\");\n  }\n  parseThrowStatement(node) {\n    this.next();\n    if (this.hasPrecedingLineBreak()) {\n      this.raise(Errors.NewlineAfterThrow, this.state.lastTokEndLoc);\n    }\n    node.argument = this.parseExpression();\n    this.semicolon();\n    return this.finishNode(node, \"ThrowStatement\");\n  }\n  parseCatchClauseParam() {\n    const param = this.parseBindingAtom();\n    this.scope.enter(this.options.annexB && param.type === \"Identifier\" ? 8 : 0);\n    this.checkLVal(param, {\n      type: \"CatchClause\"\n    }, 9);\n    return param;\n  }\n  parseTryStatement(node) {\n    this.next();\n    node.block = this.parseBlock();\n    node.handler = null;\n    if (this.match(62)) {\n      const clause = this.startNode();\n      this.next();\n      if (this.match(10)) {\n        this.expect(10);\n        clause.param = this.parseCatchClauseParam();\n        this.expect(11);\n      } else {\n        clause.param = null;\n        this.scope.enter(0);\n      }\n      clause.body = this.withSmartMixTopicForbiddingContext(() => this.parseBlock(false, false));\n      this.scope.exit();\n      node.handler = this.finishNode(clause, \"CatchClause\");\n    }\n    node.finalizer = this.eat(67) ? this.parseBlock() : null;\n    if (!node.handler && !node.finalizer) {\n      this.raise(Errors.NoCatchOrFinally, node);\n    }\n    return this.finishNode(node, \"TryStatement\");\n  }\n  parseVarStatement(node, kind, allowMissingInitializer = false) {\n    this.next();\n    this.parseVar(node, false, kind, allowMissingInitializer);\n    this.semicolon();\n    return this.finishNode(node, \"VariableDeclaration\");\n  }\n  parseWhileStatement(node) {\n    this.next();\n    node.test = this.parseHeaderExpression();\n    this.state.labels.push(loopLabel);\n    node.body = this.withSmartMixTopicForbiddingContext(() => this.parseStatement());\n    this.state.labels.pop();\n    return this.finishNode(node, \"WhileStatement\");\n  }\n  parseWithStatement(node) {\n    if (this.state.strict) {\n      this.raise(Errors.StrictWith, this.state.startLoc);\n    }\n    this.next();\n    node.object = this.parseHeaderExpression();\n    node.body = this.withSmartMixTopicForbiddingContext(() => this.parseStatement());\n    return this.finishNode(node, \"WithStatement\");\n  }\n  parseEmptyStatement(node) {\n    this.next();\n    return this.finishNode(node, \"EmptyStatement\");\n  }\n  parseLabeledStatement(node, maybeName, expr, flags) {\n    for (const label of this.state.labels) {\n      if (label.name === maybeName) {\n        this.raise(Errors.LabelRedeclaration, expr, {\n          labelName: maybeName\n        });\n      }\n    }\n    const kind = tokenIsLoop(this.state.type) ? 1 : this.match(71) ? 2 : null;\n    for (let i = this.state.labels.length - 1; i >= 0; i--) {\n      const label = this.state.labels[i];\n      if (label.statementStart === node.start) {\n        label.statementStart = this.sourceToOffsetPos(this.state.start);\n        label.kind = kind;\n      } else {\n        break;\n      }\n    }\n    this.state.labels.push({\n      name: maybeName,\n      kind: kind,\n      statementStart: this.sourceToOffsetPos(this.state.start)\n    });\n    node.body = flags & 8 ? this.parseStatementOrSloppyAnnexBFunctionDeclaration(true) : this.parseStatement();\n    this.state.labels.pop();\n    node.label = expr;\n    return this.finishNode(node, \"LabeledStatement\");\n  }\n  parseExpressionStatement(node, expr, decorators) {\n    node.expression = expr;\n    this.semicolon();\n    return this.finishNode(node, \"ExpressionStatement\");\n  }\n  parseBlock(allowDirectives = false, createNewLexicalScope = true, afterBlockParse) {\n    const node = this.startNode();\n    if (allowDirectives) {\n      this.state.strictErrors.clear();\n    }\n    this.expect(5);\n    if (createNewLexicalScope) {\n      this.scope.enter(0);\n    }\n    this.parseBlockBody(node, allowDirectives, false, 8, afterBlockParse);\n    if (createNewLexicalScope) {\n      this.scope.exit();\n    }\n    return this.finishNode(node, \"BlockStatement\");\n  }\n  isValidDirective(stmt) {\n    return stmt.type === \"ExpressionStatement\" && stmt.expression.type === \"StringLiteral\" && !stmt.expression.extra.parenthesized;\n  }\n  parseBlockBody(node, allowDirectives, topLevel, end, afterBlockParse) {\n    const body = node.body = [];\n    const directives = node.directives = [];\n    this.parseBlockOrModuleBlockBody(body, allowDirectives ? directives : undefined, topLevel, end, afterBlockParse);\n  }\n  parseBlockOrModuleBlockBody(body, directives, topLevel, end, afterBlockParse) {\n    const oldStrict = this.state.strict;\n    let hasStrictModeDirective = false;\n    let parsedNonDirective = false;\n    while (!this.match(end)) {\n      const stmt = topLevel ? this.parseModuleItem() : this.parseStatementListItem();\n      if (directives && !parsedNonDirective) {\n        if (this.isValidDirective(stmt)) {\n          const directive = this.stmtToDirective(stmt);\n          directives.push(directive);\n          if (!hasStrictModeDirective && directive.value.value === \"use strict\") {\n            hasStrictModeDirective = true;\n            this.setStrict(true);\n          }\n          continue;\n        }\n        parsedNonDirective = true;\n        this.state.strictErrors.clear();\n      }\n      body.push(stmt);\n    }\n    afterBlockParse == null || afterBlockParse.call(this, hasStrictModeDirective);\n    if (!oldStrict) {\n      this.setStrict(false);\n    }\n    this.next();\n  }\n  parseFor(node, init) {\n    node.init = init;\n    this.semicolon(false);\n    node.test = this.match(13) ? null : this.parseExpression();\n    this.semicolon(false);\n    node.update = this.match(11) ? null : this.parseExpression();\n    this.expect(11);\n    node.body = this.withSmartMixTopicForbiddingContext(() => this.parseStatement());\n    this.scope.exit();\n    this.state.labels.pop();\n    return this.finishNode(node, \"ForStatement\");\n  }\n  parseForIn(node, init, awaitAt) {\n    const isForIn = this.match(58);\n    this.next();\n    if (isForIn) {\n      if (awaitAt !== null) this.unexpected(awaitAt);\n    } else {\n      node.await = awaitAt !== null;\n    }\n    if (init.type === \"VariableDeclaration\" && init.declarations[0].init != null && (!isForIn || !this.options.annexB || this.state.strict || init.kind !== \"var\" || init.declarations[0].id.type !== \"Identifier\")) {\n      this.raise(Errors.ForInOfLoopInitializer, init, {\n        type: isForIn ? \"ForInStatement\" : \"ForOfStatement\"\n      });\n    }\n    if (init.type === \"AssignmentPattern\") {\n      this.raise(Errors.InvalidLhs, init, {\n        ancestor: {\n          type: \"ForStatement\"\n        }\n      });\n    }\n    node.left = init;\n    node.right = isForIn ? this.parseExpression() : this.parseMaybeAssignAllowIn();\n    this.expect(11);\n    node.body = this.withSmartMixTopicForbiddingContext(() => this.parseStatement());\n    this.scope.exit();\n    this.state.labels.pop();\n    return this.finishNode(node, isForIn ? \"ForInStatement\" : \"ForOfStatement\");\n  }\n  parseVar(node, isFor, kind, allowMissingInitializer = false) {\n    const declarations = node.declarations = [];\n    node.kind = kind;\n    for (;;) {\n      const decl = this.startNode();\n      this.parseVarId(decl, kind);\n      decl.init = !this.eat(29) ? null : isFor ? this.parseMaybeAssignDisallowIn() : this.parseMaybeAssignAllowIn();\n      if (decl.init === null && !allowMissingInitializer) {\n        if (decl.id.type !== \"Identifier\" && !(isFor && (this.match(58) || this.isContextual(102)))) {\n          this.raise(Errors.DeclarationMissingInitializer, this.state.lastTokEndLoc, {\n            kind: \"destructuring\"\n          });\n        } else if ((kind === \"const\" || kind === \"using\" || kind === \"await using\") && !(this.match(58) || this.isContextual(102))) {\n          this.raise(Errors.DeclarationMissingInitializer, this.state.lastTokEndLoc, {\n            kind\n          });\n        }\n      }\n      declarations.push(this.finishNode(decl, \"VariableDeclarator\"));\n      if (!this.eat(12)) break;\n    }\n    return node;\n  }\n  parseVarId(decl, kind) {\n    const id = this.parseBindingAtom();\n    if (kind === \"using\" || kind === \"await using\") {\n      if (id.type === \"ArrayPattern\" || id.type === \"ObjectPattern\") {\n        this.raise(Errors.UsingDeclarationHasBindingPattern, id.loc.start);\n      }\n    } else {\n      if (id.type === \"VoidPattern\") {\n        this.raise(Errors.UnexpectedVoidPattern, id.loc.start);\n      }\n    }\n    this.checkLVal(id, {\n      type: \"VariableDeclarator\"\n    }, kind === \"var\" ? 5 : 8201);\n    decl.id = id;\n  }\n  parseAsyncFunctionExpression(node) {\n    return this.parseFunction(node, 8);\n  }\n  parseFunction(node, flags = 0) {\n    const hangingDeclaration = flags & 2;\n    const isDeclaration = !!(flags & 1);\n    const requireId = isDeclaration && !(flags & 4);\n    const isAsync = !!(flags & 8);\n    this.initFunction(node, isAsync);\n    if (this.match(55)) {\n      if (hangingDeclaration) {\n        this.raise(Errors.GeneratorInSingleStatementContext, this.state.startLoc);\n      }\n      this.next();\n      node.generator = true;\n    }\n    if (isDeclaration) {\n      node.id = this.parseFunctionId(requireId);\n    }\n    const oldMaybeInArrowParameters = this.state.maybeInArrowParameters;\n    this.state.maybeInArrowParameters = false;\n    this.scope.enter(514);\n    this.prodParam.enter(functionFlags(isAsync, node.generator));\n    if (!isDeclaration) {\n      node.id = this.parseFunctionId();\n    }\n    this.parseFunctionParams(node, false);\n    this.withSmartMixTopicForbiddingContext(() => {\n      this.parseFunctionBodyAndFinish(node, isDeclaration ? \"FunctionDeclaration\" : \"FunctionExpression\");\n    });\n    this.prodParam.exit();\n    this.scope.exit();\n    if (isDeclaration && !hangingDeclaration) {\n      this.registerFunctionStatementId(node);\n    }\n    this.state.maybeInArrowParameters = oldMaybeInArrowParameters;\n    return node;\n  }\n  parseFunctionId(requireId) {\n    return requireId || tokenIsIdentifier(this.state.type) ? this.parseIdentifier() : null;\n  }\n  parseFunctionParams(node, isConstructor) {\n    this.expect(10);\n    this.expressionScope.enter(newParameterDeclarationScope());\n    node.params = this.parseBindingList(11, 41, 2 | (isConstructor ? 4 : 0));\n    this.expressionScope.exit();\n  }\n  registerFunctionStatementId(node) {\n    if (!node.id) return;\n    this.scope.declareName(node.id.name, !this.options.annexB || this.state.strict || node.generator || node.async ? this.scope.treatFunctionsAsVar ? 5 : 8201 : 17, node.id.loc.start);\n  }\n  parseClass(node, isStatement, optionalId) {\n    this.next();\n    const oldStrict = this.state.strict;\n    this.state.strict = true;\n    this.parseClassId(node, isStatement, optionalId);\n    this.parseClassSuper(node);\n    node.body = this.parseClassBody(!!node.superClass, oldStrict);\n    return this.finishNode(node, isStatement ? \"ClassDeclaration\" : \"ClassExpression\");\n  }\n  isClassProperty() {\n    return this.match(29) || this.match(13) || this.match(8);\n  }\n  isClassMethod() {\n    return this.match(10);\n  }\n  nameIsConstructor(key) {\n    return key.type === \"Identifier\" && key.name === \"constructor\" || key.type === \"StringLiteral\" && key.value === \"constructor\";\n  }\n  isNonstaticConstructor(method) {\n    return !method.computed && !method.static && this.nameIsConstructor(method.key);\n  }\n  parseClassBody(hadSuperClass, oldStrict) {\n    this.classScope.enter();\n    const state = {\n      hadConstructor: false,\n      hadSuperClass\n    };\n    let decorators = [];\n    const classBody = this.startNode();\n    classBody.body = [];\n    this.expect(5);\n    this.withSmartMixTopicForbiddingContext(() => {\n      while (!this.match(8)) {\n        if (this.eat(13)) {\n          if (decorators.length > 0) {\n            throw this.raise(Errors.DecoratorSemicolon, this.state.lastTokEndLoc);\n          }\n          continue;\n        }\n        if (this.match(26)) {\n          decorators.push(this.parseDecorator());\n          continue;\n        }\n        const member = this.startNode();\n        if (decorators.length) {\n          member.decorators = decorators;\n          this.resetStartLocationFromNode(member, decorators[0]);\n          decorators = [];\n        }\n        this.parseClassMember(classBody, member, state);\n        if (member.kind === \"constructor\" && member.decorators && member.decorators.length > 0) {\n          this.raise(Errors.DecoratorConstructor, member);\n        }\n      }\n    });\n    this.state.strict = oldStrict;\n    this.next();\n    if (decorators.length) {\n      throw this.raise(Errors.TrailingDecorator, this.state.startLoc);\n    }\n    this.classScope.exit();\n    return this.finishNode(classBody, \"ClassBody\");\n  }\n  parseClassMemberFromModifier(classBody, member) {\n    const key = this.parseIdentifier(true);\n    if (this.isClassMethod()) {\n      const method = member;\n      method.kind = \"method\";\n      method.computed = false;\n      method.key = key;\n      method.static = false;\n      this.pushClassMethod(classBody, method, false, false, false, false);\n      return true;\n    } else if (this.isClassProperty()) {\n      const prop = member;\n      prop.computed = false;\n      prop.key = key;\n      prop.static = false;\n      classBody.body.push(this.parseClassProperty(prop));\n      return true;\n    }\n    this.resetPreviousNodeTrailingComments(key);\n    return false;\n  }\n  parseClassMember(classBody, member, state) {\n    const isStatic = this.isContextual(106);\n    if (isStatic) {\n      if (this.parseClassMemberFromModifier(classBody, member)) {\n        return;\n      }\n      if (this.eat(5)) {\n        this.parseClassStaticBlock(classBody, member);\n        return;\n      }\n    }\n    this.parseClassMemberWithIsStatic(classBody, member, state, isStatic);\n  }\n  parseClassMemberWithIsStatic(classBody, member, state, isStatic) {\n    const publicMethod = member;\n    const privateMethod = member;\n    const publicProp = member;\n    const privateProp = member;\n    const accessorProp = member;\n    const method = publicMethod;\n    const publicMember = publicMethod;\n    member.static = isStatic;\n    this.parsePropertyNamePrefixOperator(member);\n    if (this.eat(55)) {\n      method.kind = \"method\";\n      const isPrivateName = this.match(139);\n      this.parseClassElementName(method);\n      this.parsePostMemberNameModifiers(method);\n      if (isPrivateName) {\n        this.pushClassPrivateMethod(classBody, privateMethod, true, false);\n        return;\n      }\n      if (this.isNonstaticConstructor(publicMethod)) {\n        this.raise(Errors.ConstructorIsGenerator, publicMethod.key);\n      }\n      this.pushClassMethod(classBody, publicMethod, true, false, false, false);\n      return;\n    }\n    const isContextual = !this.state.containsEsc && tokenIsIdentifier(this.state.type);\n    const key = this.parseClassElementName(member);\n    const maybeContextualKw = isContextual ? key.name : null;\n    const isPrivate = this.isPrivateName(key);\n    const maybeQuestionTokenStartLoc = this.state.startLoc;\n    this.parsePostMemberNameModifiers(publicMember);\n    if (this.isClassMethod()) {\n      method.kind = \"method\";\n      if (isPrivate) {\n        this.pushClassPrivateMethod(classBody, privateMethod, false, false);\n        return;\n      }\n      const isConstructor = this.isNonstaticConstructor(publicMethod);\n      let allowsDirectSuper = false;\n      if (isConstructor) {\n        publicMethod.kind = \"constructor\";\n        if (state.hadConstructor && !this.hasPlugin(\"typescript\")) {\n          this.raise(Errors.DuplicateConstructor, key);\n        }\n        if (isConstructor && this.hasPlugin(\"typescript\") && member.override) {\n          this.raise(Errors.OverrideOnConstructor, key);\n        }\n        state.hadConstructor = true;\n        allowsDirectSuper = state.hadSuperClass;\n      }\n      this.pushClassMethod(classBody, publicMethod, false, false, isConstructor, allowsDirectSuper);\n    } else if (this.isClassProperty()) {\n      if (isPrivate) {\n        this.pushClassPrivateProperty(classBody, privateProp);\n      } else {\n        this.pushClassProperty(classBody, publicProp);\n      }\n    } else if (maybeContextualKw === \"async\" && !this.isLineTerminator()) {\n      this.resetPreviousNodeTrailingComments(key);\n      const isGenerator = this.eat(55);\n      if (publicMember.optional) {\n        this.unexpected(maybeQuestionTokenStartLoc);\n      }\n      method.kind = \"method\";\n      const isPrivate = this.match(139);\n      this.parseClassElementName(method);\n      this.parsePostMemberNameModifiers(publicMember);\n      if (isPrivate) {\n        this.pushClassPrivateMethod(classBody, privateMethod, isGenerator, true);\n      } else {\n        if (this.isNonstaticConstructor(publicMethod)) {\n          this.raise(Errors.ConstructorIsAsync, publicMethod.key);\n        }\n        this.pushClassMethod(classBody, publicMethod, isGenerator, true, false, false);\n      }\n    } else if ((maybeContextualKw === \"get\" || maybeContextualKw === \"set\") && !(this.match(55) && this.isLineTerminator())) {\n      this.resetPreviousNodeTrailingComments(key);\n      method.kind = maybeContextualKw;\n      const isPrivate = this.match(139);\n      this.parseClassElementName(publicMethod);\n      if (isPrivate) {\n        this.pushClassPrivateMethod(classBody, privateMethod, false, false);\n      } else {\n        if (this.isNonstaticConstructor(publicMethod)) {\n          this.raise(Errors.ConstructorIsAccessor, publicMethod.key);\n        }\n        this.pushClassMethod(classBody, publicMethod, false, false, false, false);\n      }\n      this.checkGetterSetterParams(publicMethod);\n    } else if (maybeContextualKw === \"accessor\" && !this.isLineTerminator()) {\n      this.expectPlugin(\"decoratorAutoAccessors\");\n      this.resetPreviousNodeTrailingComments(key);\n      const isPrivate = this.match(139);\n      this.parseClassElementName(publicProp);\n      this.pushClassAccessorProperty(classBody, accessorProp, isPrivate);\n    } else if (this.isLineTerminator()) {\n      if (isPrivate) {\n        this.pushClassPrivateProperty(classBody, privateProp);\n      } else {\n        this.pushClassProperty(classBody, publicProp);\n      }\n    } else {\n      this.unexpected();\n    }\n  }\n  parseClassElementName(member) {\n    const {\n      type,\n      value\n    } = this.state;\n    if ((type === 132 || type === 134) && member.static && value === \"prototype\") {\n      this.raise(Errors.StaticPrototype, this.state.startLoc);\n    }\n    if (type === 139) {\n      if (value === \"constructor\") {\n        this.raise(Errors.ConstructorClassPrivateField, this.state.startLoc);\n      }\n      const key = this.parsePrivateName();\n      member.key = key;\n      return key;\n    }\n    this.parsePropertyName(member);\n    return member.key;\n  }\n  parseClassStaticBlock(classBody, member) {\n    var _member$decorators;\n    this.scope.enter(576 | 128 | 16);\n    const oldLabels = this.state.labels;\n    this.state.labels = [];\n    this.prodParam.enter(0);\n    const body = member.body = [];\n    this.parseBlockOrModuleBlockBody(body, undefined, false, 8);\n    this.prodParam.exit();\n    this.scope.exit();\n    this.state.labels = oldLabels;\n    classBody.body.push(this.finishNode(member, \"StaticBlock\"));\n    if ((_member$decorators = member.decorators) != null && _member$decorators.length) {\n      this.raise(Errors.DecoratorStaticBlock, member);\n    }\n  }\n  pushClassProperty(classBody, prop) {\n    if (!prop.computed && this.nameIsConstructor(prop.key)) {\n      this.raise(Errors.ConstructorClassField, prop.key);\n    }\n    classBody.body.push(this.parseClassProperty(prop));\n  }\n  pushClassPrivateProperty(classBody, prop) {\n    const node = this.parseClassPrivateProperty(prop);\n    classBody.body.push(node);\n    this.classScope.declarePrivateName(this.getPrivateNameSV(node.key), 0, node.key.loc.start);\n  }\n  pushClassAccessorProperty(classBody, prop, isPrivate) {\n    if (!isPrivate && !prop.computed && this.nameIsConstructor(prop.key)) {\n      this.raise(Errors.ConstructorClassField, prop.key);\n    }\n    const node = this.parseClassAccessorProperty(prop);\n    classBody.body.push(node);\n    if (isPrivate) {\n      this.classScope.declarePrivateName(this.getPrivateNameSV(node.key), 0, node.key.loc.start);\n    }\n  }\n  pushClassMethod(classBody, method, isGenerator, isAsync, isConstructor, allowsDirectSuper) {\n    classBody.body.push(this.parseMethod(method, isGenerator, isAsync, isConstructor, allowsDirectSuper, \"ClassMethod\", true));\n  }\n  pushClassPrivateMethod(classBody, method, isGenerator, isAsync) {\n    const node = this.parseMethod(method, isGenerator, isAsync, false, false, \"ClassPrivateMethod\", true);\n    classBody.body.push(node);\n    const kind = node.kind === \"get\" ? node.static ? 6 : 2 : node.kind === \"set\" ? node.static ? 5 : 1 : 0;\n    this.declareClassPrivateMethodInScope(node, kind);\n  }\n  declareClassPrivateMethodInScope(node, kind) {\n    this.classScope.declarePrivateName(this.getPrivateNameSV(node.key), kind, node.key.loc.start);\n  }\n  parsePostMemberNameModifiers(methodOrProp) {}\n  parseClassPrivateProperty(node) {\n    this.parseInitializer(node);\n    this.semicolon();\n    return this.finishNode(node, \"ClassPrivateProperty\");\n  }\n  parseClassProperty(node) {\n    this.parseInitializer(node);\n    this.semicolon();\n    return this.finishNode(node, \"ClassProperty\");\n  }\n  parseClassAccessorProperty(node) {\n    this.parseInitializer(node);\n    this.semicolon();\n    return this.finishNode(node, \"ClassAccessorProperty\");\n  }\n  parseInitializer(node) {\n    this.scope.enter(576 | 16);\n    this.expressionScope.enter(newExpressionScope());\n    this.prodParam.enter(0);\n    node.value = this.eat(29) ? this.parseMaybeAssignAllowIn() : null;\n    this.expressionScope.exit();\n    this.prodParam.exit();\n    this.scope.exit();\n  }\n  parseClassId(node, isStatement, optionalId, bindingType = 8331) {\n    if (tokenIsIdentifier(this.state.type)) {\n      node.id = this.parseIdentifier();\n      if (isStatement) {\n        this.declareNameFromIdentifier(node.id, bindingType);\n      }\n    } else {\n      if (optionalId || !isStatement) {\n        node.id = null;\n      } else {\n        throw this.raise(Errors.MissingClassName, this.state.startLoc);\n      }\n    }\n  }\n  parseClassSuper(node) {\n    node.superClass = this.eat(81) ? this.parseExprSubscripts() : null;\n  }\n  parseExport(node, decorators) {\n    const maybeDefaultIdentifier = this.parseMaybeImportPhase(node, true);\n    const hasDefault = this.maybeParseExportDefaultSpecifier(node, maybeDefaultIdentifier);\n    const parseAfterDefault = !hasDefault || this.eat(12);\n    const hasStar = parseAfterDefault && this.eatExportStar(node);\n    const hasNamespace = hasStar && this.maybeParseExportNamespaceSpecifier(node);\n    const parseAfterNamespace = parseAfterDefault && (!hasNamespace || this.eat(12));\n    const isFromRequired = hasDefault || hasStar;\n    if (hasStar && !hasNamespace) {\n      if (hasDefault) this.unexpected();\n      if (decorators) {\n        throw this.raise(Errors.UnsupportedDecoratorExport, node);\n      }\n      this.parseExportFrom(node, true);\n      this.sawUnambiguousESM = true;\n      return this.finishNode(node, \"ExportAllDeclaration\");\n    }\n    const hasSpecifiers = this.maybeParseExportNamedSpecifiers(node);\n    if (hasDefault && parseAfterDefault && !hasStar && !hasSpecifiers) {\n      this.unexpected(null, 5);\n    }\n    if (hasNamespace && parseAfterNamespace) {\n      this.unexpected(null, 98);\n    }\n    let hasDeclaration;\n    if (isFromRequired || hasSpecifiers) {\n      hasDeclaration = false;\n      if (decorators) {\n        throw this.raise(Errors.UnsupportedDecoratorExport, node);\n      }\n      this.parseExportFrom(node, isFromRequired);\n    } else {\n      hasDeclaration = this.maybeParseExportDeclaration(node);\n    }\n    if (isFromRequired || hasSpecifiers || hasDeclaration) {\n      var _node2$declaration;\n      const node2 = node;\n      this.checkExport(node2, true, false, !!node2.source);\n      if (((_node2$declaration = node2.declaration) == null ? void 0 : _node2$declaration.type) === \"ClassDeclaration\") {\n        this.maybeTakeDecorators(decorators, node2.declaration, node2);\n      } else if (decorators) {\n        throw this.raise(Errors.UnsupportedDecoratorExport, node);\n      }\n      this.sawUnambiguousESM = true;\n      return this.finishNode(node2, \"ExportNamedDeclaration\");\n    }\n    if (this.eat(65)) {\n      const node2 = node;\n      const decl = this.parseExportDefaultExpression();\n      node2.declaration = decl;\n      if (decl.type === \"ClassDeclaration\") {\n        this.maybeTakeDecorators(decorators, decl, node2);\n      } else if (decorators) {\n        throw this.raise(Errors.UnsupportedDecoratorExport, node);\n      }\n      this.checkExport(node2, true, true);\n      this.sawUnambiguousESM = true;\n      return this.finishNode(node2, \"ExportDefaultDeclaration\");\n    }\n    throw this.unexpected(null, 5);\n  }\n  eatExportStar(node) {\n    return this.eat(55);\n  }\n  maybeParseExportDefaultSpecifier(node, maybeDefaultIdentifier) {\n    if (maybeDefaultIdentifier || this.isExportDefaultSpecifier()) {\n      this.expectPlugin(\"exportDefaultFrom\", maybeDefaultIdentifier == null ? void 0 : maybeDefaultIdentifier.loc.start);\n      const id = maybeDefaultIdentifier || this.parseIdentifier(true);\n      const specifier = this.startNodeAtNode(id);\n      specifier.exported = id;\n      node.specifiers = [this.finishNode(specifier, \"ExportDefaultSpecifier\")];\n      return true;\n    }\n    return false;\n  }\n  maybeParseExportNamespaceSpecifier(node) {\n    if (this.isContextual(93)) {\n      var _ref, _ref$specifiers;\n      (_ref$specifiers = (_ref = node).specifiers) != null ? _ref$specifiers : _ref.specifiers = [];\n      const specifier = this.startNodeAt(this.state.lastTokStartLoc);\n      this.next();\n      specifier.exported = this.parseModuleExportName();\n      node.specifiers.push(this.finishNode(specifier, \"ExportNamespaceSpecifier\"));\n      return true;\n    }\n    return false;\n  }\n  maybeParseExportNamedSpecifiers(node) {\n    if (this.match(5)) {\n      const node2 = node;\n      if (!node2.specifiers) node2.specifiers = [];\n      const isTypeExport = node2.exportKind === \"type\";\n      node2.specifiers.push(...this.parseExportSpecifiers(isTypeExport));\n      node2.source = null;\n      if (this.hasPlugin(\"importAssertions\")) {\n        node2.assertions = [];\n      } else {\n        node2.attributes = [];\n      }\n      node2.declaration = null;\n      return true;\n    }\n    return false;\n  }\n  maybeParseExportDeclaration(node) {\n    if (this.shouldParseExportDeclaration()) {\n      node.specifiers = [];\n      node.source = null;\n      if (this.hasPlugin(\"importAssertions\")) {\n        node.assertions = [];\n      } else {\n        node.attributes = [];\n      }\n      node.declaration = this.parseExportDeclaration(node);\n      return true;\n    }\n    return false;\n  }\n  isAsyncFunction() {\n    if (!this.isContextual(95)) return false;\n    const next = this.nextTokenInLineStart();\n    return this.isUnparsedContextual(next, \"function\");\n  }\n  parseExportDefaultExpression() {\n    const expr = this.startNode();\n    if (this.match(68)) {\n      this.next();\n      return this.parseFunction(expr, 1 | 4);\n    } else if (this.isAsyncFunction()) {\n      this.next();\n      this.next();\n      return this.parseFunction(expr, 1 | 4 | 8);\n    }\n    if (this.match(80)) {\n      return this.parseClass(expr, true, true);\n    }\n    if (this.match(26)) {\n      if (this.hasPlugin(\"decorators\") && this.getPluginOption(\"decorators\", \"decoratorsBeforeExport\") === true) {\n        this.raise(Errors.DecoratorBeforeExport, this.state.startLoc);\n      }\n      return this.parseClass(this.maybeTakeDecorators(this.parseDecorators(false), this.startNode()), true, true);\n    }\n    if (this.match(75) || this.match(74) || this.isLet() || this.isUsing() || this.isAwaitUsing()) {\n      throw this.raise(Errors.UnsupportedDefaultExport, this.state.startLoc);\n    }\n    const res = this.parseMaybeAssignAllowIn();\n    this.semicolon();\n    return res;\n  }\n  parseExportDeclaration(node) {\n    if (this.match(80)) {\n      const node = this.parseClass(this.startNode(), true, false);\n      return node;\n    }\n    return this.parseStatementListItem();\n  }\n  isExportDefaultSpecifier() {\n    const {\n      type\n    } = this.state;\n    if (tokenIsIdentifier(type)) {\n      if (type === 95 && !this.state.containsEsc || type === 100) {\n        return false;\n      }\n      if ((type === 130 || type === 129) && !this.state.containsEsc) {\n        const next = this.nextTokenStart();\n        const nextChar = this.input.charCodeAt(next);\n        if (nextChar === 123 || this.chStartsBindingIdentifier(nextChar, next) && !this.input.startsWith(\"from\", next)) {\n          this.expectOnePlugin([\"flow\", \"typescript\"]);\n          return false;\n        }\n      }\n    } else if (!this.match(65)) {\n      return false;\n    }\n    const next = this.nextTokenStart();\n    const hasFrom = this.isUnparsedContextual(next, \"from\");\n    if (this.input.charCodeAt(next) === 44 || tokenIsIdentifier(this.state.type) && hasFrom) {\n      return true;\n    }\n    if (this.match(65) && hasFrom) {\n      const nextAfterFrom = this.input.charCodeAt(this.nextTokenStartSince(next + 4));\n      return nextAfterFrom === 34 || nextAfterFrom === 39;\n    }\n    return false;\n  }\n  parseExportFrom(node, expect) {\n    if (this.eatContextual(98)) {\n      node.source = this.parseImportSource();\n      this.checkExport(node);\n      this.maybeParseImportAttributes(node);\n      this.checkJSONModuleImport(node);\n    } else if (expect) {\n      this.unexpected();\n    }\n    this.semicolon();\n  }\n  shouldParseExportDeclaration() {\n    const {\n      type\n    } = this.state;\n    if (type === 26) {\n      this.expectOnePlugin([\"decorators\", \"decorators-legacy\"]);\n      if (this.hasPlugin(\"decorators\")) {\n        if (this.getPluginOption(\"decorators\", \"decoratorsBeforeExport\") === true) {\n          this.raise(Errors.DecoratorBeforeExport, this.state.startLoc);\n        }\n        return true;\n      }\n    }\n    if (this.isUsing()) {\n      this.raise(Errors.UsingDeclarationExport, this.state.startLoc);\n      return true;\n    }\n    if (this.isAwaitUsing()) {\n      this.raise(Errors.UsingDeclarationExport, this.state.startLoc);\n      return true;\n    }\n    return type === 74 || type === 75 || type === 68 || type === 80 || this.isLet() || this.isAsyncFunction();\n  }\n  checkExport(node, checkNames, isDefault, isFrom) {\n    if (checkNames) {\n      var _node$specifiers;\n      if (isDefault) {\n        this.checkDuplicateExports(node, \"default\");\n        if (this.hasPlugin(\"exportDefaultFrom\")) {\n          var _declaration$extra;\n          const declaration = node.declaration;\n          if (declaration.type === \"Identifier\" && declaration.name === \"from\" && declaration.end - declaration.start === 4 && !((_declaration$extra = declaration.extra) != null && _declaration$extra.parenthesized)) {\n            this.raise(Errors.ExportDefaultFromAsIdentifier, declaration);\n          }\n        }\n      } else if ((_node$specifiers = node.specifiers) != null && _node$specifiers.length) {\n        for (const specifier of node.specifiers) {\n          const {\n            exported\n          } = specifier;\n          const exportName = exported.type === \"Identifier\" ? exported.name : exported.value;\n          this.checkDuplicateExports(specifier, exportName);\n          if (!isFrom && specifier.local) {\n            const {\n              local\n            } = specifier;\n            if (local.type !== \"Identifier\") {\n              this.raise(Errors.ExportBindingIsString, specifier, {\n                localName: local.value,\n                exportName\n              });\n            } else {\n              this.checkReservedWord(local.name, local.loc.start, true, false);\n              this.scope.checkLocalExport(local);\n            }\n          }\n        }\n      } else if (node.declaration) {\n        const decl = node.declaration;\n        if (decl.type === \"FunctionDeclaration\" || decl.type === \"ClassDeclaration\") {\n          const {\n            id\n          } = decl;\n          if (!id) throw new Error(\"Assertion failure\");\n          this.checkDuplicateExports(node, id.name);\n        } else if (decl.type === \"VariableDeclaration\") {\n          for (const declaration of decl.declarations) {\n            this.checkDeclaration(declaration.id);\n          }\n        }\n      }\n    }\n  }\n  checkDeclaration(node) {\n    if (node.type === \"Identifier\") {\n      this.checkDuplicateExports(node, node.name);\n    } else if (node.type === \"ObjectPattern\") {\n      for (const prop of node.properties) {\n        this.checkDeclaration(prop);\n      }\n    } else if (node.type === \"ArrayPattern\") {\n      for (const elem of node.elements) {\n        if (elem) {\n          this.checkDeclaration(elem);\n        }\n      }\n    } else if (node.type === \"ObjectProperty\") {\n      this.checkDeclaration(node.value);\n    } else if (node.type === \"RestElement\") {\n      this.checkDeclaration(node.argument);\n    } else if (node.type === \"AssignmentPattern\") {\n      this.checkDeclaration(node.left);\n    }\n  }\n  checkDuplicateExports(node, exportName) {\n    if (this.exportedIdentifiers.has(exportName)) {\n      if (exportName === \"default\") {\n        this.raise(Errors.DuplicateDefaultExport, node);\n      } else {\n        this.raise(Errors.DuplicateExport, node, {\n          exportName\n        });\n      }\n    }\n    this.exportedIdentifiers.add(exportName);\n  }\n  parseExportSpecifiers(isInTypeExport) {\n    const nodes = [];\n    let first = true;\n    this.expect(5);\n    while (!this.eat(8)) {\n      if (first) {\n        first = false;\n      } else {\n        this.expect(12);\n        if (this.eat(8)) break;\n      }\n      const isMaybeTypeOnly = this.isContextual(130);\n      const isString = this.match(134);\n      const node = this.startNode();\n      node.local = this.parseModuleExportName();\n      nodes.push(this.parseExportSpecifier(node, isString, isInTypeExport, isMaybeTypeOnly));\n    }\n    return nodes;\n  }\n  parseExportSpecifier(node, isString, isInTypeExport, isMaybeTypeOnly) {\n    if (this.eatContextual(93)) {\n      node.exported = this.parseModuleExportName();\n    } else if (isString) {\n      node.exported = this.cloneStringLiteral(node.local);\n    } else if (!node.exported) {\n      node.exported = this.cloneIdentifier(node.local);\n    }\n    return this.finishNode(node, \"ExportSpecifier\");\n  }\n  parseModuleExportName() {\n    if (this.match(134)) {\n      const result = this.parseStringLiteral(this.state.value);\n      const surrogate = loneSurrogate.exec(result.value);\n      if (surrogate) {\n        this.raise(Errors.ModuleExportNameHasLoneSurrogate, result, {\n          surrogateCharCode: surrogate[0].charCodeAt(0)\n        });\n      }\n      return result;\n    }\n    return this.parseIdentifier(true);\n  }\n  isJSONModuleImport(node) {\n    if (node.assertions != null) {\n      return node.assertions.some(({\n        key,\n        value\n      }) => {\n        return value.value === \"json\" && (key.type === \"Identifier\" ? key.name === \"type\" : key.value === \"type\");\n      });\n    }\n    return false;\n  }\n  checkImportReflection(node) {\n    const {\n      specifiers\n    } = node;\n    const singleBindingType = specifiers.length === 1 ? specifiers[0].type : null;\n    if (node.phase === \"source\") {\n      if (singleBindingType !== \"ImportDefaultSpecifier\") {\n        this.raise(Errors.SourcePhaseImportRequiresDefault, specifiers[0].loc.start);\n      }\n    } else if (node.phase === \"defer\") {\n      if (singleBindingType !== \"ImportNamespaceSpecifier\") {\n        this.raise(Errors.DeferImportRequiresNamespace, specifiers[0].loc.start);\n      }\n    } else if (node.module) {\n      var _node$assertions;\n      if (singleBindingType !== \"ImportDefaultSpecifier\") {\n        this.raise(Errors.ImportReflectionNotBinding, specifiers[0].loc.start);\n      }\n      if (((_node$assertions = node.assertions) == null ? void 0 : _node$assertions.length) > 0) {\n        this.raise(Errors.ImportReflectionHasAssertion, specifiers[0].loc.start);\n      }\n    }\n  }\n  checkJSONModuleImport(node) {\n    if (this.isJSONModuleImport(node) && node.type !== \"ExportAllDeclaration\") {\n      const {\n        specifiers\n      } = node;\n      if (specifiers != null) {\n        const nonDefaultNamedSpecifier = specifiers.find(specifier => {\n          let imported;\n          if (specifier.type === \"ExportSpecifier\") {\n            imported = specifier.local;\n          } else if (specifier.type === \"ImportSpecifier\") {\n            imported = specifier.imported;\n          }\n          if (imported !== undefined) {\n            return imported.type === \"Identifier\" ? imported.name !== \"default\" : imported.value !== \"default\";\n          }\n        });\n        if (nonDefaultNamedSpecifier !== undefined) {\n          this.raise(Errors.ImportJSONBindingNotDefault, nonDefaultNamedSpecifier.loc.start);\n        }\n      }\n    }\n  }\n  isPotentialImportPhase(isExport) {\n    if (isExport) return false;\n    return this.isContextual(105) || this.isContextual(97) || this.isContextual(127);\n  }\n  applyImportPhase(node, isExport, phase, loc) {\n    if (isExport) {\n      return;\n    }\n    if (phase === \"module\") {\n      this.expectPlugin(\"importReflection\", loc);\n      node.module = true;\n    } else if (this.hasPlugin(\"importReflection\")) {\n      node.module = false;\n    }\n    if (phase === \"source\") {\n      this.expectPlugin(\"sourcePhaseImports\", loc);\n      node.phase = \"source\";\n    } else if (phase === \"defer\") {\n      this.expectPlugin(\"deferredImportEvaluation\", loc);\n      node.phase = \"defer\";\n    } else if (this.hasPlugin(\"sourcePhaseImports\")) {\n      node.phase = null;\n    }\n  }\n  parseMaybeImportPhase(node, isExport) {\n    if (!this.isPotentialImportPhase(isExport)) {\n      this.applyImportPhase(node, isExport, null);\n      return null;\n    }\n    const phaseIdentifier = this.startNode();\n    const phaseIdentifierName = this.parseIdentifierName(true);\n    const {\n      type\n    } = this.state;\n    const isImportPhase = tokenIsKeywordOrIdentifier(type) ? type !== 98 || this.lookaheadCharCode() === 102 : type !== 12;\n    if (isImportPhase) {\n      this.applyImportPhase(node, isExport, phaseIdentifierName, phaseIdentifier.loc.start);\n      return null;\n    } else {\n      this.applyImportPhase(node, isExport, null);\n      return this.createIdentifier(phaseIdentifier, phaseIdentifierName);\n    }\n  }\n  isPrecedingIdImportPhase(phase) {\n    const {\n      type\n    } = this.state;\n    return tokenIsIdentifier(type) ? type !== 98 || this.lookaheadCharCode() === 102 : type !== 12;\n  }\n  parseImport(node) {\n    if (this.match(134)) {\n      return this.parseImportSourceAndAttributes(node);\n    }\n    return this.parseImportSpecifiersAndAfter(node, this.parseMaybeImportPhase(node, false));\n  }\n  parseImportSpecifiersAndAfter(node, maybeDefaultIdentifier) {\n    node.specifiers = [];\n    const hasDefault = this.maybeParseDefaultImportSpecifier(node, maybeDefaultIdentifier);\n    const parseNext = !hasDefault || this.eat(12);\n    const hasStar = parseNext && this.maybeParseStarImportSpecifier(node);\n    if (parseNext && !hasStar) this.parseNamedImportSpecifiers(node);\n    this.expectContextual(98);\n    return this.parseImportSourceAndAttributes(node);\n  }\n  parseImportSourceAndAttributes(node) {\n    var _node$specifiers2;\n    (_node$specifiers2 = node.specifiers) != null ? _node$specifiers2 : node.specifiers = [];\n    node.source = this.parseImportSource();\n    this.maybeParseImportAttributes(node);\n    this.checkImportReflection(node);\n    this.checkJSONModuleImport(node);\n    this.semicolon();\n    this.sawUnambiguousESM = true;\n    return this.finishNode(node, \"ImportDeclaration\");\n  }\n  parseImportSource() {\n    if (!this.match(134)) this.unexpected();\n    return this.parseExprAtom();\n  }\n  parseImportSpecifierLocal(node, specifier, type) {\n    specifier.local = this.parseIdentifier();\n    node.specifiers.push(this.finishImportSpecifier(specifier, type));\n  }\n  finishImportSpecifier(specifier, type, bindingType = 8201) {\n    this.checkLVal(specifier.local, {\n      type\n    }, bindingType);\n    return this.finishNode(specifier, type);\n  }\n  parseImportAttributes() {\n    this.expect(5);\n    const attrs = [];\n    const attrNames = new Set();\n    do {\n      if (this.match(8)) {\n        break;\n      }\n      const node = this.startNode();\n      const keyName = this.state.value;\n      if (attrNames.has(keyName)) {\n        this.raise(Errors.ModuleAttributesWithDuplicateKeys, this.state.startLoc, {\n          key: keyName\n        });\n      }\n      attrNames.add(keyName);\n      if (this.match(134)) {\n        node.key = this.parseStringLiteral(keyName);\n      } else {\n        node.key = this.parseIdentifier(true);\n      }\n      this.expect(14);\n      if (!this.match(134)) {\n        throw this.raise(Errors.ModuleAttributeInvalidValue, this.state.startLoc);\n      }\n      node.value = this.parseStringLiteral(this.state.value);\n      attrs.push(this.finishNode(node, \"ImportAttribute\"));\n    } while (this.eat(12));\n    this.expect(8);\n    return attrs;\n  }\n  parseModuleAttributes() {\n    const attrs = [];\n    const attributes = new Set();\n    do {\n      const node = this.startNode();\n      node.key = this.parseIdentifier(true);\n      if (node.key.name !== \"type\") {\n        this.raise(Errors.ModuleAttributeDifferentFromType, node.key);\n      }\n      if (attributes.has(node.key.name)) {\n        this.raise(Errors.ModuleAttributesWithDuplicateKeys, node.key, {\n          key: node.key.name\n        });\n      }\n      attributes.add(node.key.name);\n      this.expect(14);\n      if (!this.match(134)) {\n        throw this.raise(Errors.ModuleAttributeInvalidValue, this.state.startLoc);\n      }\n      node.value = this.parseStringLiteral(this.state.value);\n      attrs.push(this.finishNode(node, \"ImportAttribute\"));\n    } while (this.eat(12));\n    return attrs;\n  }\n  maybeParseImportAttributes(node) {\n    let attributes;\n    var useWith = false;\n    if (this.match(76)) {\n      if (this.hasPrecedingLineBreak() && this.lookaheadCharCode() === 40) {\n        return;\n      }\n      this.next();\n      if (this.hasPlugin(\"moduleAttributes\")) {\n        attributes = this.parseModuleAttributes();\n        this.addExtra(node, \"deprecatedWithLegacySyntax\", true);\n      } else {\n        attributes = this.parseImportAttributes();\n      }\n      useWith = true;\n    } else if (this.isContextual(94) && !this.hasPrecedingLineBreak()) {\n      if (!this.hasPlugin(\"deprecatedImportAssert\") && !this.hasPlugin(\"importAssertions\")) {\n        this.raise(Errors.ImportAttributesUseAssert, this.state.startLoc);\n      }\n      if (!this.hasPlugin(\"importAssertions\")) {\n        this.addExtra(node, \"deprecatedAssertSyntax\", true);\n      }\n      this.next();\n      attributes = this.parseImportAttributes();\n    } else {\n      attributes = [];\n    }\n    if (!useWith && this.hasPlugin(\"importAssertions\")) {\n      node.assertions = attributes;\n    } else {\n      node.attributes = attributes;\n    }\n  }\n  maybeParseDefaultImportSpecifier(node, maybeDefaultIdentifier) {\n    if (maybeDefaultIdentifier) {\n      const specifier = this.startNodeAtNode(maybeDefaultIdentifier);\n      specifier.local = maybeDefaultIdentifier;\n      node.specifiers.push(this.finishImportSpecifier(specifier, \"ImportDefaultSpecifier\"));\n      return true;\n    } else if (tokenIsKeywordOrIdentifier(this.state.type)) {\n      this.parseImportSpecifierLocal(node, this.startNode(), \"ImportDefaultSpecifier\");\n      return true;\n    }\n    return false;\n  }\n  maybeParseStarImportSpecifier(node) {\n    if (this.match(55)) {\n      const specifier = this.startNode();\n      this.next();\n      this.expectContextual(93);\n      this.parseImportSpecifierLocal(node, specifier, \"ImportNamespaceSpecifier\");\n      return true;\n    }\n    return false;\n  }\n  parseNamedImportSpecifiers(node) {\n    let first = true;\n    this.expect(5);\n    while (!this.eat(8)) {\n      if (first) {\n        first = false;\n      } else {\n        if (this.eat(14)) {\n          throw this.raise(Errors.DestructureNamedImport, this.state.startLoc);\n        }\n        this.expect(12);\n        if (this.eat(8)) break;\n      }\n      const specifier = this.startNode();\n      const importedIsString = this.match(134);\n      const isMaybeTypeOnly = this.isContextual(130);\n      specifier.imported = this.parseModuleExportName();\n      const importSpecifier = this.parseImportSpecifier(specifier, importedIsString, node.importKind === \"type\" || node.importKind === \"typeof\", isMaybeTypeOnly, undefined);\n      node.specifiers.push(importSpecifier);\n    }\n  }\n  parseImportSpecifier(specifier, importedIsString, isInTypeOnlyImport, isMaybeTypeOnly, bindingType) {\n    if (this.eatContextual(93)) {\n      specifier.local = this.parseIdentifier();\n    } else {\n      const {\n        imported\n      } = specifier;\n      if (importedIsString) {\n        throw this.raise(Errors.ImportBindingIsString, specifier, {\n          importName: imported.value\n        });\n      }\n      this.checkReservedWord(imported.name, specifier.loc.start, true, true);\n      if (!specifier.local) {\n        specifier.local = this.cloneIdentifier(imported);\n      }\n    }\n    return this.finishImportSpecifier(specifier, \"ImportSpecifier\", bindingType);\n  }\n  isThisParam(param) {\n    return param.type === \"Identifier\" && param.name === \"this\";\n  }\n}\nclass Parser extends StatementParser {\n  constructor(options, input, pluginsMap) {\n    const normalizedOptions = getOptions(options);\n    super(normalizedOptions, input);\n    this.options = normalizedOptions;\n    this.initializeScopes();\n    this.plugins = pluginsMap;\n    this.filename = normalizedOptions.sourceFilename;\n    this.startIndex = normalizedOptions.startIndex;\n    let optionFlags = 0;\n    if (normalizedOptions.allowAwaitOutsideFunction) {\n      optionFlags |= 1;\n    }\n    if (normalizedOptions.allowReturnOutsideFunction) {\n      optionFlags |= 2;\n    }\n    if (normalizedOptions.allowImportExportEverywhere) {\n      optionFlags |= 8;\n    }\n    if (normalizedOptions.allowSuperOutsideMethod) {\n      optionFlags |= 16;\n    }\n    if (normalizedOptions.allowUndeclaredExports) {\n      optionFlags |= 64;\n    }\n    if (normalizedOptions.allowNewTargetOutsideFunction) {\n      optionFlags |= 4;\n    }\n    if (normalizedOptions.allowYieldOutsideFunction) {\n      optionFlags |= 32;\n    }\n    if (normalizedOptions.ranges) {\n      optionFlags |= 128;\n    }\n    if (normalizedOptions.tokens) {\n      optionFlags |= 256;\n    }\n    if (normalizedOptions.createImportExpressions) {\n      optionFlags |= 512;\n    }\n    if (normalizedOptions.createParenthesizedExpressions) {\n      optionFlags |= 1024;\n    }\n    if (normalizedOptions.errorRecovery) {\n      optionFlags |= 2048;\n    }\n    if (normalizedOptions.attachComment) {\n      optionFlags |= 4096;\n    }\n    if (normalizedOptions.annexB) {\n      optionFlags |= 8192;\n    }\n    this.optionFlags = optionFlags;\n  }\n  getScopeHandler() {\n    return ScopeHandler;\n  }\n  parse() {\n    this.enterInitialScopes();\n    const file = this.startNode();\n    const program = this.startNode();\n    this.nextToken();\n    file.errors = null;\n    const result = this.parseTopLevel(file, program);\n    result.errors = this.state.errors;\n    result.comments.length = this.state.commentsLen;\n    return result;\n  }\n}\nfunction parse(input, options) {\n  var _options;\n  if (((_options = options) == null ? void 0 : _options.sourceType) === \"unambiguous\") {\n    options = Object.assign({}, options);\n    try {\n      options.sourceType = \"module\";\n      const parser = getParser(options, input);\n      const ast = parser.parse();\n      if (parser.sawUnambiguousESM) {\n        return ast;\n      }\n      if (parser.ambiguousScriptDifferentAst) {\n        try {\n          options.sourceType = \"script\";\n          return getParser(options, input).parse();\n        } catch (_unused) {}\n      } else {\n        ast.program.sourceType = \"script\";\n      }\n      return ast;\n    } catch (moduleError) {\n      try {\n        options.sourceType = \"script\";\n        return getParser(options, input).parse();\n      } catch (_unused2) {}\n      throw moduleError;\n    }\n  } else {\n    return getParser(options, input).parse();\n  }\n}\nfunction parseExpression(input, options) {\n  const parser = getParser(options, input);\n  if (parser.options.strictMode) {\n    parser.state.strict = true;\n  }\n  return parser.getExpression();\n}\nfunction generateExportedTokenTypes(internalTokenTypes) {\n  const tokenTypes = {};\n  for (const typeName of Object.keys(internalTokenTypes)) {\n    tokenTypes[typeName] = getExportedToken(internalTokenTypes[typeName]);\n  }\n  return tokenTypes;\n}\nconst tokTypes = generateExportedTokenTypes(tt);\nfunction getParser(options, input) {\n  let cls = Parser;\n  const pluginsMap = new Map();\n  if (options != null && options.plugins) {\n    for (const plugin of options.plugins) {\n      let name, opts;\n      if (typeof plugin === \"string\") {\n        name = plugin;\n      } else {\n        [name, opts] = plugin;\n      }\n      if (!pluginsMap.has(name)) {\n        pluginsMap.set(name, opts || {});\n      }\n    }\n    validatePlugins(pluginsMap);\n    cls = getParserClass(pluginsMap);\n  }\n  return new cls(options, input, pluginsMap);\n}\nconst parserClassCache = new Map();\nfunction getParserClass(pluginsMap) {\n  const pluginList = [];\n  for (const name of mixinPluginNames) {\n    if (pluginsMap.has(name)) {\n      pluginList.push(name);\n    }\n  }\n  const key = pluginList.join(\"|\");\n  let cls = parserClassCache.get(key);\n  if (!cls) {\n    cls = Parser;\n    for (const plugin of pluginList) {\n      cls = mixinPlugins[plugin](cls);\n    }\n    parserClassCache.set(key, cls);\n  }\n  return cls;\n}\nexports.parse = parse;\nexports.parseExpression = parseExpression;\nexports.tokTypes = tokTypes;\n//# sourceMappingURL=index.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGJhYmVsL3BhcnNlci9saWIvaW5kZXguanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWIsOENBQTZDO0FBQzdDO0FBQ0EsQ0FBQyxFQUFDO0FBQ0Y7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLDBHQUEwRyxZQUFZO0FBQ3RIO0FBQ0E7QUFDQTtBQUNBLEdBQUcsVUFBVSxLQUFLO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHLCtCQUErQixNQUFNO0FBQ3hDO0FBQ0EsMEtBQTBLO0FBQzFLO0FBQ0EsaUdBQWlHLEtBQUs7QUFDdEcseUtBQXlLO0FBQ3pLO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUcsVUFBVSxXQUFXO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRywwR0FBMEcsR0FBRyxVQUFVLFFBQVEsV0FBVyxJQUFJO0FBQ2pKO0FBQ0E7QUFDQTtBQUNBLEdBQUcsU0FBUyxnREFBZ0Q7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRyxvQkFBb0IsaURBQWlEO0FBQ3hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHLHlGQUF5RixHQUFHLFdBQVcsVUFBVTtBQUNwSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRyxpQ0FBaUMsTUFBTTtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUcsbUNBQW1DLGFBQWE7QUFDbkQ7QUFDQTtBQUNBLEdBQUcsMkJBQTJCLGVBQWU7QUFDN0M7QUFDQTtBQUNBLEdBQUcsa0NBQWtDLDRCQUE0QjtBQUNqRTtBQUNBO0FBQ0EsR0FBRywwQ0FBMEMsNEJBQTRCO0FBQ3pFO0FBQ0E7QUFDQSxHQUFHLDJEQUEyRCw0QkFBNEI7QUFDMUY7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHLDhCQUE4QixXQUFXO0FBQzVDO0FBQ0E7QUFDQTtBQUNBLEdBQUcsc0JBQXNCLGdCQUFnQjtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRyxlQUFlLFVBQVU7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUcsc0VBQXNFLDJEQUEyRDtBQUNwSTtBQUNBO0FBQ0EsR0FBRywwRkFBMEYsMkRBQTJEO0FBQ3hKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUcsdUJBQXVCLElBQUk7QUFDOUI7QUFDQTtBQUNBLEdBQUcsa0VBQWtFLCtCQUErQjtBQUNwRztBQUNBO0FBQ0EsR0FBRyxnQkFBZ0IsVUFBVTtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRyxvRUFBb0UsZUFBZSxtQ0FBbUMsZ0JBQWdCO0FBQ3pJO0FBQ0E7QUFDQSxHQUFHLGdDQUFnQyxlQUFlO0FBQ2xELGdGQUFnRjtBQUNoRixtRkFBbUY7QUFDbkYscUZBQXFGO0FBQ3JGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkVBQTZFO0FBQzdFO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRyw0QkFBNEIsUUFBUTtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUcsa0NBQWtDLGFBQWE7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHLHdCQUF3QixrQkFBa0IsV0FBVyxTQUFTLEVBQUUsMEJBQTBCLFNBQVMsUUFBUTtBQUM5RztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUcseUNBQXlDLFFBQVEsS0FBSyxPQUFPLEdBQUcsc0JBQXNCO0FBQ3pGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHLG9CQUFvQixlQUFlO0FBQ3RDLGlHQUFpRyxNQUFNLFFBQVEsS0FBSztBQUNwSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUcsc0JBQXNCLGNBQWM7QUFDdkM7QUFDQTtBQUNBLEdBQUcsaUJBQWlCLFlBQVk7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRyxnS0FBZ0ssaUNBQWlDO0FBQ3BNO0FBQ0E7QUFDQTtBQUNBLDREQUE0RDtBQUM1RDtBQUNBLGlEQUFpRDtBQUNqRDtBQUNBO0FBQ0EsR0FBRyw0QkFBNEIsTUFBTSxvQkFBb0IsT0FBTyw0RUFBNEUscUNBQXFDLE1BQU0sR0FBRztBQUMxTCw2RUFBNkU7QUFDN0U7QUFDQTtBQUNBLEdBQUcsMERBQTBEO0FBQzdEO0FBQ0EsR0FBRyxJQUFJO0FBQ1AsQ0FBQztBQUNELG1FQUFtRTtBQUNuRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4REFBOEQ7QUFDOUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUiw0RUFBNEU7QUFDNUUsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLG9CQUFvQixHQUFHLFNBQVMsR0FBRyxXQUFXO0FBQ3pFO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsTUFBTSxJQUFJO0FBQ1Y7QUFDQTtBQUNBO0FBQ0EsK0JBQStCO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEI7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QztBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1QztBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QztBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0Esd0JBQXdCO0FBQ3hCO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsMkJBQTJCO0FBQzNCO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsNkJBQTZCO0FBQzdCO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsd0JBQXdCO0FBQ3hCLDRCQUE0QjtBQUM1QjtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILHNCQUFzQjtBQUN0QjtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSCwrQkFBK0I7QUFDL0I7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNILHFDQUFxQztBQUNyQztBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDLFlBQVk7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDO0FBQzlDO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOLCtDQUErQyxRQUFRO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDO0FBQzlDO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDO0FBQzlDO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHLHVDQUF1QyxhQUFhO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUcsa0VBQWtFLFlBQVksaUJBQWlCLFlBQVksdUJBQXVCLFNBQVM7QUFDOUk7QUFDQTtBQUNBO0FBQ0EsR0FBRyw0REFBNEQsV0FBVyw0Q0FBNEMsU0FBUztBQUMvSDtBQUNBO0FBQ0EsR0FBRyxlQUFlLFNBQVM7QUFDM0I7QUFDQTtBQUNBO0FBQ0EsR0FBRyxvQkFBb0IsZ0JBQWdCLDJGQUEyRixTQUFTO0FBQzNJO0FBQ0E7QUFDQSxHQUFHLGlIQUFpSCxTQUFTO0FBQzdIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRyxlQUFlLFNBQVMsZ0JBQWdCLGFBQWEsOEJBQThCLFdBQVcsbUJBQW1CLGNBQWM7QUFDbEk7QUFDQTtBQUNBO0FBQ0EsR0FBRyx5REFBeUQsV0FBVyxnQkFBZ0IsU0FBUztBQUNoRztBQUNBO0FBQ0E7QUFDQSxHQUFHLDBDQUEwQyxXQUFXLDJFQUEyRSxTQUFTO0FBQzVJO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRywwRkFBMEYsV0FBVyx1QkFBdUIsV0FBVyxnQkFBZ0IsU0FBUztBQUNuSztBQUNBO0FBQ0E7QUFDQSxHQUFHLDJEQUEyRCxZQUFZLGtCQUFrQixTQUFTO0FBQ3JHO0FBQ0E7QUFDQSxHQUFHLGdIQUFnSCxTQUFTO0FBQzVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSw4RUFBOEU7QUFDOUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUcsaUNBQWlDLGFBQWE7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBJQUEwSSx5QkFBeUI7QUFDbks7QUFDQTtBQUNBO0FBQ0EsR0FBRyx5QkFBeUIsc0JBQXNCLDZCQUE2QixXQUFXO0FBQzFGO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLGlCQUFpQjtBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQSxRQUFRO0FBQ1I7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixvQkFBb0I7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixxQkFBcUI7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixxQkFBcUI7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0Isd0JBQXdCO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsU0FBUztBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUcsb0RBQW9ELGVBQWU7QUFDdEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUcsMkJBQTJCLFdBQVcscUJBQXFCLFdBQVcsU0FBUyxHQUFHLFdBQVcsRUFBRTtBQUNsRztBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsU0FBUztBQUNULFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsYUFBYTtBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSwwQkFBMEIsUUFBUTtBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOLFdBQVcsUUFBUTtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOLDBDQUEwQyxRQUFRO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkI7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEI7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QjtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEI7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QjtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvREFBb0QsT0FBTztBQUMzRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTSw4REFBOEQ7QUFDcEU7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsdURBQXVEO0FBQ3ZEO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsbUVBQW1FO0FBQ25FO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLHFFQUFxRTtBQUNyRTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTixZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLHVFQUF1RTtBQUN2RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxzQ0FBc0M7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0NBQStDO0FBQy9DO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQyxRQUFRO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0MsWUFBWTtBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0RUFBNEUsWUFBWTtBQUN4RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFVBQVU7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxRQUFRO0FBQ1I7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDLEdBQUc7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUcsZ0JBQWdCLFdBQVc7QUFDOUI7QUFDQTtBQUNBLEdBQUcsa0JBQWtCLGFBQWE7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRyxvQ0FBb0MsS0FBSztBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUcsOENBQThDLFNBQVM7QUFDMUQ7QUFDQTtBQUNBLEdBQUcsNkJBQTZCLFNBQVM7QUFDekM7QUFDQTtBQUNBLEdBQUcsU0FBUyxNQUFNO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRyxTQUFTLGFBQWEsa0NBQWtDLGFBQWE7QUFDeEU7QUFDQTtBQUNBO0FBQ0EsR0FBRyxpRUFBaUUsU0FBUztBQUM3RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHLFNBQVMsTUFBTTtBQUNsQiwwREFBMEQsU0FBUztBQUNuRTtBQUNBO0FBQ0EsR0FBRyxTQUFTLFNBQVM7QUFDckI7QUFDQTtBQUNBLEdBQUcsU0FBUyxTQUFTO0FBQ3JCO0FBQ0E7QUFDQSxHQUFHLFNBQVMsU0FBUztBQUNyQixxREFBcUQsU0FBUztBQUM5RDtBQUNBO0FBQ0EsR0FBRyxTQUFTLG9CQUFvQiwyQkFBMkIsb0JBQW9CO0FBQy9FO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHLGlFQUFpRSxTQUFTO0FBQzdFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHLDhCQUE4QixtQkFBbUIsZ0RBQWdELGtCQUFrQjtBQUN0SDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRyw4RkFBOEYsS0FBSztBQUN0RyxnREFBZ0QsS0FBSztBQUNyRCxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1gsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1gsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsbURBQW1EO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsbUZBQW1GLHFGQUFxRjtBQUN4SyxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0EscUZBQXFGLHFGQUFxRjtBQUMxSyxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJEQUEyRCxFQUFFO0FBQzdELG1HQUFtRyxhQUFhO0FBQ2hIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvREFBb0QsRUFBRTtBQUN0RCx5SUFBeUksVUFBVTtBQUNuSjtBQUNBO0FBQ0EsMEVBQTBFLG1DQUFtQyxZQUFZLHFFQUFxRTtBQUM5TDtBQUNBLE1BQU07QUFDTix3RUFBd0UsbUJBQW1CLFlBQVkscUVBQXFFO0FBQzVLO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaURBQWlEO0FBQ2pELCtDQUErQztBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrSUFBK0ksRUFBRTtBQUNqSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUMsU0FBUztBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLG1CQUFtQjtBQUNyQztBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWCxVQUFVO0FBQ1Y7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWCxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQiw4QkFBOEI7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLGVBQWU7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsK0NBQStDLFFBQVE7QUFDdkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1gsVUFBVTtBQUNWO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2YsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1YsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBLHVDQUF1QztBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLHVCQUF1QjtBQUN2QixnQkFBZ0I7QUFDaEIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9yZXBvLXZpc3VhbGl6ZXIvLi9ub2RlX21vZHVsZXMvQGJhYmVsL3BhcnNlci9saWIvaW5kZXguanM/MDM0MiJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZnVuY3Rpb24gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzTG9vc2UociwgZSkge1xuICBpZiAobnVsbCA9PSByKSByZXR1cm4ge307XG4gIHZhciB0ID0ge307XG4gIGZvciAodmFyIG4gaW4gcikgaWYgKHt9Lmhhc093blByb3BlcnR5LmNhbGwociwgbikpIHtcbiAgICBpZiAoLTEgIT09IGUuaW5kZXhPZihuKSkgY29udGludWU7XG4gICAgdFtuXSA9IHJbbl07XG4gIH1cbiAgcmV0dXJuIHQ7XG59XG5jbGFzcyBQb3NpdGlvbiB7XG4gIGNvbnN0cnVjdG9yKGxpbmUsIGNvbCwgaW5kZXgpIHtcbiAgICB0aGlzLmxpbmUgPSB2b2lkIDA7XG4gICAgdGhpcy5jb2x1bW4gPSB2b2lkIDA7XG4gICAgdGhpcy5pbmRleCA9IHZvaWQgMDtcbiAgICB0aGlzLmxpbmUgPSBsaW5lO1xuICAgIHRoaXMuY29sdW1uID0gY29sO1xuICAgIHRoaXMuaW5kZXggPSBpbmRleDtcbiAgfVxufVxuY2xhc3MgU291cmNlTG9jYXRpb24ge1xuICBjb25zdHJ1Y3RvcihzdGFydCwgZW5kKSB7XG4gICAgdGhpcy5zdGFydCA9IHZvaWQgMDtcbiAgICB0aGlzLmVuZCA9IHZvaWQgMDtcbiAgICB0aGlzLmZpbGVuYW1lID0gdm9pZCAwO1xuICAgIHRoaXMuaWRlbnRpZmllck5hbWUgPSB2b2lkIDA7XG4gICAgdGhpcy5zdGFydCA9IHN0YXJ0O1xuICAgIHRoaXMuZW5kID0gZW5kO1xuICB9XG59XG5mdW5jdGlvbiBjcmVhdGVQb3NpdGlvbldpdGhDb2x1bW5PZmZzZXQocG9zaXRpb24sIGNvbHVtbk9mZnNldCkge1xuICBjb25zdCB7XG4gICAgbGluZSxcbiAgICBjb2x1bW4sXG4gICAgaW5kZXhcbiAgfSA9IHBvc2l0aW9uO1xuICByZXR1cm4gbmV3IFBvc2l0aW9uKGxpbmUsIGNvbHVtbiArIGNvbHVtbk9mZnNldCwgaW5kZXggKyBjb2x1bW5PZmZzZXQpO1xufVxuY29uc3QgY29kZSA9IFwiQkFCRUxfUEFSU0VSX1NPVVJDRVRZUEVfTU9EVUxFX1JFUVVJUkVEXCI7XG52YXIgTW9kdWxlRXJyb3JzID0ge1xuICBJbXBvcnRNZXRhT3V0c2lkZU1vZHVsZToge1xuICAgIG1lc3NhZ2U6IGBpbXBvcnQubWV0YSBtYXkgYXBwZWFyIG9ubHkgd2l0aCAnc291cmNlVHlwZTogXCJtb2R1bGVcIidgLFxuICAgIGNvZGVcbiAgfSxcbiAgSW1wb3J0T3V0c2lkZU1vZHVsZToge1xuICAgIG1lc3NhZ2U6IGAnaW1wb3J0JyBhbmQgJ2V4cG9ydCcgbWF5IGFwcGVhciBvbmx5IHdpdGggJ3NvdXJjZVR5cGU6IFwibW9kdWxlXCInYCxcbiAgICBjb2RlXG4gIH1cbn07XG5jb25zdCBOb2RlRGVzY3JpcHRpb25zID0ge1xuICBBcnJheVBhdHRlcm46IFwiYXJyYXkgZGVzdHJ1Y3R1cmluZyBwYXR0ZXJuXCIsXG4gIEFzc2lnbm1lbnRFeHByZXNzaW9uOiBcImFzc2lnbm1lbnQgZXhwcmVzc2lvblwiLFxuICBBc3NpZ25tZW50UGF0dGVybjogXCJhc3NpZ25tZW50IGV4cHJlc3Npb25cIixcbiAgQXJyb3dGdW5jdGlvbkV4cHJlc3Npb246IFwiYXJyb3cgZnVuY3Rpb24gZXhwcmVzc2lvblwiLFxuICBDb25kaXRpb25hbEV4cHJlc3Npb246IFwiY29uZGl0aW9uYWwgZXhwcmVzc2lvblwiLFxuICBDYXRjaENsYXVzZTogXCJjYXRjaCBjbGF1c2VcIixcbiAgRm9yT2ZTdGF0ZW1lbnQ6IFwiZm9yLW9mIHN0YXRlbWVudFwiLFxuICBGb3JJblN0YXRlbWVudDogXCJmb3ItaW4gc3RhdGVtZW50XCIsXG4gIEZvclN0YXRlbWVudDogXCJmb3ItbG9vcFwiLFxuICBGb3JtYWxQYXJhbWV0ZXJzOiBcImZ1bmN0aW9uIHBhcmFtZXRlciBsaXN0XCIsXG4gIElkZW50aWZpZXI6IFwiaWRlbnRpZmllclwiLFxuICBJbXBvcnRTcGVjaWZpZXI6IFwiaW1wb3J0IHNwZWNpZmllclwiLFxuICBJbXBvcnREZWZhdWx0U3BlY2lmaWVyOiBcImltcG9ydCBkZWZhdWx0IHNwZWNpZmllclwiLFxuICBJbXBvcnROYW1lc3BhY2VTcGVjaWZpZXI6IFwiaW1wb3J0IG5hbWVzcGFjZSBzcGVjaWZpZXJcIixcbiAgT2JqZWN0UGF0dGVybjogXCJvYmplY3QgZGVzdHJ1Y3R1cmluZyBwYXR0ZXJuXCIsXG4gIFBhcmVudGhlc2l6ZWRFeHByZXNzaW9uOiBcInBhcmVudGhlc2l6ZWQgZXhwcmVzc2lvblwiLFxuICBSZXN0RWxlbWVudDogXCJyZXN0IGVsZW1lbnRcIixcbiAgVXBkYXRlRXhwcmVzc2lvbjoge1xuICAgIHRydWU6IFwicHJlZml4IG9wZXJhdGlvblwiLFxuICAgIGZhbHNlOiBcInBvc3RmaXggb3BlcmF0aW9uXCJcbiAgfSxcbiAgVmFyaWFibGVEZWNsYXJhdG9yOiBcInZhcmlhYmxlIGRlY2xhcmF0aW9uXCIsXG4gIFlpZWxkRXhwcmVzc2lvbjogXCJ5aWVsZCBleHByZXNzaW9uXCJcbn07XG5jb25zdCB0b05vZGVEZXNjcmlwdGlvbiA9IG5vZGUgPT4gbm9kZS50eXBlID09PSBcIlVwZGF0ZUV4cHJlc3Npb25cIiA/IE5vZGVEZXNjcmlwdGlvbnMuVXBkYXRlRXhwcmVzc2lvbltgJHtub2RlLnByZWZpeH1gXSA6IE5vZGVEZXNjcmlwdGlvbnNbbm9kZS50eXBlXTtcbnZhciBTdGFuZGFyZEVycm9ycyA9IHtcbiAgQWNjZXNzb3JJc0dlbmVyYXRvcjogKHtcbiAgICBraW5kXG4gIH0pID0+IGBBICR7a2luZH10ZXIgY2Fubm90IGJlIGEgZ2VuZXJhdG9yLmAsXG4gIEFyZ3VtZW50c0luQ2xhc3M6IFwiJ2FyZ3VtZW50cycgaXMgb25seSBhbGxvd2VkIGluIGZ1bmN0aW9ucyBhbmQgY2xhc3MgbWV0aG9kcy5cIixcbiAgQXN5bmNGdW5jdGlvbkluU2luZ2xlU3RhdGVtZW50Q29udGV4dDogXCJBc3luYyBmdW5jdGlvbnMgY2FuIG9ubHkgYmUgZGVjbGFyZWQgYXQgdGhlIHRvcCBsZXZlbCBvciBpbnNpZGUgYSBibG9jay5cIixcbiAgQXdhaXRCaW5kaW5nSWRlbnRpZmllcjogXCJDYW4gbm90IHVzZSAnYXdhaXQnIGFzIGlkZW50aWZpZXIgaW5zaWRlIGFuIGFzeW5jIGZ1bmN0aW9uLlwiLFxuICBBd2FpdEJpbmRpbmdJZGVudGlmaWVySW5TdGF0aWNCbG9jazogXCJDYW4gbm90IHVzZSAnYXdhaXQnIGFzIGlkZW50aWZpZXIgaW5zaWRlIGEgc3RhdGljIGJsb2NrLlwiLFxuICBBd2FpdEV4cHJlc3Npb25Gb3JtYWxQYXJhbWV0ZXI6IFwiJ2F3YWl0JyBpcyBub3QgYWxsb3dlZCBpbiBhc3luYyBmdW5jdGlvbiBwYXJhbWV0ZXJzLlwiLFxuICBBd2FpdFVzaW5nTm90SW5Bc3luY0NvbnRleHQ6IFwiJ2F3YWl0IHVzaW5nJyBpcyBvbmx5IGFsbG93ZWQgd2l0aGluIGFzeW5jIGZ1bmN0aW9ucyBhbmQgYXQgdGhlIHRvcCBsZXZlbHMgb2YgbW9kdWxlcy5cIixcbiAgQXdhaXROb3RJbkFzeW5jQ29udGV4dDogXCInYXdhaXQnIGlzIG9ubHkgYWxsb3dlZCB3aXRoaW4gYXN5bmMgZnVuY3Rpb25zIGFuZCBhdCB0aGUgdG9wIGxldmVscyBvZiBtb2R1bGVzLlwiLFxuICBCYWRHZXR0ZXJBcml0eTogXCJBICdnZXQnIGFjY2Vzc29yIG11c3Qgbm90IGhhdmUgYW55IGZvcm1hbCBwYXJhbWV0ZXJzLlwiLFxuICBCYWRTZXR0ZXJBcml0eTogXCJBICdzZXQnIGFjY2Vzc29yIG11c3QgaGF2ZSBleGFjdGx5IG9uZSBmb3JtYWwgcGFyYW1ldGVyLlwiLFxuICBCYWRTZXR0ZXJSZXN0UGFyYW1ldGVyOiBcIkEgJ3NldCcgYWNjZXNzb3IgZnVuY3Rpb24gYXJndW1lbnQgbXVzdCBub3QgYmUgYSByZXN0IHBhcmFtZXRlci5cIixcbiAgQ29uc3RydWN0b3JDbGFzc0ZpZWxkOiBcIkNsYXNzZXMgbWF5IG5vdCBoYXZlIGEgZmllbGQgbmFtZWQgJ2NvbnN0cnVjdG9yJy5cIixcbiAgQ29uc3RydWN0b3JDbGFzc1ByaXZhdGVGaWVsZDogXCJDbGFzc2VzIG1heSBub3QgaGF2ZSBhIHByaXZhdGUgZmllbGQgbmFtZWQgJyNjb25zdHJ1Y3RvcicuXCIsXG4gIENvbnN0cnVjdG9ySXNBY2Nlc3NvcjogXCJDbGFzcyBjb25zdHJ1Y3RvciBtYXkgbm90IGJlIGFuIGFjY2Vzc29yLlwiLFxuICBDb25zdHJ1Y3RvcklzQXN5bmM6IFwiQ29uc3RydWN0b3IgY2FuJ3QgYmUgYW4gYXN5bmMgZnVuY3Rpb24uXCIsXG4gIENvbnN0cnVjdG9ySXNHZW5lcmF0b3I6IFwiQ29uc3RydWN0b3IgY2FuJ3QgYmUgYSBnZW5lcmF0b3IuXCIsXG4gIERlY2xhcmF0aW9uTWlzc2luZ0luaXRpYWxpemVyOiAoe1xuICAgIGtpbmRcbiAgfSkgPT4gYE1pc3NpbmcgaW5pdGlhbGl6ZXIgaW4gJHtraW5kfSBkZWNsYXJhdGlvbi5gLFxuICBEZWNvcmF0b3JBcmd1bWVudHNPdXRzaWRlUGFyZW50aGVzZXM6IFwiRGVjb3JhdG9yIGFyZ3VtZW50cyBtdXN0IGJlIG1vdmVkIGluc2lkZSBwYXJlbnRoZXNlczogdXNlICdAKGRlY29yYXRvcihhcmdzKSknIGluc3RlYWQgb2YgJ0AoZGVjb3JhdG9yKShhcmdzKScuXCIsXG4gIERlY29yYXRvckJlZm9yZUV4cG9ydDogXCJEZWNvcmF0b3JzIG11c3QgYmUgcGxhY2VkICpiZWZvcmUqIHRoZSAnZXhwb3J0JyBrZXl3b3JkLiBSZW1vdmUgdGhlICdkZWNvcmF0b3JzQmVmb3JlRXhwb3J0OiB0cnVlJyBvcHRpb24gdG8gdXNlIHRoZSAnZXhwb3J0IEBkZWNvcmF0b3IgY2xhc3Mge30nIHN5bnRheC5cIixcbiAgRGVjb3JhdG9yc0JlZm9yZUFmdGVyRXhwb3J0OiBcIkRlY29yYXRvcnMgY2FuIGJlIHBsYWNlZCAqZWl0aGVyKiBiZWZvcmUgb3IgYWZ0ZXIgdGhlICdleHBvcnQnIGtleXdvcmQsIGJ1dCBub3QgaW4gYm90aCBsb2NhdGlvbnMgYXQgdGhlIHNhbWUgdGltZS5cIixcbiAgRGVjb3JhdG9yQ29uc3RydWN0b3I6IFwiRGVjb3JhdG9ycyBjYW4ndCBiZSB1c2VkIHdpdGggYSBjb25zdHJ1Y3Rvci4gRGlkIHlvdSBtZWFuICdAZGVjIGNsYXNzIHsgLi4uIH0nP1wiLFxuICBEZWNvcmF0b3JFeHBvcnRDbGFzczogXCJEZWNvcmF0b3JzIG11c3QgYmUgcGxhY2VkICphZnRlciogdGhlICdleHBvcnQnIGtleXdvcmQuIFJlbW92ZSB0aGUgJ2RlY29yYXRvcnNCZWZvcmVFeHBvcnQ6IGZhbHNlJyBvcHRpb24gdG8gdXNlIHRoZSAnQGRlY29yYXRvciBleHBvcnQgY2xhc3Mge30nIHN5bnRheC5cIixcbiAgRGVjb3JhdG9yU2VtaWNvbG9uOiBcIkRlY29yYXRvcnMgbXVzdCBub3QgYmUgZm9sbG93ZWQgYnkgYSBzZW1pY29sb24uXCIsXG4gIERlY29yYXRvclN0YXRpY0Jsb2NrOiBcIkRlY29yYXRvcnMgY2FuJ3QgYmUgdXNlZCB3aXRoIGEgc3RhdGljIGJsb2NrLlwiLFxuICBEZWZlckltcG9ydFJlcXVpcmVzTmFtZXNwYWNlOiAnT25seSBgaW1wb3J0IGRlZmVyICogYXMgeCBmcm9tIFwiLi9tb2R1bGVcImAgaXMgdmFsaWQuJyxcbiAgRGVsZXRlUHJpdmF0ZUZpZWxkOiBcIkRlbGV0aW5nIGEgcHJpdmF0ZSBmaWVsZCBpcyBub3QgYWxsb3dlZC5cIixcbiAgRGVzdHJ1Y3R1cmVOYW1lZEltcG9ydDogXCJFUzIwMTUgbmFtZWQgaW1wb3J0cyBkbyBub3QgZGVzdHJ1Y3R1cmUuIFVzZSBhbm90aGVyIHN0YXRlbWVudCBmb3IgZGVzdHJ1Y3R1cmluZyBhZnRlciB0aGUgaW1wb3J0LlwiLFxuICBEdXBsaWNhdGVDb25zdHJ1Y3RvcjogXCJEdXBsaWNhdGUgY29uc3RydWN0b3IgaW4gdGhlIHNhbWUgY2xhc3MuXCIsXG4gIER1cGxpY2F0ZURlZmF1bHRFeHBvcnQ6IFwiT25seSBvbmUgZGVmYXVsdCBleHBvcnQgYWxsb3dlZCBwZXIgbW9kdWxlLlwiLFxuICBEdXBsaWNhdGVFeHBvcnQ6ICh7XG4gICAgZXhwb3J0TmFtZVxuICB9KSA9PiBgXFxgJHtleHBvcnROYW1lfVxcYCBoYXMgYWxyZWFkeSBiZWVuIGV4cG9ydGVkLiBFeHBvcnRlZCBpZGVudGlmaWVycyBtdXN0IGJlIHVuaXF1ZS5gLFxuICBEdXBsaWNhdGVQcm90bzogXCJSZWRlZmluaXRpb24gb2YgX19wcm90b19fIHByb3BlcnR5LlwiLFxuICBEdXBsaWNhdGVSZWdFeHBGbGFnczogXCJEdXBsaWNhdGUgcmVndWxhciBleHByZXNzaW9uIGZsYWcuXCIsXG4gIEVsZW1lbnRBZnRlclJlc3Q6IFwiUmVzdCBlbGVtZW50IG11c3QgYmUgbGFzdCBlbGVtZW50LlwiLFxuICBFc2NhcGVkQ2hhck5vdEFuSWRlbnRpZmllcjogXCJJbnZhbGlkIFVuaWNvZGUgZXNjYXBlLlwiLFxuICBFeHBvcnRCaW5kaW5nSXNTdHJpbmc6ICh7XG4gICAgbG9jYWxOYW1lLFxuICAgIGV4cG9ydE5hbWVcbiAgfSkgPT4gYEEgc3RyaW5nIGxpdGVyYWwgY2Fubm90IGJlIHVzZWQgYXMgYW4gZXhwb3J0ZWQgYmluZGluZyB3aXRob3V0IFxcYGZyb21cXGAuXFxuLSBEaWQgeW91IG1lYW4gXFxgZXhwb3J0IHsgJyR7bG9jYWxOYW1lfScgYXMgJyR7ZXhwb3J0TmFtZX0nIH0gZnJvbSAnc29tZS1tb2R1bGUnXFxgP2AsXG4gIEV4cG9ydERlZmF1bHRGcm9tQXNJZGVudGlmaWVyOiBcIidmcm9tJyBpcyBub3QgYWxsb3dlZCBhcyBhbiBpZGVudGlmaWVyIGFmdGVyICdleHBvcnQgZGVmYXVsdCcuXCIsXG4gIEZvckluT2ZMb29wSW5pdGlhbGl6ZXI6ICh7XG4gICAgdHlwZVxuICB9KSA9PiBgJyR7dHlwZSA9PT0gXCJGb3JJblN0YXRlbWVudFwiID8gXCJmb3ItaW5cIiA6IFwiZm9yLW9mXCJ9JyBsb29wIHZhcmlhYmxlIGRlY2xhcmF0aW9uIG1heSBub3QgaGF2ZSBhbiBpbml0aWFsaXplci5gLFxuICBGb3JJblVzaW5nOiBcIkZvci1pbiBsb29wIG1heSBub3Qgc3RhcnQgd2l0aCAndXNpbmcnIGRlY2xhcmF0aW9uLlwiLFxuICBGb3JPZkFzeW5jOiBcIlRoZSBsZWZ0LWhhbmQgc2lkZSBvZiBhIGZvci1vZiBsb29wIG1heSBub3QgYmUgJ2FzeW5jJy5cIixcbiAgRm9yT2ZMZXQ6IFwiVGhlIGxlZnQtaGFuZCBzaWRlIG9mIGEgZm9yLW9mIGxvb3AgbWF5IG5vdCBzdGFydCB3aXRoICdsZXQnLlwiLFxuICBHZW5lcmF0b3JJblNpbmdsZVN0YXRlbWVudENvbnRleHQ6IFwiR2VuZXJhdG9ycyBjYW4gb25seSBiZSBkZWNsYXJlZCBhdCB0aGUgdG9wIGxldmVsIG9yIGluc2lkZSBhIGJsb2NrLlwiLFxuICBJbGxlZ2FsQnJlYWtDb250aW51ZTogKHtcbiAgICB0eXBlXG4gIH0pID0+IGBVbnN5bnRhY3RpYyAke3R5cGUgPT09IFwiQnJlYWtTdGF0ZW1lbnRcIiA/IFwiYnJlYWtcIiA6IFwiY29udGludWVcIn0uYCxcbiAgSWxsZWdhbExhbmd1YWdlTW9kZURpcmVjdGl2ZTogXCJJbGxlZ2FsICd1c2Ugc3RyaWN0JyBkaXJlY3RpdmUgaW4gZnVuY3Rpb24gd2l0aCBub24tc2ltcGxlIHBhcmFtZXRlciBsaXN0LlwiLFxuICBJbGxlZ2FsUmV0dXJuOiBcIidyZXR1cm4nIG91dHNpZGUgb2YgZnVuY3Rpb24uXCIsXG4gIEltcG9ydEF0dHJpYnV0ZXNVc2VBc3NlcnQ6IFwiVGhlIGBhc3NlcnRgIGtleXdvcmQgaW4gaW1wb3J0IGF0dHJpYnV0ZXMgaXMgZGVwcmVjYXRlZCBhbmQgaXQgaGFzIGJlZW4gcmVwbGFjZWQgYnkgdGhlIGB3aXRoYCBrZXl3b3JkLiBZb3UgY2FuIGVuYWJsZSB0aGUgYGRlcHJlY2F0ZWRJbXBvcnRBc3NlcnRgIHBhcnNlciBwbHVnaW4gdG8gc3VwcHJlc3MgdGhpcyBlcnJvci5cIixcbiAgSW1wb3J0QmluZGluZ0lzU3RyaW5nOiAoe1xuICAgIGltcG9ydE5hbWVcbiAgfSkgPT4gYEEgc3RyaW5nIGxpdGVyYWwgY2Fubm90IGJlIHVzZWQgYXMgYW4gaW1wb3J0ZWQgYmluZGluZy5cXG4tIERpZCB5b3UgbWVhbiBcXGBpbXBvcnQgeyBcIiR7aW1wb3J0TmFtZX1cIiBhcyBmb28gfVxcYD9gLFxuICBJbXBvcnRDYWxsQXJpdHk6IGBcXGBpbXBvcnQoKVxcYCByZXF1aXJlcyBleGFjdGx5IG9uZSBvciB0d28gYXJndW1lbnRzLmAsXG4gIEltcG9ydENhbGxOb3ROZXdFeHByZXNzaW9uOiBcIkNhbm5vdCB1c2UgbmV3IHdpdGggaW1wb3J0KC4uLikuXCIsXG4gIEltcG9ydENhbGxTcHJlYWRBcmd1bWVudDogXCJgLi4uYCBpcyBub3QgYWxsb3dlZCBpbiBgaW1wb3J0KClgLlwiLFxuICBJbXBvcnRKU09OQmluZGluZ05vdERlZmF1bHQ6IFwiQSBKU09OIG1vZHVsZSBjYW4gb25seSBiZSBpbXBvcnRlZCB3aXRoIGBkZWZhdWx0YC5cIixcbiAgSW1wb3J0UmVmbGVjdGlvbkhhc0Fzc2VydGlvbjogXCJgaW1wb3J0IG1vZHVsZSB4YCBjYW5ub3QgaGF2ZSBhc3NlcnRpb25zLlwiLFxuICBJbXBvcnRSZWZsZWN0aW9uTm90QmluZGluZzogJ09ubHkgYGltcG9ydCBtb2R1bGUgeCBmcm9tIFwiLi9tb2R1bGVcImAgaXMgdmFsaWQuJyxcbiAgSW5jb21wYXRpYmxlUmVnRXhwVVZGbGFnczogXCJUaGUgJ3UnIGFuZCAndicgcmVndWxhciBleHByZXNzaW9uIGZsYWdzIGNhbm5vdCBiZSBlbmFibGVkIGF0IHRoZSBzYW1lIHRpbWUuXCIsXG4gIEludmFsaWRCaWdJbnRMaXRlcmFsOiBcIkludmFsaWQgQmlnSW50TGl0ZXJhbC5cIixcbiAgSW52YWxpZENvZGVQb2ludDogXCJDb2RlIHBvaW50IG91dCBvZiBib3VuZHMuXCIsXG4gIEludmFsaWRDb3ZlckRpc2NhcmRFbGVtZW50OiBcIid2b2lkJyBtdXN0IGJlIGZvbGxvd2VkIGJ5IGFuIGV4cHJlc3Npb24gd2hlbiBub3QgdXNlZCBpbiBhIGJpbmRpbmcgcG9zaXRpb24uXCIsXG4gIEludmFsaWRDb3ZlckluaXRpYWxpemVkTmFtZTogXCJJbnZhbGlkIHNob3J0aGFuZCBwcm9wZXJ0eSBpbml0aWFsaXplci5cIixcbiAgSW52YWxpZERlY2ltYWw6IFwiSW52YWxpZCBkZWNpbWFsLlwiLFxuICBJbnZhbGlkRGlnaXQ6ICh7XG4gICAgcmFkaXhcbiAgfSkgPT4gYEV4cGVjdGVkIG51bWJlciBpbiByYWRpeCAke3JhZGl4fS5gLFxuICBJbnZhbGlkRXNjYXBlU2VxdWVuY2U6IFwiQmFkIGNoYXJhY3RlciBlc2NhcGUgc2VxdWVuY2UuXCIsXG4gIEludmFsaWRFc2NhcGVTZXF1ZW5jZVRlbXBsYXRlOiBcIkludmFsaWQgZXNjYXBlIHNlcXVlbmNlIGluIHRlbXBsYXRlLlwiLFxuICBJbnZhbGlkRXNjYXBlZFJlc2VydmVkV29yZDogKHtcbiAgICByZXNlcnZlZFdvcmRcbiAgfSkgPT4gYEVzY2FwZSBzZXF1ZW5jZSBpbiBrZXl3b3JkICR7cmVzZXJ2ZWRXb3JkfS5gLFxuICBJbnZhbGlkSWRlbnRpZmllcjogKHtcbiAgICBpZGVudGlmaWVyTmFtZVxuICB9KSA9PiBgSW52YWxpZCBpZGVudGlmaWVyICR7aWRlbnRpZmllck5hbWV9LmAsXG4gIEludmFsaWRMaHM6ICh7XG4gICAgYW5jZXN0b3JcbiAgfSkgPT4gYEludmFsaWQgbGVmdC1oYW5kIHNpZGUgaW4gJHt0b05vZGVEZXNjcmlwdGlvbihhbmNlc3Rvcil9LmAsXG4gIEludmFsaWRMaHNCaW5kaW5nOiAoe1xuICAgIGFuY2VzdG9yXG4gIH0pID0+IGBCaW5kaW5nIGludmFsaWQgbGVmdC1oYW5kIHNpZGUgaW4gJHt0b05vZGVEZXNjcmlwdGlvbihhbmNlc3Rvcil9LmAsXG4gIEludmFsaWRMaHNPcHRpb25hbENoYWluaW5nOiAoe1xuICAgIGFuY2VzdG9yXG4gIH0pID0+IGBJbnZhbGlkIG9wdGlvbmFsIGNoYWluaW5nIGluIHRoZSBsZWZ0LWhhbmQgc2lkZSBvZiAke3RvTm9kZURlc2NyaXB0aW9uKGFuY2VzdG9yKX0uYCxcbiAgSW52YWxpZE51bWJlcjogXCJJbnZhbGlkIG51bWJlci5cIixcbiAgSW52YWxpZE9yTWlzc2luZ0V4cG9uZW50OiBcIkZsb2F0aW5nLXBvaW50IG51bWJlcnMgcmVxdWlyZSBhIHZhbGlkIGV4cG9uZW50IGFmdGVyIHRoZSAnZScuXCIsXG4gIEludmFsaWRPclVuZXhwZWN0ZWRUb2tlbjogKHtcbiAgICB1bmV4cGVjdGVkXG4gIH0pID0+IGBVbmV4cGVjdGVkIGNoYXJhY3RlciAnJHt1bmV4cGVjdGVkfScuYCxcbiAgSW52YWxpZFBhcmVudGhlc2l6ZWRBc3NpZ25tZW50OiBcIkludmFsaWQgcGFyZW50aGVzaXplZCBhc3NpZ25tZW50IHBhdHRlcm4uXCIsXG4gIEludmFsaWRQcml2YXRlRmllbGRSZXNvbHV0aW9uOiAoe1xuICAgIGlkZW50aWZpZXJOYW1lXG4gIH0pID0+IGBQcml2YXRlIG5hbWUgIyR7aWRlbnRpZmllck5hbWV9IGlzIG5vdCBkZWZpbmVkLmAsXG4gIEludmFsaWRQcm9wZXJ0eUJpbmRpbmdQYXR0ZXJuOiBcIkJpbmRpbmcgbWVtYmVyIGV4cHJlc3Npb24uXCIsXG4gIEludmFsaWRSZWNvcmRQcm9wZXJ0eTogXCJPbmx5IHByb3BlcnRpZXMgYW5kIHNwcmVhZCBlbGVtZW50cyBhcmUgYWxsb3dlZCBpbiByZWNvcmQgZGVmaW5pdGlvbnMuXCIsXG4gIEludmFsaWRSZXN0QXNzaWdubWVudFBhdHRlcm46IFwiSW52YWxpZCByZXN0IG9wZXJhdG9yJ3MgYXJndW1lbnQuXCIsXG4gIExhYmVsUmVkZWNsYXJhdGlvbjogKHtcbiAgICBsYWJlbE5hbWVcbiAgfSkgPT4gYExhYmVsICcke2xhYmVsTmFtZX0nIGlzIGFscmVhZHkgZGVjbGFyZWQuYCxcbiAgTGV0SW5MZXhpY2FsQmluZGluZzogXCInbGV0JyBpcyBkaXNhbGxvd2VkIGFzIGEgbGV4aWNhbGx5IGJvdW5kIG5hbWUuXCIsXG4gIExpbmVUZXJtaW5hdG9yQmVmb3JlQXJyb3c6IFwiTm8gbGluZSBicmVhayBpcyBhbGxvd2VkIGJlZm9yZSAnPT4nLlwiLFxuICBNYWxmb3JtZWRSZWdFeHBGbGFnczogXCJJbnZhbGlkIHJlZ3VsYXIgZXhwcmVzc2lvbiBmbGFnLlwiLFxuICBNaXNzaW5nQ2xhc3NOYW1lOiBcIkEgY2xhc3MgbmFtZSBpcyByZXF1aXJlZC5cIixcbiAgTWlzc2luZ0VxSW5Bc3NpZ25tZW50OiBcIk9ubHkgJz0nIG9wZXJhdG9yIGNhbiBiZSB1c2VkIGZvciBzcGVjaWZ5aW5nIGRlZmF1bHQgdmFsdWUuXCIsXG4gIE1pc3NpbmdTZW1pY29sb246IFwiTWlzc2luZyBzZW1pY29sb24uXCIsXG4gIE1pc3NpbmdQbHVnaW46ICh7XG4gICAgbWlzc2luZ1BsdWdpblxuICB9KSA9PiBgVGhpcyBleHBlcmltZW50YWwgc3ludGF4IHJlcXVpcmVzIGVuYWJsaW5nIHRoZSBwYXJzZXIgcGx1Z2luOiAke21pc3NpbmdQbHVnaW4ubWFwKG5hbWUgPT4gSlNPTi5zdHJpbmdpZnkobmFtZSkpLmpvaW4oXCIsIFwiKX0uYCxcbiAgTWlzc2luZ09uZU9mUGx1Z2luczogKHtcbiAgICBtaXNzaW5nUGx1Z2luXG4gIH0pID0+IGBUaGlzIGV4cGVyaW1lbnRhbCBzeW50YXggcmVxdWlyZXMgZW5hYmxpbmcgb25lIG9mIHRoZSBmb2xsb3dpbmcgcGFyc2VyIHBsdWdpbihzKTogJHttaXNzaW5nUGx1Z2luLm1hcChuYW1lID0+IEpTT04uc3RyaW5naWZ5KG5hbWUpKS5qb2luKFwiLCBcIil9LmAsXG4gIE1pc3NpbmdVbmljb2RlRXNjYXBlOiBcIkV4cGVjdGluZyBVbmljb2RlIGVzY2FwZSBzZXF1ZW5jZSBcXFxcdVhYWFguXCIsXG4gIE1peGluZ0NvYWxlc2NlV2l0aExvZ2ljYWw6IFwiTnVsbGlzaCBjb2FsZXNjaW5nIG9wZXJhdG9yKD8/KSByZXF1aXJlcyBwYXJlbnMgd2hlbiBtaXhpbmcgd2l0aCBsb2dpY2FsIG9wZXJhdG9ycy5cIixcbiAgTW9kdWxlQXR0cmlidXRlRGlmZmVyZW50RnJvbVR5cGU6IFwiVGhlIG9ubHkgYWNjZXB0ZWQgbW9kdWxlIGF0dHJpYnV0ZSBpcyBgdHlwZWAuXCIsXG4gIE1vZHVsZUF0dHJpYnV0ZUludmFsaWRWYWx1ZTogXCJPbmx5IHN0cmluZyBsaXRlcmFscyBhcmUgYWxsb3dlZCBhcyBtb2R1bGUgYXR0cmlidXRlIHZhbHVlcy5cIixcbiAgTW9kdWxlQXR0cmlidXRlc1dpdGhEdXBsaWNhdGVLZXlzOiAoe1xuICAgIGtleVxuICB9KSA9PiBgRHVwbGljYXRlIGtleSBcIiR7a2V5fVwiIGlzIG5vdCBhbGxvd2VkIGluIG1vZHVsZSBhdHRyaWJ1dGVzLmAsXG4gIE1vZHVsZUV4cG9ydE5hbWVIYXNMb25lU3Vycm9nYXRlOiAoe1xuICAgIHN1cnJvZ2F0ZUNoYXJDb2RlXG4gIH0pID0+IGBBbiBleHBvcnQgbmFtZSBjYW5ub3QgaW5jbHVkZSBhIGxvbmUgc3Vycm9nYXRlLCBmb3VuZCAnXFxcXHUke3N1cnJvZ2F0ZUNoYXJDb2RlLnRvU3RyaW5nKDE2KX0nLmAsXG4gIE1vZHVsZUV4cG9ydFVuZGVmaW5lZDogKHtcbiAgICBsb2NhbE5hbWVcbiAgfSkgPT4gYEV4cG9ydCAnJHtsb2NhbE5hbWV9JyBpcyBub3QgZGVmaW5lZC5gLFxuICBNdWx0aXBsZURlZmF1bHRzSW5Td2l0Y2g6IFwiTXVsdGlwbGUgZGVmYXVsdCBjbGF1c2VzLlwiLFxuICBOZXdsaW5lQWZ0ZXJUaHJvdzogXCJJbGxlZ2FsIG5ld2xpbmUgYWZ0ZXIgdGhyb3cuXCIsXG4gIE5vQ2F0Y2hPckZpbmFsbHk6IFwiTWlzc2luZyBjYXRjaCBvciBmaW5hbGx5IGNsYXVzZS5cIixcbiAgTnVtYmVySWRlbnRpZmllcjogXCJJZGVudGlmaWVyIGRpcmVjdGx5IGFmdGVyIG51bWJlci5cIixcbiAgTnVtZXJpY1NlcGFyYXRvckluRXNjYXBlU2VxdWVuY2U6IFwiTnVtZXJpYyBzZXBhcmF0b3JzIGFyZSBub3QgYWxsb3dlZCBpbnNpZGUgdW5pY29kZSBlc2NhcGUgc2VxdWVuY2VzIG9yIGhleCBlc2NhcGUgc2VxdWVuY2VzLlwiLFxuICBPYnNvbGV0ZUF3YWl0U3RhcjogXCInYXdhaXQqJyBoYXMgYmVlbiByZW1vdmVkIGZyb20gdGhlIGFzeW5jIGZ1bmN0aW9ucyBwcm9wb3NhbC4gVXNlIFByb21pc2UuYWxsKCkgaW5zdGVhZC5cIixcbiAgT3B0aW9uYWxDaGFpbmluZ05vTmV3OiBcIkNvbnN0cnVjdG9ycyBpbi9hZnRlciBhbiBPcHRpb25hbCBDaGFpbiBhcmUgbm90IGFsbG93ZWQuXCIsXG4gIE9wdGlvbmFsQ2hhaW5pbmdOb1RlbXBsYXRlOiBcIlRhZ2dlZCBUZW1wbGF0ZSBMaXRlcmFscyBhcmUgbm90IGFsbG93ZWQgaW4gb3B0aW9uYWxDaGFpbi5cIixcbiAgT3ZlcnJpZGVPbkNvbnN0cnVjdG9yOiBcIidvdmVycmlkZScgbW9kaWZpZXIgY2Fubm90IGFwcGVhciBvbiBhIGNvbnN0cnVjdG9yIGRlY2xhcmF0aW9uLlwiLFxuICBQYXJhbUR1cGU6IFwiQXJndW1lbnQgbmFtZSBjbGFzaC5cIixcbiAgUGF0dGVybkhhc0FjY2Vzc29yOiBcIk9iamVjdCBwYXR0ZXJuIGNhbid0IGNvbnRhaW4gZ2V0dGVyIG9yIHNldHRlci5cIixcbiAgUGF0dGVybkhhc01ldGhvZDogXCJPYmplY3QgcGF0dGVybiBjYW4ndCBjb250YWluIG1ldGhvZHMuXCIsXG4gIFByaXZhdGVJbkV4cGVjdGVkSW46ICh7XG4gICAgaWRlbnRpZmllck5hbWVcbiAgfSkgPT4gYFByaXZhdGUgbmFtZXMgYXJlIG9ubHkgYWxsb3dlZCBpbiBwcm9wZXJ0eSBhY2Nlc3NlcyAoXFxgb2JqLiMke2lkZW50aWZpZXJOYW1lfVxcYCkgb3IgaW4gXFxgaW5cXGAgZXhwcmVzc2lvbnMgKFxcYCMke2lkZW50aWZpZXJOYW1lfSBpbiBvYmpcXGApLmAsXG4gIFByaXZhdGVOYW1lUmVkZWNsYXJhdGlvbjogKHtcbiAgICBpZGVudGlmaWVyTmFtZVxuICB9KSA9PiBgRHVwbGljYXRlIHByaXZhdGUgbmFtZSAjJHtpZGVudGlmaWVyTmFtZX0uYCxcbiAgUmVjb3JkRXhwcmVzc2lvbkJhckluY29ycmVjdEVuZFN5bnRheFR5cGU6IFwiUmVjb3JkIGV4cHJlc3Npb25zIGVuZGluZyB3aXRoICd8fScgYXJlIG9ubHkgYWxsb3dlZCB3aGVuIHRoZSAnc3ludGF4VHlwZScgb3B0aW9uIG9mIHRoZSAncmVjb3JkQW5kVHVwbGUnIHBsdWdpbiBpcyBzZXQgdG8gJ2JhcicuXCIsXG4gIFJlY29yZEV4cHJlc3Npb25CYXJJbmNvcnJlY3RTdGFydFN5bnRheFR5cGU6IFwiUmVjb3JkIGV4cHJlc3Npb25zIHN0YXJ0aW5nIHdpdGggJ3t8JyBhcmUgb25seSBhbGxvd2VkIHdoZW4gdGhlICdzeW50YXhUeXBlJyBvcHRpb24gb2YgdGhlICdyZWNvcmRBbmRUdXBsZScgcGx1Z2luIGlzIHNldCB0byAnYmFyJy5cIixcbiAgUmVjb3JkRXhwcmVzc2lvbkhhc2hJbmNvcnJlY3RTdGFydFN5bnRheFR5cGU6IFwiUmVjb3JkIGV4cHJlc3Npb25zIHN0YXJ0aW5nIHdpdGggJyN7JyBhcmUgb25seSBhbGxvd2VkIHdoZW4gdGhlICdzeW50YXhUeXBlJyBvcHRpb24gb2YgdGhlICdyZWNvcmRBbmRUdXBsZScgcGx1Z2luIGlzIHNldCB0byAnaGFzaCcuXCIsXG4gIFJlY29yZE5vUHJvdG86IFwiJ19fcHJvdG9fXycgaXMgbm90IGFsbG93ZWQgaW4gUmVjb3JkIGV4cHJlc3Npb25zLlwiLFxuICBSZXN0VHJhaWxpbmdDb21tYTogXCJVbmV4cGVjdGVkIHRyYWlsaW5nIGNvbW1hIGFmdGVyIHJlc3QgZWxlbWVudC5cIixcbiAgU2xvcHB5RnVuY3Rpb246IFwiSW4gbm9uLXN0cmljdCBtb2RlIGNvZGUsIGZ1bmN0aW9ucyBjYW4gb25seSBiZSBkZWNsYXJlZCBhdCB0b3AgbGV2ZWwgb3IgaW5zaWRlIGEgYmxvY2suXCIsXG4gIFNsb3BweUZ1bmN0aW9uQW5uZXhCOiBcIkluIG5vbi1zdHJpY3QgbW9kZSBjb2RlLCBmdW5jdGlvbnMgY2FuIG9ubHkgYmUgZGVjbGFyZWQgYXQgdG9wIGxldmVsLCBpbnNpZGUgYSBibG9jaywgb3IgYXMgdGhlIGJvZHkgb2YgYW4gaWYgc3RhdGVtZW50LlwiLFxuICBTb3VyY2VQaGFzZUltcG9ydFJlcXVpcmVzRGVmYXVsdDogJ09ubHkgYGltcG9ydCBzb3VyY2UgeCBmcm9tIFwiLi9tb2R1bGVcImAgaXMgdmFsaWQuJyxcbiAgU3RhdGljUHJvdG90eXBlOiBcIkNsYXNzZXMgbWF5IG5vdCBoYXZlIHN0YXRpYyBwcm9wZXJ0eSBuYW1lZCBwcm90b3R5cGUuXCIsXG4gIFN1cGVyTm90QWxsb3dlZDogXCJgc3VwZXIoKWAgaXMgb25seSB2YWxpZCBpbnNpZGUgYSBjbGFzcyBjb25zdHJ1Y3RvciBvZiBhIHN1YmNsYXNzLiBNYXliZSBhIHR5cG8gaW4gdGhlIG1ldGhvZCBuYW1lICgnY29uc3RydWN0b3InKSBvciBub3QgZXh0ZW5kaW5nIGFub3RoZXIgY2xhc3M/XCIsXG4gIFN1cGVyUHJpdmF0ZUZpZWxkOiBcIlByaXZhdGUgZmllbGRzIGNhbid0IGJlIGFjY2Vzc2VkIG9uIHN1cGVyLlwiLFxuICBUcmFpbGluZ0RlY29yYXRvcjogXCJEZWNvcmF0b3JzIG11c3QgYmUgYXR0YWNoZWQgdG8gYSBjbGFzcyBlbGVtZW50LlwiLFxuICBUdXBsZUV4cHJlc3Npb25CYXJJbmNvcnJlY3RFbmRTeW50YXhUeXBlOiBcIlR1cGxlIGV4cHJlc3Npb25zIGVuZGluZyB3aXRoICd8XScgYXJlIG9ubHkgYWxsb3dlZCB3aGVuIHRoZSAnc3ludGF4VHlwZScgb3B0aW9uIG9mIHRoZSAncmVjb3JkQW5kVHVwbGUnIHBsdWdpbiBpcyBzZXQgdG8gJ2JhcicuXCIsXG4gIFR1cGxlRXhwcmVzc2lvbkJhckluY29ycmVjdFN0YXJ0U3ludGF4VHlwZTogXCJUdXBsZSBleHByZXNzaW9ucyBzdGFydGluZyB3aXRoICdbfCcgYXJlIG9ubHkgYWxsb3dlZCB3aGVuIHRoZSAnc3ludGF4VHlwZScgb3B0aW9uIG9mIHRoZSAncmVjb3JkQW5kVHVwbGUnIHBsdWdpbiBpcyBzZXQgdG8gJ2JhcicuXCIsXG4gIFR1cGxlRXhwcmVzc2lvbkhhc2hJbmNvcnJlY3RTdGFydFN5bnRheFR5cGU6IFwiVHVwbGUgZXhwcmVzc2lvbnMgc3RhcnRpbmcgd2l0aCAnI1snIGFyZSBvbmx5IGFsbG93ZWQgd2hlbiB0aGUgJ3N5bnRheFR5cGUnIG9wdGlvbiBvZiB0aGUgJ3JlY29yZEFuZFR1cGxlJyBwbHVnaW4gaXMgc2V0IHRvICdoYXNoJy5cIixcbiAgVW5leHBlY3RlZEFyZ3VtZW50UGxhY2Vob2xkZXI6IFwiVW5leHBlY3RlZCBhcmd1bWVudCBwbGFjZWhvbGRlci5cIixcbiAgVW5leHBlY3RlZEF3YWl0QWZ0ZXJQaXBlbGluZUJvZHk6ICdVbmV4cGVjdGVkIFwiYXdhaXRcIiBhZnRlciBwaXBlbGluZSBib2R5OyBhd2FpdCBtdXN0IGhhdmUgcGFyZW50aGVzZXMgaW4gbWluaW1hbCBwcm9wb3NhbC4nLFxuICBVbmV4cGVjdGVkRGlnaXRBZnRlckhhc2g6IFwiVW5leHBlY3RlZCBkaWdpdCBhZnRlciBoYXNoIHRva2VuLlwiLFxuICBVbmV4cGVjdGVkSW1wb3J0RXhwb3J0OiBcIidpbXBvcnQnIGFuZCAnZXhwb3J0JyBtYXkgb25seSBhcHBlYXIgYXQgdGhlIHRvcCBsZXZlbC5cIixcbiAgVW5leHBlY3RlZEtleXdvcmQ6ICh7XG4gICAga2V5d29yZFxuICB9KSA9PiBgVW5leHBlY3RlZCBrZXl3b3JkICcke2tleXdvcmR9Jy5gLFxuICBVbmV4cGVjdGVkTGVhZGluZ0RlY29yYXRvcjogXCJMZWFkaW5nIGRlY29yYXRvcnMgbXVzdCBiZSBhdHRhY2hlZCB0byBhIGNsYXNzIGRlY2xhcmF0aW9uLlwiLFxuICBVbmV4cGVjdGVkTGV4aWNhbERlY2xhcmF0aW9uOiBcIkxleGljYWwgZGVjbGFyYXRpb24gY2Fubm90IGFwcGVhciBpbiBhIHNpbmdsZS1zdGF0ZW1lbnQgY29udGV4dC5cIixcbiAgVW5leHBlY3RlZE5ld1RhcmdldDogXCJgbmV3LnRhcmdldGAgY2FuIG9ubHkgYmUgdXNlZCBpbiBmdW5jdGlvbnMgb3IgY2xhc3MgcHJvcGVydGllcy5cIixcbiAgVW5leHBlY3RlZE51bWVyaWNTZXBhcmF0b3I6IFwiQSBudW1lcmljIHNlcGFyYXRvciBpcyBvbmx5IGFsbG93ZWQgYmV0d2VlbiB0d28gZGlnaXRzLlwiLFxuICBVbmV4cGVjdGVkUHJpdmF0ZUZpZWxkOiBcIlVuZXhwZWN0ZWQgcHJpdmF0ZSBuYW1lLlwiLFxuICBVbmV4cGVjdGVkUmVzZXJ2ZWRXb3JkOiAoe1xuICAgIHJlc2VydmVkV29yZFxuICB9KSA9PiBgVW5leHBlY3RlZCByZXNlcnZlZCB3b3JkICcke3Jlc2VydmVkV29yZH0nLmAsXG4gIFVuZXhwZWN0ZWRTdXBlcjogXCInc3VwZXInIGlzIG9ubHkgYWxsb3dlZCBpbiBvYmplY3QgbWV0aG9kcyBhbmQgY2xhc3Nlcy5cIixcbiAgVW5leHBlY3RlZFRva2VuOiAoe1xuICAgIGV4cGVjdGVkLFxuICAgIHVuZXhwZWN0ZWRcbiAgfSkgPT4gYFVuZXhwZWN0ZWQgdG9rZW4ke3VuZXhwZWN0ZWQgPyBgICcke3VuZXhwZWN0ZWR9Jy5gIDogXCJcIn0ke2V4cGVjdGVkID8gYCwgZXhwZWN0ZWQgXCIke2V4cGVjdGVkfVwiYCA6IFwiXCJ9YCxcbiAgVW5leHBlY3RlZFRva2VuVW5hcnlFeHBvbmVudGlhdGlvbjogXCJJbGxlZ2FsIGV4cHJlc3Npb24uIFdyYXAgbGVmdCBoYW5kIHNpZGUgb3IgZW50aXJlIGV4cG9uZW50aWF0aW9uIGluIHBhcmVudGhlc2VzLlwiLFxuICBVbmV4cGVjdGVkVXNpbmdEZWNsYXJhdGlvbjogXCJVc2luZyBkZWNsYXJhdGlvbiBjYW5ub3QgYXBwZWFyIGluIHRoZSB0b3AgbGV2ZWwgd2hlbiBzb3VyY2UgdHlwZSBpcyBgc2NyaXB0YCBvciBpbiB0aGUgYmFyZSBjYXNlIHN0YXRlbWVudC5cIixcbiAgVW5leHBlY3RlZFZvaWRQYXR0ZXJuOiBcIlVuZXhwZWN0ZWQgdm9pZCBiaW5kaW5nLlwiLFxuICBVbnN1cHBvcnRlZEJpbmQ6IFwiQmluZGluZyBzaG91bGQgYmUgcGVyZm9ybWVkIG9uIG9iamVjdCBwcm9wZXJ0eS5cIixcbiAgVW5zdXBwb3J0ZWREZWNvcmF0b3JFeHBvcnQ6IFwiQSBkZWNvcmF0ZWQgZXhwb3J0IG11c3QgZXhwb3J0IGEgY2xhc3MgZGVjbGFyYXRpb24uXCIsXG4gIFVuc3VwcG9ydGVkRGVmYXVsdEV4cG9ydDogXCJPbmx5IGV4cHJlc3Npb25zLCBmdW5jdGlvbnMgb3IgY2xhc3NlcyBhcmUgYWxsb3dlZCBhcyB0aGUgYGRlZmF1bHRgIGV4cG9ydC5cIixcbiAgVW5zdXBwb3J0ZWRJbXBvcnQ6IFwiYGltcG9ydGAgY2FuIG9ubHkgYmUgdXNlZCBpbiBgaW1wb3J0KClgIG9yIGBpbXBvcnQubWV0YWAuXCIsXG4gIFVuc3VwcG9ydGVkTWV0YVByb3BlcnR5OiAoe1xuICAgIHRhcmdldCxcbiAgICBvbmx5VmFsaWRQcm9wZXJ0eU5hbWVcbiAgfSkgPT4gYFRoZSBvbmx5IHZhbGlkIG1ldGEgcHJvcGVydHkgZm9yICR7dGFyZ2V0fSBpcyAke3RhcmdldH0uJHtvbmx5VmFsaWRQcm9wZXJ0eU5hbWV9LmAsXG4gIFVuc3VwcG9ydGVkUGFyYW1ldGVyRGVjb3JhdG9yOiBcIkRlY29yYXRvcnMgY2Fubm90IGJlIHVzZWQgdG8gZGVjb3JhdGUgcGFyYW1ldGVycy5cIixcbiAgVW5zdXBwb3J0ZWRQcm9wZXJ0eURlY29yYXRvcjogXCJEZWNvcmF0b3JzIGNhbm5vdCBiZSB1c2VkIHRvIGRlY29yYXRlIG9iamVjdCBsaXRlcmFsIHByb3BlcnRpZXMuXCIsXG4gIFVuc3VwcG9ydGVkU3VwZXI6IFwiJ3N1cGVyJyBjYW4gb25seSBiZSB1c2VkIHdpdGggZnVuY3Rpb24gY2FsbHMgKGkuZS4gc3VwZXIoKSkgb3IgaW4gcHJvcGVydHkgYWNjZXNzZXMgKGkuZS4gc3VwZXIucHJvcCBvciBzdXBlcltwcm9wXSkuXCIsXG4gIFVudGVybWluYXRlZENvbW1lbnQ6IFwiVW50ZXJtaW5hdGVkIGNvbW1lbnQuXCIsXG4gIFVudGVybWluYXRlZFJlZ0V4cDogXCJVbnRlcm1pbmF0ZWQgcmVndWxhciBleHByZXNzaW9uLlwiLFxuICBVbnRlcm1pbmF0ZWRTdHJpbmc6IFwiVW50ZXJtaW5hdGVkIHN0cmluZyBjb25zdGFudC5cIixcbiAgVW50ZXJtaW5hdGVkVGVtcGxhdGU6IFwiVW50ZXJtaW5hdGVkIHRlbXBsYXRlLlwiLFxuICBVc2luZ0RlY2xhcmF0aW9uRXhwb3J0OiBcIlVzaW5nIGRlY2xhcmF0aW9uIGNhbm5vdCBiZSBleHBvcnRlZC5cIixcbiAgVXNpbmdEZWNsYXJhdGlvbkhhc0JpbmRpbmdQYXR0ZXJuOiBcIlVzaW5nIGRlY2xhcmF0aW9uIGNhbm5vdCBoYXZlIGRlc3RydWN0dXJpbmcgcGF0dGVybnMuXCIsXG4gIFZhclJlZGVjbGFyYXRpb246ICh7XG4gICAgaWRlbnRpZmllck5hbWVcbiAgfSkgPT4gYElkZW50aWZpZXIgJyR7aWRlbnRpZmllck5hbWV9JyBoYXMgYWxyZWFkeSBiZWVuIGRlY2xhcmVkLmAsXG4gIFZvaWRQYXR0ZXJuQ2F0Y2hDbGF1c2VQYXJhbTogXCJBIHZvaWQgYmluZGluZyBjYW4gbm90IGJlIHRoZSBjYXRjaCBjbGF1c2UgcGFyYW1ldGVyLiBVc2UgYHRyeSB7IC4uLiB9IGNhdGNoIHsgLi4uIH1gIGlmIHlvdSB3YW50IHRvIGRpc2NhcmQgdGhlIGNhdWdodCBlcnJvci5cIixcbiAgVm9pZFBhdHRlcm5Jbml0aWFsaXplcjogXCJBIHZvaWQgYmluZGluZyBtYXkgbm90IGhhdmUgYW4gaW5pdGlhbGl6ZXIuXCIsXG4gIFlpZWxkQmluZGluZ0lkZW50aWZpZXI6IFwiQ2FuIG5vdCB1c2UgJ3lpZWxkJyBhcyBpZGVudGlmaWVyIGluc2lkZSBhIGdlbmVyYXRvci5cIixcbiAgWWllbGRJblBhcmFtZXRlcjogXCJZaWVsZCBleHByZXNzaW9uIGlzIG5vdCBhbGxvd2VkIGluIGZvcm1hbCBwYXJhbWV0ZXJzLlwiLFxuICBZaWVsZE5vdEluR2VuZXJhdG9yRnVuY3Rpb246IFwiJ3lpZWxkJyBpcyBvbmx5IGFsbG93ZWQgd2l0aGluIGdlbmVyYXRvciBmdW5jdGlvbnMuXCIsXG4gIFplcm9EaWdpdE51bWVyaWNTZXBhcmF0b3I6IFwiTnVtZXJpYyBzZXBhcmF0b3IgY2FuIG5vdCBiZSB1c2VkIGFmdGVyIGxlYWRpbmcgMC5cIlxufTtcbnZhciBTdHJpY3RNb2RlRXJyb3JzID0ge1xuICBTdHJpY3REZWxldGU6IFwiRGVsZXRpbmcgbG9jYWwgdmFyaWFibGUgaW4gc3RyaWN0IG1vZGUuXCIsXG4gIFN0cmljdEV2YWxBcmd1bWVudHM6ICh7XG4gICAgcmVmZXJlbmNlTmFtZVxuICB9KSA9PiBgQXNzaWduaW5nIHRvICcke3JlZmVyZW5jZU5hbWV9JyBpbiBzdHJpY3QgbW9kZS5gLFxuICBTdHJpY3RFdmFsQXJndW1lbnRzQmluZGluZzogKHtcbiAgICBiaW5kaW5nTmFtZVxuICB9KSA9PiBgQmluZGluZyAnJHtiaW5kaW5nTmFtZX0nIGluIHN0cmljdCBtb2RlLmAsXG4gIFN0cmljdEZ1bmN0aW9uOiBcIkluIHN0cmljdCBtb2RlIGNvZGUsIGZ1bmN0aW9ucyBjYW4gb25seSBiZSBkZWNsYXJlZCBhdCB0b3AgbGV2ZWwgb3IgaW5zaWRlIGEgYmxvY2suXCIsXG4gIFN0cmljdE51bWVyaWNFc2NhcGU6IFwiVGhlIG9ubHkgdmFsaWQgbnVtZXJpYyBlc2NhcGUgaW4gc3RyaWN0IG1vZGUgaXMgJ1xcXFwwJy5cIixcbiAgU3RyaWN0T2N0YWxMaXRlcmFsOiBcIkxlZ2FjeSBvY3RhbCBsaXRlcmFscyBhcmUgbm90IGFsbG93ZWQgaW4gc3RyaWN0IG1vZGUuXCIsXG4gIFN0cmljdFdpdGg6IFwiJ3dpdGgnIGluIHN0cmljdCBtb2RlLlwiXG59O1xudmFyIFBhcnNlRXhwcmVzc2lvbkVycm9ycyA9IHtcbiAgUGFyc2VFeHByZXNzaW9uRW1wdHlJbnB1dDogXCJVbmV4cGVjdGVkIHBhcnNlRXhwcmVzc2lvbigpIGlucHV0OiBUaGUgaW5wdXQgaXMgZW1wdHkgb3IgY29udGFpbnMgb25seSBjb21tZW50cy5cIixcbiAgUGFyc2VFeHByZXNzaW9uRXhwZWN0c0VPRjogKHtcbiAgICB1bmV4cGVjdGVkXG4gIH0pID0+IGBVbmV4cGVjdGVkIHBhcnNlRXhwcmVzc2lvbigpIGlucHV0OiBUaGUgaW5wdXQgc2hvdWxkIGNvbnRhaW4gZXhhY3RseSBvbmUgZXhwcmVzc2lvbiwgYnV0IHRoZSBmaXJzdCBleHByZXNzaW9uIGlzIGZvbGxvd2VkIGJ5IHRoZSB1bmV4cGVjdGVkIGNoYXJhY3RlciBcXGAke1N0cmluZy5mcm9tQ29kZVBvaW50KHVuZXhwZWN0ZWQpfVxcYC5gXG59O1xuY29uc3QgVW5wYXJlbnRoZXNpemVkUGlwZUJvZHlEZXNjcmlwdGlvbnMgPSBuZXcgU2V0KFtcIkFycm93RnVuY3Rpb25FeHByZXNzaW9uXCIsIFwiQXNzaWdubWVudEV4cHJlc3Npb25cIiwgXCJDb25kaXRpb25hbEV4cHJlc3Npb25cIiwgXCJZaWVsZEV4cHJlc3Npb25cIl0pO1xudmFyIFBpcGVsaW5lT3BlcmF0b3JFcnJvcnMgPSBPYmplY3QuYXNzaWduKHtcbiAgUGlwZUJvZHlJc1RpZ2h0ZXI6IFwiVW5leHBlY3RlZCB5aWVsZCBhZnRlciBwaXBlbGluZSBib2R5OyBhbnkgeWllbGQgZXhwcmVzc2lvbiBhY3RpbmcgYXMgSGFjay1zdHlsZSBwaXBlIGJvZHkgbXVzdCBiZSBwYXJlbnRoZXNpemVkIGR1ZSB0byBpdHMgbG9vc2Ugb3BlcmF0b3IgcHJlY2VkZW5jZS5cIixcbiAgUGlwZVRvcGljUmVxdWlyZXNIYWNrUGlwZXM6ICdUb3BpYyByZWZlcmVuY2UgaXMgdXNlZCwgYnV0IHRoZSBwaXBlbGluZU9wZXJhdG9yIHBsdWdpbiB3YXMgbm90IHBhc3NlZCBhIFwicHJvcG9zYWxcIjogXCJoYWNrXCIgb3IgXCJzbWFydFwiIG9wdGlvbi4nLFxuICBQaXBlVG9waWNVbmJvdW5kOiBcIlRvcGljIHJlZmVyZW5jZSBpcyB1bmJvdW5kOyBpdCBtdXN0IGJlIGluc2lkZSBhIHBpcGUgYm9keS5cIixcbiAgUGlwZVRvcGljVW5jb25maWd1cmVkVG9rZW46ICh7XG4gICAgdG9rZW5cbiAgfSkgPT4gYEludmFsaWQgdG9waWMgdG9rZW4gJHt0b2tlbn0uIEluIG9yZGVyIHRvIHVzZSAke3Rva2VufSBhcyBhIHRvcGljIHJlZmVyZW5jZSwgdGhlIHBpcGVsaW5lT3BlcmF0b3IgcGx1Z2luIG11c3QgYmUgY29uZmlndXJlZCB3aXRoIHsgXCJwcm9wb3NhbFwiOiBcImhhY2tcIiwgXCJ0b3BpY1Rva2VuXCI6IFwiJHt0b2tlbn1cIiB9LmAsXG4gIFBpcGVUb3BpY1VudXNlZDogXCJIYWNrLXN0eWxlIHBpcGUgYm9keSBkb2VzIG5vdCBjb250YWluIGEgdG9waWMgcmVmZXJlbmNlOyBIYWNrLXN0eWxlIHBpcGVzIG11c3QgdXNlIHRvcGljIGF0IGxlYXN0IG9uY2UuXCIsXG4gIFBpcGVVbnBhcmVudGhlc2l6ZWRCb2R5OiAoe1xuICAgIHR5cGVcbiAgfSkgPT4gYEhhY2stc3R5bGUgcGlwZSBib2R5IGNhbm5vdCBiZSBhbiB1bnBhcmVudGhlc2l6ZWQgJHt0b05vZGVEZXNjcmlwdGlvbih7XG4gICAgdHlwZVxuICB9KX07IHBsZWFzZSB3cmFwIGl0IGluIHBhcmVudGhlc2VzLmBcbn0sIHtcbiAgUGlwZWxpbmVCb2R5Tm9BcnJvdzogJ1VuZXhwZWN0ZWQgYXJyb3cgXCI9PlwiIGFmdGVyIHBpcGVsaW5lIGJvZHk7IGFycm93IGZ1bmN0aW9uIGluIHBpcGVsaW5lIGJvZHkgbXVzdCBiZSBwYXJlbnRoZXNpemVkLicsXG4gIFBpcGVsaW5lQm9keVNlcXVlbmNlRXhwcmVzc2lvbjogXCJQaXBlbGluZSBib2R5IG1heSBub3QgYmUgYSBjb21tYS1zZXBhcmF0ZWQgc2VxdWVuY2UgZXhwcmVzc2lvbi5cIixcbiAgUGlwZWxpbmVIZWFkU2VxdWVuY2VFeHByZXNzaW9uOiBcIlBpcGVsaW5lIGhlYWQgc2hvdWxkIG5vdCBiZSBhIGNvbW1hLXNlcGFyYXRlZCBzZXF1ZW5jZSBleHByZXNzaW9uLlwiLFxuICBQaXBlbGluZVRvcGljVW51c2VkOiBcIlBpcGVsaW5lIGlzIGluIHRvcGljIHN0eWxlIGJ1dCBkb2VzIG5vdCB1c2UgdG9waWMgcmVmZXJlbmNlLlwiLFxuICBQcmltYXJ5VG9waWNOb3RBbGxvd2VkOiBcIlRvcGljIHJlZmVyZW5jZSB3YXMgdXNlZCBpbiBhIGxleGljYWwgY29udGV4dCB3aXRob3V0IHRvcGljIGJpbmRpbmcuXCIsXG4gIFByaW1hcnlUb3BpY1JlcXVpcmVzU21hcnRQaXBlbGluZTogJ1RvcGljIHJlZmVyZW5jZSBpcyB1c2VkLCBidXQgdGhlIHBpcGVsaW5lT3BlcmF0b3IgcGx1Z2luIHdhcyBub3QgcGFzc2VkIGEgXCJwcm9wb3NhbFwiOiBcImhhY2tcIiBvciBcInNtYXJ0XCIgb3B0aW9uLidcbn0pO1xuY29uc3QgX2V4Y2x1ZGVkID0gW1wibWVzc2FnZVwiXTtcbmZ1bmN0aW9uIGRlZmluZUhpZGRlbihvYmosIGtleSwgdmFsdWUpIHtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iaiwga2V5LCB7XG4gICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgIHZhbHVlXG4gIH0pO1xufVxuZnVuY3Rpb24gdG9QYXJzZUVycm9yQ29uc3RydWN0b3Ioe1xuICB0b01lc3NhZ2UsXG4gIGNvZGUsXG4gIHJlYXNvbkNvZGUsXG4gIHN5bnRheFBsdWdpblxufSkge1xuICBjb25zdCBoYXNNaXNzaW5nUGx1Z2luID0gcmVhc29uQ29kZSA9PT0gXCJNaXNzaW5nUGx1Z2luXCIgfHwgcmVhc29uQ29kZSA9PT0gXCJNaXNzaW5nT25lT2ZQbHVnaW5zXCI7XG4gIGNvbnN0IG9sZFJlYXNvbkNvZGVzID0ge1xuICAgIEFjY2Vzc29yQ2Fubm90RGVjbGFyZVRoaXNQYXJhbWV0ZXI6IFwiQWNjZXNvckNhbm5vdERlY2xhcmVUaGlzUGFyYW1ldGVyXCIsXG4gICAgQWNjZXNzb3JDYW5ub3RIYXZlVHlwZVBhcmFtZXRlcnM6IFwiQWNjZXNvckNhbm5vdEhhdmVUeXBlUGFyYW1ldGVyc1wiLFxuICAgIENvbnN0SW5pdGlhbGl6ZXJNdXN0QmVTdHJpbmdPck51bWVyaWNMaXRlcmFsT3JMaXRlcmFsRW51bVJlZmVyZW5jZTogXCJDb25zdEluaXRpYWlsaXplck11c3RCZVN0cmluZ09yTnVtZXJpY0xpdGVyYWxPckxpdGVyYWxFbnVtUmVmZXJlbmNlXCIsXG4gICAgU2V0QWNjZXNzb3JDYW5ub3RIYXZlT3B0aW9uYWxQYXJhbWV0ZXI6IFwiU2V0QWNjZXNvckNhbm5vdEhhdmVPcHRpb25hbFBhcmFtZXRlclwiLFxuICAgIFNldEFjY2Vzc29yQ2Fubm90SGF2ZVJlc3RQYXJhbWV0ZXI6IFwiU2V0QWNjZXNvckNhbm5vdEhhdmVSZXN0UGFyYW1ldGVyXCIsXG4gICAgU2V0QWNjZXNzb3JDYW5ub3RIYXZlUmV0dXJuVHlwZTogXCJTZXRBY2Nlc29yQ2Fubm90SGF2ZVJldHVyblR5cGVcIlxuICB9O1xuICBpZiAob2xkUmVhc29uQ29kZXNbcmVhc29uQ29kZV0pIHtcbiAgICByZWFzb25Db2RlID0gb2xkUmVhc29uQ29kZXNbcmVhc29uQ29kZV07XG4gIH1cbiAgcmV0dXJuIGZ1bmN0aW9uIGNvbnN0cnVjdG9yKGxvYywgZGV0YWlscykge1xuICAgIGNvbnN0IGVycm9yID0gbmV3IFN5bnRheEVycm9yKCk7XG4gICAgZXJyb3IuY29kZSA9IGNvZGU7XG4gICAgZXJyb3IucmVhc29uQ29kZSA9IHJlYXNvbkNvZGU7XG4gICAgZXJyb3IubG9jID0gbG9jO1xuICAgIGVycm9yLnBvcyA9IGxvYy5pbmRleDtcbiAgICBlcnJvci5zeW50YXhQbHVnaW4gPSBzeW50YXhQbHVnaW47XG4gICAgaWYgKGhhc01pc3NpbmdQbHVnaW4pIHtcbiAgICAgIGVycm9yLm1pc3NpbmdQbHVnaW4gPSBkZXRhaWxzLm1pc3NpbmdQbHVnaW47XG4gICAgfVxuICAgIGRlZmluZUhpZGRlbihlcnJvciwgXCJjbG9uZVwiLCBmdW5jdGlvbiBjbG9uZShvdmVycmlkZXMgPSB7fSkge1xuICAgICAgdmFyIF9vdmVycmlkZXMkbG9jO1xuICAgICAgY29uc3Qge1xuICAgICAgICBsaW5lLFxuICAgICAgICBjb2x1bW4sXG4gICAgICAgIGluZGV4XG4gICAgICB9ID0gKF9vdmVycmlkZXMkbG9jID0gb3ZlcnJpZGVzLmxvYykgIT0gbnVsbCA/IF9vdmVycmlkZXMkbG9jIDogbG9jO1xuICAgICAgcmV0dXJuIGNvbnN0cnVjdG9yKG5ldyBQb3NpdGlvbihsaW5lLCBjb2x1bW4sIGluZGV4KSwgT2JqZWN0LmFzc2lnbih7fSwgZGV0YWlscywgb3ZlcnJpZGVzLmRldGFpbHMpKTtcbiAgICB9KTtcbiAgICBkZWZpbmVIaWRkZW4oZXJyb3IsIFwiZGV0YWlsc1wiLCBkZXRhaWxzKTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXJyb3IsIFwibWVzc2FnZVwiLCB7XG4gICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICBnZXQoKSB7XG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBgJHt0b01lc3NhZ2UoZGV0YWlscyl9ICgke2xvYy5saW5lfToke2xvYy5jb2x1bW59KWA7XG4gICAgICAgIHRoaXMubWVzc2FnZSA9IG1lc3NhZ2U7XG4gICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgICAgfSxcbiAgICAgIHNldCh2YWx1ZSkge1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJtZXNzYWdlXCIsIHtcbiAgICAgICAgICB2YWx1ZSxcbiAgICAgICAgICB3cml0YWJsZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gZXJyb3I7XG4gIH07XG59XG5mdW5jdGlvbiBQYXJzZUVycm9yRW51bShhcmd1bWVudCwgc3ludGF4UGx1Z2luKSB7XG4gIGlmIChBcnJheS5pc0FycmF5KGFyZ3VtZW50KSkge1xuICAgIHJldHVybiBwYXJzZUVycm9yVGVtcGxhdGVzID0+IFBhcnNlRXJyb3JFbnVtKHBhcnNlRXJyb3JUZW1wbGF0ZXMsIGFyZ3VtZW50WzBdKTtcbiAgfVxuICBjb25zdCBQYXJzZUVycm9yQ29uc3RydWN0b3JzID0ge307XG4gIGZvciAoY29uc3QgcmVhc29uQ29kZSBvZiBPYmplY3Qua2V5cyhhcmd1bWVudCkpIHtcbiAgICBjb25zdCB0ZW1wbGF0ZSA9IGFyZ3VtZW50W3JlYXNvbkNvZGVdO1xuICAgIGNvbnN0IF9yZWYgPSB0eXBlb2YgdGVtcGxhdGUgPT09IFwic3RyaW5nXCIgPyB7XG4gICAgICAgIG1lc3NhZ2U6ICgpID0+IHRlbXBsYXRlXG4gICAgICB9IDogdHlwZW9mIHRlbXBsYXRlID09PSBcImZ1bmN0aW9uXCIgPyB7XG4gICAgICAgIG1lc3NhZ2U6IHRlbXBsYXRlXG4gICAgICB9IDogdGVtcGxhdGUsXG4gICAgICB7XG4gICAgICAgIG1lc3NhZ2VcbiAgICAgIH0gPSBfcmVmLFxuICAgICAgcmVzdCA9IF9vYmplY3RXaXRob3V0UHJvcGVydGllc0xvb3NlKF9yZWYsIF9leGNsdWRlZCk7XG4gICAgY29uc3QgdG9NZXNzYWdlID0gdHlwZW9mIG1lc3NhZ2UgPT09IFwic3RyaW5nXCIgPyAoKSA9PiBtZXNzYWdlIDogbWVzc2FnZTtcbiAgICBQYXJzZUVycm9yQ29uc3RydWN0b3JzW3JlYXNvbkNvZGVdID0gdG9QYXJzZUVycm9yQ29uc3RydWN0b3IoT2JqZWN0LmFzc2lnbih7XG4gICAgICBjb2RlOiBcIkJBQkVMX1BBUlNFUl9TWU5UQVhfRVJST1JcIixcbiAgICAgIHJlYXNvbkNvZGUsXG4gICAgICB0b01lc3NhZ2VcbiAgICB9LCBzeW50YXhQbHVnaW4gPyB7XG4gICAgICBzeW50YXhQbHVnaW5cbiAgICB9IDoge30sIHJlc3QpKTtcbiAgfVxuICByZXR1cm4gUGFyc2VFcnJvckNvbnN0cnVjdG9ycztcbn1cbmNvbnN0IEVycm9ycyA9IE9iamVjdC5hc3NpZ24oe30sIFBhcnNlRXJyb3JFbnVtKE1vZHVsZUVycm9ycyksIFBhcnNlRXJyb3JFbnVtKFN0YW5kYXJkRXJyb3JzKSwgUGFyc2VFcnJvckVudW0oU3RyaWN0TW9kZUVycm9ycyksIFBhcnNlRXJyb3JFbnVtKFBhcnNlRXhwcmVzc2lvbkVycm9ycyksIFBhcnNlRXJyb3JFbnVtYHBpcGVsaW5lT3BlcmF0b3JgKFBpcGVsaW5lT3BlcmF0b3JFcnJvcnMpKTtcbmZ1bmN0aW9uIGNyZWF0ZURlZmF1bHRPcHRpb25zKCkge1xuICByZXR1cm4ge1xuICAgIHNvdXJjZVR5cGU6IFwic2NyaXB0XCIsXG4gICAgc291cmNlRmlsZW5hbWU6IHVuZGVmaW5lZCxcbiAgICBzdGFydEluZGV4OiAwLFxuICAgIHN0YXJ0Q29sdW1uOiAwLFxuICAgIHN0YXJ0TGluZTogMSxcbiAgICBhbGxvd0F3YWl0T3V0c2lkZUZ1bmN0aW9uOiBmYWxzZSxcbiAgICBhbGxvd1JldHVybk91dHNpZGVGdW5jdGlvbjogZmFsc2UsXG4gICAgYWxsb3dOZXdUYXJnZXRPdXRzaWRlRnVuY3Rpb246IGZhbHNlLFxuICAgIGFsbG93SW1wb3J0RXhwb3J0RXZlcnl3aGVyZTogZmFsc2UsXG4gICAgYWxsb3dTdXBlck91dHNpZGVNZXRob2Q6IGZhbHNlLFxuICAgIGFsbG93VW5kZWNsYXJlZEV4cG9ydHM6IGZhbHNlLFxuICAgIGFsbG93WWllbGRPdXRzaWRlRnVuY3Rpb246IGZhbHNlLFxuICAgIHBsdWdpbnM6IFtdLFxuICAgIHN0cmljdE1vZGU6IHVuZGVmaW5lZCxcbiAgICByYW5nZXM6IGZhbHNlLFxuICAgIHRva2VuczogZmFsc2UsXG4gICAgY3JlYXRlSW1wb3J0RXhwcmVzc2lvbnM6IGZhbHNlLFxuICAgIGNyZWF0ZVBhcmVudGhlc2l6ZWRFeHByZXNzaW9uczogZmFsc2UsXG4gICAgZXJyb3JSZWNvdmVyeTogZmFsc2UsXG4gICAgYXR0YWNoQ29tbWVudDogdHJ1ZSxcbiAgICBhbm5leEI6IHRydWVcbiAgfTtcbn1cbmZ1bmN0aW9uIGdldE9wdGlvbnMob3B0cykge1xuICBjb25zdCBvcHRpb25zID0gY3JlYXRlRGVmYXVsdE9wdGlvbnMoKTtcbiAgaWYgKG9wdHMgPT0gbnVsbCkge1xuICAgIHJldHVybiBvcHRpb25zO1xuICB9XG4gIGlmIChvcHRzLmFubmV4QiAhPSBudWxsICYmIG9wdHMuYW5uZXhCICE9PSBmYWxzZSkge1xuICAgIHRocm93IG5ldyBFcnJvcihcIlRoZSBgYW5uZXhCYCBvcHRpb24gY2FuIG9ubHkgYmUgc2V0IHRvIGBmYWxzZWAuXCIpO1xuICB9XG4gIGZvciAoY29uc3Qga2V5IG9mIE9iamVjdC5rZXlzKG9wdGlvbnMpKSB7XG4gICAgaWYgKG9wdHNba2V5XSAhPSBudWxsKSBvcHRpb25zW2tleV0gPSBvcHRzW2tleV07XG4gIH1cbiAgaWYgKG9wdGlvbnMuc3RhcnRMaW5lID09PSAxKSB7XG4gICAgaWYgKG9wdHMuc3RhcnRJbmRleCA9PSBudWxsICYmIG9wdGlvbnMuc3RhcnRDb2x1bW4gPiAwKSB7XG4gICAgICBvcHRpb25zLnN0YXJ0SW5kZXggPSBvcHRpb25zLnN0YXJ0Q29sdW1uO1xuICAgIH0gZWxzZSBpZiAob3B0cy5zdGFydENvbHVtbiA9PSBudWxsICYmIG9wdGlvbnMuc3RhcnRJbmRleCA+IDApIHtcbiAgICAgIG9wdGlvbnMuc3RhcnRDb2x1bW4gPSBvcHRpb25zLnN0YXJ0SW5kZXg7XG4gICAgfVxuICB9IGVsc2UgaWYgKG9wdHMuc3RhcnRDb2x1bW4gPT0gbnVsbCB8fCBvcHRzLnN0YXJ0SW5kZXggPT0gbnVsbCkge1xuICAgIGlmIChvcHRzLnN0YXJ0SW5kZXggIT0gbnVsbCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiV2l0aCBhIGBzdGFydExpbmUgPiAxYCB5b3UgbXVzdCBhbHNvIHNwZWNpZnkgYHN0YXJ0SW5kZXhgIGFuZCBgc3RhcnRDb2x1bW5gLlwiKTtcbiAgICB9XG4gIH1cbiAgaWYgKG9wdGlvbnMuc291cmNlVHlwZSA9PT0gXCJjb21tb25qc1wiKSB7XG4gICAgaWYgKG9wdHMuYWxsb3dBd2FpdE91dHNpZGVGdW5jdGlvbiAhPSBudWxsKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJUaGUgYGFsbG93QXdhaXRPdXRzaWRlRnVuY3Rpb25gIG9wdGlvbiBjYW5ub3QgYmUgdXNlZCB3aXRoIGBzb3VyY2VUeXBlOiAnY29tbW9uanMnYC5cIik7XG4gICAgfVxuICAgIGlmIChvcHRzLmFsbG93UmV0dXJuT3V0c2lkZUZ1bmN0aW9uICE9IG51bGwpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcImBzb3VyY2VUeXBlOiAnY29tbW9uanMnYCBpbXBsaWVzIGBhbGxvd1JldHVybk91dHNpZGVGdW5jdGlvbjogdHJ1ZWAsIHBsZWFzZSByZW1vdmUgdGhlIGBhbGxvd1JldHVybk91dHNpZGVGdW5jdGlvbmAgb3B0aW9uIG9yIHVzZSBgc291cmNlVHlwZTogJ3NjcmlwdCdgLlwiKTtcbiAgICB9XG4gICAgaWYgKG9wdHMuYWxsb3dOZXdUYXJnZXRPdXRzaWRlRnVuY3Rpb24gIT0gbnVsbCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiYHNvdXJjZVR5cGU6ICdjb21tb25qcydgIGltcGxpZXMgYGFsbG93TmV3VGFyZ2V0T3V0c2lkZUZ1bmN0aW9uOiB0cnVlYCwgcGxlYXNlIHJlbW92ZSB0aGUgYGFsbG93TmV3VGFyZ2V0T3V0c2lkZUZ1bmN0aW9uYCBvcHRpb24gb3IgdXNlIGBzb3VyY2VUeXBlOiAnc2NyaXB0J2AuXCIpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gb3B0aW9ucztcbn1cbmNvbnN0IHtcbiAgZGVmaW5lUHJvcGVydHlcbn0gPSBPYmplY3Q7XG5jb25zdCB0b1VuZW51bWVyYWJsZSA9IChvYmplY3QsIGtleSkgPT4ge1xuICBpZiAob2JqZWN0KSB7XG4gICAgZGVmaW5lUHJvcGVydHkob2JqZWN0LCBrZXksIHtcbiAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgdmFsdWU6IG9iamVjdFtrZXldXG4gICAgfSk7XG4gIH1cbn07XG5mdW5jdGlvbiB0b0VTVHJlZUxvY2F0aW9uKG5vZGUpIHtcbiAgdG9VbmVudW1lcmFibGUobm9kZS5sb2Muc3RhcnQsIFwiaW5kZXhcIik7XG4gIHRvVW5lbnVtZXJhYmxlKG5vZGUubG9jLmVuZCwgXCJpbmRleFwiKTtcbiAgcmV0dXJuIG5vZGU7XG59XG52YXIgZXN0cmVlID0gc3VwZXJDbGFzcyA9PiBjbGFzcyBFU1RyZWVQYXJzZXJNaXhpbiBleHRlbmRzIHN1cGVyQ2xhc3Mge1xuICBwYXJzZSgpIHtcbiAgICBjb25zdCBmaWxlID0gdG9FU1RyZWVMb2NhdGlvbihzdXBlci5wYXJzZSgpKTtcbiAgICBpZiAodGhpcy5vcHRpb25GbGFncyAmIDI1Nikge1xuICAgICAgZmlsZS50b2tlbnMgPSBmaWxlLnRva2Vucy5tYXAodG9FU1RyZWVMb2NhdGlvbik7XG4gICAgfVxuICAgIHJldHVybiBmaWxlO1xuICB9XG4gIHBhcnNlUmVnRXhwTGl0ZXJhbCh7XG4gICAgcGF0dGVybixcbiAgICBmbGFnc1xuICB9KSB7XG4gICAgbGV0IHJlZ2V4ID0gbnVsbDtcbiAgICB0cnkge1xuICAgICAgcmVnZXggPSBuZXcgUmVnRXhwKHBhdHRlcm4sIGZsYWdzKTtcbiAgICB9IGNhdGNoIChfKSB7fVxuICAgIGNvbnN0IG5vZGUgPSB0aGlzLmVzdHJlZVBhcnNlTGl0ZXJhbChyZWdleCk7XG4gICAgbm9kZS5yZWdleCA9IHtcbiAgICAgIHBhdHRlcm4sXG4gICAgICBmbGFnc1xuICAgIH07XG4gICAgcmV0dXJuIG5vZGU7XG4gIH1cbiAgcGFyc2VCaWdJbnRMaXRlcmFsKHZhbHVlKSB7XG4gICAgbGV0IGJpZ0ludDtcbiAgICB0cnkge1xuICAgICAgYmlnSW50ID0gQmlnSW50KHZhbHVlKTtcbiAgICB9IGNhdGNoIChfdW51c2VkKSB7XG4gICAgICBiaWdJbnQgPSBudWxsO1xuICAgIH1cbiAgICBjb25zdCBub2RlID0gdGhpcy5lc3RyZWVQYXJzZUxpdGVyYWwoYmlnSW50KTtcbiAgICBub2RlLmJpZ2ludCA9IFN0cmluZyhub2RlLnZhbHVlIHx8IHZhbHVlKTtcbiAgICByZXR1cm4gbm9kZTtcbiAgfVxuICBwYXJzZURlY2ltYWxMaXRlcmFsKHZhbHVlKSB7XG4gICAgY29uc3QgZGVjaW1hbCA9IG51bGw7XG4gICAgY29uc3Qgbm9kZSA9IHRoaXMuZXN0cmVlUGFyc2VMaXRlcmFsKGRlY2ltYWwpO1xuICAgIG5vZGUuZGVjaW1hbCA9IFN0cmluZyhub2RlLnZhbHVlIHx8IHZhbHVlKTtcbiAgICByZXR1cm4gbm9kZTtcbiAgfVxuICBlc3RyZWVQYXJzZUxpdGVyYWwodmFsdWUpIHtcbiAgICByZXR1cm4gdGhpcy5wYXJzZUxpdGVyYWwodmFsdWUsIFwiTGl0ZXJhbFwiKTtcbiAgfVxuICBwYXJzZVN0cmluZ0xpdGVyYWwodmFsdWUpIHtcbiAgICByZXR1cm4gdGhpcy5lc3RyZWVQYXJzZUxpdGVyYWwodmFsdWUpO1xuICB9XG4gIHBhcnNlTnVtZXJpY0xpdGVyYWwodmFsdWUpIHtcbiAgICByZXR1cm4gdGhpcy5lc3RyZWVQYXJzZUxpdGVyYWwodmFsdWUpO1xuICB9XG4gIHBhcnNlTnVsbExpdGVyYWwoKSB7XG4gICAgcmV0dXJuIHRoaXMuZXN0cmVlUGFyc2VMaXRlcmFsKG51bGwpO1xuICB9XG4gIHBhcnNlQm9vbGVhbkxpdGVyYWwodmFsdWUpIHtcbiAgICByZXR1cm4gdGhpcy5lc3RyZWVQYXJzZUxpdGVyYWwodmFsdWUpO1xuICB9XG4gIGVzdHJlZVBhcnNlQ2hhaW5FeHByZXNzaW9uKG5vZGUsIGVuZExvYykge1xuICAgIGNvbnN0IGNoYWluID0gdGhpcy5zdGFydE5vZGVBdE5vZGUobm9kZSk7XG4gICAgY2hhaW4uZXhwcmVzc2lvbiA9IG5vZGU7XG4gICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZUF0KGNoYWluLCBcIkNoYWluRXhwcmVzc2lvblwiLCBlbmRMb2MpO1xuICB9XG4gIGRpcmVjdGl2ZVRvU3RtdChkaXJlY3RpdmUpIHtcbiAgICBjb25zdCBleHByZXNzaW9uID0gZGlyZWN0aXZlLnZhbHVlO1xuICAgIGRlbGV0ZSBkaXJlY3RpdmUudmFsdWU7XG4gICAgdGhpcy5jYXN0Tm9kZVRvKGV4cHJlc3Npb24sIFwiTGl0ZXJhbFwiKTtcbiAgICBleHByZXNzaW9uLnJhdyA9IGV4cHJlc3Npb24uZXh0cmEucmF3O1xuICAgIGV4cHJlc3Npb24udmFsdWUgPSBleHByZXNzaW9uLmV4dHJhLmV4cHJlc3Npb25WYWx1ZTtcbiAgICBjb25zdCBzdG10ID0gdGhpcy5jYXN0Tm9kZVRvKGRpcmVjdGl2ZSwgXCJFeHByZXNzaW9uU3RhdGVtZW50XCIpO1xuICAgIHN0bXQuZXhwcmVzc2lvbiA9IGV4cHJlc3Npb247XG4gICAgc3RtdC5kaXJlY3RpdmUgPSBleHByZXNzaW9uLmV4dHJhLnJhd1ZhbHVlO1xuICAgIGRlbGV0ZSBleHByZXNzaW9uLmV4dHJhO1xuICAgIHJldHVybiBzdG10O1xuICB9XG4gIGZpbGxPcHRpb25hbFByb3BlcnRpZXNGb3JUU0VTTGludChub2RlKSB7fVxuICBjbG9uZUVzdHJlZVN0cmluZ0xpdGVyYWwobm9kZSkge1xuICAgIGNvbnN0IHtcbiAgICAgIHN0YXJ0LFxuICAgICAgZW5kLFxuICAgICAgbG9jLFxuICAgICAgcmFuZ2UsXG4gICAgICByYXcsXG4gICAgICB2YWx1ZVxuICAgIH0gPSBub2RlO1xuICAgIGNvbnN0IGNsb25lZCA9IE9iamVjdC5jcmVhdGUobm9kZS5jb25zdHJ1Y3Rvci5wcm90b3R5cGUpO1xuICAgIGNsb25lZC50eXBlID0gXCJMaXRlcmFsXCI7XG4gICAgY2xvbmVkLnN0YXJ0ID0gc3RhcnQ7XG4gICAgY2xvbmVkLmVuZCA9IGVuZDtcbiAgICBjbG9uZWQubG9jID0gbG9jO1xuICAgIGNsb25lZC5yYW5nZSA9IHJhbmdlO1xuICAgIGNsb25lZC5yYXcgPSByYXc7XG4gICAgY2xvbmVkLnZhbHVlID0gdmFsdWU7XG4gICAgcmV0dXJuIGNsb25lZDtcbiAgfVxuICBpbml0RnVuY3Rpb24obm9kZSwgaXNBc3luYykge1xuICAgIHN1cGVyLmluaXRGdW5jdGlvbihub2RlLCBpc0FzeW5jKTtcbiAgICBub2RlLmV4cHJlc3Npb24gPSBmYWxzZTtcbiAgfVxuICBjaGVja0RlY2xhcmF0aW9uKG5vZGUpIHtcbiAgICBpZiAobm9kZSAhPSBudWxsICYmIHRoaXMuaXNPYmplY3RQcm9wZXJ0eShub2RlKSkge1xuICAgICAgdGhpcy5jaGVja0RlY2xhcmF0aW9uKG5vZGUudmFsdWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICBzdXBlci5jaGVja0RlY2xhcmF0aW9uKG5vZGUpO1xuICAgIH1cbiAgfVxuICBnZXRPYmplY3RPckNsYXNzTWV0aG9kUGFyYW1zKG1ldGhvZCkge1xuICAgIHJldHVybiBtZXRob2QudmFsdWUucGFyYW1zO1xuICB9XG4gIGlzVmFsaWREaXJlY3RpdmUoc3RtdCkge1xuICAgIHZhciBfc3RtdCRleHByZXNzaW9uJGV4dHI7XG4gICAgcmV0dXJuIHN0bXQudHlwZSA9PT0gXCJFeHByZXNzaW9uU3RhdGVtZW50XCIgJiYgc3RtdC5leHByZXNzaW9uLnR5cGUgPT09IFwiTGl0ZXJhbFwiICYmIHR5cGVvZiBzdG10LmV4cHJlc3Npb24udmFsdWUgPT09IFwic3RyaW5nXCIgJiYgISgoX3N0bXQkZXhwcmVzc2lvbiRleHRyID0gc3RtdC5leHByZXNzaW9uLmV4dHJhKSAhPSBudWxsICYmIF9zdG10JGV4cHJlc3Npb24kZXh0ci5wYXJlbnRoZXNpemVkKTtcbiAgfVxuICBwYXJzZUJsb2NrQm9keShub2RlLCBhbGxvd0RpcmVjdGl2ZXMsIHRvcExldmVsLCBlbmQsIGFmdGVyQmxvY2tQYXJzZSkge1xuICAgIHN1cGVyLnBhcnNlQmxvY2tCb2R5KG5vZGUsIGFsbG93RGlyZWN0aXZlcywgdG9wTGV2ZWwsIGVuZCwgYWZ0ZXJCbG9ja1BhcnNlKTtcbiAgICBjb25zdCBkaXJlY3RpdmVTdGF0ZW1lbnRzID0gbm9kZS5kaXJlY3RpdmVzLm1hcChkID0+IHRoaXMuZGlyZWN0aXZlVG9TdG10KGQpKTtcbiAgICBub2RlLmJvZHkgPSBkaXJlY3RpdmVTdGF0ZW1lbnRzLmNvbmNhdChub2RlLmJvZHkpO1xuICAgIGRlbGV0ZSBub2RlLmRpcmVjdGl2ZXM7XG4gIH1cbiAgcGFyc2VQcml2YXRlTmFtZSgpIHtcbiAgICBjb25zdCBub2RlID0gc3VwZXIucGFyc2VQcml2YXRlTmFtZSgpO1xuICAgIGlmICghdGhpcy5nZXRQbHVnaW5PcHRpb24oXCJlc3RyZWVcIiwgXCJjbGFzc0ZlYXR1cmVzXCIpKSB7XG4gICAgICByZXR1cm4gbm9kZTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuY29udmVydFByaXZhdGVOYW1lVG9Qcml2YXRlSWRlbnRpZmllcihub2RlKTtcbiAgfVxuICBjb252ZXJ0UHJpdmF0ZU5hbWVUb1ByaXZhdGVJZGVudGlmaWVyKG5vZGUpIHtcbiAgICBjb25zdCBuYW1lID0gc3VwZXIuZ2V0UHJpdmF0ZU5hbWVTVihub2RlKTtcbiAgICBkZWxldGUgbm9kZS5pZDtcbiAgICBub2RlLm5hbWUgPSBuYW1lO1xuICAgIHJldHVybiB0aGlzLmNhc3ROb2RlVG8obm9kZSwgXCJQcml2YXRlSWRlbnRpZmllclwiKTtcbiAgfVxuICBpc1ByaXZhdGVOYW1lKG5vZGUpIHtcbiAgICBpZiAoIXRoaXMuZ2V0UGx1Z2luT3B0aW9uKFwiZXN0cmVlXCIsIFwiY2xhc3NGZWF0dXJlc1wiKSkge1xuICAgICAgcmV0dXJuIHN1cGVyLmlzUHJpdmF0ZU5hbWUobm9kZSk7XG4gICAgfVxuICAgIHJldHVybiBub2RlLnR5cGUgPT09IFwiUHJpdmF0ZUlkZW50aWZpZXJcIjtcbiAgfVxuICBnZXRQcml2YXRlTmFtZVNWKG5vZGUpIHtcbiAgICBpZiAoIXRoaXMuZ2V0UGx1Z2luT3B0aW9uKFwiZXN0cmVlXCIsIFwiY2xhc3NGZWF0dXJlc1wiKSkge1xuICAgICAgcmV0dXJuIHN1cGVyLmdldFByaXZhdGVOYW1lU1Yobm9kZSk7XG4gICAgfVxuICAgIHJldHVybiBub2RlLm5hbWU7XG4gIH1cbiAgcGFyc2VMaXRlcmFsKHZhbHVlLCB0eXBlKSB7XG4gICAgY29uc3Qgbm9kZSA9IHN1cGVyLnBhcnNlTGl0ZXJhbCh2YWx1ZSwgdHlwZSk7XG4gICAgbm9kZS5yYXcgPSBub2RlLmV4dHJhLnJhdztcbiAgICBkZWxldGUgbm9kZS5leHRyYTtcbiAgICByZXR1cm4gbm9kZTtcbiAgfVxuICBwYXJzZUZ1bmN0aW9uQm9keShub2RlLCBhbGxvd0V4cHJlc3Npb24sIGlzTWV0aG9kID0gZmFsc2UpIHtcbiAgICBzdXBlci5wYXJzZUZ1bmN0aW9uQm9keShub2RlLCBhbGxvd0V4cHJlc3Npb24sIGlzTWV0aG9kKTtcbiAgICBub2RlLmV4cHJlc3Npb24gPSBub2RlLmJvZHkudHlwZSAhPT0gXCJCbG9ja1N0YXRlbWVudFwiO1xuICB9XG4gIHBhcnNlTWV0aG9kKG5vZGUsIGlzR2VuZXJhdG9yLCBpc0FzeW5jLCBpc0NvbnN0cnVjdG9yLCBhbGxvd0RpcmVjdFN1cGVyLCB0eXBlLCBpbkNsYXNzU2NvcGUgPSBmYWxzZSkge1xuICAgIGxldCBmdW5jTm9kZSA9IHRoaXMuc3RhcnROb2RlKCk7XG4gICAgZnVuY05vZGUua2luZCA9IG5vZGUua2luZDtcbiAgICBmdW5jTm9kZSA9IHN1cGVyLnBhcnNlTWV0aG9kKGZ1bmNOb2RlLCBpc0dlbmVyYXRvciwgaXNBc3luYywgaXNDb25zdHJ1Y3RvciwgYWxsb3dEaXJlY3RTdXBlciwgdHlwZSwgaW5DbGFzc1Njb3BlKTtcbiAgICBkZWxldGUgZnVuY05vZGUua2luZDtcbiAgICBjb25zdCB7XG4gICAgICB0eXBlUGFyYW1ldGVyc1xuICAgIH0gPSBub2RlO1xuICAgIGlmICh0eXBlUGFyYW1ldGVycykge1xuICAgICAgZGVsZXRlIG5vZGUudHlwZVBhcmFtZXRlcnM7XG4gICAgICBmdW5jTm9kZS50eXBlUGFyYW1ldGVycyA9IHR5cGVQYXJhbWV0ZXJzO1xuICAgICAgdGhpcy5yZXNldFN0YXJ0TG9jYXRpb25Gcm9tTm9kZShmdW5jTm9kZSwgdHlwZVBhcmFtZXRlcnMpO1xuICAgIH1cbiAgICBjb25zdCB2YWx1ZU5vZGUgPSB0aGlzLmNhc3ROb2RlVG8oZnVuY05vZGUsIFwiRnVuY3Rpb25FeHByZXNzaW9uXCIpO1xuICAgIG5vZGUudmFsdWUgPSB2YWx1ZU5vZGU7XG4gICAgaWYgKHR5cGUgPT09IFwiQ2xhc3NQcml2YXRlTWV0aG9kXCIpIHtcbiAgICAgIG5vZGUuY29tcHV0ZWQgPSBmYWxzZTtcbiAgICB9XG4gICAgaWYgKHR5cGUgPT09IFwiT2JqZWN0TWV0aG9kXCIpIHtcbiAgICAgIGlmIChub2RlLmtpbmQgPT09IFwibWV0aG9kXCIpIHtcbiAgICAgICAgbm9kZS5raW5kID0gXCJpbml0XCI7XG4gICAgICB9XG4gICAgICBub2RlLnNob3J0aGFuZCA9IGZhbHNlO1xuICAgICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIlByb3BlcnR5XCIpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiTWV0aG9kRGVmaW5pdGlvblwiKTtcbiAgICB9XG4gIH1cbiAgbmFtZUlzQ29uc3RydWN0b3Ioa2V5KSB7XG4gICAgaWYgKGtleS50eXBlID09PSBcIkxpdGVyYWxcIikgcmV0dXJuIGtleS52YWx1ZSA9PT0gXCJjb25zdHJ1Y3RvclwiO1xuICAgIHJldHVybiBzdXBlci5uYW1lSXNDb25zdHJ1Y3RvcihrZXkpO1xuICB9XG4gIHBhcnNlQ2xhc3NQcm9wZXJ0eSguLi5hcmdzKSB7XG4gICAgY29uc3QgcHJvcGVydHlOb2RlID0gc3VwZXIucGFyc2VDbGFzc1Byb3BlcnR5KC4uLmFyZ3MpO1xuICAgIGlmICghdGhpcy5nZXRQbHVnaW5PcHRpb24oXCJlc3RyZWVcIiwgXCJjbGFzc0ZlYXR1cmVzXCIpKSB7XG4gICAgICByZXR1cm4gcHJvcGVydHlOb2RlO1xuICAgIH1cbiAgICB0aGlzLmNhc3ROb2RlVG8ocHJvcGVydHlOb2RlLCBcIlByb3BlcnR5RGVmaW5pdGlvblwiKTtcbiAgICByZXR1cm4gcHJvcGVydHlOb2RlO1xuICB9XG4gIHBhcnNlQ2xhc3NQcml2YXRlUHJvcGVydHkoLi4uYXJncykge1xuICAgIGNvbnN0IHByb3BlcnR5Tm9kZSA9IHN1cGVyLnBhcnNlQ2xhc3NQcml2YXRlUHJvcGVydHkoLi4uYXJncyk7XG4gICAgaWYgKCF0aGlzLmdldFBsdWdpbk9wdGlvbihcImVzdHJlZVwiLCBcImNsYXNzRmVhdHVyZXNcIikpIHtcbiAgICAgIHJldHVybiBwcm9wZXJ0eU5vZGU7XG4gICAgfVxuICAgIHRoaXMuY2FzdE5vZGVUbyhwcm9wZXJ0eU5vZGUsIFwiUHJvcGVydHlEZWZpbml0aW9uXCIpO1xuICAgIHByb3BlcnR5Tm9kZS5jb21wdXRlZCA9IGZhbHNlO1xuICAgIHJldHVybiBwcm9wZXJ0eU5vZGU7XG4gIH1cbiAgcGFyc2VDbGFzc0FjY2Vzc29yUHJvcGVydHkobm9kZSkge1xuICAgIGNvbnN0IGFjY2Vzc29yUHJvcGVydHlOb2RlID0gc3VwZXIucGFyc2VDbGFzc0FjY2Vzc29yUHJvcGVydHkobm9kZSk7XG4gICAgaWYgKCF0aGlzLmdldFBsdWdpbk9wdGlvbihcImVzdHJlZVwiLCBcImNsYXNzRmVhdHVyZXNcIikpIHtcbiAgICAgIHJldHVybiBhY2Nlc3NvclByb3BlcnR5Tm9kZTtcbiAgICB9XG4gICAgaWYgKGFjY2Vzc29yUHJvcGVydHlOb2RlLmFic3RyYWN0ICYmIHRoaXMuaGFzUGx1Z2luKFwidHlwZXNjcmlwdFwiKSkge1xuICAgICAgZGVsZXRlIGFjY2Vzc29yUHJvcGVydHlOb2RlLmFic3RyYWN0O1xuICAgICAgdGhpcy5jYXN0Tm9kZVRvKGFjY2Vzc29yUHJvcGVydHlOb2RlLCBcIlRTQWJzdHJhY3RBY2Nlc3NvclByb3BlcnR5XCIpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmNhc3ROb2RlVG8oYWNjZXNzb3JQcm9wZXJ0eU5vZGUsIFwiQWNjZXNzb3JQcm9wZXJ0eVwiKTtcbiAgICB9XG4gICAgcmV0dXJuIGFjY2Vzc29yUHJvcGVydHlOb2RlO1xuICB9XG4gIHBhcnNlT2JqZWN0UHJvcGVydHkocHJvcCwgc3RhcnRMb2MsIGlzUGF0dGVybiwgcmVmRXhwcmVzc2lvbkVycm9ycykge1xuICAgIGNvbnN0IG5vZGUgPSBzdXBlci5wYXJzZU9iamVjdFByb3BlcnR5KHByb3AsIHN0YXJ0TG9jLCBpc1BhdHRlcm4sIHJlZkV4cHJlc3Npb25FcnJvcnMpO1xuICAgIGlmIChub2RlKSB7XG4gICAgICBub2RlLmtpbmQgPSBcImluaXRcIjtcbiAgICAgIHRoaXMuY2FzdE5vZGVUbyhub2RlLCBcIlByb3BlcnR5XCIpO1xuICAgIH1cbiAgICByZXR1cm4gbm9kZTtcbiAgfVxuICBmaW5pc2hPYmplY3RQcm9wZXJ0eShub2RlKSB7XG4gICAgbm9kZS5raW5kID0gXCJpbml0XCI7XG4gICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIlByb3BlcnR5XCIpO1xuICB9XG4gIGlzVmFsaWRMVmFsKHR5cGUsIGRpc2FsbG93Q2FsbEV4cHJlc3Npb24sIGlzVW5wYXJlbnRoZXNpemVkSW5Bc3NpZ24sIGJpbmRpbmcpIHtcbiAgICByZXR1cm4gdHlwZSA9PT0gXCJQcm9wZXJ0eVwiID8gXCJ2YWx1ZVwiIDogc3VwZXIuaXNWYWxpZExWYWwodHlwZSwgZGlzYWxsb3dDYWxsRXhwcmVzc2lvbiwgaXNVbnBhcmVudGhlc2l6ZWRJbkFzc2lnbiwgYmluZGluZyk7XG4gIH1cbiAgaXNBc3NpZ25hYmxlKG5vZGUsIGlzQmluZGluZykge1xuICAgIGlmIChub2RlICE9IG51bGwgJiYgdGhpcy5pc09iamVjdFByb3BlcnR5KG5vZGUpKSB7XG4gICAgICByZXR1cm4gdGhpcy5pc0Fzc2lnbmFibGUobm9kZS52YWx1ZSwgaXNCaW5kaW5nKTtcbiAgICB9XG4gICAgcmV0dXJuIHN1cGVyLmlzQXNzaWduYWJsZShub2RlLCBpc0JpbmRpbmcpO1xuICB9XG4gIHRvQXNzaWduYWJsZShub2RlLCBpc0xIUyA9IGZhbHNlKSB7XG4gICAgaWYgKG5vZGUgIT0gbnVsbCAmJiB0aGlzLmlzT2JqZWN0UHJvcGVydHkobm9kZSkpIHtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAga2V5LFxuICAgICAgICB2YWx1ZVxuICAgICAgfSA9IG5vZGU7XG4gICAgICBpZiAodGhpcy5pc1ByaXZhdGVOYW1lKGtleSkpIHtcbiAgICAgICAgdGhpcy5jbGFzc1Njb3BlLnVzZVByaXZhdGVOYW1lKHRoaXMuZ2V0UHJpdmF0ZU5hbWVTVihrZXkpLCBrZXkubG9jLnN0YXJ0KTtcbiAgICAgIH1cbiAgICAgIHRoaXMudG9Bc3NpZ25hYmxlKHZhbHVlLCBpc0xIUyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHN1cGVyLnRvQXNzaWduYWJsZShub2RlLCBpc0xIUyk7XG4gICAgfVxuICB9XG4gIHRvQXNzaWduYWJsZU9iamVjdEV4cHJlc3Npb25Qcm9wKHByb3AsIGlzTGFzdCwgaXNMSFMpIHtcbiAgICBpZiAocHJvcC50eXBlID09PSBcIlByb3BlcnR5XCIgJiYgKHByb3Aua2luZCA9PT0gXCJnZXRcIiB8fCBwcm9wLmtpbmQgPT09IFwic2V0XCIpKSB7XG4gICAgICB0aGlzLnJhaXNlKEVycm9ycy5QYXR0ZXJuSGFzQWNjZXNzb3IsIHByb3Aua2V5KTtcbiAgICB9IGVsc2UgaWYgKHByb3AudHlwZSA9PT0gXCJQcm9wZXJ0eVwiICYmIHByb3AubWV0aG9kKSB7XG4gICAgICB0aGlzLnJhaXNlKEVycm9ycy5QYXR0ZXJuSGFzTWV0aG9kLCBwcm9wLmtleSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHN1cGVyLnRvQXNzaWduYWJsZU9iamVjdEV4cHJlc3Npb25Qcm9wKHByb3AsIGlzTGFzdCwgaXNMSFMpO1xuICAgIH1cbiAgfVxuICBmaW5pc2hDYWxsRXhwcmVzc2lvbih1bmZpbmlzaGVkLCBvcHRpb25hbCkge1xuICAgIGNvbnN0IG5vZGUgPSBzdXBlci5maW5pc2hDYWxsRXhwcmVzc2lvbih1bmZpbmlzaGVkLCBvcHRpb25hbCk7XG4gICAgaWYgKG5vZGUuY2FsbGVlLnR5cGUgPT09IFwiSW1wb3J0XCIpIHtcbiAgICAgIHZhciBfcmVmLCBfcmVmMjtcbiAgICAgIHRoaXMuY2FzdE5vZGVUbyhub2RlLCBcIkltcG9ydEV4cHJlc3Npb25cIik7XG4gICAgICBub2RlLnNvdXJjZSA9IG5vZGUuYXJndW1lbnRzWzBdO1xuICAgICAgbm9kZS5vcHRpb25zID0gKF9yZWYgPSBub2RlLmFyZ3VtZW50c1sxXSkgIT0gbnVsbCA/IF9yZWYgOiBudWxsO1xuICAgICAgbm9kZS5hdHRyaWJ1dGVzID0gKF9yZWYyID0gbm9kZS5hcmd1bWVudHNbMV0pICE9IG51bGwgPyBfcmVmMiA6IG51bGw7XG4gICAgICBkZWxldGUgbm9kZS5hcmd1bWVudHM7XG4gICAgICBkZWxldGUgbm9kZS5jYWxsZWU7XG4gICAgfSBlbHNlIGlmIChub2RlLnR5cGUgPT09IFwiT3B0aW9uYWxDYWxsRXhwcmVzc2lvblwiKSB7XG4gICAgICB0aGlzLmNhc3ROb2RlVG8obm9kZSwgXCJDYWxsRXhwcmVzc2lvblwiKTtcbiAgICB9IGVsc2Uge1xuICAgICAgbm9kZS5vcHRpb25hbCA9IGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gbm9kZTtcbiAgfVxuICB0b1JlZmVyZW5jZWRBcmd1bWVudHMobm9kZSkge1xuICAgIGlmIChub2RlLnR5cGUgPT09IFwiSW1wb3J0RXhwcmVzc2lvblwiKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHN1cGVyLnRvUmVmZXJlbmNlZEFyZ3VtZW50cyhub2RlKTtcbiAgfVxuICBwYXJzZUV4cG9ydCh1bmZpbmlzaGVkLCBkZWNvcmF0b3JzKSB7XG4gICAgY29uc3QgZXhwb3J0U3RhcnRMb2MgPSB0aGlzLnN0YXRlLmxhc3RUb2tTdGFydExvYztcbiAgICBjb25zdCBub2RlID0gc3VwZXIucGFyc2VFeHBvcnQodW5maW5pc2hlZCwgZGVjb3JhdG9ycyk7XG4gICAgc3dpdGNoIChub2RlLnR5cGUpIHtcbiAgICAgIGNhc2UgXCJFeHBvcnRBbGxEZWNsYXJhdGlvblwiOlxuICAgICAgICBub2RlLmV4cG9ydGVkID0gbnVsbDtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFwiRXhwb3J0TmFtZWREZWNsYXJhdGlvblwiOlxuICAgICAgICBpZiAobm9kZS5zcGVjaWZpZXJzLmxlbmd0aCA9PT0gMSAmJiBub2RlLnNwZWNpZmllcnNbMF0udHlwZSA9PT0gXCJFeHBvcnROYW1lc3BhY2VTcGVjaWZpZXJcIikge1xuICAgICAgICAgIHRoaXMuY2FzdE5vZGVUbyhub2RlLCBcIkV4cG9ydEFsbERlY2xhcmF0aW9uXCIpO1xuICAgICAgICAgIG5vZGUuZXhwb3J0ZWQgPSBub2RlLnNwZWNpZmllcnNbMF0uZXhwb3J0ZWQ7XG4gICAgICAgICAgZGVsZXRlIG5vZGUuc3BlY2lmaWVycztcbiAgICAgICAgfVxuICAgICAgY2FzZSBcIkV4cG9ydERlZmF1bHREZWNsYXJhdGlvblwiOlxuICAgICAgICB7XG4gICAgICAgICAgdmFyIF9kZWNsYXJhdGlvbiRkZWNvcmF0bztcbiAgICAgICAgICBjb25zdCB7XG4gICAgICAgICAgICBkZWNsYXJhdGlvblxuICAgICAgICAgIH0gPSBub2RlO1xuICAgICAgICAgIGlmICgoZGVjbGFyYXRpb24gPT0gbnVsbCA/IHZvaWQgMCA6IGRlY2xhcmF0aW9uLnR5cGUpID09PSBcIkNsYXNzRGVjbGFyYXRpb25cIiAmJiAoKF9kZWNsYXJhdGlvbiRkZWNvcmF0byA9IGRlY2xhcmF0aW9uLmRlY29yYXRvcnMpID09IG51bGwgPyB2b2lkIDAgOiBfZGVjbGFyYXRpb24kZGVjb3JhdG8ubGVuZ3RoKSA+IDAgJiYgZGVjbGFyYXRpb24uc3RhcnQgPT09IG5vZGUuc3RhcnQpIHtcbiAgICAgICAgICAgIHRoaXMucmVzZXRTdGFydExvY2F0aW9uKG5vZGUsIGV4cG9ydFN0YXJ0TG9jKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICAgIHJldHVybiBub2RlO1xuICB9XG4gIHN0b3BQYXJzZVN1YnNjcmlwdChiYXNlLCBzdGF0ZSkge1xuICAgIGNvbnN0IG5vZGUgPSBzdXBlci5zdG9wUGFyc2VTdWJzY3JpcHQoYmFzZSwgc3RhdGUpO1xuICAgIGlmIChzdGF0ZS5vcHRpb25hbENoYWluTWVtYmVyKSB7XG4gICAgICByZXR1cm4gdGhpcy5lc3RyZWVQYXJzZUNoYWluRXhwcmVzc2lvbihub2RlLCBiYXNlLmxvYy5lbmQpO1xuICAgIH1cbiAgICByZXR1cm4gbm9kZTtcbiAgfVxuICBwYXJzZU1lbWJlcihiYXNlLCBzdGFydExvYywgc3RhdGUsIGNvbXB1dGVkLCBvcHRpb25hbCkge1xuICAgIGNvbnN0IG5vZGUgPSBzdXBlci5wYXJzZU1lbWJlcihiYXNlLCBzdGFydExvYywgc3RhdGUsIGNvbXB1dGVkLCBvcHRpb25hbCk7XG4gICAgaWYgKG5vZGUudHlwZSA9PT0gXCJPcHRpb25hbE1lbWJlckV4cHJlc3Npb25cIikge1xuICAgICAgdGhpcy5jYXN0Tm9kZVRvKG5vZGUsIFwiTWVtYmVyRXhwcmVzc2lvblwiKTtcbiAgICB9IGVsc2Uge1xuICAgICAgbm9kZS5vcHRpb25hbCA9IGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gbm9kZTtcbiAgfVxuICBpc09wdGlvbmFsTWVtYmVyRXhwcmVzc2lvbihub2RlKSB7XG4gICAgaWYgKG5vZGUudHlwZSA9PT0gXCJDaGFpbkV4cHJlc3Npb25cIikge1xuICAgICAgcmV0dXJuIG5vZGUuZXhwcmVzc2lvbi50eXBlID09PSBcIk1lbWJlckV4cHJlc3Npb25cIjtcbiAgICB9XG4gICAgcmV0dXJuIHN1cGVyLmlzT3B0aW9uYWxNZW1iZXJFeHByZXNzaW9uKG5vZGUpO1xuICB9XG4gIGhhc1Byb3BlcnR5QXNQcml2YXRlTmFtZShub2RlKSB7XG4gICAgaWYgKG5vZGUudHlwZSA9PT0gXCJDaGFpbkV4cHJlc3Npb25cIikge1xuICAgICAgbm9kZSA9IG5vZGUuZXhwcmVzc2lvbjtcbiAgICB9XG4gICAgcmV0dXJuIHN1cGVyLmhhc1Byb3BlcnR5QXNQcml2YXRlTmFtZShub2RlKTtcbiAgfVxuICBpc09iamVjdFByb3BlcnR5KG5vZGUpIHtcbiAgICByZXR1cm4gbm9kZS50eXBlID09PSBcIlByb3BlcnR5XCIgJiYgbm9kZS5raW5kID09PSBcImluaXRcIiAmJiAhbm9kZS5tZXRob2Q7XG4gIH1cbiAgaXNPYmplY3RNZXRob2Qobm9kZSkge1xuICAgIHJldHVybiBub2RlLnR5cGUgPT09IFwiUHJvcGVydHlcIiAmJiAobm9kZS5tZXRob2QgfHwgbm9kZS5raW5kID09PSBcImdldFwiIHx8IG5vZGUua2luZCA9PT0gXCJzZXRcIik7XG4gIH1cbiAgY2FzdE5vZGVUbyhub2RlLCB0eXBlKSB7XG4gICAgY29uc3QgcmVzdWx0ID0gc3VwZXIuY2FzdE5vZGVUbyhub2RlLCB0eXBlKTtcbiAgICB0aGlzLmZpbGxPcHRpb25hbFByb3BlcnRpZXNGb3JUU0VTTGludChyZXN1bHQpO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cbiAgY2xvbmVJZGVudGlmaWVyKG5vZGUpIHtcbiAgICBjb25zdCBjbG9uZWQgPSBzdXBlci5jbG9uZUlkZW50aWZpZXIobm9kZSk7XG4gICAgdGhpcy5maWxsT3B0aW9uYWxQcm9wZXJ0aWVzRm9yVFNFU0xpbnQoY2xvbmVkKTtcbiAgICByZXR1cm4gY2xvbmVkO1xuICB9XG4gIGNsb25lU3RyaW5nTGl0ZXJhbChub2RlKSB7XG4gICAgaWYgKG5vZGUudHlwZSA9PT0gXCJMaXRlcmFsXCIpIHtcbiAgICAgIHJldHVybiB0aGlzLmNsb25lRXN0cmVlU3RyaW5nTGl0ZXJhbChub2RlKTtcbiAgICB9XG4gICAgcmV0dXJuIHN1cGVyLmNsb25lU3RyaW5nTGl0ZXJhbChub2RlKTtcbiAgfVxuICBmaW5pc2hOb2RlQXQobm9kZSwgdHlwZSwgZW5kTG9jKSB7XG4gICAgcmV0dXJuIHRvRVNUcmVlTG9jYXRpb24oc3VwZXIuZmluaXNoTm9kZUF0KG5vZGUsIHR5cGUsIGVuZExvYykpO1xuICB9XG4gIGZpbmlzaE5vZGUobm9kZSwgdHlwZSkge1xuICAgIGNvbnN0IHJlc3VsdCA9IHN1cGVyLmZpbmlzaE5vZGUobm9kZSwgdHlwZSk7XG4gICAgdGhpcy5maWxsT3B0aW9uYWxQcm9wZXJ0aWVzRm9yVFNFU0xpbnQocmVzdWx0KTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG4gIHJlc2V0U3RhcnRMb2NhdGlvbihub2RlLCBzdGFydExvYykge1xuICAgIHN1cGVyLnJlc2V0U3RhcnRMb2NhdGlvbihub2RlLCBzdGFydExvYyk7XG4gICAgdG9FU1RyZWVMb2NhdGlvbihub2RlKTtcbiAgfVxuICByZXNldEVuZExvY2F0aW9uKG5vZGUsIGVuZExvYyA9IHRoaXMuc3RhdGUubGFzdFRva0VuZExvYykge1xuICAgIHN1cGVyLnJlc2V0RW5kTG9jYXRpb24obm9kZSwgZW5kTG9jKTtcbiAgICB0b0VTVHJlZUxvY2F0aW9uKG5vZGUpO1xuICB9XG59O1xuY2xhc3MgVG9rQ29udGV4dCB7XG4gIGNvbnN0cnVjdG9yKHRva2VuLCBwcmVzZXJ2ZVNwYWNlKSB7XG4gICAgdGhpcy50b2tlbiA9IHZvaWQgMDtcbiAgICB0aGlzLnByZXNlcnZlU3BhY2UgPSB2b2lkIDA7XG4gICAgdGhpcy50b2tlbiA9IHRva2VuO1xuICAgIHRoaXMucHJlc2VydmVTcGFjZSA9ICEhcHJlc2VydmVTcGFjZTtcbiAgfVxufVxuY29uc3QgdHlwZXMgPSB7XG4gIGJyYWNlOiBuZXcgVG9rQ29udGV4dChcIntcIiksXG4gIGpfb1RhZzogbmV3IFRva0NvbnRleHQoXCI8dGFnXCIpLFxuICBqX2NUYWc6IG5ldyBUb2tDb250ZXh0KFwiPC90YWdcIiksXG4gIGpfZXhwcjogbmV3IFRva0NvbnRleHQoXCI8dGFnPi4uLjwvdGFnPlwiLCB0cnVlKVxufTtcbnR5cGVzLnRlbXBsYXRlID0gbmV3IFRva0NvbnRleHQoXCJgXCIsIHRydWUpO1xuY29uc3QgYmVmb3JlRXhwciA9IHRydWU7XG5jb25zdCBzdGFydHNFeHByID0gdHJ1ZTtcbmNvbnN0IGlzTG9vcCA9IHRydWU7XG5jb25zdCBpc0Fzc2lnbiA9IHRydWU7XG5jb25zdCBwcmVmaXggPSB0cnVlO1xuY29uc3QgcG9zdGZpeCA9IHRydWU7XG5jbGFzcyBFeHBvcnRlZFRva2VuVHlwZSB7XG4gIGNvbnN0cnVjdG9yKGxhYmVsLCBjb25mID0ge30pIHtcbiAgICB0aGlzLmxhYmVsID0gdm9pZCAwO1xuICAgIHRoaXMua2V5d29yZCA9IHZvaWQgMDtcbiAgICB0aGlzLmJlZm9yZUV4cHIgPSB2b2lkIDA7XG4gICAgdGhpcy5zdGFydHNFeHByID0gdm9pZCAwO1xuICAgIHRoaXMucmlnaHRBc3NvY2lhdGl2ZSA9IHZvaWQgMDtcbiAgICB0aGlzLmlzTG9vcCA9IHZvaWQgMDtcbiAgICB0aGlzLmlzQXNzaWduID0gdm9pZCAwO1xuICAgIHRoaXMucHJlZml4ID0gdm9pZCAwO1xuICAgIHRoaXMucG9zdGZpeCA9IHZvaWQgMDtcbiAgICB0aGlzLmJpbm9wID0gdm9pZCAwO1xuICAgIHRoaXMubGFiZWwgPSBsYWJlbDtcbiAgICB0aGlzLmtleXdvcmQgPSBjb25mLmtleXdvcmQ7XG4gICAgdGhpcy5iZWZvcmVFeHByID0gISFjb25mLmJlZm9yZUV4cHI7XG4gICAgdGhpcy5zdGFydHNFeHByID0gISFjb25mLnN0YXJ0c0V4cHI7XG4gICAgdGhpcy5yaWdodEFzc29jaWF0aXZlID0gISFjb25mLnJpZ2h0QXNzb2NpYXRpdmU7XG4gICAgdGhpcy5pc0xvb3AgPSAhIWNvbmYuaXNMb29wO1xuICAgIHRoaXMuaXNBc3NpZ24gPSAhIWNvbmYuaXNBc3NpZ247XG4gICAgdGhpcy5wcmVmaXggPSAhIWNvbmYucHJlZml4O1xuICAgIHRoaXMucG9zdGZpeCA9ICEhY29uZi5wb3N0Zml4O1xuICAgIHRoaXMuYmlub3AgPSBjb25mLmJpbm9wICE9IG51bGwgPyBjb25mLmJpbm9wIDogbnVsbDtcbiAgICB0aGlzLnVwZGF0ZUNvbnRleHQgPSBudWxsO1xuICB9XG59XG5jb25zdCBrZXl3b3JkcyQxID0gbmV3IE1hcCgpO1xuZnVuY3Rpb24gY3JlYXRlS2V5d29yZChuYW1lLCBvcHRpb25zID0ge30pIHtcbiAgb3B0aW9ucy5rZXl3b3JkID0gbmFtZTtcbiAgY29uc3QgdG9rZW4gPSBjcmVhdGVUb2tlbihuYW1lLCBvcHRpb25zKTtcbiAga2V5d29yZHMkMS5zZXQobmFtZSwgdG9rZW4pO1xuICByZXR1cm4gdG9rZW47XG59XG5mdW5jdGlvbiBjcmVhdGVCaW5vcChuYW1lLCBiaW5vcCkge1xuICByZXR1cm4gY3JlYXRlVG9rZW4obmFtZSwge1xuICAgIGJlZm9yZUV4cHIsXG4gICAgYmlub3BcbiAgfSk7XG59XG5sZXQgdG9rZW5UeXBlQ291bnRlciA9IC0xO1xuY29uc3QgdG9rZW5UeXBlcyA9IFtdO1xuY29uc3QgdG9rZW5MYWJlbHMgPSBbXTtcbmNvbnN0IHRva2VuQmlub3BzID0gW107XG5jb25zdCB0b2tlbkJlZm9yZUV4cHJzID0gW107XG5jb25zdCB0b2tlblN0YXJ0c0V4cHJzID0gW107XG5jb25zdCB0b2tlblByZWZpeGVzID0gW107XG5mdW5jdGlvbiBjcmVhdGVUb2tlbihuYW1lLCBvcHRpb25zID0ge30pIHtcbiAgdmFyIF9vcHRpb25zJGJpbm9wLCBfb3B0aW9ucyRiZWZvcmVFeHByLCBfb3B0aW9ucyRzdGFydHNFeHByLCBfb3B0aW9ucyRwcmVmaXg7XG4gICsrdG9rZW5UeXBlQ291bnRlcjtcbiAgdG9rZW5MYWJlbHMucHVzaChuYW1lKTtcbiAgdG9rZW5CaW5vcHMucHVzaCgoX29wdGlvbnMkYmlub3AgPSBvcHRpb25zLmJpbm9wKSAhPSBudWxsID8gX29wdGlvbnMkYmlub3AgOiAtMSk7XG4gIHRva2VuQmVmb3JlRXhwcnMucHVzaCgoX29wdGlvbnMkYmVmb3JlRXhwciA9IG9wdGlvbnMuYmVmb3JlRXhwcikgIT0gbnVsbCA/IF9vcHRpb25zJGJlZm9yZUV4cHIgOiBmYWxzZSk7XG4gIHRva2VuU3RhcnRzRXhwcnMucHVzaCgoX29wdGlvbnMkc3RhcnRzRXhwciA9IG9wdGlvbnMuc3RhcnRzRXhwcikgIT0gbnVsbCA/IF9vcHRpb25zJHN0YXJ0c0V4cHIgOiBmYWxzZSk7XG4gIHRva2VuUHJlZml4ZXMucHVzaCgoX29wdGlvbnMkcHJlZml4ID0gb3B0aW9ucy5wcmVmaXgpICE9IG51bGwgPyBfb3B0aW9ucyRwcmVmaXggOiBmYWxzZSk7XG4gIHRva2VuVHlwZXMucHVzaChuZXcgRXhwb3J0ZWRUb2tlblR5cGUobmFtZSwgb3B0aW9ucykpO1xuICByZXR1cm4gdG9rZW5UeXBlQ291bnRlcjtcbn1cbmZ1bmN0aW9uIGNyZWF0ZUtleXdvcmRMaWtlKG5hbWUsIG9wdGlvbnMgPSB7fSkge1xuICB2YXIgX29wdGlvbnMkYmlub3AyLCBfb3B0aW9ucyRiZWZvcmVFeHByMiwgX29wdGlvbnMkc3RhcnRzRXhwcjIsIF9vcHRpb25zJHByZWZpeDI7XG4gICsrdG9rZW5UeXBlQ291bnRlcjtcbiAga2V5d29yZHMkMS5zZXQobmFtZSwgdG9rZW5UeXBlQ291bnRlcik7XG4gIHRva2VuTGFiZWxzLnB1c2gobmFtZSk7XG4gIHRva2VuQmlub3BzLnB1c2goKF9vcHRpb25zJGJpbm9wMiA9IG9wdGlvbnMuYmlub3ApICE9IG51bGwgPyBfb3B0aW9ucyRiaW5vcDIgOiAtMSk7XG4gIHRva2VuQmVmb3JlRXhwcnMucHVzaCgoX29wdGlvbnMkYmVmb3JlRXhwcjIgPSBvcHRpb25zLmJlZm9yZUV4cHIpICE9IG51bGwgPyBfb3B0aW9ucyRiZWZvcmVFeHByMiA6IGZhbHNlKTtcbiAgdG9rZW5TdGFydHNFeHBycy5wdXNoKChfb3B0aW9ucyRzdGFydHNFeHByMiA9IG9wdGlvbnMuc3RhcnRzRXhwcikgIT0gbnVsbCA/IF9vcHRpb25zJHN0YXJ0c0V4cHIyIDogZmFsc2UpO1xuICB0b2tlblByZWZpeGVzLnB1c2goKF9vcHRpb25zJHByZWZpeDIgPSBvcHRpb25zLnByZWZpeCkgIT0gbnVsbCA/IF9vcHRpb25zJHByZWZpeDIgOiBmYWxzZSk7XG4gIHRva2VuVHlwZXMucHVzaChuZXcgRXhwb3J0ZWRUb2tlblR5cGUoXCJuYW1lXCIsIG9wdGlvbnMpKTtcbiAgcmV0dXJuIHRva2VuVHlwZUNvdW50ZXI7XG59XG5jb25zdCB0dCA9IHtcbiAgYnJhY2tldEw6IGNyZWF0ZVRva2VuKFwiW1wiLCB7XG4gICAgYmVmb3JlRXhwcixcbiAgICBzdGFydHNFeHByXG4gIH0pLFxuICBicmFja2V0SGFzaEw6IGNyZWF0ZVRva2VuKFwiI1tcIiwge1xuICAgIGJlZm9yZUV4cHIsXG4gICAgc3RhcnRzRXhwclxuICB9KSxcbiAgYnJhY2tldEJhckw6IGNyZWF0ZVRva2VuKFwiW3xcIiwge1xuICAgIGJlZm9yZUV4cHIsXG4gICAgc3RhcnRzRXhwclxuICB9KSxcbiAgYnJhY2tldFI6IGNyZWF0ZVRva2VuKFwiXVwiKSxcbiAgYnJhY2tldEJhclI6IGNyZWF0ZVRva2VuKFwifF1cIiksXG4gIGJyYWNlTDogY3JlYXRlVG9rZW4oXCJ7XCIsIHtcbiAgICBiZWZvcmVFeHByLFxuICAgIHN0YXJ0c0V4cHJcbiAgfSksXG4gIGJyYWNlQmFyTDogY3JlYXRlVG9rZW4oXCJ7fFwiLCB7XG4gICAgYmVmb3JlRXhwcixcbiAgICBzdGFydHNFeHByXG4gIH0pLFxuICBicmFjZUhhc2hMOiBjcmVhdGVUb2tlbihcIiN7XCIsIHtcbiAgICBiZWZvcmVFeHByLFxuICAgIHN0YXJ0c0V4cHJcbiAgfSksXG4gIGJyYWNlUjogY3JlYXRlVG9rZW4oXCJ9XCIpLFxuICBicmFjZUJhclI6IGNyZWF0ZVRva2VuKFwifH1cIiksXG4gIHBhcmVuTDogY3JlYXRlVG9rZW4oXCIoXCIsIHtcbiAgICBiZWZvcmVFeHByLFxuICAgIHN0YXJ0c0V4cHJcbiAgfSksXG4gIHBhcmVuUjogY3JlYXRlVG9rZW4oXCIpXCIpLFxuICBjb21tYTogY3JlYXRlVG9rZW4oXCIsXCIsIHtcbiAgICBiZWZvcmVFeHByXG4gIH0pLFxuICBzZW1pOiBjcmVhdGVUb2tlbihcIjtcIiwge1xuICAgIGJlZm9yZUV4cHJcbiAgfSksXG4gIGNvbG9uOiBjcmVhdGVUb2tlbihcIjpcIiwge1xuICAgIGJlZm9yZUV4cHJcbiAgfSksXG4gIGRvdWJsZUNvbG9uOiBjcmVhdGVUb2tlbihcIjo6XCIsIHtcbiAgICBiZWZvcmVFeHByXG4gIH0pLFxuICBkb3Q6IGNyZWF0ZVRva2VuKFwiLlwiKSxcbiAgcXVlc3Rpb246IGNyZWF0ZVRva2VuKFwiP1wiLCB7XG4gICAgYmVmb3JlRXhwclxuICB9KSxcbiAgcXVlc3Rpb25Eb3Q6IGNyZWF0ZVRva2VuKFwiPy5cIiksXG4gIGFycm93OiBjcmVhdGVUb2tlbihcIj0+XCIsIHtcbiAgICBiZWZvcmVFeHByXG4gIH0pLFxuICB0ZW1wbGF0ZTogY3JlYXRlVG9rZW4oXCJ0ZW1wbGF0ZVwiKSxcbiAgZWxsaXBzaXM6IGNyZWF0ZVRva2VuKFwiLi4uXCIsIHtcbiAgICBiZWZvcmVFeHByXG4gIH0pLFxuICBiYWNrUXVvdGU6IGNyZWF0ZVRva2VuKFwiYFwiLCB7XG4gICAgc3RhcnRzRXhwclxuICB9KSxcbiAgZG9sbGFyQnJhY2VMOiBjcmVhdGVUb2tlbihcIiR7XCIsIHtcbiAgICBiZWZvcmVFeHByLFxuICAgIHN0YXJ0c0V4cHJcbiAgfSksXG4gIHRlbXBsYXRlVGFpbDogY3JlYXRlVG9rZW4oXCIuLi5gXCIsIHtcbiAgICBzdGFydHNFeHByXG4gIH0pLFxuICB0ZW1wbGF0ZU5vblRhaWw6IGNyZWF0ZVRva2VuKFwiLi4uJHtcIiwge1xuICAgIGJlZm9yZUV4cHIsXG4gICAgc3RhcnRzRXhwclxuICB9KSxcbiAgYXQ6IGNyZWF0ZVRva2VuKFwiQFwiKSxcbiAgaGFzaDogY3JlYXRlVG9rZW4oXCIjXCIsIHtcbiAgICBzdGFydHNFeHByXG4gIH0pLFxuICBpbnRlcnByZXRlckRpcmVjdGl2ZTogY3JlYXRlVG9rZW4oXCIjIS4uLlwiKSxcbiAgZXE6IGNyZWF0ZVRva2VuKFwiPVwiLCB7XG4gICAgYmVmb3JlRXhwcixcbiAgICBpc0Fzc2lnblxuICB9KSxcbiAgYXNzaWduOiBjcmVhdGVUb2tlbihcIl89XCIsIHtcbiAgICBiZWZvcmVFeHByLFxuICAgIGlzQXNzaWduXG4gIH0pLFxuICBzbGFzaEFzc2lnbjogY3JlYXRlVG9rZW4oXCJfPVwiLCB7XG4gICAgYmVmb3JlRXhwcixcbiAgICBpc0Fzc2lnblxuICB9KSxcbiAgeG9yQXNzaWduOiBjcmVhdGVUb2tlbihcIl89XCIsIHtcbiAgICBiZWZvcmVFeHByLFxuICAgIGlzQXNzaWduXG4gIH0pLFxuICBtb2R1bG9Bc3NpZ246IGNyZWF0ZVRva2VuKFwiXz1cIiwge1xuICAgIGJlZm9yZUV4cHIsXG4gICAgaXNBc3NpZ25cbiAgfSksXG4gIGluY0RlYzogY3JlYXRlVG9rZW4oXCIrKy8tLVwiLCB7XG4gICAgcHJlZml4LFxuICAgIHBvc3RmaXgsXG4gICAgc3RhcnRzRXhwclxuICB9KSxcbiAgYmFuZzogY3JlYXRlVG9rZW4oXCIhXCIsIHtcbiAgICBiZWZvcmVFeHByLFxuICAgIHByZWZpeCxcbiAgICBzdGFydHNFeHByXG4gIH0pLFxuICB0aWxkZTogY3JlYXRlVG9rZW4oXCJ+XCIsIHtcbiAgICBiZWZvcmVFeHByLFxuICAgIHByZWZpeCxcbiAgICBzdGFydHNFeHByXG4gIH0pLFxuICBkb3VibGVDYXJldDogY3JlYXRlVG9rZW4oXCJeXlwiLCB7XG4gICAgc3RhcnRzRXhwclxuICB9KSxcbiAgZG91YmxlQXQ6IGNyZWF0ZVRva2VuKFwiQEBcIiwge1xuICAgIHN0YXJ0c0V4cHJcbiAgfSksXG4gIHBpcGVsaW5lOiBjcmVhdGVCaW5vcChcInw+XCIsIDApLFxuICBudWxsaXNoQ29hbGVzY2luZzogY3JlYXRlQmlub3AoXCI/P1wiLCAxKSxcbiAgbG9naWNhbE9SOiBjcmVhdGVCaW5vcChcInx8XCIsIDEpLFxuICBsb2dpY2FsQU5EOiBjcmVhdGVCaW5vcChcIiYmXCIsIDIpLFxuICBiaXR3aXNlT1I6IGNyZWF0ZUJpbm9wKFwifFwiLCAzKSxcbiAgYml0d2lzZVhPUjogY3JlYXRlQmlub3AoXCJeXCIsIDQpLFxuICBiaXR3aXNlQU5EOiBjcmVhdGVCaW5vcChcIiZcIiwgNSksXG4gIGVxdWFsaXR5OiBjcmVhdGVCaW5vcChcIj09LyE9Lz09PS8hPT1cIiwgNiksXG4gIGx0OiBjcmVhdGVCaW5vcChcIjwvPi88PS8+PVwiLCA3KSxcbiAgZ3Q6IGNyZWF0ZUJpbm9wKFwiPC8+Lzw9Lz49XCIsIDcpLFxuICByZWxhdGlvbmFsOiBjcmVhdGVCaW5vcChcIjwvPi88PS8+PVwiLCA3KSxcbiAgYml0U2hpZnQ6IGNyZWF0ZUJpbm9wKFwiPDwvPj4vPj4+XCIsIDgpLFxuICBiaXRTaGlmdEw6IGNyZWF0ZUJpbm9wKFwiPDwvPj4vPj4+XCIsIDgpLFxuICBiaXRTaGlmdFI6IGNyZWF0ZUJpbm9wKFwiPDwvPj4vPj4+XCIsIDgpLFxuICBwbHVzTWluOiBjcmVhdGVUb2tlbihcIisvLVwiLCB7XG4gICAgYmVmb3JlRXhwcixcbiAgICBiaW5vcDogOSxcbiAgICBwcmVmaXgsXG4gICAgc3RhcnRzRXhwclxuICB9KSxcbiAgbW9kdWxvOiBjcmVhdGVUb2tlbihcIiVcIiwge1xuICAgIGJpbm9wOiAxMCxcbiAgICBzdGFydHNFeHByXG4gIH0pLFxuICBzdGFyOiBjcmVhdGVUb2tlbihcIipcIiwge1xuICAgIGJpbm9wOiAxMFxuICB9KSxcbiAgc2xhc2g6IGNyZWF0ZUJpbm9wKFwiL1wiLCAxMCksXG4gIGV4cG9uZW50OiBjcmVhdGVUb2tlbihcIioqXCIsIHtcbiAgICBiZWZvcmVFeHByLFxuICAgIGJpbm9wOiAxMSxcbiAgICByaWdodEFzc29jaWF0aXZlOiB0cnVlXG4gIH0pLFxuICBfaW46IGNyZWF0ZUtleXdvcmQoXCJpblwiLCB7XG4gICAgYmVmb3JlRXhwcixcbiAgICBiaW5vcDogN1xuICB9KSxcbiAgX2luc3RhbmNlb2Y6IGNyZWF0ZUtleXdvcmQoXCJpbnN0YW5jZW9mXCIsIHtcbiAgICBiZWZvcmVFeHByLFxuICAgIGJpbm9wOiA3XG4gIH0pLFxuICBfYnJlYWs6IGNyZWF0ZUtleXdvcmQoXCJicmVha1wiKSxcbiAgX2Nhc2U6IGNyZWF0ZUtleXdvcmQoXCJjYXNlXCIsIHtcbiAgICBiZWZvcmVFeHByXG4gIH0pLFxuICBfY2F0Y2g6IGNyZWF0ZUtleXdvcmQoXCJjYXRjaFwiKSxcbiAgX2NvbnRpbnVlOiBjcmVhdGVLZXl3b3JkKFwiY29udGludWVcIiksXG4gIF9kZWJ1Z2dlcjogY3JlYXRlS2V5d29yZChcImRlYnVnZ2VyXCIpLFxuICBfZGVmYXVsdDogY3JlYXRlS2V5d29yZChcImRlZmF1bHRcIiwge1xuICAgIGJlZm9yZUV4cHJcbiAgfSksXG4gIF9lbHNlOiBjcmVhdGVLZXl3b3JkKFwiZWxzZVwiLCB7XG4gICAgYmVmb3JlRXhwclxuICB9KSxcbiAgX2ZpbmFsbHk6IGNyZWF0ZUtleXdvcmQoXCJmaW5hbGx5XCIpLFxuICBfZnVuY3Rpb246IGNyZWF0ZUtleXdvcmQoXCJmdW5jdGlvblwiLCB7XG4gICAgc3RhcnRzRXhwclxuICB9KSxcbiAgX2lmOiBjcmVhdGVLZXl3b3JkKFwiaWZcIiksXG4gIF9yZXR1cm46IGNyZWF0ZUtleXdvcmQoXCJyZXR1cm5cIiwge1xuICAgIGJlZm9yZUV4cHJcbiAgfSksXG4gIF9zd2l0Y2g6IGNyZWF0ZUtleXdvcmQoXCJzd2l0Y2hcIiksXG4gIF90aHJvdzogY3JlYXRlS2V5d29yZChcInRocm93XCIsIHtcbiAgICBiZWZvcmVFeHByLFxuICAgIHByZWZpeCxcbiAgICBzdGFydHNFeHByXG4gIH0pLFxuICBfdHJ5OiBjcmVhdGVLZXl3b3JkKFwidHJ5XCIpLFxuICBfdmFyOiBjcmVhdGVLZXl3b3JkKFwidmFyXCIpLFxuICBfY29uc3Q6IGNyZWF0ZUtleXdvcmQoXCJjb25zdFwiKSxcbiAgX3dpdGg6IGNyZWF0ZUtleXdvcmQoXCJ3aXRoXCIpLFxuICBfbmV3OiBjcmVhdGVLZXl3b3JkKFwibmV3XCIsIHtcbiAgICBiZWZvcmVFeHByLFxuICAgIHN0YXJ0c0V4cHJcbiAgfSksXG4gIF90aGlzOiBjcmVhdGVLZXl3b3JkKFwidGhpc1wiLCB7XG4gICAgc3RhcnRzRXhwclxuICB9KSxcbiAgX3N1cGVyOiBjcmVhdGVLZXl3b3JkKFwic3VwZXJcIiwge1xuICAgIHN0YXJ0c0V4cHJcbiAgfSksXG4gIF9jbGFzczogY3JlYXRlS2V5d29yZChcImNsYXNzXCIsIHtcbiAgICBzdGFydHNFeHByXG4gIH0pLFxuICBfZXh0ZW5kczogY3JlYXRlS2V5d29yZChcImV4dGVuZHNcIiwge1xuICAgIGJlZm9yZUV4cHJcbiAgfSksXG4gIF9leHBvcnQ6IGNyZWF0ZUtleXdvcmQoXCJleHBvcnRcIiksXG4gIF9pbXBvcnQ6IGNyZWF0ZUtleXdvcmQoXCJpbXBvcnRcIiwge1xuICAgIHN0YXJ0c0V4cHJcbiAgfSksXG4gIF9udWxsOiBjcmVhdGVLZXl3b3JkKFwibnVsbFwiLCB7XG4gICAgc3RhcnRzRXhwclxuICB9KSxcbiAgX3RydWU6IGNyZWF0ZUtleXdvcmQoXCJ0cnVlXCIsIHtcbiAgICBzdGFydHNFeHByXG4gIH0pLFxuICBfZmFsc2U6IGNyZWF0ZUtleXdvcmQoXCJmYWxzZVwiLCB7XG4gICAgc3RhcnRzRXhwclxuICB9KSxcbiAgX3R5cGVvZjogY3JlYXRlS2V5d29yZChcInR5cGVvZlwiLCB7XG4gICAgYmVmb3JlRXhwcixcbiAgICBwcmVmaXgsXG4gICAgc3RhcnRzRXhwclxuICB9KSxcbiAgX3ZvaWQ6IGNyZWF0ZUtleXdvcmQoXCJ2b2lkXCIsIHtcbiAgICBiZWZvcmVFeHByLFxuICAgIHByZWZpeCxcbiAgICBzdGFydHNFeHByXG4gIH0pLFxuICBfZGVsZXRlOiBjcmVhdGVLZXl3b3JkKFwiZGVsZXRlXCIsIHtcbiAgICBiZWZvcmVFeHByLFxuICAgIHByZWZpeCxcbiAgICBzdGFydHNFeHByXG4gIH0pLFxuICBfZG86IGNyZWF0ZUtleXdvcmQoXCJkb1wiLCB7XG4gICAgaXNMb29wLFxuICAgIGJlZm9yZUV4cHJcbiAgfSksXG4gIF9mb3I6IGNyZWF0ZUtleXdvcmQoXCJmb3JcIiwge1xuICAgIGlzTG9vcFxuICB9KSxcbiAgX3doaWxlOiBjcmVhdGVLZXl3b3JkKFwid2hpbGVcIiwge1xuICAgIGlzTG9vcFxuICB9KSxcbiAgX2FzOiBjcmVhdGVLZXl3b3JkTGlrZShcImFzXCIsIHtcbiAgICBzdGFydHNFeHByXG4gIH0pLFxuICBfYXNzZXJ0OiBjcmVhdGVLZXl3b3JkTGlrZShcImFzc2VydFwiLCB7XG4gICAgc3RhcnRzRXhwclxuICB9KSxcbiAgX2FzeW5jOiBjcmVhdGVLZXl3b3JkTGlrZShcImFzeW5jXCIsIHtcbiAgICBzdGFydHNFeHByXG4gIH0pLFxuICBfYXdhaXQ6IGNyZWF0ZUtleXdvcmRMaWtlKFwiYXdhaXRcIiwge1xuICAgIHN0YXJ0c0V4cHJcbiAgfSksXG4gIF9kZWZlcjogY3JlYXRlS2V5d29yZExpa2UoXCJkZWZlclwiLCB7XG4gICAgc3RhcnRzRXhwclxuICB9KSxcbiAgX2Zyb206IGNyZWF0ZUtleXdvcmRMaWtlKFwiZnJvbVwiLCB7XG4gICAgc3RhcnRzRXhwclxuICB9KSxcbiAgX2dldDogY3JlYXRlS2V5d29yZExpa2UoXCJnZXRcIiwge1xuICAgIHN0YXJ0c0V4cHJcbiAgfSksXG4gIF9sZXQ6IGNyZWF0ZUtleXdvcmRMaWtlKFwibGV0XCIsIHtcbiAgICBzdGFydHNFeHByXG4gIH0pLFxuICBfbWV0YTogY3JlYXRlS2V5d29yZExpa2UoXCJtZXRhXCIsIHtcbiAgICBzdGFydHNFeHByXG4gIH0pLFxuICBfb2Y6IGNyZWF0ZUtleXdvcmRMaWtlKFwib2ZcIiwge1xuICAgIHN0YXJ0c0V4cHJcbiAgfSksXG4gIF9zZW50OiBjcmVhdGVLZXl3b3JkTGlrZShcInNlbnRcIiwge1xuICAgIHN0YXJ0c0V4cHJcbiAgfSksXG4gIF9zZXQ6IGNyZWF0ZUtleXdvcmRMaWtlKFwic2V0XCIsIHtcbiAgICBzdGFydHNFeHByXG4gIH0pLFxuICBfc291cmNlOiBjcmVhdGVLZXl3b3JkTGlrZShcInNvdXJjZVwiLCB7XG4gICAgc3RhcnRzRXhwclxuICB9KSxcbiAgX3N0YXRpYzogY3JlYXRlS2V5d29yZExpa2UoXCJzdGF0aWNcIiwge1xuICAgIHN0YXJ0c0V4cHJcbiAgfSksXG4gIF91c2luZzogY3JlYXRlS2V5d29yZExpa2UoXCJ1c2luZ1wiLCB7XG4gICAgc3RhcnRzRXhwclxuICB9KSxcbiAgX3lpZWxkOiBjcmVhdGVLZXl3b3JkTGlrZShcInlpZWxkXCIsIHtcbiAgICBzdGFydHNFeHByXG4gIH0pLFxuICBfYXNzZXJ0czogY3JlYXRlS2V5d29yZExpa2UoXCJhc3NlcnRzXCIsIHtcbiAgICBzdGFydHNFeHByXG4gIH0pLFxuICBfY2hlY2tzOiBjcmVhdGVLZXl3b3JkTGlrZShcImNoZWNrc1wiLCB7XG4gICAgc3RhcnRzRXhwclxuICB9KSxcbiAgX2V4cG9ydHM6IGNyZWF0ZUtleXdvcmRMaWtlKFwiZXhwb3J0c1wiLCB7XG4gICAgc3RhcnRzRXhwclxuICB9KSxcbiAgX2dsb2JhbDogY3JlYXRlS2V5d29yZExpa2UoXCJnbG9iYWxcIiwge1xuICAgIHN0YXJ0c0V4cHJcbiAgfSksXG4gIF9pbXBsZW1lbnRzOiBjcmVhdGVLZXl3b3JkTGlrZShcImltcGxlbWVudHNcIiwge1xuICAgIHN0YXJ0c0V4cHJcbiAgfSksXG4gIF9pbnRyaW5zaWM6IGNyZWF0ZUtleXdvcmRMaWtlKFwiaW50cmluc2ljXCIsIHtcbiAgICBzdGFydHNFeHByXG4gIH0pLFxuICBfaW5mZXI6IGNyZWF0ZUtleXdvcmRMaWtlKFwiaW5mZXJcIiwge1xuICAgIHN0YXJ0c0V4cHJcbiAgfSksXG4gIF9pczogY3JlYXRlS2V5d29yZExpa2UoXCJpc1wiLCB7XG4gICAgc3RhcnRzRXhwclxuICB9KSxcbiAgX21peGluczogY3JlYXRlS2V5d29yZExpa2UoXCJtaXhpbnNcIiwge1xuICAgIHN0YXJ0c0V4cHJcbiAgfSksXG4gIF9wcm90bzogY3JlYXRlS2V5d29yZExpa2UoXCJwcm90b1wiLCB7XG4gICAgc3RhcnRzRXhwclxuICB9KSxcbiAgX3JlcXVpcmU6IGNyZWF0ZUtleXdvcmRMaWtlKFwicmVxdWlyZVwiLCB7XG4gICAgc3RhcnRzRXhwclxuICB9KSxcbiAgX3NhdGlzZmllczogY3JlYXRlS2V5d29yZExpa2UoXCJzYXRpc2ZpZXNcIiwge1xuICAgIHN0YXJ0c0V4cHJcbiAgfSksXG4gIF9rZXlvZjogY3JlYXRlS2V5d29yZExpa2UoXCJrZXlvZlwiLCB7XG4gICAgc3RhcnRzRXhwclxuICB9KSxcbiAgX3JlYWRvbmx5OiBjcmVhdGVLZXl3b3JkTGlrZShcInJlYWRvbmx5XCIsIHtcbiAgICBzdGFydHNFeHByXG4gIH0pLFxuICBfdW5pcXVlOiBjcmVhdGVLZXl3b3JkTGlrZShcInVuaXF1ZVwiLCB7XG4gICAgc3RhcnRzRXhwclxuICB9KSxcbiAgX2Fic3RyYWN0OiBjcmVhdGVLZXl3b3JkTGlrZShcImFic3RyYWN0XCIsIHtcbiAgICBzdGFydHNFeHByXG4gIH0pLFxuICBfZGVjbGFyZTogY3JlYXRlS2V5d29yZExpa2UoXCJkZWNsYXJlXCIsIHtcbiAgICBzdGFydHNFeHByXG4gIH0pLFxuICBfZW51bTogY3JlYXRlS2V5d29yZExpa2UoXCJlbnVtXCIsIHtcbiAgICBzdGFydHNFeHByXG4gIH0pLFxuICBfbW9kdWxlOiBjcmVhdGVLZXl3b3JkTGlrZShcIm1vZHVsZVwiLCB7XG4gICAgc3RhcnRzRXhwclxuICB9KSxcbiAgX25hbWVzcGFjZTogY3JlYXRlS2V5d29yZExpa2UoXCJuYW1lc3BhY2VcIiwge1xuICAgIHN0YXJ0c0V4cHJcbiAgfSksXG4gIF9pbnRlcmZhY2U6IGNyZWF0ZUtleXdvcmRMaWtlKFwiaW50ZXJmYWNlXCIsIHtcbiAgICBzdGFydHNFeHByXG4gIH0pLFxuICBfdHlwZTogY3JlYXRlS2V5d29yZExpa2UoXCJ0eXBlXCIsIHtcbiAgICBzdGFydHNFeHByXG4gIH0pLFxuICBfb3BhcXVlOiBjcmVhdGVLZXl3b3JkTGlrZShcIm9wYXF1ZVwiLCB7XG4gICAgc3RhcnRzRXhwclxuICB9KSxcbiAgbmFtZTogY3JlYXRlVG9rZW4oXCJuYW1lXCIsIHtcbiAgICBzdGFydHNFeHByXG4gIH0pLFxuICBwbGFjZWhvbGRlcjogY3JlYXRlVG9rZW4oXCIlJVwiLCB7XG4gICAgc3RhcnRzRXhwclxuICB9KSxcbiAgc3RyaW5nOiBjcmVhdGVUb2tlbihcInN0cmluZ1wiLCB7XG4gICAgc3RhcnRzRXhwclxuICB9KSxcbiAgbnVtOiBjcmVhdGVUb2tlbihcIm51bVwiLCB7XG4gICAgc3RhcnRzRXhwclxuICB9KSxcbiAgYmlnaW50OiBjcmVhdGVUb2tlbihcImJpZ2ludFwiLCB7XG4gICAgc3RhcnRzRXhwclxuICB9KSxcbiAgZGVjaW1hbDogY3JlYXRlVG9rZW4oXCJkZWNpbWFsXCIsIHtcbiAgICBzdGFydHNFeHByXG4gIH0pLFxuICByZWdleHA6IGNyZWF0ZVRva2VuKFwicmVnZXhwXCIsIHtcbiAgICBzdGFydHNFeHByXG4gIH0pLFxuICBwcml2YXRlTmFtZTogY3JlYXRlVG9rZW4oXCIjbmFtZVwiLCB7XG4gICAgc3RhcnRzRXhwclxuICB9KSxcbiAgZW9mOiBjcmVhdGVUb2tlbihcImVvZlwiKSxcbiAganN4TmFtZTogY3JlYXRlVG9rZW4oXCJqc3hOYW1lXCIpLFxuICBqc3hUZXh0OiBjcmVhdGVUb2tlbihcImpzeFRleHRcIiwge1xuICAgIGJlZm9yZUV4cHJcbiAgfSksXG4gIGpzeFRhZ1N0YXJ0OiBjcmVhdGVUb2tlbihcImpzeFRhZ1N0YXJ0XCIsIHtcbiAgICBzdGFydHNFeHByXG4gIH0pLFxuICBqc3hUYWdFbmQ6IGNyZWF0ZVRva2VuKFwianN4VGFnRW5kXCIpXG59O1xuZnVuY3Rpb24gdG9rZW5Jc0lkZW50aWZpZXIodG9rZW4pIHtcbiAgcmV0dXJuIHRva2VuID49IDkzICYmIHRva2VuIDw9IDEzMztcbn1cbmZ1bmN0aW9uIHRva2VuS2V5d29yZE9ySWRlbnRpZmllcklzS2V5d29yZCh0b2tlbikge1xuICByZXR1cm4gdG9rZW4gPD0gOTI7XG59XG5mdW5jdGlvbiB0b2tlbklzS2V5d29yZE9ySWRlbnRpZmllcih0b2tlbikge1xuICByZXR1cm4gdG9rZW4gPj0gNTggJiYgdG9rZW4gPD0gMTMzO1xufVxuZnVuY3Rpb24gdG9rZW5Jc0xpdGVyYWxQcm9wZXJ0eU5hbWUodG9rZW4pIHtcbiAgcmV0dXJuIHRva2VuID49IDU4ICYmIHRva2VuIDw9IDEzNztcbn1cbmZ1bmN0aW9uIHRva2VuQ29tZXNCZWZvcmVFeHByZXNzaW9uKHRva2VuKSB7XG4gIHJldHVybiB0b2tlbkJlZm9yZUV4cHJzW3Rva2VuXTtcbn1cbmZ1bmN0aW9uIHRva2VuQ2FuU3RhcnRFeHByZXNzaW9uKHRva2VuKSB7XG4gIHJldHVybiB0b2tlblN0YXJ0c0V4cHJzW3Rva2VuXTtcbn1cbmZ1bmN0aW9uIHRva2VuSXNBc3NpZ25tZW50KHRva2VuKSB7XG4gIHJldHVybiB0b2tlbiA+PSAyOSAmJiB0b2tlbiA8PSAzMztcbn1cbmZ1bmN0aW9uIHRva2VuSXNGbG93SW50ZXJmYWNlT3JUeXBlT3JPcGFxdWUodG9rZW4pIHtcbiAgcmV0dXJuIHRva2VuID49IDEyOSAmJiB0b2tlbiA8PSAxMzE7XG59XG5mdW5jdGlvbiB0b2tlbklzTG9vcCh0b2tlbikge1xuICByZXR1cm4gdG9rZW4gPj0gOTAgJiYgdG9rZW4gPD0gOTI7XG59XG5mdW5jdGlvbiB0b2tlbklzS2V5d29yZCh0b2tlbikge1xuICByZXR1cm4gdG9rZW4gPj0gNTggJiYgdG9rZW4gPD0gOTI7XG59XG5mdW5jdGlvbiB0b2tlbklzT3BlcmF0b3IodG9rZW4pIHtcbiAgcmV0dXJuIHRva2VuID49IDM5ICYmIHRva2VuIDw9IDU5O1xufVxuZnVuY3Rpb24gdG9rZW5Jc1Bvc3RmaXgodG9rZW4pIHtcbiAgcmV0dXJuIHRva2VuID09PSAzNDtcbn1cbmZ1bmN0aW9uIHRva2VuSXNQcmVmaXgodG9rZW4pIHtcbiAgcmV0dXJuIHRva2VuUHJlZml4ZXNbdG9rZW5dO1xufVxuZnVuY3Rpb24gdG9rZW5Jc1RTVHlwZU9wZXJhdG9yKHRva2VuKSB7XG4gIHJldHVybiB0b2tlbiA+PSAxMjEgJiYgdG9rZW4gPD0gMTIzO1xufVxuZnVuY3Rpb24gdG9rZW5Jc1RTRGVjbGFyYXRpb25TdGFydCh0b2tlbikge1xuICByZXR1cm4gdG9rZW4gPj0gMTI0ICYmIHRva2VuIDw9IDEzMDtcbn1cbmZ1bmN0aW9uIHRva2VuTGFiZWxOYW1lKHRva2VuKSB7XG4gIHJldHVybiB0b2tlbkxhYmVsc1t0b2tlbl07XG59XG5mdW5jdGlvbiB0b2tlbk9wZXJhdG9yUHJlY2VkZW5jZSh0b2tlbikge1xuICByZXR1cm4gdG9rZW5CaW5vcHNbdG9rZW5dO1xufVxuZnVuY3Rpb24gdG9rZW5Jc1JpZ2h0QXNzb2NpYXRpdmUodG9rZW4pIHtcbiAgcmV0dXJuIHRva2VuID09PSA1Nztcbn1cbmZ1bmN0aW9uIHRva2VuSXNUZW1wbGF0ZSh0b2tlbikge1xuICByZXR1cm4gdG9rZW4gPj0gMjQgJiYgdG9rZW4gPD0gMjU7XG59XG5mdW5jdGlvbiBnZXRFeHBvcnRlZFRva2VuKHRva2VuKSB7XG4gIHJldHVybiB0b2tlblR5cGVzW3Rva2VuXTtcbn1cbnRva2VuVHlwZXNbOF0udXBkYXRlQ29udGV4dCA9IGNvbnRleHQgPT4ge1xuICBjb250ZXh0LnBvcCgpO1xufTtcbnRva2VuVHlwZXNbNV0udXBkYXRlQ29udGV4dCA9IHRva2VuVHlwZXNbN10udXBkYXRlQ29udGV4dCA9IHRva2VuVHlwZXNbMjNdLnVwZGF0ZUNvbnRleHQgPSBjb250ZXh0ID0+IHtcbiAgY29udGV4dC5wdXNoKHR5cGVzLmJyYWNlKTtcbn07XG50b2tlblR5cGVzWzIyXS51cGRhdGVDb250ZXh0ID0gY29udGV4dCA9PiB7XG4gIGlmIChjb250ZXh0W2NvbnRleHQubGVuZ3RoIC0gMV0gPT09IHR5cGVzLnRlbXBsYXRlKSB7XG4gICAgY29udGV4dC5wb3AoKTtcbiAgfSBlbHNlIHtcbiAgICBjb250ZXh0LnB1c2godHlwZXMudGVtcGxhdGUpO1xuICB9XG59O1xudG9rZW5UeXBlc1sxNDNdLnVwZGF0ZUNvbnRleHQgPSBjb250ZXh0ID0+IHtcbiAgY29udGV4dC5wdXNoKHR5cGVzLmpfZXhwciwgdHlwZXMual9vVGFnKTtcbn07XG5sZXQgbm9uQVNDSUlpZGVudGlmaWVyU3RhcnRDaGFycyA9IFwiXFx4YWFcXHhiNVxceGJhXFx4YzAtXFx4ZDZcXHhkOC1cXHhmNlxceGY4LVxcdTAyYzFcXHUwMmM2LVxcdTAyZDFcXHUwMmUwLVxcdTAyZTRcXHUwMmVjXFx1MDJlZVxcdTAzNzAtXFx1MDM3NFxcdTAzNzZcXHUwMzc3XFx1MDM3YS1cXHUwMzdkXFx1MDM3ZlxcdTAzODZcXHUwMzg4LVxcdTAzOGFcXHUwMzhjXFx1MDM4ZS1cXHUwM2ExXFx1MDNhMy1cXHUwM2Y1XFx1MDNmNy1cXHUwNDgxXFx1MDQ4YS1cXHUwNTJmXFx1MDUzMS1cXHUwNTU2XFx1MDU1OVxcdTA1NjAtXFx1MDU4OFxcdTA1ZDAtXFx1MDVlYVxcdTA1ZWYtXFx1MDVmMlxcdTA2MjAtXFx1MDY0YVxcdTA2NmVcXHUwNjZmXFx1MDY3MS1cXHUwNmQzXFx1MDZkNVxcdTA2ZTVcXHUwNmU2XFx1MDZlZVxcdTA2ZWZcXHUwNmZhLVxcdTA2ZmNcXHUwNmZmXFx1MDcxMFxcdTA3MTItXFx1MDcyZlxcdTA3NGQtXFx1MDdhNVxcdTA3YjFcXHUwN2NhLVxcdTA3ZWFcXHUwN2Y0XFx1MDdmNVxcdTA3ZmFcXHUwODAwLVxcdTA4MTVcXHUwODFhXFx1MDgyNFxcdTA4MjhcXHUwODQwLVxcdTA4NThcXHUwODYwLVxcdTA4NmFcXHUwODcwLVxcdTA4ODdcXHUwODg5LVxcdTA4OGZcXHUwOGEwLVxcdTA4YzlcXHUwOTA0LVxcdTA5MzlcXHUwOTNkXFx1MDk1MFxcdTA5NTgtXFx1MDk2MVxcdTA5NzEtXFx1MDk4MFxcdTA5ODUtXFx1MDk4Y1xcdTA5OGZcXHUwOTkwXFx1MDk5My1cXHUwOWE4XFx1MDlhYS1cXHUwOWIwXFx1MDliMlxcdTA5YjYtXFx1MDliOVxcdTA5YmRcXHUwOWNlXFx1MDlkY1xcdTA5ZGRcXHUwOWRmLVxcdTA5ZTFcXHUwOWYwXFx1MDlmMVxcdTA5ZmNcXHUwYTA1LVxcdTBhMGFcXHUwYTBmXFx1MGExMFxcdTBhMTMtXFx1MGEyOFxcdTBhMmEtXFx1MGEzMFxcdTBhMzJcXHUwYTMzXFx1MGEzNVxcdTBhMzZcXHUwYTM4XFx1MGEzOVxcdTBhNTktXFx1MGE1Y1xcdTBhNWVcXHUwYTcyLVxcdTBhNzRcXHUwYTg1LVxcdTBhOGRcXHUwYThmLVxcdTBhOTFcXHUwYTkzLVxcdTBhYThcXHUwYWFhLVxcdTBhYjBcXHUwYWIyXFx1MGFiM1xcdTBhYjUtXFx1MGFiOVxcdTBhYmRcXHUwYWQwXFx1MGFlMFxcdTBhZTFcXHUwYWY5XFx1MGIwNS1cXHUwYjBjXFx1MGIwZlxcdTBiMTBcXHUwYjEzLVxcdTBiMjhcXHUwYjJhLVxcdTBiMzBcXHUwYjMyXFx1MGIzM1xcdTBiMzUtXFx1MGIzOVxcdTBiM2RcXHUwYjVjXFx1MGI1ZFxcdTBiNWYtXFx1MGI2MVxcdTBiNzFcXHUwYjgzXFx1MGI4NS1cXHUwYjhhXFx1MGI4ZS1cXHUwYjkwXFx1MGI5Mi1cXHUwYjk1XFx1MGI5OVxcdTBiOWFcXHUwYjljXFx1MGI5ZVxcdTBiOWZcXHUwYmEzXFx1MGJhNFxcdTBiYTgtXFx1MGJhYVxcdTBiYWUtXFx1MGJiOVxcdTBiZDBcXHUwYzA1LVxcdTBjMGNcXHUwYzBlLVxcdTBjMTBcXHUwYzEyLVxcdTBjMjhcXHUwYzJhLVxcdTBjMzlcXHUwYzNkXFx1MGM1OC1cXHUwYzVhXFx1MGM1Y1xcdTBjNWRcXHUwYzYwXFx1MGM2MVxcdTBjODBcXHUwYzg1LVxcdTBjOGNcXHUwYzhlLVxcdTBjOTBcXHUwYzkyLVxcdTBjYThcXHUwY2FhLVxcdTBjYjNcXHUwY2I1LVxcdTBjYjlcXHUwY2JkXFx1MGNkYy1cXHUwY2RlXFx1MGNlMFxcdTBjZTFcXHUwY2YxXFx1MGNmMlxcdTBkMDQtXFx1MGQwY1xcdTBkMGUtXFx1MGQxMFxcdTBkMTItXFx1MGQzYVxcdTBkM2RcXHUwZDRlXFx1MGQ1NC1cXHUwZDU2XFx1MGQ1Zi1cXHUwZDYxXFx1MGQ3YS1cXHUwZDdmXFx1MGQ4NS1cXHUwZDk2XFx1MGQ5YS1cXHUwZGIxXFx1MGRiMy1cXHUwZGJiXFx1MGRiZFxcdTBkYzAtXFx1MGRjNlxcdTBlMDEtXFx1MGUzMFxcdTBlMzJcXHUwZTMzXFx1MGU0MC1cXHUwZTQ2XFx1MGU4MVxcdTBlODJcXHUwZTg0XFx1MGU4Ni1cXHUwZThhXFx1MGU4Yy1cXHUwZWEzXFx1MGVhNVxcdTBlYTctXFx1MGViMFxcdTBlYjJcXHUwZWIzXFx1MGViZFxcdTBlYzAtXFx1MGVjNFxcdTBlYzZcXHUwZWRjLVxcdTBlZGZcXHUwZjAwXFx1MGY0MC1cXHUwZjQ3XFx1MGY0OS1cXHUwZjZjXFx1MGY4OC1cXHUwZjhjXFx1MTAwMC1cXHUxMDJhXFx1MTAzZlxcdTEwNTAtXFx1MTA1NVxcdTEwNWEtXFx1MTA1ZFxcdTEwNjFcXHUxMDY1XFx1MTA2NlxcdTEwNmUtXFx1MTA3MFxcdTEwNzUtXFx1MTA4MVxcdTEwOGVcXHUxMGEwLVxcdTEwYzVcXHUxMGM3XFx1MTBjZFxcdTEwZDAtXFx1MTBmYVxcdTEwZmMtXFx1MTI0OFxcdTEyNGEtXFx1MTI0ZFxcdTEyNTAtXFx1MTI1NlxcdTEyNThcXHUxMjVhLVxcdTEyNWRcXHUxMjYwLVxcdTEyODhcXHUxMjhhLVxcdTEyOGRcXHUxMjkwLVxcdTEyYjBcXHUxMmIyLVxcdTEyYjVcXHUxMmI4LVxcdTEyYmVcXHUxMmMwXFx1MTJjMi1cXHUxMmM1XFx1MTJjOC1cXHUxMmQ2XFx1MTJkOC1cXHUxMzEwXFx1MTMxMi1cXHUxMzE1XFx1MTMxOC1cXHUxMzVhXFx1MTM4MC1cXHUxMzhmXFx1MTNhMC1cXHUxM2Y1XFx1MTNmOC1cXHUxM2ZkXFx1MTQwMS1cXHUxNjZjXFx1MTY2Zi1cXHUxNjdmXFx1MTY4MS1cXHUxNjlhXFx1MTZhMC1cXHUxNmVhXFx1MTZlZS1cXHUxNmY4XFx1MTcwMC1cXHUxNzExXFx1MTcxZi1cXHUxNzMxXFx1MTc0MC1cXHUxNzUxXFx1MTc2MC1cXHUxNzZjXFx1MTc2ZS1cXHUxNzcwXFx1MTc4MC1cXHUxN2IzXFx1MTdkN1xcdTE3ZGNcXHUxODIwLVxcdTE4NzhcXHUxODgwLVxcdTE4YThcXHUxOGFhXFx1MThiMC1cXHUxOGY1XFx1MTkwMC1cXHUxOTFlXFx1MTk1MC1cXHUxOTZkXFx1MTk3MC1cXHUxOTc0XFx1MTk4MC1cXHUxOWFiXFx1MTliMC1cXHUxOWM5XFx1MWEwMC1cXHUxYTE2XFx1MWEyMC1cXHUxYTU0XFx1MWFhN1xcdTFiMDUtXFx1MWIzM1xcdTFiNDUtXFx1MWI0Y1xcdTFiODMtXFx1MWJhMFxcdTFiYWVcXHUxYmFmXFx1MWJiYS1cXHUxYmU1XFx1MWMwMC1cXHUxYzIzXFx1MWM0ZC1cXHUxYzRmXFx1MWM1YS1cXHUxYzdkXFx1MWM4MC1cXHUxYzhhXFx1MWM5MC1cXHUxY2JhXFx1MWNiZC1cXHUxY2JmXFx1MWNlOS1cXHUxY2VjXFx1MWNlZS1cXHUxY2YzXFx1MWNmNVxcdTFjZjZcXHUxY2ZhXFx1MWQwMC1cXHUxZGJmXFx1MWUwMC1cXHUxZjE1XFx1MWYxOC1cXHUxZjFkXFx1MWYyMC1cXHUxZjQ1XFx1MWY0OC1cXHUxZjRkXFx1MWY1MC1cXHUxZjU3XFx1MWY1OVxcdTFmNWJcXHUxZjVkXFx1MWY1Zi1cXHUxZjdkXFx1MWY4MC1cXHUxZmI0XFx1MWZiNi1cXHUxZmJjXFx1MWZiZVxcdTFmYzItXFx1MWZjNFxcdTFmYzYtXFx1MWZjY1xcdTFmZDAtXFx1MWZkM1xcdTFmZDYtXFx1MWZkYlxcdTFmZTAtXFx1MWZlY1xcdTFmZjItXFx1MWZmNFxcdTFmZjYtXFx1MWZmY1xcdTIwNzFcXHUyMDdmXFx1MjA5MC1cXHUyMDljXFx1MjEwMlxcdTIxMDdcXHUyMTBhLVxcdTIxMTNcXHUyMTE1XFx1MjExOC1cXHUyMTFkXFx1MjEyNFxcdTIxMjZcXHUyMTI4XFx1MjEyYS1cXHUyMTM5XFx1MjEzYy1cXHUyMTNmXFx1MjE0NS1cXHUyMTQ5XFx1MjE0ZVxcdTIxNjAtXFx1MjE4OFxcdTJjMDAtXFx1MmNlNFxcdTJjZWItXFx1MmNlZVxcdTJjZjJcXHUyY2YzXFx1MmQwMC1cXHUyZDI1XFx1MmQyN1xcdTJkMmRcXHUyZDMwLVxcdTJkNjdcXHUyZDZmXFx1MmQ4MC1cXHUyZDk2XFx1MmRhMC1cXHUyZGE2XFx1MmRhOC1cXHUyZGFlXFx1MmRiMC1cXHUyZGI2XFx1MmRiOC1cXHUyZGJlXFx1MmRjMC1cXHUyZGM2XFx1MmRjOC1cXHUyZGNlXFx1MmRkMC1cXHUyZGQ2XFx1MmRkOC1cXHUyZGRlXFx1MzAwNS1cXHUzMDA3XFx1MzAyMS1cXHUzMDI5XFx1MzAzMS1cXHUzMDM1XFx1MzAzOC1cXHUzMDNjXFx1MzA0MS1cXHUzMDk2XFx1MzA5Yi1cXHUzMDlmXFx1MzBhMS1cXHUzMGZhXFx1MzBmYy1cXHUzMGZmXFx1MzEwNS1cXHUzMTJmXFx1MzEzMS1cXHUzMThlXFx1MzFhMC1cXHUzMWJmXFx1MzFmMC1cXHUzMWZmXFx1MzQwMC1cXHU0ZGJmXFx1NGUwMC1cXHVhNDhjXFx1YTRkMC1cXHVhNGZkXFx1YTUwMC1cXHVhNjBjXFx1YTYxMC1cXHVhNjFmXFx1YTYyYVxcdWE2MmJcXHVhNjQwLVxcdWE2NmVcXHVhNjdmLVxcdWE2OWRcXHVhNmEwLVxcdWE2ZWZcXHVhNzE3LVxcdWE3MWZcXHVhNzIyLVxcdWE3ODhcXHVhNzhiLVxcdWE3ZGNcXHVhN2YxLVxcdWE4MDFcXHVhODAzLVxcdWE4MDVcXHVhODA3LVxcdWE4MGFcXHVhODBjLVxcdWE4MjJcXHVhODQwLVxcdWE4NzNcXHVhODgyLVxcdWE4YjNcXHVhOGYyLVxcdWE4ZjdcXHVhOGZiXFx1YThmZFxcdWE4ZmVcXHVhOTBhLVxcdWE5MjVcXHVhOTMwLVxcdWE5NDZcXHVhOTYwLVxcdWE5N2NcXHVhOTg0LVxcdWE5YjJcXHVhOWNmXFx1YTllMC1cXHVhOWU0XFx1YTllNi1cXHVhOWVmXFx1YTlmYS1cXHVhOWZlXFx1YWEwMC1cXHVhYTI4XFx1YWE0MC1cXHVhYTQyXFx1YWE0NC1cXHVhYTRiXFx1YWE2MC1cXHVhYTc2XFx1YWE3YVxcdWFhN2UtXFx1YWFhZlxcdWFhYjFcXHVhYWI1XFx1YWFiNlxcdWFhYjktXFx1YWFiZFxcdWFhYzBcXHVhYWMyXFx1YWFkYi1cXHVhYWRkXFx1YWFlMC1cXHVhYWVhXFx1YWFmMi1cXHVhYWY0XFx1YWIwMS1cXHVhYjA2XFx1YWIwOS1cXHVhYjBlXFx1YWIxMS1cXHVhYjE2XFx1YWIyMC1cXHVhYjI2XFx1YWIyOC1cXHVhYjJlXFx1YWIzMC1cXHVhYjVhXFx1YWI1Yy1cXHVhYjY5XFx1YWI3MC1cXHVhYmUyXFx1YWMwMC1cXHVkN2EzXFx1ZDdiMC1cXHVkN2M2XFx1ZDdjYi1cXHVkN2ZiXFx1ZjkwMC1cXHVmYTZkXFx1ZmE3MC1cXHVmYWQ5XFx1ZmIwMC1cXHVmYjA2XFx1ZmIxMy1cXHVmYjE3XFx1ZmIxZFxcdWZiMWYtXFx1ZmIyOFxcdWZiMmEtXFx1ZmIzNlxcdWZiMzgtXFx1ZmIzY1xcdWZiM2VcXHVmYjQwXFx1ZmI0MVxcdWZiNDNcXHVmYjQ0XFx1ZmI0Ni1cXHVmYmIxXFx1ZmJkMy1cXHVmZDNkXFx1ZmQ1MC1cXHVmZDhmXFx1ZmQ5Mi1cXHVmZGM3XFx1ZmRmMC1cXHVmZGZiXFx1ZmU3MC1cXHVmZTc0XFx1ZmU3Ni1cXHVmZWZjXFx1ZmYyMS1cXHVmZjNhXFx1ZmY0MS1cXHVmZjVhXFx1ZmY2Ni1cXHVmZmJlXFx1ZmZjMi1cXHVmZmM3XFx1ZmZjYS1cXHVmZmNmXFx1ZmZkMi1cXHVmZmQ3XFx1ZmZkYS1cXHVmZmRjXCI7XG5sZXQgbm9uQVNDSUlpZGVudGlmaWVyQ2hhcnMgPSBcIlxceGI3XFx1MDMwMC1cXHUwMzZmXFx1MDM4N1xcdTA0ODMtXFx1MDQ4N1xcdTA1OTEtXFx1MDViZFxcdTA1YmZcXHUwNWMxXFx1MDVjMlxcdTA1YzRcXHUwNWM1XFx1MDVjN1xcdTA2MTAtXFx1MDYxYVxcdTA2NGItXFx1MDY2OVxcdTA2NzBcXHUwNmQ2LVxcdTA2ZGNcXHUwNmRmLVxcdTA2ZTRcXHUwNmU3XFx1MDZlOFxcdTA2ZWEtXFx1MDZlZFxcdTA2ZjAtXFx1MDZmOVxcdTA3MTFcXHUwNzMwLVxcdTA3NGFcXHUwN2E2LVxcdTA3YjBcXHUwN2MwLVxcdTA3YzlcXHUwN2ViLVxcdTA3ZjNcXHUwN2ZkXFx1MDgxNi1cXHUwODE5XFx1MDgxYi1cXHUwODIzXFx1MDgyNS1cXHUwODI3XFx1MDgyOS1cXHUwODJkXFx1MDg1OS1cXHUwODViXFx1MDg5Ny1cXHUwODlmXFx1MDhjYS1cXHUwOGUxXFx1MDhlMy1cXHUwOTAzXFx1MDkzYS1cXHUwOTNjXFx1MDkzZS1cXHUwOTRmXFx1MDk1MS1cXHUwOTU3XFx1MDk2MlxcdTA5NjNcXHUwOTY2LVxcdTA5NmZcXHUwOTgxLVxcdTA5ODNcXHUwOWJjXFx1MDliZS1cXHUwOWM0XFx1MDljN1xcdTA5YzhcXHUwOWNiLVxcdTA5Y2RcXHUwOWQ3XFx1MDllMlxcdTA5ZTNcXHUwOWU2LVxcdTA5ZWZcXHUwOWZlXFx1MGEwMS1cXHUwYTAzXFx1MGEzY1xcdTBhM2UtXFx1MGE0MlxcdTBhNDdcXHUwYTQ4XFx1MGE0Yi1cXHUwYTRkXFx1MGE1MVxcdTBhNjYtXFx1MGE3MVxcdTBhNzVcXHUwYTgxLVxcdTBhODNcXHUwYWJjXFx1MGFiZS1cXHUwYWM1XFx1MGFjNy1cXHUwYWM5XFx1MGFjYi1cXHUwYWNkXFx1MGFlMlxcdTBhZTNcXHUwYWU2LVxcdTBhZWZcXHUwYWZhLVxcdTBhZmZcXHUwYjAxLVxcdTBiMDNcXHUwYjNjXFx1MGIzZS1cXHUwYjQ0XFx1MGI0N1xcdTBiNDhcXHUwYjRiLVxcdTBiNGRcXHUwYjU1LVxcdTBiNTdcXHUwYjYyXFx1MGI2M1xcdTBiNjYtXFx1MGI2ZlxcdTBiODJcXHUwYmJlLVxcdTBiYzJcXHUwYmM2LVxcdTBiYzhcXHUwYmNhLVxcdTBiY2RcXHUwYmQ3XFx1MGJlNi1cXHUwYmVmXFx1MGMwMC1cXHUwYzA0XFx1MGMzY1xcdTBjM2UtXFx1MGM0NFxcdTBjNDYtXFx1MGM0OFxcdTBjNGEtXFx1MGM0ZFxcdTBjNTVcXHUwYzU2XFx1MGM2MlxcdTBjNjNcXHUwYzY2LVxcdTBjNmZcXHUwYzgxLVxcdTBjODNcXHUwY2JjXFx1MGNiZS1cXHUwY2M0XFx1MGNjNi1cXHUwY2M4XFx1MGNjYS1cXHUwY2NkXFx1MGNkNVxcdTBjZDZcXHUwY2UyXFx1MGNlM1xcdTBjZTYtXFx1MGNlZlxcdTBjZjNcXHUwZDAwLVxcdTBkMDNcXHUwZDNiXFx1MGQzY1xcdTBkM2UtXFx1MGQ0NFxcdTBkNDYtXFx1MGQ0OFxcdTBkNGEtXFx1MGQ0ZFxcdTBkNTdcXHUwZDYyXFx1MGQ2M1xcdTBkNjYtXFx1MGQ2ZlxcdTBkODEtXFx1MGQ4M1xcdTBkY2FcXHUwZGNmLVxcdTBkZDRcXHUwZGQ2XFx1MGRkOC1cXHUwZGRmXFx1MGRlNi1cXHUwZGVmXFx1MGRmMlxcdTBkZjNcXHUwZTMxXFx1MGUzNC1cXHUwZTNhXFx1MGU0Ny1cXHUwZTRlXFx1MGU1MC1cXHUwZTU5XFx1MGViMVxcdTBlYjQtXFx1MGViY1xcdTBlYzgtXFx1MGVjZVxcdTBlZDAtXFx1MGVkOVxcdTBmMThcXHUwZjE5XFx1MGYyMC1cXHUwZjI5XFx1MGYzNVxcdTBmMzdcXHUwZjM5XFx1MGYzZVxcdTBmM2ZcXHUwZjcxLVxcdTBmODRcXHUwZjg2XFx1MGY4N1xcdTBmOGQtXFx1MGY5N1xcdTBmOTktXFx1MGZiY1xcdTBmYzZcXHUxMDJiLVxcdTEwM2VcXHUxMDQwLVxcdTEwNDlcXHUxMDU2LVxcdTEwNTlcXHUxMDVlLVxcdTEwNjBcXHUxMDYyLVxcdTEwNjRcXHUxMDY3LVxcdTEwNmRcXHUxMDcxLVxcdTEwNzRcXHUxMDgyLVxcdTEwOGRcXHUxMDhmLVxcdTEwOWRcXHUxMzVkLVxcdTEzNWZcXHUxMzY5LVxcdTEzNzFcXHUxNzEyLVxcdTE3MTVcXHUxNzMyLVxcdTE3MzRcXHUxNzUyXFx1MTc1M1xcdTE3NzJcXHUxNzczXFx1MTdiNC1cXHUxN2QzXFx1MTdkZFxcdTE3ZTAtXFx1MTdlOVxcdTE4MGItXFx1MTgwZFxcdTE4MGYtXFx1MTgxOVxcdTE4YTlcXHUxOTIwLVxcdTE5MmJcXHUxOTMwLVxcdTE5M2JcXHUxOTQ2LVxcdTE5NGZcXHUxOWQwLVxcdTE5ZGFcXHUxYTE3LVxcdTFhMWJcXHUxYTU1LVxcdTFhNWVcXHUxYTYwLVxcdTFhN2NcXHUxYTdmLVxcdTFhODlcXHUxYTkwLVxcdTFhOTlcXHUxYWIwLVxcdTFhYmRcXHUxYWJmLVxcdTFhZGRcXHUxYWUwLVxcdTFhZWJcXHUxYjAwLVxcdTFiMDRcXHUxYjM0LVxcdTFiNDRcXHUxYjUwLVxcdTFiNTlcXHUxYjZiLVxcdTFiNzNcXHUxYjgwLVxcdTFiODJcXHUxYmExLVxcdTFiYWRcXHUxYmIwLVxcdTFiYjlcXHUxYmU2LVxcdTFiZjNcXHUxYzI0LVxcdTFjMzdcXHUxYzQwLVxcdTFjNDlcXHUxYzUwLVxcdTFjNTlcXHUxY2QwLVxcdTFjZDJcXHUxY2Q0LVxcdTFjZThcXHUxY2VkXFx1MWNmNFxcdTFjZjctXFx1MWNmOVxcdTFkYzAtXFx1MWRmZlxcdTIwMGNcXHUyMDBkXFx1MjAzZlxcdTIwNDBcXHUyMDU0XFx1MjBkMC1cXHUyMGRjXFx1MjBlMVxcdTIwZTUtXFx1MjBmMFxcdTJjZWYtXFx1MmNmMVxcdTJkN2ZcXHUyZGUwLVxcdTJkZmZcXHUzMDJhLVxcdTMwMmZcXHUzMDk5XFx1MzA5YVxcdTMwZmJcXHVhNjIwLVxcdWE2MjlcXHVhNjZmXFx1YTY3NC1cXHVhNjdkXFx1YTY5ZVxcdWE2OWZcXHVhNmYwXFx1YTZmMVxcdWE4MDJcXHVhODA2XFx1YTgwYlxcdWE4MjMtXFx1YTgyN1xcdWE4MmNcXHVhODgwXFx1YTg4MVxcdWE4YjQtXFx1YThjNVxcdWE4ZDAtXFx1YThkOVxcdWE4ZTAtXFx1YThmMVxcdWE4ZmYtXFx1YTkwOVxcdWE5MjYtXFx1YTkyZFxcdWE5NDctXFx1YTk1M1xcdWE5ODAtXFx1YTk4M1xcdWE5YjMtXFx1YTljMFxcdWE5ZDAtXFx1YTlkOVxcdWE5ZTVcXHVhOWYwLVxcdWE5ZjlcXHVhYTI5LVxcdWFhMzZcXHVhYTQzXFx1YWE0Y1xcdWFhNGRcXHVhYTUwLVxcdWFhNTlcXHVhYTdiLVxcdWFhN2RcXHVhYWIwXFx1YWFiMi1cXHVhYWI0XFx1YWFiN1xcdWFhYjhcXHVhYWJlXFx1YWFiZlxcdWFhYzFcXHVhYWViLVxcdWFhZWZcXHVhYWY1XFx1YWFmNlxcdWFiZTMtXFx1YWJlYVxcdWFiZWNcXHVhYmVkXFx1YWJmMC1cXHVhYmY5XFx1ZmIxZVxcdWZlMDAtXFx1ZmUwZlxcdWZlMjAtXFx1ZmUyZlxcdWZlMzNcXHVmZTM0XFx1ZmU0ZC1cXHVmZTRmXFx1ZmYxMC1cXHVmZjE5XFx1ZmYzZlxcdWZmNjVcIjtcbmNvbnN0IG5vbkFTQ0lJaWRlbnRpZmllclN0YXJ0ID0gbmV3IFJlZ0V4cChcIltcIiArIG5vbkFTQ0lJaWRlbnRpZmllclN0YXJ0Q2hhcnMgKyBcIl1cIik7XG5jb25zdCBub25BU0NJSWlkZW50aWZpZXIgPSBuZXcgUmVnRXhwKFwiW1wiICsgbm9uQVNDSUlpZGVudGlmaWVyU3RhcnRDaGFycyArIG5vbkFTQ0lJaWRlbnRpZmllckNoYXJzICsgXCJdXCIpO1xubm9uQVNDSUlpZGVudGlmaWVyU3RhcnRDaGFycyA9IG5vbkFTQ0lJaWRlbnRpZmllckNoYXJzID0gbnVsbDtcbmNvbnN0IGFzdHJhbElkZW50aWZpZXJTdGFydENvZGVzID0gWzAsIDExLCAyLCAyNSwgMiwgMTgsIDIsIDEsIDIsIDE0LCAzLCAxMywgMzUsIDEyMiwgNzAsIDUyLCAyNjgsIDI4LCA0LCA0OCwgNDgsIDMxLCAxNCwgMjksIDYsIDM3LCAxMSwgMjksIDMsIDM1LCA1LCA3LCAyLCA0LCA0MywgMTU3LCAxOSwgMzUsIDUsIDM1LCA1LCAzOSwgOSwgNTEsIDEzLCAxMCwgMiwgMTQsIDIsIDYsIDIsIDEsIDIsIDEwLCAyLCAxNCwgMiwgNiwgMiwgMSwgNCwgNTEsIDEzLCAzMTAsIDEwLCAyMSwgMTEsIDcsIDI1LCA1LCAyLCA0MSwgMiwgOCwgNzAsIDUsIDMsIDAsIDIsIDQzLCAyLCAxLCA0LCAwLCAzLCAyMiwgMTEsIDIyLCAxMCwgMzAsIDY2LCAxOCwgMiwgMSwgMTEsIDIxLCAxMSwgMjUsIDcsIDI1LCAzOSwgNTUsIDcsIDEsIDY1LCAwLCAxNiwgMywgMiwgMiwgMiwgMjgsIDQzLCAyOCwgNCwgMjgsIDM2LCA3LCAyLCAyNywgMjgsIDUzLCAxMSwgMjEsIDExLCAxOCwgMTQsIDE3LCAxMTEsIDcyLCA1NiwgNTAsIDE0LCA1MCwgMTQsIDM1LCAzOSwgMjcsIDEwLCAyMiwgMjUxLCA0MSwgNywgMSwgMTcsIDUsIDU3LCAyOCwgMTEsIDAsIDksIDIxLCA0MywgMTcsIDQ3LCAyMCwgMjgsIDIyLCAxMywgNTIsIDU4LCAxLCAzLCAwLCAxNCwgNDQsIDMzLCAyNCwgMjcsIDM1LCAzMCwgMCwgMywgMCwgOSwgMzQsIDQsIDAsIDEzLCA0NywgMTUsIDMsIDIyLCAwLCAyLCAwLCAzNiwgMTcsIDIsIDI0LCAyMCwgMSwgNjQsIDYsIDIsIDAsIDIsIDMsIDIsIDE0LCAyLCA5LCA4LCA0NiwgMzksIDcsIDMsIDEsIDMsIDIxLCAyLCA2LCAyLCAxLCAyLCA0LCA0LCAwLCAxOSwgMCwgMTMsIDQsIDMxLCA5LCAyLCAwLCAzLCAwLCAyLCAzNywgMiwgMCwgMjYsIDAsIDIsIDAsIDQ1LCA1MiwgMTksIDMsIDIxLCAyLCAzMSwgNDcsIDIxLCAxLCAyLCAwLCAxODUsIDQ2LCA0MiwgMywgMzcsIDQ3LCAyMSwgMCwgNjAsIDQyLCAxNCwgMCwgNzIsIDI2LCAzOCwgNiwgMTg2LCA0MywgMTE3LCA2MywgMzIsIDcsIDMsIDAsIDMsIDcsIDIsIDEsIDIsIDIzLCAxNiwgMCwgMiwgMCwgOTUsIDcsIDMsIDM4LCAxNywgMCwgMiwgMCwgMjksIDAsIDExLCAzOSwgOCwgMCwgMjIsIDAsIDEyLCA0NSwgMjAsIDAsIDE5LCA3MiwgMjAwLCAzMiwgMzIsIDgsIDIsIDM2LCAxOCwgMCwgNTAsIDI5LCAxMTMsIDYsIDIsIDEsIDIsIDM3LCAyMiwgMCwgMjYsIDUsIDIsIDEsIDIsIDMxLCAxNSwgMCwgMjQsIDQzLCAyNjEsIDE4LCAxNiwgMCwgMiwgMTIsIDIsIDMzLCAxMjUsIDAsIDgwLCA5MjEsIDEwMywgMTEwLCAxOCwgMTk1LCAyNjM3LCA5NiwgMTYsIDEwNzEsIDE4LCA1LCAyNiwgMzk5NCwgNiwgNTgyLCA2ODQyLCAyOSwgMTc2MywgNTY4LCA4LCAzMCwgMTgsIDc4LCAxOCwgMjksIDE5LCA0NywgMTcsIDMsIDMyLCAyMCwgNiwgMTgsIDQzMywgNDQsIDIxMiwgNjMsIDMzLCAyNCwgMywgMjQsIDQ1LCA3NCwgNiwgMCwgNjcsIDEyLCA2NSwgMSwgMiwgMCwgMTUsIDQsIDEwLCA3MzgxLCA0MiwgMzEsIDk4LCAxMTQsIDg3MDIsIDMsIDIsIDYsIDIsIDEsIDIsIDI5MCwgMTYsIDAsIDMwLCAyLCAzLCAwLCAxNSwgMywgOSwgMzk1LCAyMzA5LCAxMDYsIDYsIDEyLCA0LCA4LCA4LCA5LCA1OTkxLCA4NCwgMiwgNzAsIDIsIDEsIDMsIDAsIDMsIDEsIDMsIDMsIDIsIDExLCAyLCAwLCAyLCA2LCAyLCA2NCwgMiwgMywgMywgNywgMiwgNiwgMiwgMjcsIDIsIDMsIDIsIDQsIDIsIDAsIDQsIDYsIDIsIDMzOSwgMywgMjQsIDIsIDI0LCAyLCAzMCwgMiwgMjQsIDIsIDMwLCAyLCAyNCwgMiwgMzAsIDIsIDI0LCAyLCAzMCwgMiwgMjQsIDIsIDcsIDE4NDUsIDMwLCA3LCA1LCAyNjIsIDYxLCAxNDcsIDQ0LCAxMSwgNiwgMTcsIDAsIDMyMiwgMjksIDE5LCA0MywgNDg1LCAyNywgMjI5LCAyOSwgMywgMCwgMjA4LCAzMCwgMiwgMiwgMiwgMSwgMiwgNiwgMywgNCwgMTAsIDEsIDIyNSwgNiwgMiwgMywgMiwgMSwgMiwgMTQsIDIsIDE5NiwgNjAsIDY3LCA4LCAwLCAxMjA1LCAzLCAyLCAyNiwgMiwgMSwgMiwgMCwgMywgMCwgMiwgOSwgMiwgMywgMiwgMCwgMiwgMCwgNywgMCwgNSwgMCwgMiwgMCwgMiwgMCwgMiwgMiwgMiwgMSwgMiwgMCwgMywgMCwgMiwgMCwgMiwgMCwgMiwgMCwgMiwgMCwgMiwgMSwgMiwgMCwgMywgMywgMiwgNiwgMiwgMywgMiwgMywgMiwgMCwgMiwgOSwgMiwgMTYsIDYsIDIsIDIsIDQsIDIsIDE2LCA0NDIxLCA0MjcxOSwgMzMsIDQzODEsIDMsIDU3NzMsIDMsIDc0NzIsIDE2LCA2MjEsIDI0NjcsIDU0MSwgMTUwNywgNDkzOCwgNiwgODQ4OV07XG5jb25zdCBhc3RyYWxJZGVudGlmaWVyQ29kZXMgPSBbNTA5LCAwLCAyMjcsIDAsIDE1MCwgNCwgMjk0LCA5LCAxMzY4LCAyLCAyLCAxLCA2LCAzLCA0MSwgMiwgNSwgMCwgMTY2LCAxLCA1NzQsIDMsIDksIDksIDcsIDksIDMyLCA0LCAzMTgsIDEsIDc4LCA1LCA3MSwgMTAsIDUwLCAzLCAxMjMsIDIsIDU0LCAxNCwgMzIsIDEwLCAzLCAxLCAxMSwgMywgNDYsIDEwLCA4LCAwLCA0NiwgOSwgNywgMiwgMzcsIDEzLCAyLCA5LCA2LCAxLCA0NSwgMCwgMTMsIDIsIDQ5LCAxMywgOSwgMywgMiwgMTEsIDgzLCAxMSwgNywgMCwgMywgMCwgMTU4LCAxMSwgNiwgOSwgNywgMywgNTYsIDEsIDIsIDYsIDMsIDEsIDMsIDIsIDEwLCAwLCAxMSwgMSwgMywgNiwgNCwgNCwgNjgsIDgsIDIsIDAsIDMsIDAsIDIsIDMsIDIsIDQsIDIsIDAsIDE1LCAxLCA4MywgMTcsIDEwLCA5LCA1LCAwLCA4MiwgMTksIDEzLCA5LCAyMTQsIDYsIDMsIDgsIDI4LCAxLCA4MywgMTYsIDE2LCA5LCA4MiwgMTIsIDksIDksIDcsIDE5LCA1OCwgMTQsIDUsIDksIDI0MywgMTQsIDE2NiwgOSwgNzEsIDUsIDIsIDEsIDMsIDMsIDIsIDAsIDIsIDEsIDEzLCA5LCAxMjAsIDYsIDMsIDYsIDQsIDAsIDI5LCA5LCA0MSwgNiwgMiwgMywgOSwgMCwgMTAsIDEwLCA0NywgMTUsIDE5OSwgNywgMTM3LCA5LCA1NCwgNywgMiwgNywgMTcsIDksIDU3LCAyMSwgMiwgMTMsIDEyMywgNSwgNCwgMCwgMiwgMSwgMiwgNiwgMiwgMCwgOSwgOSwgNDksIDQsIDIsIDEsIDIsIDQsIDksIDksIDU1LCA5LCAyNjYsIDMsIDEwLCAxLCAyLCAwLCA0OSwgNiwgNCwgNCwgMTQsIDEwLCA1MzUwLCAwLCA3LCAxNCwgMTE0NjUsIDI3LCAyMzQzLCA5LCA4NywgOSwgMzksIDQsIDYwLCA2LCAyNiwgOSwgNTM1LCA5LCA0NzAsIDAsIDIsIDU0LCA4LCAzLCA4MiwgMCwgMTIsIDEsIDE5NjI4LCAxLCA0MTc4LCA5LCA1MTksIDQ1LCAzLCAyMiwgNTQzLCA0LCA0LCA1LCA5LCA3LCAzLCA2LCAzMSwgMywgMTQ5LCAyLCAxNDE4LCA0OSwgNTEzLCA1NCwgNSwgNDksIDksIDAsIDE1LCAwLCAyMywgNCwgMiwgMTQsIDEzNjEsIDYsIDIsIDE2LCAzLCA2LCAyLCAxLCAyLCA0LCAxMDEsIDAsIDE2MSwgNiwgMTAsIDksIDM1NywgMCwgNjIsIDEzLCA0OTksIDEzLCAyNDUsIDEsIDIsIDksIDIzMywgMCwgMywgMCwgOCwgMSwgNiwgMCwgNDc1LCA2LCAxMTAsIDYsIDYsIDksIDQ3NTksIDksIDc4NzcxOSwgMjM5XTtcbmZ1bmN0aW9uIGlzSW5Bc3RyYWxTZXQoY29kZSwgc2V0KSB7XG4gIGxldCBwb3MgPSAweDEwMDAwO1xuICBmb3IgKGxldCBpID0gMCwgbGVuZ3RoID0gc2V0Lmxlbmd0aDsgaSA8IGxlbmd0aDsgaSArPSAyKSB7XG4gICAgcG9zICs9IHNldFtpXTtcbiAgICBpZiAocG9zID4gY29kZSkgcmV0dXJuIGZhbHNlO1xuICAgIHBvcyArPSBzZXRbaSArIDFdO1xuICAgIGlmIChwb3MgPj0gY29kZSkgcmV0dXJuIHRydWU7XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufVxuZnVuY3Rpb24gaXNJZGVudGlmaWVyU3RhcnQoY29kZSkge1xuICBpZiAoY29kZSA8IDY1KSByZXR1cm4gY29kZSA9PT0gMzY7XG4gIGlmIChjb2RlIDw9IDkwKSByZXR1cm4gdHJ1ZTtcbiAgaWYgKGNvZGUgPCA5NykgcmV0dXJuIGNvZGUgPT09IDk1O1xuICBpZiAoY29kZSA8PSAxMjIpIHJldHVybiB0cnVlO1xuICBpZiAoY29kZSA8PSAweGZmZmYpIHtcbiAgICByZXR1cm4gY29kZSA+PSAweGFhICYmIG5vbkFTQ0lJaWRlbnRpZmllclN0YXJ0LnRlc3QoU3RyaW5nLmZyb21DaGFyQ29kZShjb2RlKSk7XG4gIH1cbiAgcmV0dXJuIGlzSW5Bc3RyYWxTZXQoY29kZSwgYXN0cmFsSWRlbnRpZmllclN0YXJ0Q29kZXMpO1xufVxuZnVuY3Rpb24gaXNJZGVudGlmaWVyQ2hhcihjb2RlKSB7XG4gIGlmIChjb2RlIDwgNDgpIHJldHVybiBjb2RlID09PSAzNjtcbiAgaWYgKGNvZGUgPCA1OCkgcmV0dXJuIHRydWU7XG4gIGlmIChjb2RlIDwgNjUpIHJldHVybiBmYWxzZTtcbiAgaWYgKGNvZGUgPD0gOTApIHJldHVybiB0cnVlO1xuICBpZiAoY29kZSA8IDk3KSByZXR1cm4gY29kZSA9PT0gOTU7XG4gIGlmIChjb2RlIDw9IDEyMikgcmV0dXJuIHRydWU7XG4gIGlmIChjb2RlIDw9IDB4ZmZmZikge1xuICAgIHJldHVybiBjb2RlID49IDB4YWEgJiYgbm9uQVNDSUlpZGVudGlmaWVyLnRlc3QoU3RyaW5nLmZyb21DaGFyQ29kZShjb2RlKSk7XG4gIH1cbiAgcmV0dXJuIGlzSW5Bc3RyYWxTZXQoY29kZSwgYXN0cmFsSWRlbnRpZmllclN0YXJ0Q29kZXMpIHx8IGlzSW5Bc3RyYWxTZXQoY29kZSwgYXN0cmFsSWRlbnRpZmllckNvZGVzKTtcbn1cbmNvbnN0IHJlc2VydmVkV29yZHMgPSB7XG4gIGtleXdvcmQ6IFtcImJyZWFrXCIsIFwiY2FzZVwiLCBcImNhdGNoXCIsIFwiY29udGludWVcIiwgXCJkZWJ1Z2dlclwiLCBcImRlZmF1bHRcIiwgXCJkb1wiLCBcImVsc2VcIiwgXCJmaW5hbGx5XCIsIFwiZm9yXCIsIFwiZnVuY3Rpb25cIiwgXCJpZlwiLCBcInJldHVyblwiLCBcInN3aXRjaFwiLCBcInRocm93XCIsIFwidHJ5XCIsIFwidmFyXCIsIFwiY29uc3RcIiwgXCJ3aGlsZVwiLCBcIndpdGhcIiwgXCJuZXdcIiwgXCJ0aGlzXCIsIFwic3VwZXJcIiwgXCJjbGFzc1wiLCBcImV4dGVuZHNcIiwgXCJleHBvcnRcIiwgXCJpbXBvcnRcIiwgXCJudWxsXCIsIFwidHJ1ZVwiLCBcImZhbHNlXCIsIFwiaW5cIiwgXCJpbnN0YW5jZW9mXCIsIFwidHlwZW9mXCIsIFwidm9pZFwiLCBcImRlbGV0ZVwiXSxcbiAgc3RyaWN0OiBbXCJpbXBsZW1lbnRzXCIsIFwiaW50ZXJmYWNlXCIsIFwibGV0XCIsIFwicGFja2FnZVwiLCBcInByaXZhdGVcIiwgXCJwcm90ZWN0ZWRcIiwgXCJwdWJsaWNcIiwgXCJzdGF0aWNcIiwgXCJ5aWVsZFwiXSxcbiAgc3RyaWN0QmluZDogW1wiZXZhbFwiLCBcImFyZ3VtZW50c1wiXVxufTtcbmNvbnN0IGtleXdvcmRzID0gbmV3IFNldChyZXNlcnZlZFdvcmRzLmtleXdvcmQpO1xuY29uc3QgcmVzZXJ2ZWRXb3Jkc1N0cmljdFNldCA9IG5ldyBTZXQocmVzZXJ2ZWRXb3Jkcy5zdHJpY3QpO1xuY29uc3QgcmVzZXJ2ZWRXb3Jkc1N0cmljdEJpbmRTZXQgPSBuZXcgU2V0KHJlc2VydmVkV29yZHMuc3RyaWN0QmluZCk7XG5mdW5jdGlvbiBpc1Jlc2VydmVkV29yZCh3b3JkLCBpbk1vZHVsZSkge1xuICByZXR1cm4gaW5Nb2R1bGUgJiYgd29yZCA9PT0gXCJhd2FpdFwiIHx8IHdvcmQgPT09IFwiZW51bVwiO1xufVxuZnVuY3Rpb24gaXNTdHJpY3RSZXNlcnZlZFdvcmQod29yZCwgaW5Nb2R1bGUpIHtcbiAgcmV0dXJuIGlzUmVzZXJ2ZWRXb3JkKHdvcmQsIGluTW9kdWxlKSB8fCByZXNlcnZlZFdvcmRzU3RyaWN0U2V0Lmhhcyh3b3JkKTtcbn1cbmZ1bmN0aW9uIGlzU3RyaWN0QmluZE9ubHlSZXNlcnZlZFdvcmQod29yZCkge1xuICByZXR1cm4gcmVzZXJ2ZWRXb3Jkc1N0cmljdEJpbmRTZXQuaGFzKHdvcmQpO1xufVxuZnVuY3Rpb24gaXNTdHJpY3RCaW5kUmVzZXJ2ZWRXb3JkKHdvcmQsIGluTW9kdWxlKSB7XG4gIHJldHVybiBpc1N0cmljdFJlc2VydmVkV29yZCh3b3JkLCBpbk1vZHVsZSkgfHwgaXNTdHJpY3RCaW5kT25seVJlc2VydmVkV29yZCh3b3JkKTtcbn1cbmZ1bmN0aW9uIGlzS2V5d29yZCh3b3JkKSB7XG4gIHJldHVybiBrZXl3b3Jkcy5oYXMod29yZCk7XG59XG5mdW5jdGlvbiBpc0l0ZXJhdG9yU3RhcnQoY3VycmVudCwgbmV4dCwgbmV4dDIpIHtcbiAgcmV0dXJuIGN1cnJlbnQgPT09IDY0ICYmIG5leHQgPT09IDY0ICYmIGlzSWRlbnRpZmllclN0YXJ0KG5leHQyKTtcbn1cbmNvbnN0IHJlc2VydmVkV29yZExpa2VTZXQgPSBuZXcgU2V0KFtcImJyZWFrXCIsIFwiY2FzZVwiLCBcImNhdGNoXCIsIFwiY29udGludWVcIiwgXCJkZWJ1Z2dlclwiLCBcImRlZmF1bHRcIiwgXCJkb1wiLCBcImVsc2VcIiwgXCJmaW5hbGx5XCIsIFwiZm9yXCIsIFwiZnVuY3Rpb25cIiwgXCJpZlwiLCBcInJldHVyblwiLCBcInN3aXRjaFwiLCBcInRocm93XCIsIFwidHJ5XCIsIFwidmFyXCIsIFwiY29uc3RcIiwgXCJ3aGlsZVwiLCBcIndpdGhcIiwgXCJuZXdcIiwgXCJ0aGlzXCIsIFwic3VwZXJcIiwgXCJjbGFzc1wiLCBcImV4dGVuZHNcIiwgXCJleHBvcnRcIiwgXCJpbXBvcnRcIiwgXCJudWxsXCIsIFwidHJ1ZVwiLCBcImZhbHNlXCIsIFwiaW5cIiwgXCJpbnN0YW5jZW9mXCIsIFwidHlwZW9mXCIsIFwidm9pZFwiLCBcImRlbGV0ZVwiLCBcImltcGxlbWVudHNcIiwgXCJpbnRlcmZhY2VcIiwgXCJsZXRcIiwgXCJwYWNrYWdlXCIsIFwicHJpdmF0ZVwiLCBcInByb3RlY3RlZFwiLCBcInB1YmxpY1wiLCBcInN0YXRpY1wiLCBcInlpZWxkXCIsIFwiZXZhbFwiLCBcImFyZ3VtZW50c1wiLCBcImVudW1cIiwgXCJhd2FpdFwiXSk7XG5mdW5jdGlvbiBjYW5CZVJlc2VydmVkV29yZCh3b3JkKSB7XG4gIHJldHVybiByZXNlcnZlZFdvcmRMaWtlU2V0Lmhhcyh3b3JkKTtcbn1cbmNsYXNzIFNjb3BlIHtcbiAgY29uc3RydWN0b3IoZmxhZ3MpIHtcbiAgICB0aGlzLmZsYWdzID0gMDtcbiAgICB0aGlzLm5hbWVzID0gbmV3IE1hcCgpO1xuICAgIHRoaXMuZmlyc3RMZXhpY2FsTmFtZSA9IFwiXCI7XG4gICAgdGhpcy5mbGFncyA9IGZsYWdzO1xuICB9XG59XG5jbGFzcyBTY29wZUhhbmRsZXIge1xuICBjb25zdHJ1Y3RvcihwYXJzZXIsIGluTW9kdWxlKSB7XG4gICAgdGhpcy5wYXJzZXIgPSB2b2lkIDA7XG4gICAgdGhpcy5zY29wZVN0YWNrID0gW107XG4gICAgdGhpcy5pbk1vZHVsZSA9IHZvaWQgMDtcbiAgICB0aGlzLnVuZGVmaW5lZEV4cG9ydHMgPSBuZXcgTWFwKCk7XG4gICAgdGhpcy5wYXJzZXIgPSBwYXJzZXI7XG4gICAgdGhpcy5pbk1vZHVsZSA9IGluTW9kdWxlO1xuICB9XG4gIGdldCBpblRvcExldmVsKCkge1xuICAgIHJldHVybiAodGhpcy5jdXJyZW50U2NvcGUoKS5mbGFncyAmIDEpID4gMDtcbiAgfVxuICBnZXQgaW5GdW5jdGlvbigpIHtcbiAgICByZXR1cm4gKHRoaXMuY3VycmVudFZhclNjb3BlRmxhZ3MoKSAmIDIpID4gMDtcbiAgfVxuICBnZXQgYWxsb3dTdXBlcigpIHtcbiAgICByZXR1cm4gKHRoaXMuY3VycmVudFRoaXNTY29wZUZsYWdzKCkgJiAxNikgPiAwO1xuICB9XG4gIGdldCBhbGxvd0RpcmVjdFN1cGVyKCkge1xuICAgIHJldHVybiAodGhpcy5jdXJyZW50VGhpc1Njb3BlRmxhZ3MoKSAmIDMyKSA+IDA7XG4gIH1cbiAgZ2V0IGFsbG93TmV3VGFyZ2V0KCkge1xuICAgIHJldHVybiAodGhpcy5jdXJyZW50VGhpc1Njb3BlRmxhZ3MoKSAmIDUxMikgPiAwO1xuICB9XG4gIGdldCBpbkNsYXNzKCkge1xuICAgIHJldHVybiAodGhpcy5jdXJyZW50VGhpc1Njb3BlRmxhZ3MoKSAmIDY0KSA+IDA7XG4gIH1cbiAgZ2V0IGluQ2xhc3NBbmROb3RJbk5vbkFycm93RnVuY3Rpb24oKSB7XG4gICAgY29uc3QgZmxhZ3MgPSB0aGlzLmN1cnJlbnRUaGlzU2NvcGVGbGFncygpO1xuICAgIHJldHVybiAoZmxhZ3MgJiA2NCkgPiAwICYmIChmbGFncyAmIDIpID09PSAwO1xuICB9XG4gIGdldCBpblN0YXRpY0Jsb2NrKCkge1xuICAgIGZvciAobGV0IGkgPSB0aGlzLnNjb3BlU3RhY2subGVuZ3RoIC0gMTs7IGktLSkge1xuICAgICAgY29uc3Qge1xuICAgICAgICBmbGFnc1xuICAgICAgfSA9IHRoaXMuc2NvcGVTdGFja1tpXTtcbiAgICAgIGlmIChmbGFncyAmIDEyOCkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIGlmIChmbGFncyAmICgxNjY3IHwgNjQpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgZ2V0IGluTm9uQXJyb3dGdW5jdGlvbigpIHtcbiAgICByZXR1cm4gKHRoaXMuY3VycmVudFRoaXNTY29wZUZsYWdzKCkgJiAyKSA+IDA7XG4gIH1cbiAgZ2V0IGluQmFyZUNhc2VTdGF0ZW1lbnQoKSB7XG4gICAgcmV0dXJuICh0aGlzLmN1cnJlbnRTY29wZSgpLmZsYWdzICYgMjU2KSA+IDA7XG4gIH1cbiAgZ2V0IHRyZWF0RnVuY3Rpb25zQXNWYXIoKSB7XG4gICAgcmV0dXJuIHRoaXMudHJlYXRGdW5jdGlvbnNBc1ZhckluU2NvcGUodGhpcy5jdXJyZW50U2NvcGUoKSk7XG4gIH1cbiAgY3JlYXRlU2NvcGUoZmxhZ3MpIHtcbiAgICByZXR1cm4gbmV3IFNjb3BlKGZsYWdzKTtcbiAgfVxuICBlbnRlcihmbGFncykge1xuICAgIHRoaXMuc2NvcGVTdGFjay5wdXNoKHRoaXMuY3JlYXRlU2NvcGUoZmxhZ3MpKTtcbiAgfVxuICBleGl0KCkge1xuICAgIGNvbnN0IHNjb3BlID0gdGhpcy5zY29wZVN0YWNrLnBvcCgpO1xuICAgIHJldHVybiBzY29wZS5mbGFncztcbiAgfVxuICB0cmVhdEZ1bmN0aW9uc0FzVmFySW5TY29wZShzY29wZSkge1xuICAgIHJldHVybiAhIShzY29wZS5mbGFncyAmICgyIHwgMTI4KSB8fCAhdGhpcy5wYXJzZXIuaW5Nb2R1bGUgJiYgc2NvcGUuZmxhZ3MgJiAxKTtcbiAgfVxuICBkZWNsYXJlTmFtZShuYW1lLCBiaW5kaW5nVHlwZSwgbG9jKSB7XG4gICAgbGV0IHNjb3BlID0gdGhpcy5jdXJyZW50U2NvcGUoKTtcbiAgICBpZiAoYmluZGluZ1R5cGUgJiA4IHx8IGJpbmRpbmdUeXBlICYgMTYpIHtcbiAgICAgIHRoaXMuY2hlY2tSZWRlY2xhcmF0aW9uSW5TY29wZShzY29wZSwgbmFtZSwgYmluZGluZ1R5cGUsIGxvYyk7XG4gICAgICBsZXQgdHlwZSA9IHNjb3BlLm5hbWVzLmdldChuYW1lKSB8fCAwO1xuICAgICAgaWYgKGJpbmRpbmdUeXBlICYgMTYpIHtcbiAgICAgICAgdHlwZSA9IHR5cGUgfCA0O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKCFzY29wZS5maXJzdExleGljYWxOYW1lKSB7XG4gICAgICAgICAgc2NvcGUuZmlyc3RMZXhpY2FsTmFtZSA9IG5hbWU7XG4gICAgICAgIH1cbiAgICAgICAgdHlwZSA9IHR5cGUgfCAyO1xuICAgICAgfVxuICAgICAgc2NvcGUubmFtZXMuc2V0KG5hbWUsIHR5cGUpO1xuICAgICAgaWYgKGJpbmRpbmdUeXBlICYgOCkge1xuICAgICAgICB0aGlzLm1heWJlRXhwb3J0RGVmaW5lZChzY29wZSwgbmFtZSk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChiaW5kaW5nVHlwZSAmIDQpIHtcbiAgICAgIGZvciAobGV0IGkgPSB0aGlzLnNjb3BlU3RhY2subGVuZ3RoIC0gMTsgaSA+PSAwOyAtLWkpIHtcbiAgICAgICAgc2NvcGUgPSB0aGlzLnNjb3BlU3RhY2tbaV07XG4gICAgICAgIHRoaXMuY2hlY2tSZWRlY2xhcmF0aW9uSW5TY29wZShzY29wZSwgbmFtZSwgYmluZGluZ1R5cGUsIGxvYyk7XG4gICAgICAgIHNjb3BlLm5hbWVzLnNldChuYW1lLCAoc2NvcGUubmFtZXMuZ2V0KG5hbWUpIHx8IDApIHwgMSk7XG4gICAgICAgIHRoaXMubWF5YmVFeHBvcnREZWZpbmVkKHNjb3BlLCBuYW1lKTtcbiAgICAgICAgaWYgKHNjb3BlLmZsYWdzICYgMTY2NykgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICAgIGlmICh0aGlzLnBhcnNlci5pbk1vZHVsZSAmJiBzY29wZS5mbGFncyAmIDEpIHtcbiAgICAgIHRoaXMudW5kZWZpbmVkRXhwb3J0cy5kZWxldGUobmFtZSk7XG4gICAgfVxuICB9XG4gIG1heWJlRXhwb3J0RGVmaW5lZChzY29wZSwgbmFtZSkge1xuICAgIGlmICh0aGlzLnBhcnNlci5pbk1vZHVsZSAmJiBzY29wZS5mbGFncyAmIDEpIHtcbiAgICAgIHRoaXMudW5kZWZpbmVkRXhwb3J0cy5kZWxldGUobmFtZSk7XG4gICAgfVxuICB9XG4gIGNoZWNrUmVkZWNsYXJhdGlvbkluU2NvcGUoc2NvcGUsIG5hbWUsIGJpbmRpbmdUeXBlLCBsb2MpIHtcbiAgICBpZiAodGhpcy5pc1JlZGVjbGFyZWRJblNjb3BlKHNjb3BlLCBuYW1lLCBiaW5kaW5nVHlwZSkpIHtcbiAgICAgIHRoaXMucGFyc2VyLnJhaXNlKEVycm9ycy5WYXJSZWRlY2xhcmF0aW9uLCBsb2MsIHtcbiAgICAgICAgaWRlbnRpZmllck5hbWU6IG5hbWVcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuICBpc1JlZGVjbGFyZWRJblNjb3BlKHNjb3BlLCBuYW1lLCBiaW5kaW5nVHlwZSkge1xuICAgIGlmICghKGJpbmRpbmdUeXBlICYgMSkpIHJldHVybiBmYWxzZTtcbiAgICBpZiAoYmluZGluZ1R5cGUgJiA4KSB7XG4gICAgICByZXR1cm4gc2NvcGUubmFtZXMuaGFzKG5hbWUpO1xuICAgIH1cbiAgICBjb25zdCB0eXBlID0gc2NvcGUubmFtZXMuZ2V0KG5hbWUpIHx8IDA7XG4gICAgaWYgKGJpbmRpbmdUeXBlICYgMTYpIHtcbiAgICAgIHJldHVybiAodHlwZSAmIDIpID4gMCB8fCAhdGhpcy50cmVhdEZ1bmN0aW9uc0FzVmFySW5TY29wZShzY29wZSkgJiYgKHR5cGUgJiAxKSA+IDA7XG4gICAgfVxuICAgIHJldHVybiAodHlwZSAmIDIpID4gMCAmJiAhKHNjb3BlLmZsYWdzICYgOCAmJiBzY29wZS5maXJzdExleGljYWxOYW1lID09PSBuYW1lKSB8fCAhdGhpcy50cmVhdEZ1bmN0aW9uc0FzVmFySW5TY29wZShzY29wZSkgJiYgKHR5cGUgJiA0KSA+IDA7XG4gIH1cbiAgY2hlY2tMb2NhbEV4cG9ydChpZCkge1xuICAgIGNvbnN0IHtcbiAgICAgIG5hbWVcbiAgICB9ID0gaWQ7XG4gICAgY29uc3QgdG9wTGV2ZWxTY29wZSA9IHRoaXMuc2NvcGVTdGFja1swXTtcbiAgICBpZiAoIXRvcExldmVsU2NvcGUubmFtZXMuaGFzKG5hbWUpKSB7XG4gICAgICB0aGlzLnVuZGVmaW5lZEV4cG9ydHMuc2V0KG5hbWUsIGlkLmxvYy5zdGFydCk7XG4gICAgfVxuICB9XG4gIGN1cnJlbnRTY29wZSgpIHtcbiAgICByZXR1cm4gdGhpcy5zY29wZVN0YWNrW3RoaXMuc2NvcGVTdGFjay5sZW5ndGggLSAxXTtcbiAgfVxuICBjdXJyZW50VmFyU2NvcGVGbGFncygpIHtcbiAgICBmb3IgKGxldCBpID0gdGhpcy5zY29wZVN0YWNrLmxlbmd0aCAtIDE7OyBpLS0pIHtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgZmxhZ3NcbiAgICAgIH0gPSB0aGlzLnNjb3BlU3RhY2tbaV07XG4gICAgICBpZiAoZmxhZ3MgJiAxNjY3KSB7XG4gICAgICAgIHJldHVybiBmbGFncztcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgY3VycmVudFRoaXNTY29wZUZsYWdzKCkge1xuICAgIGZvciAobGV0IGkgPSB0aGlzLnNjb3BlU3RhY2subGVuZ3RoIC0gMTs7IGktLSkge1xuICAgICAgY29uc3Qge1xuICAgICAgICBmbGFnc1xuICAgICAgfSA9IHRoaXMuc2NvcGVTdGFja1tpXTtcbiAgICAgIGlmIChmbGFncyAmICgxNjY3IHwgNjQpICYmICEoZmxhZ3MgJiA0KSkge1xuICAgICAgICByZXR1cm4gZmxhZ3M7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5jbGFzcyBGbG93U2NvcGUgZXh0ZW5kcyBTY29wZSB7XG4gIGNvbnN0cnVjdG9yKC4uLmFyZ3MpIHtcbiAgICBzdXBlciguLi5hcmdzKTtcbiAgICB0aGlzLmRlY2xhcmVGdW5jdGlvbnMgPSBuZXcgU2V0KCk7XG4gIH1cbn1cbmNsYXNzIEZsb3dTY29wZUhhbmRsZXIgZXh0ZW5kcyBTY29wZUhhbmRsZXIge1xuICBjcmVhdGVTY29wZShmbGFncykge1xuICAgIHJldHVybiBuZXcgRmxvd1Njb3BlKGZsYWdzKTtcbiAgfVxuICBkZWNsYXJlTmFtZShuYW1lLCBiaW5kaW5nVHlwZSwgbG9jKSB7XG4gICAgY29uc3Qgc2NvcGUgPSB0aGlzLmN1cnJlbnRTY29wZSgpO1xuICAgIGlmIChiaW5kaW5nVHlwZSAmIDIwNDgpIHtcbiAgICAgIHRoaXMuY2hlY2tSZWRlY2xhcmF0aW9uSW5TY29wZShzY29wZSwgbmFtZSwgYmluZGluZ1R5cGUsIGxvYyk7XG4gICAgICB0aGlzLm1heWJlRXhwb3J0RGVmaW5lZChzY29wZSwgbmFtZSk7XG4gICAgICBzY29wZS5kZWNsYXJlRnVuY3Rpb25zLmFkZChuYW1lKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgc3VwZXIuZGVjbGFyZU5hbWUobmFtZSwgYmluZGluZ1R5cGUsIGxvYyk7XG4gIH1cbiAgaXNSZWRlY2xhcmVkSW5TY29wZShzY29wZSwgbmFtZSwgYmluZGluZ1R5cGUpIHtcbiAgICBpZiAoc3VwZXIuaXNSZWRlY2xhcmVkSW5TY29wZShzY29wZSwgbmFtZSwgYmluZGluZ1R5cGUpKSByZXR1cm4gdHJ1ZTtcbiAgICBpZiAoYmluZGluZ1R5cGUgJiAyMDQ4ICYmICFzY29wZS5kZWNsYXJlRnVuY3Rpb25zLmhhcyhuYW1lKSkge1xuICAgICAgY29uc3QgdHlwZSA9IHNjb3BlLm5hbWVzLmdldChuYW1lKTtcbiAgICAgIHJldHVybiAodHlwZSAmIDQpID4gMCB8fCAodHlwZSAmIDIpID4gMDtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGNoZWNrTG9jYWxFeHBvcnQoaWQpIHtcbiAgICBpZiAoIXRoaXMuc2NvcGVTdGFja1swXS5kZWNsYXJlRnVuY3Rpb25zLmhhcyhpZC5uYW1lKSkge1xuICAgICAgc3VwZXIuY2hlY2tMb2NhbEV4cG9ydChpZCk7XG4gICAgfVxuICB9XG59XG5jb25zdCByZXNlcnZlZFR5cGVzID0gbmV3IFNldChbXCJfXCIsIFwiYW55XCIsIFwiYm9vbFwiLCBcImJvb2xlYW5cIiwgXCJlbXB0eVwiLCBcImV4dGVuZHNcIiwgXCJmYWxzZVwiLCBcImludGVyZmFjZVwiLCBcIm1peGVkXCIsIFwibnVsbFwiLCBcIm51bWJlclwiLCBcInN0YXRpY1wiLCBcInN0cmluZ1wiLCBcInRydWVcIiwgXCJ0eXBlb2ZcIiwgXCJ2b2lkXCJdKTtcbmNvbnN0IEZsb3dFcnJvcnMgPSBQYXJzZUVycm9yRW51bWBmbG93YCh7XG4gIEFtYmlndW91c0NvbmRpdGlvbmFsQXJyb3c6IFwiQW1iaWd1b3VzIGV4cHJlc3Npb246IHdyYXAgdGhlIGFycm93IGZ1bmN0aW9ucyBpbiBwYXJlbnRoZXNlcyB0byBkaXNhbWJpZ3VhdGUuXCIsXG4gIEFtYmlndW91c0RlY2xhcmVNb2R1bGVLaW5kOiBcIkZvdW5kIGJvdGggYGRlY2xhcmUgbW9kdWxlLmV4cG9ydHNgIGFuZCBgZGVjbGFyZSBleHBvcnRgIGluIHRoZSBzYW1lIG1vZHVsZS4gTW9kdWxlcyBjYW4gb25seSBoYXZlIDEgc2luY2UgdGhleSBhcmUgZWl0aGVyIGFuIEVTIG1vZHVsZSBvciB0aGV5IGFyZSBhIENvbW1vbkpTIG1vZHVsZS5cIixcbiAgQXNzaWduUmVzZXJ2ZWRUeXBlOiAoe1xuICAgIHJlc2VydmVkVHlwZVxuICB9KSA9PiBgQ2Fubm90IG92ZXJ3cml0ZSByZXNlcnZlZCB0eXBlICR7cmVzZXJ2ZWRUeXBlfS5gLFxuICBEZWNsYXJlQ2xhc3NFbGVtZW50OiBcIlRoZSBgZGVjbGFyZWAgbW9kaWZpZXIgY2FuIG9ubHkgYXBwZWFyIG9uIGNsYXNzIGZpZWxkcy5cIixcbiAgRGVjbGFyZUNsYXNzRmllbGRJbml0aWFsaXplcjogXCJJbml0aWFsaXplcnMgYXJlIG5vdCBhbGxvd2VkIGluIGZpZWxkcyB3aXRoIHRoZSBgZGVjbGFyZWAgbW9kaWZpZXIuXCIsXG4gIER1cGxpY2F0ZURlY2xhcmVNb2R1bGVFeHBvcnRzOiBcIkR1cGxpY2F0ZSBgZGVjbGFyZSBtb2R1bGUuZXhwb3J0c2Agc3RhdGVtZW50LlwiLFxuICBFbnVtQm9vbGVhbk1lbWJlck5vdEluaXRpYWxpemVkOiAoe1xuICAgIG1lbWJlck5hbWUsXG4gICAgZW51bU5hbWVcbiAgfSkgPT4gYEJvb2xlYW4gZW51bSBtZW1iZXJzIG5lZWQgdG8gYmUgaW5pdGlhbGl6ZWQuIFVzZSBlaXRoZXIgXFxgJHttZW1iZXJOYW1lfSA9IHRydWUsXFxgIG9yIFxcYCR7bWVtYmVyTmFtZX0gPSBmYWxzZSxcXGAgaW4gZW51bSBcXGAke2VudW1OYW1lfVxcYC5gLFxuICBFbnVtRHVwbGljYXRlTWVtYmVyTmFtZTogKHtcbiAgICBtZW1iZXJOYW1lLFxuICAgIGVudW1OYW1lXG4gIH0pID0+IGBFbnVtIG1lbWJlciBuYW1lcyBuZWVkIHRvIGJlIHVuaXF1ZSwgYnV0IHRoZSBuYW1lIFxcYCR7bWVtYmVyTmFtZX1cXGAgaGFzIGFscmVhZHkgYmVlbiB1c2VkIGJlZm9yZSBpbiBlbnVtIFxcYCR7ZW51bU5hbWV9XFxgLmAsXG4gIEVudW1JbmNvbnNpc3RlbnRNZW1iZXJWYWx1ZXM6ICh7XG4gICAgZW51bU5hbWVcbiAgfSkgPT4gYEVudW0gXFxgJHtlbnVtTmFtZX1cXGAgaGFzIGluY29uc2lzdGVudCBtZW1iZXIgaW5pdGlhbGl6ZXJzLiBFaXRoZXIgdXNlIG5vIGluaXRpYWxpemVycywgb3IgY29uc2lzdGVudGx5IHVzZSBsaXRlcmFscyAoZWl0aGVyIGJvb2xlYW5zLCBudW1iZXJzLCBvciBzdHJpbmdzKSBmb3IgYWxsIG1lbWJlciBpbml0aWFsaXplcnMuYCxcbiAgRW51bUludmFsaWRFeHBsaWNpdFR5cGU6ICh7XG4gICAgaW52YWxpZEVudW1UeXBlLFxuICAgIGVudW1OYW1lXG4gIH0pID0+IGBFbnVtIHR5cGUgXFxgJHtpbnZhbGlkRW51bVR5cGV9XFxgIGlzIG5vdCB2YWxpZC4gVXNlIG9uZSBvZiBcXGBib29sZWFuXFxgLCBcXGBudW1iZXJcXGAsIFxcYHN0cmluZ1xcYCwgb3IgXFxgc3ltYm9sXFxgIGluIGVudW0gXFxgJHtlbnVtTmFtZX1cXGAuYCxcbiAgRW51bUludmFsaWRFeHBsaWNpdFR5cGVVbmtub3duU3VwcGxpZWQ6ICh7XG4gICAgZW51bU5hbWVcbiAgfSkgPT4gYFN1cHBsaWVkIGVudW0gdHlwZSBpcyBub3QgdmFsaWQuIFVzZSBvbmUgb2YgXFxgYm9vbGVhblxcYCwgXFxgbnVtYmVyXFxgLCBcXGBzdHJpbmdcXGAsIG9yIFxcYHN5bWJvbFxcYCBpbiBlbnVtIFxcYCR7ZW51bU5hbWV9XFxgLmAsXG4gIEVudW1JbnZhbGlkTWVtYmVySW5pdGlhbGl6ZXJQcmltYXJ5VHlwZTogKHtcbiAgICBlbnVtTmFtZSxcbiAgICBtZW1iZXJOYW1lLFxuICAgIGV4cGxpY2l0VHlwZVxuICB9KSA9PiBgRW51bSBcXGAke2VudW1OYW1lfVxcYCBoYXMgdHlwZSBcXGAke2V4cGxpY2l0VHlwZX1cXGAsIHNvIHRoZSBpbml0aWFsaXplciBvZiBcXGAke21lbWJlck5hbWV9XFxgIG5lZWRzIHRvIGJlIGEgJHtleHBsaWNpdFR5cGV9IGxpdGVyYWwuYCxcbiAgRW51bUludmFsaWRNZW1iZXJJbml0aWFsaXplclN5bWJvbFR5cGU6ICh7XG4gICAgZW51bU5hbWUsXG4gICAgbWVtYmVyTmFtZVxuICB9KSA9PiBgU3ltYm9sIGVudW0gbWVtYmVycyBjYW5ub3QgYmUgaW5pdGlhbGl6ZWQuIFVzZSBcXGAke21lbWJlck5hbWV9LFxcYCBpbiBlbnVtIFxcYCR7ZW51bU5hbWV9XFxgLmAsXG4gIEVudW1JbnZhbGlkTWVtYmVySW5pdGlhbGl6ZXJVbmtub3duVHlwZTogKHtcbiAgICBlbnVtTmFtZSxcbiAgICBtZW1iZXJOYW1lXG4gIH0pID0+IGBUaGUgZW51bSBtZW1iZXIgaW5pdGlhbGl6ZXIgZm9yIFxcYCR7bWVtYmVyTmFtZX1cXGAgbmVlZHMgdG8gYmUgYSBsaXRlcmFsIChlaXRoZXIgYSBib29sZWFuLCBudW1iZXIsIG9yIHN0cmluZykgaW4gZW51bSBcXGAke2VudW1OYW1lfVxcYC5gLFxuICBFbnVtSW52YWxpZE1lbWJlck5hbWU6ICh7XG4gICAgZW51bU5hbWUsXG4gICAgbWVtYmVyTmFtZSxcbiAgICBzdWdnZXN0aW9uXG4gIH0pID0+IGBFbnVtIG1lbWJlciBuYW1lcyBjYW5ub3Qgc3RhcnQgd2l0aCBsb3dlcmNhc2UgJ2EnIHRocm91Z2ggJ3onLiBJbnN0ZWFkIG9mIHVzaW5nIFxcYCR7bWVtYmVyTmFtZX1cXGAsIGNvbnNpZGVyIHVzaW5nIFxcYCR7c3VnZ2VzdGlvbn1cXGAsIGluIGVudW0gXFxgJHtlbnVtTmFtZX1cXGAuYCxcbiAgRW51bU51bWJlck1lbWJlck5vdEluaXRpYWxpemVkOiAoe1xuICAgIGVudW1OYW1lLFxuICAgIG1lbWJlck5hbWVcbiAgfSkgPT4gYE51bWJlciBlbnVtIG1lbWJlcnMgbmVlZCB0byBiZSBpbml0aWFsaXplZCwgZS5nLiBcXGAke21lbWJlck5hbWV9ID0gMVxcYCBpbiBlbnVtIFxcYCR7ZW51bU5hbWV9XFxgLmAsXG4gIEVudW1TdHJpbmdNZW1iZXJJbmNvbnNpc3RlbnRseUluaXRpYWxpemVkOiAoe1xuICAgIGVudW1OYW1lXG4gIH0pID0+IGBTdHJpbmcgZW51bSBtZW1iZXJzIG5lZWQgdG8gY29uc2lzdGVudGx5IGVpdGhlciBhbGwgdXNlIGluaXRpYWxpemVycywgb3IgdXNlIG5vIGluaXRpYWxpemVycywgaW4gZW51bSBcXGAke2VudW1OYW1lfVxcYC5gLFxuICBHZXR0ZXJNYXlOb3RIYXZlVGhpc1BhcmFtOiBcIkEgZ2V0dGVyIGNhbm5vdCBoYXZlIGEgYHRoaXNgIHBhcmFtZXRlci5cIixcbiAgSW1wb3J0UmVmbGVjdGlvbkhhc0ltcG9ydFR5cGU6IFwiQW4gYGltcG9ydCBtb2R1bGVgIGRlY2xhcmF0aW9uIGNhbiBub3QgdXNlIGB0eXBlYCBvciBgdHlwZW9mYCBrZXl3b3JkLlwiLFxuICBJbXBvcnRUeXBlU2hvcnRoYW5kT25seUluUHVyZUltcG9ydDogXCJUaGUgYHR5cGVgIGFuZCBgdHlwZW9mYCBrZXl3b3JkcyBvbiBuYW1lZCBpbXBvcnRzIGNhbiBvbmx5IGJlIHVzZWQgb24gcmVndWxhciBgaW1wb3J0YCBzdGF0ZW1lbnRzLiBJdCBjYW5ub3QgYmUgdXNlZCB3aXRoIGBpbXBvcnQgdHlwZWAgb3IgYGltcG9ydCB0eXBlb2ZgIHN0YXRlbWVudHMuXCIsXG4gIEluZXhhY3RJbnNpZGVFeGFjdDogXCJFeHBsaWNpdCBpbmV4YWN0IHN5bnRheCBjYW5ub3QgYXBwZWFyIGluc2lkZSBhbiBleHBsaWNpdCBleGFjdCBvYmplY3QgdHlwZS5cIixcbiAgSW5leGFjdEluc2lkZU5vbk9iamVjdDogXCJFeHBsaWNpdCBpbmV4YWN0IHN5bnRheCBjYW5ub3QgYXBwZWFyIGluIGNsYXNzIG9yIGludGVyZmFjZSBkZWZpbml0aW9ucy5cIixcbiAgSW5leGFjdFZhcmlhbmNlOiBcIkV4cGxpY2l0IGluZXhhY3Qgc3ludGF4IGNhbm5vdCBoYXZlIHZhcmlhbmNlLlwiLFxuICBJbnZhbGlkTm9uVHlwZUltcG9ydEluRGVjbGFyZU1vZHVsZTogXCJJbXBvcnRzIHdpdGhpbiBhIGBkZWNsYXJlIG1vZHVsZWAgYm9keSBtdXN0IGFsd2F5cyBiZSBgaW1wb3J0IHR5cGVgIG9yIGBpbXBvcnQgdHlwZW9mYC5cIixcbiAgTWlzc2luZ1R5cGVQYXJhbURlZmF1bHQ6IFwiVHlwZSBwYXJhbWV0ZXIgZGVjbGFyYXRpb24gbmVlZHMgYSBkZWZhdWx0LCBzaW5jZSBhIHByZWNlZGluZyB0eXBlIHBhcmFtZXRlciBkZWNsYXJhdGlvbiBoYXMgYSBkZWZhdWx0LlwiLFxuICBOZXN0ZWREZWNsYXJlTW9kdWxlOiBcImBkZWNsYXJlIG1vZHVsZWAgY2Fubm90IGJlIHVzZWQgaW5zaWRlIGFub3RoZXIgYGRlY2xhcmUgbW9kdWxlYC5cIixcbiAgTmVzdGVkRmxvd0NvbW1lbnQ6IFwiQ2Fubm90IGhhdmUgYSBmbG93IGNvbW1lbnQgaW5zaWRlIGFub3RoZXIgZmxvdyBjb21tZW50LlwiLFxuICBQYXR0ZXJuSXNPcHRpb25hbDogT2JqZWN0LmFzc2lnbih7XG4gICAgbWVzc2FnZTogXCJBIGJpbmRpbmcgcGF0dGVybiBwYXJhbWV0ZXIgY2Fubm90IGJlIG9wdGlvbmFsIGluIGFuIGltcGxlbWVudGF0aW9uIHNpZ25hdHVyZS5cIlxuICB9LCB7XG4gICAgcmVhc29uQ29kZTogXCJPcHRpb25hbEJpbmRpbmdQYXR0ZXJuXCJcbiAgfSksXG4gIFNldHRlck1heU5vdEhhdmVUaGlzUGFyYW06IFwiQSBzZXR0ZXIgY2Fubm90IGhhdmUgYSBgdGhpc2AgcGFyYW1ldGVyLlwiLFxuICBTcHJlYWRWYXJpYW5jZTogXCJTcHJlYWQgcHJvcGVydGllcyBjYW5ub3QgaGF2ZSB2YXJpYW5jZS5cIixcbiAgVGhpc1BhcmFtQW5ub3RhdGlvblJlcXVpcmVkOiBcIkEgdHlwZSBhbm5vdGF0aW9uIGlzIHJlcXVpcmVkIGZvciB0aGUgYHRoaXNgIHBhcmFtZXRlci5cIixcbiAgVGhpc1BhcmFtQmFubmVkSW5Db25zdHJ1Y3RvcjogXCJDb25zdHJ1Y3RvcnMgY2Fubm90IGhhdmUgYSBgdGhpc2AgcGFyYW1ldGVyOyBjb25zdHJ1Y3RvcnMgZG9uJ3QgYmluZCBgdGhpc2AgbGlrZSBvdGhlciBmdW5jdGlvbnMuXCIsXG4gIFRoaXNQYXJhbU1heU5vdEJlT3B0aW9uYWw6IFwiVGhlIGB0aGlzYCBwYXJhbWV0ZXIgY2Fubm90IGJlIG9wdGlvbmFsLlwiLFxuICBUaGlzUGFyYW1NdXN0QmVGaXJzdDogXCJUaGUgYHRoaXNgIHBhcmFtZXRlciBtdXN0IGJlIHRoZSBmaXJzdCBmdW5jdGlvbiBwYXJhbWV0ZXIuXCIsXG4gIFRoaXNQYXJhbU5vRGVmYXVsdDogXCJUaGUgYHRoaXNgIHBhcmFtZXRlciBtYXkgbm90IGhhdmUgYSBkZWZhdWx0IHZhbHVlLlwiLFxuICBUeXBlQmVmb3JlSW5pdGlhbGl6ZXI6IFwiVHlwZSBhbm5vdGF0aW9ucyBtdXN0IGNvbWUgYmVmb3JlIGRlZmF1bHQgYXNzaWdubWVudHMsIGUuZy4gaW5zdGVhZCBvZiBgYWdlID0gMjU6IG51bWJlcmAgdXNlIGBhZ2U6IG51bWJlciA9IDI1YC5cIixcbiAgVHlwZUNhc3RJblBhdHRlcm46IFwiVGhlIHR5cGUgY2FzdCBleHByZXNzaW9uIGlzIGV4cGVjdGVkIHRvIGJlIHdyYXBwZWQgd2l0aCBwYXJlbnRoZXNpcy5cIixcbiAgVW5leHBlY3RlZEV4cGxpY2l0SW5leGFjdEluT2JqZWN0OiBcIkV4cGxpY2l0IGluZXhhY3Qgc3ludGF4IG11c3QgYXBwZWFyIGF0IHRoZSBlbmQgb2YgYW4gaW5leGFjdCBvYmplY3QuXCIsXG4gIFVuZXhwZWN0ZWRSZXNlcnZlZFR5cGU6ICh7XG4gICAgcmVzZXJ2ZWRUeXBlXG4gIH0pID0+IGBVbmV4cGVjdGVkIHJlc2VydmVkIHR5cGUgJHtyZXNlcnZlZFR5cGV9LmAsXG4gIFVuZXhwZWN0ZWRSZXNlcnZlZFVuZGVyc2NvcmU6IFwiYF9gIGlzIG9ubHkgYWxsb3dlZCBhcyBhIHR5cGUgYXJndW1lbnQgdG8gY2FsbCBvciBuZXcuXCIsXG4gIFVuZXhwZWN0ZWRTcGFjZUJldHdlZW5Nb2R1bG9DaGVja3M6IFwiU3BhY2VzIGJldHdlZW4gYCVgIGFuZCBgY2hlY2tzYCBhcmUgbm90IGFsbG93ZWQgaGVyZS5cIixcbiAgVW5leHBlY3RlZFNwcmVhZFR5cGU6IFwiU3ByZWFkIG9wZXJhdG9yIGNhbm5vdCBhcHBlYXIgaW4gY2xhc3Mgb3IgaW50ZXJmYWNlIGRlZmluaXRpb25zLlwiLFxuICBVbmV4cGVjdGVkU3VidHJhY3Rpb25PcGVyYW5kOiAnVW5leHBlY3RlZCB0b2tlbiwgZXhwZWN0ZWQgXCJudW1iZXJcIiBvciBcImJpZ2ludFwiLicsXG4gIFVuZXhwZWN0ZWRUb2tlbkFmdGVyVHlwZVBhcmFtZXRlcjogXCJFeHBlY3RlZCBhbiBhcnJvdyBmdW5jdGlvbiBhZnRlciB0aGlzIHR5cGUgcGFyYW1ldGVyIGRlY2xhcmF0aW9uLlwiLFxuICBVbmV4cGVjdGVkVHlwZVBhcmFtZXRlckJlZm9yZUFzeW5jQXJyb3dGdW5jdGlvbjogXCJUeXBlIHBhcmFtZXRlcnMgbXVzdCBjb21lIGFmdGVyIHRoZSBhc3luYyBrZXl3b3JkLCBlLmcuIGluc3RlYWQgb2YgYDxUPiBhc3luYyAoKSA9PiB7fWAsIHVzZSBgYXN5bmMgPFQ+KCkgPT4ge31gLlwiLFxuICBVbnN1cHBvcnRlZERlY2xhcmVFeHBvcnRLaW5kOiAoe1xuICAgIHVuc3VwcG9ydGVkRXhwb3J0S2luZCxcbiAgICBzdWdnZXN0aW9uXG4gIH0pID0+IGBcXGBkZWNsYXJlIGV4cG9ydCAke3Vuc3VwcG9ydGVkRXhwb3J0S2luZH1cXGAgaXMgbm90IHN1cHBvcnRlZC4gVXNlIFxcYCR7c3VnZ2VzdGlvbn1cXGAgaW5zdGVhZC5gLFxuICBVbnN1cHBvcnRlZFN0YXRlbWVudEluRGVjbGFyZU1vZHVsZTogXCJPbmx5IGRlY2xhcmVzIGFuZCB0eXBlIGltcG9ydHMgYXJlIGFsbG93ZWQgaW5zaWRlIGRlY2xhcmUgbW9kdWxlLlwiLFxuICBVbnRlcm1pbmF0ZWRGbG93Q29tbWVudDogXCJVbnRlcm1pbmF0ZWQgZmxvdy1jb21tZW50LlwiXG59KTtcbmZ1bmN0aW9uIGlzRXNNb2R1bGVUeXBlKGJvZHlFbGVtZW50KSB7XG4gIHJldHVybiBib2R5RWxlbWVudC50eXBlID09PSBcIkRlY2xhcmVFeHBvcnRBbGxEZWNsYXJhdGlvblwiIHx8IGJvZHlFbGVtZW50LnR5cGUgPT09IFwiRGVjbGFyZUV4cG9ydERlY2xhcmF0aW9uXCIgJiYgKCFib2R5RWxlbWVudC5kZWNsYXJhdGlvbiB8fCBib2R5RWxlbWVudC5kZWNsYXJhdGlvbi50eXBlICE9PSBcIlR5cGVBbGlhc1wiICYmIGJvZHlFbGVtZW50LmRlY2xhcmF0aW9uLnR5cGUgIT09IFwiSW50ZXJmYWNlRGVjbGFyYXRpb25cIik7XG59XG5mdW5jdGlvbiBoYXNUeXBlSW1wb3J0S2luZChub2RlKSB7XG4gIHJldHVybiBub2RlLmltcG9ydEtpbmQgPT09IFwidHlwZVwiIHx8IG5vZGUuaW1wb3J0S2luZCA9PT0gXCJ0eXBlb2ZcIjtcbn1cbmNvbnN0IGV4cG9ydFN1Z2dlc3Rpb25zID0ge1xuICBjb25zdDogXCJkZWNsYXJlIGV4cG9ydCB2YXJcIixcbiAgbGV0OiBcImRlY2xhcmUgZXhwb3J0IHZhclwiLFxuICB0eXBlOiBcImV4cG9ydCB0eXBlXCIsXG4gIGludGVyZmFjZTogXCJleHBvcnQgaW50ZXJmYWNlXCJcbn07XG5mdW5jdGlvbiBwYXJ0aXRpb24obGlzdCwgdGVzdCkge1xuICBjb25zdCBsaXN0MSA9IFtdO1xuICBjb25zdCBsaXN0MiA9IFtdO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IGxpc3QubGVuZ3RoOyBpKyspIHtcbiAgICAodGVzdChsaXN0W2ldLCBpLCBsaXN0KSA/IGxpc3QxIDogbGlzdDIpLnB1c2gobGlzdFtpXSk7XG4gIH1cbiAgcmV0dXJuIFtsaXN0MSwgbGlzdDJdO1xufVxuY29uc3QgRkxPV19QUkFHTUFfUkVHRVggPSAvXFwqP1xccypAKCg/Om5vKT9mbG93KVxcYi87XG52YXIgZmxvdyA9IHN1cGVyQ2xhc3MgPT4gY2xhc3MgRmxvd1BhcnNlck1peGluIGV4dGVuZHMgc3VwZXJDbGFzcyB7XG4gIGNvbnN0cnVjdG9yKC4uLmFyZ3MpIHtcbiAgICBzdXBlciguLi5hcmdzKTtcbiAgICB0aGlzLmZsb3dQcmFnbWEgPSB1bmRlZmluZWQ7XG4gIH1cbiAgZ2V0U2NvcGVIYW5kbGVyKCkge1xuICAgIHJldHVybiBGbG93U2NvcGVIYW5kbGVyO1xuICB9XG4gIHNob3VsZFBhcnNlVHlwZXMoKSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0UGx1Z2luT3B0aW9uKFwiZmxvd1wiLCBcImFsbFwiKSB8fCB0aGlzLmZsb3dQcmFnbWEgPT09IFwiZmxvd1wiO1xuICB9XG4gIGZpbmlzaFRva2VuKHR5cGUsIHZhbCkge1xuICAgIGlmICh0eXBlICE9PSAxMzQgJiYgdHlwZSAhPT0gMTMgJiYgdHlwZSAhPT0gMjgpIHtcbiAgICAgIGlmICh0aGlzLmZsb3dQcmFnbWEgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aGlzLmZsb3dQcmFnbWEgPSBudWxsO1xuICAgICAgfVxuICAgIH1cbiAgICBzdXBlci5maW5pc2hUb2tlbih0eXBlLCB2YWwpO1xuICB9XG4gIGFkZENvbW1lbnQoY29tbWVudCkge1xuICAgIGlmICh0aGlzLmZsb3dQcmFnbWEgPT09IHVuZGVmaW5lZCkge1xuICAgICAgY29uc3QgbWF0Y2hlcyA9IEZMT1dfUFJBR01BX1JFR0VYLmV4ZWMoY29tbWVudC52YWx1ZSk7XG4gICAgICBpZiAoIW1hdGNoZXMpIDtlbHNlIGlmIChtYXRjaGVzWzFdID09PSBcImZsb3dcIikge1xuICAgICAgICB0aGlzLmZsb3dQcmFnbWEgPSBcImZsb3dcIjtcbiAgICAgIH0gZWxzZSBpZiAobWF0Y2hlc1sxXSA9PT0gXCJub2Zsb3dcIikge1xuICAgICAgICB0aGlzLmZsb3dQcmFnbWEgPSBcIm5vZmxvd1wiO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVW5leHBlY3RlZCBmbG93IHByYWdtYVwiKTtcbiAgICAgIH1cbiAgICB9XG4gICAgc3VwZXIuYWRkQ29tbWVudChjb21tZW50KTtcbiAgfVxuICBmbG93UGFyc2VUeXBlSW5pdGlhbGlzZXIodG9rKSB7XG4gICAgY29uc3Qgb2xkSW5UeXBlID0gdGhpcy5zdGF0ZS5pblR5cGU7XG4gICAgdGhpcy5zdGF0ZS5pblR5cGUgPSB0cnVlO1xuICAgIHRoaXMuZXhwZWN0KHRvayB8fCAxNCk7XG4gICAgY29uc3QgdHlwZSA9IHRoaXMuZmxvd1BhcnNlVHlwZSgpO1xuICAgIHRoaXMuc3RhdGUuaW5UeXBlID0gb2xkSW5UeXBlO1xuICAgIHJldHVybiB0eXBlO1xuICB9XG4gIGZsb3dQYXJzZVByZWRpY2F0ZSgpIHtcbiAgICBjb25zdCBub2RlID0gdGhpcy5zdGFydE5vZGUoKTtcbiAgICBjb25zdCBtb2R1bG9Mb2MgPSB0aGlzLnN0YXRlLnN0YXJ0TG9jO1xuICAgIHRoaXMubmV4dCgpO1xuICAgIHRoaXMuZXhwZWN0Q29udGV4dHVhbCgxMTApO1xuICAgIGlmICh0aGlzLnN0YXRlLmxhc3RUb2tTdGFydExvYy5pbmRleCA+IG1vZHVsb0xvYy5pbmRleCArIDEpIHtcbiAgICAgIHRoaXMucmFpc2UoRmxvd0Vycm9ycy5VbmV4cGVjdGVkU3BhY2VCZXR3ZWVuTW9kdWxvQ2hlY2tzLCBtb2R1bG9Mb2MpO1xuICAgIH1cbiAgICBpZiAodGhpcy5lYXQoMTApKSB7XG4gICAgICBub2RlLnZhbHVlID0gc3VwZXIucGFyc2VFeHByZXNzaW9uKCk7XG4gICAgICB0aGlzLmV4cGVjdCgxMSk7XG4gICAgICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiRGVjbGFyZWRQcmVkaWNhdGVcIik7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJJbmZlcnJlZFByZWRpY2F0ZVwiKTtcbiAgICB9XG4gIH1cbiAgZmxvd1BhcnNlVHlwZUFuZFByZWRpY2F0ZUluaXRpYWxpc2VyKCkge1xuICAgIGNvbnN0IG9sZEluVHlwZSA9IHRoaXMuc3RhdGUuaW5UeXBlO1xuICAgIHRoaXMuc3RhdGUuaW5UeXBlID0gdHJ1ZTtcbiAgICB0aGlzLmV4cGVjdCgxNCk7XG4gICAgbGV0IHR5cGUgPSBudWxsO1xuICAgIGxldCBwcmVkaWNhdGUgPSBudWxsO1xuICAgIGlmICh0aGlzLm1hdGNoKDU0KSkge1xuICAgICAgdGhpcy5zdGF0ZS5pblR5cGUgPSBvbGRJblR5cGU7XG4gICAgICBwcmVkaWNhdGUgPSB0aGlzLmZsb3dQYXJzZVByZWRpY2F0ZSgpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0eXBlID0gdGhpcy5mbG93UGFyc2VUeXBlKCk7XG4gICAgICB0aGlzLnN0YXRlLmluVHlwZSA9IG9sZEluVHlwZTtcbiAgICAgIGlmICh0aGlzLm1hdGNoKDU0KSkge1xuICAgICAgICBwcmVkaWNhdGUgPSB0aGlzLmZsb3dQYXJzZVByZWRpY2F0ZSgpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gW3R5cGUsIHByZWRpY2F0ZV07XG4gIH1cbiAgZmxvd1BhcnNlRGVjbGFyZUNsYXNzKG5vZGUpIHtcbiAgICB0aGlzLm5leHQoKTtcbiAgICB0aGlzLmZsb3dQYXJzZUludGVyZmFjZWlzaChub2RlLCB0cnVlKTtcbiAgICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiRGVjbGFyZUNsYXNzXCIpO1xuICB9XG4gIGZsb3dQYXJzZURlY2xhcmVGdW5jdGlvbihub2RlKSB7XG4gICAgdGhpcy5uZXh0KCk7XG4gICAgY29uc3QgaWQgPSBub2RlLmlkID0gdGhpcy5wYXJzZUlkZW50aWZpZXIoKTtcbiAgICBjb25zdCB0eXBlTm9kZSA9IHRoaXMuc3RhcnROb2RlKCk7XG4gICAgY29uc3QgdHlwZUNvbnRhaW5lciA9IHRoaXMuc3RhcnROb2RlKCk7XG4gICAgaWYgKHRoaXMubWF0Y2goNDcpKSB7XG4gICAgICB0eXBlTm9kZS50eXBlUGFyYW1ldGVycyA9IHRoaXMuZmxvd1BhcnNlVHlwZVBhcmFtZXRlckRlY2xhcmF0aW9uKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHR5cGVOb2RlLnR5cGVQYXJhbWV0ZXJzID0gbnVsbDtcbiAgICB9XG4gICAgdGhpcy5leHBlY3QoMTApO1xuICAgIGNvbnN0IHRtcCA9IHRoaXMuZmxvd1BhcnNlRnVuY3Rpb25UeXBlUGFyYW1zKCk7XG4gICAgdHlwZU5vZGUucGFyYW1zID0gdG1wLnBhcmFtcztcbiAgICB0eXBlTm9kZS5yZXN0ID0gdG1wLnJlc3Q7XG4gICAgdHlwZU5vZGUudGhpcyA9IHRtcC5fdGhpcztcbiAgICB0aGlzLmV4cGVjdCgxMSk7XG4gICAgW3R5cGVOb2RlLnJldHVyblR5cGUsIG5vZGUucHJlZGljYXRlXSA9IHRoaXMuZmxvd1BhcnNlVHlwZUFuZFByZWRpY2F0ZUluaXRpYWxpc2VyKCk7XG4gICAgdHlwZUNvbnRhaW5lci50eXBlQW5ub3RhdGlvbiA9IHRoaXMuZmluaXNoTm9kZSh0eXBlTm9kZSwgXCJGdW5jdGlvblR5cGVBbm5vdGF0aW9uXCIpO1xuICAgIGlkLnR5cGVBbm5vdGF0aW9uID0gdGhpcy5maW5pc2hOb2RlKHR5cGVDb250YWluZXIsIFwiVHlwZUFubm90YXRpb25cIik7XG4gICAgdGhpcy5yZXNldEVuZExvY2F0aW9uKGlkKTtcbiAgICB0aGlzLnNlbWljb2xvbigpO1xuICAgIHRoaXMuc2NvcGUuZGVjbGFyZU5hbWUobm9kZS5pZC5uYW1lLCAyMDQ4LCBub2RlLmlkLmxvYy5zdGFydCk7XG4gICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIkRlY2xhcmVGdW5jdGlvblwiKTtcbiAgfVxuICBmbG93UGFyc2VEZWNsYXJlKG5vZGUsIGluc2lkZU1vZHVsZSkge1xuICAgIGlmICh0aGlzLm1hdGNoKDgwKSkge1xuICAgICAgcmV0dXJuIHRoaXMuZmxvd1BhcnNlRGVjbGFyZUNsYXNzKG5vZGUpO1xuICAgIH0gZWxzZSBpZiAodGhpcy5tYXRjaCg2OCkpIHtcbiAgICAgIHJldHVybiB0aGlzLmZsb3dQYXJzZURlY2xhcmVGdW5jdGlvbihub2RlKTtcbiAgICB9IGVsc2UgaWYgKHRoaXMubWF0Y2goNzQpKSB7XG4gICAgICByZXR1cm4gdGhpcy5mbG93UGFyc2VEZWNsYXJlVmFyaWFibGUobm9kZSk7XG4gICAgfSBlbHNlIGlmICh0aGlzLmVhdENvbnRleHR1YWwoMTI3KSkge1xuICAgICAgaWYgKHRoaXMubWF0Y2goMTYpKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmZsb3dQYXJzZURlY2xhcmVNb2R1bGVFeHBvcnRzKG5vZGUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKGluc2lkZU1vZHVsZSkge1xuICAgICAgICAgIHRoaXMucmFpc2UoRmxvd0Vycm9ycy5OZXN0ZWREZWNsYXJlTW9kdWxlLCB0aGlzLnN0YXRlLmxhc3RUb2tTdGFydExvYyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuZmxvd1BhcnNlRGVjbGFyZU1vZHVsZShub2RlKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHRoaXMuaXNDb250ZXh0dWFsKDEzMCkpIHtcbiAgICAgIHJldHVybiB0aGlzLmZsb3dQYXJzZURlY2xhcmVUeXBlQWxpYXMobm9kZSk7XG4gICAgfSBlbHNlIGlmICh0aGlzLmlzQ29udGV4dHVhbCgxMzEpKSB7XG4gICAgICByZXR1cm4gdGhpcy5mbG93UGFyc2VEZWNsYXJlT3BhcXVlVHlwZShub2RlKTtcbiAgICB9IGVsc2UgaWYgKHRoaXMuaXNDb250ZXh0dWFsKDEyOSkpIHtcbiAgICAgIHJldHVybiB0aGlzLmZsb3dQYXJzZURlY2xhcmVJbnRlcmZhY2Uobm9kZSk7XG4gICAgfSBlbHNlIGlmICh0aGlzLm1hdGNoKDgyKSkge1xuICAgICAgcmV0dXJuIHRoaXMuZmxvd1BhcnNlRGVjbGFyZUV4cG9ydERlY2xhcmF0aW9uKG5vZGUsIGluc2lkZU1vZHVsZSk7XG4gICAgfVxuICAgIHRocm93IHRoaXMudW5leHBlY3RlZCgpO1xuICB9XG4gIGZsb3dQYXJzZURlY2xhcmVWYXJpYWJsZShub2RlKSB7XG4gICAgdGhpcy5uZXh0KCk7XG4gICAgbm9kZS5pZCA9IHRoaXMuZmxvd1BhcnNlVHlwZUFubm90YXRhYmxlSWRlbnRpZmllcih0cnVlKTtcbiAgICB0aGlzLnNjb3BlLmRlY2xhcmVOYW1lKG5vZGUuaWQubmFtZSwgNSwgbm9kZS5pZC5sb2Muc3RhcnQpO1xuICAgIHRoaXMuc2VtaWNvbG9uKCk7XG4gICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIkRlY2xhcmVWYXJpYWJsZVwiKTtcbiAgfVxuICBmbG93UGFyc2VEZWNsYXJlTW9kdWxlKG5vZGUpIHtcbiAgICB0aGlzLnNjb3BlLmVudGVyKDApO1xuICAgIGlmICh0aGlzLm1hdGNoKDEzNCkpIHtcbiAgICAgIG5vZGUuaWQgPSBzdXBlci5wYXJzZUV4cHJBdG9tKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIG5vZGUuaWQgPSB0aGlzLnBhcnNlSWRlbnRpZmllcigpO1xuICAgIH1cbiAgICBjb25zdCBib2R5Tm9kZSA9IG5vZGUuYm9keSA9IHRoaXMuc3RhcnROb2RlKCk7XG4gICAgY29uc3QgYm9keSA9IGJvZHlOb2RlLmJvZHkgPSBbXTtcbiAgICB0aGlzLmV4cGVjdCg1KTtcbiAgICB3aGlsZSAoIXRoaXMubWF0Y2goOCkpIHtcbiAgICAgIGNvbnN0IGJvZHlOb2RlID0gdGhpcy5zdGFydE5vZGUoKTtcbiAgICAgIGlmICh0aGlzLm1hdGNoKDgzKSkge1xuICAgICAgICB0aGlzLm5leHQoKTtcbiAgICAgICAgaWYgKCF0aGlzLmlzQ29udGV4dHVhbCgxMzApICYmICF0aGlzLm1hdGNoKDg3KSkge1xuICAgICAgICAgIHRoaXMucmFpc2UoRmxvd0Vycm9ycy5JbnZhbGlkTm9uVHlwZUltcG9ydEluRGVjbGFyZU1vZHVsZSwgdGhpcy5zdGF0ZS5sYXN0VG9rU3RhcnRMb2MpO1xuICAgICAgICB9XG4gICAgICAgIGJvZHkucHVzaChzdXBlci5wYXJzZUltcG9ydChib2R5Tm9kZSkpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5leHBlY3RDb250ZXh0dWFsKDEyNSwgRmxvd0Vycm9ycy5VbnN1cHBvcnRlZFN0YXRlbWVudEluRGVjbGFyZU1vZHVsZSk7XG4gICAgICAgIGJvZHkucHVzaCh0aGlzLmZsb3dQYXJzZURlY2xhcmUoYm9keU5vZGUsIHRydWUpKTtcbiAgICAgIH1cbiAgICB9XG4gICAgdGhpcy5zY29wZS5leGl0KCk7XG4gICAgdGhpcy5leHBlY3QoOCk7XG4gICAgdGhpcy5maW5pc2hOb2RlKGJvZHlOb2RlLCBcIkJsb2NrU3RhdGVtZW50XCIpO1xuICAgIGxldCBraW5kID0gbnVsbDtcbiAgICBsZXQgaGFzTW9kdWxlRXhwb3J0ID0gZmFsc2U7XG4gICAgYm9keS5mb3JFYWNoKGJvZHlFbGVtZW50ID0+IHtcbiAgICAgIGlmIChpc0VzTW9kdWxlVHlwZShib2R5RWxlbWVudCkpIHtcbiAgICAgICAgaWYgKGtpbmQgPT09IFwiQ29tbW9uSlNcIikge1xuICAgICAgICAgIHRoaXMucmFpc2UoRmxvd0Vycm9ycy5BbWJpZ3VvdXNEZWNsYXJlTW9kdWxlS2luZCwgYm9keUVsZW1lbnQpO1xuICAgICAgICB9XG4gICAgICAgIGtpbmQgPSBcIkVTXCI7XG4gICAgICB9IGVsc2UgaWYgKGJvZHlFbGVtZW50LnR5cGUgPT09IFwiRGVjbGFyZU1vZHVsZUV4cG9ydHNcIikge1xuICAgICAgICBpZiAoaGFzTW9kdWxlRXhwb3J0KSB7XG4gICAgICAgICAgdGhpcy5yYWlzZShGbG93RXJyb3JzLkR1cGxpY2F0ZURlY2xhcmVNb2R1bGVFeHBvcnRzLCBib2R5RWxlbWVudCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGtpbmQgPT09IFwiRVNcIikge1xuICAgICAgICAgIHRoaXMucmFpc2UoRmxvd0Vycm9ycy5BbWJpZ3VvdXNEZWNsYXJlTW9kdWxlS2luZCwgYm9keUVsZW1lbnQpO1xuICAgICAgICB9XG4gICAgICAgIGtpbmQgPSBcIkNvbW1vbkpTXCI7XG4gICAgICAgIGhhc01vZHVsZUV4cG9ydCA9IHRydWU7XG4gICAgICB9XG4gICAgfSk7XG4gICAgbm9kZS5raW5kID0ga2luZCB8fCBcIkNvbW1vbkpTXCI7XG4gICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIkRlY2xhcmVNb2R1bGVcIik7XG4gIH1cbiAgZmxvd1BhcnNlRGVjbGFyZUV4cG9ydERlY2xhcmF0aW9uKG5vZGUsIGluc2lkZU1vZHVsZSkge1xuICAgIHRoaXMuZXhwZWN0KDgyKTtcbiAgICBpZiAodGhpcy5lYXQoNjUpKSB7XG4gICAgICBpZiAodGhpcy5tYXRjaCg2OCkgfHwgdGhpcy5tYXRjaCg4MCkpIHtcbiAgICAgICAgbm9kZS5kZWNsYXJhdGlvbiA9IHRoaXMuZmxvd1BhcnNlRGVjbGFyZSh0aGlzLnN0YXJ0Tm9kZSgpKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG5vZGUuZGVjbGFyYXRpb24gPSB0aGlzLmZsb3dQYXJzZVR5cGUoKTtcbiAgICAgICAgdGhpcy5zZW1pY29sb24oKTtcbiAgICAgIH1cbiAgICAgIG5vZGUuZGVmYXVsdCA9IHRydWU7XG4gICAgICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiRGVjbGFyZUV4cG9ydERlY2xhcmF0aW9uXCIpO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAodGhpcy5tYXRjaCg3NSkgfHwgdGhpcy5pc0xldCgpIHx8ICh0aGlzLmlzQ29udGV4dHVhbCgxMzApIHx8IHRoaXMuaXNDb250ZXh0dWFsKDEyOSkpICYmICFpbnNpZGVNb2R1bGUpIHtcbiAgICAgICAgY29uc3QgbGFiZWwgPSB0aGlzLnN0YXRlLnZhbHVlO1xuICAgICAgICB0aHJvdyB0aGlzLnJhaXNlKEZsb3dFcnJvcnMuVW5zdXBwb3J0ZWREZWNsYXJlRXhwb3J0S2luZCwgdGhpcy5zdGF0ZS5zdGFydExvYywge1xuICAgICAgICAgIHVuc3VwcG9ydGVkRXhwb3J0S2luZDogbGFiZWwsXG4gICAgICAgICAgc3VnZ2VzdGlvbjogZXhwb3J0U3VnZ2VzdGlvbnNbbGFiZWxdXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMubWF0Y2goNzQpIHx8IHRoaXMubWF0Y2goNjgpIHx8IHRoaXMubWF0Y2goODApIHx8IHRoaXMuaXNDb250ZXh0dWFsKDEzMSkpIHtcbiAgICAgICAgbm9kZS5kZWNsYXJhdGlvbiA9IHRoaXMuZmxvd1BhcnNlRGVjbGFyZSh0aGlzLnN0YXJ0Tm9kZSgpKTtcbiAgICAgICAgbm9kZS5kZWZhdWx0ID0gZmFsc2U7XG4gICAgICAgIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJEZWNsYXJlRXhwb3J0RGVjbGFyYXRpb25cIik7XG4gICAgICB9IGVsc2UgaWYgKHRoaXMubWF0Y2goNTUpIHx8IHRoaXMubWF0Y2goNSkgfHwgdGhpcy5pc0NvbnRleHR1YWwoMTI5KSB8fCB0aGlzLmlzQ29udGV4dHVhbCgxMzApIHx8IHRoaXMuaXNDb250ZXh0dWFsKDEzMSkpIHtcbiAgICAgICAgbm9kZSA9IHRoaXMucGFyc2VFeHBvcnQobm9kZSwgbnVsbCk7XG4gICAgICAgIGlmIChub2RlLnR5cGUgPT09IFwiRXhwb3J0TmFtZWREZWNsYXJhdGlvblwiKSB7XG4gICAgICAgICAgbm9kZS5kZWZhdWx0ID0gZmFsc2U7XG4gICAgICAgICAgZGVsZXRlIG5vZGUuZXhwb3J0S2luZDtcbiAgICAgICAgICByZXR1cm4gdGhpcy5jYXN0Tm9kZVRvKG5vZGUsIFwiRGVjbGFyZUV4cG9ydERlY2xhcmF0aW9uXCIpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiB0aGlzLmNhc3ROb2RlVG8obm9kZSwgXCJEZWNsYXJlRXhwb3J0QWxsRGVjbGFyYXRpb25cIik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgdGhyb3cgdGhpcy51bmV4cGVjdGVkKCk7XG4gIH1cbiAgZmxvd1BhcnNlRGVjbGFyZU1vZHVsZUV4cG9ydHMobm9kZSkge1xuICAgIHRoaXMubmV4dCgpO1xuICAgIHRoaXMuZXhwZWN0Q29udGV4dHVhbCgxMTEpO1xuICAgIG5vZGUudHlwZUFubm90YXRpb24gPSB0aGlzLmZsb3dQYXJzZVR5cGVBbm5vdGF0aW9uKCk7XG4gICAgdGhpcy5zZW1pY29sb24oKTtcbiAgICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiRGVjbGFyZU1vZHVsZUV4cG9ydHNcIik7XG4gIH1cbiAgZmxvd1BhcnNlRGVjbGFyZVR5cGVBbGlhcyhub2RlKSB7XG4gICAgdGhpcy5uZXh0KCk7XG4gICAgY29uc3QgZmluaXNoZWQgPSB0aGlzLmZsb3dQYXJzZVR5cGVBbGlhcyhub2RlKTtcbiAgICB0aGlzLmNhc3ROb2RlVG8oZmluaXNoZWQsIFwiRGVjbGFyZVR5cGVBbGlhc1wiKTtcbiAgICByZXR1cm4gZmluaXNoZWQ7XG4gIH1cbiAgZmxvd1BhcnNlRGVjbGFyZU9wYXF1ZVR5cGUobm9kZSkge1xuICAgIHRoaXMubmV4dCgpO1xuICAgIGNvbnN0IGZpbmlzaGVkID0gdGhpcy5mbG93UGFyc2VPcGFxdWVUeXBlKG5vZGUsIHRydWUpO1xuICAgIHRoaXMuY2FzdE5vZGVUbyhmaW5pc2hlZCwgXCJEZWNsYXJlT3BhcXVlVHlwZVwiKTtcbiAgICByZXR1cm4gZmluaXNoZWQ7XG4gIH1cbiAgZmxvd1BhcnNlRGVjbGFyZUludGVyZmFjZShub2RlKSB7XG4gICAgdGhpcy5uZXh0KCk7XG4gICAgdGhpcy5mbG93UGFyc2VJbnRlcmZhY2Vpc2gobm9kZSwgZmFsc2UpO1xuICAgIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJEZWNsYXJlSW50ZXJmYWNlXCIpO1xuICB9XG4gIGZsb3dQYXJzZUludGVyZmFjZWlzaChub2RlLCBpc0NsYXNzKSB7XG4gICAgbm9kZS5pZCA9IHRoaXMuZmxvd1BhcnNlUmVzdHJpY3RlZElkZW50aWZpZXIoIWlzQ2xhc3MsIHRydWUpO1xuICAgIHRoaXMuc2NvcGUuZGVjbGFyZU5hbWUobm9kZS5pZC5uYW1lLCBpc0NsYXNzID8gMTcgOiA4MjAxLCBub2RlLmlkLmxvYy5zdGFydCk7XG4gICAgaWYgKHRoaXMubWF0Y2goNDcpKSB7XG4gICAgICBub2RlLnR5cGVQYXJhbWV0ZXJzID0gdGhpcy5mbG93UGFyc2VUeXBlUGFyYW1ldGVyRGVjbGFyYXRpb24oKTtcbiAgICB9IGVsc2Uge1xuICAgICAgbm9kZS50eXBlUGFyYW1ldGVycyA9IG51bGw7XG4gICAgfVxuICAgIG5vZGUuZXh0ZW5kcyA9IFtdO1xuICAgIGlmICh0aGlzLmVhdCg4MSkpIHtcbiAgICAgIGRvIHtcbiAgICAgICAgbm9kZS5leHRlbmRzLnB1c2godGhpcy5mbG93UGFyc2VJbnRlcmZhY2VFeHRlbmRzKCkpO1xuICAgICAgfSB3aGlsZSAoIWlzQ2xhc3MgJiYgdGhpcy5lYXQoMTIpKTtcbiAgICB9XG4gICAgaWYgKGlzQ2xhc3MpIHtcbiAgICAgIG5vZGUuaW1wbGVtZW50cyA9IFtdO1xuICAgICAgbm9kZS5taXhpbnMgPSBbXTtcbiAgICAgIGlmICh0aGlzLmVhdENvbnRleHR1YWwoMTE3KSkge1xuICAgICAgICBkbyB7XG4gICAgICAgICAgbm9kZS5taXhpbnMucHVzaCh0aGlzLmZsb3dQYXJzZUludGVyZmFjZUV4dGVuZHMoKSk7XG4gICAgICAgIH0gd2hpbGUgKHRoaXMuZWF0KDEyKSk7XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5lYXRDb250ZXh0dWFsKDExMykpIHtcbiAgICAgICAgZG8ge1xuICAgICAgICAgIG5vZGUuaW1wbGVtZW50cy5wdXNoKHRoaXMuZmxvd1BhcnNlSW50ZXJmYWNlRXh0ZW5kcygpKTtcbiAgICAgICAgfSB3aGlsZSAodGhpcy5lYXQoMTIpKTtcbiAgICAgIH1cbiAgICB9XG4gICAgbm9kZS5ib2R5ID0gdGhpcy5mbG93UGFyc2VPYmplY3RUeXBlKHtcbiAgICAgIGFsbG93U3RhdGljOiBpc0NsYXNzLFxuICAgICAgYWxsb3dFeGFjdDogZmFsc2UsXG4gICAgICBhbGxvd1NwcmVhZDogZmFsc2UsXG4gICAgICBhbGxvd1Byb3RvOiBpc0NsYXNzLFxuICAgICAgYWxsb3dJbmV4YWN0OiBmYWxzZVxuICAgIH0pO1xuICB9XG4gIGZsb3dQYXJzZUludGVyZmFjZUV4dGVuZHMoKSB7XG4gICAgY29uc3Qgbm9kZSA9IHRoaXMuc3RhcnROb2RlKCk7XG4gICAgbm9kZS5pZCA9IHRoaXMuZmxvd1BhcnNlUXVhbGlmaWVkVHlwZUlkZW50aWZpZXIoKTtcbiAgICBpZiAodGhpcy5tYXRjaCg0NykpIHtcbiAgICAgIG5vZGUudHlwZVBhcmFtZXRlcnMgPSB0aGlzLmZsb3dQYXJzZVR5cGVQYXJhbWV0ZXJJbnN0YW50aWF0aW9uKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIG5vZGUudHlwZVBhcmFtZXRlcnMgPSBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiSW50ZXJmYWNlRXh0ZW5kc1wiKTtcbiAgfVxuICBmbG93UGFyc2VJbnRlcmZhY2Uobm9kZSkge1xuICAgIHRoaXMuZmxvd1BhcnNlSW50ZXJmYWNlaXNoKG5vZGUsIGZhbHNlKTtcbiAgICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiSW50ZXJmYWNlRGVjbGFyYXRpb25cIik7XG4gIH1cbiAgY2hlY2tOb3RVbmRlcnNjb3JlKHdvcmQpIHtcbiAgICBpZiAod29yZCA9PT0gXCJfXCIpIHtcbiAgICAgIHRoaXMucmFpc2UoRmxvd0Vycm9ycy5VbmV4cGVjdGVkUmVzZXJ2ZWRVbmRlcnNjb3JlLCB0aGlzLnN0YXRlLnN0YXJ0TG9jKTtcbiAgICB9XG4gIH1cbiAgY2hlY2tSZXNlcnZlZFR5cGUod29yZCwgc3RhcnRMb2MsIGRlY2xhcmF0aW9uKSB7XG4gICAgaWYgKCFyZXNlcnZlZFR5cGVzLmhhcyh3b3JkKSkgcmV0dXJuO1xuICAgIHRoaXMucmFpc2UoZGVjbGFyYXRpb24gPyBGbG93RXJyb3JzLkFzc2lnblJlc2VydmVkVHlwZSA6IEZsb3dFcnJvcnMuVW5leHBlY3RlZFJlc2VydmVkVHlwZSwgc3RhcnRMb2MsIHtcbiAgICAgIHJlc2VydmVkVHlwZTogd29yZFxuICAgIH0pO1xuICB9XG4gIGZsb3dQYXJzZVJlc3RyaWN0ZWRJZGVudGlmaWVyKGxpYmVyYWwsIGRlY2xhcmF0aW9uKSB7XG4gICAgdGhpcy5jaGVja1Jlc2VydmVkVHlwZSh0aGlzLnN0YXRlLnZhbHVlLCB0aGlzLnN0YXRlLnN0YXJ0TG9jLCBkZWNsYXJhdGlvbik7XG4gICAgcmV0dXJuIHRoaXMucGFyc2VJZGVudGlmaWVyKGxpYmVyYWwpO1xuICB9XG4gIGZsb3dQYXJzZVR5cGVBbGlhcyhub2RlKSB7XG4gICAgbm9kZS5pZCA9IHRoaXMuZmxvd1BhcnNlUmVzdHJpY3RlZElkZW50aWZpZXIoZmFsc2UsIHRydWUpO1xuICAgIHRoaXMuc2NvcGUuZGVjbGFyZU5hbWUobm9kZS5pZC5uYW1lLCA4MjAxLCBub2RlLmlkLmxvYy5zdGFydCk7XG4gICAgaWYgKHRoaXMubWF0Y2goNDcpKSB7XG4gICAgICBub2RlLnR5cGVQYXJhbWV0ZXJzID0gdGhpcy5mbG93UGFyc2VUeXBlUGFyYW1ldGVyRGVjbGFyYXRpb24oKTtcbiAgICB9IGVsc2Uge1xuICAgICAgbm9kZS50eXBlUGFyYW1ldGVycyA9IG51bGw7XG4gICAgfVxuICAgIG5vZGUucmlnaHQgPSB0aGlzLmZsb3dQYXJzZVR5cGVJbml0aWFsaXNlcigyOSk7XG4gICAgdGhpcy5zZW1pY29sb24oKTtcbiAgICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiVHlwZUFsaWFzXCIpO1xuICB9XG4gIGZsb3dQYXJzZU9wYXF1ZVR5cGUobm9kZSwgZGVjbGFyZSkge1xuICAgIHRoaXMuZXhwZWN0Q29udGV4dHVhbCgxMzApO1xuICAgIG5vZGUuaWQgPSB0aGlzLmZsb3dQYXJzZVJlc3RyaWN0ZWRJZGVudGlmaWVyKHRydWUsIHRydWUpO1xuICAgIHRoaXMuc2NvcGUuZGVjbGFyZU5hbWUobm9kZS5pZC5uYW1lLCA4MjAxLCBub2RlLmlkLmxvYy5zdGFydCk7XG4gICAgaWYgKHRoaXMubWF0Y2goNDcpKSB7XG4gICAgICBub2RlLnR5cGVQYXJhbWV0ZXJzID0gdGhpcy5mbG93UGFyc2VUeXBlUGFyYW1ldGVyRGVjbGFyYXRpb24oKTtcbiAgICB9IGVsc2Uge1xuICAgICAgbm9kZS50eXBlUGFyYW1ldGVycyA9IG51bGw7XG4gICAgfVxuICAgIG5vZGUuc3VwZXJ0eXBlID0gbnVsbDtcbiAgICBpZiAodGhpcy5tYXRjaCgxNCkpIHtcbiAgICAgIG5vZGUuc3VwZXJ0eXBlID0gdGhpcy5mbG93UGFyc2VUeXBlSW5pdGlhbGlzZXIoMTQpO1xuICAgIH1cbiAgICBub2RlLmltcGx0eXBlID0gbnVsbDtcbiAgICBpZiAoIWRlY2xhcmUpIHtcbiAgICAgIG5vZGUuaW1wbHR5cGUgPSB0aGlzLmZsb3dQYXJzZVR5cGVJbml0aWFsaXNlcigyOSk7XG4gICAgfVxuICAgIHRoaXMuc2VtaWNvbG9uKCk7XG4gICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIk9wYXF1ZVR5cGVcIik7XG4gIH1cbiAgZmxvd1BhcnNlVHlwZVBhcmFtZXRlcihyZXF1aXJlRGVmYXVsdCA9IGZhbHNlKSB7XG4gICAgY29uc3Qgbm9kZVN0YXJ0TG9jID0gdGhpcy5zdGF0ZS5zdGFydExvYztcbiAgICBjb25zdCBub2RlID0gdGhpcy5zdGFydE5vZGUoKTtcbiAgICBjb25zdCB2YXJpYW5jZSA9IHRoaXMuZmxvd1BhcnNlVmFyaWFuY2UoKTtcbiAgICBjb25zdCBpZGVudCA9IHRoaXMuZmxvd1BhcnNlVHlwZUFubm90YXRhYmxlSWRlbnRpZmllcigpO1xuICAgIG5vZGUubmFtZSA9IGlkZW50Lm5hbWU7XG4gICAgbm9kZS52YXJpYW5jZSA9IHZhcmlhbmNlO1xuICAgIG5vZGUuYm91bmQgPSBpZGVudC50eXBlQW5ub3RhdGlvbjtcbiAgICBpZiAodGhpcy5tYXRjaCgyOSkpIHtcbiAgICAgIHRoaXMuZWF0KDI5KTtcbiAgICAgIG5vZGUuZGVmYXVsdCA9IHRoaXMuZmxvd1BhcnNlVHlwZSgpO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAocmVxdWlyZURlZmF1bHQpIHtcbiAgICAgICAgdGhpcy5yYWlzZShGbG93RXJyb3JzLk1pc3NpbmdUeXBlUGFyYW1EZWZhdWx0LCBub2RlU3RhcnRMb2MpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiVHlwZVBhcmFtZXRlclwiKTtcbiAgfVxuICBmbG93UGFyc2VUeXBlUGFyYW1ldGVyRGVjbGFyYXRpb24oKSB7XG4gICAgY29uc3Qgb2xkSW5UeXBlID0gdGhpcy5zdGF0ZS5pblR5cGU7XG4gICAgY29uc3Qgbm9kZSA9IHRoaXMuc3RhcnROb2RlKCk7XG4gICAgbm9kZS5wYXJhbXMgPSBbXTtcbiAgICB0aGlzLnN0YXRlLmluVHlwZSA9IHRydWU7XG4gICAgaWYgKHRoaXMubWF0Y2goNDcpIHx8IHRoaXMubWF0Y2goMTQzKSkge1xuICAgICAgdGhpcy5uZXh0KCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMudW5leHBlY3RlZCgpO1xuICAgIH1cbiAgICBsZXQgZGVmYXVsdFJlcXVpcmVkID0gZmFsc2U7XG4gICAgZG8ge1xuICAgICAgY29uc3QgdHlwZVBhcmFtZXRlciA9IHRoaXMuZmxvd1BhcnNlVHlwZVBhcmFtZXRlcihkZWZhdWx0UmVxdWlyZWQpO1xuICAgICAgbm9kZS5wYXJhbXMucHVzaCh0eXBlUGFyYW1ldGVyKTtcbiAgICAgIGlmICh0eXBlUGFyYW1ldGVyLmRlZmF1bHQpIHtcbiAgICAgICAgZGVmYXVsdFJlcXVpcmVkID0gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIGlmICghdGhpcy5tYXRjaCg0OCkpIHtcbiAgICAgICAgdGhpcy5leHBlY3QoMTIpO1xuICAgICAgfVxuICAgIH0gd2hpbGUgKCF0aGlzLm1hdGNoKDQ4KSk7XG4gICAgdGhpcy5leHBlY3QoNDgpO1xuICAgIHRoaXMuc3RhdGUuaW5UeXBlID0gb2xkSW5UeXBlO1xuICAgIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJUeXBlUGFyYW1ldGVyRGVjbGFyYXRpb25cIik7XG4gIH1cbiAgZmxvd0luVG9wTGV2ZWxDb250ZXh0KGNiKSB7XG4gICAgaWYgKHRoaXMuY3VyQ29udGV4dCgpICE9PSB0eXBlcy5icmFjZSkge1xuICAgICAgY29uc3Qgb2xkQ29udGV4dCA9IHRoaXMuc3RhdGUuY29udGV4dDtcbiAgICAgIHRoaXMuc3RhdGUuY29udGV4dCA9IFtvbGRDb250ZXh0WzBdXTtcbiAgICAgIHRyeSB7XG4gICAgICAgIHJldHVybiBjYigpO1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgdGhpcy5zdGF0ZS5jb250ZXh0ID0gb2xkQ29udGV4dDtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIGNiKCk7XG4gICAgfVxuICB9XG4gIGZsb3dQYXJzZVR5cGVQYXJhbWV0ZXJJbnN0YW50aWF0aW9uSW5FeHByZXNzaW9uKCkge1xuICAgIGlmICh0aGlzLnJlU2Nhbl9sdCgpICE9PSA0NykgcmV0dXJuO1xuICAgIHJldHVybiB0aGlzLmZsb3dQYXJzZVR5cGVQYXJhbWV0ZXJJbnN0YW50aWF0aW9uKCk7XG4gIH1cbiAgZmxvd1BhcnNlVHlwZVBhcmFtZXRlckluc3RhbnRpYXRpb24oKSB7XG4gICAgY29uc3Qgbm9kZSA9IHRoaXMuc3RhcnROb2RlKCk7XG4gICAgY29uc3Qgb2xkSW5UeXBlID0gdGhpcy5zdGF0ZS5pblR5cGU7XG4gICAgdGhpcy5zdGF0ZS5pblR5cGUgPSB0cnVlO1xuICAgIG5vZGUucGFyYW1zID0gW107XG4gICAgdGhpcy5mbG93SW5Ub3BMZXZlbENvbnRleHQoKCkgPT4ge1xuICAgICAgdGhpcy5leHBlY3QoNDcpO1xuICAgICAgY29uc3Qgb2xkTm9Bbm9uRnVuY3Rpb25UeXBlID0gdGhpcy5zdGF0ZS5ub0Fub25GdW5jdGlvblR5cGU7XG4gICAgICB0aGlzLnN0YXRlLm5vQW5vbkZ1bmN0aW9uVHlwZSA9IGZhbHNlO1xuICAgICAgd2hpbGUgKCF0aGlzLm1hdGNoKDQ4KSkge1xuICAgICAgICBub2RlLnBhcmFtcy5wdXNoKHRoaXMuZmxvd1BhcnNlVHlwZSgpKTtcbiAgICAgICAgaWYgKCF0aGlzLm1hdGNoKDQ4KSkge1xuICAgICAgICAgIHRoaXMuZXhwZWN0KDEyKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdGhpcy5zdGF0ZS5ub0Fub25GdW5jdGlvblR5cGUgPSBvbGROb0Fub25GdW5jdGlvblR5cGU7XG4gICAgfSk7XG4gICAgdGhpcy5zdGF0ZS5pblR5cGUgPSBvbGRJblR5cGU7XG4gICAgaWYgKCF0aGlzLnN0YXRlLmluVHlwZSAmJiB0aGlzLmN1ckNvbnRleHQoKSA9PT0gdHlwZXMuYnJhY2UpIHtcbiAgICAgIHRoaXMucmVTY2FuX2x0X2d0KCk7XG4gICAgfVxuICAgIHRoaXMuZXhwZWN0KDQ4KTtcbiAgICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiVHlwZVBhcmFtZXRlckluc3RhbnRpYXRpb25cIik7XG4gIH1cbiAgZmxvd1BhcnNlVHlwZVBhcmFtZXRlckluc3RhbnRpYXRpb25DYWxsT3JOZXcoKSB7XG4gICAgaWYgKHRoaXMucmVTY2FuX2x0KCkgIT09IDQ3KSByZXR1cm4gbnVsbDtcbiAgICBjb25zdCBub2RlID0gdGhpcy5zdGFydE5vZGUoKTtcbiAgICBjb25zdCBvbGRJblR5cGUgPSB0aGlzLnN0YXRlLmluVHlwZTtcbiAgICBub2RlLnBhcmFtcyA9IFtdO1xuICAgIHRoaXMuc3RhdGUuaW5UeXBlID0gdHJ1ZTtcbiAgICB0aGlzLmV4cGVjdCg0Nyk7XG4gICAgd2hpbGUgKCF0aGlzLm1hdGNoKDQ4KSkge1xuICAgICAgbm9kZS5wYXJhbXMucHVzaCh0aGlzLmZsb3dQYXJzZVR5cGVPckltcGxpY2l0SW5zdGFudGlhdGlvbigpKTtcbiAgICAgIGlmICghdGhpcy5tYXRjaCg0OCkpIHtcbiAgICAgICAgdGhpcy5leHBlY3QoMTIpO1xuICAgICAgfVxuICAgIH1cbiAgICB0aGlzLmV4cGVjdCg0OCk7XG4gICAgdGhpcy5zdGF0ZS5pblR5cGUgPSBvbGRJblR5cGU7XG4gICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIlR5cGVQYXJhbWV0ZXJJbnN0YW50aWF0aW9uXCIpO1xuICB9XG4gIGZsb3dQYXJzZUludGVyZmFjZVR5cGUoKSB7XG4gICAgY29uc3Qgbm9kZSA9IHRoaXMuc3RhcnROb2RlKCk7XG4gICAgdGhpcy5leHBlY3RDb250ZXh0dWFsKDEyOSk7XG4gICAgbm9kZS5leHRlbmRzID0gW107XG4gICAgaWYgKHRoaXMuZWF0KDgxKSkge1xuICAgICAgZG8ge1xuICAgICAgICBub2RlLmV4dGVuZHMucHVzaCh0aGlzLmZsb3dQYXJzZUludGVyZmFjZUV4dGVuZHMoKSk7XG4gICAgICB9IHdoaWxlICh0aGlzLmVhdCgxMikpO1xuICAgIH1cbiAgICBub2RlLmJvZHkgPSB0aGlzLmZsb3dQYXJzZU9iamVjdFR5cGUoe1xuICAgICAgYWxsb3dTdGF0aWM6IGZhbHNlLFxuICAgICAgYWxsb3dFeGFjdDogZmFsc2UsXG4gICAgICBhbGxvd1NwcmVhZDogZmFsc2UsXG4gICAgICBhbGxvd1Byb3RvOiBmYWxzZSxcbiAgICAgIGFsbG93SW5leGFjdDogZmFsc2VcbiAgICB9KTtcbiAgICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiSW50ZXJmYWNlVHlwZUFubm90YXRpb25cIik7XG4gIH1cbiAgZmxvd1BhcnNlT2JqZWN0UHJvcGVydHlLZXkoKSB7XG4gICAgcmV0dXJuIHRoaXMubWF0Y2goMTM1KSB8fCB0aGlzLm1hdGNoKDEzNCkgPyBzdXBlci5wYXJzZUV4cHJBdG9tKCkgOiB0aGlzLnBhcnNlSWRlbnRpZmllcih0cnVlKTtcbiAgfVxuICBmbG93UGFyc2VPYmplY3RUeXBlSW5kZXhlcihub2RlLCBpc1N0YXRpYywgdmFyaWFuY2UpIHtcbiAgICBub2RlLnN0YXRpYyA9IGlzU3RhdGljO1xuICAgIGlmICh0aGlzLmxvb2thaGVhZCgpLnR5cGUgPT09IDE0KSB7XG4gICAgICBub2RlLmlkID0gdGhpcy5mbG93UGFyc2VPYmplY3RQcm9wZXJ0eUtleSgpO1xuICAgICAgbm9kZS5rZXkgPSB0aGlzLmZsb3dQYXJzZVR5cGVJbml0aWFsaXNlcigpO1xuICAgIH0gZWxzZSB7XG4gICAgICBub2RlLmlkID0gbnVsbDtcbiAgICAgIG5vZGUua2V5ID0gdGhpcy5mbG93UGFyc2VUeXBlKCk7XG4gICAgfVxuICAgIHRoaXMuZXhwZWN0KDMpO1xuICAgIG5vZGUudmFsdWUgPSB0aGlzLmZsb3dQYXJzZVR5cGVJbml0aWFsaXNlcigpO1xuICAgIG5vZGUudmFyaWFuY2UgPSB2YXJpYW5jZTtcbiAgICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiT2JqZWN0VHlwZUluZGV4ZXJcIik7XG4gIH1cbiAgZmxvd1BhcnNlT2JqZWN0VHlwZUludGVybmFsU2xvdChub2RlLCBpc1N0YXRpYykge1xuICAgIG5vZGUuc3RhdGljID0gaXNTdGF0aWM7XG4gICAgbm9kZS5pZCA9IHRoaXMuZmxvd1BhcnNlT2JqZWN0UHJvcGVydHlLZXkoKTtcbiAgICB0aGlzLmV4cGVjdCgzKTtcbiAgICB0aGlzLmV4cGVjdCgzKTtcbiAgICBpZiAodGhpcy5tYXRjaCg0NykgfHwgdGhpcy5tYXRjaCgxMCkpIHtcbiAgICAgIG5vZGUubWV0aG9kID0gdHJ1ZTtcbiAgICAgIG5vZGUub3B0aW9uYWwgPSBmYWxzZTtcbiAgICAgIG5vZGUudmFsdWUgPSB0aGlzLmZsb3dQYXJzZU9iamVjdFR5cGVNZXRob2Rpc2godGhpcy5zdGFydE5vZGVBdChub2RlLmxvYy5zdGFydCkpO1xuICAgIH0gZWxzZSB7XG4gICAgICBub2RlLm1ldGhvZCA9IGZhbHNlO1xuICAgICAgaWYgKHRoaXMuZWF0KDE3KSkge1xuICAgICAgICBub2RlLm9wdGlvbmFsID0gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIG5vZGUudmFsdWUgPSB0aGlzLmZsb3dQYXJzZVR5cGVJbml0aWFsaXNlcigpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiT2JqZWN0VHlwZUludGVybmFsU2xvdFwiKTtcbiAgfVxuICBmbG93UGFyc2VPYmplY3RUeXBlTWV0aG9kaXNoKG5vZGUpIHtcbiAgICBub2RlLnBhcmFtcyA9IFtdO1xuICAgIG5vZGUucmVzdCA9IG51bGw7XG4gICAgbm9kZS50eXBlUGFyYW1ldGVycyA9IG51bGw7XG4gICAgbm9kZS50aGlzID0gbnVsbDtcbiAgICBpZiAodGhpcy5tYXRjaCg0NykpIHtcbiAgICAgIG5vZGUudHlwZVBhcmFtZXRlcnMgPSB0aGlzLmZsb3dQYXJzZVR5cGVQYXJhbWV0ZXJEZWNsYXJhdGlvbigpO1xuICAgIH1cbiAgICB0aGlzLmV4cGVjdCgxMCk7XG4gICAgaWYgKHRoaXMubWF0Y2goNzgpKSB7XG4gICAgICBub2RlLnRoaXMgPSB0aGlzLmZsb3dQYXJzZUZ1bmN0aW9uVHlwZVBhcmFtKHRydWUpO1xuICAgICAgbm9kZS50aGlzLm5hbWUgPSBudWxsO1xuICAgICAgaWYgKCF0aGlzLm1hdGNoKDExKSkge1xuICAgICAgICB0aGlzLmV4cGVjdCgxMik7XG4gICAgICB9XG4gICAgfVxuICAgIHdoaWxlICghdGhpcy5tYXRjaCgxMSkgJiYgIXRoaXMubWF0Y2goMjEpKSB7XG4gICAgICBub2RlLnBhcmFtcy5wdXNoKHRoaXMuZmxvd1BhcnNlRnVuY3Rpb25UeXBlUGFyYW0oZmFsc2UpKTtcbiAgICAgIGlmICghdGhpcy5tYXRjaCgxMSkpIHtcbiAgICAgICAgdGhpcy5leHBlY3QoMTIpO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAodGhpcy5lYXQoMjEpKSB7XG4gICAgICBub2RlLnJlc3QgPSB0aGlzLmZsb3dQYXJzZUZ1bmN0aW9uVHlwZVBhcmFtKGZhbHNlKTtcbiAgICB9XG4gICAgdGhpcy5leHBlY3QoMTEpO1xuICAgIG5vZGUucmV0dXJuVHlwZSA9IHRoaXMuZmxvd1BhcnNlVHlwZUluaXRpYWxpc2VyKCk7XG4gICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIkZ1bmN0aW9uVHlwZUFubm90YXRpb25cIik7XG4gIH1cbiAgZmxvd1BhcnNlT2JqZWN0VHlwZUNhbGxQcm9wZXJ0eShub2RlLCBpc1N0YXRpYykge1xuICAgIGNvbnN0IHZhbHVlTm9kZSA9IHRoaXMuc3RhcnROb2RlKCk7XG4gICAgbm9kZS5zdGF0aWMgPSBpc1N0YXRpYztcbiAgICBub2RlLnZhbHVlID0gdGhpcy5mbG93UGFyc2VPYmplY3RUeXBlTWV0aG9kaXNoKHZhbHVlTm9kZSk7XG4gICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIk9iamVjdFR5cGVDYWxsUHJvcGVydHlcIik7XG4gIH1cbiAgZmxvd1BhcnNlT2JqZWN0VHlwZSh7XG4gICAgYWxsb3dTdGF0aWMsXG4gICAgYWxsb3dFeGFjdCxcbiAgICBhbGxvd1NwcmVhZCxcbiAgICBhbGxvd1Byb3RvLFxuICAgIGFsbG93SW5leGFjdFxuICB9KSB7XG4gICAgY29uc3Qgb2xkSW5UeXBlID0gdGhpcy5zdGF0ZS5pblR5cGU7XG4gICAgdGhpcy5zdGF0ZS5pblR5cGUgPSB0cnVlO1xuICAgIGNvbnN0IG5vZGVTdGFydCA9IHRoaXMuc3RhcnROb2RlKCk7XG4gICAgbm9kZVN0YXJ0LmNhbGxQcm9wZXJ0aWVzID0gW107XG4gICAgbm9kZVN0YXJ0LnByb3BlcnRpZXMgPSBbXTtcbiAgICBub2RlU3RhcnQuaW5kZXhlcnMgPSBbXTtcbiAgICBub2RlU3RhcnQuaW50ZXJuYWxTbG90cyA9IFtdO1xuICAgIGxldCBlbmREZWxpbTtcbiAgICBsZXQgZXhhY3Q7XG4gICAgbGV0IGluZXhhY3QgPSBmYWxzZTtcbiAgICBpZiAoYWxsb3dFeGFjdCAmJiB0aGlzLm1hdGNoKDYpKSB7XG4gICAgICB0aGlzLmV4cGVjdCg2KTtcbiAgICAgIGVuZERlbGltID0gOTtcbiAgICAgIGV4YWN0ID0gdHJ1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5leHBlY3QoNSk7XG4gICAgICBlbmREZWxpbSA9IDg7XG4gICAgICBleGFjdCA9IGZhbHNlO1xuICAgIH1cbiAgICBub2RlU3RhcnQuZXhhY3QgPSBleGFjdDtcbiAgICB3aGlsZSAoIXRoaXMubWF0Y2goZW5kRGVsaW0pKSB7XG4gICAgICBsZXQgaXNTdGF0aWMgPSBmYWxzZTtcbiAgICAgIGxldCBwcm90b1N0YXJ0TG9jID0gbnVsbDtcbiAgICAgIGxldCBpbmV4YWN0U3RhcnRMb2MgPSBudWxsO1xuICAgICAgY29uc3Qgbm9kZSA9IHRoaXMuc3RhcnROb2RlKCk7XG4gICAgICBpZiAoYWxsb3dQcm90byAmJiB0aGlzLmlzQ29udGV4dHVhbCgxMTgpKSB7XG4gICAgICAgIGNvbnN0IGxvb2thaGVhZCA9IHRoaXMubG9va2FoZWFkKCk7XG4gICAgICAgIGlmIChsb29rYWhlYWQudHlwZSAhPT0gMTQgJiYgbG9va2FoZWFkLnR5cGUgIT09IDE3KSB7XG4gICAgICAgICAgdGhpcy5uZXh0KCk7XG4gICAgICAgICAgcHJvdG9TdGFydExvYyA9IHRoaXMuc3RhdGUuc3RhcnRMb2M7XG4gICAgICAgICAgYWxsb3dTdGF0aWMgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKGFsbG93U3RhdGljICYmIHRoaXMuaXNDb250ZXh0dWFsKDEwNikpIHtcbiAgICAgICAgY29uc3QgbG9va2FoZWFkID0gdGhpcy5sb29rYWhlYWQoKTtcbiAgICAgICAgaWYgKGxvb2thaGVhZC50eXBlICE9PSAxNCAmJiBsb29rYWhlYWQudHlwZSAhPT0gMTcpIHtcbiAgICAgICAgICB0aGlzLm5leHQoKTtcbiAgICAgICAgICBpc1N0YXRpYyA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGNvbnN0IHZhcmlhbmNlID0gdGhpcy5mbG93UGFyc2VWYXJpYW5jZSgpO1xuICAgICAgaWYgKHRoaXMuZWF0KDApKSB7XG4gICAgICAgIGlmIChwcm90b1N0YXJ0TG9jICE9IG51bGwpIHtcbiAgICAgICAgICB0aGlzLnVuZXhwZWN0ZWQocHJvdG9TdGFydExvYyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuZWF0KDApKSB7XG4gICAgICAgICAgaWYgKHZhcmlhbmNlKSB7XG4gICAgICAgICAgICB0aGlzLnVuZXhwZWN0ZWQodmFyaWFuY2UubG9jLnN0YXJ0KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgbm9kZVN0YXJ0LmludGVybmFsU2xvdHMucHVzaCh0aGlzLmZsb3dQYXJzZU9iamVjdFR5cGVJbnRlcm5hbFNsb3Qobm9kZSwgaXNTdGF0aWMpKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBub2RlU3RhcnQuaW5kZXhlcnMucHVzaCh0aGlzLmZsb3dQYXJzZU9iamVjdFR5cGVJbmRleGVyKG5vZGUsIGlzU3RhdGljLCB2YXJpYW5jZSkpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKHRoaXMubWF0Y2goMTApIHx8IHRoaXMubWF0Y2goNDcpKSB7XG4gICAgICAgIGlmIChwcm90b1N0YXJ0TG9jICE9IG51bGwpIHtcbiAgICAgICAgICB0aGlzLnVuZXhwZWN0ZWQocHJvdG9TdGFydExvYyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHZhcmlhbmNlKSB7XG4gICAgICAgICAgdGhpcy51bmV4cGVjdGVkKHZhcmlhbmNlLmxvYy5zdGFydCk7XG4gICAgICAgIH1cbiAgICAgICAgbm9kZVN0YXJ0LmNhbGxQcm9wZXJ0aWVzLnB1c2godGhpcy5mbG93UGFyc2VPYmplY3RUeXBlQ2FsbFByb3BlcnR5KG5vZGUsIGlzU3RhdGljKSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBsZXQga2luZCA9IFwiaW5pdFwiO1xuICAgICAgICBpZiAodGhpcy5pc0NvbnRleHR1YWwoOTkpIHx8IHRoaXMuaXNDb250ZXh0dWFsKDEwNCkpIHtcbiAgICAgICAgICBjb25zdCBsb29rYWhlYWQgPSB0aGlzLmxvb2thaGVhZCgpO1xuICAgICAgICAgIGlmICh0b2tlbklzTGl0ZXJhbFByb3BlcnR5TmFtZShsb29rYWhlYWQudHlwZSkpIHtcbiAgICAgICAgICAgIGtpbmQgPSB0aGlzLnN0YXRlLnZhbHVlO1xuICAgICAgICAgICAgdGhpcy5uZXh0KCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHByb3BPckluZXhhY3QgPSB0aGlzLmZsb3dQYXJzZU9iamVjdFR5cGVQcm9wZXJ0eShub2RlLCBpc1N0YXRpYywgcHJvdG9TdGFydExvYywgdmFyaWFuY2UsIGtpbmQsIGFsbG93U3ByZWFkLCBhbGxvd0luZXhhY3QgIT0gbnVsbCA/IGFsbG93SW5leGFjdCA6ICFleGFjdCk7XG4gICAgICAgIGlmIChwcm9wT3JJbmV4YWN0ID09PSBudWxsKSB7XG4gICAgICAgICAgaW5leGFjdCA9IHRydWU7XG4gICAgICAgICAgaW5leGFjdFN0YXJ0TG9jID0gdGhpcy5zdGF0ZS5sYXN0VG9rU3RhcnRMb2M7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbm9kZVN0YXJ0LnByb3BlcnRpZXMucHVzaChwcm9wT3JJbmV4YWN0KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdGhpcy5mbG93T2JqZWN0VHlwZVNlbWljb2xvbigpO1xuICAgICAgaWYgKGluZXhhY3RTdGFydExvYyAmJiAhdGhpcy5tYXRjaCg4KSAmJiAhdGhpcy5tYXRjaCg5KSkge1xuICAgICAgICB0aGlzLnJhaXNlKEZsb3dFcnJvcnMuVW5leHBlY3RlZEV4cGxpY2l0SW5leGFjdEluT2JqZWN0LCBpbmV4YWN0U3RhcnRMb2MpO1xuICAgICAgfVxuICAgIH1cbiAgICB0aGlzLmV4cGVjdChlbmREZWxpbSk7XG4gICAgaWYgKGFsbG93U3ByZWFkKSB7XG4gICAgICBub2RlU3RhcnQuaW5leGFjdCA9IGluZXhhY3Q7XG4gICAgfVxuICAgIGNvbnN0IG91dCA9IHRoaXMuZmluaXNoTm9kZShub2RlU3RhcnQsIFwiT2JqZWN0VHlwZUFubm90YXRpb25cIik7XG4gICAgdGhpcy5zdGF0ZS5pblR5cGUgPSBvbGRJblR5cGU7XG4gICAgcmV0dXJuIG91dDtcbiAgfVxuICBmbG93UGFyc2VPYmplY3RUeXBlUHJvcGVydHkobm9kZSwgaXNTdGF0aWMsIHByb3RvU3RhcnRMb2MsIHZhcmlhbmNlLCBraW5kLCBhbGxvd1NwcmVhZCwgYWxsb3dJbmV4YWN0KSB7XG4gICAgaWYgKHRoaXMuZWF0KDIxKSkge1xuICAgICAgY29uc3QgaXNJbmV4YWN0VG9rZW4gPSB0aGlzLm1hdGNoKDEyKSB8fCB0aGlzLm1hdGNoKDEzKSB8fCB0aGlzLm1hdGNoKDgpIHx8IHRoaXMubWF0Y2goOSk7XG4gICAgICBpZiAoaXNJbmV4YWN0VG9rZW4pIHtcbiAgICAgICAgaWYgKCFhbGxvd1NwcmVhZCkge1xuICAgICAgICAgIHRoaXMucmFpc2UoRmxvd0Vycm9ycy5JbmV4YWN0SW5zaWRlTm9uT2JqZWN0LCB0aGlzLnN0YXRlLmxhc3RUb2tTdGFydExvYyk7XG4gICAgICAgIH0gZWxzZSBpZiAoIWFsbG93SW5leGFjdCkge1xuICAgICAgICAgIHRoaXMucmFpc2UoRmxvd0Vycm9ycy5JbmV4YWN0SW5zaWRlRXhhY3QsIHRoaXMuc3RhdGUubGFzdFRva1N0YXJ0TG9jKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodmFyaWFuY2UpIHtcbiAgICAgICAgICB0aGlzLnJhaXNlKEZsb3dFcnJvcnMuSW5leGFjdFZhcmlhbmNlLCB2YXJpYW5jZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG4gICAgICBpZiAoIWFsbG93U3ByZWFkKSB7XG4gICAgICAgIHRoaXMucmFpc2UoRmxvd0Vycm9ycy5VbmV4cGVjdGVkU3ByZWFkVHlwZSwgdGhpcy5zdGF0ZS5sYXN0VG9rU3RhcnRMb2MpO1xuICAgICAgfVxuICAgICAgaWYgKHByb3RvU3RhcnRMb2MgIT0gbnVsbCkge1xuICAgICAgICB0aGlzLnVuZXhwZWN0ZWQocHJvdG9TdGFydExvYyk7XG4gICAgICB9XG4gICAgICBpZiAodmFyaWFuY2UpIHtcbiAgICAgICAgdGhpcy5yYWlzZShGbG93RXJyb3JzLlNwcmVhZFZhcmlhbmNlLCB2YXJpYW5jZSk7XG4gICAgICB9XG4gICAgICBub2RlLmFyZ3VtZW50ID0gdGhpcy5mbG93UGFyc2VUeXBlKCk7XG4gICAgICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiT2JqZWN0VHlwZVNwcmVhZFByb3BlcnR5XCIpO1xuICAgIH0gZWxzZSB7XG4gICAgICBub2RlLmtleSA9IHRoaXMuZmxvd1BhcnNlT2JqZWN0UHJvcGVydHlLZXkoKTtcbiAgICAgIG5vZGUuc3RhdGljID0gaXNTdGF0aWM7XG4gICAgICBub2RlLnByb3RvID0gcHJvdG9TdGFydExvYyAhPSBudWxsO1xuICAgICAgbm9kZS5raW5kID0ga2luZDtcbiAgICAgIGxldCBvcHRpb25hbCA9IGZhbHNlO1xuICAgICAgaWYgKHRoaXMubWF0Y2goNDcpIHx8IHRoaXMubWF0Y2goMTApKSB7XG4gICAgICAgIG5vZGUubWV0aG9kID0gdHJ1ZTtcbiAgICAgICAgaWYgKHByb3RvU3RhcnRMb2MgIT0gbnVsbCkge1xuICAgICAgICAgIHRoaXMudW5leHBlY3RlZChwcm90b1N0YXJ0TG9jKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodmFyaWFuY2UpIHtcbiAgICAgICAgICB0aGlzLnVuZXhwZWN0ZWQodmFyaWFuY2UubG9jLnN0YXJ0KTtcbiAgICAgICAgfVxuICAgICAgICBub2RlLnZhbHVlID0gdGhpcy5mbG93UGFyc2VPYmplY3RUeXBlTWV0aG9kaXNoKHRoaXMuc3RhcnROb2RlQXQobm9kZS5sb2Muc3RhcnQpKTtcbiAgICAgICAgaWYgKGtpbmQgPT09IFwiZ2V0XCIgfHwga2luZCA9PT0gXCJzZXRcIikge1xuICAgICAgICAgIHRoaXMuZmxvd0NoZWNrR2V0dGVyU2V0dGVyUGFyYW1zKG5vZGUpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghYWxsb3dTcHJlYWQgJiYgbm9kZS5rZXkubmFtZSA9PT0gXCJjb25zdHJ1Y3RvclwiICYmIG5vZGUudmFsdWUudGhpcykge1xuICAgICAgICAgIHRoaXMucmFpc2UoRmxvd0Vycm9ycy5UaGlzUGFyYW1CYW5uZWRJbkNvbnN0cnVjdG9yLCBub2RlLnZhbHVlLnRoaXMpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoa2luZCAhPT0gXCJpbml0XCIpIHRoaXMudW5leHBlY3RlZCgpO1xuICAgICAgICBub2RlLm1ldGhvZCA9IGZhbHNlO1xuICAgICAgICBpZiAodGhpcy5lYXQoMTcpKSB7XG4gICAgICAgICAgb3B0aW9uYWwgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIG5vZGUudmFsdWUgPSB0aGlzLmZsb3dQYXJzZVR5cGVJbml0aWFsaXNlcigpO1xuICAgICAgICBub2RlLnZhcmlhbmNlID0gdmFyaWFuY2U7XG4gICAgICB9XG4gICAgICBub2RlLm9wdGlvbmFsID0gb3B0aW9uYWw7XG4gICAgICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiT2JqZWN0VHlwZVByb3BlcnR5XCIpO1xuICAgIH1cbiAgfVxuICBmbG93Q2hlY2tHZXR0ZXJTZXR0ZXJQYXJhbXMocHJvcGVydHkpIHtcbiAgICBjb25zdCBwYXJhbUNvdW50ID0gcHJvcGVydHkua2luZCA9PT0gXCJnZXRcIiA/IDAgOiAxO1xuICAgIGNvbnN0IGxlbmd0aCA9IHByb3BlcnR5LnZhbHVlLnBhcmFtcy5sZW5ndGggKyAocHJvcGVydHkudmFsdWUucmVzdCA/IDEgOiAwKTtcbiAgICBpZiAocHJvcGVydHkudmFsdWUudGhpcykge1xuICAgICAgdGhpcy5yYWlzZShwcm9wZXJ0eS5raW5kID09PSBcImdldFwiID8gRmxvd0Vycm9ycy5HZXR0ZXJNYXlOb3RIYXZlVGhpc1BhcmFtIDogRmxvd0Vycm9ycy5TZXR0ZXJNYXlOb3RIYXZlVGhpc1BhcmFtLCBwcm9wZXJ0eS52YWx1ZS50aGlzKTtcbiAgICB9XG4gICAgaWYgKGxlbmd0aCAhPT0gcGFyYW1Db3VudCkge1xuICAgICAgdGhpcy5yYWlzZShwcm9wZXJ0eS5raW5kID09PSBcImdldFwiID8gRXJyb3JzLkJhZEdldHRlckFyaXR5IDogRXJyb3JzLkJhZFNldHRlckFyaXR5LCBwcm9wZXJ0eSk7XG4gICAgfVxuICAgIGlmIChwcm9wZXJ0eS5raW5kID09PSBcInNldFwiICYmIHByb3BlcnR5LnZhbHVlLnJlc3QpIHtcbiAgICAgIHRoaXMucmFpc2UoRXJyb3JzLkJhZFNldHRlclJlc3RQYXJhbWV0ZXIsIHByb3BlcnR5KTtcbiAgICB9XG4gIH1cbiAgZmxvd09iamVjdFR5cGVTZW1pY29sb24oKSB7XG4gICAgaWYgKCF0aGlzLmVhdCgxMykgJiYgIXRoaXMuZWF0KDEyKSAmJiAhdGhpcy5tYXRjaCg4KSAmJiAhdGhpcy5tYXRjaCg5KSkge1xuICAgICAgdGhpcy51bmV4cGVjdGVkKCk7XG4gICAgfVxuICB9XG4gIGZsb3dQYXJzZVF1YWxpZmllZFR5cGVJZGVudGlmaWVyKHN0YXJ0TG9jLCBpZCkge1xuICAgIHN0YXJ0TG9jICE9IG51bGwgPyBzdGFydExvYyA6IHN0YXJ0TG9jID0gdGhpcy5zdGF0ZS5zdGFydExvYztcbiAgICBsZXQgbm9kZSA9IGlkIHx8IHRoaXMuZmxvd1BhcnNlUmVzdHJpY3RlZElkZW50aWZpZXIodHJ1ZSk7XG4gICAgd2hpbGUgKHRoaXMuZWF0KDE2KSkge1xuICAgICAgY29uc3Qgbm9kZTIgPSB0aGlzLnN0YXJ0Tm9kZUF0KHN0YXJ0TG9jKTtcbiAgICAgIG5vZGUyLnF1YWxpZmljYXRpb24gPSBub2RlO1xuICAgICAgbm9kZTIuaWQgPSB0aGlzLmZsb3dQYXJzZVJlc3RyaWN0ZWRJZGVudGlmaWVyKHRydWUpO1xuICAgICAgbm9kZSA9IHRoaXMuZmluaXNoTm9kZShub2RlMiwgXCJRdWFsaWZpZWRUeXBlSWRlbnRpZmllclwiKTtcbiAgICB9XG4gICAgcmV0dXJuIG5vZGU7XG4gIH1cbiAgZmxvd1BhcnNlR2VuZXJpY1R5cGUoc3RhcnRMb2MsIGlkKSB7XG4gICAgY29uc3Qgbm9kZSA9IHRoaXMuc3RhcnROb2RlQXQoc3RhcnRMb2MpO1xuICAgIG5vZGUudHlwZVBhcmFtZXRlcnMgPSBudWxsO1xuICAgIG5vZGUuaWQgPSB0aGlzLmZsb3dQYXJzZVF1YWxpZmllZFR5cGVJZGVudGlmaWVyKHN0YXJ0TG9jLCBpZCk7XG4gICAgaWYgKHRoaXMubWF0Y2goNDcpKSB7XG4gICAgICBub2RlLnR5cGVQYXJhbWV0ZXJzID0gdGhpcy5mbG93UGFyc2VUeXBlUGFyYW1ldGVySW5zdGFudGlhdGlvbigpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiR2VuZXJpY1R5cGVBbm5vdGF0aW9uXCIpO1xuICB9XG4gIGZsb3dQYXJzZVR5cGVvZlR5cGUoKSB7XG4gICAgY29uc3Qgbm9kZSA9IHRoaXMuc3RhcnROb2RlKCk7XG4gICAgdGhpcy5leHBlY3QoODcpO1xuICAgIG5vZGUuYXJndW1lbnQgPSB0aGlzLmZsb3dQYXJzZVByaW1hcnlUeXBlKCk7XG4gICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIlR5cGVvZlR5cGVBbm5vdGF0aW9uXCIpO1xuICB9XG4gIGZsb3dQYXJzZVR1cGxlVHlwZSgpIHtcbiAgICBjb25zdCBub2RlID0gdGhpcy5zdGFydE5vZGUoKTtcbiAgICBub2RlLnR5cGVzID0gW107XG4gICAgdGhpcy5leHBlY3QoMCk7XG4gICAgd2hpbGUgKHRoaXMuc3RhdGUucG9zIDwgdGhpcy5sZW5ndGggJiYgIXRoaXMubWF0Y2goMykpIHtcbiAgICAgIG5vZGUudHlwZXMucHVzaCh0aGlzLmZsb3dQYXJzZVR5cGUoKSk7XG4gICAgICBpZiAodGhpcy5tYXRjaCgzKSkgYnJlYWs7XG4gICAgICB0aGlzLmV4cGVjdCgxMik7XG4gICAgfVxuICAgIHRoaXMuZXhwZWN0KDMpO1xuICAgIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJUdXBsZVR5cGVBbm5vdGF0aW9uXCIpO1xuICB9XG4gIGZsb3dQYXJzZUZ1bmN0aW9uVHlwZVBhcmFtKGZpcnN0KSB7XG4gICAgbGV0IG5hbWUgPSBudWxsO1xuICAgIGxldCBvcHRpb25hbCA9IGZhbHNlO1xuICAgIGxldCB0eXBlQW5ub3RhdGlvbiA9IG51bGw7XG4gICAgY29uc3Qgbm9kZSA9IHRoaXMuc3RhcnROb2RlKCk7XG4gICAgY29uc3QgbGggPSB0aGlzLmxvb2thaGVhZCgpO1xuICAgIGNvbnN0IGlzVGhpcyA9IHRoaXMuc3RhdGUudHlwZSA9PT0gNzg7XG4gICAgaWYgKGxoLnR5cGUgPT09IDE0IHx8IGxoLnR5cGUgPT09IDE3KSB7XG4gICAgICBpZiAoaXNUaGlzICYmICFmaXJzdCkge1xuICAgICAgICB0aGlzLnJhaXNlKEZsb3dFcnJvcnMuVGhpc1BhcmFtTXVzdEJlRmlyc3QsIG5vZGUpO1xuICAgICAgfVxuICAgICAgbmFtZSA9IHRoaXMucGFyc2VJZGVudGlmaWVyKGlzVGhpcyk7XG4gICAgICBpZiAodGhpcy5lYXQoMTcpKSB7XG4gICAgICAgIG9wdGlvbmFsID0gdHJ1ZTtcbiAgICAgICAgaWYgKGlzVGhpcykge1xuICAgICAgICAgIHRoaXMucmFpc2UoRmxvd0Vycm9ycy5UaGlzUGFyYW1NYXlOb3RCZU9wdGlvbmFsLCBub2RlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdHlwZUFubm90YXRpb24gPSB0aGlzLmZsb3dQYXJzZVR5cGVJbml0aWFsaXNlcigpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0eXBlQW5ub3RhdGlvbiA9IHRoaXMuZmxvd1BhcnNlVHlwZSgpO1xuICAgIH1cbiAgICBub2RlLm5hbWUgPSBuYW1lO1xuICAgIG5vZGUub3B0aW9uYWwgPSBvcHRpb25hbDtcbiAgICBub2RlLnR5cGVBbm5vdGF0aW9uID0gdHlwZUFubm90YXRpb247XG4gICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIkZ1bmN0aW9uVHlwZVBhcmFtXCIpO1xuICB9XG4gIHJlaW50ZXJwcmV0VHlwZUFzRnVuY3Rpb25UeXBlUGFyYW0odHlwZSkge1xuICAgIGNvbnN0IG5vZGUgPSB0aGlzLnN0YXJ0Tm9kZUF0KHR5cGUubG9jLnN0YXJ0KTtcbiAgICBub2RlLm5hbWUgPSBudWxsO1xuICAgIG5vZGUub3B0aW9uYWwgPSBmYWxzZTtcbiAgICBub2RlLnR5cGVBbm5vdGF0aW9uID0gdHlwZTtcbiAgICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiRnVuY3Rpb25UeXBlUGFyYW1cIik7XG4gIH1cbiAgZmxvd1BhcnNlRnVuY3Rpb25UeXBlUGFyYW1zKHBhcmFtcyA9IFtdKSB7XG4gICAgbGV0IHJlc3QgPSBudWxsO1xuICAgIGxldCBfdGhpcyA9IG51bGw7XG4gICAgaWYgKHRoaXMubWF0Y2goNzgpKSB7XG4gICAgICBfdGhpcyA9IHRoaXMuZmxvd1BhcnNlRnVuY3Rpb25UeXBlUGFyYW0odHJ1ZSk7XG4gICAgICBfdGhpcy5uYW1lID0gbnVsbDtcbiAgICAgIGlmICghdGhpcy5tYXRjaCgxMSkpIHtcbiAgICAgICAgdGhpcy5leHBlY3QoMTIpO1xuICAgICAgfVxuICAgIH1cbiAgICB3aGlsZSAoIXRoaXMubWF0Y2goMTEpICYmICF0aGlzLm1hdGNoKDIxKSkge1xuICAgICAgcGFyYW1zLnB1c2godGhpcy5mbG93UGFyc2VGdW5jdGlvblR5cGVQYXJhbShmYWxzZSkpO1xuICAgICAgaWYgKCF0aGlzLm1hdGNoKDExKSkge1xuICAgICAgICB0aGlzLmV4cGVjdCgxMik7XG4gICAgICB9XG4gICAgfVxuICAgIGlmICh0aGlzLmVhdCgyMSkpIHtcbiAgICAgIHJlc3QgPSB0aGlzLmZsb3dQYXJzZUZ1bmN0aW9uVHlwZVBhcmFtKGZhbHNlKTtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgIHBhcmFtcyxcbiAgICAgIHJlc3QsXG4gICAgICBfdGhpc1xuICAgIH07XG4gIH1cbiAgZmxvd0lkZW50VG9UeXBlQW5ub3RhdGlvbihzdGFydExvYywgbm9kZSwgaWQpIHtcbiAgICBzd2l0Y2ggKGlkLm5hbWUpIHtcbiAgICAgIGNhc2UgXCJhbnlcIjpcbiAgICAgICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIkFueVR5cGVBbm5vdGF0aW9uXCIpO1xuICAgICAgY2FzZSBcImJvb2xcIjpcbiAgICAgIGNhc2UgXCJib29sZWFuXCI6XG4gICAgICAgIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJCb29sZWFuVHlwZUFubm90YXRpb25cIik7XG4gICAgICBjYXNlIFwibWl4ZWRcIjpcbiAgICAgICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIk1peGVkVHlwZUFubm90YXRpb25cIik7XG4gICAgICBjYXNlIFwiZW1wdHlcIjpcbiAgICAgICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIkVtcHR5VHlwZUFubm90YXRpb25cIik7XG4gICAgICBjYXNlIFwibnVtYmVyXCI6XG4gICAgICAgIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJOdW1iZXJUeXBlQW5ub3RhdGlvblwiKTtcbiAgICAgIGNhc2UgXCJzdHJpbmdcIjpcbiAgICAgICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIlN0cmluZ1R5cGVBbm5vdGF0aW9uXCIpO1xuICAgICAgY2FzZSBcInN5bWJvbFwiOlxuICAgICAgICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiU3ltYm9sVHlwZUFubm90YXRpb25cIik7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICB0aGlzLmNoZWNrTm90VW5kZXJzY29yZShpZC5uYW1lKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuZmxvd1BhcnNlR2VuZXJpY1R5cGUoc3RhcnRMb2MsIGlkKTtcbiAgICB9XG4gIH1cbiAgZmxvd1BhcnNlUHJpbWFyeVR5cGUoKSB7XG4gICAgY29uc3Qgc3RhcnRMb2MgPSB0aGlzLnN0YXRlLnN0YXJ0TG9jO1xuICAgIGNvbnN0IG5vZGUgPSB0aGlzLnN0YXJ0Tm9kZSgpO1xuICAgIGxldCB0bXA7XG4gICAgbGV0IHR5cGU7XG4gICAgbGV0IGlzR3JvdXBlZFR5cGUgPSBmYWxzZTtcbiAgICBjb25zdCBvbGROb0Fub25GdW5jdGlvblR5cGUgPSB0aGlzLnN0YXRlLm5vQW5vbkZ1bmN0aW9uVHlwZTtcbiAgICBzd2l0Y2ggKHRoaXMuc3RhdGUudHlwZSkge1xuICAgICAgY2FzZSA1OlxuICAgICAgICByZXR1cm4gdGhpcy5mbG93UGFyc2VPYmplY3RUeXBlKHtcbiAgICAgICAgICBhbGxvd1N0YXRpYzogZmFsc2UsXG4gICAgICAgICAgYWxsb3dFeGFjdDogZmFsc2UsXG4gICAgICAgICAgYWxsb3dTcHJlYWQ6IHRydWUsXG4gICAgICAgICAgYWxsb3dQcm90bzogZmFsc2UsXG4gICAgICAgICAgYWxsb3dJbmV4YWN0OiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgY2FzZSA2OlxuICAgICAgICByZXR1cm4gdGhpcy5mbG93UGFyc2VPYmplY3RUeXBlKHtcbiAgICAgICAgICBhbGxvd1N0YXRpYzogZmFsc2UsXG4gICAgICAgICAgYWxsb3dFeGFjdDogdHJ1ZSxcbiAgICAgICAgICBhbGxvd1NwcmVhZDogdHJ1ZSxcbiAgICAgICAgICBhbGxvd1Byb3RvOiBmYWxzZSxcbiAgICAgICAgICBhbGxvd0luZXhhY3Q6IGZhbHNlXG4gICAgICAgIH0pO1xuICAgICAgY2FzZSAwOlxuICAgICAgICB0aGlzLnN0YXRlLm5vQW5vbkZ1bmN0aW9uVHlwZSA9IGZhbHNlO1xuICAgICAgICB0eXBlID0gdGhpcy5mbG93UGFyc2VUdXBsZVR5cGUoKTtcbiAgICAgICAgdGhpcy5zdGF0ZS5ub0Fub25GdW5jdGlvblR5cGUgPSBvbGROb0Fub25GdW5jdGlvblR5cGU7XG4gICAgICAgIHJldHVybiB0eXBlO1xuICAgICAgY2FzZSA0NzpcbiAgICAgICAge1xuICAgICAgICAgIGNvbnN0IG5vZGUgPSB0aGlzLnN0YXJ0Tm9kZSgpO1xuICAgICAgICAgIG5vZGUudHlwZVBhcmFtZXRlcnMgPSB0aGlzLmZsb3dQYXJzZVR5cGVQYXJhbWV0ZXJEZWNsYXJhdGlvbigpO1xuICAgICAgICAgIHRoaXMuZXhwZWN0KDEwKTtcbiAgICAgICAgICB0bXAgPSB0aGlzLmZsb3dQYXJzZUZ1bmN0aW9uVHlwZVBhcmFtcygpO1xuICAgICAgICAgIG5vZGUucGFyYW1zID0gdG1wLnBhcmFtcztcbiAgICAgICAgICBub2RlLnJlc3QgPSB0bXAucmVzdDtcbiAgICAgICAgICBub2RlLnRoaXMgPSB0bXAuX3RoaXM7XG4gICAgICAgICAgdGhpcy5leHBlY3QoMTEpO1xuICAgICAgICAgIHRoaXMuZXhwZWN0KDE5KTtcbiAgICAgICAgICBub2RlLnJldHVyblR5cGUgPSB0aGlzLmZsb3dQYXJzZVR5cGUoKTtcbiAgICAgICAgICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiRnVuY3Rpb25UeXBlQW5ub3RhdGlvblwiKTtcbiAgICAgICAgfVxuICAgICAgY2FzZSAxMDpcbiAgICAgICAge1xuICAgICAgICAgIGNvbnN0IG5vZGUgPSB0aGlzLnN0YXJ0Tm9kZSgpO1xuICAgICAgICAgIHRoaXMubmV4dCgpO1xuICAgICAgICAgIGlmICghdGhpcy5tYXRjaCgxMSkgJiYgIXRoaXMubWF0Y2goMjEpKSB7XG4gICAgICAgICAgICBpZiAodG9rZW5Jc0lkZW50aWZpZXIodGhpcy5zdGF0ZS50eXBlKSB8fCB0aGlzLm1hdGNoKDc4KSkge1xuICAgICAgICAgICAgICBjb25zdCB0b2tlbiA9IHRoaXMubG9va2FoZWFkKCkudHlwZTtcbiAgICAgICAgICAgICAgaXNHcm91cGVkVHlwZSA9IHRva2VuICE9PSAxNyAmJiB0b2tlbiAhPT0gMTQ7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBpc0dyb3VwZWRUeXBlID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGlzR3JvdXBlZFR5cGUpIHtcbiAgICAgICAgICAgIHRoaXMuc3RhdGUubm9Bbm9uRnVuY3Rpb25UeXBlID0gZmFsc2U7XG4gICAgICAgICAgICB0eXBlID0gdGhpcy5mbG93UGFyc2VUeXBlKCk7XG4gICAgICAgICAgICB0aGlzLnN0YXRlLm5vQW5vbkZ1bmN0aW9uVHlwZSA9IG9sZE5vQW5vbkZ1bmN0aW9uVHlwZTtcbiAgICAgICAgICAgIGlmICh0aGlzLnN0YXRlLm5vQW5vbkZ1bmN0aW9uVHlwZSB8fCAhKHRoaXMubWF0Y2goMTIpIHx8IHRoaXMubWF0Y2goMTEpICYmIHRoaXMubG9va2FoZWFkKCkudHlwZSA9PT0gMTkpKSB7XG4gICAgICAgICAgICAgIHRoaXMuZXhwZWN0KDExKTtcbiAgICAgICAgICAgICAgcmV0dXJuIHR5cGU7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICB0aGlzLmVhdCgxMik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICh0eXBlKSB7XG4gICAgICAgICAgICB0bXAgPSB0aGlzLmZsb3dQYXJzZUZ1bmN0aW9uVHlwZVBhcmFtcyhbdGhpcy5yZWludGVycHJldFR5cGVBc0Z1bmN0aW9uVHlwZVBhcmFtKHR5cGUpXSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRtcCA9IHRoaXMuZmxvd1BhcnNlRnVuY3Rpb25UeXBlUGFyYW1zKCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIG5vZGUucGFyYW1zID0gdG1wLnBhcmFtcztcbiAgICAgICAgICBub2RlLnJlc3QgPSB0bXAucmVzdDtcbiAgICAgICAgICBub2RlLnRoaXMgPSB0bXAuX3RoaXM7XG4gICAgICAgICAgdGhpcy5leHBlY3QoMTEpO1xuICAgICAgICAgIHRoaXMuZXhwZWN0KDE5KTtcbiAgICAgICAgICBub2RlLnJldHVyblR5cGUgPSB0aGlzLmZsb3dQYXJzZVR5cGUoKTtcbiAgICAgICAgICBub2RlLnR5cGVQYXJhbWV0ZXJzID0gbnVsbDtcbiAgICAgICAgICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiRnVuY3Rpb25UeXBlQW5ub3RhdGlvblwiKTtcbiAgICAgICAgfVxuICAgICAgY2FzZSAxMzQ6XG4gICAgICAgIHJldHVybiB0aGlzLnBhcnNlTGl0ZXJhbCh0aGlzLnN0YXRlLnZhbHVlLCBcIlN0cmluZ0xpdGVyYWxUeXBlQW5ub3RhdGlvblwiKTtcbiAgICAgIGNhc2UgODU6XG4gICAgICBjYXNlIDg2OlxuICAgICAgICBub2RlLnZhbHVlID0gdGhpcy5tYXRjaCg4NSk7XG4gICAgICAgIHRoaXMubmV4dCgpO1xuICAgICAgICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiQm9vbGVhbkxpdGVyYWxUeXBlQW5ub3RhdGlvblwiKTtcbiAgICAgIGNhc2UgNTM6XG4gICAgICAgIGlmICh0aGlzLnN0YXRlLnZhbHVlID09PSBcIi1cIikge1xuICAgICAgICAgIHRoaXMubmV4dCgpO1xuICAgICAgICAgIGlmICh0aGlzLm1hdGNoKDEzNSkpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnBhcnNlTGl0ZXJhbEF0Tm9kZSgtdGhpcy5zdGF0ZS52YWx1ZSwgXCJOdW1iZXJMaXRlcmFsVHlwZUFubm90YXRpb25cIiwgbm9kZSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICh0aGlzLm1hdGNoKDEzNikpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnBhcnNlTGl0ZXJhbEF0Tm9kZSgtdGhpcy5zdGF0ZS52YWx1ZSwgXCJCaWdJbnRMaXRlcmFsVHlwZUFubm90YXRpb25cIiwgbm9kZSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHRocm93IHRoaXMucmFpc2UoRmxvd0Vycm9ycy5VbmV4cGVjdGVkU3VidHJhY3Rpb25PcGVyYW5kLCB0aGlzLnN0YXRlLnN0YXJ0TG9jKTtcbiAgICAgICAgfVxuICAgICAgICB0aHJvdyB0aGlzLnVuZXhwZWN0ZWQoKTtcbiAgICAgIGNhc2UgMTM1OlxuICAgICAgICByZXR1cm4gdGhpcy5wYXJzZUxpdGVyYWwodGhpcy5zdGF0ZS52YWx1ZSwgXCJOdW1iZXJMaXRlcmFsVHlwZUFubm90YXRpb25cIik7XG4gICAgICBjYXNlIDEzNjpcbiAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VMaXRlcmFsKHRoaXMuc3RhdGUudmFsdWUsIFwiQmlnSW50TGl0ZXJhbFR5cGVBbm5vdGF0aW9uXCIpO1xuICAgICAgY2FzZSA4ODpcbiAgICAgICAgdGhpcy5uZXh0KCk7XG4gICAgICAgIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJWb2lkVHlwZUFubm90YXRpb25cIik7XG4gICAgICBjYXNlIDg0OlxuICAgICAgICB0aGlzLm5leHQoKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIk51bGxMaXRlcmFsVHlwZUFubm90YXRpb25cIik7XG4gICAgICBjYXNlIDc4OlxuICAgICAgICB0aGlzLm5leHQoKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIlRoaXNUeXBlQW5ub3RhdGlvblwiKTtcbiAgICAgIGNhc2UgNTU6XG4gICAgICAgIHRoaXMubmV4dCgpO1xuICAgICAgICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiRXhpc3RzVHlwZUFubm90YXRpb25cIik7XG4gICAgICBjYXNlIDg3OlxuICAgICAgICByZXR1cm4gdGhpcy5mbG93UGFyc2VUeXBlb2ZUeXBlKCk7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICBpZiAodG9rZW5Jc0tleXdvcmQodGhpcy5zdGF0ZS50eXBlKSkge1xuICAgICAgICAgIGNvbnN0IGxhYmVsID0gdG9rZW5MYWJlbE5hbWUodGhpcy5zdGF0ZS50eXBlKTtcbiAgICAgICAgICB0aGlzLm5leHQoKTtcbiAgICAgICAgICByZXR1cm4gc3VwZXIuY3JlYXRlSWRlbnRpZmllcihub2RlLCBsYWJlbCk7XG4gICAgICAgIH0gZWxzZSBpZiAodG9rZW5Jc0lkZW50aWZpZXIodGhpcy5zdGF0ZS50eXBlKSkge1xuICAgICAgICAgIGlmICh0aGlzLmlzQ29udGV4dHVhbCgxMjkpKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5mbG93UGFyc2VJbnRlcmZhY2VUeXBlKCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiB0aGlzLmZsb3dJZGVudFRvVHlwZUFubm90YXRpb24oc3RhcnRMb2MsIG5vZGUsIHRoaXMucGFyc2VJZGVudGlmaWVyKCkpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHRocm93IHRoaXMudW5leHBlY3RlZCgpO1xuICB9XG4gIGZsb3dQYXJzZVBvc3RmaXhUeXBlKCkge1xuICAgIGNvbnN0IHN0YXJ0TG9jID0gdGhpcy5zdGF0ZS5zdGFydExvYztcbiAgICBsZXQgdHlwZSA9IHRoaXMuZmxvd1BhcnNlUHJpbWFyeVR5cGUoKTtcbiAgICBsZXQgc2Vlbk9wdGlvbmFsSW5kZXhlZEFjY2VzcyA9IGZhbHNlO1xuICAgIHdoaWxlICgodGhpcy5tYXRjaCgwKSB8fCB0aGlzLm1hdGNoKDE4KSkgJiYgIXRoaXMuY2FuSW5zZXJ0U2VtaWNvbG9uKCkpIHtcbiAgICAgIGNvbnN0IG5vZGUgPSB0aGlzLnN0YXJ0Tm9kZUF0KHN0YXJ0TG9jKTtcbiAgICAgIGNvbnN0IG9wdGlvbmFsID0gdGhpcy5lYXQoMTgpO1xuICAgICAgc2Vlbk9wdGlvbmFsSW5kZXhlZEFjY2VzcyA9IHNlZW5PcHRpb25hbEluZGV4ZWRBY2Nlc3MgfHwgb3B0aW9uYWw7XG4gICAgICB0aGlzLmV4cGVjdCgwKTtcbiAgICAgIGlmICghb3B0aW9uYWwgJiYgdGhpcy5tYXRjaCgzKSkge1xuICAgICAgICBub2RlLmVsZW1lbnRUeXBlID0gdHlwZTtcbiAgICAgICAgdGhpcy5uZXh0KCk7XG4gICAgICAgIHR5cGUgPSB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJBcnJheVR5cGVBbm5vdGF0aW9uXCIpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbm9kZS5vYmplY3RUeXBlID0gdHlwZTtcbiAgICAgICAgbm9kZS5pbmRleFR5cGUgPSB0aGlzLmZsb3dQYXJzZVR5cGUoKTtcbiAgICAgICAgdGhpcy5leHBlY3QoMyk7XG4gICAgICAgIGlmIChzZWVuT3B0aW9uYWxJbmRleGVkQWNjZXNzKSB7XG4gICAgICAgICAgbm9kZS5vcHRpb25hbCA9IG9wdGlvbmFsO1xuICAgICAgICAgIHR5cGUgPSB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJPcHRpb25hbEluZGV4ZWRBY2Nlc3NUeXBlXCIpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHR5cGUgPSB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJJbmRleGVkQWNjZXNzVHlwZVwiKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdHlwZTtcbiAgfVxuICBmbG93UGFyc2VQcmVmaXhUeXBlKCkge1xuICAgIGNvbnN0IG5vZGUgPSB0aGlzLnN0YXJ0Tm9kZSgpO1xuICAgIGlmICh0aGlzLmVhdCgxNykpIHtcbiAgICAgIG5vZGUudHlwZUFubm90YXRpb24gPSB0aGlzLmZsb3dQYXJzZVByZWZpeFR5cGUoKTtcbiAgICAgIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJOdWxsYWJsZVR5cGVBbm5vdGF0aW9uXCIpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gdGhpcy5mbG93UGFyc2VQb3N0Zml4VHlwZSgpO1xuICAgIH1cbiAgfVxuICBmbG93UGFyc2VBbm9uRnVuY3Rpb25XaXRob3V0UGFyZW5zKCkge1xuICAgIGNvbnN0IHBhcmFtID0gdGhpcy5mbG93UGFyc2VQcmVmaXhUeXBlKCk7XG4gICAgaWYgKCF0aGlzLnN0YXRlLm5vQW5vbkZ1bmN0aW9uVHlwZSAmJiB0aGlzLmVhdCgxOSkpIHtcbiAgICAgIGNvbnN0IG5vZGUgPSB0aGlzLnN0YXJ0Tm9kZUF0KHBhcmFtLmxvYy5zdGFydCk7XG4gICAgICBub2RlLnBhcmFtcyA9IFt0aGlzLnJlaW50ZXJwcmV0VHlwZUFzRnVuY3Rpb25UeXBlUGFyYW0ocGFyYW0pXTtcbiAgICAgIG5vZGUucmVzdCA9IG51bGw7XG4gICAgICBub2RlLnRoaXMgPSBudWxsO1xuICAgICAgbm9kZS5yZXR1cm5UeXBlID0gdGhpcy5mbG93UGFyc2VUeXBlKCk7XG4gICAgICBub2RlLnR5cGVQYXJhbWV0ZXJzID0gbnVsbDtcbiAgICAgIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJGdW5jdGlvblR5cGVBbm5vdGF0aW9uXCIpO1xuICAgIH1cbiAgICByZXR1cm4gcGFyYW07XG4gIH1cbiAgZmxvd1BhcnNlSW50ZXJzZWN0aW9uVHlwZSgpIHtcbiAgICBjb25zdCBub2RlID0gdGhpcy5zdGFydE5vZGUoKTtcbiAgICB0aGlzLmVhdCg0NSk7XG4gICAgY29uc3QgdHlwZSA9IHRoaXMuZmxvd1BhcnNlQW5vbkZ1bmN0aW9uV2l0aG91dFBhcmVucygpO1xuICAgIG5vZGUudHlwZXMgPSBbdHlwZV07XG4gICAgd2hpbGUgKHRoaXMuZWF0KDQ1KSkge1xuICAgICAgbm9kZS50eXBlcy5wdXNoKHRoaXMuZmxvd1BhcnNlQW5vbkZ1bmN0aW9uV2l0aG91dFBhcmVucygpKTtcbiAgICB9XG4gICAgcmV0dXJuIG5vZGUudHlwZXMubGVuZ3RoID09PSAxID8gdHlwZSA6IHRoaXMuZmluaXNoTm9kZShub2RlLCBcIkludGVyc2VjdGlvblR5cGVBbm5vdGF0aW9uXCIpO1xuICB9XG4gIGZsb3dQYXJzZVVuaW9uVHlwZSgpIHtcbiAgICBjb25zdCBub2RlID0gdGhpcy5zdGFydE5vZGUoKTtcbiAgICB0aGlzLmVhdCg0Myk7XG4gICAgY29uc3QgdHlwZSA9IHRoaXMuZmxvd1BhcnNlSW50ZXJzZWN0aW9uVHlwZSgpO1xuICAgIG5vZGUudHlwZXMgPSBbdHlwZV07XG4gICAgd2hpbGUgKHRoaXMuZWF0KDQzKSkge1xuICAgICAgbm9kZS50eXBlcy5wdXNoKHRoaXMuZmxvd1BhcnNlSW50ZXJzZWN0aW9uVHlwZSgpKTtcbiAgICB9XG4gICAgcmV0dXJuIG5vZGUudHlwZXMubGVuZ3RoID09PSAxID8gdHlwZSA6IHRoaXMuZmluaXNoTm9kZShub2RlLCBcIlVuaW9uVHlwZUFubm90YXRpb25cIik7XG4gIH1cbiAgZmxvd1BhcnNlVHlwZSgpIHtcbiAgICBjb25zdCBvbGRJblR5cGUgPSB0aGlzLnN0YXRlLmluVHlwZTtcbiAgICB0aGlzLnN0YXRlLmluVHlwZSA9IHRydWU7XG4gICAgY29uc3QgdHlwZSA9IHRoaXMuZmxvd1BhcnNlVW5pb25UeXBlKCk7XG4gICAgdGhpcy5zdGF0ZS5pblR5cGUgPSBvbGRJblR5cGU7XG4gICAgcmV0dXJuIHR5cGU7XG4gIH1cbiAgZmxvd1BhcnNlVHlwZU9ySW1wbGljaXRJbnN0YW50aWF0aW9uKCkge1xuICAgIGlmICh0aGlzLnN0YXRlLnR5cGUgPT09IDEzMiAmJiB0aGlzLnN0YXRlLnZhbHVlID09PSBcIl9cIikge1xuICAgICAgY29uc3Qgc3RhcnRMb2MgPSB0aGlzLnN0YXRlLnN0YXJ0TG9jO1xuICAgICAgY29uc3Qgbm9kZSA9IHRoaXMucGFyc2VJZGVudGlmaWVyKCk7XG4gICAgICByZXR1cm4gdGhpcy5mbG93UGFyc2VHZW5lcmljVHlwZShzdGFydExvYywgbm9kZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiB0aGlzLmZsb3dQYXJzZVR5cGUoKTtcbiAgICB9XG4gIH1cbiAgZmxvd1BhcnNlVHlwZUFubm90YXRpb24oKSB7XG4gICAgY29uc3Qgbm9kZSA9IHRoaXMuc3RhcnROb2RlKCk7XG4gICAgbm9kZS50eXBlQW5ub3RhdGlvbiA9IHRoaXMuZmxvd1BhcnNlVHlwZUluaXRpYWxpc2VyKCk7XG4gICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIlR5cGVBbm5vdGF0aW9uXCIpO1xuICB9XG4gIGZsb3dQYXJzZVR5cGVBbm5vdGF0YWJsZUlkZW50aWZpZXIoYWxsb3dQcmltaXRpdmVPdmVycmlkZSkge1xuICAgIGNvbnN0IGlkZW50ID0gYWxsb3dQcmltaXRpdmVPdmVycmlkZSA/IHRoaXMucGFyc2VJZGVudGlmaWVyKCkgOiB0aGlzLmZsb3dQYXJzZVJlc3RyaWN0ZWRJZGVudGlmaWVyKCk7XG4gICAgaWYgKHRoaXMubWF0Y2goMTQpKSB7XG4gICAgICBpZGVudC50eXBlQW5ub3RhdGlvbiA9IHRoaXMuZmxvd1BhcnNlVHlwZUFubm90YXRpb24oKTtcbiAgICAgIHRoaXMucmVzZXRFbmRMb2NhdGlvbihpZGVudCk7XG4gICAgfVxuICAgIHJldHVybiBpZGVudDtcbiAgfVxuICB0eXBlQ2FzdFRvUGFyYW1ldGVyKG5vZGUpIHtcbiAgICBub2RlLmV4cHJlc3Npb24udHlwZUFubm90YXRpb24gPSBub2RlLnR5cGVBbm5vdGF0aW9uO1xuICAgIHRoaXMucmVzZXRFbmRMb2NhdGlvbihub2RlLmV4cHJlc3Npb24sIG5vZGUudHlwZUFubm90YXRpb24ubG9jLmVuZCk7XG4gICAgcmV0dXJuIG5vZGUuZXhwcmVzc2lvbjtcbiAgfVxuICBmbG93UGFyc2VWYXJpYW5jZSgpIHtcbiAgICBsZXQgdmFyaWFuY2UgPSBudWxsO1xuICAgIGlmICh0aGlzLm1hdGNoKDUzKSkge1xuICAgICAgdmFyaWFuY2UgPSB0aGlzLnN0YXJ0Tm9kZSgpO1xuICAgICAgaWYgKHRoaXMuc3RhdGUudmFsdWUgPT09IFwiK1wiKSB7XG4gICAgICAgIHZhcmlhbmNlLmtpbmQgPSBcInBsdXNcIjtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhcmlhbmNlLmtpbmQgPSBcIm1pbnVzXCI7XG4gICAgICB9XG4gICAgICB0aGlzLm5leHQoKTtcbiAgICAgIHJldHVybiB0aGlzLmZpbmlzaE5vZGUodmFyaWFuY2UsIFwiVmFyaWFuY2VcIik7XG4gICAgfVxuICAgIHJldHVybiB2YXJpYW5jZTtcbiAgfVxuICBwYXJzZUZ1bmN0aW9uQm9keShub2RlLCBhbGxvd0V4cHJlc3Npb25Cb2R5LCBpc01ldGhvZCA9IGZhbHNlKSB7XG4gICAgaWYgKGFsbG93RXhwcmVzc2lvbkJvZHkpIHtcbiAgICAgIHRoaXMuZm9yd2FyZE5vQXJyb3dQYXJhbXNDb252ZXJzaW9uQXQobm9kZSwgKCkgPT4gc3VwZXIucGFyc2VGdW5jdGlvbkJvZHkobm9kZSwgdHJ1ZSwgaXNNZXRob2QpKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgc3VwZXIucGFyc2VGdW5jdGlvbkJvZHkobm9kZSwgZmFsc2UsIGlzTWV0aG9kKTtcbiAgfVxuICBwYXJzZUZ1bmN0aW9uQm9keUFuZEZpbmlzaChub2RlLCB0eXBlLCBpc01ldGhvZCA9IGZhbHNlKSB7XG4gICAgaWYgKHRoaXMubWF0Y2goMTQpKSB7XG4gICAgICBjb25zdCB0eXBlTm9kZSA9IHRoaXMuc3RhcnROb2RlKCk7XG4gICAgICBbdHlwZU5vZGUudHlwZUFubm90YXRpb24sIG5vZGUucHJlZGljYXRlXSA9IHRoaXMuZmxvd1BhcnNlVHlwZUFuZFByZWRpY2F0ZUluaXRpYWxpc2VyKCk7XG4gICAgICBub2RlLnJldHVyblR5cGUgPSB0eXBlTm9kZS50eXBlQW5ub3RhdGlvbiA/IHRoaXMuZmluaXNoTm9kZSh0eXBlTm9kZSwgXCJUeXBlQW5ub3RhdGlvblwiKSA6IG51bGw7XG4gICAgfVxuICAgIHJldHVybiBzdXBlci5wYXJzZUZ1bmN0aW9uQm9keUFuZEZpbmlzaChub2RlLCB0eXBlLCBpc01ldGhvZCk7XG4gIH1cbiAgcGFyc2VTdGF0ZW1lbnRMaWtlKGZsYWdzKSB7XG4gICAgaWYgKHRoaXMuc3RhdGUuc3RyaWN0ICYmIHRoaXMuaXNDb250ZXh0dWFsKDEyOSkpIHtcbiAgICAgIGNvbnN0IGxvb2thaGVhZCA9IHRoaXMubG9va2FoZWFkKCk7XG4gICAgICBpZiAodG9rZW5Jc0tleXdvcmRPcklkZW50aWZpZXIobG9va2FoZWFkLnR5cGUpKSB7XG4gICAgICAgIGNvbnN0IG5vZGUgPSB0aGlzLnN0YXJ0Tm9kZSgpO1xuICAgICAgICB0aGlzLm5leHQoKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuZmxvd1BhcnNlSW50ZXJmYWNlKG5vZGUpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAodGhpcy5pc0NvbnRleHR1YWwoMTI2KSkge1xuICAgICAgY29uc3Qgbm9kZSA9IHRoaXMuc3RhcnROb2RlKCk7XG4gICAgICB0aGlzLm5leHQoKTtcbiAgICAgIHJldHVybiB0aGlzLmZsb3dQYXJzZUVudW1EZWNsYXJhdGlvbihub2RlKTtcbiAgICB9XG4gICAgY29uc3Qgc3RtdCA9IHN1cGVyLnBhcnNlU3RhdGVtZW50TGlrZShmbGFncyk7XG4gICAgaWYgKHRoaXMuZmxvd1ByYWdtYSA9PT0gdW5kZWZpbmVkICYmICF0aGlzLmlzVmFsaWREaXJlY3RpdmUoc3RtdCkpIHtcbiAgICAgIHRoaXMuZmxvd1ByYWdtYSA9IG51bGw7XG4gICAgfVxuICAgIHJldHVybiBzdG10O1xuICB9XG4gIHBhcnNlRXhwcmVzc2lvblN0YXRlbWVudChub2RlLCBleHByLCBkZWNvcmF0b3JzKSB7XG4gICAgaWYgKGV4cHIudHlwZSA9PT0gXCJJZGVudGlmaWVyXCIpIHtcbiAgICAgIGlmIChleHByLm5hbWUgPT09IFwiZGVjbGFyZVwiKSB7XG4gICAgICAgIGlmICh0aGlzLm1hdGNoKDgwKSB8fCB0b2tlbklzSWRlbnRpZmllcih0aGlzLnN0YXRlLnR5cGUpIHx8IHRoaXMubWF0Y2goNjgpIHx8IHRoaXMubWF0Y2goNzQpIHx8IHRoaXMubWF0Y2goODIpKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuZmxvd1BhcnNlRGVjbGFyZShub2RlKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmICh0b2tlbklzSWRlbnRpZmllcih0aGlzLnN0YXRlLnR5cGUpKSB7XG4gICAgICAgIGlmIChleHByLm5hbWUgPT09IFwiaW50ZXJmYWNlXCIpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5mbG93UGFyc2VJbnRlcmZhY2Uobm9kZSk7XG4gICAgICAgIH0gZWxzZSBpZiAoZXhwci5uYW1lID09PSBcInR5cGVcIikge1xuICAgICAgICAgIHJldHVybiB0aGlzLmZsb3dQYXJzZVR5cGVBbGlhcyhub2RlKTtcbiAgICAgICAgfSBlbHNlIGlmIChleHByLm5hbWUgPT09IFwib3BhcXVlXCIpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5mbG93UGFyc2VPcGFxdWVUeXBlKG5vZGUsIGZhbHNlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gc3VwZXIucGFyc2VFeHByZXNzaW9uU3RhdGVtZW50KG5vZGUsIGV4cHIsIGRlY29yYXRvcnMpO1xuICB9XG4gIHNob3VsZFBhcnNlRXhwb3J0RGVjbGFyYXRpb24oKSB7XG4gICAgY29uc3Qge1xuICAgICAgdHlwZVxuICAgIH0gPSB0aGlzLnN0YXRlO1xuICAgIGlmICh0eXBlID09PSAxMjYgfHwgdG9rZW5Jc0Zsb3dJbnRlcmZhY2VPclR5cGVPck9wYXF1ZSh0eXBlKSkge1xuICAgICAgcmV0dXJuICF0aGlzLnN0YXRlLmNvbnRhaW5zRXNjO1xuICAgIH1cbiAgICByZXR1cm4gc3VwZXIuc2hvdWxkUGFyc2VFeHBvcnREZWNsYXJhdGlvbigpO1xuICB9XG4gIGlzRXhwb3J0RGVmYXVsdFNwZWNpZmllcigpIHtcbiAgICBjb25zdCB7XG4gICAgICB0eXBlXG4gICAgfSA9IHRoaXMuc3RhdGU7XG4gICAgaWYgKHR5cGUgPT09IDEyNiB8fCB0b2tlbklzRmxvd0ludGVyZmFjZU9yVHlwZU9yT3BhcXVlKHR5cGUpKSB7XG4gICAgICByZXR1cm4gdGhpcy5zdGF0ZS5jb250YWluc0VzYztcbiAgICB9XG4gICAgcmV0dXJuIHN1cGVyLmlzRXhwb3J0RGVmYXVsdFNwZWNpZmllcigpO1xuICB9XG4gIHBhcnNlRXhwb3J0RGVmYXVsdEV4cHJlc3Npb24oKSB7XG4gICAgaWYgKHRoaXMuaXNDb250ZXh0dWFsKDEyNikpIHtcbiAgICAgIGNvbnN0IG5vZGUgPSB0aGlzLnN0YXJ0Tm9kZSgpO1xuICAgICAgdGhpcy5uZXh0KCk7XG4gICAgICByZXR1cm4gdGhpcy5mbG93UGFyc2VFbnVtRGVjbGFyYXRpb24obm9kZSk7XG4gICAgfVxuICAgIHJldHVybiBzdXBlci5wYXJzZUV4cG9ydERlZmF1bHRFeHByZXNzaW9uKCk7XG4gIH1cbiAgcGFyc2VDb25kaXRpb25hbChleHByLCBzdGFydExvYywgcmVmRXhwcmVzc2lvbkVycm9ycykge1xuICAgIGlmICghdGhpcy5tYXRjaCgxNykpIHJldHVybiBleHByO1xuICAgIGlmICh0aGlzLnN0YXRlLm1heWJlSW5BcnJvd1BhcmFtZXRlcnMpIHtcbiAgICAgIGNvbnN0IG5leHRDaCA9IHRoaXMubG9va2FoZWFkQ2hhckNvZGUoKTtcbiAgICAgIGlmIChuZXh0Q2ggPT09IDQ0IHx8IG5leHRDaCA9PT0gNjEgfHwgbmV4dENoID09PSA1OCB8fCBuZXh0Q2ggPT09IDQxKSB7XG4gICAgICAgIHRoaXMuc2V0T3B0aW9uYWxQYXJhbWV0ZXJzRXJyb3IocmVmRXhwcmVzc2lvbkVycm9ycyk7XG4gICAgICAgIHJldHVybiBleHByO1xuICAgICAgfVxuICAgIH1cbiAgICB0aGlzLmV4cGVjdCgxNyk7XG4gICAgY29uc3Qgc3RhdGUgPSB0aGlzLnN0YXRlLmNsb25lKCk7XG4gICAgY29uc3Qgb3JpZ2luYWxOb0Fycm93QXQgPSB0aGlzLnN0YXRlLm5vQXJyb3dBdDtcbiAgICBjb25zdCBub2RlID0gdGhpcy5zdGFydE5vZGVBdChzdGFydExvYyk7XG4gICAgbGV0IHtcbiAgICAgIGNvbnNlcXVlbnQsXG4gICAgICBmYWlsZWRcbiAgICB9ID0gdGhpcy50cnlQYXJzZUNvbmRpdGlvbmFsQ29uc2VxdWVudCgpO1xuICAgIGxldCBbdmFsaWQsIGludmFsaWRdID0gdGhpcy5nZXRBcnJvd0xpa2VFeHByZXNzaW9ucyhjb25zZXF1ZW50KTtcbiAgICBpZiAoZmFpbGVkIHx8IGludmFsaWQubGVuZ3RoID4gMCkge1xuICAgICAgY29uc3Qgbm9BcnJvd0F0ID0gWy4uLm9yaWdpbmFsTm9BcnJvd0F0XTtcbiAgICAgIGlmIChpbnZhbGlkLmxlbmd0aCA+IDApIHtcbiAgICAgICAgdGhpcy5zdGF0ZSA9IHN0YXRlO1xuICAgICAgICB0aGlzLnN0YXRlLm5vQXJyb3dBdCA9IG5vQXJyb3dBdDtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBpbnZhbGlkLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgbm9BcnJvd0F0LnB1c2goaW52YWxpZFtpXS5zdGFydCk7XG4gICAgICAgIH1cbiAgICAgICAgKHtcbiAgICAgICAgICBjb25zZXF1ZW50LFxuICAgICAgICAgIGZhaWxlZFxuICAgICAgICB9ID0gdGhpcy50cnlQYXJzZUNvbmRpdGlvbmFsQ29uc2VxdWVudCgpKTtcbiAgICAgICAgW3ZhbGlkLCBpbnZhbGlkXSA9IHRoaXMuZ2V0QXJyb3dMaWtlRXhwcmVzc2lvbnMoY29uc2VxdWVudCk7XG4gICAgICB9XG4gICAgICBpZiAoZmFpbGVkICYmIHZhbGlkLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgdGhpcy5yYWlzZShGbG93RXJyb3JzLkFtYmlndW91c0NvbmRpdGlvbmFsQXJyb3csIHN0YXRlLnN0YXJ0TG9jKTtcbiAgICAgIH1cbiAgICAgIGlmIChmYWlsZWQgJiYgdmFsaWQubGVuZ3RoID09PSAxKSB7XG4gICAgICAgIHRoaXMuc3RhdGUgPSBzdGF0ZTtcbiAgICAgICAgbm9BcnJvd0F0LnB1c2godmFsaWRbMF0uc3RhcnQpO1xuICAgICAgICB0aGlzLnN0YXRlLm5vQXJyb3dBdCA9IG5vQXJyb3dBdDtcbiAgICAgICAgKHtcbiAgICAgICAgICBjb25zZXF1ZW50LFxuICAgICAgICAgIGZhaWxlZFxuICAgICAgICB9ID0gdGhpcy50cnlQYXJzZUNvbmRpdGlvbmFsQ29uc2VxdWVudCgpKTtcbiAgICAgIH1cbiAgICB9XG4gICAgdGhpcy5nZXRBcnJvd0xpa2VFeHByZXNzaW9ucyhjb25zZXF1ZW50LCB0cnVlKTtcbiAgICB0aGlzLnN0YXRlLm5vQXJyb3dBdCA9IG9yaWdpbmFsTm9BcnJvd0F0O1xuICAgIHRoaXMuZXhwZWN0KDE0KTtcbiAgICBub2RlLnRlc3QgPSBleHByO1xuICAgIG5vZGUuY29uc2VxdWVudCA9IGNvbnNlcXVlbnQ7XG4gICAgbm9kZS5hbHRlcm5hdGUgPSB0aGlzLmZvcndhcmROb0Fycm93UGFyYW1zQ29udmVyc2lvbkF0KG5vZGUsICgpID0+IHRoaXMucGFyc2VNYXliZUFzc2lnbih1bmRlZmluZWQsIHVuZGVmaW5lZCkpO1xuICAgIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJDb25kaXRpb25hbEV4cHJlc3Npb25cIik7XG4gIH1cbiAgdHJ5UGFyc2VDb25kaXRpb25hbENvbnNlcXVlbnQoKSB7XG4gICAgdGhpcy5zdGF0ZS5ub0Fycm93UGFyYW1zQ29udmVyc2lvbkF0LnB1c2godGhpcy5zdGF0ZS5zdGFydCk7XG4gICAgY29uc3QgY29uc2VxdWVudCA9IHRoaXMucGFyc2VNYXliZUFzc2lnbkFsbG93SW4oKTtcbiAgICBjb25zdCBmYWlsZWQgPSAhdGhpcy5tYXRjaCgxNCk7XG4gICAgdGhpcy5zdGF0ZS5ub0Fycm93UGFyYW1zQ29udmVyc2lvbkF0LnBvcCgpO1xuICAgIHJldHVybiB7XG4gICAgICBjb25zZXF1ZW50LFxuICAgICAgZmFpbGVkXG4gICAgfTtcbiAgfVxuICBnZXRBcnJvd0xpa2VFeHByZXNzaW9ucyhub2RlLCBkaXNhbGxvd0ludmFsaWQpIHtcbiAgICBjb25zdCBzdGFjayA9IFtub2RlXTtcbiAgICBjb25zdCBhcnJvd3MgPSBbXTtcbiAgICB3aGlsZSAoc3RhY2subGVuZ3RoICE9PSAwKSB7XG4gICAgICBjb25zdCBub2RlID0gc3RhY2sucG9wKCk7XG4gICAgICBpZiAobm9kZS50eXBlID09PSBcIkFycm93RnVuY3Rpb25FeHByZXNzaW9uXCIgJiYgbm9kZS5ib2R5LnR5cGUgIT09IFwiQmxvY2tTdGF0ZW1lbnRcIikge1xuICAgICAgICBpZiAobm9kZS50eXBlUGFyYW1ldGVycyB8fCAhbm9kZS5yZXR1cm5UeXBlKSB7XG4gICAgICAgICAgdGhpcy5maW5pc2hBcnJvd1ZhbGlkYXRpb24obm9kZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgYXJyb3dzLnB1c2gobm9kZSk7XG4gICAgICAgIH1cbiAgICAgICAgc3RhY2sucHVzaChub2RlLmJvZHkpO1xuICAgICAgfSBlbHNlIGlmIChub2RlLnR5cGUgPT09IFwiQ29uZGl0aW9uYWxFeHByZXNzaW9uXCIpIHtcbiAgICAgICAgc3RhY2sucHVzaChub2RlLmNvbnNlcXVlbnQpO1xuICAgICAgICBzdGFjay5wdXNoKG5vZGUuYWx0ZXJuYXRlKTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGRpc2FsbG93SW52YWxpZCkge1xuICAgICAgYXJyb3dzLmZvckVhY2gobm9kZSA9PiB0aGlzLmZpbmlzaEFycm93VmFsaWRhdGlvbihub2RlKSk7XG4gICAgICByZXR1cm4gW2Fycm93cywgW11dO1xuICAgIH1cbiAgICByZXR1cm4gcGFydGl0aW9uKGFycm93cywgbm9kZSA9PiBub2RlLnBhcmFtcy5ldmVyeShwYXJhbSA9PiB0aGlzLmlzQXNzaWduYWJsZShwYXJhbSwgdHJ1ZSkpKTtcbiAgfVxuICBmaW5pc2hBcnJvd1ZhbGlkYXRpb24obm9kZSkge1xuICAgIHZhciBfbm9kZSRleHRyYTtcbiAgICB0aGlzLnRvQXNzaWduYWJsZUxpc3Qobm9kZS5wYXJhbXMsIChfbm9kZSRleHRyYSA9IG5vZGUuZXh0cmEpID09IG51bGwgPyB2b2lkIDAgOiBfbm9kZSRleHRyYS50cmFpbGluZ0NvbW1hTG9jLCBmYWxzZSk7XG4gICAgdGhpcy5zY29wZS5lbnRlcig1MTQgfCA0KTtcbiAgICBzdXBlci5jaGVja1BhcmFtcyhub2RlLCBmYWxzZSwgdHJ1ZSk7XG4gICAgdGhpcy5zY29wZS5leGl0KCk7XG4gIH1cbiAgZm9yd2FyZE5vQXJyb3dQYXJhbXNDb252ZXJzaW9uQXQobm9kZSwgcGFyc2UpIHtcbiAgICBsZXQgcmVzdWx0O1xuICAgIGlmICh0aGlzLnN0YXRlLm5vQXJyb3dQYXJhbXNDb252ZXJzaW9uQXQuaW5jbHVkZXModGhpcy5vZmZzZXRUb1NvdXJjZVBvcyhub2RlLnN0YXJ0KSkpIHtcbiAgICAgIHRoaXMuc3RhdGUubm9BcnJvd1BhcmFtc0NvbnZlcnNpb25BdC5wdXNoKHRoaXMuc3RhdGUuc3RhcnQpO1xuICAgICAgcmVzdWx0ID0gcGFyc2UoKTtcbiAgICAgIHRoaXMuc3RhdGUubm9BcnJvd1BhcmFtc0NvbnZlcnNpb25BdC5wb3AoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmVzdWx0ID0gcGFyc2UoKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuICBwYXJzZVBhcmVuSXRlbShub2RlLCBzdGFydExvYykge1xuICAgIGNvbnN0IG5ld05vZGUgPSBzdXBlci5wYXJzZVBhcmVuSXRlbShub2RlLCBzdGFydExvYyk7XG4gICAgaWYgKHRoaXMuZWF0KDE3KSkge1xuICAgICAgbmV3Tm9kZS5vcHRpb25hbCA9IHRydWU7XG4gICAgICB0aGlzLnJlc2V0RW5kTG9jYXRpb24obm9kZSk7XG4gICAgfVxuICAgIGlmICh0aGlzLm1hdGNoKDE0KSkge1xuICAgICAgY29uc3QgdHlwZUNhc3ROb2RlID0gdGhpcy5zdGFydE5vZGVBdChzdGFydExvYyk7XG4gICAgICB0eXBlQ2FzdE5vZGUuZXhwcmVzc2lvbiA9IG5ld05vZGU7XG4gICAgICB0eXBlQ2FzdE5vZGUudHlwZUFubm90YXRpb24gPSB0aGlzLmZsb3dQYXJzZVR5cGVBbm5vdGF0aW9uKCk7XG4gICAgICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKHR5cGVDYXN0Tm9kZSwgXCJUeXBlQ2FzdEV4cHJlc3Npb25cIik7XG4gICAgfVxuICAgIHJldHVybiBuZXdOb2RlO1xuICB9XG4gIGFzc2VydE1vZHVsZU5vZGVBbGxvd2VkKG5vZGUpIHtcbiAgICBpZiAobm9kZS50eXBlID09PSBcIkltcG9ydERlY2xhcmF0aW9uXCIgJiYgKG5vZGUuaW1wb3J0S2luZCA9PT0gXCJ0eXBlXCIgfHwgbm9kZS5pbXBvcnRLaW5kID09PSBcInR5cGVvZlwiKSB8fCBub2RlLnR5cGUgPT09IFwiRXhwb3J0TmFtZWREZWNsYXJhdGlvblwiICYmIG5vZGUuZXhwb3J0S2luZCA9PT0gXCJ0eXBlXCIgfHwgbm9kZS50eXBlID09PSBcIkV4cG9ydEFsbERlY2xhcmF0aW9uXCIgJiYgbm9kZS5leHBvcnRLaW5kID09PSBcInR5cGVcIikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBzdXBlci5hc3NlcnRNb2R1bGVOb2RlQWxsb3dlZChub2RlKTtcbiAgfVxuICBwYXJzZUV4cG9ydERlY2xhcmF0aW9uKG5vZGUpIHtcbiAgICBpZiAodGhpcy5pc0NvbnRleHR1YWwoMTMwKSkge1xuICAgICAgbm9kZS5leHBvcnRLaW5kID0gXCJ0eXBlXCI7XG4gICAgICBjb25zdCBkZWNsYXJhdGlvbk5vZGUgPSB0aGlzLnN0YXJ0Tm9kZSgpO1xuICAgICAgdGhpcy5uZXh0KCk7XG4gICAgICBpZiAodGhpcy5tYXRjaCg1KSkge1xuICAgICAgICBub2RlLnNwZWNpZmllcnMgPSB0aGlzLnBhcnNlRXhwb3J0U3BlY2lmaWVycyh0cnVlKTtcbiAgICAgICAgc3VwZXIucGFyc2VFeHBvcnRGcm9tKG5vZGUpO1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiB0aGlzLmZsb3dQYXJzZVR5cGVBbGlhcyhkZWNsYXJhdGlvbk5vZGUpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAodGhpcy5pc0NvbnRleHR1YWwoMTMxKSkge1xuICAgICAgbm9kZS5leHBvcnRLaW5kID0gXCJ0eXBlXCI7XG4gICAgICBjb25zdCBkZWNsYXJhdGlvbk5vZGUgPSB0aGlzLnN0YXJ0Tm9kZSgpO1xuICAgICAgdGhpcy5uZXh0KCk7XG4gICAgICByZXR1cm4gdGhpcy5mbG93UGFyc2VPcGFxdWVUeXBlKGRlY2xhcmF0aW9uTm9kZSwgZmFsc2UpO1xuICAgIH0gZWxzZSBpZiAodGhpcy5pc0NvbnRleHR1YWwoMTI5KSkge1xuICAgICAgbm9kZS5leHBvcnRLaW5kID0gXCJ0eXBlXCI7XG4gICAgICBjb25zdCBkZWNsYXJhdGlvbk5vZGUgPSB0aGlzLnN0YXJ0Tm9kZSgpO1xuICAgICAgdGhpcy5uZXh0KCk7XG4gICAgICByZXR1cm4gdGhpcy5mbG93UGFyc2VJbnRlcmZhY2UoZGVjbGFyYXRpb25Ob2RlKTtcbiAgICB9IGVsc2UgaWYgKHRoaXMuaXNDb250ZXh0dWFsKDEyNikpIHtcbiAgICAgIG5vZGUuZXhwb3J0S2luZCA9IFwidmFsdWVcIjtcbiAgICAgIGNvbnN0IGRlY2xhcmF0aW9uTm9kZSA9IHRoaXMuc3RhcnROb2RlKCk7XG4gICAgICB0aGlzLm5leHQoKTtcbiAgICAgIHJldHVybiB0aGlzLmZsb3dQYXJzZUVudW1EZWNsYXJhdGlvbihkZWNsYXJhdGlvbk5vZGUpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gc3VwZXIucGFyc2VFeHBvcnREZWNsYXJhdGlvbihub2RlKTtcbiAgICB9XG4gIH1cbiAgZWF0RXhwb3J0U3Rhcihub2RlKSB7XG4gICAgaWYgKHN1cGVyLmVhdEV4cG9ydFN0YXIobm9kZSkpIHJldHVybiB0cnVlO1xuICAgIGlmICh0aGlzLmlzQ29udGV4dHVhbCgxMzApICYmIHRoaXMubG9va2FoZWFkKCkudHlwZSA9PT0gNTUpIHtcbiAgICAgIG5vZGUuZXhwb3J0S2luZCA9IFwidHlwZVwiO1xuICAgICAgdGhpcy5uZXh0KCk7XG4gICAgICB0aGlzLm5leHQoKTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgbWF5YmVQYXJzZUV4cG9ydE5hbWVzcGFjZVNwZWNpZmllcihub2RlKSB7XG4gICAgY29uc3Qge1xuICAgICAgc3RhcnRMb2NcbiAgICB9ID0gdGhpcy5zdGF0ZTtcbiAgICBjb25zdCBoYXNOYW1lc3BhY2UgPSBzdXBlci5tYXliZVBhcnNlRXhwb3J0TmFtZXNwYWNlU3BlY2lmaWVyKG5vZGUpO1xuICAgIGlmIChoYXNOYW1lc3BhY2UgJiYgbm9kZS5leHBvcnRLaW5kID09PSBcInR5cGVcIikge1xuICAgICAgdGhpcy51bmV4cGVjdGVkKHN0YXJ0TG9jKTtcbiAgICB9XG4gICAgcmV0dXJuIGhhc05hbWVzcGFjZTtcbiAgfVxuICBwYXJzZUNsYXNzSWQobm9kZSwgaXNTdGF0ZW1lbnQsIG9wdGlvbmFsSWQpIHtcbiAgICBzdXBlci5wYXJzZUNsYXNzSWQobm9kZSwgaXNTdGF0ZW1lbnQsIG9wdGlvbmFsSWQpO1xuICAgIGlmICh0aGlzLm1hdGNoKDQ3KSkge1xuICAgICAgbm9kZS50eXBlUGFyYW1ldGVycyA9IHRoaXMuZmxvd1BhcnNlVHlwZVBhcmFtZXRlckRlY2xhcmF0aW9uKCk7XG4gICAgfVxuICB9XG4gIHBhcnNlQ2xhc3NNZW1iZXIoY2xhc3NCb2R5LCBtZW1iZXIsIHN0YXRlKSB7XG4gICAgY29uc3Qge1xuICAgICAgc3RhcnRMb2NcbiAgICB9ID0gdGhpcy5zdGF0ZTtcbiAgICBpZiAodGhpcy5pc0NvbnRleHR1YWwoMTI1KSkge1xuICAgICAgaWYgKHN1cGVyLnBhcnNlQ2xhc3NNZW1iZXJGcm9tTW9kaWZpZXIoY2xhc3NCb2R5LCBtZW1iZXIpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIG1lbWJlci5kZWNsYXJlID0gdHJ1ZTtcbiAgICB9XG4gICAgc3VwZXIucGFyc2VDbGFzc01lbWJlcihjbGFzc0JvZHksIG1lbWJlciwgc3RhdGUpO1xuICAgIGlmIChtZW1iZXIuZGVjbGFyZSkge1xuICAgICAgaWYgKG1lbWJlci50eXBlICE9PSBcIkNsYXNzUHJvcGVydHlcIiAmJiBtZW1iZXIudHlwZSAhPT0gXCJDbGFzc1ByaXZhdGVQcm9wZXJ0eVwiICYmIG1lbWJlci50eXBlICE9PSBcIlByb3BlcnR5RGVmaW5pdGlvblwiKSB7XG4gICAgICAgIHRoaXMucmFpc2UoRmxvd0Vycm9ycy5EZWNsYXJlQ2xhc3NFbGVtZW50LCBzdGFydExvYyk7XG4gICAgICB9IGVsc2UgaWYgKG1lbWJlci52YWx1ZSkge1xuICAgICAgICB0aGlzLnJhaXNlKEZsb3dFcnJvcnMuRGVjbGFyZUNsYXNzRmllbGRJbml0aWFsaXplciwgbWVtYmVyLnZhbHVlKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgaXNJdGVyYXRvcih3b3JkKSB7XG4gICAgcmV0dXJuIHdvcmQgPT09IFwiaXRlcmF0b3JcIiB8fCB3b3JkID09PSBcImFzeW5jSXRlcmF0b3JcIjtcbiAgfVxuICByZWFkSXRlcmF0b3IoKSB7XG4gICAgY29uc3Qgd29yZCA9IHN1cGVyLnJlYWRXb3JkMSgpO1xuICAgIGNvbnN0IGZ1bGxXb3JkID0gXCJAQFwiICsgd29yZDtcbiAgICBpZiAoIXRoaXMuaXNJdGVyYXRvcih3b3JkKSB8fCAhdGhpcy5zdGF0ZS5pblR5cGUpIHtcbiAgICAgIHRoaXMucmFpc2UoRXJyb3JzLkludmFsaWRJZGVudGlmaWVyLCB0aGlzLnN0YXRlLmN1clBvc2l0aW9uKCksIHtcbiAgICAgICAgaWRlbnRpZmllck5hbWU6IGZ1bGxXb3JkXG4gICAgICB9KTtcbiAgICB9XG4gICAgdGhpcy5maW5pc2hUb2tlbigxMzIsIGZ1bGxXb3JkKTtcbiAgfVxuICBnZXRUb2tlbkZyb21Db2RlKGNvZGUpIHtcbiAgICBjb25zdCBuZXh0ID0gdGhpcy5pbnB1dC5jaGFyQ29kZUF0KHRoaXMuc3RhdGUucG9zICsgMSk7XG4gICAgaWYgKGNvZGUgPT09IDEyMyAmJiBuZXh0ID09PSAxMjQpIHtcbiAgICAgIHRoaXMuZmluaXNoT3AoNiwgMik7XG4gICAgfSBlbHNlIGlmICh0aGlzLnN0YXRlLmluVHlwZSAmJiAoY29kZSA9PT0gNjIgfHwgY29kZSA9PT0gNjApKSB7XG4gICAgICB0aGlzLmZpbmlzaE9wKGNvZGUgPT09IDYyID8gNDggOiA0NywgMSk7XG4gICAgfSBlbHNlIGlmICh0aGlzLnN0YXRlLmluVHlwZSAmJiBjb2RlID09PSA2Mykge1xuICAgICAgaWYgKG5leHQgPT09IDQ2KSB7XG4gICAgICAgIHRoaXMuZmluaXNoT3AoMTgsIDIpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5maW5pc2hPcCgxNywgMSk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChpc0l0ZXJhdG9yU3RhcnQoY29kZSwgbmV4dCwgdGhpcy5pbnB1dC5jaGFyQ29kZUF0KHRoaXMuc3RhdGUucG9zICsgMikpKSB7XG4gICAgICB0aGlzLnN0YXRlLnBvcyArPSAyO1xuICAgICAgdGhpcy5yZWFkSXRlcmF0b3IoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgc3VwZXIuZ2V0VG9rZW5Gcm9tQ29kZShjb2RlKTtcbiAgICB9XG4gIH1cbiAgaXNBc3NpZ25hYmxlKG5vZGUsIGlzQmluZGluZykge1xuICAgIGlmIChub2RlLnR5cGUgPT09IFwiVHlwZUNhc3RFeHByZXNzaW9uXCIpIHtcbiAgICAgIHJldHVybiB0aGlzLmlzQXNzaWduYWJsZShub2RlLmV4cHJlc3Npb24sIGlzQmluZGluZyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBzdXBlci5pc0Fzc2lnbmFibGUobm9kZSwgaXNCaW5kaW5nKTtcbiAgICB9XG4gIH1cbiAgdG9Bc3NpZ25hYmxlKG5vZGUsIGlzTEhTID0gZmFsc2UpIHtcbiAgICBpZiAoIWlzTEhTICYmIG5vZGUudHlwZSA9PT0gXCJBc3NpZ25tZW50RXhwcmVzc2lvblwiICYmIG5vZGUubGVmdC50eXBlID09PSBcIlR5cGVDYXN0RXhwcmVzc2lvblwiKSB7XG4gICAgICBub2RlLmxlZnQgPSB0aGlzLnR5cGVDYXN0VG9QYXJhbWV0ZXIobm9kZS5sZWZ0KTtcbiAgICB9XG4gICAgc3VwZXIudG9Bc3NpZ25hYmxlKG5vZGUsIGlzTEhTKTtcbiAgfVxuICB0b0Fzc2lnbmFibGVMaXN0KGV4cHJMaXN0LCB0cmFpbGluZ0NvbW1hTG9jLCBpc0xIUykge1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZXhwckxpc3QubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvbnN0IGV4cHIgPSBleHByTGlzdFtpXTtcbiAgICAgIGlmICgoZXhwciA9PSBudWxsID8gdm9pZCAwIDogZXhwci50eXBlKSA9PT0gXCJUeXBlQ2FzdEV4cHJlc3Npb25cIikge1xuICAgICAgICBleHByTGlzdFtpXSA9IHRoaXMudHlwZUNhc3RUb1BhcmFtZXRlcihleHByKTtcbiAgICAgIH1cbiAgICB9XG4gICAgc3VwZXIudG9Bc3NpZ25hYmxlTGlzdChleHByTGlzdCwgdHJhaWxpbmdDb21tYUxvYywgaXNMSFMpO1xuICB9XG4gIHRvUmVmZXJlbmNlZExpc3QoZXhwckxpc3QsIGlzUGFyZW50aGVzaXplZEV4cHIpIHtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGV4cHJMaXN0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgX2V4cHIkZXh0cmE7XG4gICAgICBjb25zdCBleHByID0gZXhwckxpc3RbaV07XG4gICAgICBpZiAoZXhwciAmJiBleHByLnR5cGUgPT09IFwiVHlwZUNhc3RFeHByZXNzaW9uXCIgJiYgISgoX2V4cHIkZXh0cmEgPSBleHByLmV4dHJhKSAhPSBudWxsICYmIF9leHByJGV4dHJhLnBhcmVudGhlc2l6ZWQpICYmIChleHByTGlzdC5sZW5ndGggPiAxIHx8ICFpc1BhcmVudGhlc2l6ZWRFeHByKSkge1xuICAgICAgICB0aGlzLnJhaXNlKEZsb3dFcnJvcnMuVHlwZUNhc3RJblBhdHRlcm4sIGV4cHIudHlwZUFubm90YXRpb24pO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZXhwckxpc3Q7XG4gIH1cbiAgcGFyc2VBcnJheUxpa2UoY2xvc2UsIGlzVHVwbGUsIHJlZkV4cHJlc3Npb25FcnJvcnMpIHtcbiAgICBjb25zdCBub2RlID0gc3VwZXIucGFyc2VBcnJheUxpa2UoY2xvc2UsIGlzVHVwbGUsIHJlZkV4cHJlc3Npb25FcnJvcnMpO1xuICAgIGlmIChyZWZFeHByZXNzaW9uRXJyb3JzICE9IG51bGwgJiYgIXRoaXMuc3RhdGUubWF5YmVJbkFycm93UGFyYW1ldGVycykge1xuICAgICAgdGhpcy50b1JlZmVyZW5jZWRMaXN0KG5vZGUuZWxlbWVudHMpO1xuICAgIH1cbiAgICByZXR1cm4gbm9kZTtcbiAgfVxuICBpc1ZhbGlkTFZhbCh0eXBlLCBkaXNhbGxvd0NhbGxFeHByZXNzaW9uLCBpc1BhcmVudGhlc2l6ZWQsIGJpbmRpbmcpIHtcbiAgICByZXR1cm4gdHlwZSA9PT0gXCJUeXBlQ2FzdEV4cHJlc3Npb25cIiB8fCBzdXBlci5pc1ZhbGlkTFZhbCh0eXBlLCBkaXNhbGxvd0NhbGxFeHByZXNzaW9uLCBpc1BhcmVudGhlc2l6ZWQsIGJpbmRpbmcpO1xuICB9XG4gIHBhcnNlQ2xhc3NQcm9wZXJ0eShub2RlKSB7XG4gICAgaWYgKHRoaXMubWF0Y2goMTQpKSB7XG4gICAgICBub2RlLnR5cGVBbm5vdGF0aW9uID0gdGhpcy5mbG93UGFyc2VUeXBlQW5ub3RhdGlvbigpO1xuICAgIH1cbiAgICByZXR1cm4gc3VwZXIucGFyc2VDbGFzc1Byb3BlcnR5KG5vZGUpO1xuICB9XG4gIHBhcnNlQ2xhc3NQcml2YXRlUHJvcGVydHkobm9kZSkge1xuICAgIGlmICh0aGlzLm1hdGNoKDE0KSkge1xuICAgICAgbm9kZS50eXBlQW5ub3RhdGlvbiA9IHRoaXMuZmxvd1BhcnNlVHlwZUFubm90YXRpb24oKTtcbiAgICB9XG4gICAgcmV0dXJuIHN1cGVyLnBhcnNlQ2xhc3NQcml2YXRlUHJvcGVydHkobm9kZSk7XG4gIH1cbiAgaXNDbGFzc01ldGhvZCgpIHtcbiAgICByZXR1cm4gdGhpcy5tYXRjaCg0NykgfHwgc3VwZXIuaXNDbGFzc01ldGhvZCgpO1xuICB9XG4gIGlzQ2xhc3NQcm9wZXJ0eSgpIHtcbiAgICByZXR1cm4gdGhpcy5tYXRjaCgxNCkgfHwgc3VwZXIuaXNDbGFzc1Byb3BlcnR5KCk7XG4gIH1cbiAgaXNOb25zdGF0aWNDb25zdHJ1Y3RvcihtZXRob2QpIHtcbiAgICByZXR1cm4gIXRoaXMubWF0Y2goMTQpICYmIHN1cGVyLmlzTm9uc3RhdGljQ29uc3RydWN0b3IobWV0aG9kKTtcbiAgfVxuICBwdXNoQ2xhc3NNZXRob2QoY2xhc3NCb2R5LCBtZXRob2QsIGlzR2VuZXJhdG9yLCBpc0FzeW5jLCBpc0NvbnN0cnVjdG9yLCBhbGxvd3NEaXJlY3RTdXBlcikge1xuICAgIGlmIChtZXRob2QudmFyaWFuY2UpIHtcbiAgICAgIHRoaXMudW5leHBlY3RlZChtZXRob2QudmFyaWFuY2UubG9jLnN0YXJ0KTtcbiAgICB9XG4gICAgZGVsZXRlIG1ldGhvZC52YXJpYW5jZTtcbiAgICBpZiAodGhpcy5tYXRjaCg0NykpIHtcbiAgICAgIG1ldGhvZC50eXBlUGFyYW1ldGVycyA9IHRoaXMuZmxvd1BhcnNlVHlwZVBhcmFtZXRlckRlY2xhcmF0aW9uKCk7XG4gICAgfVxuICAgIHN1cGVyLnB1c2hDbGFzc01ldGhvZChjbGFzc0JvZHksIG1ldGhvZCwgaXNHZW5lcmF0b3IsIGlzQXN5bmMsIGlzQ29uc3RydWN0b3IsIGFsbG93c0RpcmVjdFN1cGVyKTtcbiAgICBpZiAobWV0aG9kLnBhcmFtcyAmJiBpc0NvbnN0cnVjdG9yKSB7XG4gICAgICBjb25zdCBwYXJhbXMgPSBtZXRob2QucGFyYW1zO1xuICAgICAgaWYgKHBhcmFtcy5sZW5ndGggPiAwICYmIHRoaXMuaXNUaGlzUGFyYW0ocGFyYW1zWzBdKSkge1xuICAgICAgICB0aGlzLnJhaXNlKEZsb3dFcnJvcnMuVGhpc1BhcmFtQmFubmVkSW5Db25zdHJ1Y3RvciwgbWV0aG9kKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKG1ldGhvZC50eXBlID09PSBcIk1ldGhvZERlZmluaXRpb25cIiAmJiBpc0NvbnN0cnVjdG9yICYmIG1ldGhvZC52YWx1ZS5wYXJhbXMpIHtcbiAgICAgIGNvbnN0IHBhcmFtcyA9IG1ldGhvZC52YWx1ZS5wYXJhbXM7XG4gICAgICBpZiAocGFyYW1zLmxlbmd0aCA+IDAgJiYgdGhpcy5pc1RoaXNQYXJhbShwYXJhbXNbMF0pKSB7XG4gICAgICAgIHRoaXMucmFpc2UoRmxvd0Vycm9ycy5UaGlzUGFyYW1CYW5uZWRJbkNvbnN0cnVjdG9yLCBtZXRob2QpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBwdXNoQ2xhc3NQcml2YXRlTWV0aG9kKGNsYXNzQm9keSwgbWV0aG9kLCBpc0dlbmVyYXRvciwgaXNBc3luYykge1xuICAgIGlmIChtZXRob2QudmFyaWFuY2UpIHtcbiAgICAgIHRoaXMudW5leHBlY3RlZChtZXRob2QudmFyaWFuY2UubG9jLnN0YXJ0KTtcbiAgICB9XG4gICAgZGVsZXRlIG1ldGhvZC52YXJpYW5jZTtcbiAgICBpZiAodGhpcy5tYXRjaCg0NykpIHtcbiAgICAgIG1ldGhvZC50eXBlUGFyYW1ldGVycyA9IHRoaXMuZmxvd1BhcnNlVHlwZVBhcmFtZXRlckRlY2xhcmF0aW9uKCk7XG4gICAgfVxuICAgIHN1cGVyLnB1c2hDbGFzc1ByaXZhdGVNZXRob2QoY2xhc3NCb2R5LCBtZXRob2QsIGlzR2VuZXJhdG9yLCBpc0FzeW5jKTtcbiAgfVxuICBwYXJzZUNsYXNzU3VwZXIobm9kZSkge1xuICAgIHN1cGVyLnBhcnNlQ2xhc3NTdXBlcihub2RlKTtcbiAgICBpZiAobm9kZS5zdXBlckNsYXNzICYmICh0aGlzLm1hdGNoKDQ3KSB8fCB0aGlzLm1hdGNoKDUxKSkpIHtcbiAgICAgIG5vZGUuc3VwZXJUeXBlUGFyYW1ldGVycyA9IHRoaXMuZmxvd1BhcnNlVHlwZVBhcmFtZXRlckluc3RhbnRpYXRpb25JbkV4cHJlc3Npb24oKTtcbiAgICB9XG4gICAgaWYgKHRoaXMuaXNDb250ZXh0dWFsKDExMykpIHtcbiAgICAgIHRoaXMubmV4dCgpO1xuICAgICAgY29uc3QgaW1wbGVtZW50ZWQgPSBub2RlLmltcGxlbWVudHMgPSBbXTtcbiAgICAgIGRvIHtcbiAgICAgICAgY29uc3Qgbm9kZSA9IHRoaXMuc3RhcnROb2RlKCk7XG4gICAgICAgIG5vZGUuaWQgPSB0aGlzLmZsb3dQYXJzZVJlc3RyaWN0ZWRJZGVudGlmaWVyKHRydWUpO1xuICAgICAgICBpZiAodGhpcy5tYXRjaCg0NykpIHtcbiAgICAgICAgICBub2RlLnR5cGVQYXJhbWV0ZXJzID0gdGhpcy5mbG93UGFyc2VUeXBlUGFyYW1ldGVySW5zdGFudGlhdGlvbigpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG5vZGUudHlwZVBhcmFtZXRlcnMgPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGltcGxlbWVudGVkLnB1c2godGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiQ2xhc3NJbXBsZW1lbnRzXCIpKTtcbiAgICAgIH0gd2hpbGUgKHRoaXMuZWF0KDEyKSk7XG4gICAgfVxuICB9XG4gIGNoZWNrR2V0dGVyU2V0dGVyUGFyYW1zKG1ldGhvZCkge1xuICAgIHN1cGVyLmNoZWNrR2V0dGVyU2V0dGVyUGFyYW1zKG1ldGhvZCk7XG4gICAgY29uc3QgcGFyYW1zID0gdGhpcy5nZXRPYmplY3RPckNsYXNzTWV0aG9kUGFyYW1zKG1ldGhvZCk7XG4gICAgaWYgKHBhcmFtcy5sZW5ndGggPiAwKSB7XG4gICAgICBjb25zdCBwYXJhbSA9IHBhcmFtc1swXTtcbiAgICAgIGlmICh0aGlzLmlzVGhpc1BhcmFtKHBhcmFtKSAmJiBtZXRob2Qua2luZCA9PT0gXCJnZXRcIikge1xuICAgICAgICB0aGlzLnJhaXNlKEZsb3dFcnJvcnMuR2V0dGVyTWF5Tm90SGF2ZVRoaXNQYXJhbSwgcGFyYW0pO1xuICAgICAgfSBlbHNlIGlmICh0aGlzLmlzVGhpc1BhcmFtKHBhcmFtKSkge1xuICAgICAgICB0aGlzLnJhaXNlKEZsb3dFcnJvcnMuU2V0dGVyTWF5Tm90SGF2ZVRoaXNQYXJhbSwgcGFyYW0pO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBwYXJzZVByb3BlcnR5TmFtZVByZWZpeE9wZXJhdG9yKG5vZGUpIHtcbiAgICBub2RlLnZhcmlhbmNlID0gdGhpcy5mbG93UGFyc2VWYXJpYW5jZSgpO1xuICB9XG4gIHBhcnNlT2JqUHJvcFZhbHVlKHByb3AsIHN0YXJ0TG9jLCBpc0dlbmVyYXRvciwgaXNBc3luYywgaXNQYXR0ZXJuLCBpc0FjY2Vzc29yLCByZWZFeHByZXNzaW9uRXJyb3JzKSB7XG4gICAgaWYgKHByb3AudmFyaWFuY2UpIHtcbiAgICAgIHRoaXMudW5leHBlY3RlZChwcm9wLnZhcmlhbmNlLmxvYy5zdGFydCk7XG4gICAgfVxuICAgIGRlbGV0ZSBwcm9wLnZhcmlhbmNlO1xuICAgIGxldCB0eXBlUGFyYW1ldGVycztcbiAgICBpZiAodGhpcy5tYXRjaCg0NykgJiYgIWlzQWNjZXNzb3IpIHtcbiAgICAgIHR5cGVQYXJhbWV0ZXJzID0gdGhpcy5mbG93UGFyc2VUeXBlUGFyYW1ldGVyRGVjbGFyYXRpb24oKTtcbiAgICAgIGlmICghdGhpcy5tYXRjaCgxMCkpIHRoaXMudW5leHBlY3RlZCgpO1xuICAgIH1cbiAgICBjb25zdCByZXN1bHQgPSBzdXBlci5wYXJzZU9ialByb3BWYWx1ZShwcm9wLCBzdGFydExvYywgaXNHZW5lcmF0b3IsIGlzQXN5bmMsIGlzUGF0dGVybiwgaXNBY2Nlc3NvciwgcmVmRXhwcmVzc2lvbkVycm9ycyk7XG4gICAgaWYgKHR5cGVQYXJhbWV0ZXJzKSB7XG4gICAgICAocmVzdWx0LnZhbHVlIHx8IHJlc3VsdCkudHlwZVBhcmFtZXRlcnMgPSB0eXBlUGFyYW1ldGVycztcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuICBwYXJzZUZ1bmN0aW9uUGFyYW1UeXBlKHBhcmFtKSB7XG4gICAgaWYgKHRoaXMuZWF0KDE3KSkge1xuICAgICAgaWYgKHBhcmFtLnR5cGUgIT09IFwiSWRlbnRpZmllclwiKSB7XG4gICAgICAgIHRoaXMucmFpc2UoRmxvd0Vycm9ycy5QYXR0ZXJuSXNPcHRpb25hbCwgcGFyYW0pO1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMuaXNUaGlzUGFyYW0ocGFyYW0pKSB7XG4gICAgICAgIHRoaXMucmFpc2UoRmxvd0Vycm9ycy5UaGlzUGFyYW1NYXlOb3RCZU9wdGlvbmFsLCBwYXJhbSk7XG4gICAgICB9XG4gICAgICBwYXJhbS5vcHRpb25hbCA9IHRydWU7XG4gICAgfVxuICAgIGlmICh0aGlzLm1hdGNoKDE0KSkge1xuICAgICAgcGFyYW0udHlwZUFubm90YXRpb24gPSB0aGlzLmZsb3dQYXJzZVR5cGVBbm5vdGF0aW9uKCk7XG4gICAgfSBlbHNlIGlmICh0aGlzLmlzVGhpc1BhcmFtKHBhcmFtKSkge1xuICAgICAgdGhpcy5yYWlzZShGbG93RXJyb3JzLlRoaXNQYXJhbUFubm90YXRpb25SZXF1aXJlZCwgcGFyYW0pO1xuICAgIH1cbiAgICBpZiAodGhpcy5tYXRjaCgyOSkgJiYgdGhpcy5pc1RoaXNQYXJhbShwYXJhbSkpIHtcbiAgICAgIHRoaXMucmFpc2UoRmxvd0Vycm9ycy5UaGlzUGFyYW1Ob0RlZmF1bHQsIHBhcmFtKTtcbiAgICB9XG4gICAgdGhpcy5yZXNldEVuZExvY2F0aW9uKHBhcmFtKTtcbiAgICByZXR1cm4gcGFyYW07XG4gIH1cbiAgcGFyc2VNYXliZURlZmF1bHQoc3RhcnRMb2MsIGxlZnQpIHtcbiAgICBjb25zdCBub2RlID0gc3VwZXIucGFyc2VNYXliZURlZmF1bHQoc3RhcnRMb2MsIGxlZnQpO1xuICAgIGlmIChub2RlLnR5cGUgPT09IFwiQXNzaWdubWVudFBhdHRlcm5cIiAmJiBub2RlLnR5cGVBbm5vdGF0aW9uICYmIG5vZGUucmlnaHQuc3RhcnQgPCBub2RlLnR5cGVBbm5vdGF0aW9uLnN0YXJ0KSB7XG4gICAgICB0aGlzLnJhaXNlKEZsb3dFcnJvcnMuVHlwZUJlZm9yZUluaXRpYWxpemVyLCBub2RlLnR5cGVBbm5vdGF0aW9uKTtcbiAgICB9XG4gICAgcmV0dXJuIG5vZGU7XG4gIH1cbiAgY2hlY2tJbXBvcnRSZWZsZWN0aW9uKG5vZGUpIHtcbiAgICBzdXBlci5jaGVja0ltcG9ydFJlZmxlY3Rpb24obm9kZSk7XG4gICAgaWYgKG5vZGUubW9kdWxlICYmIG5vZGUuaW1wb3J0S2luZCAhPT0gXCJ2YWx1ZVwiKSB7XG4gICAgICB0aGlzLnJhaXNlKEZsb3dFcnJvcnMuSW1wb3J0UmVmbGVjdGlvbkhhc0ltcG9ydFR5cGUsIG5vZGUuc3BlY2lmaWVyc1swXS5sb2Muc3RhcnQpO1xuICAgIH1cbiAgfVxuICBwYXJzZUltcG9ydFNwZWNpZmllckxvY2FsKG5vZGUsIHNwZWNpZmllciwgdHlwZSkge1xuICAgIHNwZWNpZmllci5sb2NhbCA9IGhhc1R5cGVJbXBvcnRLaW5kKG5vZGUpID8gdGhpcy5mbG93UGFyc2VSZXN0cmljdGVkSWRlbnRpZmllcih0cnVlLCB0cnVlKSA6IHRoaXMucGFyc2VJZGVudGlmaWVyKCk7XG4gICAgbm9kZS5zcGVjaWZpZXJzLnB1c2godGhpcy5maW5pc2hJbXBvcnRTcGVjaWZpZXIoc3BlY2lmaWVyLCB0eXBlKSk7XG4gIH1cbiAgaXNQb3RlbnRpYWxJbXBvcnRQaGFzZShpc0V4cG9ydCkge1xuICAgIGlmIChzdXBlci5pc1BvdGVudGlhbEltcG9ydFBoYXNlKGlzRXhwb3J0KSkgcmV0dXJuIHRydWU7XG4gICAgaWYgKHRoaXMuaXNDb250ZXh0dWFsKDEzMCkpIHtcbiAgICAgIGlmICghaXNFeHBvcnQpIHJldHVybiB0cnVlO1xuICAgICAgY29uc3QgY2ggPSB0aGlzLmxvb2thaGVhZENoYXJDb2RlKCk7XG4gICAgICByZXR1cm4gY2ggPT09IDEyMyB8fCBjaCA9PT0gNDI7XG4gICAgfVxuICAgIHJldHVybiAhaXNFeHBvcnQgJiYgdGhpcy5pc0NvbnRleHR1YWwoODcpO1xuICB9XG4gIGFwcGx5SW1wb3J0UGhhc2Uobm9kZSwgaXNFeHBvcnQsIHBoYXNlLCBsb2MpIHtcbiAgICBzdXBlci5hcHBseUltcG9ydFBoYXNlKG5vZGUsIGlzRXhwb3J0LCBwaGFzZSwgbG9jKTtcbiAgICBpZiAoaXNFeHBvcnQpIHtcbiAgICAgIGlmICghcGhhc2UgJiYgdGhpcy5tYXRjaCg2NSkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgbm9kZS5leHBvcnRLaW5kID0gcGhhc2UgPT09IFwidHlwZVwiID8gcGhhc2UgOiBcInZhbHVlXCI7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChwaGFzZSA9PT0gXCJ0eXBlXCIgJiYgdGhpcy5tYXRjaCg1NSkpIHRoaXMudW5leHBlY3RlZCgpO1xuICAgICAgbm9kZS5pbXBvcnRLaW5kID0gcGhhc2UgPT09IFwidHlwZVwiIHx8IHBoYXNlID09PSBcInR5cGVvZlwiID8gcGhhc2UgOiBcInZhbHVlXCI7XG4gICAgfVxuICB9XG4gIHBhcnNlSW1wb3J0U3BlY2lmaWVyKHNwZWNpZmllciwgaW1wb3J0ZWRJc1N0cmluZywgaXNJblR5cGVPbmx5SW1wb3J0LCBpc01heWJlVHlwZU9ubHksIGJpbmRpbmdUeXBlKSB7XG4gICAgY29uc3QgZmlyc3RJZGVudCA9IHNwZWNpZmllci5pbXBvcnRlZDtcbiAgICBsZXQgc3BlY2lmaWVyVHlwZUtpbmQgPSBudWxsO1xuICAgIGlmIChmaXJzdElkZW50LnR5cGUgPT09IFwiSWRlbnRpZmllclwiKSB7XG4gICAgICBpZiAoZmlyc3RJZGVudC5uYW1lID09PSBcInR5cGVcIikge1xuICAgICAgICBzcGVjaWZpZXJUeXBlS2luZCA9IFwidHlwZVwiO1xuICAgICAgfSBlbHNlIGlmIChmaXJzdElkZW50Lm5hbWUgPT09IFwidHlwZW9mXCIpIHtcbiAgICAgICAgc3BlY2lmaWVyVHlwZUtpbmQgPSBcInR5cGVvZlwiO1xuICAgICAgfVxuICAgIH1cbiAgICBsZXQgaXNCaW5kaW5nID0gZmFsc2U7XG4gICAgaWYgKHRoaXMuaXNDb250ZXh0dWFsKDkzKSAmJiAhdGhpcy5pc0xvb2thaGVhZENvbnRleHR1YWwoXCJhc1wiKSkge1xuICAgICAgY29uc3QgYXNfaWRlbnQgPSB0aGlzLnBhcnNlSWRlbnRpZmllcih0cnVlKTtcbiAgICAgIGlmIChzcGVjaWZpZXJUeXBlS2luZCAhPT0gbnVsbCAmJiAhdG9rZW5Jc0tleXdvcmRPcklkZW50aWZpZXIodGhpcy5zdGF0ZS50eXBlKSkge1xuICAgICAgICBzcGVjaWZpZXIuaW1wb3J0ZWQgPSBhc19pZGVudDtcbiAgICAgICAgc3BlY2lmaWVyLmltcG9ydEtpbmQgPSBzcGVjaWZpZXJUeXBlS2luZDtcbiAgICAgICAgc3BlY2lmaWVyLmxvY2FsID0gdGhpcy5jbG9uZUlkZW50aWZpZXIoYXNfaWRlbnQpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc3BlY2lmaWVyLmltcG9ydGVkID0gZmlyc3RJZGVudDtcbiAgICAgICAgc3BlY2lmaWVyLmltcG9ydEtpbmQgPSBudWxsO1xuICAgICAgICBzcGVjaWZpZXIubG9jYWwgPSB0aGlzLnBhcnNlSWRlbnRpZmllcigpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoc3BlY2lmaWVyVHlwZUtpbmQgIT09IG51bGwgJiYgdG9rZW5Jc0tleXdvcmRPcklkZW50aWZpZXIodGhpcy5zdGF0ZS50eXBlKSkge1xuICAgICAgICBzcGVjaWZpZXIuaW1wb3J0ZWQgPSB0aGlzLnBhcnNlSWRlbnRpZmllcih0cnVlKTtcbiAgICAgICAgc3BlY2lmaWVyLmltcG9ydEtpbmQgPSBzcGVjaWZpZXJUeXBlS2luZDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChpbXBvcnRlZElzU3RyaW5nKSB7XG4gICAgICAgICAgdGhyb3cgdGhpcy5yYWlzZShFcnJvcnMuSW1wb3J0QmluZGluZ0lzU3RyaW5nLCBzcGVjaWZpZXIsIHtcbiAgICAgICAgICAgIGltcG9ydE5hbWU6IGZpcnN0SWRlbnQudmFsdWVcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBzcGVjaWZpZXIuaW1wb3J0ZWQgPSBmaXJzdElkZW50O1xuICAgICAgICBzcGVjaWZpZXIuaW1wb3J0S2luZCA9IG51bGw7XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5lYXRDb250ZXh0dWFsKDkzKSkge1xuICAgICAgICBzcGVjaWZpZXIubG9jYWwgPSB0aGlzLnBhcnNlSWRlbnRpZmllcigpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaXNCaW5kaW5nID0gdHJ1ZTtcbiAgICAgICAgc3BlY2lmaWVyLmxvY2FsID0gdGhpcy5jbG9uZUlkZW50aWZpZXIoc3BlY2lmaWVyLmltcG9ydGVkKTtcbiAgICAgIH1cbiAgICB9XG4gICAgY29uc3Qgc3BlY2lmaWVySXNUeXBlSW1wb3J0ID0gaGFzVHlwZUltcG9ydEtpbmQoc3BlY2lmaWVyKTtcbiAgICBpZiAoaXNJblR5cGVPbmx5SW1wb3J0ICYmIHNwZWNpZmllcklzVHlwZUltcG9ydCkge1xuICAgICAgdGhpcy5yYWlzZShGbG93RXJyb3JzLkltcG9ydFR5cGVTaG9ydGhhbmRPbmx5SW5QdXJlSW1wb3J0LCBzcGVjaWZpZXIpO1xuICAgIH1cbiAgICBpZiAoaXNJblR5cGVPbmx5SW1wb3J0IHx8IHNwZWNpZmllcklzVHlwZUltcG9ydCkge1xuICAgICAgdGhpcy5jaGVja1Jlc2VydmVkVHlwZShzcGVjaWZpZXIubG9jYWwubmFtZSwgc3BlY2lmaWVyLmxvY2FsLmxvYy5zdGFydCwgdHJ1ZSk7XG4gICAgfVxuICAgIGlmIChpc0JpbmRpbmcgJiYgIWlzSW5UeXBlT25seUltcG9ydCAmJiAhc3BlY2lmaWVySXNUeXBlSW1wb3J0KSB7XG4gICAgICB0aGlzLmNoZWNrUmVzZXJ2ZWRXb3JkKHNwZWNpZmllci5sb2NhbC5uYW1lLCBzcGVjaWZpZXIubG9jLnN0YXJ0LCB0cnVlLCB0cnVlKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuZmluaXNoSW1wb3J0U3BlY2lmaWVyKHNwZWNpZmllciwgXCJJbXBvcnRTcGVjaWZpZXJcIik7XG4gIH1cbiAgcGFyc2VCaW5kaW5nQXRvbSgpIHtcbiAgICBzd2l0Y2ggKHRoaXMuc3RhdGUudHlwZSkge1xuICAgICAgY2FzZSA3ODpcbiAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VJZGVudGlmaWVyKHRydWUpO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcmV0dXJuIHN1cGVyLnBhcnNlQmluZGluZ0F0b20oKTtcbiAgICB9XG4gIH1cbiAgcGFyc2VGdW5jdGlvblBhcmFtcyhub2RlLCBpc0NvbnN0cnVjdG9yKSB7XG4gICAgY29uc3Qga2luZCA9IG5vZGUua2luZDtcbiAgICBpZiAoa2luZCAhPT0gXCJnZXRcIiAmJiBraW5kICE9PSBcInNldFwiICYmIHRoaXMubWF0Y2goNDcpKSB7XG4gICAgICBub2RlLnR5cGVQYXJhbWV0ZXJzID0gdGhpcy5mbG93UGFyc2VUeXBlUGFyYW1ldGVyRGVjbGFyYXRpb24oKTtcbiAgICB9XG4gICAgc3VwZXIucGFyc2VGdW5jdGlvblBhcmFtcyhub2RlLCBpc0NvbnN0cnVjdG9yKTtcbiAgfVxuICBwYXJzZVZhcklkKGRlY2wsIGtpbmQpIHtcbiAgICBzdXBlci5wYXJzZVZhcklkKGRlY2wsIGtpbmQpO1xuICAgIGlmICh0aGlzLm1hdGNoKDE0KSkge1xuICAgICAgZGVjbC5pZC50eXBlQW5ub3RhdGlvbiA9IHRoaXMuZmxvd1BhcnNlVHlwZUFubm90YXRpb24oKTtcbiAgICAgIHRoaXMucmVzZXRFbmRMb2NhdGlvbihkZWNsLmlkKTtcbiAgICB9XG4gIH1cbiAgcGFyc2VBc3luY0Fycm93RnJvbUNhbGxFeHByZXNzaW9uKG5vZGUsIGNhbGwpIHtcbiAgICBpZiAodGhpcy5tYXRjaCgxNCkpIHtcbiAgICAgIGNvbnN0IG9sZE5vQW5vbkZ1bmN0aW9uVHlwZSA9IHRoaXMuc3RhdGUubm9Bbm9uRnVuY3Rpb25UeXBlO1xuICAgICAgdGhpcy5zdGF0ZS5ub0Fub25GdW5jdGlvblR5cGUgPSB0cnVlO1xuICAgICAgbm9kZS5yZXR1cm5UeXBlID0gdGhpcy5mbG93UGFyc2VUeXBlQW5ub3RhdGlvbigpO1xuICAgICAgdGhpcy5zdGF0ZS5ub0Fub25GdW5jdGlvblR5cGUgPSBvbGROb0Fub25GdW5jdGlvblR5cGU7XG4gICAgfVxuICAgIHJldHVybiBzdXBlci5wYXJzZUFzeW5jQXJyb3dGcm9tQ2FsbEV4cHJlc3Npb24obm9kZSwgY2FsbCk7XG4gIH1cbiAgc2hvdWxkUGFyc2VBc3luY0Fycm93KCkge1xuICAgIHJldHVybiB0aGlzLm1hdGNoKDE0KSB8fCBzdXBlci5zaG91bGRQYXJzZUFzeW5jQXJyb3coKTtcbiAgfVxuICBwYXJzZU1heWJlQXNzaWduKHJlZkV4cHJlc3Npb25FcnJvcnMsIGFmdGVyTGVmdFBhcnNlKSB7XG4gICAgdmFyIF9qc3g7XG4gICAgbGV0IHN0YXRlID0gbnVsbDtcbiAgICBsZXQganN4O1xuICAgIGlmICh0aGlzLmhhc1BsdWdpbihcImpzeFwiKSAmJiAodGhpcy5tYXRjaCgxNDMpIHx8IHRoaXMubWF0Y2goNDcpKSkge1xuICAgICAgc3RhdGUgPSB0aGlzLnN0YXRlLmNsb25lKCk7XG4gICAgICBqc3ggPSB0aGlzLnRyeVBhcnNlKCgpID0+IHN1cGVyLnBhcnNlTWF5YmVBc3NpZ24ocmVmRXhwcmVzc2lvbkVycm9ycywgYWZ0ZXJMZWZ0UGFyc2UpLCBzdGF0ZSk7XG4gICAgICBpZiAoIWpzeC5lcnJvcikgcmV0dXJuIGpzeC5ub2RlO1xuICAgICAgY29uc3Qge1xuICAgICAgICBjb250ZXh0XG4gICAgICB9ID0gdGhpcy5zdGF0ZTtcbiAgICAgIGNvbnN0IGN1cnJlbnRDb250ZXh0ID0gY29udGV4dFtjb250ZXh0Lmxlbmd0aCAtIDFdO1xuICAgICAgaWYgKGN1cnJlbnRDb250ZXh0ID09PSB0eXBlcy5qX29UYWcgfHwgY3VycmVudENvbnRleHQgPT09IHR5cGVzLmpfZXhwcikge1xuICAgICAgICBjb250ZXh0LnBvcCgpO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoKF9qc3ggPSBqc3gpICE9IG51bGwgJiYgX2pzeC5lcnJvciB8fCB0aGlzLm1hdGNoKDQ3KSkge1xuICAgICAgdmFyIF9qc3gyLCBfanN4MztcbiAgICAgIHN0YXRlID0gc3RhdGUgfHwgdGhpcy5zdGF0ZS5jbG9uZSgpO1xuICAgICAgbGV0IHR5cGVQYXJhbWV0ZXJzO1xuICAgICAgY29uc3QgYXJyb3cgPSB0aGlzLnRyeVBhcnNlKGFib3J0ID0+IHtcbiAgICAgICAgdmFyIF9hcnJvd0V4cHJlc3Npb24kZXh0cjtcbiAgICAgICAgdHlwZVBhcmFtZXRlcnMgPSB0aGlzLmZsb3dQYXJzZVR5cGVQYXJhbWV0ZXJEZWNsYXJhdGlvbigpO1xuICAgICAgICBjb25zdCBhcnJvd0V4cHJlc3Npb24gPSB0aGlzLmZvcndhcmROb0Fycm93UGFyYW1zQ29udmVyc2lvbkF0KHR5cGVQYXJhbWV0ZXJzLCAoKSA9PiB7XG4gICAgICAgICAgY29uc3QgcmVzdWx0ID0gc3VwZXIucGFyc2VNYXliZUFzc2lnbihyZWZFeHByZXNzaW9uRXJyb3JzLCBhZnRlckxlZnRQYXJzZSk7XG4gICAgICAgICAgdGhpcy5yZXNldFN0YXJ0TG9jYXRpb25Gcm9tTm9kZShyZXN1bHQsIHR5cGVQYXJhbWV0ZXJzKTtcbiAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9KTtcbiAgICAgICAgaWYgKChfYXJyb3dFeHByZXNzaW9uJGV4dHIgPSBhcnJvd0V4cHJlc3Npb24uZXh0cmEpICE9IG51bGwgJiYgX2Fycm93RXhwcmVzc2lvbiRleHRyLnBhcmVudGhlc2l6ZWQpIGFib3J0KCk7XG4gICAgICAgIGNvbnN0IGV4cHIgPSB0aGlzLm1heWJlVW53cmFwVHlwZUNhc3RFeHByZXNzaW9uKGFycm93RXhwcmVzc2lvbik7XG4gICAgICAgIGlmIChleHByLnR5cGUgIT09IFwiQXJyb3dGdW5jdGlvbkV4cHJlc3Npb25cIikgYWJvcnQoKTtcbiAgICAgICAgZXhwci50eXBlUGFyYW1ldGVycyA9IHR5cGVQYXJhbWV0ZXJzO1xuICAgICAgICB0aGlzLnJlc2V0U3RhcnRMb2NhdGlvbkZyb21Ob2RlKGV4cHIsIHR5cGVQYXJhbWV0ZXJzKTtcbiAgICAgICAgcmV0dXJuIGFycm93RXhwcmVzc2lvbjtcbiAgICAgIH0sIHN0YXRlKTtcbiAgICAgIGxldCBhcnJvd0V4cHJlc3Npb24gPSBudWxsO1xuICAgICAgaWYgKGFycm93Lm5vZGUgJiYgdGhpcy5tYXliZVVud3JhcFR5cGVDYXN0RXhwcmVzc2lvbihhcnJvdy5ub2RlKS50eXBlID09PSBcIkFycm93RnVuY3Rpb25FeHByZXNzaW9uXCIpIHtcbiAgICAgICAgaWYgKCFhcnJvdy5lcnJvciAmJiAhYXJyb3cuYWJvcnRlZCkge1xuICAgICAgICAgIGlmIChhcnJvdy5ub2RlLmFzeW5jKSB7XG4gICAgICAgICAgICB0aGlzLnJhaXNlKEZsb3dFcnJvcnMuVW5leHBlY3RlZFR5cGVQYXJhbWV0ZXJCZWZvcmVBc3luY0Fycm93RnVuY3Rpb24sIHR5cGVQYXJhbWV0ZXJzKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIGFycm93Lm5vZGU7XG4gICAgICAgIH1cbiAgICAgICAgYXJyb3dFeHByZXNzaW9uID0gYXJyb3cubm9kZTtcbiAgICAgIH1cbiAgICAgIGlmICgoX2pzeDIgPSBqc3gpICE9IG51bGwgJiYgX2pzeDIubm9kZSkge1xuICAgICAgICB0aGlzLnN0YXRlID0ganN4LmZhaWxTdGF0ZTtcbiAgICAgICAgcmV0dXJuIGpzeC5ub2RlO1xuICAgICAgfVxuICAgICAgaWYgKGFycm93RXhwcmVzc2lvbikge1xuICAgICAgICB0aGlzLnN0YXRlID0gYXJyb3cuZmFpbFN0YXRlO1xuICAgICAgICByZXR1cm4gYXJyb3dFeHByZXNzaW9uO1xuICAgICAgfVxuICAgICAgaWYgKChfanN4MyA9IGpzeCkgIT0gbnVsbCAmJiBfanN4My50aHJvd24pIHRocm93IGpzeC5lcnJvcjtcbiAgICAgIGlmIChhcnJvdy50aHJvd24pIHRocm93IGFycm93LmVycm9yO1xuICAgICAgdGhyb3cgdGhpcy5yYWlzZShGbG93RXJyb3JzLlVuZXhwZWN0ZWRUb2tlbkFmdGVyVHlwZVBhcmFtZXRlciwgdHlwZVBhcmFtZXRlcnMpO1xuICAgIH1cbiAgICByZXR1cm4gc3VwZXIucGFyc2VNYXliZUFzc2lnbihyZWZFeHByZXNzaW9uRXJyb3JzLCBhZnRlckxlZnRQYXJzZSk7XG4gIH1cbiAgcGFyc2VBcnJvdyhub2RlKSB7XG4gICAgaWYgKHRoaXMubWF0Y2goMTQpKSB7XG4gICAgICBjb25zdCByZXN1bHQgPSB0aGlzLnRyeVBhcnNlKCgpID0+IHtcbiAgICAgICAgY29uc3Qgb2xkTm9Bbm9uRnVuY3Rpb25UeXBlID0gdGhpcy5zdGF0ZS5ub0Fub25GdW5jdGlvblR5cGU7XG4gICAgICAgIHRoaXMuc3RhdGUubm9Bbm9uRnVuY3Rpb25UeXBlID0gdHJ1ZTtcbiAgICAgICAgY29uc3QgdHlwZU5vZGUgPSB0aGlzLnN0YXJ0Tm9kZSgpO1xuICAgICAgICBbdHlwZU5vZGUudHlwZUFubm90YXRpb24sIG5vZGUucHJlZGljYXRlXSA9IHRoaXMuZmxvd1BhcnNlVHlwZUFuZFByZWRpY2F0ZUluaXRpYWxpc2VyKCk7XG4gICAgICAgIHRoaXMuc3RhdGUubm9Bbm9uRnVuY3Rpb25UeXBlID0gb2xkTm9Bbm9uRnVuY3Rpb25UeXBlO1xuICAgICAgICBpZiAodGhpcy5jYW5JbnNlcnRTZW1pY29sb24oKSkgdGhpcy51bmV4cGVjdGVkKCk7XG4gICAgICAgIGlmICghdGhpcy5tYXRjaCgxOSkpIHRoaXMudW5leHBlY3RlZCgpO1xuICAgICAgICByZXR1cm4gdHlwZU5vZGU7XG4gICAgICB9KTtcbiAgICAgIGlmIChyZXN1bHQudGhyb3duKSByZXR1cm4gbnVsbDtcbiAgICAgIGlmIChyZXN1bHQuZXJyb3IpIHRoaXMuc3RhdGUgPSByZXN1bHQuZmFpbFN0YXRlO1xuICAgICAgbm9kZS5yZXR1cm5UeXBlID0gcmVzdWx0Lm5vZGUudHlwZUFubm90YXRpb24gPyB0aGlzLmZpbmlzaE5vZGUocmVzdWx0Lm5vZGUsIFwiVHlwZUFubm90YXRpb25cIikgOiBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gc3VwZXIucGFyc2VBcnJvdyhub2RlKTtcbiAgfVxuICBzaG91bGRQYXJzZUFycm93KHBhcmFtcykge1xuICAgIHJldHVybiB0aGlzLm1hdGNoKDE0KSB8fCBzdXBlci5zaG91bGRQYXJzZUFycm93KHBhcmFtcyk7XG4gIH1cbiAgc2V0QXJyb3dGdW5jdGlvblBhcmFtZXRlcnMobm9kZSwgcGFyYW1zKSB7XG4gICAgaWYgKHRoaXMuc3RhdGUubm9BcnJvd1BhcmFtc0NvbnZlcnNpb25BdC5pbmNsdWRlcyh0aGlzLm9mZnNldFRvU291cmNlUG9zKG5vZGUuc3RhcnQpKSkge1xuICAgICAgbm9kZS5wYXJhbXMgPSBwYXJhbXM7XG4gICAgfSBlbHNlIHtcbiAgICAgIHN1cGVyLnNldEFycm93RnVuY3Rpb25QYXJhbWV0ZXJzKG5vZGUsIHBhcmFtcyk7XG4gICAgfVxuICB9XG4gIGNoZWNrUGFyYW1zKG5vZGUsIGFsbG93RHVwbGljYXRlcywgaXNBcnJvd0Z1bmN0aW9uLCBzdHJpY3RNb2RlQ2hhbmdlZCA9IHRydWUpIHtcbiAgICBpZiAoaXNBcnJvd0Z1bmN0aW9uICYmIHRoaXMuc3RhdGUubm9BcnJvd1BhcmFtc0NvbnZlcnNpb25BdC5pbmNsdWRlcyh0aGlzLm9mZnNldFRvU291cmNlUG9zKG5vZGUuc3RhcnQpKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IG5vZGUucGFyYW1zLmxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAodGhpcy5pc1RoaXNQYXJhbShub2RlLnBhcmFtc1tpXSkgJiYgaSA+IDApIHtcbiAgICAgICAgdGhpcy5yYWlzZShGbG93RXJyb3JzLlRoaXNQYXJhbU11c3RCZUZpcnN0LCBub2RlLnBhcmFtc1tpXSk7XG4gICAgICB9XG4gICAgfVxuICAgIHN1cGVyLmNoZWNrUGFyYW1zKG5vZGUsIGFsbG93RHVwbGljYXRlcywgaXNBcnJvd0Z1bmN0aW9uLCBzdHJpY3RNb2RlQ2hhbmdlZCk7XG4gIH1cbiAgcGFyc2VQYXJlbkFuZERpc3Rpbmd1aXNoRXhwcmVzc2lvbihjYW5CZUFycm93KSB7XG4gICAgcmV0dXJuIHN1cGVyLnBhcnNlUGFyZW5BbmREaXN0aW5ndWlzaEV4cHJlc3Npb24oY2FuQmVBcnJvdyAmJiAhdGhpcy5zdGF0ZS5ub0Fycm93QXQuaW5jbHVkZXModGhpcy5zb3VyY2VUb09mZnNldFBvcyh0aGlzLnN0YXRlLnN0YXJ0KSkpO1xuICB9XG4gIHBhcnNlU3Vic2NyaXB0cyhiYXNlLCBzdGFydExvYywgbm9DYWxscykge1xuICAgIGlmIChiYXNlLnR5cGUgPT09IFwiSWRlbnRpZmllclwiICYmIGJhc2UubmFtZSA9PT0gXCJhc3luY1wiICYmIHRoaXMuc3RhdGUubm9BcnJvd0F0LmluY2x1ZGVzKHN0YXJ0TG9jLmluZGV4KSkge1xuICAgICAgdGhpcy5uZXh0KCk7XG4gICAgICBjb25zdCBub2RlID0gdGhpcy5zdGFydE5vZGVBdChzdGFydExvYyk7XG4gICAgICBub2RlLmNhbGxlZSA9IGJhc2U7XG4gICAgICBub2RlLmFyZ3VtZW50cyA9IHN1cGVyLnBhcnNlQ2FsbEV4cHJlc3Npb25Bcmd1bWVudHMoKTtcbiAgICAgIGJhc2UgPSB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJDYWxsRXhwcmVzc2lvblwiKTtcbiAgICB9IGVsc2UgaWYgKGJhc2UudHlwZSA9PT0gXCJJZGVudGlmaWVyXCIgJiYgYmFzZS5uYW1lID09PSBcImFzeW5jXCIgJiYgdGhpcy5tYXRjaCg0NykpIHtcbiAgICAgIGNvbnN0IHN0YXRlID0gdGhpcy5zdGF0ZS5jbG9uZSgpO1xuICAgICAgY29uc3QgYXJyb3cgPSB0aGlzLnRyeVBhcnNlKGFib3J0ID0+IHRoaXMucGFyc2VBc3luY0Fycm93V2l0aFR5cGVQYXJhbWV0ZXJzKHN0YXJ0TG9jKSB8fCBhYm9ydCgpLCBzdGF0ZSk7XG4gICAgICBpZiAoIWFycm93LmVycm9yICYmICFhcnJvdy5hYm9ydGVkKSByZXR1cm4gYXJyb3cubm9kZTtcbiAgICAgIGNvbnN0IHJlc3VsdCA9IHRoaXMudHJ5UGFyc2UoKCkgPT4gc3VwZXIucGFyc2VTdWJzY3JpcHRzKGJhc2UsIHN0YXJ0TG9jLCBub0NhbGxzKSwgc3RhdGUpO1xuICAgICAgaWYgKHJlc3VsdC5ub2RlICYmICFyZXN1bHQuZXJyb3IpIHJldHVybiByZXN1bHQubm9kZTtcbiAgICAgIGlmIChhcnJvdy5ub2RlKSB7XG4gICAgICAgIHRoaXMuc3RhdGUgPSBhcnJvdy5mYWlsU3RhdGU7XG4gICAgICAgIHJldHVybiBhcnJvdy5ub2RlO1xuICAgICAgfVxuICAgICAgaWYgKHJlc3VsdC5ub2RlKSB7XG4gICAgICAgIHRoaXMuc3RhdGUgPSByZXN1bHQuZmFpbFN0YXRlO1xuICAgICAgICByZXR1cm4gcmVzdWx0Lm5vZGU7XG4gICAgICB9XG4gICAgICB0aHJvdyBhcnJvdy5lcnJvciB8fCByZXN1bHQuZXJyb3I7XG4gICAgfVxuICAgIHJldHVybiBzdXBlci5wYXJzZVN1YnNjcmlwdHMoYmFzZSwgc3RhcnRMb2MsIG5vQ2FsbHMpO1xuICB9XG4gIHBhcnNlU3Vic2NyaXB0KGJhc2UsIHN0YXJ0TG9jLCBub0NhbGxzLCBzdWJzY3JpcHRTdGF0ZSkge1xuICAgIGlmICh0aGlzLm1hdGNoKDE4KSAmJiB0aGlzLmlzTG9va2FoZWFkVG9rZW5fbHQoKSkge1xuICAgICAgc3Vic2NyaXB0U3RhdGUub3B0aW9uYWxDaGFpbk1lbWJlciA9IHRydWU7XG4gICAgICBpZiAobm9DYWxscykge1xuICAgICAgICBzdWJzY3JpcHRTdGF0ZS5zdG9wID0gdHJ1ZTtcbiAgICAgICAgcmV0dXJuIGJhc2U7XG4gICAgICB9XG4gICAgICB0aGlzLm5leHQoKTtcbiAgICAgIGNvbnN0IG5vZGUgPSB0aGlzLnN0YXJ0Tm9kZUF0KHN0YXJ0TG9jKTtcbiAgICAgIG5vZGUuY2FsbGVlID0gYmFzZTtcbiAgICAgIG5vZGUudHlwZUFyZ3VtZW50cyA9IHRoaXMuZmxvd1BhcnNlVHlwZVBhcmFtZXRlckluc3RhbnRpYXRpb25JbkV4cHJlc3Npb24oKTtcbiAgICAgIHRoaXMuZXhwZWN0KDEwKTtcbiAgICAgIG5vZGUuYXJndW1lbnRzID0gdGhpcy5wYXJzZUNhbGxFeHByZXNzaW9uQXJndW1lbnRzKCk7XG4gICAgICBub2RlLm9wdGlvbmFsID0gdHJ1ZTtcbiAgICAgIHJldHVybiB0aGlzLmZpbmlzaENhbGxFeHByZXNzaW9uKG5vZGUsIHRydWUpO1xuICAgIH0gZWxzZSBpZiAoIW5vQ2FsbHMgJiYgdGhpcy5zaG91bGRQYXJzZVR5cGVzKCkgJiYgKHRoaXMubWF0Y2goNDcpIHx8IHRoaXMubWF0Y2goNTEpKSkge1xuICAgICAgY29uc3Qgbm9kZSA9IHRoaXMuc3RhcnROb2RlQXQoc3RhcnRMb2MpO1xuICAgICAgbm9kZS5jYWxsZWUgPSBiYXNlO1xuICAgICAgY29uc3QgcmVzdWx0ID0gdGhpcy50cnlQYXJzZSgoKSA9PiB7XG4gICAgICAgIG5vZGUudHlwZUFyZ3VtZW50cyA9IHRoaXMuZmxvd1BhcnNlVHlwZVBhcmFtZXRlckluc3RhbnRpYXRpb25DYWxsT3JOZXcoKTtcbiAgICAgICAgdGhpcy5leHBlY3QoMTApO1xuICAgICAgICBub2RlLmFyZ3VtZW50cyA9IHN1cGVyLnBhcnNlQ2FsbEV4cHJlc3Npb25Bcmd1bWVudHMoKTtcbiAgICAgICAgaWYgKHN1YnNjcmlwdFN0YXRlLm9wdGlvbmFsQ2hhaW5NZW1iZXIpIHtcbiAgICAgICAgICBub2RlLm9wdGlvbmFsID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuZmluaXNoQ2FsbEV4cHJlc3Npb24obm9kZSwgc3Vic2NyaXB0U3RhdGUub3B0aW9uYWxDaGFpbk1lbWJlcik7XG4gICAgICB9KTtcbiAgICAgIGlmIChyZXN1bHQubm9kZSkge1xuICAgICAgICBpZiAocmVzdWx0LmVycm9yKSB0aGlzLnN0YXRlID0gcmVzdWx0LmZhaWxTdGF0ZTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdC5ub2RlO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gc3VwZXIucGFyc2VTdWJzY3JpcHQoYmFzZSwgc3RhcnRMb2MsIG5vQ2FsbHMsIHN1YnNjcmlwdFN0YXRlKTtcbiAgfVxuICBwYXJzZU5ld0NhbGxlZShub2RlKSB7XG4gICAgc3VwZXIucGFyc2VOZXdDYWxsZWUobm9kZSk7XG4gICAgbGV0IHRhcmdzID0gbnVsbDtcbiAgICBpZiAodGhpcy5zaG91bGRQYXJzZVR5cGVzKCkgJiYgdGhpcy5tYXRjaCg0NykpIHtcbiAgICAgIHRhcmdzID0gdGhpcy50cnlQYXJzZSgoKSA9PiB0aGlzLmZsb3dQYXJzZVR5cGVQYXJhbWV0ZXJJbnN0YW50aWF0aW9uQ2FsbE9yTmV3KCkpLm5vZGU7XG4gICAgfVxuICAgIG5vZGUudHlwZUFyZ3VtZW50cyA9IHRhcmdzO1xuICB9XG4gIHBhcnNlQXN5bmNBcnJvd1dpdGhUeXBlUGFyYW1ldGVycyhzdGFydExvYykge1xuICAgIGNvbnN0IG5vZGUgPSB0aGlzLnN0YXJ0Tm9kZUF0KHN0YXJ0TG9jKTtcbiAgICB0aGlzLnBhcnNlRnVuY3Rpb25QYXJhbXMobm9kZSwgZmFsc2UpO1xuICAgIGlmICghdGhpcy5wYXJzZUFycm93KG5vZGUpKSByZXR1cm47XG4gICAgcmV0dXJuIHN1cGVyLnBhcnNlQXJyb3dFeHByZXNzaW9uKG5vZGUsIHVuZGVmaW5lZCwgdHJ1ZSk7XG4gIH1cbiAgcmVhZFRva2VuX211bHRfbW9kdWxvKGNvZGUpIHtcbiAgICBjb25zdCBuZXh0ID0gdGhpcy5pbnB1dC5jaGFyQ29kZUF0KHRoaXMuc3RhdGUucG9zICsgMSk7XG4gICAgaWYgKGNvZGUgPT09IDQyICYmIG5leHQgPT09IDQ3ICYmIHRoaXMuc3RhdGUuaGFzRmxvd0NvbW1lbnQpIHtcbiAgICAgIHRoaXMuc3RhdGUuaGFzRmxvd0NvbW1lbnQgPSBmYWxzZTtcbiAgICAgIHRoaXMuc3RhdGUucG9zICs9IDI7XG4gICAgICB0aGlzLm5leHRUb2tlbigpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBzdXBlci5yZWFkVG9rZW5fbXVsdF9tb2R1bG8oY29kZSk7XG4gIH1cbiAgcmVhZFRva2VuX3BpcGVfYW1wKGNvZGUpIHtcbiAgICBjb25zdCBuZXh0ID0gdGhpcy5pbnB1dC5jaGFyQ29kZUF0KHRoaXMuc3RhdGUucG9zICsgMSk7XG4gICAgaWYgKGNvZGUgPT09IDEyNCAmJiBuZXh0ID09PSAxMjUpIHtcbiAgICAgIHRoaXMuZmluaXNoT3AoOSwgMik7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHN1cGVyLnJlYWRUb2tlbl9waXBlX2FtcChjb2RlKTtcbiAgfVxuICBwYXJzZVRvcExldmVsKGZpbGUsIHByb2dyYW0pIHtcbiAgICBjb25zdCBmaWxlTm9kZSA9IHN1cGVyLnBhcnNlVG9wTGV2ZWwoZmlsZSwgcHJvZ3JhbSk7XG4gICAgaWYgKHRoaXMuc3RhdGUuaGFzRmxvd0NvbW1lbnQpIHtcbiAgICAgIHRoaXMucmFpc2UoRmxvd0Vycm9ycy5VbnRlcm1pbmF0ZWRGbG93Q29tbWVudCwgdGhpcy5zdGF0ZS5jdXJQb3NpdGlvbigpKTtcbiAgICB9XG4gICAgcmV0dXJuIGZpbGVOb2RlO1xuICB9XG4gIHNraXBCbG9ja0NvbW1lbnQoKSB7XG4gICAgaWYgKHRoaXMuaGFzUGx1Z2luKFwiZmxvd0NvbW1lbnRzXCIpICYmIHRoaXMuc2tpcEZsb3dDb21tZW50KCkpIHtcbiAgICAgIGlmICh0aGlzLnN0YXRlLmhhc0Zsb3dDb21tZW50KSB7XG4gICAgICAgIHRocm93IHRoaXMucmFpc2UoRmxvd0Vycm9ycy5OZXN0ZWRGbG93Q29tbWVudCwgdGhpcy5zdGF0ZS5zdGFydExvYyk7XG4gICAgICB9XG4gICAgICB0aGlzLmhhc0Zsb3dDb21tZW50Q29tcGxldGlvbigpO1xuICAgICAgY29uc3QgY29tbWVudFNraXAgPSB0aGlzLnNraXBGbG93Q29tbWVudCgpO1xuICAgICAgaWYgKGNvbW1lbnRTa2lwKSB7XG4gICAgICAgIHRoaXMuc3RhdGUucG9zICs9IGNvbW1lbnRTa2lwO1xuICAgICAgICB0aGlzLnN0YXRlLmhhc0Zsb3dDb21tZW50ID0gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgcmV0dXJuIHN1cGVyLnNraXBCbG9ja0NvbW1lbnQodGhpcy5zdGF0ZS5oYXNGbG93Q29tbWVudCA/IFwiKi0vXCIgOiBcIiovXCIpO1xuICB9XG4gIHNraXBGbG93Q29tbWVudCgpIHtcbiAgICBjb25zdCB7XG4gICAgICBwb3NcbiAgICB9ID0gdGhpcy5zdGF0ZTtcbiAgICBsZXQgc2hpZnRUb0ZpcnN0Tm9uV2hpdGVTcGFjZSA9IDI7XG4gICAgd2hpbGUgKFszMiwgOV0uaW5jbHVkZXModGhpcy5pbnB1dC5jaGFyQ29kZUF0KHBvcyArIHNoaWZ0VG9GaXJzdE5vbldoaXRlU3BhY2UpKSkge1xuICAgICAgc2hpZnRUb0ZpcnN0Tm9uV2hpdGVTcGFjZSsrO1xuICAgIH1cbiAgICBjb25zdCBjaDIgPSB0aGlzLmlucHV0LmNoYXJDb2RlQXQoc2hpZnRUb0ZpcnN0Tm9uV2hpdGVTcGFjZSArIHBvcyk7XG4gICAgY29uc3QgY2gzID0gdGhpcy5pbnB1dC5jaGFyQ29kZUF0KHNoaWZ0VG9GaXJzdE5vbldoaXRlU3BhY2UgKyBwb3MgKyAxKTtcbiAgICBpZiAoY2gyID09PSA1OCAmJiBjaDMgPT09IDU4KSB7XG4gICAgICByZXR1cm4gc2hpZnRUb0ZpcnN0Tm9uV2hpdGVTcGFjZSArIDI7XG4gICAgfVxuICAgIGlmICh0aGlzLmlucHV0LnNsaWNlKHNoaWZ0VG9GaXJzdE5vbldoaXRlU3BhY2UgKyBwb3MsIHNoaWZ0VG9GaXJzdE5vbldoaXRlU3BhY2UgKyBwb3MgKyAxMikgPT09IFwiZmxvdy1pbmNsdWRlXCIpIHtcbiAgICAgIHJldHVybiBzaGlmdFRvRmlyc3ROb25XaGl0ZVNwYWNlICsgMTI7XG4gICAgfVxuICAgIGlmIChjaDIgPT09IDU4ICYmIGNoMyAhPT0gNTgpIHtcbiAgICAgIHJldHVybiBzaGlmdFRvRmlyc3ROb25XaGl0ZVNwYWNlO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgaGFzRmxvd0NvbW1lbnRDb21wbGV0aW9uKCkge1xuICAgIGNvbnN0IGVuZCA9IHRoaXMuaW5wdXQuaW5kZXhPZihcIiovXCIsIHRoaXMuc3RhdGUucG9zKTtcbiAgICBpZiAoZW5kID09PSAtMSkge1xuICAgICAgdGhyb3cgdGhpcy5yYWlzZShFcnJvcnMuVW50ZXJtaW5hdGVkQ29tbWVudCwgdGhpcy5zdGF0ZS5jdXJQb3NpdGlvbigpKTtcbiAgICB9XG4gIH1cbiAgZmxvd0VudW1FcnJvckJvb2xlYW5NZW1iZXJOb3RJbml0aWFsaXplZChsb2MsIHtcbiAgICBlbnVtTmFtZSxcbiAgICBtZW1iZXJOYW1lXG4gIH0pIHtcbiAgICB0aGlzLnJhaXNlKEZsb3dFcnJvcnMuRW51bUJvb2xlYW5NZW1iZXJOb3RJbml0aWFsaXplZCwgbG9jLCB7XG4gICAgICBtZW1iZXJOYW1lLFxuICAgICAgZW51bU5hbWVcbiAgICB9KTtcbiAgfVxuICBmbG93RW51bUVycm9ySW52YWxpZE1lbWJlckluaXRpYWxpemVyKGxvYywgZW51bUNvbnRleHQpIHtcbiAgICByZXR1cm4gdGhpcy5yYWlzZSghZW51bUNvbnRleHQuZXhwbGljaXRUeXBlID8gRmxvd0Vycm9ycy5FbnVtSW52YWxpZE1lbWJlckluaXRpYWxpemVyVW5rbm93blR5cGUgOiBlbnVtQ29udGV4dC5leHBsaWNpdFR5cGUgPT09IFwic3ltYm9sXCIgPyBGbG93RXJyb3JzLkVudW1JbnZhbGlkTWVtYmVySW5pdGlhbGl6ZXJTeW1ib2xUeXBlIDogRmxvd0Vycm9ycy5FbnVtSW52YWxpZE1lbWJlckluaXRpYWxpemVyUHJpbWFyeVR5cGUsIGxvYywgZW51bUNvbnRleHQpO1xuICB9XG4gIGZsb3dFbnVtRXJyb3JOdW1iZXJNZW1iZXJOb3RJbml0aWFsaXplZChsb2MsIGRldGFpbHMpIHtcbiAgICB0aGlzLnJhaXNlKEZsb3dFcnJvcnMuRW51bU51bWJlck1lbWJlck5vdEluaXRpYWxpemVkLCBsb2MsIGRldGFpbHMpO1xuICB9XG4gIGZsb3dFbnVtRXJyb3JTdHJpbmdNZW1iZXJJbmNvbnNpc3RlbnRseUluaXRpYWxpemVkKG5vZGUsIGRldGFpbHMpIHtcbiAgICB0aGlzLnJhaXNlKEZsb3dFcnJvcnMuRW51bVN0cmluZ01lbWJlckluY29uc2lzdGVudGx5SW5pdGlhbGl6ZWQsIG5vZGUsIGRldGFpbHMpO1xuICB9XG4gIGZsb3dFbnVtTWVtYmVySW5pdCgpIHtcbiAgICBjb25zdCBzdGFydExvYyA9IHRoaXMuc3RhdGUuc3RhcnRMb2M7XG4gICAgY29uc3QgZW5kT2ZJbml0ID0gKCkgPT4gdGhpcy5tYXRjaCgxMikgfHwgdGhpcy5tYXRjaCg4KTtcbiAgICBzd2l0Y2ggKHRoaXMuc3RhdGUudHlwZSkge1xuICAgICAgY2FzZSAxMzU6XG4gICAgICAgIHtcbiAgICAgICAgICBjb25zdCBsaXRlcmFsID0gdGhpcy5wYXJzZU51bWVyaWNMaXRlcmFsKHRoaXMuc3RhdGUudmFsdWUpO1xuICAgICAgICAgIGlmIChlbmRPZkluaXQoKSkge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgdHlwZTogXCJudW1iZXJcIixcbiAgICAgICAgICAgICAgbG9jOiBsaXRlcmFsLmxvYy5zdGFydCxcbiAgICAgICAgICAgICAgdmFsdWU6IGxpdGVyYWxcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB0eXBlOiBcImludmFsaWRcIixcbiAgICAgICAgICAgIGxvYzogc3RhcnRMb2NcbiAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICBjYXNlIDEzNDpcbiAgICAgICAge1xuICAgICAgICAgIGNvbnN0IGxpdGVyYWwgPSB0aGlzLnBhcnNlU3RyaW5nTGl0ZXJhbCh0aGlzLnN0YXRlLnZhbHVlKTtcbiAgICAgICAgICBpZiAoZW5kT2ZJbml0KCkpIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgIHR5cGU6IFwic3RyaW5nXCIsXG4gICAgICAgICAgICAgIGxvYzogbGl0ZXJhbC5sb2Muc3RhcnQsXG4gICAgICAgICAgICAgIHZhbHVlOiBsaXRlcmFsXG4gICAgICAgICAgICB9O1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdHlwZTogXCJpbnZhbGlkXCIsXG4gICAgICAgICAgICBsb2M6IHN0YXJ0TG9jXG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgY2FzZSA4NTpcbiAgICAgIGNhc2UgODY6XG4gICAgICAgIHtcbiAgICAgICAgICBjb25zdCBsaXRlcmFsID0gdGhpcy5wYXJzZUJvb2xlYW5MaXRlcmFsKHRoaXMubWF0Y2goODUpKTtcbiAgICAgICAgICBpZiAoZW5kT2ZJbml0KCkpIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgIHR5cGU6IFwiYm9vbGVhblwiLFxuICAgICAgICAgICAgICBsb2M6IGxpdGVyYWwubG9jLnN0YXJ0LFxuICAgICAgICAgICAgICB2YWx1ZTogbGl0ZXJhbFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHR5cGU6IFwiaW52YWxpZFwiLFxuICAgICAgICAgICAgbG9jOiBzdGFydExvY1xuICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgdHlwZTogXCJpbnZhbGlkXCIsXG4gICAgICAgICAgbG9jOiBzdGFydExvY1xuICAgICAgICB9O1xuICAgIH1cbiAgfVxuICBmbG93RW51bU1lbWJlclJhdygpIHtcbiAgICBjb25zdCBsb2MgPSB0aGlzLnN0YXRlLnN0YXJ0TG9jO1xuICAgIGNvbnN0IGlkID0gdGhpcy5wYXJzZUlkZW50aWZpZXIodHJ1ZSk7XG4gICAgY29uc3QgaW5pdCA9IHRoaXMuZWF0KDI5KSA/IHRoaXMuZmxvd0VudW1NZW1iZXJJbml0KCkgOiB7XG4gICAgICB0eXBlOiBcIm5vbmVcIixcbiAgICAgIGxvY1xuICAgIH07XG4gICAgcmV0dXJuIHtcbiAgICAgIGlkLFxuICAgICAgaW5pdFxuICAgIH07XG4gIH1cbiAgZmxvd0VudW1DaGVja0V4cGxpY2l0VHlwZU1pc21hdGNoKGxvYywgY29udGV4dCwgZXhwZWN0ZWRUeXBlKSB7XG4gICAgY29uc3Qge1xuICAgICAgZXhwbGljaXRUeXBlXG4gICAgfSA9IGNvbnRleHQ7XG4gICAgaWYgKGV4cGxpY2l0VHlwZSA9PT0gbnVsbCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoZXhwbGljaXRUeXBlICE9PSBleHBlY3RlZFR5cGUpIHtcbiAgICAgIHRoaXMuZmxvd0VudW1FcnJvckludmFsaWRNZW1iZXJJbml0aWFsaXplcihsb2MsIGNvbnRleHQpO1xuICAgIH1cbiAgfVxuICBmbG93RW51bU1lbWJlcnMoe1xuICAgIGVudW1OYW1lLFxuICAgIGV4cGxpY2l0VHlwZVxuICB9KSB7XG4gICAgY29uc3Qgc2Vlbk5hbWVzID0gbmV3IFNldCgpO1xuICAgIGNvbnN0IG1lbWJlcnMgPSB7XG4gICAgICBib29sZWFuTWVtYmVyczogW10sXG4gICAgICBudW1iZXJNZW1iZXJzOiBbXSxcbiAgICAgIHN0cmluZ01lbWJlcnM6IFtdLFxuICAgICAgZGVmYXVsdGVkTWVtYmVyczogW11cbiAgICB9O1xuICAgIGxldCBoYXNVbmtub3duTWVtYmVycyA9IGZhbHNlO1xuICAgIHdoaWxlICghdGhpcy5tYXRjaCg4KSkge1xuICAgICAgaWYgKHRoaXMuZWF0KDIxKSkge1xuICAgICAgICBoYXNVbmtub3duTWVtYmVycyA9IHRydWU7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgY29uc3QgbWVtYmVyTm9kZSA9IHRoaXMuc3RhcnROb2RlKCk7XG4gICAgICBjb25zdCB7XG4gICAgICAgIGlkLFxuICAgICAgICBpbml0XG4gICAgICB9ID0gdGhpcy5mbG93RW51bU1lbWJlclJhdygpO1xuICAgICAgY29uc3QgbWVtYmVyTmFtZSA9IGlkLm5hbWU7XG4gICAgICBpZiAobWVtYmVyTmFtZSA9PT0gXCJcIikge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIGlmICgvXlthLXpdLy50ZXN0KG1lbWJlck5hbWUpKSB7XG4gICAgICAgIHRoaXMucmFpc2UoRmxvd0Vycm9ycy5FbnVtSW52YWxpZE1lbWJlck5hbWUsIGlkLCB7XG4gICAgICAgICAgbWVtYmVyTmFtZSxcbiAgICAgICAgICBzdWdnZXN0aW9uOiBtZW1iZXJOYW1lWzBdLnRvVXBwZXJDYXNlKCkgKyBtZW1iZXJOYW1lLnNsaWNlKDEpLFxuICAgICAgICAgIGVudW1OYW1lXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgaWYgKHNlZW5OYW1lcy5oYXMobWVtYmVyTmFtZSkpIHtcbiAgICAgICAgdGhpcy5yYWlzZShGbG93RXJyb3JzLkVudW1EdXBsaWNhdGVNZW1iZXJOYW1lLCBpZCwge1xuICAgICAgICAgIG1lbWJlck5hbWUsXG4gICAgICAgICAgZW51bU5hbWVcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICBzZWVuTmFtZXMuYWRkKG1lbWJlck5hbWUpO1xuICAgICAgY29uc3QgY29udGV4dCA9IHtcbiAgICAgICAgZW51bU5hbWUsXG4gICAgICAgIGV4cGxpY2l0VHlwZSxcbiAgICAgICAgbWVtYmVyTmFtZVxuICAgICAgfTtcbiAgICAgIG1lbWJlck5vZGUuaWQgPSBpZDtcbiAgICAgIHN3aXRjaCAoaW5pdC50eXBlKSB7XG4gICAgICAgIGNhc2UgXCJib29sZWFuXCI6XG4gICAgICAgICAge1xuICAgICAgICAgICAgdGhpcy5mbG93RW51bUNoZWNrRXhwbGljaXRUeXBlTWlzbWF0Y2goaW5pdC5sb2MsIGNvbnRleHQsIFwiYm9vbGVhblwiKTtcbiAgICAgICAgICAgIG1lbWJlck5vZGUuaW5pdCA9IGluaXQudmFsdWU7XG4gICAgICAgICAgICBtZW1iZXJzLmJvb2xlYW5NZW1iZXJzLnB1c2godGhpcy5maW5pc2hOb2RlKG1lbWJlck5vZGUsIFwiRW51bUJvb2xlYW5NZW1iZXJcIikpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICBjYXNlIFwibnVtYmVyXCI6XG4gICAgICAgICAge1xuICAgICAgICAgICAgdGhpcy5mbG93RW51bUNoZWNrRXhwbGljaXRUeXBlTWlzbWF0Y2goaW5pdC5sb2MsIGNvbnRleHQsIFwibnVtYmVyXCIpO1xuICAgICAgICAgICAgbWVtYmVyTm9kZS5pbml0ID0gaW5pdC52YWx1ZTtcbiAgICAgICAgICAgIG1lbWJlcnMubnVtYmVyTWVtYmVycy5wdXNoKHRoaXMuZmluaXNoTm9kZShtZW1iZXJOb2RlLCBcIkVudW1OdW1iZXJNZW1iZXJcIikpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICBjYXNlIFwic3RyaW5nXCI6XG4gICAgICAgICAge1xuICAgICAgICAgICAgdGhpcy5mbG93RW51bUNoZWNrRXhwbGljaXRUeXBlTWlzbWF0Y2goaW5pdC5sb2MsIGNvbnRleHQsIFwic3RyaW5nXCIpO1xuICAgICAgICAgICAgbWVtYmVyTm9kZS5pbml0ID0gaW5pdC52YWx1ZTtcbiAgICAgICAgICAgIG1lbWJlcnMuc3RyaW5nTWVtYmVycy5wdXNoKHRoaXMuZmluaXNoTm9kZShtZW1iZXJOb2RlLCBcIkVudW1TdHJpbmdNZW1iZXJcIikpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICBjYXNlIFwiaW52YWxpZFwiOlxuICAgICAgICAgIHtcbiAgICAgICAgICAgIHRocm93IHRoaXMuZmxvd0VudW1FcnJvckludmFsaWRNZW1iZXJJbml0aWFsaXplcihpbml0LmxvYywgY29udGV4dCk7XG4gICAgICAgICAgfVxuICAgICAgICBjYXNlIFwibm9uZVwiOlxuICAgICAgICAgIHtcbiAgICAgICAgICAgIHN3aXRjaCAoZXhwbGljaXRUeXBlKSB7XG4gICAgICAgICAgICAgIGNhc2UgXCJib29sZWFuXCI6XG4gICAgICAgICAgICAgICAgdGhpcy5mbG93RW51bUVycm9yQm9vbGVhbk1lbWJlck5vdEluaXRpYWxpemVkKGluaXQubG9jLCBjb250ZXh0KTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgY2FzZSBcIm51bWJlclwiOlxuICAgICAgICAgICAgICAgIHRoaXMuZmxvd0VudW1FcnJvck51bWJlck1lbWJlck5vdEluaXRpYWxpemVkKGluaXQubG9jLCBjb250ZXh0KTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICBtZW1iZXJzLmRlZmF1bHRlZE1lbWJlcnMucHVzaCh0aGlzLmZpbmlzaE5vZGUobWVtYmVyTm9kZSwgXCJFbnVtRGVmYXVsdGVkTWVtYmVyXCIpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoIXRoaXMubWF0Y2goOCkpIHtcbiAgICAgICAgdGhpcy5leHBlY3QoMTIpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgbWVtYmVycyxcbiAgICAgIGhhc1Vua25vd25NZW1iZXJzXG4gICAgfTtcbiAgfVxuICBmbG93RW51bVN0cmluZ01lbWJlcnMoaW5pdGlhbGl6ZWRNZW1iZXJzLCBkZWZhdWx0ZWRNZW1iZXJzLCB7XG4gICAgZW51bU5hbWVcbiAgfSkge1xuICAgIGlmIChpbml0aWFsaXplZE1lbWJlcnMubGVuZ3RoID09PSAwKSB7XG4gICAgICByZXR1cm4gZGVmYXVsdGVkTWVtYmVycztcbiAgICB9IGVsc2UgaWYgKGRlZmF1bHRlZE1lbWJlcnMubGVuZ3RoID09PSAwKSB7XG4gICAgICByZXR1cm4gaW5pdGlhbGl6ZWRNZW1iZXJzO1xuICAgIH0gZWxzZSBpZiAoZGVmYXVsdGVkTWVtYmVycy5sZW5ndGggPiBpbml0aWFsaXplZE1lbWJlcnMubGVuZ3RoKSB7XG4gICAgICBmb3IgKGNvbnN0IG1lbWJlciBvZiBpbml0aWFsaXplZE1lbWJlcnMpIHtcbiAgICAgICAgdGhpcy5mbG93RW51bUVycm9yU3RyaW5nTWVtYmVySW5jb25zaXN0ZW50bHlJbml0aWFsaXplZChtZW1iZXIsIHtcbiAgICAgICAgICBlbnVtTmFtZVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBkZWZhdWx0ZWRNZW1iZXJzO1xuICAgIH0gZWxzZSB7XG4gICAgICBmb3IgKGNvbnN0IG1lbWJlciBvZiBkZWZhdWx0ZWRNZW1iZXJzKSB7XG4gICAgICAgIHRoaXMuZmxvd0VudW1FcnJvclN0cmluZ01lbWJlckluY29uc2lzdGVudGx5SW5pdGlhbGl6ZWQobWVtYmVyLCB7XG4gICAgICAgICAgZW51bU5hbWVcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gaW5pdGlhbGl6ZWRNZW1iZXJzO1xuICAgIH1cbiAgfVxuICBmbG93RW51bVBhcnNlRXhwbGljaXRUeXBlKHtcbiAgICBlbnVtTmFtZVxuICB9KSB7XG4gICAgaWYgKCF0aGlzLmVhdENvbnRleHR1YWwoMTAyKSkgcmV0dXJuIG51bGw7XG4gICAgaWYgKCF0b2tlbklzSWRlbnRpZmllcih0aGlzLnN0YXRlLnR5cGUpKSB7XG4gICAgICB0aHJvdyB0aGlzLnJhaXNlKEZsb3dFcnJvcnMuRW51bUludmFsaWRFeHBsaWNpdFR5cGVVbmtub3duU3VwcGxpZWQsIHRoaXMuc3RhdGUuc3RhcnRMb2MsIHtcbiAgICAgICAgZW51bU5hbWVcbiAgICAgIH0pO1xuICAgIH1cbiAgICBjb25zdCB7XG4gICAgICB2YWx1ZVxuICAgIH0gPSB0aGlzLnN0YXRlO1xuICAgIHRoaXMubmV4dCgpO1xuICAgIGlmICh2YWx1ZSAhPT0gXCJib29sZWFuXCIgJiYgdmFsdWUgIT09IFwibnVtYmVyXCIgJiYgdmFsdWUgIT09IFwic3RyaW5nXCIgJiYgdmFsdWUgIT09IFwic3ltYm9sXCIpIHtcbiAgICAgIHRoaXMucmFpc2UoRmxvd0Vycm9ycy5FbnVtSW52YWxpZEV4cGxpY2l0VHlwZSwgdGhpcy5zdGF0ZS5zdGFydExvYywge1xuICAgICAgICBlbnVtTmFtZSxcbiAgICAgICAgaW52YWxpZEVudW1UeXBlOiB2YWx1ZVxuICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiB2YWx1ZTtcbiAgfVxuICBmbG93RW51bUJvZHkobm9kZSwgaWQpIHtcbiAgICBjb25zdCBlbnVtTmFtZSA9IGlkLm5hbWU7XG4gICAgY29uc3QgbmFtZUxvYyA9IGlkLmxvYy5zdGFydDtcbiAgICBjb25zdCBleHBsaWNpdFR5cGUgPSB0aGlzLmZsb3dFbnVtUGFyc2VFeHBsaWNpdFR5cGUoe1xuICAgICAgZW51bU5hbWVcbiAgICB9KTtcbiAgICB0aGlzLmV4cGVjdCg1KTtcbiAgICBjb25zdCB7XG4gICAgICBtZW1iZXJzLFxuICAgICAgaGFzVW5rbm93bk1lbWJlcnNcbiAgICB9ID0gdGhpcy5mbG93RW51bU1lbWJlcnMoe1xuICAgICAgZW51bU5hbWUsXG4gICAgICBleHBsaWNpdFR5cGVcbiAgICB9KTtcbiAgICBub2RlLmhhc1Vua25vd25NZW1iZXJzID0gaGFzVW5rbm93bk1lbWJlcnM7XG4gICAgc3dpdGNoIChleHBsaWNpdFR5cGUpIHtcbiAgICAgIGNhc2UgXCJib29sZWFuXCI6XG4gICAgICAgIG5vZGUuZXhwbGljaXRUeXBlID0gdHJ1ZTtcbiAgICAgICAgbm9kZS5tZW1iZXJzID0gbWVtYmVycy5ib29sZWFuTWVtYmVycztcbiAgICAgICAgdGhpcy5leHBlY3QoOCk7XG4gICAgICAgIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJFbnVtQm9vbGVhbkJvZHlcIik7XG4gICAgICBjYXNlIFwibnVtYmVyXCI6XG4gICAgICAgIG5vZGUuZXhwbGljaXRUeXBlID0gdHJ1ZTtcbiAgICAgICAgbm9kZS5tZW1iZXJzID0gbWVtYmVycy5udW1iZXJNZW1iZXJzO1xuICAgICAgICB0aGlzLmV4cGVjdCg4KTtcbiAgICAgICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIkVudW1OdW1iZXJCb2R5XCIpO1xuICAgICAgY2FzZSBcInN0cmluZ1wiOlxuICAgICAgICBub2RlLmV4cGxpY2l0VHlwZSA9IHRydWU7XG4gICAgICAgIG5vZGUubWVtYmVycyA9IHRoaXMuZmxvd0VudW1TdHJpbmdNZW1iZXJzKG1lbWJlcnMuc3RyaW5nTWVtYmVycywgbWVtYmVycy5kZWZhdWx0ZWRNZW1iZXJzLCB7XG4gICAgICAgICAgZW51bU5hbWVcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuZXhwZWN0KDgpO1xuICAgICAgICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiRW51bVN0cmluZ0JvZHlcIik7XG4gICAgICBjYXNlIFwic3ltYm9sXCI6XG4gICAgICAgIG5vZGUubWVtYmVycyA9IG1lbWJlcnMuZGVmYXVsdGVkTWVtYmVycztcbiAgICAgICAgdGhpcy5leHBlY3QoOCk7XG4gICAgICAgIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJFbnVtU3ltYm9sQm9keVwiKTtcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHtcbiAgICAgICAgICBjb25zdCBlbXB0eSA9ICgpID0+IHtcbiAgICAgICAgICAgIG5vZGUubWVtYmVycyA9IFtdO1xuICAgICAgICAgICAgdGhpcy5leHBlY3QoOCk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiRW51bVN0cmluZ0JvZHlcIik7XG4gICAgICAgICAgfTtcbiAgICAgICAgICBub2RlLmV4cGxpY2l0VHlwZSA9IGZhbHNlO1xuICAgICAgICAgIGNvbnN0IGJvb2xzTGVuID0gbWVtYmVycy5ib29sZWFuTWVtYmVycy5sZW5ndGg7XG4gICAgICAgICAgY29uc3QgbnVtc0xlbiA9IG1lbWJlcnMubnVtYmVyTWVtYmVycy5sZW5ndGg7XG4gICAgICAgICAgY29uc3Qgc3Ryc0xlbiA9IG1lbWJlcnMuc3RyaW5nTWVtYmVycy5sZW5ndGg7XG4gICAgICAgICAgY29uc3QgZGVmYXVsdGVkTGVuID0gbWVtYmVycy5kZWZhdWx0ZWRNZW1iZXJzLmxlbmd0aDtcbiAgICAgICAgICBpZiAoIWJvb2xzTGVuICYmICFudW1zTGVuICYmICFzdHJzTGVuICYmICFkZWZhdWx0ZWRMZW4pIHtcbiAgICAgICAgICAgIHJldHVybiBlbXB0eSgpO1xuICAgICAgICAgIH0gZWxzZSBpZiAoIWJvb2xzTGVuICYmICFudW1zTGVuKSB7XG4gICAgICAgICAgICBub2RlLm1lbWJlcnMgPSB0aGlzLmZsb3dFbnVtU3RyaW5nTWVtYmVycyhtZW1iZXJzLnN0cmluZ01lbWJlcnMsIG1lbWJlcnMuZGVmYXVsdGVkTWVtYmVycywge1xuICAgICAgICAgICAgICBlbnVtTmFtZVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB0aGlzLmV4cGVjdCg4KTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJFbnVtU3RyaW5nQm9keVwiKTtcbiAgICAgICAgICB9IGVsc2UgaWYgKCFudW1zTGVuICYmICFzdHJzTGVuICYmIGJvb2xzTGVuID49IGRlZmF1bHRlZExlbikge1xuICAgICAgICAgICAgZm9yIChjb25zdCBtZW1iZXIgb2YgbWVtYmVycy5kZWZhdWx0ZWRNZW1iZXJzKSB7XG4gICAgICAgICAgICAgIHRoaXMuZmxvd0VudW1FcnJvckJvb2xlYW5NZW1iZXJOb3RJbml0aWFsaXplZChtZW1iZXIubG9jLnN0YXJ0LCB7XG4gICAgICAgICAgICAgICAgZW51bU5hbWUsXG4gICAgICAgICAgICAgICAgbWVtYmVyTmFtZTogbWVtYmVyLmlkLm5hbWVcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBub2RlLm1lbWJlcnMgPSBtZW1iZXJzLmJvb2xlYW5NZW1iZXJzO1xuICAgICAgICAgICAgdGhpcy5leHBlY3QoOCk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiRW51bUJvb2xlYW5Cb2R5XCIpO1xuICAgICAgICAgIH0gZWxzZSBpZiAoIWJvb2xzTGVuICYmICFzdHJzTGVuICYmIG51bXNMZW4gPj0gZGVmYXVsdGVkTGVuKSB7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IG1lbWJlciBvZiBtZW1iZXJzLmRlZmF1bHRlZE1lbWJlcnMpIHtcbiAgICAgICAgICAgICAgdGhpcy5mbG93RW51bUVycm9yTnVtYmVyTWVtYmVyTm90SW5pdGlhbGl6ZWQobWVtYmVyLmxvYy5zdGFydCwge1xuICAgICAgICAgICAgICAgIGVudW1OYW1lLFxuICAgICAgICAgICAgICAgIG1lbWJlck5hbWU6IG1lbWJlci5pZC5uYW1lXG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbm9kZS5tZW1iZXJzID0gbWVtYmVycy5udW1iZXJNZW1iZXJzO1xuICAgICAgICAgICAgdGhpcy5leHBlY3QoOCk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiRW51bU51bWJlckJvZHlcIik7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMucmFpc2UoRmxvd0Vycm9ycy5FbnVtSW5jb25zaXN0ZW50TWVtYmVyVmFsdWVzLCBuYW1lTG9jLCB7XG4gICAgICAgICAgICAgIGVudW1OYW1lXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiBlbXB0eSgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgfVxuICBmbG93UGFyc2VFbnVtRGVjbGFyYXRpb24obm9kZSkge1xuICAgIGNvbnN0IGlkID0gdGhpcy5wYXJzZUlkZW50aWZpZXIoKTtcbiAgICBub2RlLmlkID0gaWQ7XG4gICAgbm9kZS5ib2R5ID0gdGhpcy5mbG93RW51bUJvZHkodGhpcy5zdGFydE5vZGUoKSwgaWQpO1xuICAgIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJFbnVtRGVjbGFyYXRpb25cIik7XG4gIH1cbiAganN4UGFyc2VPcGVuaW5nRWxlbWVudEFmdGVyTmFtZShub2RlKSB7XG4gICAgaWYgKHRoaXMuc2hvdWxkUGFyc2VUeXBlcygpKSB7XG4gICAgICBpZiAodGhpcy5tYXRjaCg0NykgfHwgdGhpcy5tYXRjaCg1MSkpIHtcbiAgICAgICAgbm9kZS50eXBlQXJndW1lbnRzID0gdGhpcy5mbG93UGFyc2VUeXBlUGFyYW1ldGVySW5zdGFudGlhdGlvbkluRXhwcmVzc2lvbigpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gc3VwZXIuanN4UGFyc2VPcGVuaW5nRWxlbWVudEFmdGVyTmFtZShub2RlKTtcbiAgfVxuICBpc0xvb2thaGVhZFRva2VuX2x0KCkge1xuICAgIGNvbnN0IG5leHQgPSB0aGlzLm5leHRUb2tlblN0YXJ0KCk7XG4gICAgaWYgKHRoaXMuaW5wdXQuY2hhckNvZGVBdChuZXh0KSA9PT0gNjApIHtcbiAgICAgIGNvbnN0IGFmdGVyTmV4dCA9IHRoaXMuaW5wdXQuY2hhckNvZGVBdChuZXh0ICsgMSk7XG4gICAgICByZXR1cm4gYWZ0ZXJOZXh0ICE9PSA2MCAmJiBhZnRlck5leHQgIT09IDYxO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgcmVTY2FuX2x0X2d0KCkge1xuICAgIGNvbnN0IHtcbiAgICAgIHR5cGVcbiAgICB9ID0gdGhpcy5zdGF0ZTtcbiAgICBpZiAodHlwZSA9PT0gNDcpIHtcbiAgICAgIHRoaXMuc3RhdGUucG9zIC09IDE7XG4gICAgICB0aGlzLnJlYWRUb2tlbl9sdCgpO1xuICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gNDgpIHtcbiAgICAgIHRoaXMuc3RhdGUucG9zIC09IDE7XG4gICAgICB0aGlzLnJlYWRUb2tlbl9ndCgpO1xuICAgIH1cbiAgfVxuICByZVNjYW5fbHQoKSB7XG4gICAgY29uc3Qge1xuICAgICAgdHlwZVxuICAgIH0gPSB0aGlzLnN0YXRlO1xuICAgIGlmICh0eXBlID09PSA1MSkge1xuICAgICAgdGhpcy5zdGF0ZS5wb3MgLT0gMjtcbiAgICAgIHRoaXMuZmluaXNoT3AoNDcsIDEpO1xuICAgICAgcmV0dXJuIDQ3O1xuICAgIH1cbiAgICByZXR1cm4gdHlwZTtcbiAgfVxuICBtYXliZVVud3JhcFR5cGVDYXN0RXhwcmVzc2lvbihub2RlKSB7XG4gICAgcmV0dXJuIG5vZGUudHlwZSA9PT0gXCJUeXBlQ2FzdEV4cHJlc3Npb25cIiA/IG5vZGUuZXhwcmVzc2lvbiA6IG5vZGU7XG4gIH1cbn07XG5jb25zdCBlbnRpdGllcyA9IHtcbiAgX19wcm90b19fOiBudWxsLFxuICBxdW90OiBcIlxcdTAwMjJcIixcbiAgYW1wOiBcIiZcIixcbiAgYXBvczogXCJcXHUwMDI3XCIsXG4gIGx0OiBcIjxcIixcbiAgZ3Q6IFwiPlwiLFxuICBuYnNwOiBcIlxcdTAwQTBcIixcbiAgaWV4Y2w6IFwiXFx1MDBBMVwiLFxuICBjZW50OiBcIlxcdTAwQTJcIixcbiAgcG91bmQ6IFwiXFx1MDBBM1wiLFxuICBjdXJyZW46IFwiXFx1MDBBNFwiLFxuICB5ZW46IFwiXFx1MDBBNVwiLFxuICBicnZiYXI6IFwiXFx1MDBBNlwiLFxuICBzZWN0OiBcIlxcdTAwQTdcIixcbiAgdW1sOiBcIlxcdTAwQThcIixcbiAgY29weTogXCJcXHUwMEE5XCIsXG4gIG9yZGY6IFwiXFx1MDBBQVwiLFxuICBsYXF1bzogXCJcXHUwMEFCXCIsXG4gIG5vdDogXCJcXHUwMEFDXCIsXG4gIHNoeTogXCJcXHUwMEFEXCIsXG4gIHJlZzogXCJcXHUwMEFFXCIsXG4gIG1hY3I6IFwiXFx1MDBBRlwiLFxuICBkZWc6IFwiXFx1MDBCMFwiLFxuICBwbHVzbW46IFwiXFx1MDBCMVwiLFxuICBzdXAyOiBcIlxcdTAwQjJcIixcbiAgc3VwMzogXCJcXHUwMEIzXCIsXG4gIGFjdXRlOiBcIlxcdTAwQjRcIixcbiAgbWljcm86IFwiXFx1MDBCNVwiLFxuICBwYXJhOiBcIlxcdTAwQjZcIixcbiAgbWlkZG90OiBcIlxcdTAwQjdcIixcbiAgY2VkaWw6IFwiXFx1MDBCOFwiLFxuICBzdXAxOiBcIlxcdTAwQjlcIixcbiAgb3JkbTogXCJcXHUwMEJBXCIsXG4gIHJhcXVvOiBcIlxcdTAwQkJcIixcbiAgZnJhYzE0OiBcIlxcdTAwQkNcIixcbiAgZnJhYzEyOiBcIlxcdTAwQkRcIixcbiAgZnJhYzM0OiBcIlxcdTAwQkVcIixcbiAgaXF1ZXN0OiBcIlxcdTAwQkZcIixcbiAgQWdyYXZlOiBcIlxcdTAwQzBcIixcbiAgQWFjdXRlOiBcIlxcdTAwQzFcIixcbiAgQWNpcmM6IFwiXFx1MDBDMlwiLFxuICBBdGlsZGU6IFwiXFx1MDBDM1wiLFxuICBBdW1sOiBcIlxcdTAwQzRcIixcbiAgQXJpbmc6IFwiXFx1MDBDNVwiLFxuICBBRWxpZzogXCJcXHUwMEM2XCIsXG4gIENjZWRpbDogXCJcXHUwMEM3XCIsXG4gIEVncmF2ZTogXCJcXHUwMEM4XCIsXG4gIEVhY3V0ZTogXCJcXHUwMEM5XCIsXG4gIEVjaXJjOiBcIlxcdTAwQ0FcIixcbiAgRXVtbDogXCJcXHUwMENCXCIsXG4gIElncmF2ZTogXCJcXHUwMENDXCIsXG4gIElhY3V0ZTogXCJcXHUwMENEXCIsXG4gIEljaXJjOiBcIlxcdTAwQ0VcIixcbiAgSXVtbDogXCJcXHUwMENGXCIsXG4gIEVUSDogXCJcXHUwMEQwXCIsXG4gIE50aWxkZTogXCJcXHUwMEQxXCIsXG4gIE9ncmF2ZTogXCJcXHUwMEQyXCIsXG4gIE9hY3V0ZTogXCJcXHUwMEQzXCIsXG4gIE9jaXJjOiBcIlxcdTAwRDRcIixcbiAgT3RpbGRlOiBcIlxcdTAwRDVcIixcbiAgT3VtbDogXCJcXHUwMEQ2XCIsXG4gIHRpbWVzOiBcIlxcdTAwRDdcIixcbiAgT3NsYXNoOiBcIlxcdTAwRDhcIixcbiAgVWdyYXZlOiBcIlxcdTAwRDlcIixcbiAgVWFjdXRlOiBcIlxcdTAwREFcIixcbiAgVWNpcmM6IFwiXFx1MDBEQlwiLFxuICBVdW1sOiBcIlxcdTAwRENcIixcbiAgWWFjdXRlOiBcIlxcdTAwRERcIixcbiAgVEhPUk46IFwiXFx1MDBERVwiLFxuICBzemxpZzogXCJcXHUwMERGXCIsXG4gIGFncmF2ZTogXCJcXHUwMEUwXCIsXG4gIGFhY3V0ZTogXCJcXHUwMEUxXCIsXG4gIGFjaXJjOiBcIlxcdTAwRTJcIixcbiAgYXRpbGRlOiBcIlxcdTAwRTNcIixcbiAgYXVtbDogXCJcXHUwMEU0XCIsXG4gIGFyaW5nOiBcIlxcdTAwRTVcIixcbiAgYWVsaWc6IFwiXFx1MDBFNlwiLFxuICBjY2VkaWw6IFwiXFx1MDBFN1wiLFxuICBlZ3JhdmU6IFwiXFx1MDBFOFwiLFxuICBlYWN1dGU6IFwiXFx1MDBFOVwiLFxuICBlY2lyYzogXCJcXHUwMEVBXCIsXG4gIGV1bWw6IFwiXFx1MDBFQlwiLFxuICBpZ3JhdmU6IFwiXFx1MDBFQ1wiLFxuICBpYWN1dGU6IFwiXFx1MDBFRFwiLFxuICBpY2lyYzogXCJcXHUwMEVFXCIsXG4gIGl1bWw6IFwiXFx1MDBFRlwiLFxuICBldGg6IFwiXFx1MDBGMFwiLFxuICBudGlsZGU6IFwiXFx1MDBGMVwiLFxuICBvZ3JhdmU6IFwiXFx1MDBGMlwiLFxuICBvYWN1dGU6IFwiXFx1MDBGM1wiLFxuICBvY2lyYzogXCJcXHUwMEY0XCIsXG4gIG90aWxkZTogXCJcXHUwMEY1XCIsXG4gIG91bWw6IFwiXFx1MDBGNlwiLFxuICBkaXZpZGU6IFwiXFx1MDBGN1wiLFxuICBvc2xhc2g6IFwiXFx1MDBGOFwiLFxuICB1Z3JhdmU6IFwiXFx1MDBGOVwiLFxuICB1YWN1dGU6IFwiXFx1MDBGQVwiLFxuICB1Y2lyYzogXCJcXHUwMEZCXCIsXG4gIHV1bWw6IFwiXFx1MDBGQ1wiLFxuICB5YWN1dGU6IFwiXFx1MDBGRFwiLFxuICB0aG9ybjogXCJcXHUwMEZFXCIsXG4gIHl1bWw6IFwiXFx1MDBGRlwiLFxuICBPRWxpZzogXCJcXHUwMTUyXCIsXG4gIG9lbGlnOiBcIlxcdTAxNTNcIixcbiAgU2Nhcm9uOiBcIlxcdTAxNjBcIixcbiAgc2Nhcm9uOiBcIlxcdTAxNjFcIixcbiAgWXVtbDogXCJcXHUwMTc4XCIsXG4gIGZub2Y6IFwiXFx1MDE5MlwiLFxuICBjaXJjOiBcIlxcdTAyQzZcIixcbiAgdGlsZGU6IFwiXFx1MDJEQ1wiLFxuICBBbHBoYTogXCJcXHUwMzkxXCIsXG4gIEJldGE6IFwiXFx1MDM5MlwiLFxuICBHYW1tYTogXCJcXHUwMzkzXCIsXG4gIERlbHRhOiBcIlxcdTAzOTRcIixcbiAgRXBzaWxvbjogXCJcXHUwMzk1XCIsXG4gIFpldGE6IFwiXFx1MDM5NlwiLFxuICBFdGE6IFwiXFx1MDM5N1wiLFxuICBUaGV0YTogXCJcXHUwMzk4XCIsXG4gIElvdGE6IFwiXFx1MDM5OVwiLFxuICBLYXBwYTogXCJcXHUwMzlBXCIsXG4gIExhbWJkYTogXCJcXHUwMzlCXCIsXG4gIE11OiBcIlxcdTAzOUNcIixcbiAgTnU6IFwiXFx1MDM5RFwiLFxuICBYaTogXCJcXHUwMzlFXCIsXG4gIE9taWNyb246IFwiXFx1MDM5RlwiLFxuICBQaTogXCJcXHUwM0EwXCIsXG4gIFJobzogXCJcXHUwM0ExXCIsXG4gIFNpZ21hOiBcIlxcdTAzQTNcIixcbiAgVGF1OiBcIlxcdTAzQTRcIixcbiAgVXBzaWxvbjogXCJcXHUwM0E1XCIsXG4gIFBoaTogXCJcXHUwM0E2XCIsXG4gIENoaTogXCJcXHUwM0E3XCIsXG4gIFBzaTogXCJcXHUwM0E4XCIsXG4gIE9tZWdhOiBcIlxcdTAzQTlcIixcbiAgYWxwaGE6IFwiXFx1MDNCMVwiLFxuICBiZXRhOiBcIlxcdTAzQjJcIixcbiAgZ2FtbWE6IFwiXFx1MDNCM1wiLFxuICBkZWx0YTogXCJcXHUwM0I0XCIsXG4gIGVwc2lsb246IFwiXFx1MDNCNVwiLFxuICB6ZXRhOiBcIlxcdTAzQjZcIixcbiAgZXRhOiBcIlxcdTAzQjdcIixcbiAgdGhldGE6IFwiXFx1MDNCOFwiLFxuICBpb3RhOiBcIlxcdTAzQjlcIixcbiAga2FwcGE6IFwiXFx1MDNCQVwiLFxuICBsYW1iZGE6IFwiXFx1MDNCQlwiLFxuICBtdTogXCJcXHUwM0JDXCIsXG4gIG51OiBcIlxcdTAzQkRcIixcbiAgeGk6IFwiXFx1MDNCRVwiLFxuICBvbWljcm9uOiBcIlxcdTAzQkZcIixcbiAgcGk6IFwiXFx1MDNDMFwiLFxuICByaG86IFwiXFx1MDNDMVwiLFxuICBzaWdtYWY6IFwiXFx1MDNDMlwiLFxuICBzaWdtYTogXCJcXHUwM0MzXCIsXG4gIHRhdTogXCJcXHUwM0M0XCIsXG4gIHVwc2lsb246IFwiXFx1MDNDNVwiLFxuICBwaGk6IFwiXFx1MDNDNlwiLFxuICBjaGk6IFwiXFx1MDNDN1wiLFxuICBwc2k6IFwiXFx1MDNDOFwiLFxuICBvbWVnYTogXCJcXHUwM0M5XCIsXG4gIHRoZXRhc3ltOiBcIlxcdTAzRDFcIixcbiAgdXBzaWg6IFwiXFx1MDNEMlwiLFxuICBwaXY6IFwiXFx1MDNENlwiLFxuICBlbnNwOiBcIlxcdTIwMDJcIixcbiAgZW1zcDogXCJcXHUyMDAzXCIsXG4gIHRoaW5zcDogXCJcXHUyMDA5XCIsXG4gIHp3bmo6IFwiXFx1MjAwQ1wiLFxuICB6d2o6IFwiXFx1MjAwRFwiLFxuICBscm06IFwiXFx1MjAwRVwiLFxuICBybG06IFwiXFx1MjAwRlwiLFxuICBuZGFzaDogXCJcXHUyMDEzXCIsXG4gIG1kYXNoOiBcIlxcdTIwMTRcIixcbiAgbHNxdW86IFwiXFx1MjAxOFwiLFxuICByc3F1bzogXCJcXHUyMDE5XCIsXG4gIHNicXVvOiBcIlxcdTIwMUFcIixcbiAgbGRxdW86IFwiXFx1MjAxQ1wiLFxuICByZHF1bzogXCJcXHUyMDFEXCIsXG4gIGJkcXVvOiBcIlxcdTIwMUVcIixcbiAgZGFnZ2VyOiBcIlxcdTIwMjBcIixcbiAgRGFnZ2VyOiBcIlxcdTIwMjFcIixcbiAgYnVsbDogXCJcXHUyMDIyXCIsXG4gIGhlbGxpcDogXCJcXHUyMDI2XCIsXG4gIHBlcm1pbDogXCJcXHUyMDMwXCIsXG4gIHByaW1lOiBcIlxcdTIwMzJcIixcbiAgUHJpbWU6IFwiXFx1MjAzM1wiLFxuICBsc2FxdW86IFwiXFx1MjAzOVwiLFxuICByc2FxdW86IFwiXFx1MjAzQVwiLFxuICBvbGluZTogXCJcXHUyMDNFXCIsXG4gIGZyYXNsOiBcIlxcdTIwNDRcIixcbiAgZXVybzogXCJcXHUyMEFDXCIsXG4gIGltYWdlOiBcIlxcdTIxMTFcIixcbiAgd2VpZXJwOiBcIlxcdTIxMThcIixcbiAgcmVhbDogXCJcXHUyMTFDXCIsXG4gIHRyYWRlOiBcIlxcdTIxMjJcIixcbiAgYWxlZnN5bTogXCJcXHUyMTM1XCIsXG4gIGxhcnI6IFwiXFx1MjE5MFwiLFxuICB1YXJyOiBcIlxcdTIxOTFcIixcbiAgcmFycjogXCJcXHUyMTkyXCIsXG4gIGRhcnI6IFwiXFx1MjE5M1wiLFxuICBoYXJyOiBcIlxcdTIxOTRcIixcbiAgY3JhcnI6IFwiXFx1MjFCNVwiLFxuICBsQXJyOiBcIlxcdTIxRDBcIixcbiAgdUFycjogXCJcXHUyMUQxXCIsXG4gIHJBcnI6IFwiXFx1MjFEMlwiLFxuICBkQXJyOiBcIlxcdTIxRDNcIixcbiAgaEFycjogXCJcXHUyMUQ0XCIsXG4gIGZvcmFsbDogXCJcXHUyMjAwXCIsXG4gIHBhcnQ6IFwiXFx1MjIwMlwiLFxuICBleGlzdDogXCJcXHUyMjAzXCIsXG4gIGVtcHR5OiBcIlxcdTIyMDVcIixcbiAgbmFibGE6IFwiXFx1MjIwN1wiLFxuICBpc2luOiBcIlxcdTIyMDhcIixcbiAgbm90aW46IFwiXFx1MjIwOVwiLFxuICBuaTogXCJcXHUyMjBCXCIsXG4gIHByb2Q6IFwiXFx1MjIwRlwiLFxuICBzdW06IFwiXFx1MjIxMVwiLFxuICBtaW51czogXCJcXHUyMjEyXCIsXG4gIGxvd2FzdDogXCJcXHUyMjE3XCIsXG4gIHJhZGljOiBcIlxcdTIyMUFcIixcbiAgcHJvcDogXCJcXHUyMjFEXCIsXG4gIGluZmluOiBcIlxcdTIyMUVcIixcbiAgYW5nOiBcIlxcdTIyMjBcIixcbiAgYW5kOiBcIlxcdTIyMjdcIixcbiAgb3I6IFwiXFx1MjIyOFwiLFxuICBjYXA6IFwiXFx1MjIyOVwiLFxuICBjdXA6IFwiXFx1MjIyQVwiLFxuICBpbnQ6IFwiXFx1MjIyQlwiLFxuICB0aGVyZTQ6IFwiXFx1MjIzNFwiLFxuICBzaW06IFwiXFx1MjIzQ1wiLFxuICBjb25nOiBcIlxcdTIyNDVcIixcbiAgYXN5bXA6IFwiXFx1MjI0OFwiLFxuICBuZTogXCJcXHUyMjYwXCIsXG4gIGVxdWl2OiBcIlxcdTIyNjFcIixcbiAgbGU6IFwiXFx1MjI2NFwiLFxuICBnZTogXCJcXHUyMjY1XCIsXG4gIHN1YjogXCJcXHUyMjgyXCIsXG4gIHN1cDogXCJcXHUyMjgzXCIsXG4gIG5zdWI6IFwiXFx1MjI4NFwiLFxuICBzdWJlOiBcIlxcdTIyODZcIixcbiAgc3VwZTogXCJcXHUyMjg3XCIsXG4gIG9wbHVzOiBcIlxcdTIyOTVcIixcbiAgb3RpbWVzOiBcIlxcdTIyOTdcIixcbiAgcGVycDogXCJcXHUyMkE1XCIsXG4gIHNkb3Q6IFwiXFx1MjJDNVwiLFxuICBsY2VpbDogXCJcXHUyMzA4XCIsXG4gIHJjZWlsOiBcIlxcdTIzMDlcIixcbiAgbGZsb29yOiBcIlxcdTIzMEFcIixcbiAgcmZsb29yOiBcIlxcdTIzMEJcIixcbiAgbGFuZzogXCJcXHUyMzI5XCIsXG4gIHJhbmc6IFwiXFx1MjMyQVwiLFxuICBsb3o6IFwiXFx1MjVDQVwiLFxuICBzcGFkZXM6IFwiXFx1MjY2MFwiLFxuICBjbHViczogXCJcXHUyNjYzXCIsXG4gIGhlYXJ0czogXCJcXHUyNjY1XCIsXG4gIGRpYW1zOiBcIlxcdTI2NjZcIlxufTtcbmNvbnN0IGxpbmVCcmVhayA9IC9cXHJcXG58W1xcclxcblxcdTIwMjhcXHUyMDI5XS87XG5jb25zdCBsaW5lQnJlYWtHID0gbmV3IFJlZ0V4cChsaW5lQnJlYWsuc291cmNlLCBcImdcIik7XG5mdW5jdGlvbiBpc05ld0xpbmUoY29kZSkge1xuICBzd2l0Y2ggKGNvZGUpIHtcbiAgICBjYXNlIDEwOlxuICAgIGNhc2UgMTM6XG4gICAgY2FzZSA4MjMyOlxuICAgIGNhc2UgODIzMzpcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gZmFsc2U7XG4gIH1cbn1cbmZ1bmN0aW9uIGhhc05ld0xpbmUoaW5wdXQsIHN0YXJ0LCBlbmQpIHtcbiAgZm9yIChsZXQgaSA9IHN0YXJ0OyBpIDwgZW5kOyBpKyspIHtcbiAgICBpZiAoaXNOZXdMaW5lKGlucHV0LmNoYXJDb2RlQXQoaSkpKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufVxuY29uc3Qgc2tpcFdoaXRlU3BhY2UgPSAvKD86XFxzfFxcL1xcLy4qfFxcL1xcKlteXSo/XFwqXFwvKSovZztcbmNvbnN0IHNraXBXaGl0ZVNwYWNlSW5MaW5lID0gLyg/OlteXFxTXFxuXFxyXFx1MjAyOFxcdTIwMjldfFxcL1xcLy4qfFxcL1xcKi4qP1xcKlxcLykqL2c7XG5mdW5jdGlvbiBpc1doaXRlc3BhY2UoY29kZSkge1xuICBzd2l0Y2ggKGNvZGUpIHtcbiAgICBjYXNlIDB4MDAwOTpcbiAgICBjYXNlIDB4MDAwYjpcbiAgICBjYXNlIDB4MDAwYzpcbiAgICBjYXNlIDMyOlxuICAgIGNhc2UgMTYwOlxuICAgIGNhc2UgNTc2MDpcbiAgICBjYXNlIDB4MjAwMDpcbiAgICBjYXNlIDB4MjAwMTpcbiAgICBjYXNlIDB4MjAwMjpcbiAgICBjYXNlIDB4MjAwMzpcbiAgICBjYXNlIDB4MjAwNDpcbiAgICBjYXNlIDB4MjAwNTpcbiAgICBjYXNlIDB4MjAwNjpcbiAgICBjYXNlIDB4MjAwNzpcbiAgICBjYXNlIDB4MjAwODpcbiAgICBjYXNlIDB4MjAwOTpcbiAgICBjYXNlIDB4MjAwYTpcbiAgICBjYXNlIDB4MjAyZjpcbiAgICBjYXNlIDB4MjA1ZjpcbiAgICBjYXNlIDB4MzAwMDpcbiAgICBjYXNlIDB4ZmVmZjpcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gZmFsc2U7XG4gIH1cbn1cbmNvbnN0IEpzeEVycm9ycyA9IFBhcnNlRXJyb3JFbnVtYGpzeGAoe1xuICBBdHRyaWJ1dGVJc0VtcHR5OiBcIkpTWCBhdHRyaWJ1dGVzIG11c3Qgb25seSBiZSBhc3NpZ25lZCBhIG5vbi1lbXB0eSBleHByZXNzaW9uLlwiLFxuICBNaXNzaW5nQ2xvc2luZ1RhZ0VsZW1lbnQ6ICh7XG4gICAgb3BlbmluZ1RhZ05hbWVcbiAgfSkgPT4gYEV4cGVjdGVkIGNvcnJlc3BvbmRpbmcgSlNYIGNsb3NpbmcgdGFnIGZvciA8JHtvcGVuaW5nVGFnTmFtZX0+LmAsXG4gIE1pc3NpbmdDbG9zaW5nVGFnRnJhZ21lbnQ6IFwiRXhwZWN0ZWQgY29ycmVzcG9uZGluZyBKU1ggY2xvc2luZyB0YWcgZm9yIDw+LlwiLFxuICBVbmV4cGVjdGVkU2VxdWVuY2VFeHByZXNzaW9uOiBcIlNlcXVlbmNlIGV4cHJlc3Npb25zIGNhbm5vdCBiZSBkaXJlY3RseSBuZXN0ZWQgaW5zaWRlIEpTWC4gRGlkIHlvdSBtZWFuIHRvIHdyYXAgaXQgaW4gcGFyZW50aGVzZXMgKC4uLik/XCIsXG4gIFVuZXhwZWN0ZWRUb2tlbjogKHtcbiAgICB1bmV4cGVjdGVkLFxuICAgIEhUTUxFbnRpdHlcbiAgfSkgPT4gYFVuZXhwZWN0ZWQgdG9rZW4gXFxgJHt1bmV4cGVjdGVkfVxcYC4gRGlkIHlvdSBtZWFuIFxcYCR7SFRNTEVudGl0eX1cXGAgb3IgXFxgeycke3VuZXhwZWN0ZWR9J31cXGA/YCxcbiAgVW5zdXBwb3J0ZWRKc3hWYWx1ZTogXCJKU1ggdmFsdWUgc2hvdWxkIGJlIGVpdGhlciBhbiBleHByZXNzaW9uIG9yIGEgcXVvdGVkIEpTWCB0ZXh0LlwiLFxuICBVbnRlcm1pbmF0ZWRKc3hDb250ZW50OiBcIlVudGVybWluYXRlZCBKU1ggY29udGVudHMuXCIsXG4gIFVud3JhcHBlZEFkamFjZW50SlNYRWxlbWVudHM6IFwiQWRqYWNlbnQgSlNYIGVsZW1lbnRzIG11c3QgYmUgd3JhcHBlZCBpbiBhbiBlbmNsb3NpbmcgdGFnLiBEaWQgeW91IHdhbnQgYSBKU1ggZnJhZ21lbnQgPD4uLi48Lz4/XCJcbn0pO1xuZnVuY3Rpb24gaXNGcmFnbWVudChvYmplY3QpIHtcbiAgcmV0dXJuIG9iamVjdCA/IG9iamVjdC50eXBlID09PSBcIkpTWE9wZW5pbmdGcmFnbWVudFwiIHx8IG9iamVjdC50eXBlID09PSBcIkpTWENsb3NpbmdGcmFnbWVudFwiIDogZmFsc2U7XG59XG5mdW5jdGlvbiBnZXRRdWFsaWZpZWRKU1hOYW1lKG9iamVjdCkge1xuICBpZiAob2JqZWN0LnR5cGUgPT09IFwiSlNYSWRlbnRpZmllclwiKSB7XG4gICAgcmV0dXJuIG9iamVjdC5uYW1lO1xuICB9XG4gIGlmIChvYmplY3QudHlwZSA9PT0gXCJKU1hOYW1lc3BhY2VkTmFtZVwiKSB7XG4gICAgcmV0dXJuIG9iamVjdC5uYW1lc3BhY2UubmFtZSArIFwiOlwiICsgb2JqZWN0Lm5hbWUubmFtZTtcbiAgfVxuICBpZiAob2JqZWN0LnR5cGUgPT09IFwiSlNYTWVtYmVyRXhwcmVzc2lvblwiKSB7XG4gICAgcmV0dXJuIGdldFF1YWxpZmllZEpTWE5hbWUob2JqZWN0Lm9iamVjdCkgKyBcIi5cIiArIGdldFF1YWxpZmllZEpTWE5hbWUob2JqZWN0LnByb3BlcnR5KTtcbiAgfVxuICB0aHJvdyBuZXcgRXJyb3IoXCJOb2RlIGhhZCB1bmV4cGVjdGVkIHR5cGU6IFwiICsgb2JqZWN0LnR5cGUpO1xufVxudmFyIGpzeCA9IHN1cGVyQ2xhc3MgPT4gY2xhc3MgSlNYUGFyc2VyTWl4aW4gZXh0ZW5kcyBzdXBlckNsYXNzIHtcbiAganN4UmVhZFRva2VuKCkge1xuICAgIGxldCBvdXQgPSBcIlwiO1xuICAgIGxldCBjaHVua1N0YXJ0ID0gdGhpcy5zdGF0ZS5wb3M7XG4gICAgZm9yICg7Oykge1xuICAgICAgaWYgKHRoaXMuc3RhdGUucG9zID49IHRoaXMubGVuZ3RoKSB7XG4gICAgICAgIHRocm93IHRoaXMucmFpc2UoSnN4RXJyb3JzLlVudGVybWluYXRlZEpzeENvbnRlbnQsIHRoaXMuc3RhdGUuc3RhcnRMb2MpO1xuICAgICAgfVxuICAgICAgY29uc3QgY2ggPSB0aGlzLmlucHV0LmNoYXJDb2RlQXQodGhpcy5zdGF0ZS5wb3MpO1xuICAgICAgc3dpdGNoIChjaCkge1xuICAgICAgICBjYXNlIDYwOlxuICAgICAgICBjYXNlIDEyMzpcbiAgICAgICAgICBpZiAodGhpcy5zdGF0ZS5wb3MgPT09IHRoaXMuc3RhdGUuc3RhcnQpIHtcbiAgICAgICAgICAgIGlmIChjaCA9PT0gNjAgJiYgdGhpcy5zdGF0ZS5jYW5TdGFydEpTWEVsZW1lbnQpIHtcbiAgICAgICAgICAgICAgKyt0aGlzLnN0YXRlLnBvcztcbiAgICAgICAgICAgICAgdGhpcy5maW5pc2hUb2tlbigxNDMpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgc3VwZXIuZ2V0VG9rZW5Gcm9tQ29kZShjaCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICAgIG91dCArPSB0aGlzLmlucHV0LnNsaWNlKGNodW5rU3RhcnQsIHRoaXMuc3RhdGUucG9zKTtcbiAgICAgICAgICB0aGlzLmZpbmlzaFRva2VuKDE0Miwgb3V0KTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIGNhc2UgMzg6XG4gICAgICAgICAgb3V0ICs9IHRoaXMuaW5wdXQuc2xpY2UoY2h1bmtTdGFydCwgdGhpcy5zdGF0ZS5wb3MpO1xuICAgICAgICAgIG91dCArPSB0aGlzLmpzeFJlYWRFbnRpdHkoKTtcbiAgICAgICAgICBjaHVua1N0YXJ0ID0gdGhpcy5zdGF0ZS5wb3M7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgNjI6XG4gICAgICAgIGNhc2UgMTI1OlxuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIGlmIChpc05ld0xpbmUoY2gpKSB7XG4gICAgICAgICAgICBvdXQgKz0gdGhpcy5pbnB1dC5zbGljZShjaHVua1N0YXJ0LCB0aGlzLnN0YXRlLnBvcyk7XG4gICAgICAgICAgICBvdXQgKz0gdGhpcy5qc3hSZWFkTmV3TGluZSh0cnVlKTtcbiAgICAgICAgICAgIGNodW5rU3RhcnQgPSB0aGlzLnN0YXRlLnBvcztcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgKyt0aGlzLnN0YXRlLnBvcztcbiAgICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGpzeFJlYWROZXdMaW5lKG5vcm1hbGl6ZUNSTEYpIHtcbiAgICBjb25zdCBjaCA9IHRoaXMuaW5wdXQuY2hhckNvZGVBdCh0aGlzLnN0YXRlLnBvcyk7XG4gICAgbGV0IG91dDtcbiAgICArK3RoaXMuc3RhdGUucG9zO1xuICAgIGlmIChjaCA9PT0gMTMgJiYgdGhpcy5pbnB1dC5jaGFyQ29kZUF0KHRoaXMuc3RhdGUucG9zKSA9PT0gMTApIHtcbiAgICAgICsrdGhpcy5zdGF0ZS5wb3M7XG4gICAgICBvdXQgPSBub3JtYWxpemVDUkxGID8gXCJcXG5cIiA6IFwiXFxyXFxuXCI7XG4gICAgfSBlbHNlIHtcbiAgICAgIG91dCA9IFN0cmluZy5mcm9tQ2hhckNvZGUoY2gpO1xuICAgIH1cbiAgICArK3RoaXMuc3RhdGUuY3VyTGluZTtcbiAgICB0aGlzLnN0YXRlLmxpbmVTdGFydCA9IHRoaXMuc3RhdGUucG9zO1xuICAgIHJldHVybiBvdXQ7XG4gIH1cbiAganN4UmVhZFN0cmluZyhxdW90ZSkge1xuICAgIGxldCBvdXQgPSBcIlwiO1xuICAgIGxldCBjaHVua1N0YXJ0ID0gKyt0aGlzLnN0YXRlLnBvcztcbiAgICBmb3IgKDs7KSB7XG4gICAgICBpZiAodGhpcy5zdGF0ZS5wb3MgPj0gdGhpcy5sZW5ndGgpIHtcbiAgICAgICAgdGhyb3cgdGhpcy5yYWlzZShFcnJvcnMuVW50ZXJtaW5hdGVkU3RyaW5nLCB0aGlzLnN0YXRlLnN0YXJ0TG9jKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGNoID0gdGhpcy5pbnB1dC5jaGFyQ29kZUF0KHRoaXMuc3RhdGUucG9zKTtcbiAgICAgIGlmIChjaCA9PT0gcXVvdGUpIGJyZWFrO1xuICAgICAgaWYgKGNoID09PSAzOCkge1xuICAgICAgICBvdXQgKz0gdGhpcy5pbnB1dC5zbGljZShjaHVua1N0YXJ0LCB0aGlzLnN0YXRlLnBvcyk7XG4gICAgICAgIG91dCArPSB0aGlzLmpzeFJlYWRFbnRpdHkoKTtcbiAgICAgICAgY2h1bmtTdGFydCA9IHRoaXMuc3RhdGUucG9zO1xuICAgICAgfSBlbHNlIGlmIChpc05ld0xpbmUoY2gpKSB7XG4gICAgICAgIG91dCArPSB0aGlzLmlucHV0LnNsaWNlKGNodW5rU3RhcnQsIHRoaXMuc3RhdGUucG9zKTtcbiAgICAgICAgb3V0ICs9IHRoaXMuanN4UmVhZE5ld0xpbmUoZmFsc2UpO1xuICAgICAgICBjaHVua1N0YXJ0ID0gdGhpcy5zdGF0ZS5wb3M7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICArK3RoaXMuc3RhdGUucG9zO1xuICAgICAgfVxuICAgIH1cbiAgICBvdXQgKz0gdGhpcy5pbnB1dC5zbGljZShjaHVua1N0YXJ0LCB0aGlzLnN0YXRlLnBvcysrKTtcbiAgICB0aGlzLmZpbmlzaFRva2VuKDEzNCwgb3V0KTtcbiAgfVxuICBqc3hSZWFkRW50aXR5KCkge1xuICAgIGNvbnN0IHN0YXJ0UG9zID0gKyt0aGlzLnN0YXRlLnBvcztcbiAgICBpZiAodGhpcy5jb2RlUG9pbnRBdFBvcyh0aGlzLnN0YXRlLnBvcykgPT09IDM1KSB7XG4gICAgICArK3RoaXMuc3RhdGUucG9zO1xuICAgICAgbGV0IHJhZGl4ID0gMTA7XG4gICAgICBpZiAodGhpcy5jb2RlUG9pbnRBdFBvcyh0aGlzLnN0YXRlLnBvcykgPT09IDEyMCkge1xuICAgICAgICByYWRpeCA9IDE2O1xuICAgICAgICArK3RoaXMuc3RhdGUucG9zO1xuICAgICAgfVxuICAgICAgY29uc3QgY29kZVBvaW50ID0gdGhpcy5yZWFkSW50KHJhZGl4LCB1bmRlZmluZWQsIGZhbHNlLCBcImJhaWxcIik7XG4gICAgICBpZiAoY29kZVBvaW50ICE9PSBudWxsICYmIHRoaXMuY29kZVBvaW50QXRQb3ModGhpcy5zdGF0ZS5wb3MpID09PSA1OSkge1xuICAgICAgICArK3RoaXMuc3RhdGUucG9zO1xuICAgICAgICByZXR1cm4gU3RyaW5nLmZyb21Db2RlUG9pbnQoY29kZVBvaW50KTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgbGV0IGNvdW50ID0gMDtcbiAgICAgIGxldCBzZW1pID0gZmFsc2U7XG4gICAgICB3aGlsZSAoY291bnQrKyA8IDEwICYmIHRoaXMuc3RhdGUucG9zIDwgdGhpcy5sZW5ndGggJiYgIShzZW1pID0gdGhpcy5jb2RlUG9pbnRBdFBvcyh0aGlzLnN0YXRlLnBvcykgPT09IDU5KSkge1xuICAgICAgICArK3RoaXMuc3RhdGUucG9zO1xuICAgICAgfVxuICAgICAgaWYgKHNlbWkpIHtcbiAgICAgICAgY29uc3QgZGVzYyA9IHRoaXMuaW5wdXQuc2xpY2Uoc3RhcnRQb3MsIHRoaXMuc3RhdGUucG9zKTtcbiAgICAgICAgY29uc3QgZW50aXR5ID0gZW50aXRpZXNbZGVzY107XG4gICAgICAgICsrdGhpcy5zdGF0ZS5wb3M7XG4gICAgICAgIGlmIChlbnRpdHkpIHtcbiAgICAgICAgICByZXR1cm4gZW50aXR5O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHRoaXMuc3RhdGUucG9zID0gc3RhcnRQb3M7XG4gICAgcmV0dXJuIFwiJlwiO1xuICB9XG4gIGpzeFJlYWRXb3JkKCkge1xuICAgIGxldCBjaDtcbiAgICBjb25zdCBzdGFydCA9IHRoaXMuc3RhdGUucG9zO1xuICAgIGRvIHtcbiAgICAgIGNoID0gdGhpcy5pbnB1dC5jaGFyQ29kZUF0KCsrdGhpcy5zdGF0ZS5wb3MpO1xuICAgIH0gd2hpbGUgKGlzSWRlbnRpZmllckNoYXIoY2gpIHx8IGNoID09PSA0NSk7XG4gICAgdGhpcy5maW5pc2hUb2tlbigxNDEsIHRoaXMuaW5wdXQuc2xpY2Uoc3RhcnQsIHRoaXMuc3RhdGUucG9zKSk7XG4gIH1cbiAganN4UGFyc2VJZGVudGlmaWVyKCkge1xuICAgIGNvbnN0IG5vZGUgPSB0aGlzLnN0YXJ0Tm9kZSgpO1xuICAgIGlmICh0aGlzLm1hdGNoKDE0MSkpIHtcbiAgICAgIG5vZGUubmFtZSA9IHRoaXMuc3RhdGUudmFsdWU7XG4gICAgfSBlbHNlIGlmICh0b2tlbklzS2V5d29yZCh0aGlzLnN0YXRlLnR5cGUpKSB7XG4gICAgICBub2RlLm5hbWUgPSB0b2tlbkxhYmVsTmFtZSh0aGlzLnN0YXRlLnR5cGUpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnVuZXhwZWN0ZWQoKTtcbiAgICB9XG4gICAgdGhpcy5uZXh0KCk7XG4gICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIkpTWElkZW50aWZpZXJcIik7XG4gIH1cbiAganN4UGFyc2VOYW1lc3BhY2VkTmFtZSgpIHtcbiAgICBjb25zdCBzdGFydExvYyA9IHRoaXMuc3RhdGUuc3RhcnRMb2M7XG4gICAgY29uc3QgbmFtZSA9IHRoaXMuanN4UGFyc2VJZGVudGlmaWVyKCk7XG4gICAgaWYgKCF0aGlzLmVhdCgxNCkpIHJldHVybiBuYW1lO1xuICAgIGNvbnN0IG5vZGUgPSB0aGlzLnN0YXJ0Tm9kZUF0KHN0YXJ0TG9jKTtcbiAgICBub2RlLm5hbWVzcGFjZSA9IG5hbWU7XG4gICAgbm9kZS5uYW1lID0gdGhpcy5qc3hQYXJzZUlkZW50aWZpZXIoKTtcbiAgICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiSlNYTmFtZXNwYWNlZE5hbWVcIik7XG4gIH1cbiAganN4UGFyc2VFbGVtZW50TmFtZSgpIHtcbiAgICBjb25zdCBzdGFydExvYyA9IHRoaXMuc3RhdGUuc3RhcnRMb2M7XG4gICAgbGV0IG5vZGUgPSB0aGlzLmpzeFBhcnNlTmFtZXNwYWNlZE5hbWUoKTtcbiAgICBpZiAobm9kZS50eXBlID09PSBcIkpTWE5hbWVzcGFjZWROYW1lXCIpIHtcbiAgICAgIHJldHVybiBub2RlO1xuICAgIH1cbiAgICB3aGlsZSAodGhpcy5lYXQoMTYpKSB7XG4gICAgICBjb25zdCBuZXdOb2RlID0gdGhpcy5zdGFydE5vZGVBdChzdGFydExvYyk7XG4gICAgICBuZXdOb2RlLm9iamVjdCA9IG5vZGU7XG4gICAgICBuZXdOb2RlLnByb3BlcnR5ID0gdGhpcy5qc3hQYXJzZUlkZW50aWZpZXIoKTtcbiAgICAgIG5vZGUgPSB0aGlzLmZpbmlzaE5vZGUobmV3Tm9kZSwgXCJKU1hNZW1iZXJFeHByZXNzaW9uXCIpO1xuICAgIH1cbiAgICByZXR1cm4gbm9kZTtcbiAgfVxuICBqc3hQYXJzZUF0dHJpYnV0ZVZhbHVlKCkge1xuICAgIGxldCBub2RlO1xuICAgIHN3aXRjaCAodGhpcy5zdGF0ZS50eXBlKSB7XG4gICAgICBjYXNlIDU6XG4gICAgICAgIG5vZGUgPSB0aGlzLnN0YXJ0Tm9kZSgpO1xuICAgICAgICB0aGlzLnNldENvbnRleHQodHlwZXMuYnJhY2UpO1xuICAgICAgICB0aGlzLm5leHQoKTtcbiAgICAgICAgbm9kZSA9IHRoaXMuanN4UGFyc2VFeHByZXNzaW9uQ29udGFpbmVyKG5vZGUsIHR5cGVzLmpfb1RhZyk7XG4gICAgICAgIGlmIChub2RlLmV4cHJlc3Npb24udHlwZSA9PT0gXCJKU1hFbXB0eUV4cHJlc3Npb25cIikge1xuICAgICAgICAgIHRoaXMucmFpc2UoSnN4RXJyb3JzLkF0dHJpYnV0ZUlzRW1wdHksIG5vZGUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBub2RlO1xuICAgICAgY2FzZSAxNDM6XG4gICAgICBjYXNlIDEzNDpcbiAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VFeHByQXRvbSgpO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgdGhyb3cgdGhpcy5yYWlzZShKc3hFcnJvcnMuVW5zdXBwb3J0ZWRKc3hWYWx1ZSwgdGhpcy5zdGF0ZS5zdGFydExvYyk7XG4gICAgfVxuICB9XG4gIGpzeFBhcnNlRW1wdHlFeHByZXNzaW9uKCkge1xuICAgIGNvbnN0IG5vZGUgPSB0aGlzLnN0YXJ0Tm9kZUF0KHRoaXMuc3RhdGUubGFzdFRva0VuZExvYyk7XG4gICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZUF0KG5vZGUsIFwiSlNYRW1wdHlFeHByZXNzaW9uXCIsIHRoaXMuc3RhdGUuc3RhcnRMb2MpO1xuICB9XG4gIGpzeFBhcnNlU3ByZWFkQ2hpbGQobm9kZSkge1xuICAgIHRoaXMubmV4dCgpO1xuICAgIG5vZGUuZXhwcmVzc2lvbiA9IHRoaXMucGFyc2VFeHByZXNzaW9uKCk7XG4gICAgdGhpcy5zZXRDb250ZXh0KHR5cGVzLmpfZXhwcik7XG4gICAgdGhpcy5zdGF0ZS5jYW5TdGFydEpTWEVsZW1lbnQgPSB0cnVlO1xuICAgIHRoaXMuZXhwZWN0KDgpO1xuICAgIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJKU1hTcHJlYWRDaGlsZFwiKTtcbiAgfVxuICBqc3hQYXJzZUV4cHJlc3Npb25Db250YWluZXIobm9kZSwgcHJldmlvdXNDb250ZXh0KSB7XG4gICAgaWYgKHRoaXMubWF0Y2goOCkpIHtcbiAgICAgIG5vZGUuZXhwcmVzc2lvbiA9IHRoaXMuanN4UGFyc2VFbXB0eUV4cHJlc3Npb24oKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgZXhwcmVzc2lvbiA9IHRoaXMucGFyc2VFeHByZXNzaW9uKCk7XG4gICAgICBub2RlLmV4cHJlc3Npb24gPSBleHByZXNzaW9uO1xuICAgIH1cbiAgICB0aGlzLnNldENvbnRleHQocHJldmlvdXNDb250ZXh0KTtcbiAgICB0aGlzLnN0YXRlLmNhblN0YXJ0SlNYRWxlbWVudCA9IHRydWU7XG4gICAgdGhpcy5leHBlY3QoOCk7XG4gICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIkpTWEV4cHJlc3Npb25Db250YWluZXJcIik7XG4gIH1cbiAganN4UGFyc2VBdHRyaWJ1dGUoKSB7XG4gICAgY29uc3Qgbm9kZSA9IHRoaXMuc3RhcnROb2RlKCk7XG4gICAgaWYgKHRoaXMubWF0Y2goNSkpIHtcbiAgICAgIHRoaXMuc2V0Q29udGV4dCh0eXBlcy5icmFjZSk7XG4gICAgICB0aGlzLm5leHQoKTtcbiAgICAgIHRoaXMuZXhwZWN0KDIxKTtcbiAgICAgIG5vZGUuYXJndW1lbnQgPSB0aGlzLnBhcnNlTWF5YmVBc3NpZ25BbGxvd0luKCk7XG4gICAgICB0aGlzLnNldENvbnRleHQodHlwZXMual9vVGFnKTtcbiAgICAgIHRoaXMuc3RhdGUuY2FuU3RhcnRKU1hFbGVtZW50ID0gdHJ1ZTtcbiAgICAgIHRoaXMuZXhwZWN0KDgpO1xuICAgICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIkpTWFNwcmVhZEF0dHJpYnV0ZVwiKTtcbiAgICB9XG4gICAgbm9kZS5uYW1lID0gdGhpcy5qc3hQYXJzZU5hbWVzcGFjZWROYW1lKCk7XG4gICAgbm9kZS52YWx1ZSA9IHRoaXMuZWF0KDI5KSA/IHRoaXMuanN4UGFyc2VBdHRyaWJ1dGVWYWx1ZSgpIDogbnVsbDtcbiAgICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiSlNYQXR0cmlidXRlXCIpO1xuICB9XG4gIGpzeFBhcnNlT3BlbmluZ0VsZW1lbnRBdChzdGFydExvYykge1xuICAgIGNvbnN0IG5vZGUgPSB0aGlzLnN0YXJ0Tm9kZUF0KHN0YXJ0TG9jKTtcbiAgICBpZiAodGhpcy5lYXQoMTQ0KSkge1xuICAgICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIkpTWE9wZW5pbmdGcmFnbWVudFwiKTtcbiAgICB9XG4gICAgbm9kZS5uYW1lID0gdGhpcy5qc3hQYXJzZUVsZW1lbnROYW1lKCk7XG4gICAgcmV0dXJuIHRoaXMuanN4UGFyc2VPcGVuaW5nRWxlbWVudEFmdGVyTmFtZShub2RlKTtcbiAgfVxuICBqc3hQYXJzZU9wZW5pbmdFbGVtZW50QWZ0ZXJOYW1lKG5vZGUpIHtcbiAgICBjb25zdCBhdHRyaWJ1dGVzID0gW107XG4gICAgd2hpbGUgKCF0aGlzLm1hdGNoKDU2KSAmJiAhdGhpcy5tYXRjaCgxNDQpKSB7XG4gICAgICBhdHRyaWJ1dGVzLnB1c2godGhpcy5qc3hQYXJzZUF0dHJpYnV0ZSgpKTtcbiAgICB9XG4gICAgbm9kZS5hdHRyaWJ1dGVzID0gYXR0cmlidXRlcztcbiAgICBub2RlLnNlbGZDbG9zaW5nID0gdGhpcy5lYXQoNTYpO1xuICAgIHRoaXMuZXhwZWN0KDE0NCk7XG4gICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIkpTWE9wZW5pbmdFbGVtZW50XCIpO1xuICB9XG4gIGpzeFBhcnNlQ2xvc2luZ0VsZW1lbnRBdChzdGFydExvYykge1xuICAgIGNvbnN0IG5vZGUgPSB0aGlzLnN0YXJ0Tm9kZUF0KHN0YXJ0TG9jKTtcbiAgICBpZiAodGhpcy5lYXQoMTQ0KSkge1xuICAgICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIkpTWENsb3NpbmdGcmFnbWVudFwiKTtcbiAgICB9XG4gICAgbm9kZS5uYW1lID0gdGhpcy5qc3hQYXJzZUVsZW1lbnROYW1lKCk7XG4gICAgdGhpcy5leHBlY3QoMTQ0KTtcbiAgICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiSlNYQ2xvc2luZ0VsZW1lbnRcIik7XG4gIH1cbiAganN4UGFyc2VFbGVtZW50QXQoc3RhcnRMb2MpIHtcbiAgICBjb25zdCBub2RlID0gdGhpcy5zdGFydE5vZGVBdChzdGFydExvYyk7XG4gICAgY29uc3QgY2hpbGRyZW4gPSBbXTtcbiAgICBjb25zdCBvcGVuaW5nRWxlbWVudCA9IHRoaXMuanN4UGFyc2VPcGVuaW5nRWxlbWVudEF0KHN0YXJ0TG9jKTtcbiAgICBsZXQgY2xvc2luZ0VsZW1lbnQgPSBudWxsO1xuICAgIGlmICghb3BlbmluZ0VsZW1lbnQuc2VsZkNsb3NpbmcpIHtcbiAgICAgIGNvbnRlbnRzOiBmb3IgKDs7KSB7XG4gICAgICAgIHN3aXRjaCAodGhpcy5zdGF0ZS50eXBlKSB7XG4gICAgICAgICAgY2FzZSAxNDM6XG4gICAgICAgICAgICBzdGFydExvYyA9IHRoaXMuc3RhdGUuc3RhcnRMb2M7XG4gICAgICAgICAgICB0aGlzLm5leHQoKTtcbiAgICAgICAgICAgIGlmICh0aGlzLmVhdCg1NikpIHtcbiAgICAgICAgICAgICAgY2xvc2luZ0VsZW1lbnQgPSB0aGlzLmpzeFBhcnNlQ2xvc2luZ0VsZW1lbnRBdChzdGFydExvYyk7XG4gICAgICAgICAgICAgIGJyZWFrIGNvbnRlbnRzO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2hpbGRyZW4ucHVzaCh0aGlzLmpzeFBhcnNlRWxlbWVudEF0KHN0YXJ0TG9jKSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIDE0MjpcbiAgICAgICAgICAgIGNoaWxkcmVuLnB1c2godGhpcy5wYXJzZUxpdGVyYWwodGhpcy5zdGF0ZS52YWx1ZSwgXCJKU1hUZXh0XCIpKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgNTpcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgY29uc3Qgbm9kZSA9IHRoaXMuc3RhcnROb2RlKCk7XG4gICAgICAgICAgICAgIHRoaXMuc2V0Q29udGV4dCh0eXBlcy5icmFjZSk7XG4gICAgICAgICAgICAgIHRoaXMubmV4dCgpO1xuICAgICAgICAgICAgICBpZiAodGhpcy5tYXRjaCgyMSkpIHtcbiAgICAgICAgICAgICAgICBjaGlsZHJlbi5wdXNoKHRoaXMuanN4UGFyc2VTcHJlYWRDaGlsZChub2RlKSk7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgY2hpbGRyZW4ucHVzaCh0aGlzLmpzeFBhcnNlRXhwcmVzc2lvbkNvbnRhaW5lcihub2RlLCB0eXBlcy5qX2V4cHIpKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgdGhpcy51bmV4cGVjdGVkKCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChpc0ZyYWdtZW50KG9wZW5pbmdFbGVtZW50KSAmJiAhaXNGcmFnbWVudChjbG9zaW5nRWxlbWVudCkgJiYgY2xvc2luZ0VsZW1lbnQgIT09IG51bGwpIHtcbiAgICAgICAgdGhpcy5yYWlzZShKc3hFcnJvcnMuTWlzc2luZ0Nsb3NpbmdUYWdGcmFnbWVudCwgY2xvc2luZ0VsZW1lbnQpO1xuICAgICAgfSBlbHNlIGlmICghaXNGcmFnbWVudChvcGVuaW5nRWxlbWVudCkgJiYgaXNGcmFnbWVudChjbG9zaW5nRWxlbWVudCkpIHtcbiAgICAgICAgdGhpcy5yYWlzZShKc3hFcnJvcnMuTWlzc2luZ0Nsb3NpbmdUYWdFbGVtZW50LCBjbG9zaW5nRWxlbWVudCwge1xuICAgICAgICAgIG9wZW5pbmdUYWdOYW1lOiBnZXRRdWFsaWZpZWRKU1hOYW1lKG9wZW5pbmdFbGVtZW50Lm5hbWUpXG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIGlmICghaXNGcmFnbWVudChvcGVuaW5nRWxlbWVudCkgJiYgIWlzRnJhZ21lbnQoY2xvc2luZ0VsZW1lbnQpKSB7XG4gICAgICAgIGlmIChnZXRRdWFsaWZpZWRKU1hOYW1lKGNsb3NpbmdFbGVtZW50Lm5hbWUpICE9PSBnZXRRdWFsaWZpZWRKU1hOYW1lKG9wZW5pbmdFbGVtZW50Lm5hbWUpKSB7XG4gICAgICAgICAgdGhpcy5yYWlzZShKc3hFcnJvcnMuTWlzc2luZ0Nsb3NpbmdUYWdFbGVtZW50LCBjbG9zaW5nRWxlbWVudCwge1xuICAgICAgICAgICAgb3BlbmluZ1RhZ05hbWU6IGdldFF1YWxpZmllZEpTWE5hbWUob3BlbmluZ0VsZW1lbnQubmFtZSlcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBpZiAoaXNGcmFnbWVudChvcGVuaW5nRWxlbWVudCkpIHtcbiAgICAgIG5vZGUub3BlbmluZ0ZyYWdtZW50ID0gb3BlbmluZ0VsZW1lbnQ7XG4gICAgICBub2RlLmNsb3NpbmdGcmFnbWVudCA9IGNsb3NpbmdFbGVtZW50O1xuICAgIH0gZWxzZSB7XG4gICAgICBub2RlLm9wZW5pbmdFbGVtZW50ID0gb3BlbmluZ0VsZW1lbnQ7XG4gICAgICBub2RlLmNsb3NpbmdFbGVtZW50ID0gY2xvc2luZ0VsZW1lbnQ7XG4gICAgfVxuICAgIG5vZGUuY2hpbGRyZW4gPSBjaGlsZHJlbjtcbiAgICBpZiAodGhpcy5tYXRjaCg0NykpIHtcbiAgICAgIHRocm93IHRoaXMucmFpc2UoSnN4RXJyb3JzLlVud3JhcHBlZEFkamFjZW50SlNYRWxlbWVudHMsIHRoaXMuc3RhdGUuc3RhcnRMb2MpO1xuICAgIH1cbiAgICByZXR1cm4gaXNGcmFnbWVudChvcGVuaW5nRWxlbWVudCkgPyB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJKU1hGcmFnbWVudFwiKSA6IHRoaXMuZmluaXNoTm9kZShub2RlLCBcIkpTWEVsZW1lbnRcIik7XG4gIH1cbiAganN4UGFyc2VFbGVtZW50KCkge1xuICAgIGNvbnN0IHN0YXJ0TG9jID0gdGhpcy5zdGF0ZS5zdGFydExvYztcbiAgICB0aGlzLm5leHQoKTtcbiAgICByZXR1cm4gdGhpcy5qc3hQYXJzZUVsZW1lbnRBdChzdGFydExvYyk7XG4gIH1cbiAgc2V0Q29udGV4dChuZXdDb250ZXh0KSB7XG4gICAgY29uc3Qge1xuICAgICAgY29udGV4dFxuICAgIH0gPSB0aGlzLnN0YXRlO1xuICAgIGNvbnRleHRbY29udGV4dC5sZW5ndGggLSAxXSA9IG5ld0NvbnRleHQ7XG4gIH1cbiAgcGFyc2VFeHByQXRvbShyZWZFeHByZXNzaW9uRXJyb3JzKSB7XG4gICAgaWYgKHRoaXMubWF0Y2goMTQzKSkge1xuICAgICAgcmV0dXJuIHRoaXMuanN4UGFyc2VFbGVtZW50KCk7XG4gICAgfSBlbHNlIGlmICh0aGlzLm1hdGNoKDQ3KSAmJiB0aGlzLmlucHV0LmNoYXJDb2RlQXQodGhpcy5zdGF0ZS5wb3MpICE9PSAzMykge1xuICAgICAgdGhpcy5yZXBsYWNlVG9rZW4oMTQzKTtcbiAgICAgIHJldHVybiB0aGlzLmpzeFBhcnNlRWxlbWVudCgpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gc3VwZXIucGFyc2VFeHByQXRvbShyZWZFeHByZXNzaW9uRXJyb3JzKTtcbiAgICB9XG4gIH1cbiAgc2tpcFNwYWNlKCkge1xuICAgIGNvbnN0IGN1ckNvbnRleHQgPSB0aGlzLmN1ckNvbnRleHQoKTtcbiAgICBpZiAoIWN1ckNvbnRleHQucHJlc2VydmVTcGFjZSkgc3VwZXIuc2tpcFNwYWNlKCk7XG4gIH1cbiAgZ2V0VG9rZW5Gcm9tQ29kZShjb2RlKSB7XG4gICAgY29uc3QgY29udGV4dCA9IHRoaXMuY3VyQ29udGV4dCgpO1xuICAgIGlmIChjb250ZXh0ID09PSB0eXBlcy5qX2V4cHIpIHtcbiAgICAgIHRoaXMuanN4UmVhZFRva2VuKCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmIChjb250ZXh0ID09PSB0eXBlcy5qX29UYWcgfHwgY29udGV4dCA9PT0gdHlwZXMual9jVGFnKSB7XG4gICAgICBpZiAoaXNJZGVudGlmaWVyU3RhcnQoY29kZSkpIHtcbiAgICAgICAgdGhpcy5qc3hSZWFkV29yZCgpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZiAoY29kZSA9PT0gNjIpIHtcbiAgICAgICAgKyt0aGlzLnN0YXRlLnBvcztcbiAgICAgICAgdGhpcy5maW5pc2hUb2tlbigxNDQpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZiAoKGNvZGUgPT09IDM0IHx8IGNvZGUgPT09IDM5KSAmJiBjb250ZXh0ID09PSB0eXBlcy5qX29UYWcpIHtcbiAgICAgICAgdGhpcy5qc3hSZWFkU3RyaW5nKGNvZGUpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChjb2RlID09PSA2MCAmJiB0aGlzLnN0YXRlLmNhblN0YXJ0SlNYRWxlbWVudCAmJiB0aGlzLmlucHV0LmNoYXJDb2RlQXQodGhpcy5zdGF0ZS5wb3MgKyAxKSAhPT0gMzMpIHtcbiAgICAgICsrdGhpcy5zdGF0ZS5wb3M7XG4gICAgICB0aGlzLmZpbmlzaFRva2VuKDE0Myk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHN1cGVyLmdldFRva2VuRnJvbUNvZGUoY29kZSk7XG4gIH1cbiAgdXBkYXRlQ29udGV4dChwcmV2VHlwZSkge1xuICAgIGNvbnN0IHtcbiAgICAgIGNvbnRleHQsXG4gICAgICB0eXBlXG4gICAgfSA9IHRoaXMuc3RhdGU7XG4gICAgaWYgKHR5cGUgPT09IDU2ICYmIHByZXZUeXBlID09PSAxNDMpIHtcbiAgICAgIGNvbnRleHQuc3BsaWNlKC0yLCAyLCB0eXBlcy5qX2NUYWcpO1xuICAgICAgdGhpcy5zdGF0ZS5jYW5TdGFydEpTWEVsZW1lbnQgPSBmYWxzZTtcbiAgICB9IGVsc2UgaWYgKHR5cGUgPT09IDE0Mykge1xuICAgICAgY29udGV4dC5wdXNoKHR5cGVzLmpfb1RhZyk7XG4gICAgfSBlbHNlIGlmICh0eXBlID09PSAxNDQpIHtcbiAgICAgIGNvbnN0IG91dCA9IGNvbnRleHRbY29udGV4dC5sZW5ndGggLSAxXTtcbiAgICAgIGlmIChvdXQgPT09IHR5cGVzLmpfb1RhZyAmJiBwcmV2VHlwZSA9PT0gNTYgfHwgb3V0ID09PSB0eXBlcy5qX2NUYWcpIHtcbiAgICAgICAgY29udGV4dC5wb3AoKTtcbiAgICAgICAgdGhpcy5zdGF0ZS5jYW5TdGFydEpTWEVsZW1lbnQgPSBjb250ZXh0W2NvbnRleHQubGVuZ3RoIC0gMV0gPT09IHR5cGVzLmpfZXhwcjtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuc2V0Q29udGV4dCh0eXBlcy5qX2V4cHIpO1xuICAgICAgICB0aGlzLnN0YXRlLmNhblN0YXJ0SlNYRWxlbWVudCA9IHRydWU7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuc3RhdGUuY2FuU3RhcnRKU1hFbGVtZW50ID0gdG9rZW5Db21lc0JlZm9yZUV4cHJlc3Npb24odHlwZSk7XG4gICAgfVxuICB9XG59O1xuY2xhc3MgVHlwZVNjcmlwdFNjb3BlIGV4dGVuZHMgU2NvcGUge1xuICBjb25zdHJ1Y3RvciguLi5hcmdzKSB7XG4gICAgc3VwZXIoLi4uYXJncyk7XG4gICAgdGhpcy50c05hbWVzID0gbmV3IE1hcCgpO1xuICB9XG59XG5jbGFzcyBUeXBlU2NyaXB0U2NvcGVIYW5kbGVyIGV4dGVuZHMgU2NvcGVIYW5kbGVyIHtcbiAgY29uc3RydWN0b3IoLi4uYXJncykge1xuICAgIHN1cGVyKC4uLmFyZ3MpO1xuICAgIHRoaXMuaW1wb3J0c1N0YWNrID0gW107XG4gIH1cbiAgY3JlYXRlU2NvcGUoZmxhZ3MpIHtcbiAgICB0aGlzLmltcG9ydHNTdGFjay5wdXNoKG5ldyBTZXQoKSk7XG4gICAgcmV0dXJuIG5ldyBUeXBlU2NyaXB0U2NvcGUoZmxhZ3MpO1xuICB9XG4gIGVudGVyKGZsYWdzKSB7XG4gICAgaWYgKGZsYWdzID09PSAxMDI0KSB7XG4gICAgICB0aGlzLmltcG9ydHNTdGFjay5wdXNoKG5ldyBTZXQoKSk7XG4gICAgfVxuICAgIHN1cGVyLmVudGVyKGZsYWdzKTtcbiAgfVxuICBleGl0KCkge1xuICAgIGNvbnN0IGZsYWdzID0gc3VwZXIuZXhpdCgpO1xuICAgIGlmIChmbGFncyA9PT0gMTAyNCkge1xuICAgICAgdGhpcy5pbXBvcnRzU3RhY2sucG9wKCk7XG4gICAgfVxuICAgIHJldHVybiBmbGFncztcbiAgfVxuICBoYXNJbXBvcnQobmFtZSwgYWxsb3dTaGFkb3cpIHtcbiAgICBjb25zdCBsZW4gPSB0aGlzLmltcG9ydHNTdGFjay5sZW5ndGg7XG4gICAgaWYgKHRoaXMuaW1wb3J0c1N0YWNrW2xlbiAtIDFdLmhhcyhuYW1lKSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGlmICghYWxsb3dTaGFkb3cgJiYgbGVuID4gMSkge1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW4gLSAxOyBpKyspIHtcbiAgICAgICAgaWYgKHRoaXMuaW1wb3J0c1N0YWNrW2ldLmhhcyhuYW1lKSkgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBkZWNsYXJlTmFtZShuYW1lLCBiaW5kaW5nVHlwZSwgbG9jKSB7XG4gICAgaWYgKGJpbmRpbmdUeXBlICYgNDA5Nikge1xuICAgICAgaWYgKHRoaXMuaGFzSW1wb3J0KG5hbWUsIHRydWUpKSB7XG4gICAgICAgIHRoaXMucGFyc2VyLnJhaXNlKEVycm9ycy5WYXJSZWRlY2xhcmF0aW9uLCBsb2MsIHtcbiAgICAgICAgICBpZGVudGlmaWVyTmFtZTogbmFtZVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIHRoaXMuaW1wb3J0c1N0YWNrW3RoaXMuaW1wb3J0c1N0YWNrLmxlbmd0aCAtIDFdLmFkZChuYW1lKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3Qgc2NvcGUgPSB0aGlzLmN1cnJlbnRTY29wZSgpO1xuICAgIGxldCB0eXBlID0gc2NvcGUudHNOYW1lcy5nZXQobmFtZSkgfHwgMDtcbiAgICBpZiAoYmluZGluZ1R5cGUgJiAxMDI0KSB7XG4gICAgICB0aGlzLm1heWJlRXhwb3J0RGVmaW5lZChzY29wZSwgbmFtZSk7XG4gICAgICBzY29wZS50c05hbWVzLnNldChuYW1lLCB0eXBlIHwgMTYpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBzdXBlci5kZWNsYXJlTmFtZShuYW1lLCBiaW5kaW5nVHlwZSwgbG9jKTtcbiAgICBpZiAoYmluZGluZ1R5cGUgJiAyKSB7XG4gICAgICBpZiAoIShiaW5kaW5nVHlwZSAmIDEpKSB7XG4gICAgICAgIHRoaXMuY2hlY2tSZWRlY2xhcmF0aW9uSW5TY29wZShzY29wZSwgbmFtZSwgYmluZGluZ1R5cGUsIGxvYyk7XG4gICAgICAgIHRoaXMubWF5YmVFeHBvcnREZWZpbmVkKHNjb3BlLCBuYW1lKTtcbiAgICAgIH1cbiAgICAgIHR5cGUgPSB0eXBlIHwgMTtcbiAgICB9XG4gICAgaWYgKGJpbmRpbmdUeXBlICYgMjU2KSB7XG4gICAgICB0eXBlID0gdHlwZSB8IDI7XG4gICAgfVxuICAgIGlmIChiaW5kaW5nVHlwZSAmIDUxMikge1xuICAgICAgdHlwZSA9IHR5cGUgfCA0O1xuICAgIH1cbiAgICBpZiAoYmluZGluZ1R5cGUgJiAxMjgpIHtcbiAgICAgIHR5cGUgPSB0eXBlIHwgODtcbiAgICB9XG4gICAgaWYgKHR5cGUpIHNjb3BlLnRzTmFtZXMuc2V0KG5hbWUsIHR5cGUpO1xuICB9XG4gIGlzUmVkZWNsYXJlZEluU2NvcGUoc2NvcGUsIG5hbWUsIGJpbmRpbmdUeXBlKSB7XG4gICAgY29uc3QgdHlwZSA9IHNjb3BlLnRzTmFtZXMuZ2V0KG5hbWUpO1xuICAgIGlmICgodHlwZSAmIDIpID4gMCkge1xuICAgICAgaWYgKGJpbmRpbmdUeXBlICYgMjU2KSB7XG4gICAgICAgIGNvbnN0IGlzQ29uc3QgPSAhIShiaW5kaW5nVHlwZSAmIDUxMik7XG4gICAgICAgIGNvbnN0IHdhc0NvbnN0ID0gKHR5cGUgJiA0KSA+IDA7XG4gICAgICAgIHJldHVybiBpc0NvbnN0ICE9PSB3YXNDb25zdDtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBpZiAoYmluZGluZ1R5cGUgJiAxMjggJiYgKHR5cGUgJiA4KSA+IDApIHtcbiAgICAgIGlmIChzY29wZS5uYW1lcy5nZXQobmFtZSkgJiAyKSB7XG4gICAgICAgIHJldHVybiAhIShiaW5kaW5nVHlwZSAmIDEpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoYmluZGluZ1R5cGUgJiAyICYmICh0eXBlICYgMSkgPiAwKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIHN1cGVyLmlzUmVkZWNsYXJlZEluU2NvcGUoc2NvcGUsIG5hbWUsIGJpbmRpbmdUeXBlKTtcbiAgfVxuICBjaGVja0xvY2FsRXhwb3J0KGlkKSB7XG4gICAgY29uc3Qge1xuICAgICAgbmFtZVxuICAgIH0gPSBpZDtcbiAgICBpZiAodGhpcy5oYXNJbXBvcnQobmFtZSkpIHJldHVybjtcbiAgICBjb25zdCBsZW4gPSB0aGlzLnNjb3BlU3RhY2subGVuZ3RoO1xuICAgIGZvciAobGV0IGkgPSBsZW4gLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgY29uc3Qgc2NvcGUgPSB0aGlzLnNjb3BlU3RhY2tbaV07XG4gICAgICBjb25zdCB0eXBlID0gc2NvcGUudHNOYW1lcy5nZXQobmFtZSk7XG4gICAgICBpZiAoKHR5cGUgJiAxKSA+IDAgfHwgKHR5cGUgJiAxNikgPiAwKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICB9XG4gICAgc3VwZXIuY2hlY2tMb2NhbEV4cG9ydChpZCk7XG4gIH1cbn1cbmNsYXNzIFByb2R1Y3Rpb25QYXJhbWV0ZXJIYW5kbGVyIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgdGhpcy5zdGFja3MgPSBbXTtcbiAgfVxuICBlbnRlcihmbGFncykge1xuICAgIHRoaXMuc3RhY2tzLnB1c2goZmxhZ3MpO1xuICB9XG4gIGV4aXQoKSB7XG4gICAgdGhpcy5zdGFja3MucG9wKCk7XG4gIH1cbiAgY3VycmVudEZsYWdzKCkge1xuICAgIHJldHVybiB0aGlzLnN0YWNrc1t0aGlzLnN0YWNrcy5sZW5ndGggLSAxXTtcbiAgfVxuICBnZXQgaGFzQXdhaXQoKSB7XG4gICAgcmV0dXJuICh0aGlzLmN1cnJlbnRGbGFncygpICYgMikgPiAwO1xuICB9XG4gIGdldCBoYXNZaWVsZCgpIHtcbiAgICByZXR1cm4gKHRoaXMuY3VycmVudEZsYWdzKCkgJiAxKSA+IDA7XG4gIH1cbiAgZ2V0IGhhc1JldHVybigpIHtcbiAgICByZXR1cm4gKHRoaXMuY3VycmVudEZsYWdzKCkgJiA0KSA+IDA7XG4gIH1cbiAgZ2V0IGhhc0luKCkge1xuICAgIHJldHVybiAodGhpcy5jdXJyZW50RmxhZ3MoKSAmIDgpID4gMDtcbiAgfVxufVxuZnVuY3Rpb24gZnVuY3Rpb25GbGFncyhpc0FzeW5jLCBpc0dlbmVyYXRvcikge1xuICByZXR1cm4gKGlzQXN5bmMgPyAyIDogMCkgfCAoaXNHZW5lcmF0b3IgPyAxIDogMCk7XG59XG5jbGFzcyBCYXNlUGFyc2VyIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgdGhpcy5zYXdVbmFtYmlndW91c0VTTSA9IGZhbHNlO1xuICAgIHRoaXMuYW1iaWd1b3VzU2NyaXB0RGlmZmVyZW50QXN0ID0gZmFsc2U7XG4gIH1cbiAgc291cmNlVG9PZmZzZXRQb3Moc291cmNlUG9zKSB7XG4gICAgcmV0dXJuIHNvdXJjZVBvcyArIHRoaXMuc3RhcnRJbmRleDtcbiAgfVxuICBvZmZzZXRUb1NvdXJjZVBvcyhvZmZzZXRQb3MpIHtcbiAgICByZXR1cm4gb2Zmc2V0UG9zIC0gdGhpcy5zdGFydEluZGV4O1xuICB9XG4gIGhhc1BsdWdpbihwbHVnaW5Db25maWcpIHtcbiAgICBpZiAodHlwZW9mIHBsdWdpbkNvbmZpZyA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgcmV0dXJuIHRoaXMucGx1Z2lucy5oYXMocGx1Z2luQ29uZmlnKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgW3BsdWdpbk5hbWUsIHBsdWdpbk9wdGlvbnNdID0gcGx1Z2luQ29uZmlnO1xuICAgICAgaWYgKCF0aGlzLmhhc1BsdWdpbihwbHVnaW5OYW1lKSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICBjb25zdCBhY3R1YWxPcHRpb25zID0gdGhpcy5wbHVnaW5zLmdldChwbHVnaW5OYW1lKTtcbiAgICAgIGZvciAoY29uc3Qga2V5IG9mIE9iamVjdC5rZXlzKHBsdWdpbk9wdGlvbnMpKSB7XG4gICAgICAgIGlmICgoYWN0dWFsT3B0aW9ucyA9PSBudWxsID8gdm9pZCAwIDogYWN0dWFsT3B0aW9uc1trZXldKSAhPT0gcGx1Z2luT3B0aW9uc1trZXldKSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH1cbiAgZ2V0UGx1Z2luT3B0aW9uKHBsdWdpbiwgbmFtZSkge1xuICAgIHZhciBfdGhpcyRwbHVnaW5zJGdldDtcbiAgICByZXR1cm4gKF90aGlzJHBsdWdpbnMkZ2V0ID0gdGhpcy5wbHVnaW5zLmdldChwbHVnaW4pKSA9PSBudWxsID8gdm9pZCAwIDogX3RoaXMkcGx1Z2lucyRnZXRbbmFtZV07XG4gIH1cbn1cbmZ1bmN0aW9uIHNldFRyYWlsaW5nQ29tbWVudHMobm9kZSwgY29tbWVudHMpIHtcbiAgaWYgKG5vZGUudHJhaWxpbmdDb21tZW50cyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgbm9kZS50cmFpbGluZ0NvbW1lbnRzID0gY29tbWVudHM7XG4gIH0gZWxzZSB7XG4gICAgbm9kZS50cmFpbGluZ0NvbW1lbnRzLnVuc2hpZnQoLi4uY29tbWVudHMpO1xuICB9XG59XG5mdW5jdGlvbiBzZXRMZWFkaW5nQ29tbWVudHMobm9kZSwgY29tbWVudHMpIHtcbiAgaWYgKG5vZGUubGVhZGluZ0NvbW1lbnRzID09PSB1bmRlZmluZWQpIHtcbiAgICBub2RlLmxlYWRpbmdDb21tZW50cyA9IGNvbW1lbnRzO1xuICB9IGVsc2Uge1xuICAgIG5vZGUubGVhZGluZ0NvbW1lbnRzLnVuc2hpZnQoLi4uY29tbWVudHMpO1xuICB9XG59XG5mdW5jdGlvbiBzZXRJbm5lckNvbW1lbnRzKG5vZGUsIGNvbW1lbnRzKSB7XG4gIGlmIChub2RlLmlubmVyQ29tbWVudHMgPT09IHVuZGVmaW5lZCkge1xuICAgIG5vZGUuaW5uZXJDb21tZW50cyA9IGNvbW1lbnRzO1xuICB9IGVsc2Uge1xuICAgIG5vZGUuaW5uZXJDb21tZW50cy51bnNoaWZ0KC4uLmNvbW1lbnRzKTtcbiAgfVxufVxuZnVuY3Rpb24gYWRqdXN0SW5uZXJDb21tZW50cyhub2RlLCBlbGVtZW50cywgY29tbWVudFdTKSB7XG4gIGxldCBsYXN0RWxlbWVudCA9IG51bGw7XG4gIGxldCBpID0gZWxlbWVudHMubGVuZ3RoO1xuICB3aGlsZSAobGFzdEVsZW1lbnQgPT09IG51bGwgJiYgaSA+IDApIHtcbiAgICBsYXN0RWxlbWVudCA9IGVsZW1lbnRzWy0taV07XG4gIH1cbiAgaWYgKGxhc3RFbGVtZW50ID09PSBudWxsIHx8IGxhc3RFbGVtZW50LnN0YXJ0ID4gY29tbWVudFdTLnN0YXJ0KSB7XG4gICAgc2V0SW5uZXJDb21tZW50cyhub2RlLCBjb21tZW50V1MuY29tbWVudHMpO1xuICB9IGVsc2Uge1xuICAgIHNldFRyYWlsaW5nQ29tbWVudHMobGFzdEVsZW1lbnQsIGNvbW1lbnRXUy5jb21tZW50cyk7XG4gIH1cbn1cbmNsYXNzIENvbW1lbnRzUGFyc2VyIGV4dGVuZHMgQmFzZVBhcnNlciB7XG4gIGFkZENvbW1lbnQoY29tbWVudCkge1xuICAgIGlmICh0aGlzLmZpbGVuYW1lKSBjb21tZW50LmxvYy5maWxlbmFtZSA9IHRoaXMuZmlsZW5hbWU7XG4gICAgY29uc3Qge1xuICAgICAgY29tbWVudHNMZW5cbiAgICB9ID0gdGhpcy5zdGF0ZTtcbiAgICBpZiAodGhpcy5jb21tZW50cy5sZW5ndGggIT09IGNvbW1lbnRzTGVuKSB7XG4gICAgICB0aGlzLmNvbW1lbnRzLmxlbmd0aCA9IGNvbW1lbnRzTGVuO1xuICAgIH1cbiAgICB0aGlzLmNvbW1lbnRzLnB1c2goY29tbWVudCk7XG4gICAgdGhpcy5zdGF0ZS5jb21tZW50c0xlbisrO1xuICB9XG4gIHByb2Nlc3NDb21tZW50KG5vZGUpIHtcbiAgICBjb25zdCB7XG4gICAgICBjb21tZW50U3RhY2tcbiAgICB9ID0gdGhpcy5zdGF0ZTtcbiAgICBjb25zdCBjb21tZW50U3RhY2tMZW5ndGggPSBjb21tZW50U3RhY2subGVuZ3RoO1xuICAgIGlmIChjb21tZW50U3RhY2tMZW5ndGggPT09IDApIHJldHVybjtcbiAgICBsZXQgaSA9IGNvbW1lbnRTdGFja0xlbmd0aCAtIDE7XG4gICAgY29uc3QgbGFzdENvbW1lbnRXUyA9IGNvbW1lbnRTdGFja1tpXTtcbiAgICBpZiAobGFzdENvbW1lbnRXUy5zdGFydCA9PT0gbm9kZS5lbmQpIHtcbiAgICAgIGxhc3RDb21tZW50V1MubGVhZGluZ05vZGUgPSBub2RlO1xuICAgICAgaS0tO1xuICAgIH1cbiAgICBjb25zdCB7XG4gICAgICBzdGFydDogbm9kZVN0YXJ0XG4gICAgfSA9IG5vZGU7XG4gICAgZm9yICg7IGkgPj0gMDsgaS0tKSB7XG4gICAgICBjb25zdCBjb21tZW50V1MgPSBjb21tZW50U3RhY2tbaV07XG4gICAgICBjb25zdCBjb21tZW50RW5kID0gY29tbWVudFdTLmVuZDtcbiAgICAgIGlmIChjb21tZW50RW5kID4gbm9kZVN0YXJ0KSB7XG4gICAgICAgIGNvbW1lbnRXUy5jb250YWluaW5nTm9kZSA9IG5vZGU7XG4gICAgICAgIHRoaXMuZmluYWxpemVDb21tZW50KGNvbW1lbnRXUyk7XG4gICAgICAgIGNvbW1lbnRTdGFjay5zcGxpY2UoaSwgMSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoY29tbWVudEVuZCA9PT0gbm9kZVN0YXJ0KSB7XG4gICAgICAgICAgY29tbWVudFdTLnRyYWlsaW5nTm9kZSA9IG5vZGU7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGZpbmFsaXplQ29tbWVudChjb21tZW50V1MpIHtcbiAgICB2YXIgX25vZGUkb3B0aW9ucztcbiAgICBjb25zdCB7XG4gICAgICBjb21tZW50c1xuICAgIH0gPSBjb21tZW50V1M7XG4gICAgaWYgKGNvbW1lbnRXUy5sZWFkaW5nTm9kZSAhPT0gbnVsbCB8fCBjb21tZW50V1MudHJhaWxpbmdOb2RlICE9PSBudWxsKSB7XG4gICAgICBpZiAoY29tbWVudFdTLmxlYWRpbmdOb2RlICE9PSBudWxsKSB7XG4gICAgICAgIHNldFRyYWlsaW5nQ29tbWVudHMoY29tbWVudFdTLmxlYWRpbmdOb2RlLCBjb21tZW50cyk7XG4gICAgICB9XG4gICAgICBpZiAoY29tbWVudFdTLnRyYWlsaW5nTm9kZSAhPT0gbnVsbCkge1xuICAgICAgICBzZXRMZWFkaW5nQ29tbWVudHMoY29tbWVudFdTLnRyYWlsaW5nTm9kZSwgY29tbWVudHMpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBub2RlID0gY29tbWVudFdTLmNvbnRhaW5pbmdOb2RlO1xuICAgICAgY29uc3QgY29tbWVudFN0YXJ0ID0gY29tbWVudFdTLnN0YXJ0O1xuICAgICAgaWYgKHRoaXMuaW5wdXQuY2hhckNvZGVBdCh0aGlzLm9mZnNldFRvU291cmNlUG9zKGNvbW1lbnRTdGFydCkgLSAxKSA9PT0gNDQpIHtcbiAgICAgICAgc3dpdGNoIChub2RlLnR5cGUpIHtcbiAgICAgICAgICBjYXNlIFwiT2JqZWN0RXhwcmVzc2lvblwiOlxuICAgICAgICAgIGNhc2UgXCJPYmplY3RQYXR0ZXJuXCI6XG4gICAgICAgICAgICBhZGp1c3RJbm5lckNvbW1lbnRzKG5vZGUsIG5vZGUucHJvcGVydGllcywgY29tbWVudFdTKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgXCJDYWxsRXhwcmVzc2lvblwiOlxuICAgICAgICAgIGNhc2UgXCJPcHRpb25hbENhbGxFeHByZXNzaW9uXCI6XG4gICAgICAgICAgICBhZGp1c3RJbm5lckNvbW1lbnRzKG5vZGUsIG5vZGUuYXJndW1lbnRzLCBjb21tZW50V1MpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSBcIkltcG9ydEV4cHJlc3Npb25cIjpcbiAgICAgICAgICAgIGFkanVzdElubmVyQ29tbWVudHMobm9kZSwgW25vZGUuc291cmNlLCAoX25vZGUkb3B0aW9ucyA9IG5vZGUub3B0aW9ucykgIT0gbnVsbCA/IF9ub2RlJG9wdGlvbnMgOiBudWxsXSwgY29tbWVudFdTKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgXCJGdW5jdGlvbkRlY2xhcmF0aW9uXCI6XG4gICAgICAgICAgY2FzZSBcIkZ1bmN0aW9uRXhwcmVzc2lvblwiOlxuICAgICAgICAgIGNhc2UgXCJBcnJvd0Z1bmN0aW9uRXhwcmVzc2lvblwiOlxuICAgICAgICAgIGNhc2UgXCJPYmplY3RNZXRob2RcIjpcbiAgICAgICAgICBjYXNlIFwiQ2xhc3NNZXRob2RcIjpcbiAgICAgICAgICBjYXNlIFwiQ2xhc3NQcml2YXRlTWV0aG9kXCI6XG4gICAgICAgICAgICBhZGp1c3RJbm5lckNvbW1lbnRzKG5vZGUsIG5vZGUucGFyYW1zLCBjb21tZW50V1MpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSBcIkFycmF5RXhwcmVzc2lvblwiOlxuICAgICAgICAgIGNhc2UgXCJBcnJheVBhdHRlcm5cIjpcbiAgICAgICAgICAgIGFkanVzdElubmVyQ29tbWVudHMobm9kZSwgbm9kZS5lbGVtZW50cywgY29tbWVudFdTKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgXCJFeHBvcnROYW1lZERlY2xhcmF0aW9uXCI6XG4gICAgICAgICAgY2FzZSBcIkltcG9ydERlY2xhcmF0aW9uXCI6XG4gICAgICAgICAgICBhZGp1c3RJbm5lckNvbW1lbnRzKG5vZGUsIG5vZGUuc3BlY2lmaWVycywgY29tbWVudFdTKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgXCJUU0VudW1EZWNsYXJhdGlvblwiOlxuICAgICAgICAgICAgYWRqdXN0SW5uZXJDb21tZW50cyhub2RlLCBub2RlLm1lbWJlcnMsIGNvbW1lbnRXUyk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIFwiVFNFbnVtQm9keVwiOlxuICAgICAgICAgICAgYWRqdXN0SW5uZXJDb21tZW50cyhub2RlLCBub2RlLm1lbWJlcnMsIGNvbW1lbnRXUyk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICBpZiAobm9kZS50eXBlID09PSBcIlJlY29yZEV4cHJlc3Npb25cIikge1xuICAgICAgICAgICAgICAgIGFkanVzdElubmVyQ29tbWVudHMobm9kZSwgbm9kZS5wcm9wZXJ0aWVzLCBjb21tZW50V1MpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGlmIChub2RlLnR5cGUgPT09IFwiVHVwbGVFeHByZXNzaW9uXCIpIHtcbiAgICAgICAgICAgICAgICBhZGp1c3RJbm5lckNvbW1lbnRzKG5vZGUsIG5vZGUuZWxlbWVudHMsIGNvbW1lbnRXUyk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgc2V0SW5uZXJDb21tZW50cyhub2RlLCBjb21tZW50cyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHNldElubmVyQ29tbWVudHMobm9kZSwgY29tbWVudHMpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBmaW5hbGl6ZVJlbWFpbmluZ0NvbW1lbnRzKCkge1xuICAgIGNvbnN0IHtcbiAgICAgIGNvbW1lbnRTdGFja1xuICAgIH0gPSB0aGlzLnN0YXRlO1xuICAgIGZvciAobGV0IGkgPSBjb21tZW50U3RhY2subGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgIHRoaXMuZmluYWxpemVDb21tZW50KGNvbW1lbnRTdGFja1tpXSk7XG4gICAgfVxuICAgIHRoaXMuc3RhdGUuY29tbWVudFN0YWNrID0gW107XG4gIH1cbiAgcmVzZXRQcmV2aW91c05vZGVUcmFpbGluZ0NvbW1lbnRzKG5vZGUpIHtcbiAgICBjb25zdCB7XG4gICAgICBjb21tZW50U3RhY2tcbiAgICB9ID0gdGhpcy5zdGF0ZTtcbiAgICBjb25zdCB7XG4gICAgICBsZW5ndGhcbiAgICB9ID0gY29tbWVudFN0YWNrO1xuICAgIGlmIChsZW5ndGggPT09IDApIHJldHVybjtcbiAgICBjb25zdCBjb21tZW50V1MgPSBjb21tZW50U3RhY2tbbGVuZ3RoIC0gMV07XG4gICAgaWYgKGNvbW1lbnRXUy5sZWFkaW5nTm9kZSA9PT0gbm9kZSkge1xuICAgICAgY29tbWVudFdTLmxlYWRpbmdOb2RlID0gbnVsbDtcbiAgICB9XG4gIH1cbiAgdGFrZVN1cnJvdW5kaW5nQ29tbWVudHMobm9kZSwgc3RhcnQsIGVuZCkge1xuICAgIGNvbnN0IHtcbiAgICAgIGNvbW1lbnRTdGFja1xuICAgIH0gPSB0aGlzLnN0YXRlO1xuICAgIGNvbnN0IGNvbW1lbnRTdGFja0xlbmd0aCA9IGNvbW1lbnRTdGFjay5sZW5ndGg7XG4gICAgaWYgKGNvbW1lbnRTdGFja0xlbmd0aCA9PT0gMCkgcmV0dXJuO1xuICAgIGxldCBpID0gY29tbWVudFN0YWNrTGVuZ3RoIC0gMTtcbiAgICBmb3IgKDsgaSA+PSAwOyBpLS0pIHtcbiAgICAgIGNvbnN0IGNvbW1lbnRXUyA9IGNvbW1lbnRTdGFja1tpXTtcbiAgICAgIGNvbnN0IGNvbW1lbnRFbmQgPSBjb21tZW50V1MuZW5kO1xuICAgICAgY29uc3QgY29tbWVudFN0YXJ0ID0gY29tbWVudFdTLnN0YXJ0O1xuICAgICAgaWYgKGNvbW1lbnRTdGFydCA9PT0gZW5kKSB7XG4gICAgICAgIGNvbW1lbnRXUy5sZWFkaW5nTm9kZSA9IG5vZGU7XG4gICAgICB9IGVsc2UgaWYgKGNvbW1lbnRFbmQgPT09IHN0YXJ0KSB7XG4gICAgICAgIGNvbW1lbnRXUy50cmFpbGluZ05vZGUgPSBub2RlO1xuICAgICAgfSBlbHNlIGlmIChjb21tZW50RW5kIDwgc3RhcnQpIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5jbGFzcyBTdGF0ZSB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHRoaXMuZmxhZ3MgPSAxMDI0O1xuICAgIHRoaXMuc3RhcnRJbmRleCA9IHZvaWQgMDtcbiAgICB0aGlzLmN1ckxpbmUgPSB2b2lkIDA7XG4gICAgdGhpcy5saW5lU3RhcnQgPSB2b2lkIDA7XG4gICAgdGhpcy5zdGFydExvYyA9IHZvaWQgMDtcbiAgICB0aGlzLmVuZExvYyA9IHZvaWQgMDtcbiAgICB0aGlzLmVycm9ycyA9IFtdO1xuICAgIHRoaXMucG90ZW50aWFsQXJyb3dBdCA9IC0xO1xuICAgIHRoaXMubm9BcnJvd0F0ID0gW107XG4gICAgdGhpcy5ub0Fycm93UGFyYW1zQ29udmVyc2lvbkF0ID0gW107XG4gICAgdGhpcy50b3BpY0NvbnRleHQgPSB7XG4gICAgICBtYXhOdW1PZlJlc29sdmFibGVUb3BpY3M6IDAsXG4gICAgICBtYXhUb3BpY0luZGV4OiBudWxsXG4gICAgfTtcbiAgICB0aGlzLmxhYmVscyA9IFtdO1xuICAgIHRoaXMuY29tbWVudHNMZW4gPSAwO1xuICAgIHRoaXMuY29tbWVudFN0YWNrID0gW107XG4gICAgdGhpcy5wb3MgPSAwO1xuICAgIHRoaXMudHlwZSA9IDE0MDtcbiAgICB0aGlzLnZhbHVlID0gbnVsbDtcbiAgICB0aGlzLnN0YXJ0ID0gMDtcbiAgICB0aGlzLmVuZCA9IDA7XG4gICAgdGhpcy5sYXN0VG9rRW5kTG9jID0gbnVsbDtcbiAgICB0aGlzLmxhc3RUb2tTdGFydExvYyA9IG51bGw7XG4gICAgdGhpcy5jb250ZXh0ID0gW3R5cGVzLmJyYWNlXTtcbiAgICB0aGlzLmZpcnN0SW52YWxpZFRlbXBsYXRlRXNjYXBlUG9zID0gbnVsbDtcbiAgICB0aGlzLnN0cmljdEVycm9ycyA9IG5ldyBNYXAoKTtcbiAgICB0aGlzLnRva2Vuc0xlbmd0aCA9IDA7XG4gIH1cbiAgZ2V0IHN0cmljdCgpIHtcbiAgICByZXR1cm4gKHRoaXMuZmxhZ3MgJiAxKSA+IDA7XG4gIH1cbiAgc2V0IHN0cmljdCh2KSB7XG4gICAgaWYgKHYpIHRoaXMuZmxhZ3MgfD0gMTtlbHNlIHRoaXMuZmxhZ3MgJj0gLTI7XG4gIH1cbiAgaW5pdCh7XG4gICAgc3RyaWN0TW9kZSxcbiAgICBzb3VyY2VUeXBlLFxuICAgIHN0YXJ0SW5kZXgsXG4gICAgc3RhcnRMaW5lLFxuICAgIHN0YXJ0Q29sdW1uXG4gIH0pIHtcbiAgICB0aGlzLnN0cmljdCA9IHN0cmljdE1vZGUgPT09IGZhbHNlID8gZmFsc2UgOiBzdHJpY3RNb2RlID09PSB0cnVlID8gdHJ1ZSA6IHNvdXJjZVR5cGUgPT09IFwibW9kdWxlXCI7XG4gICAgdGhpcy5zdGFydEluZGV4ID0gc3RhcnRJbmRleDtcbiAgICB0aGlzLmN1ckxpbmUgPSBzdGFydExpbmU7XG4gICAgdGhpcy5saW5lU3RhcnQgPSAtc3RhcnRDb2x1bW47XG4gICAgdGhpcy5zdGFydExvYyA9IHRoaXMuZW5kTG9jID0gbmV3IFBvc2l0aW9uKHN0YXJ0TGluZSwgc3RhcnRDb2x1bW4sIHN0YXJ0SW5kZXgpO1xuICB9XG4gIGdldCBtYXliZUluQXJyb3dQYXJhbWV0ZXJzKCkge1xuICAgIHJldHVybiAodGhpcy5mbGFncyAmIDIpID4gMDtcbiAgfVxuICBzZXQgbWF5YmVJbkFycm93UGFyYW1ldGVycyh2KSB7XG4gICAgaWYgKHYpIHRoaXMuZmxhZ3MgfD0gMjtlbHNlIHRoaXMuZmxhZ3MgJj0gLTM7XG4gIH1cbiAgZ2V0IGluVHlwZSgpIHtcbiAgICByZXR1cm4gKHRoaXMuZmxhZ3MgJiA0KSA+IDA7XG4gIH1cbiAgc2V0IGluVHlwZSh2KSB7XG4gICAgaWYgKHYpIHRoaXMuZmxhZ3MgfD0gNDtlbHNlIHRoaXMuZmxhZ3MgJj0gLTU7XG4gIH1cbiAgZ2V0IG5vQW5vbkZ1bmN0aW9uVHlwZSgpIHtcbiAgICByZXR1cm4gKHRoaXMuZmxhZ3MgJiA4KSA+IDA7XG4gIH1cbiAgc2V0IG5vQW5vbkZ1bmN0aW9uVHlwZSh2KSB7XG4gICAgaWYgKHYpIHRoaXMuZmxhZ3MgfD0gODtlbHNlIHRoaXMuZmxhZ3MgJj0gLTk7XG4gIH1cbiAgZ2V0IGhhc0Zsb3dDb21tZW50KCkge1xuICAgIHJldHVybiAodGhpcy5mbGFncyAmIDE2KSA+IDA7XG4gIH1cbiAgc2V0IGhhc0Zsb3dDb21tZW50KHYpIHtcbiAgICBpZiAodikgdGhpcy5mbGFncyB8PSAxNjtlbHNlIHRoaXMuZmxhZ3MgJj0gLTE3O1xuICB9XG4gIGdldCBpc0FtYmllbnRDb250ZXh0KCkge1xuICAgIHJldHVybiAodGhpcy5mbGFncyAmIDMyKSA+IDA7XG4gIH1cbiAgc2V0IGlzQW1iaWVudENvbnRleHQodikge1xuICAgIGlmICh2KSB0aGlzLmZsYWdzIHw9IDMyO2Vsc2UgdGhpcy5mbGFncyAmPSAtMzM7XG4gIH1cbiAgZ2V0IGluQWJzdHJhY3RDbGFzcygpIHtcbiAgICByZXR1cm4gKHRoaXMuZmxhZ3MgJiA2NCkgPiAwO1xuICB9XG4gIHNldCBpbkFic3RyYWN0Q2xhc3Modikge1xuICAgIGlmICh2KSB0aGlzLmZsYWdzIHw9IDY0O2Vsc2UgdGhpcy5mbGFncyAmPSAtNjU7XG4gIH1cbiAgZ2V0IGluRGlzYWxsb3dDb25kaXRpb25hbFR5cGVzQ29udGV4dCgpIHtcbiAgICByZXR1cm4gKHRoaXMuZmxhZ3MgJiAxMjgpID4gMDtcbiAgfVxuICBzZXQgaW5EaXNhbGxvd0NvbmRpdGlvbmFsVHlwZXNDb250ZXh0KHYpIHtcbiAgICBpZiAodikgdGhpcy5mbGFncyB8PSAxMjg7ZWxzZSB0aGlzLmZsYWdzICY9IC0xMjk7XG4gIH1cbiAgZ2V0IHNvbG9Bd2FpdCgpIHtcbiAgICByZXR1cm4gKHRoaXMuZmxhZ3MgJiAyNTYpID4gMDtcbiAgfVxuICBzZXQgc29sb0F3YWl0KHYpIHtcbiAgICBpZiAodikgdGhpcy5mbGFncyB8PSAyNTY7ZWxzZSB0aGlzLmZsYWdzICY9IC0yNTc7XG4gIH1cbiAgZ2V0IGluRlNoYXJwUGlwZWxpbmVEaXJlY3RCb2R5KCkge1xuICAgIHJldHVybiAodGhpcy5mbGFncyAmIDUxMikgPiAwO1xuICB9XG4gIHNldCBpbkZTaGFycFBpcGVsaW5lRGlyZWN0Qm9keSh2KSB7XG4gICAgaWYgKHYpIHRoaXMuZmxhZ3MgfD0gNTEyO2Vsc2UgdGhpcy5mbGFncyAmPSAtNTEzO1xuICB9XG4gIGdldCBjYW5TdGFydEpTWEVsZW1lbnQoKSB7XG4gICAgcmV0dXJuICh0aGlzLmZsYWdzICYgMTAyNCkgPiAwO1xuICB9XG4gIHNldCBjYW5TdGFydEpTWEVsZW1lbnQodikge1xuICAgIGlmICh2KSB0aGlzLmZsYWdzIHw9IDEwMjQ7ZWxzZSB0aGlzLmZsYWdzICY9IC0xMDI1O1xuICB9XG4gIGdldCBjb250YWluc0VzYygpIHtcbiAgICByZXR1cm4gKHRoaXMuZmxhZ3MgJiAyMDQ4KSA+IDA7XG4gIH1cbiAgc2V0IGNvbnRhaW5zRXNjKHYpIHtcbiAgICBpZiAodikgdGhpcy5mbGFncyB8PSAyMDQ4O2Vsc2UgdGhpcy5mbGFncyAmPSAtMjA0OTtcbiAgfVxuICBnZXQgaGFzVG9wTGV2ZWxBd2FpdCgpIHtcbiAgICByZXR1cm4gKHRoaXMuZmxhZ3MgJiA0MDk2KSA+IDA7XG4gIH1cbiAgc2V0IGhhc1RvcExldmVsQXdhaXQodikge1xuICAgIGlmICh2KSB0aGlzLmZsYWdzIHw9IDQwOTY7ZWxzZSB0aGlzLmZsYWdzICY9IC00MDk3O1xuICB9XG4gIGN1clBvc2l0aW9uKCkge1xuICAgIHJldHVybiBuZXcgUG9zaXRpb24odGhpcy5jdXJMaW5lLCB0aGlzLnBvcyAtIHRoaXMubGluZVN0YXJ0LCB0aGlzLnBvcyArIHRoaXMuc3RhcnRJbmRleCk7XG4gIH1cbiAgY2xvbmUoKSB7XG4gICAgY29uc3Qgc3RhdGUgPSBuZXcgU3RhdGUoKTtcbiAgICBzdGF0ZS5mbGFncyA9IHRoaXMuZmxhZ3M7XG4gICAgc3RhdGUuc3RhcnRJbmRleCA9IHRoaXMuc3RhcnRJbmRleDtcbiAgICBzdGF0ZS5jdXJMaW5lID0gdGhpcy5jdXJMaW5lO1xuICAgIHN0YXRlLmxpbmVTdGFydCA9IHRoaXMubGluZVN0YXJ0O1xuICAgIHN0YXRlLnN0YXJ0TG9jID0gdGhpcy5zdGFydExvYztcbiAgICBzdGF0ZS5lbmRMb2MgPSB0aGlzLmVuZExvYztcbiAgICBzdGF0ZS5lcnJvcnMgPSB0aGlzLmVycm9ycy5zbGljZSgpO1xuICAgIHN0YXRlLnBvdGVudGlhbEFycm93QXQgPSB0aGlzLnBvdGVudGlhbEFycm93QXQ7XG4gICAgc3RhdGUubm9BcnJvd0F0ID0gdGhpcy5ub0Fycm93QXQuc2xpY2UoKTtcbiAgICBzdGF0ZS5ub0Fycm93UGFyYW1zQ29udmVyc2lvbkF0ID0gdGhpcy5ub0Fycm93UGFyYW1zQ29udmVyc2lvbkF0LnNsaWNlKCk7XG4gICAgc3RhdGUudG9waWNDb250ZXh0ID0gdGhpcy50b3BpY0NvbnRleHQ7XG4gICAgc3RhdGUubGFiZWxzID0gdGhpcy5sYWJlbHMuc2xpY2UoKTtcbiAgICBzdGF0ZS5jb21tZW50c0xlbiA9IHRoaXMuY29tbWVudHNMZW47XG4gICAgc3RhdGUuY29tbWVudFN0YWNrID0gdGhpcy5jb21tZW50U3RhY2suc2xpY2UoKTtcbiAgICBzdGF0ZS5wb3MgPSB0aGlzLnBvcztcbiAgICBzdGF0ZS50eXBlID0gdGhpcy50eXBlO1xuICAgIHN0YXRlLnZhbHVlID0gdGhpcy52YWx1ZTtcbiAgICBzdGF0ZS5zdGFydCA9IHRoaXMuc3RhcnQ7XG4gICAgc3RhdGUuZW5kID0gdGhpcy5lbmQ7XG4gICAgc3RhdGUubGFzdFRva0VuZExvYyA9IHRoaXMubGFzdFRva0VuZExvYztcbiAgICBzdGF0ZS5sYXN0VG9rU3RhcnRMb2MgPSB0aGlzLmxhc3RUb2tTdGFydExvYztcbiAgICBzdGF0ZS5jb250ZXh0ID0gdGhpcy5jb250ZXh0LnNsaWNlKCk7XG4gICAgc3RhdGUuZmlyc3RJbnZhbGlkVGVtcGxhdGVFc2NhcGVQb3MgPSB0aGlzLmZpcnN0SW52YWxpZFRlbXBsYXRlRXNjYXBlUG9zO1xuICAgIHN0YXRlLnN0cmljdEVycm9ycyA9IHRoaXMuc3RyaWN0RXJyb3JzO1xuICAgIHN0YXRlLnRva2Vuc0xlbmd0aCA9IHRoaXMudG9rZW5zTGVuZ3RoO1xuICAgIHJldHVybiBzdGF0ZTtcbiAgfVxufVxudmFyIF9pc0RpZ2l0ID0gZnVuY3Rpb24gaXNEaWdpdChjb2RlKSB7XG4gIHJldHVybiBjb2RlID49IDQ4ICYmIGNvZGUgPD0gNTc7XG59O1xuY29uc3QgZm9yYmlkZGVuTnVtZXJpY1NlcGFyYXRvclNpYmxpbmdzID0ge1xuICBkZWNCaW5PY3Q6IG5ldyBTZXQoWzQ2LCA2NiwgNjksIDc5LCA5NSwgOTgsIDEwMSwgMTExXSksXG4gIGhleDogbmV3IFNldChbNDYsIDg4LCA5NSwgMTIwXSlcbn07XG5jb25zdCBpc0FsbG93ZWROdW1lcmljU2VwYXJhdG9yU2libGluZyA9IHtcbiAgYmluOiBjaCA9PiBjaCA9PT0gNDggfHwgY2ggPT09IDQ5LFxuICBvY3Q6IGNoID0+IGNoID49IDQ4ICYmIGNoIDw9IDU1LFxuICBkZWM6IGNoID0+IGNoID49IDQ4ICYmIGNoIDw9IDU3LFxuICBoZXg6IGNoID0+IGNoID49IDQ4ICYmIGNoIDw9IDU3IHx8IGNoID49IDY1ICYmIGNoIDw9IDcwIHx8IGNoID49IDk3ICYmIGNoIDw9IDEwMlxufTtcbmZ1bmN0aW9uIHJlYWRTdHJpbmdDb250ZW50cyh0eXBlLCBpbnB1dCwgcG9zLCBsaW5lU3RhcnQsIGN1ckxpbmUsIGVycm9ycykge1xuICBjb25zdCBpbml0aWFsUG9zID0gcG9zO1xuICBjb25zdCBpbml0aWFsTGluZVN0YXJ0ID0gbGluZVN0YXJ0O1xuICBjb25zdCBpbml0aWFsQ3VyTGluZSA9IGN1ckxpbmU7XG4gIGxldCBvdXQgPSBcIlwiO1xuICBsZXQgZmlyc3RJbnZhbGlkTG9jID0gbnVsbDtcbiAgbGV0IGNodW5rU3RhcnQgPSBwb3M7XG4gIGNvbnN0IHtcbiAgICBsZW5ndGhcbiAgfSA9IGlucHV0O1xuICBmb3IgKDs7KSB7XG4gICAgaWYgKHBvcyA+PSBsZW5ndGgpIHtcbiAgICAgIGVycm9ycy51bnRlcm1pbmF0ZWQoaW5pdGlhbFBvcywgaW5pdGlhbExpbmVTdGFydCwgaW5pdGlhbEN1ckxpbmUpO1xuICAgICAgb3V0ICs9IGlucHV0LnNsaWNlKGNodW5rU3RhcnQsIHBvcyk7XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgY29uc3QgY2ggPSBpbnB1dC5jaGFyQ29kZUF0KHBvcyk7XG4gICAgaWYgKGlzU3RyaW5nRW5kKHR5cGUsIGNoLCBpbnB1dCwgcG9zKSkge1xuICAgICAgb3V0ICs9IGlucHV0LnNsaWNlKGNodW5rU3RhcnQsIHBvcyk7XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgaWYgKGNoID09PSA5Mikge1xuICAgICAgb3V0ICs9IGlucHV0LnNsaWNlKGNodW5rU3RhcnQsIHBvcyk7XG4gICAgICBjb25zdCByZXMgPSByZWFkRXNjYXBlZENoYXIoaW5wdXQsIHBvcywgbGluZVN0YXJ0LCBjdXJMaW5lLCB0eXBlID09PSBcInRlbXBsYXRlXCIsIGVycm9ycyk7XG4gICAgICBpZiAocmVzLmNoID09PSBudWxsICYmICFmaXJzdEludmFsaWRMb2MpIHtcbiAgICAgICAgZmlyc3RJbnZhbGlkTG9jID0ge1xuICAgICAgICAgIHBvcyxcbiAgICAgICAgICBsaW5lU3RhcnQsXG4gICAgICAgICAgY3VyTGluZVxuICAgICAgICB9O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgb3V0ICs9IHJlcy5jaDtcbiAgICAgIH1cbiAgICAgICh7XG4gICAgICAgIHBvcyxcbiAgICAgICAgbGluZVN0YXJ0LFxuICAgICAgICBjdXJMaW5lXG4gICAgICB9ID0gcmVzKTtcbiAgICAgIGNodW5rU3RhcnQgPSBwb3M7XG4gICAgfSBlbHNlIGlmIChjaCA9PT0gODIzMiB8fCBjaCA9PT0gODIzMykge1xuICAgICAgKytwb3M7XG4gICAgICArK2N1ckxpbmU7XG4gICAgICBsaW5lU3RhcnQgPSBwb3M7XG4gICAgfSBlbHNlIGlmIChjaCA9PT0gMTAgfHwgY2ggPT09IDEzKSB7XG4gICAgICBpZiAodHlwZSA9PT0gXCJ0ZW1wbGF0ZVwiKSB7XG4gICAgICAgIG91dCArPSBpbnB1dC5zbGljZShjaHVua1N0YXJ0LCBwb3MpICsgXCJcXG5cIjtcbiAgICAgICAgKytwb3M7XG4gICAgICAgIGlmIChjaCA9PT0gMTMgJiYgaW5wdXQuY2hhckNvZGVBdChwb3MpID09PSAxMCkge1xuICAgICAgICAgICsrcG9zO1xuICAgICAgICB9XG4gICAgICAgICsrY3VyTGluZTtcbiAgICAgICAgY2h1bmtTdGFydCA9IGxpbmVTdGFydCA9IHBvcztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGVycm9ycy51bnRlcm1pbmF0ZWQoaW5pdGlhbFBvcywgaW5pdGlhbExpbmVTdGFydCwgaW5pdGlhbEN1ckxpbmUpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICArK3BvcztcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHtcbiAgICBwb3MsXG4gICAgc3RyOiBvdXQsXG4gICAgZmlyc3RJbnZhbGlkTG9jLFxuICAgIGxpbmVTdGFydCxcbiAgICBjdXJMaW5lLFxuICAgIGNvbnRhaW5zSW52YWxpZDogISFmaXJzdEludmFsaWRMb2NcbiAgfTtcbn1cbmZ1bmN0aW9uIGlzU3RyaW5nRW5kKHR5cGUsIGNoLCBpbnB1dCwgcG9zKSB7XG4gIGlmICh0eXBlID09PSBcInRlbXBsYXRlXCIpIHtcbiAgICByZXR1cm4gY2ggPT09IDk2IHx8IGNoID09PSAzNiAmJiBpbnB1dC5jaGFyQ29kZUF0KHBvcyArIDEpID09PSAxMjM7XG4gIH1cbiAgcmV0dXJuIGNoID09PSAodHlwZSA9PT0gXCJkb3VibGVcIiA/IDM0IDogMzkpO1xufVxuZnVuY3Rpb24gcmVhZEVzY2FwZWRDaGFyKGlucHV0LCBwb3MsIGxpbmVTdGFydCwgY3VyTGluZSwgaW5UZW1wbGF0ZSwgZXJyb3JzKSB7XG4gIGNvbnN0IHRocm93T25JbnZhbGlkID0gIWluVGVtcGxhdGU7XG4gIHBvcysrO1xuICBjb25zdCByZXMgPSBjaCA9PiAoe1xuICAgIHBvcyxcbiAgICBjaCxcbiAgICBsaW5lU3RhcnQsXG4gICAgY3VyTGluZVxuICB9KTtcbiAgY29uc3QgY2ggPSBpbnB1dC5jaGFyQ29kZUF0KHBvcysrKTtcbiAgc3dpdGNoIChjaCkge1xuICAgIGNhc2UgMTEwOlxuICAgICAgcmV0dXJuIHJlcyhcIlxcblwiKTtcbiAgICBjYXNlIDExNDpcbiAgICAgIHJldHVybiByZXMoXCJcXHJcIik7XG4gICAgY2FzZSAxMjA6XG4gICAgICB7XG4gICAgICAgIGxldCBjb2RlO1xuICAgICAgICAoe1xuICAgICAgICAgIGNvZGUsXG4gICAgICAgICAgcG9zXG4gICAgICAgIH0gPSByZWFkSGV4Q2hhcihpbnB1dCwgcG9zLCBsaW5lU3RhcnQsIGN1ckxpbmUsIDIsIGZhbHNlLCB0aHJvd09uSW52YWxpZCwgZXJyb3JzKSk7XG4gICAgICAgIHJldHVybiByZXMoY29kZSA9PT0gbnVsbCA/IG51bGwgOiBTdHJpbmcuZnJvbUNoYXJDb2RlKGNvZGUpKTtcbiAgICAgIH1cbiAgICBjYXNlIDExNzpcbiAgICAgIHtcbiAgICAgICAgbGV0IGNvZGU7XG4gICAgICAgICh7XG4gICAgICAgICAgY29kZSxcbiAgICAgICAgICBwb3NcbiAgICAgICAgfSA9IHJlYWRDb2RlUG9pbnQoaW5wdXQsIHBvcywgbGluZVN0YXJ0LCBjdXJMaW5lLCB0aHJvd09uSW52YWxpZCwgZXJyb3JzKSk7XG4gICAgICAgIHJldHVybiByZXMoY29kZSA9PT0gbnVsbCA/IG51bGwgOiBTdHJpbmcuZnJvbUNvZGVQb2ludChjb2RlKSk7XG4gICAgICB9XG4gICAgY2FzZSAxMTY6XG4gICAgICByZXR1cm4gcmVzKFwiXFx0XCIpO1xuICAgIGNhc2UgOTg6XG4gICAgICByZXR1cm4gcmVzKFwiXFxiXCIpO1xuICAgIGNhc2UgMTE4OlxuICAgICAgcmV0dXJuIHJlcyhcIlxcdTAwMGJcIik7XG4gICAgY2FzZSAxMDI6XG4gICAgICByZXR1cm4gcmVzKFwiXFxmXCIpO1xuICAgIGNhc2UgMTM6XG4gICAgICBpZiAoaW5wdXQuY2hhckNvZGVBdChwb3MpID09PSAxMCkge1xuICAgICAgICArK3BvcztcbiAgICAgIH1cbiAgICBjYXNlIDEwOlxuICAgICAgbGluZVN0YXJ0ID0gcG9zO1xuICAgICAgKytjdXJMaW5lO1xuICAgIGNhc2UgODIzMjpcbiAgICBjYXNlIDgyMzM6XG4gICAgICByZXR1cm4gcmVzKFwiXCIpO1xuICAgIGNhc2UgNTY6XG4gICAgY2FzZSA1NzpcbiAgICAgIGlmIChpblRlbXBsYXRlKSB7XG4gICAgICAgIHJldHVybiByZXMobnVsbCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBlcnJvcnMuc3RyaWN0TnVtZXJpY0VzY2FwZShwb3MgLSAxLCBsaW5lU3RhcnQsIGN1ckxpbmUpO1xuICAgICAgfVxuICAgIGRlZmF1bHQ6XG4gICAgICBpZiAoY2ggPj0gNDggJiYgY2ggPD0gNTUpIHtcbiAgICAgICAgY29uc3Qgc3RhcnRQb3MgPSBwb3MgLSAxO1xuICAgICAgICBjb25zdCBtYXRjaCA9IC9eWzAtN10rLy5leGVjKGlucHV0LnNsaWNlKHN0YXJ0UG9zLCBwb3MgKyAyKSk7XG4gICAgICAgIGxldCBvY3RhbFN0ciA9IG1hdGNoWzBdO1xuICAgICAgICBsZXQgb2N0YWwgPSBwYXJzZUludChvY3RhbFN0ciwgOCk7XG4gICAgICAgIGlmIChvY3RhbCA+IDI1NSkge1xuICAgICAgICAgIG9jdGFsU3RyID0gb2N0YWxTdHIuc2xpY2UoMCwgLTEpO1xuICAgICAgICAgIG9jdGFsID0gcGFyc2VJbnQob2N0YWxTdHIsIDgpO1xuICAgICAgICB9XG4gICAgICAgIHBvcyArPSBvY3RhbFN0ci5sZW5ndGggLSAxO1xuICAgICAgICBjb25zdCBuZXh0ID0gaW5wdXQuY2hhckNvZGVBdChwb3MpO1xuICAgICAgICBpZiAob2N0YWxTdHIgIT09IFwiMFwiIHx8IG5leHQgPT09IDU2IHx8IG5leHQgPT09IDU3KSB7XG4gICAgICAgICAgaWYgKGluVGVtcGxhdGUpIHtcbiAgICAgICAgICAgIHJldHVybiByZXMobnVsbCk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGVycm9ycy5zdHJpY3ROdW1lcmljRXNjYXBlKHN0YXJ0UG9zLCBsaW5lU3RhcnQsIGN1ckxpbmUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzKFN0cmluZy5mcm9tQ2hhckNvZGUob2N0YWwpKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiByZXMoU3RyaW5nLmZyb21DaGFyQ29kZShjaCkpO1xuICB9XG59XG5mdW5jdGlvbiByZWFkSGV4Q2hhcihpbnB1dCwgcG9zLCBsaW5lU3RhcnQsIGN1ckxpbmUsIGxlbiwgZm9yY2VMZW4sIHRocm93T25JbnZhbGlkLCBlcnJvcnMpIHtcbiAgY29uc3QgaW5pdGlhbFBvcyA9IHBvcztcbiAgbGV0IG47XG4gICh7XG4gICAgbixcbiAgICBwb3NcbiAgfSA9IHJlYWRJbnQoaW5wdXQsIHBvcywgbGluZVN0YXJ0LCBjdXJMaW5lLCAxNiwgbGVuLCBmb3JjZUxlbiwgZmFsc2UsIGVycm9ycywgIXRocm93T25JbnZhbGlkKSk7XG4gIGlmIChuID09PSBudWxsKSB7XG4gICAgaWYgKHRocm93T25JbnZhbGlkKSB7XG4gICAgICBlcnJvcnMuaW52YWxpZEVzY2FwZVNlcXVlbmNlKGluaXRpYWxQb3MsIGxpbmVTdGFydCwgY3VyTGluZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHBvcyA9IGluaXRpYWxQb3MgLSAxO1xuICAgIH1cbiAgfVxuICByZXR1cm4ge1xuICAgIGNvZGU6IG4sXG4gICAgcG9zXG4gIH07XG59XG5mdW5jdGlvbiByZWFkSW50KGlucHV0LCBwb3MsIGxpbmVTdGFydCwgY3VyTGluZSwgcmFkaXgsIGxlbiwgZm9yY2VMZW4sIGFsbG93TnVtU2VwYXJhdG9yLCBlcnJvcnMsIGJhaWxPbkVycm9yKSB7XG4gIGNvbnN0IHN0YXJ0ID0gcG9zO1xuICBjb25zdCBmb3JiaWRkZW5TaWJsaW5ncyA9IHJhZGl4ID09PSAxNiA/IGZvcmJpZGRlbk51bWVyaWNTZXBhcmF0b3JTaWJsaW5ncy5oZXggOiBmb3JiaWRkZW5OdW1lcmljU2VwYXJhdG9yU2libGluZ3MuZGVjQmluT2N0O1xuICBjb25zdCBpc0FsbG93ZWRTaWJsaW5nID0gcmFkaXggPT09IDE2ID8gaXNBbGxvd2VkTnVtZXJpY1NlcGFyYXRvclNpYmxpbmcuaGV4IDogcmFkaXggPT09IDEwID8gaXNBbGxvd2VkTnVtZXJpY1NlcGFyYXRvclNpYmxpbmcuZGVjIDogcmFkaXggPT09IDggPyBpc0FsbG93ZWROdW1lcmljU2VwYXJhdG9yU2libGluZy5vY3QgOiBpc0FsbG93ZWROdW1lcmljU2VwYXJhdG9yU2libGluZy5iaW47XG4gIGxldCBpbnZhbGlkID0gZmFsc2U7XG4gIGxldCB0b3RhbCA9IDA7XG4gIGZvciAobGV0IGkgPSAwLCBlID0gbGVuID09IG51bGwgPyBJbmZpbml0eSA6IGxlbjsgaSA8IGU7ICsraSkge1xuICAgIGNvbnN0IGNvZGUgPSBpbnB1dC5jaGFyQ29kZUF0KHBvcyk7XG4gICAgbGV0IHZhbDtcbiAgICBpZiAoY29kZSA9PT0gOTUgJiYgYWxsb3dOdW1TZXBhcmF0b3IgIT09IFwiYmFpbFwiKSB7XG4gICAgICBjb25zdCBwcmV2ID0gaW5wdXQuY2hhckNvZGVBdChwb3MgLSAxKTtcbiAgICAgIGNvbnN0IG5leHQgPSBpbnB1dC5jaGFyQ29kZUF0KHBvcyArIDEpO1xuICAgICAgaWYgKCFhbGxvd051bVNlcGFyYXRvcikge1xuICAgICAgICBpZiAoYmFpbE9uRXJyb3IpIHJldHVybiB7XG4gICAgICAgICAgbjogbnVsbCxcbiAgICAgICAgICBwb3NcbiAgICAgICAgfTtcbiAgICAgICAgZXJyb3JzLm51bWVyaWNTZXBhcmF0b3JJbkVzY2FwZVNlcXVlbmNlKHBvcywgbGluZVN0YXJ0LCBjdXJMaW5lKTtcbiAgICAgIH0gZWxzZSBpZiAoTnVtYmVyLmlzTmFOKG5leHQpIHx8ICFpc0FsbG93ZWRTaWJsaW5nKG5leHQpIHx8IGZvcmJpZGRlblNpYmxpbmdzLmhhcyhwcmV2KSB8fCBmb3JiaWRkZW5TaWJsaW5ncy5oYXMobmV4dCkpIHtcbiAgICAgICAgaWYgKGJhaWxPbkVycm9yKSByZXR1cm4ge1xuICAgICAgICAgIG46IG51bGwsXG4gICAgICAgICAgcG9zXG4gICAgICAgIH07XG4gICAgICAgIGVycm9ycy51bmV4cGVjdGVkTnVtZXJpY1NlcGFyYXRvcihwb3MsIGxpbmVTdGFydCwgY3VyTGluZSk7XG4gICAgICB9XG4gICAgICArK3BvcztcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICBpZiAoY29kZSA+PSA5Nykge1xuICAgICAgdmFsID0gY29kZSAtIDk3ICsgMTA7XG4gICAgfSBlbHNlIGlmIChjb2RlID49IDY1KSB7XG4gICAgICB2YWwgPSBjb2RlIC0gNjUgKyAxMDtcbiAgICB9IGVsc2UgaWYgKF9pc0RpZ2l0KGNvZGUpKSB7XG4gICAgICB2YWwgPSBjb2RlIC0gNDg7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhbCA9IEluZmluaXR5O1xuICAgIH1cbiAgICBpZiAodmFsID49IHJhZGl4KSB7XG4gICAgICBpZiAodmFsIDw9IDkgJiYgYmFpbE9uRXJyb3IpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBuOiBudWxsLFxuICAgICAgICAgIHBvc1xuICAgICAgICB9O1xuICAgICAgfSBlbHNlIGlmICh2YWwgPD0gOSAmJiBlcnJvcnMuaW52YWxpZERpZ2l0KHBvcywgbGluZVN0YXJ0LCBjdXJMaW5lLCByYWRpeCkpIHtcbiAgICAgICAgdmFsID0gMDtcbiAgICAgIH0gZWxzZSBpZiAoZm9yY2VMZW4pIHtcbiAgICAgICAgdmFsID0gMDtcbiAgICAgICAgaW52YWxpZCA9IHRydWU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gICAgKytwb3M7XG4gICAgdG90YWwgPSB0b3RhbCAqIHJhZGl4ICsgdmFsO1xuICB9XG4gIGlmIChwb3MgPT09IHN0YXJ0IHx8IGxlbiAhPSBudWxsICYmIHBvcyAtIHN0YXJ0ICE9PSBsZW4gfHwgaW52YWxpZCkge1xuICAgIHJldHVybiB7XG4gICAgICBuOiBudWxsLFxuICAgICAgcG9zXG4gICAgfTtcbiAgfVxuICByZXR1cm4ge1xuICAgIG46IHRvdGFsLFxuICAgIHBvc1xuICB9O1xufVxuZnVuY3Rpb24gcmVhZENvZGVQb2ludChpbnB1dCwgcG9zLCBsaW5lU3RhcnQsIGN1ckxpbmUsIHRocm93T25JbnZhbGlkLCBlcnJvcnMpIHtcbiAgY29uc3QgY2ggPSBpbnB1dC5jaGFyQ29kZUF0KHBvcyk7XG4gIGxldCBjb2RlO1xuICBpZiAoY2ggPT09IDEyMykge1xuICAgICsrcG9zO1xuICAgICh7XG4gICAgICBjb2RlLFxuICAgICAgcG9zXG4gICAgfSA9IHJlYWRIZXhDaGFyKGlucHV0LCBwb3MsIGxpbmVTdGFydCwgY3VyTGluZSwgaW5wdXQuaW5kZXhPZihcIn1cIiwgcG9zKSAtIHBvcywgdHJ1ZSwgdGhyb3dPbkludmFsaWQsIGVycm9ycykpO1xuICAgICsrcG9zO1xuICAgIGlmIChjb2RlICE9PSBudWxsICYmIGNvZGUgPiAweDEwZmZmZikge1xuICAgICAgaWYgKHRocm93T25JbnZhbGlkKSB7XG4gICAgICAgIGVycm9ycy5pbnZhbGlkQ29kZVBvaW50KHBvcywgbGluZVN0YXJ0LCBjdXJMaW5lKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgY29kZTogbnVsbCxcbiAgICAgICAgICBwb3NcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgKHtcbiAgICAgIGNvZGUsXG4gICAgICBwb3NcbiAgICB9ID0gcmVhZEhleENoYXIoaW5wdXQsIHBvcywgbGluZVN0YXJ0LCBjdXJMaW5lLCA0LCBmYWxzZSwgdGhyb3dPbkludmFsaWQsIGVycm9ycykpO1xuICB9XG4gIHJldHVybiB7XG4gICAgY29kZSxcbiAgICBwb3NcbiAgfTtcbn1cbmZ1bmN0aW9uIGJ1aWxkUG9zaXRpb24ocG9zLCBsaW5lU3RhcnQsIGN1ckxpbmUpIHtcbiAgcmV0dXJuIG5ldyBQb3NpdGlvbihjdXJMaW5lLCBwb3MgLSBsaW5lU3RhcnQsIHBvcyk7XG59XG5jb25zdCBWQUxJRF9SRUdFWF9GTEFHUyA9IG5ldyBTZXQoWzEwMywgMTA5LCAxMTUsIDEwNSwgMTIxLCAxMTcsIDEwMCwgMTE4XSk7XG5jbGFzcyBUb2tlbiB7XG4gIGNvbnN0cnVjdG9yKHN0YXRlKSB7XG4gICAgY29uc3Qgc3RhcnRJbmRleCA9IHN0YXRlLnN0YXJ0SW5kZXggfHwgMDtcbiAgICB0aGlzLnR5cGUgPSBzdGF0ZS50eXBlO1xuICAgIHRoaXMudmFsdWUgPSBzdGF0ZS52YWx1ZTtcbiAgICB0aGlzLnN0YXJ0ID0gc3RhcnRJbmRleCArIHN0YXRlLnN0YXJ0O1xuICAgIHRoaXMuZW5kID0gc3RhcnRJbmRleCArIHN0YXRlLmVuZDtcbiAgICB0aGlzLmxvYyA9IG5ldyBTb3VyY2VMb2NhdGlvbihzdGF0ZS5zdGFydExvYywgc3RhdGUuZW5kTG9jKTtcbiAgfVxufVxuY2xhc3MgVG9rZW5pemVyIGV4dGVuZHMgQ29tbWVudHNQYXJzZXIge1xuICBjb25zdHJ1Y3RvcihvcHRpb25zLCBpbnB1dCkge1xuICAgIHN1cGVyKCk7XG4gICAgdGhpcy5pc0xvb2thaGVhZCA9IHZvaWQgMDtcbiAgICB0aGlzLnRva2VucyA9IFtdO1xuICAgIHRoaXMuZXJyb3JIYW5kbGVyc19yZWFkSW50ID0ge1xuICAgICAgaW52YWxpZERpZ2l0OiAocG9zLCBsaW5lU3RhcnQsIGN1ckxpbmUsIHJhZGl4KSA9PiB7XG4gICAgICAgIGlmICghKHRoaXMub3B0aW9uRmxhZ3MgJiAyMDQ4KSkgcmV0dXJuIGZhbHNlO1xuICAgICAgICB0aGlzLnJhaXNlKEVycm9ycy5JbnZhbGlkRGlnaXQsIGJ1aWxkUG9zaXRpb24ocG9zLCBsaW5lU3RhcnQsIGN1ckxpbmUpLCB7XG4gICAgICAgICAgcmFkaXhcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfSxcbiAgICAgIG51bWVyaWNTZXBhcmF0b3JJbkVzY2FwZVNlcXVlbmNlOiB0aGlzLmVycm9yQnVpbGRlcihFcnJvcnMuTnVtZXJpY1NlcGFyYXRvckluRXNjYXBlU2VxdWVuY2UpLFxuICAgICAgdW5leHBlY3RlZE51bWVyaWNTZXBhcmF0b3I6IHRoaXMuZXJyb3JCdWlsZGVyKEVycm9ycy5VbmV4cGVjdGVkTnVtZXJpY1NlcGFyYXRvcilcbiAgICB9O1xuICAgIHRoaXMuZXJyb3JIYW5kbGVyc19yZWFkQ29kZVBvaW50ID0gT2JqZWN0LmFzc2lnbih7fSwgdGhpcy5lcnJvckhhbmRsZXJzX3JlYWRJbnQsIHtcbiAgICAgIGludmFsaWRFc2NhcGVTZXF1ZW5jZTogdGhpcy5lcnJvckJ1aWxkZXIoRXJyb3JzLkludmFsaWRFc2NhcGVTZXF1ZW5jZSksXG4gICAgICBpbnZhbGlkQ29kZVBvaW50OiB0aGlzLmVycm9yQnVpbGRlcihFcnJvcnMuSW52YWxpZENvZGVQb2ludClcbiAgICB9KTtcbiAgICB0aGlzLmVycm9ySGFuZGxlcnNfcmVhZFN0cmluZ0NvbnRlbnRzX3N0cmluZyA9IE9iamVjdC5hc3NpZ24oe30sIHRoaXMuZXJyb3JIYW5kbGVyc19yZWFkQ29kZVBvaW50LCB7XG4gICAgICBzdHJpY3ROdW1lcmljRXNjYXBlOiAocG9zLCBsaW5lU3RhcnQsIGN1ckxpbmUpID0+IHtcbiAgICAgICAgdGhpcy5yZWNvcmRTdHJpY3RNb2RlRXJyb3JzKEVycm9ycy5TdHJpY3ROdW1lcmljRXNjYXBlLCBidWlsZFBvc2l0aW9uKHBvcywgbGluZVN0YXJ0LCBjdXJMaW5lKSk7XG4gICAgICB9LFxuICAgICAgdW50ZXJtaW5hdGVkOiAocG9zLCBsaW5lU3RhcnQsIGN1ckxpbmUpID0+IHtcbiAgICAgICAgdGhyb3cgdGhpcy5yYWlzZShFcnJvcnMuVW50ZXJtaW5hdGVkU3RyaW5nLCBidWlsZFBvc2l0aW9uKHBvcyAtIDEsIGxpbmVTdGFydCwgY3VyTGluZSkpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHRoaXMuZXJyb3JIYW5kbGVyc19yZWFkU3RyaW5nQ29udGVudHNfdGVtcGxhdGUgPSBPYmplY3QuYXNzaWduKHt9LCB0aGlzLmVycm9ySGFuZGxlcnNfcmVhZENvZGVQb2ludCwge1xuICAgICAgc3RyaWN0TnVtZXJpY0VzY2FwZTogdGhpcy5lcnJvckJ1aWxkZXIoRXJyb3JzLlN0cmljdE51bWVyaWNFc2NhcGUpLFxuICAgICAgdW50ZXJtaW5hdGVkOiAocG9zLCBsaW5lU3RhcnQsIGN1ckxpbmUpID0+IHtcbiAgICAgICAgdGhyb3cgdGhpcy5yYWlzZShFcnJvcnMuVW50ZXJtaW5hdGVkVGVtcGxhdGUsIGJ1aWxkUG9zaXRpb24ocG9zLCBsaW5lU3RhcnQsIGN1ckxpbmUpKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICB0aGlzLnN0YXRlID0gbmV3IFN0YXRlKCk7XG4gICAgdGhpcy5zdGF0ZS5pbml0KG9wdGlvbnMpO1xuICAgIHRoaXMuaW5wdXQgPSBpbnB1dDtcbiAgICB0aGlzLmxlbmd0aCA9IGlucHV0Lmxlbmd0aDtcbiAgICB0aGlzLmNvbW1lbnRzID0gW107XG4gICAgdGhpcy5pc0xvb2thaGVhZCA9IGZhbHNlO1xuICB9XG4gIHB1c2hUb2tlbih0b2tlbikge1xuICAgIHRoaXMudG9rZW5zLmxlbmd0aCA9IHRoaXMuc3RhdGUudG9rZW5zTGVuZ3RoO1xuICAgIHRoaXMudG9rZW5zLnB1c2godG9rZW4pO1xuICAgICsrdGhpcy5zdGF0ZS50b2tlbnNMZW5ndGg7XG4gIH1cbiAgbmV4dCgpIHtcbiAgICB0aGlzLmNoZWNrS2V5d29yZEVzY2FwZXMoKTtcbiAgICBpZiAodGhpcy5vcHRpb25GbGFncyAmIDI1Nikge1xuICAgICAgdGhpcy5wdXNoVG9rZW4obmV3IFRva2VuKHRoaXMuc3RhdGUpKTtcbiAgICB9XG4gICAgdGhpcy5zdGF0ZS5sYXN0VG9rRW5kTG9jID0gdGhpcy5zdGF0ZS5lbmRMb2M7XG4gICAgdGhpcy5zdGF0ZS5sYXN0VG9rU3RhcnRMb2MgPSB0aGlzLnN0YXRlLnN0YXJ0TG9jO1xuICAgIHRoaXMubmV4dFRva2VuKCk7XG4gIH1cbiAgZWF0KHR5cGUpIHtcbiAgICBpZiAodGhpcy5tYXRjaCh0eXBlKSkge1xuICAgICAgdGhpcy5uZXh0KCk7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuICBtYXRjaCh0eXBlKSB7XG4gICAgcmV0dXJuIHRoaXMuc3RhdGUudHlwZSA9PT0gdHlwZTtcbiAgfVxuICBjcmVhdGVMb29rYWhlYWRTdGF0ZShzdGF0ZSkge1xuICAgIHJldHVybiB7XG4gICAgICBwb3M6IHN0YXRlLnBvcyxcbiAgICAgIHZhbHVlOiBudWxsLFxuICAgICAgdHlwZTogc3RhdGUudHlwZSxcbiAgICAgIHN0YXJ0OiBzdGF0ZS5zdGFydCxcbiAgICAgIGVuZDogc3RhdGUuZW5kLFxuICAgICAgY29udGV4dDogW3RoaXMuY3VyQ29udGV4dCgpXSxcbiAgICAgIGluVHlwZTogc3RhdGUuaW5UeXBlLFxuICAgICAgc3RhcnRMb2M6IHN0YXRlLnN0YXJ0TG9jLFxuICAgICAgbGFzdFRva0VuZExvYzogc3RhdGUubGFzdFRva0VuZExvYyxcbiAgICAgIGN1ckxpbmU6IHN0YXRlLmN1ckxpbmUsXG4gICAgICBsaW5lU3RhcnQ6IHN0YXRlLmxpbmVTdGFydCxcbiAgICAgIGN1clBvc2l0aW9uOiBzdGF0ZS5jdXJQb3NpdGlvblxuICAgIH07XG4gIH1cbiAgbG9va2FoZWFkKCkge1xuICAgIGNvbnN0IG9sZCA9IHRoaXMuc3RhdGU7XG4gICAgdGhpcy5zdGF0ZSA9IHRoaXMuY3JlYXRlTG9va2FoZWFkU3RhdGUob2xkKTtcbiAgICB0aGlzLmlzTG9va2FoZWFkID0gdHJ1ZTtcbiAgICB0aGlzLm5leHRUb2tlbigpO1xuICAgIHRoaXMuaXNMb29rYWhlYWQgPSBmYWxzZTtcbiAgICBjb25zdCBjdXJyID0gdGhpcy5zdGF0ZTtcbiAgICB0aGlzLnN0YXRlID0gb2xkO1xuICAgIHJldHVybiBjdXJyO1xuICB9XG4gIG5leHRUb2tlblN0YXJ0KCkge1xuICAgIHJldHVybiB0aGlzLm5leHRUb2tlblN0YXJ0U2luY2UodGhpcy5zdGF0ZS5wb3MpO1xuICB9XG4gIG5leHRUb2tlblN0YXJ0U2luY2UocG9zKSB7XG4gICAgc2tpcFdoaXRlU3BhY2UubGFzdEluZGV4ID0gcG9zO1xuICAgIHJldHVybiBza2lwV2hpdGVTcGFjZS50ZXN0KHRoaXMuaW5wdXQpID8gc2tpcFdoaXRlU3BhY2UubGFzdEluZGV4IDogcG9zO1xuICB9XG4gIGxvb2thaGVhZENoYXJDb2RlKCkge1xuICAgIHJldHVybiB0aGlzLmxvb2thaGVhZENoYXJDb2RlU2luY2UodGhpcy5zdGF0ZS5wb3MpO1xuICB9XG4gIGxvb2thaGVhZENoYXJDb2RlU2luY2UocG9zKSB7XG4gICAgcmV0dXJuIHRoaXMuaW5wdXQuY2hhckNvZGVBdCh0aGlzLm5leHRUb2tlblN0YXJ0U2luY2UocG9zKSk7XG4gIH1cbiAgbmV4dFRva2VuSW5MaW5lU3RhcnQoKSB7XG4gICAgcmV0dXJuIHRoaXMubmV4dFRva2VuSW5MaW5lU3RhcnRTaW5jZSh0aGlzLnN0YXRlLnBvcyk7XG4gIH1cbiAgbmV4dFRva2VuSW5MaW5lU3RhcnRTaW5jZShwb3MpIHtcbiAgICBza2lwV2hpdGVTcGFjZUluTGluZS5sYXN0SW5kZXggPSBwb3M7XG4gICAgcmV0dXJuIHNraXBXaGl0ZVNwYWNlSW5MaW5lLnRlc3QodGhpcy5pbnB1dCkgPyBza2lwV2hpdGVTcGFjZUluTGluZS5sYXN0SW5kZXggOiBwb3M7XG4gIH1cbiAgbG9va2FoZWFkSW5MaW5lQ2hhckNvZGUoKSB7XG4gICAgcmV0dXJuIHRoaXMuaW5wdXQuY2hhckNvZGVBdCh0aGlzLm5leHRUb2tlbkluTGluZVN0YXJ0KCkpO1xuICB9XG4gIGNvZGVQb2ludEF0UG9zKHBvcykge1xuICAgIGxldCBjcCA9IHRoaXMuaW5wdXQuY2hhckNvZGVBdChwb3MpO1xuICAgIGlmICgoY3AgJiAweGZjMDApID09PSAweGQ4MDAgJiYgKytwb3MgPCB0aGlzLmlucHV0Lmxlbmd0aCkge1xuICAgICAgY29uc3QgdHJhaWwgPSB0aGlzLmlucHV0LmNoYXJDb2RlQXQocG9zKTtcbiAgICAgIGlmICgodHJhaWwgJiAweGZjMDApID09PSAweGRjMDApIHtcbiAgICAgICAgY3AgPSAweDEwMDAwICsgKChjcCAmIDB4M2ZmKSA8PCAxMCkgKyAodHJhaWwgJiAweDNmZik7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBjcDtcbiAgfVxuICBzZXRTdHJpY3Qoc3RyaWN0KSB7XG4gICAgdGhpcy5zdGF0ZS5zdHJpY3QgPSBzdHJpY3Q7XG4gICAgaWYgKHN0cmljdCkge1xuICAgICAgdGhpcy5zdGF0ZS5zdHJpY3RFcnJvcnMuZm9yRWFjaCgoW3RvUGFyc2VFcnJvciwgYXRdKSA9PiB0aGlzLnJhaXNlKHRvUGFyc2VFcnJvciwgYXQpKTtcbiAgICAgIHRoaXMuc3RhdGUuc3RyaWN0RXJyb3JzLmNsZWFyKCk7XG4gICAgfVxuICB9XG4gIGN1ckNvbnRleHQoKSB7XG4gICAgcmV0dXJuIHRoaXMuc3RhdGUuY29udGV4dFt0aGlzLnN0YXRlLmNvbnRleHQubGVuZ3RoIC0gMV07XG4gIH1cbiAgbmV4dFRva2VuKCkge1xuICAgIHRoaXMuc2tpcFNwYWNlKCk7XG4gICAgdGhpcy5zdGF0ZS5zdGFydCA9IHRoaXMuc3RhdGUucG9zO1xuICAgIGlmICghdGhpcy5pc0xvb2thaGVhZCkgdGhpcy5zdGF0ZS5zdGFydExvYyA9IHRoaXMuc3RhdGUuY3VyUG9zaXRpb24oKTtcbiAgICBpZiAodGhpcy5zdGF0ZS5wb3MgPj0gdGhpcy5sZW5ndGgpIHtcbiAgICAgIHRoaXMuZmluaXNoVG9rZW4oMTQwKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5nZXRUb2tlbkZyb21Db2RlKHRoaXMuY29kZVBvaW50QXRQb3ModGhpcy5zdGF0ZS5wb3MpKTtcbiAgfVxuICBza2lwQmxvY2tDb21tZW50KGNvbW1lbnRFbmQpIHtcbiAgICBsZXQgc3RhcnRMb2M7XG4gICAgaWYgKCF0aGlzLmlzTG9va2FoZWFkKSBzdGFydExvYyA9IHRoaXMuc3RhdGUuY3VyUG9zaXRpb24oKTtcbiAgICBjb25zdCBzdGFydCA9IHRoaXMuc3RhdGUucG9zO1xuICAgIGNvbnN0IGVuZCA9IHRoaXMuaW5wdXQuaW5kZXhPZihjb21tZW50RW5kLCBzdGFydCArIDIpO1xuICAgIGlmIChlbmQgPT09IC0xKSB7XG4gICAgICB0aHJvdyB0aGlzLnJhaXNlKEVycm9ycy5VbnRlcm1pbmF0ZWRDb21tZW50LCB0aGlzLnN0YXRlLmN1clBvc2l0aW9uKCkpO1xuICAgIH1cbiAgICB0aGlzLnN0YXRlLnBvcyA9IGVuZCArIGNvbW1lbnRFbmQubGVuZ3RoO1xuICAgIGxpbmVCcmVha0cubGFzdEluZGV4ID0gc3RhcnQgKyAyO1xuICAgIHdoaWxlIChsaW5lQnJlYWtHLnRlc3QodGhpcy5pbnB1dCkgJiYgbGluZUJyZWFrRy5sYXN0SW5kZXggPD0gZW5kKSB7XG4gICAgICArK3RoaXMuc3RhdGUuY3VyTGluZTtcbiAgICAgIHRoaXMuc3RhdGUubGluZVN0YXJ0ID0gbGluZUJyZWFrRy5sYXN0SW5kZXg7XG4gICAgfVxuICAgIGlmICh0aGlzLmlzTG9va2FoZWFkKSByZXR1cm47XG4gICAgY29uc3QgY29tbWVudCA9IHtcbiAgICAgIHR5cGU6IFwiQ29tbWVudEJsb2NrXCIsXG4gICAgICB2YWx1ZTogdGhpcy5pbnB1dC5zbGljZShzdGFydCArIDIsIGVuZCksXG4gICAgICBzdGFydDogdGhpcy5zb3VyY2VUb09mZnNldFBvcyhzdGFydCksXG4gICAgICBlbmQ6IHRoaXMuc291cmNlVG9PZmZzZXRQb3MoZW5kICsgY29tbWVudEVuZC5sZW5ndGgpLFxuICAgICAgbG9jOiBuZXcgU291cmNlTG9jYXRpb24oc3RhcnRMb2MsIHRoaXMuc3RhdGUuY3VyUG9zaXRpb24oKSlcbiAgICB9O1xuICAgIGlmICh0aGlzLm9wdGlvbkZsYWdzICYgMjU2KSB0aGlzLnB1c2hUb2tlbihjb21tZW50KTtcbiAgICByZXR1cm4gY29tbWVudDtcbiAgfVxuICBza2lwTGluZUNvbW1lbnQoc3RhcnRTa2lwKSB7XG4gICAgY29uc3Qgc3RhcnQgPSB0aGlzLnN0YXRlLnBvcztcbiAgICBsZXQgc3RhcnRMb2M7XG4gICAgaWYgKCF0aGlzLmlzTG9va2FoZWFkKSBzdGFydExvYyA9IHRoaXMuc3RhdGUuY3VyUG9zaXRpb24oKTtcbiAgICBsZXQgY2ggPSB0aGlzLmlucHV0LmNoYXJDb2RlQXQodGhpcy5zdGF0ZS5wb3MgKz0gc3RhcnRTa2lwKTtcbiAgICBpZiAodGhpcy5zdGF0ZS5wb3MgPCB0aGlzLmxlbmd0aCkge1xuICAgICAgd2hpbGUgKCFpc05ld0xpbmUoY2gpICYmICsrdGhpcy5zdGF0ZS5wb3MgPCB0aGlzLmxlbmd0aCkge1xuICAgICAgICBjaCA9IHRoaXMuaW5wdXQuY2hhckNvZGVBdCh0aGlzLnN0YXRlLnBvcyk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmICh0aGlzLmlzTG9va2FoZWFkKSByZXR1cm47XG4gICAgY29uc3QgZW5kID0gdGhpcy5zdGF0ZS5wb3M7XG4gICAgY29uc3QgdmFsdWUgPSB0aGlzLmlucHV0LnNsaWNlKHN0YXJ0ICsgc3RhcnRTa2lwLCBlbmQpO1xuICAgIGNvbnN0IGNvbW1lbnQgPSB7XG4gICAgICB0eXBlOiBcIkNvbW1lbnRMaW5lXCIsXG4gICAgICB2YWx1ZSxcbiAgICAgIHN0YXJ0OiB0aGlzLnNvdXJjZVRvT2Zmc2V0UG9zKHN0YXJ0KSxcbiAgICAgIGVuZDogdGhpcy5zb3VyY2VUb09mZnNldFBvcyhlbmQpLFxuICAgICAgbG9jOiBuZXcgU291cmNlTG9jYXRpb24oc3RhcnRMb2MsIHRoaXMuc3RhdGUuY3VyUG9zaXRpb24oKSlcbiAgICB9O1xuICAgIGlmICh0aGlzLm9wdGlvbkZsYWdzICYgMjU2KSB0aGlzLnB1c2hUb2tlbihjb21tZW50KTtcbiAgICByZXR1cm4gY29tbWVudDtcbiAgfVxuICBza2lwU3BhY2UoKSB7XG4gICAgY29uc3Qgc3BhY2VTdGFydCA9IHRoaXMuc3RhdGUucG9zO1xuICAgIGNvbnN0IGNvbW1lbnRzID0gdGhpcy5vcHRpb25GbGFncyAmIDQwOTYgPyBbXSA6IG51bGw7XG4gICAgbG9vcDogd2hpbGUgKHRoaXMuc3RhdGUucG9zIDwgdGhpcy5sZW5ndGgpIHtcbiAgICAgIGNvbnN0IGNoID0gdGhpcy5pbnB1dC5jaGFyQ29kZUF0KHRoaXMuc3RhdGUucG9zKTtcbiAgICAgIHN3aXRjaCAoY2gpIHtcbiAgICAgICAgY2FzZSAzMjpcbiAgICAgICAgY2FzZSAxNjA6XG4gICAgICAgIGNhc2UgOTpcbiAgICAgICAgICArK3RoaXMuc3RhdGUucG9zO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDEzOlxuICAgICAgICAgIGlmICh0aGlzLmlucHV0LmNoYXJDb2RlQXQodGhpcy5zdGF0ZS5wb3MgKyAxKSA9PT0gMTApIHtcbiAgICAgICAgICAgICsrdGhpcy5zdGF0ZS5wb3M7XG4gICAgICAgICAgfVxuICAgICAgICBjYXNlIDEwOlxuICAgICAgICBjYXNlIDgyMzI6XG4gICAgICAgIGNhc2UgODIzMzpcbiAgICAgICAgICArK3RoaXMuc3RhdGUucG9zO1xuICAgICAgICAgICsrdGhpcy5zdGF0ZS5jdXJMaW5lO1xuICAgICAgICAgIHRoaXMuc3RhdGUubGluZVN0YXJ0ID0gdGhpcy5zdGF0ZS5wb3M7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgNDc6XG4gICAgICAgICAgc3dpdGNoICh0aGlzLmlucHV0LmNoYXJDb2RlQXQodGhpcy5zdGF0ZS5wb3MgKyAxKSkge1xuICAgICAgICAgICAgY2FzZSA0MjpcbiAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGNvbnN0IGNvbW1lbnQgPSB0aGlzLnNraXBCbG9ja0NvbW1lbnQoXCIqL1wiKTtcbiAgICAgICAgICAgICAgICBpZiAoY29tbWVudCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICB0aGlzLmFkZENvbW1lbnQoY29tbWVudCk7XG4gICAgICAgICAgICAgICAgICBjb21tZW50cyA9PSBudWxsIHx8IGNvbW1lbnRzLnB1c2goY29tbWVudCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXNlIDQ3OlxuICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgY29uc3QgY29tbWVudCA9IHRoaXMuc2tpcExpbmVDb21tZW50KDIpO1xuICAgICAgICAgICAgICAgIGlmIChjb21tZW50ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgIHRoaXMuYWRkQ29tbWVudChjb21tZW50KTtcbiAgICAgICAgICAgICAgICAgIGNvbW1lbnRzID09IG51bGwgfHwgY29tbWVudHMucHVzaChjb21tZW50KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgIGJyZWFrIGxvb3A7XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIGlmIChpc1doaXRlc3BhY2UoY2gpKSB7XG4gICAgICAgICAgICArK3RoaXMuc3RhdGUucG9zO1xuICAgICAgICAgIH0gZWxzZSBpZiAoY2ggPT09IDQ1ICYmICF0aGlzLmluTW9kdWxlICYmIHRoaXMub3B0aW9uRmxhZ3MgJiA4MTkyKSB7XG4gICAgICAgICAgICBjb25zdCBwb3MgPSB0aGlzLnN0YXRlLnBvcztcbiAgICAgICAgICAgIGlmICh0aGlzLmlucHV0LmNoYXJDb2RlQXQocG9zICsgMSkgPT09IDQ1ICYmIHRoaXMuaW5wdXQuY2hhckNvZGVBdChwb3MgKyAyKSA9PT0gNjIgJiYgKHNwYWNlU3RhcnQgPT09IDAgfHwgdGhpcy5zdGF0ZS5saW5lU3RhcnQgPiBzcGFjZVN0YXJ0KSkge1xuICAgICAgICAgICAgICBjb25zdCBjb21tZW50ID0gdGhpcy5za2lwTGluZUNvbW1lbnQoMyk7XG4gICAgICAgICAgICAgIGlmIChjb21tZW50ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmFkZENvbW1lbnQoY29tbWVudCk7XG4gICAgICAgICAgICAgICAgY29tbWVudHMgPT0gbnVsbCB8fCBjb21tZW50cy5wdXNoKGNvbW1lbnQpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBicmVhayBsb29wO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSBpZiAoY2ggPT09IDYwICYmICF0aGlzLmluTW9kdWxlICYmIHRoaXMub3B0aW9uRmxhZ3MgJiA4MTkyKSB7XG4gICAgICAgICAgICBjb25zdCBwb3MgPSB0aGlzLnN0YXRlLnBvcztcbiAgICAgICAgICAgIGlmICh0aGlzLmlucHV0LmNoYXJDb2RlQXQocG9zICsgMSkgPT09IDMzICYmIHRoaXMuaW5wdXQuY2hhckNvZGVBdChwb3MgKyAyKSA9PT0gNDUgJiYgdGhpcy5pbnB1dC5jaGFyQ29kZUF0KHBvcyArIDMpID09PSA0NSkge1xuICAgICAgICAgICAgICBjb25zdCBjb21tZW50ID0gdGhpcy5za2lwTGluZUNvbW1lbnQoNCk7XG4gICAgICAgICAgICAgIGlmIChjb21tZW50ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmFkZENvbW1lbnQoY29tbWVudCk7XG4gICAgICAgICAgICAgICAgY29tbWVudHMgPT0gbnVsbCB8fCBjb21tZW50cy5wdXNoKGNvbW1lbnQpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBicmVhayBsb29wO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBicmVhayBsb29wO1xuICAgICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKChjb21tZW50cyA9PSBudWxsID8gdm9pZCAwIDogY29tbWVudHMubGVuZ3RoKSA+IDApIHtcbiAgICAgIGNvbnN0IGVuZCA9IHRoaXMuc3RhdGUucG9zO1xuICAgICAgY29uc3QgY29tbWVudFdoaXRlc3BhY2UgPSB7XG4gICAgICAgIHN0YXJ0OiB0aGlzLnNvdXJjZVRvT2Zmc2V0UG9zKHNwYWNlU3RhcnQpLFxuICAgICAgICBlbmQ6IHRoaXMuc291cmNlVG9PZmZzZXRQb3MoZW5kKSxcbiAgICAgICAgY29tbWVudHM6IGNvbW1lbnRzLFxuICAgICAgICBsZWFkaW5nTm9kZTogbnVsbCxcbiAgICAgICAgdHJhaWxpbmdOb2RlOiBudWxsLFxuICAgICAgICBjb250YWluaW5nTm9kZTogbnVsbFxuICAgICAgfTtcbiAgICAgIHRoaXMuc3RhdGUuY29tbWVudFN0YWNrLnB1c2goY29tbWVudFdoaXRlc3BhY2UpO1xuICAgIH1cbiAgfVxuICBmaW5pc2hUb2tlbih0eXBlLCB2YWwpIHtcbiAgICB0aGlzLnN0YXRlLmVuZCA9IHRoaXMuc3RhdGUucG9zO1xuICAgIHRoaXMuc3RhdGUuZW5kTG9jID0gdGhpcy5zdGF0ZS5jdXJQb3NpdGlvbigpO1xuICAgIGNvbnN0IHByZXZUeXBlID0gdGhpcy5zdGF0ZS50eXBlO1xuICAgIHRoaXMuc3RhdGUudHlwZSA9IHR5cGU7XG4gICAgdGhpcy5zdGF0ZS52YWx1ZSA9IHZhbDtcbiAgICBpZiAoIXRoaXMuaXNMb29rYWhlYWQpIHtcbiAgICAgIHRoaXMudXBkYXRlQ29udGV4dChwcmV2VHlwZSk7XG4gICAgfVxuICB9XG4gIHJlcGxhY2VUb2tlbih0eXBlKSB7XG4gICAgdGhpcy5zdGF0ZS50eXBlID0gdHlwZTtcbiAgICB0aGlzLnVwZGF0ZUNvbnRleHQoKTtcbiAgfVxuICByZWFkVG9rZW5fbnVtYmVyU2lnbigpIHtcbiAgICBpZiAodGhpcy5zdGF0ZS5wb3MgPT09IDAgJiYgdGhpcy5yZWFkVG9rZW5faW50ZXJwcmV0ZXIoKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBuZXh0UG9zID0gdGhpcy5zdGF0ZS5wb3MgKyAxO1xuICAgIGNvbnN0IG5leHQgPSB0aGlzLmNvZGVQb2ludEF0UG9zKG5leHRQb3MpO1xuICAgIGlmIChuZXh0ID49IDQ4ICYmIG5leHQgPD0gNTcpIHtcbiAgICAgIHRocm93IHRoaXMucmFpc2UoRXJyb3JzLlVuZXhwZWN0ZWREaWdpdEFmdGVySGFzaCwgdGhpcy5zdGF0ZS5jdXJQb3NpdGlvbigpKTtcbiAgICB9XG4gICAgaWYgKG5leHQgPT09IDEyMyB8fCBuZXh0ID09PSA5MSAmJiB0aGlzLmhhc1BsdWdpbihcInJlY29yZEFuZFR1cGxlXCIpKSB7XG4gICAgICB0aGlzLmV4cGVjdFBsdWdpbihcInJlY29yZEFuZFR1cGxlXCIpO1xuICAgICAgaWYgKHRoaXMuZ2V0UGx1Z2luT3B0aW9uKFwicmVjb3JkQW5kVHVwbGVcIiwgXCJzeW50YXhUeXBlXCIpID09PSBcImJhclwiKSB7XG4gICAgICAgIHRocm93IHRoaXMucmFpc2UobmV4dCA9PT0gMTIzID8gRXJyb3JzLlJlY29yZEV4cHJlc3Npb25IYXNoSW5jb3JyZWN0U3RhcnRTeW50YXhUeXBlIDogRXJyb3JzLlR1cGxlRXhwcmVzc2lvbkhhc2hJbmNvcnJlY3RTdGFydFN5bnRheFR5cGUsIHRoaXMuc3RhdGUuY3VyUG9zaXRpb24oKSk7XG4gICAgICB9XG4gICAgICB0aGlzLnN0YXRlLnBvcyArPSAyO1xuICAgICAgaWYgKG5leHQgPT09IDEyMykge1xuICAgICAgICB0aGlzLmZpbmlzaFRva2VuKDcpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5maW5pc2hUb2tlbigxKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGlzSWRlbnRpZmllclN0YXJ0KG5leHQpKSB7XG4gICAgICArK3RoaXMuc3RhdGUucG9zO1xuICAgICAgdGhpcy5maW5pc2hUb2tlbigxMzksIHRoaXMucmVhZFdvcmQxKG5leHQpKTtcbiAgICB9IGVsc2UgaWYgKG5leHQgPT09IDkyKSB7XG4gICAgICArK3RoaXMuc3RhdGUucG9zO1xuICAgICAgdGhpcy5maW5pc2hUb2tlbigxMzksIHRoaXMucmVhZFdvcmQxKCkpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmZpbmlzaE9wKDI3LCAxKTtcbiAgICB9XG4gIH1cbiAgcmVhZFRva2VuX2RvdCgpIHtcbiAgICBjb25zdCBuZXh0ID0gdGhpcy5pbnB1dC5jaGFyQ29kZUF0KHRoaXMuc3RhdGUucG9zICsgMSk7XG4gICAgaWYgKG5leHQgPj0gNDggJiYgbmV4dCA8PSA1Nykge1xuICAgICAgdGhpcy5yZWFkTnVtYmVyKHRydWUpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAobmV4dCA9PT0gNDYgJiYgdGhpcy5pbnB1dC5jaGFyQ29kZUF0KHRoaXMuc3RhdGUucG9zICsgMikgPT09IDQ2KSB7XG4gICAgICB0aGlzLnN0YXRlLnBvcyArPSAzO1xuICAgICAgdGhpcy5maW5pc2hUb2tlbigyMSk7XG4gICAgfSBlbHNlIHtcbiAgICAgICsrdGhpcy5zdGF0ZS5wb3M7XG4gICAgICB0aGlzLmZpbmlzaFRva2VuKDE2KTtcbiAgICB9XG4gIH1cbiAgcmVhZFRva2VuX3NsYXNoKCkge1xuICAgIGNvbnN0IG5leHQgPSB0aGlzLmlucHV0LmNoYXJDb2RlQXQodGhpcy5zdGF0ZS5wb3MgKyAxKTtcbiAgICBpZiAobmV4dCA9PT0gNjEpIHtcbiAgICAgIHRoaXMuZmluaXNoT3AoMzEsIDIpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmZpbmlzaE9wKDU2LCAxKTtcbiAgICB9XG4gIH1cbiAgcmVhZFRva2VuX2ludGVycHJldGVyKCkge1xuICAgIGlmICh0aGlzLnN0YXRlLnBvcyAhPT0gMCB8fCB0aGlzLmxlbmd0aCA8IDIpIHJldHVybiBmYWxzZTtcbiAgICBsZXQgY2ggPSB0aGlzLmlucHV0LmNoYXJDb2RlQXQodGhpcy5zdGF0ZS5wb3MgKyAxKTtcbiAgICBpZiAoY2ggIT09IDMzKSByZXR1cm4gZmFsc2U7XG4gICAgY29uc3Qgc3RhcnQgPSB0aGlzLnN0YXRlLnBvcztcbiAgICB0aGlzLnN0YXRlLnBvcyArPSAxO1xuICAgIHdoaWxlICghaXNOZXdMaW5lKGNoKSAmJiArK3RoaXMuc3RhdGUucG9zIDwgdGhpcy5sZW5ndGgpIHtcbiAgICAgIGNoID0gdGhpcy5pbnB1dC5jaGFyQ29kZUF0KHRoaXMuc3RhdGUucG9zKTtcbiAgICB9XG4gICAgY29uc3QgdmFsdWUgPSB0aGlzLmlucHV0LnNsaWNlKHN0YXJ0ICsgMiwgdGhpcy5zdGF0ZS5wb3MpO1xuICAgIHRoaXMuZmluaXNoVG9rZW4oMjgsIHZhbHVlKTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICByZWFkVG9rZW5fbXVsdF9tb2R1bG8oY29kZSkge1xuICAgIGxldCB0eXBlID0gY29kZSA9PT0gNDIgPyA1NSA6IDU0O1xuICAgIGxldCB3aWR0aCA9IDE7XG4gICAgbGV0IG5leHQgPSB0aGlzLmlucHV0LmNoYXJDb2RlQXQodGhpcy5zdGF0ZS5wb3MgKyAxKTtcbiAgICBpZiAoY29kZSA9PT0gNDIgJiYgbmV4dCA9PT0gNDIpIHtcbiAgICAgIHdpZHRoKys7XG4gICAgICBuZXh0ID0gdGhpcy5pbnB1dC5jaGFyQ29kZUF0KHRoaXMuc3RhdGUucG9zICsgMik7XG4gICAgICB0eXBlID0gNTc7XG4gICAgfVxuICAgIGlmIChuZXh0ID09PSA2MSAmJiAhdGhpcy5zdGF0ZS5pblR5cGUpIHtcbiAgICAgIHdpZHRoKys7XG4gICAgICB0eXBlID0gY29kZSA9PT0gMzcgPyAzMyA6IDMwO1xuICAgIH1cbiAgICB0aGlzLmZpbmlzaE9wKHR5cGUsIHdpZHRoKTtcbiAgfVxuICByZWFkVG9rZW5fcGlwZV9hbXAoY29kZSkge1xuICAgIGNvbnN0IG5leHQgPSB0aGlzLmlucHV0LmNoYXJDb2RlQXQodGhpcy5zdGF0ZS5wb3MgKyAxKTtcbiAgICBpZiAobmV4dCA9PT0gY29kZSkge1xuICAgICAgaWYgKHRoaXMuaW5wdXQuY2hhckNvZGVBdCh0aGlzLnN0YXRlLnBvcyArIDIpID09PSA2MSkge1xuICAgICAgICB0aGlzLmZpbmlzaE9wKDMwLCAzKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuZmluaXNoT3AoY29kZSA9PT0gMTI0ID8gNDEgOiA0MiwgMik7XG4gICAgICB9XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmIChjb2RlID09PSAxMjQpIHtcbiAgICAgIGlmIChuZXh0ID09PSA2Mikge1xuICAgICAgICB0aGlzLmZpbmlzaE9wKDM5LCAyKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMuaGFzUGx1Z2luKFwicmVjb3JkQW5kVHVwbGVcIikgJiYgbmV4dCA9PT0gMTI1KSB7XG4gICAgICAgIGlmICh0aGlzLmdldFBsdWdpbk9wdGlvbihcInJlY29yZEFuZFR1cGxlXCIsIFwic3ludGF4VHlwZVwiKSAhPT0gXCJiYXJcIikge1xuICAgICAgICAgIHRocm93IHRoaXMucmFpc2UoRXJyb3JzLlJlY29yZEV4cHJlc3Npb25CYXJJbmNvcnJlY3RFbmRTeW50YXhUeXBlLCB0aGlzLnN0YXRlLmN1clBvc2l0aW9uKCkpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuc3RhdGUucG9zICs9IDI7XG4gICAgICAgIHRoaXMuZmluaXNoVG9rZW4oOSk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLmhhc1BsdWdpbihcInJlY29yZEFuZFR1cGxlXCIpICYmIG5leHQgPT09IDkzKSB7XG4gICAgICAgIGlmICh0aGlzLmdldFBsdWdpbk9wdGlvbihcInJlY29yZEFuZFR1cGxlXCIsIFwic3ludGF4VHlwZVwiKSAhPT0gXCJiYXJcIikge1xuICAgICAgICAgIHRocm93IHRoaXMucmFpc2UoRXJyb3JzLlR1cGxlRXhwcmVzc2lvbkJhckluY29ycmVjdEVuZFN5bnRheFR5cGUsIHRoaXMuc3RhdGUuY3VyUG9zaXRpb24oKSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5zdGF0ZS5wb3MgKz0gMjtcbiAgICAgICAgdGhpcy5maW5pc2hUb2tlbig0KTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAobmV4dCA9PT0gNjEpIHtcbiAgICAgIHRoaXMuZmluaXNoT3AoMzAsIDIpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLmZpbmlzaE9wKGNvZGUgPT09IDEyNCA/IDQzIDogNDUsIDEpO1xuICB9XG4gIHJlYWRUb2tlbl9jYXJldCgpIHtcbiAgICBjb25zdCBuZXh0ID0gdGhpcy5pbnB1dC5jaGFyQ29kZUF0KHRoaXMuc3RhdGUucG9zICsgMSk7XG4gICAgaWYgKG5leHQgPT09IDYxICYmICF0aGlzLnN0YXRlLmluVHlwZSkge1xuICAgICAgdGhpcy5maW5pc2hPcCgzMiwgMik7XG4gICAgfSBlbHNlIGlmIChuZXh0ID09PSA5NCAmJiB0aGlzLmhhc1BsdWdpbihbXCJwaXBlbGluZU9wZXJhdG9yXCIsIHtcbiAgICAgIHByb3Bvc2FsOiBcImhhY2tcIixcbiAgICAgIHRvcGljVG9rZW46IFwiXl5cIlxuICAgIH1dKSkge1xuICAgICAgdGhpcy5maW5pc2hPcCgzNywgMik7XG4gICAgICBjb25zdCBsb29rYWhlYWRDaCA9IHRoaXMuaW5wdXQuY29kZVBvaW50QXQodGhpcy5zdGF0ZS5wb3MpO1xuICAgICAgaWYgKGxvb2thaGVhZENoID09PSA5NCkge1xuICAgICAgICB0aGlzLnVuZXhwZWN0ZWQoKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5maW5pc2hPcCg0NCwgMSk7XG4gICAgfVxuICB9XG4gIHJlYWRUb2tlbl9hdFNpZ24oKSB7XG4gICAgY29uc3QgbmV4dCA9IHRoaXMuaW5wdXQuY2hhckNvZGVBdCh0aGlzLnN0YXRlLnBvcyArIDEpO1xuICAgIGlmIChuZXh0ID09PSA2NCAmJiB0aGlzLmhhc1BsdWdpbihbXCJwaXBlbGluZU9wZXJhdG9yXCIsIHtcbiAgICAgIHByb3Bvc2FsOiBcImhhY2tcIixcbiAgICAgIHRvcGljVG9rZW46IFwiQEBcIlxuICAgIH1dKSkge1xuICAgICAgdGhpcy5maW5pc2hPcCgzOCwgMik7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuZmluaXNoT3AoMjYsIDEpO1xuICAgIH1cbiAgfVxuICByZWFkVG9rZW5fcGx1c19taW4oY29kZSkge1xuICAgIGNvbnN0IG5leHQgPSB0aGlzLmlucHV0LmNoYXJDb2RlQXQodGhpcy5zdGF0ZS5wb3MgKyAxKTtcbiAgICBpZiAobmV4dCA9PT0gY29kZSkge1xuICAgICAgdGhpcy5maW5pc2hPcCgzNCwgMik7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmIChuZXh0ID09PSA2MSkge1xuICAgICAgdGhpcy5maW5pc2hPcCgzMCwgMik7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuZmluaXNoT3AoNTMsIDEpO1xuICAgIH1cbiAgfVxuICByZWFkVG9rZW5fbHQoKSB7XG4gICAgY29uc3Qge1xuICAgICAgcG9zXG4gICAgfSA9IHRoaXMuc3RhdGU7XG4gICAgY29uc3QgbmV4dCA9IHRoaXMuaW5wdXQuY2hhckNvZGVBdChwb3MgKyAxKTtcbiAgICBpZiAobmV4dCA9PT0gNjApIHtcbiAgICAgIGlmICh0aGlzLmlucHV0LmNoYXJDb2RlQXQocG9zICsgMikgPT09IDYxKSB7XG4gICAgICAgIHRoaXMuZmluaXNoT3AoMzAsIDMpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB0aGlzLmZpbmlzaE9wKDUxLCAyKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKG5leHQgPT09IDYxKSB7XG4gICAgICB0aGlzLmZpbmlzaE9wKDQ5LCAyKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5maW5pc2hPcCg0NywgMSk7XG4gIH1cbiAgcmVhZFRva2VuX2d0KCkge1xuICAgIGNvbnN0IHtcbiAgICAgIHBvc1xuICAgIH0gPSB0aGlzLnN0YXRlO1xuICAgIGNvbnN0IG5leHQgPSB0aGlzLmlucHV0LmNoYXJDb2RlQXQocG9zICsgMSk7XG4gICAgaWYgKG5leHQgPT09IDYyKSB7XG4gICAgICBjb25zdCBzaXplID0gdGhpcy5pbnB1dC5jaGFyQ29kZUF0KHBvcyArIDIpID09PSA2MiA/IDMgOiAyO1xuICAgICAgaWYgKHRoaXMuaW5wdXQuY2hhckNvZGVBdChwb3MgKyBzaXplKSA9PT0gNjEpIHtcbiAgICAgICAgdGhpcy5maW5pc2hPcCgzMCwgc2l6ZSArIDEpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB0aGlzLmZpbmlzaE9wKDUyLCBzaXplKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKG5leHQgPT09IDYxKSB7XG4gICAgICB0aGlzLmZpbmlzaE9wKDQ5LCAyKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5maW5pc2hPcCg0OCwgMSk7XG4gIH1cbiAgcmVhZFRva2VuX2VxX2V4Y2woY29kZSkge1xuICAgIGNvbnN0IG5leHQgPSB0aGlzLmlucHV0LmNoYXJDb2RlQXQodGhpcy5zdGF0ZS5wb3MgKyAxKTtcbiAgICBpZiAobmV4dCA9PT0gNjEpIHtcbiAgICAgIHRoaXMuZmluaXNoT3AoNDYsIHRoaXMuaW5wdXQuY2hhckNvZGVBdCh0aGlzLnN0YXRlLnBvcyArIDIpID09PSA2MSA/IDMgOiAyKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKGNvZGUgPT09IDYxICYmIG5leHQgPT09IDYyKSB7XG4gICAgICB0aGlzLnN0YXRlLnBvcyArPSAyO1xuICAgICAgdGhpcy5maW5pc2hUb2tlbigxOSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuZmluaXNoT3AoY29kZSA9PT0gNjEgPyAyOSA6IDM1LCAxKTtcbiAgfVxuICByZWFkVG9rZW5fcXVlc3Rpb24oKSB7XG4gICAgY29uc3QgbmV4dCA9IHRoaXMuaW5wdXQuY2hhckNvZGVBdCh0aGlzLnN0YXRlLnBvcyArIDEpO1xuICAgIGNvbnN0IG5leHQyID0gdGhpcy5pbnB1dC5jaGFyQ29kZUF0KHRoaXMuc3RhdGUucG9zICsgMik7XG4gICAgaWYgKG5leHQgPT09IDYzKSB7XG4gICAgICBpZiAobmV4dDIgPT09IDYxKSB7XG4gICAgICAgIHRoaXMuZmluaXNoT3AoMzAsIDMpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5maW5pc2hPcCg0MCwgMik7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChuZXh0ID09PSA0NiAmJiAhKG5leHQyID49IDQ4ICYmIG5leHQyIDw9IDU3KSkge1xuICAgICAgdGhpcy5zdGF0ZS5wb3MgKz0gMjtcbiAgICAgIHRoaXMuZmluaXNoVG9rZW4oMTgpO1xuICAgIH0gZWxzZSB7XG4gICAgICArK3RoaXMuc3RhdGUucG9zO1xuICAgICAgdGhpcy5maW5pc2hUb2tlbigxNyk7XG4gICAgfVxuICB9XG4gIGdldFRva2VuRnJvbUNvZGUoY29kZSkge1xuICAgIHN3aXRjaCAoY29kZSkge1xuICAgICAgY2FzZSA0NjpcbiAgICAgICAgdGhpcy5yZWFkVG9rZW5fZG90KCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIGNhc2UgNDA6XG4gICAgICAgICsrdGhpcy5zdGF0ZS5wb3M7XG4gICAgICAgIHRoaXMuZmluaXNoVG9rZW4oMTApO1xuICAgICAgICByZXR1cm47XG4gICAgICBjYXNlIDQxOlxuICAgICAgICArK3RoaXMuc3RhdGUucG9zO1xuICAgICAgICB0aGlzLmZpbmlzaFRva2VuKDExKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgY2FzZSA1OTpcbiAgICAgICAgKyt0aGlzLnN0YXRlLnBvcztcbiAgICAgICAgdGhpcy5maW5pc2hUb2tlbigxMyk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIGNhc2UgNDQ6XG4gICAgICAgICsrdGhpcy5zdGF0ZS5wb3M7XG4gICAgICAgIHRoaXMuZmluaXNoVG9rZW4oMTIpO1xuICAgICAgICByZXR1cm47XG4gICAgICBjYXNlIDkxOlxuICAgICAgICBpZiAodGhpcy5oYXNQbHVnaW4oXCJyZWNvcmRBbmRUdXBsZVwiKSAmJiB0aGlzLmlucHV0LmNoYXJDb2RlQXQodGhpcy5zdGF0ZS5wb3MgKyAxKSA9PT0gMTI0KSB7XG4gICAgICAgICAgaWYgKHRoaXMuZ2V0UGx1Z2luT3B0aW9uKFwicmVjb3JkQW5kVHVwbGVcIiwgXCJzeW50YXhUeXBlXCIpICE9PSBcImJhclwiKSB7XG4gICAgICAgICAgICB0aHJvdyB0aGlzLnJhaXNlKEVycm9ycy5UdXBsZUV4cHJlc3Npb25CYXJJbmNvcnJlY3RTdGFydFN5bnRheFR5cGUsIHRoaXMuc3RhdGUuY3VyUG9zaXRpb24oKSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHRoaXMuc3RhdGUucG9zICs9IDI7XG4gICAgICAgICAgdGhpcy5maW5pc2hUb2tlbigyKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICArK3RoaXMuc3RhdGUucG9zO1xuICAgICAgICAgIHRoaXMuZmluaXNoVG9rZW4oMCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuO1xuICAgICAgY2FzZSA5MzpcbiAgICAgICAgKyt0aGlzLnN0YXRlLnBvcztcbiAgICAgICAgdGhpcy5maW5pc2hUb2tlbigzKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgY2FzZSAxMjM6XG4gICAgICAgIGlmICh0aGlzLmhhc1BsdWdpbihcInJlY29yZEFuZFR1cGxlXCIpICYmIHRoaXMuaW5wdXQuY2hhckNvZGVBdCh0aGlzLnN0YXRlLnBvcyArIDEpID09PSAxMjQpIHtcbiAgICAgICAgICBpZiAodGhpcy5nZXRQbHVnaW5PcHRpb24oXCJyZWNvcmRBbmRUdXBsZVwiLCBcInN5bnRheFR5cGVcIikgIT09IFwiYmFyXCIpIHtcbiAgICAgICAgICAgIHRocm93IHRoaXMucmFpc2UoRXJyb3JzLlJlY29yZEV4cHJlc3Npb25CYXJJbmNvcnJlY3RTdGFydFN5bnRheFR5cGUsIHRoaXMuc3RhdGUuY3VyUG9zaXRpb24oKSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHRoaXMuc3RhdGUucG9zICs9IDI7XG4gICAgICAgICAgdGhpcy5maW5pc2hUb2tlbig2KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICArK3RoaXMuc3RhdGUucG9zO1xuICAgICAgICAgIHRoaXMuZmluaXNoVG9rZW4oNSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuO1xuICAgICAgY2FzZSAxMjU6XG4gICAgICAgICsrdGhpcy5zdGF0ZS5wb3M7XG4gICAgICAgIHRoaXMuZmluaXNoVG9rZW4oOCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIGNhc2UgNTg6XG4gICAgICAgIGlmICh0aGlzLmhhc1BsdWdpbihcImZ1bmN0aW9uQmluZFwiKSAmJiB0aGlzLmlucHV0LmNoYXJDb2RlQXQodGhpcy5zdGF0ZS5wb3MgKyAxKSA9PT0gNTgpIHtcbiAgICAgICAgICB0aGlzLmZpbmlzaE9wKDE1LCAyKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICArK3RoaXMuc3RhdGUucG9zO1xuICAgICAgICAgIHRoaXMuZmluaXNoVG9rZW4oMTQpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybjtcbiAgICAgIGNhc2UgNjM6XG4gICAgICAgIHRoaXMucmVhZFRva2VuX3F1ZXN0aW9uKCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIGNhc2UgOTY6XG4gICAgICAgIHRoaXMucmVhZFRlbXBsYXRlVG9rZW4oKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgY2FzZSA0ODpcbiAgICAgICAge1xuICAgICAgICAgIGNvbnN0IG5leHQgPSB0aGlzLmlucHV0LmNoYXJDb2RlQXQodGhpcy5zdGF0ZS5wb3MgKyAxKTtcbiAgICAgICAgICBpZiAobmV4dCA9PT0gMTIwIHx8IG5leHQgPT09IDg4KSB7XG4gICAgICAgICAgICB0aGlzLnJlYWRSYWRpeE51bWJlcigxNik7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChuZXh0ID09PSAxMTEgfHwgbmV4dCA9PT0gNzkpIHtcbiAgICAgICAgICAgIHRoaXMucmVhZFJhZGl4TnVtYmVyKDgpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAobmV4dCA9PT0gOTggfHwgbmV4dCA9PT0gNjYpIHtcbiAgICAgICAgICAgIHRoaXMucmVhZFJhZGl4TnVtYmVyKDIpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgY2FzZSA0OTpcbiAgICAgIGNhc2UgNTA6XG4gICAgICBjYXNlIDUxOlxuICAgICAgY2FzZSA1MjpcbiAgICAgIGNhc2UgNTM6XG4gICAgICBjYXNlIDU0OlxuICAgICAgY2FzZSA1NTpcbiAgICAgIGNhc2UgNTY6XG4gICAgICBjYXNlIDU3OlxuICAgICAgICB0aGlzLnJlYWROdW1iZXIoZmFsc2UpO1xuICAgICAgICByZXR1cm47XG4gICAgICBjYXNlIDM0OlxuICAgICAgY2FzZSAzOTpcbiAgICAgICAgdGhpcy5yZWFkU3RyaW5nKGNvZGUpO1xuICAgICAgICByZXR1cm47XG4gICAgICBjYXNlIDQ3OlxuICAgICAgICB0aGlzLnJlYWRUb2tlbl9zbGFzaCgpO1xuICAgICAgICByZXR1cm47XG4gICAgICBjYXNlIDM3OlxuICAgICAgY2FzZSA0MjpcbiAgICAgICAgdGhpcy5yZWFkVG9rZW5fbXVsdF9tb2R1bG8oY29kZSk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIGNhc2UgMTI0OlxuICAgICAgY2FzZSAzODpcbiAgICAgICAgdGhpcy5yZWFkVG9rZW5fcGlwZV9hbXAoY29kZSk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIGNhc2UgOTQ6XG4gICAgICAgIHRoaXMucmVhZFRva2VuX2NhcmV0KCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIGNhc2UgNDM6XG4gICAgICBjYXNlIDQ1OlxuICAgICAgICB0aGlzLnJlYWRUb2tlbl9wbHVzX21pbihjb2RlKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgY2FzZSA2MDpcbiAgICAgICAgdGhpcy5yZWFkVG9rZW5fbHQoKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgY2FzZSA2MjpcbiAgICAgICAgdGhpcy5yZWFkVG9rZW5fZ3QoKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgY2FzZSA2MTpcbiAgICAgIGNhc2UgMzM6XG4gICAgICAgIHRoaXMucmVhZFRva2VuX2VxX2V4Y2woY29kZSk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIGNhc2UgMTI2OlxuICAgICAgICB0aGlzLmZpbmlzaE9wKDM2LCAxKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgY2FzZSA2NDpcbiAgICAgICAgdGhpcy5yZWFkVG9rZW5fYXRTaWduKCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIGNhc2UgMzU6XG4gICAgICAgIHRoaXMucmVhZFRva2VuX251bWJlclNpZ24oKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgY2FzZSA5MjpcbiAgICAgICAgdGhpcy5yZWFkV29yZCgpO1xuICAgICAgICByZXR1cm47XG4gICAgICBkZWZhdWx0OlxuICAgICAgICBpZiAoaXNJZGVudGlmaWVyU3RhcnQoY29kZSkpIHtcbiAgICAgICAgICB0aGlzLnJlYWRXb3JkKGNvZGUpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgIH1cbiAgICB0aHJvdyB0aGlzLnJhaXNlKEVycm9ycy5JbnZhbGlkT3JVbmV4cGVjdGVkVG9rZW4sIHRoaXMuc3RhdGUuY3VyUG9zaXRpb24oKSwge1xuICAgICAgdW5leHBlY3RlZDogU3RyaW5nLmZyb21Db2RlUG9pbnQoY29kZSlcbiAgICB9KTtcbiAgfVxuICBmaW5pc2hPcCh0eXBlLCBzaXplKSB7XG4gICAgY29uc3Qgc3RyID0gdGhpcy5pbnB1dC5zbGljZSh0aGlzLnN0YXRlLnBvcywgdGhpcy5zdGF0ZS5wb3MgKyBzaXplKTtcbiAgICB0aGlzLnN0YXRlLnBvcyArPSBzaXplO1xuICAgIHRoaXMuZmluaXNoVG9rZW4odHlwZSwgc3RyKTtcbiAgfVxuICByZWFkUmVnZXhwKCkge1xuICAgIGNvbnN0IHN0YXJ0TG9jID0gdGhpcy5zdGF0ZS5zdGFydExvYztcbiAgICBjb25zdCBzdGFydCA9IHRoaXMuc3RhdGUuc3RhcnQgKyAxO1xuICAgIGxldCBlc2NhcGVkLCBpbkNsYXNzO1xuICAgIGxldCB7XG4gICAgICBwb3NcbiAgICB9ID0gdGhpcy5zdGF0ZTtcbiAgICBmb3IgKDs7ICsrcG9zKSB7XG4gICAgICBpZiAocG9zID49IHRoaXMubGVuZ3RoKSB7XG4gICAgICAgIHRocm93IHRoaXMucmFpc2UoRXJyb3JzLlVudGVybWluYXRlZFJlZ0V4cCwgY3JlYXRlUG9zaXRpb25XaXRoQ29sdW1uT2Zmc2V0KHN0YXJ0TG9jLCAxKSk7XG4gICAgICB9XG4gICAgICBjb25zdCBjaCA9IHRoaXMuaW5wdXQuY2hhckNvZGVBdChwb3MpO1xuICAgICAgaWYgKGlzTmV3TGluZShjaCkpIHtcbiAgICAgICAgdGhyb3cgdGhpcy5yYWlzZShFcnJvcnMuVW50ZXJtaW5hdGVkUmVnRXhwLCBjcmVhdGVQb3NpdGlvbldpdGhDb2x1bW5PZmZzZXQoc3RhcnRMb2MsIDEpKTtcbiAgICAgIH1cbiAgICAgIGlmIChlc2NhcGVkKSB7XG4gICAgICAgIGVzY2FwZWQgPSBmYWxzZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChjaCA9PT0gOTEpIHtcbiAgICAgICAgICBpbkNsYXNzID0gdHJ1ZTtcbiAgICAgICAgfSBlbHNlIGlmIChjaCA9PT0gOTMgJiYgaW5DbGFzcykge1xuICAgICAgICAgIGluQ2xhc3MgPSBmYWxzZTtcbiAgICAgICAgfSBlbHNlIGlmIChjaCA9PT0gNDcgJiYgIWluQ2xhc3MpIHtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBlc2NhcGVkID0gY2ggPT09IDkyO1xuICAgICAgfVxuICAgIH1cbiAgICBjb25zdCBjb250ZW50ID0gdGhpcy5pbnB1dC5zbGljZShzdGFydCwgcG9zKTtcbiAgICArK3BvcztcbiAgICBsZXQgbW9kcyA9IFwiXCI7XG4gICAgY29uc3QgbmV4dFBvcyA9ICgpID0+IGNyZWF0ZVBvc2l0aW9uV2l0aENvbHVtbk9mZnNldChzdGFydExvYywgcG9zICsgMiAtIHN0YXJ0KTtcbiAgICB3aGlsZSAocG9zIDwgdGhpcy5sZW5ndGgpIHtcbiAgICAgIGNvbnN0IGNwID0gdGhpcy5jb2RlUG9pbnRBdFBvcyhwb3MpO1xuICAgICAgY29uc3QgY2hhciA9IFN0cmluZy5mcm9tQ2hhckNvZGUoY3ApO1xuICAgICAgaWYgKFZBTElEX1JFR0VYX0ZMQUdTLmhhcyhjcCkpIHtcbiAgICAgICAgaWYgKGNwID09PSAxMTgpIHtcbiAgICAgICAgICBpZiAobW9kcy5pbmNsdWRlcyhcInVcIikpIHtcbiAgICAgICAgICAgIHRoaXMucmFpc2UoRXJyb3JzLkluY29tcGF0aWJsZVJlZ0V4cFVWRmxhZ3MsIG5leHRQb3MoKSk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKGNwID09PSAxMTcpIHtcbiAgICAgICAgICBpZiAobW9kcy5pbmNsdWRlcyhcInZcIikpIHtcbiAgICAgICAgICAgIHRoaXMucmFpc2UoRXJyb3JzLkluY29tcGF0aWJsZVJlZ0V4cFVWRmxhZ3MsIG5leHRQb3MoKSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChtb2RzLmluY2x1ZGVzKGNoYXIpKSB7XG4gICAgICAgICAgdGhpcy5yYWlzZShFcnJvcnMuRHVwbGljYXRlUmVnRXhwRmxhZ3MsIG5leHRQb3MoKSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoaXNJZGVudGlmaWVyQ2hhcihjcCkgfHwgY3AgPT09IDkyKSB7XG4gICAgICAgIHRoaXMucmFpc2UoRXJyb3JzLk1hbGZvcm1lZFJlZ0V4cEZsYWdzLCBuZXh0UG9zKCkpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICArK3BvcztcbiAgICAgIG1vZHMgKz0gY2hhcjtcbiAgICB9XG4gICAgdGhpcy5zdGF0ZS5wb3MgPSBwb3M7XG4gICAgdGhpcy5maW5pc2hUb2tlbigxMzgsIHtcbiAgICAgIHBhdHRlcm46IGNvbnRlbnQsXG4gICAgICBmbGFnczogbW9kc1xuICAgIH0pO1xuICB9XG4gIHJlYWRJbnQocmFkaXgsIGxlbiwgZm9yY2VMZW4gPSBmYWxzZSwgYWxsb3dOdW1TZXBhcmF0b3IgPSB0cnVlKSB7XG4gICAgY29uc3Qge1xuICAgICAgbixcbiAgICAgIHBvc1xuICAgIH0gPSByZWFkSW50KHRoaXMuaW5wdXQsIHRoaXMuc3RhdGUucG9zLCB0aGlzLnN0YXRlLmxpbmVTdGFydCwgdGhpcy5zdGF0ZS5jdXJMaW5lLCByYWRpeCwgbGVuLCBmb3JjZUxlbiwgYWxsb3dOdW1TZXBhcmF0b3IsIHRoaXMuZXJyb3JIYW5kbGVyc19yZWFkSW50LCBmYWxzZSk7XG4gICAgdGhpcy5zdGF0ZS5wb3MgPSBwb3M7XG4gICAgcmV0dXJuIG47XG4gIH1cbiAgcmVhZFJhZGl4TnVtYmVyKHJhZGl4KSB7XG4gICAgY29uc3Qgc3RhcnQgPSB0aGlzLnN0YXRlLnBvcztcbiAgICBjb25zdCBzdGFydExvYyA9IHRoaXMuc3RhdGUuY3VyUG9zaXRpb24oKTtcbiAgICBsZXQgaXNCaWdJbnQgPSBmYWxzZTtcbiAgICB0aGlzLnN0YXRlLnBvcyArPSAyO1xuICAgIGNvbnN0IHZhbCA9IHRoaXMucmVhZEludChyYWRpeCk7XG4gICAgaWYgKHZhbCA9PSBudWxsKSB7XG4gICAgICB0aGlzLnJhaXNlKEVycm9ycy5JbnZhbGlkRGlnaXQsIGNyZWF0ZVBvc2l0aW9uV2l0aENvbHVtbk9mZnNldChzdGFydExvYywgMiksIHtcbiAgICAgICAgcmFkaXhcbiAgICAgIH0pO1xuICAgIH1cbiAgICBjb25zdCBuZXh0ID0gdGhpcy5pbnB1dC5jaGFyQ29kZUF0KHRoaXMuc3RhdGUucG9zKTtcbiAgICBpZiAobmV4dCA9PT0gMTEwKSB7XG4gICAgICArK3RoaXMuc3RhdGUucG9zO1xuICAgICAgaXNCaWdJbnQgPSB0cnVlO1xuICAgIH0gZWxzZSBpZiAobmV4dCA9PT0gMTA5KSB7XG4gICAgICB0aHJvdyB0aGlzLnJhaXNlKEVycm9ycy5JbnZhbGlkRGVjaW1hbCwgc3RhcnRMb2MpO1xuICAgIH1cbiAgICBpZiAoaXNJZGVudGlmaWVyU3RhcnQodGhpcy5jb2RlUG9pbnRBdFBvcyh0aGlzLnN0YXRlLnBvcykpKSB7XG4gICAgICB0aHJvdyB0aGlzLnJhaXNlKEVycm9ycy5OdW1iZXJJZGVudGlmaWVyLCB0aGlzLnN0YXRlLmN1clBvc2l0aW9uKCkpO1xuICAgIH1cbiAgICBpZiAoaXNCaWdJbnQpIHtcbiAgICAgIGNvbnN0IHN0ciA9IHRoaXMuaW5wdXQuc2xpY2Uoc3RhcnQsIHRoaXMuc3RhdGUucG9zKS5yZXBsYWNlKC9bX25dL2csIFwiXCIpO1xuICAgICAgdGhpcy5maW5pc2hUb2tlbigxMzYsIHN0cik7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuZmluaXNoVG9rZW4oMTM1LCB2YWwpO1xuICB9XG4gIHJlYWROdW1iZXIoc3RhcnRzV2l0aERvdCkge1xuICAgIGNvbnN0IHN0YXJ0ID0gdGhpcy5zdGF0ZS5wb3M7XG4gICAgY29uc3Qgc3RhcnRMb2MgPSB0aGlzLnN0YXRlLmN1clBvc2l0aW9uKCk7XG4gICAgbGV0IGlzRmxvYXQgPSBmYWxzZTtcbiAgICBsZXQgaXNCaWdJbnQgPSBmYWxzZTtcbiAgICBsZXQgaGFzRXhwb25lbnQgPSBmYWxzZTtcbiAgICBsZXQgaXNPY3RhbCA9IGZhbHNlO1xuICAgIGlmICghc3RhcnRzV2l0aERvdCAmJiB0aGlzLnJlYWRJbnQoMTApID09PSBudWxsKSB7XG4gICAgICB0aGlzLnJhaXNlKEVycm9ycy5JbnZhbGlkTnVtYmVyLCB0aGlzLnN0YXRlLmN1clBvc2l0aW9uKCkpO1xuICAgIH1cbiAgICBjb25zdCBoYXNMZWFkaW5nWmVybyA9IHRoaXMuc3RhdGUucG9zIC0gc3RhcnQgPj0gMiAmJiB0aGlzLmlucHV0LmNoYXJDb2RlQXQoc3RhcnQpID09PSA0ODtcbiAgICBpZiAoaGFzTGVhZGluZ1plcm8pIHtcbiAgICAgIGNvbnN0IGludGVnZXIgPSB0aGlzLmlucHV0LnNsaWNlKHN0YXJ0LCB0aGlzLnN0YXRlLnBvcyk7XG4gICAgICB0aGlzLnJlY29yZFN0cmljdE1vZGVFcnJvcnMoRXJyb3JzLlN0cmljdE9jdGFsTGl0ZXJhbCwgc3RhcnRMb2MpO1xuICAgICAgaWYgKCF0aGlzLnN0YXRlLnN0cmljdCkge1xuICAgICAgICBjb25zdCB1bmRlcnNjb3JlUG9zID0gaW50ZWdlci5pbmRleE9mKFwiX1wiKTtcbiAgICAgICAgaWYgKHVuZGVyc2NvcmVQb3MgPiAwKSB7XG4gICAgICAgICAgdGhpcy5yYWlzZShFcnJvcnMuWmVyb0RpZ2l0TnVtZXJpY1NlcGFyYXRvciwgY3JlYXRlUG9zaXRpb25XaXRoQ29sdW1uT2Zmc2V0KHN0YXJ0TG9jLCB1bmRlcnNjb3JlUG9zKSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlzT2N0YWwgPSBoYXNMZWFkaW5nWmVybyAmJiAhL1s4OV0vLnRlc3QoaW50ZWdlcik7XG4gICAgfVxuICAgIGxldCBuZXh0ID0gdGhpcy5pbnB1dC5jaGFyQ29kZUF0KHRoaXMuc3RhdGUucG9zKTtcbiAgICBpZiAobmV4dCA9PT0gNDYgJiYgIWlzT2N0YWwpIHtcbiAgICAgICsrdGhpcy5zdGF0ZS5wb3M7XG4gICAgICB0aGlzLnJlYWRJbnQoMTApO1xuICAgICAgaXNGbG9hdCA9IHRydWU7XG4gICAgICBuZXh0ID0gdGhpcy5pbnB1dC5jaGFyQ29kZUF0KHRoaXMuc3RhdGUucG9zKTtcbiAgICB9XG4gICAgaWYgKChuZXh0ID09PSA2OSB8fCBuZXh0ID09PSAxMDEpICYmICFpc09jdGFsKSB7XG4gICAgICBuZXh0ID0gdGhpcy5pbnB1dC5jaGFyQ29kZUF0KCsrdGhpcy5zdGF0ZS5wb3MpO1xuICAgICAgaWYgKG5leHQgPT09IDQzIHx8IG5leHQgPT09IDQ1KSB7XG4gICAgICAgICsrdGhpcy5zdGF0ZS5wb3M7XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5yZWFkSW50KDEwKSA9PT0gbnVsbCkge1xuICAgICAgICB0aGlzLnJhaXNlKEVycm9ycy5JbnZhbGlkT3JNaXNzaW5nRXhwb25lbnQsIHN0YXJ0TG9jKTtcbiAgICAgIH1cbiAgICAgIGlzRmxvYXQgPSB0cnVlO1xuICAgICAgaGFzRXhwb25lbnQgPSB0cnVlO1xuICAgICAgbmV4dCA9IHRoaXMuaW5wdXQuY2hhckNvZGVBdCh0aGlzLnN0YXRlLnBvcyk7XG4gICAgfVxuICAgIGlmIChuZXh0ID09PSAxMTApIHtcbiAgICAgIGlmIChpc0Zsb2F0IHx8IGhhc0xlYWRpbmdaZXJvKSB7XG4gICAgICAgIHRoaXMucmFpc2UoRXJyb3JzLkludmFsaWRCaWdJbnRMaXRlcmFsLCBzdGFydExvYyk7XG4gICAgICB9XG4gICAgICArK3RoaXMuc3RhdGUucG9zO1xuICAgICAgaXNCaWdJbnQgPSB0cnVlO1xuICAgIH1cbiAgICBpZiAobmV4dCA9PT0gMTA5KSB7XG4gICAgICB0aGlzLmV4cGVjdFBsdWdpbihcImRlY2ltYWxcIiwgdGhpcy5zdGF0ZS5jdXJQb3NpdGlvbigpKTtcbiAgICAgIGlmIChoYXNFeHBvbmVudCB8fCBoYXNMZWFkaW5nWmVybykge1xuICAgICAgICB0aGlzLnJhaXNlKEVycm9ycy5JbnZhbGlkRGVjaW1hbCwgc3RhcnRMb2MpO1xuICAgICAgfVxuICAgICAgKyt0aGlzLnN0YXRlLnBvcztcbiAgICAgIHZhciBpc0RlY2ltYWwgPSB0cnVlO1xuICAgIH1cbiAgICBpZiAoaXNJZGVudGlmaWVyU3RhcnQodGhpcy5jb2RlUG9pbnRBdFBvcyh0aGlzLnN0YXRlLnBvcykpKSB7XG4gICAgICB0aHJvdyB0aGlzLnJhaXNlKEVycm9ycy5OdW1iZXJJZGVudGlmaWVyLCB0aGlzLnN0YXRlLmN1clBvc2l0aW9uKCkpO1xuICAgIH1cbiAgICBjb25zdCBzdHIgPSB0aGlzLmlucHV0LnNsaWNlKHN0YXJ0LCB0aGlzLnN0YXRlLnBvcykucmVwbGFjZSgvW19tbl0vZywgXCJcIik7XG4gICAgaWYgKGlzQmlnSW50KSB7XG4gICAgICB0aGlzLmZpbmlzaFRva2VuKDEzNiwgc3RyKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKGlzRGVjaW1hbCkge1xuICAgICAgdGhpcy5maW5pc2hUb2tlbigxMzcsIHN0cik7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHZhbCA9IGlzT2N0YWwgPyBwYXJzZUludChzdHIsIDgpIDogcGFyc2VGbG9hdChzdHIpO1xuICAgIHRoaXMuZmluaXNoVG9rZW4oMTM1LCB2YWwpO1xuICB9XG4gIHJlYWRDb2RlUG9pbnQodGhyb3dPbkludmFsaWQpIHtcbiAgICBjb25zdCB7XG4gICAgICBjb2RlLFxuICAgICAgcG9zXG4gICAgfSA9IHJlYWRDb2RlUG9pbnQodGhpcy5pbnB1dCwgdGhpcy5zdGF0ZS5wb3MsIHRoaXMuc3RhdGUubGluZVN0YXJ0LCB0aGlzLnN0YXRlLmN1ckxpbmUsIHRocm93T25JbnZhbGlkLCB0aGlzLmVycm9ySGFuZGxlcnNfcmVhZENvZGVQb2ludCk7XG4gICAgdGhpcy5zdGF0ZS5wb3MgPSBwb3M7XG4gICAgcmV0dXJuIGNvZGU7XG4gIH1cbiAgcmVhZFN0cmluZyhxdW90ZSkge1xuICAgIGNvbnN0IHtcbiAgICAgIHN0cixcbiAgICAgIHBvcyxcbiAgICAgIGN1ckxpbmUsXG4gICAgICBsaW5lU3RhcnRcbiAgICB9ID0gcmVhZFN0cmluZ0NvbnRlbnRzKHF1b3RlID09PSAzNCA/IFwiZG91YmxlXCIgOiBcInNpbmdsZVwiLCB0aGlzLmlucHV0LCB0aGlzLnN0YXRlLnBvcyArIDEsIHRoaXMuc3RhdGUubGluZVN0YXJ0LCB0aGlzLnN0YXRlLmN1ckxpbmUsIHRoaXMuZXJyb3JIYW5kbGVyc19yZWFkU3RyaW5nQ29udGVudHNfc3RyaW5nKTtcbiAgICB0aGlzLnN0YXRlLnBvcyA9IHBvcyArIDE7XG4gICAgdGhpcy5zdGF0ZS5saW5lU3RhcnQgPSBsaW5lU3RhcnQ7XG4gICAgdGhpcy5zdGF0ZS5jdXJMaW5lID0gY3VyTGluZTtcbiAgICB0aGlzLmZpbmlzaFRva2VuKDEzNCwgc3RyKTtcbiAgfVxuICByZWFkVGVtcGxhdGVDb250aW51YXRpb24oKSB7XG4gICAgaWYgKCF0aGlzLm1hdGNoKDgpKSB7XG4gICAgICB0aGlzLnVuZXhwZWN0ZWQobnVsbCwgOCk7XG4gICAgfVxuICAgIHRoaXMuc3RhdGUucG9zLS07XG4gICAgdGhpcy5yZWFkVGVtcGxhdGVUb2tlbigpO1xuICB9XG4gIHJlYWRUZW1wbGF0ZVRva2VuKCkge1xuICAgIGNvbnN0IG9wZW5pbmcgPSB0aGlzLmlucHV0W3RoaXMuc3RhdGUucG9zXTtcbiAgICBjb25zdCB7XG4gICAgICBzdHIsXG4gICAgICBmaXJzdEludmFsaWRMb2MsXG4gICAgICBwb3MsXG4gICAgICBjdXJMaW5lLFxuICAgICAgbGluZVN0YXJ0XG4gICAgfSA9IHJlYWRTdHJpbmdDb250ZW50cyhcInRlbXBsYXRlXCIsIHRoaXMuaW5wdXQsIHRoaXMuc3RhdGUucG9zICsgMSwgdGhpcy5zdGF0ZS5saW5lU3RhcnQsIHRoaXMuc3RhdGUuY3VyTGluZSwgdGhpcy5lcnJvckhhbmRsZXJzX3JlYWRTdHJpbmdDb250ZW50c190ZW1wbGF0ZSk7XG4gICAgdGhpcy5zdGF0ZS5wb3MgPSBwb3MgKyAxO1xuICAgIHRoaXMuc3RhdGUubGluZVN0YXJ0ID0gbGluZVN0YXJ0O1xuICAgIHRoaXMuc3RhdGUuY3VyTGluZSA9IGN1ckxpbmU7XG4gICAgaWYgKGZpcnN0SW52YWxpZExvYykge1xuICAgICAgdGhpcy5zdGF0ZS5maXJzdEludmFsaWRUZW1wbGF0ZUVzY2FwZVBvcyA9IG5ldyBQb3NpdGlvbihmaXJzdEludmFsaWRMb2MuY3VyTGluZSwgZmlyc3RJbnZhbGlkTG9jLnBvcyAtIGZpcnN0SW52YWxpZExvYy5saW5lU3RhcnQsIHRoaXMuc291cmNlVG9PZmZzZXRQb3MoZmlyc3RJbnZhbGlkTG9jLnBvcykpO1xuICAgIH1cbiAgICBpZiAodGhpcy5pbnB1dC5jb2RlUG9pbnRBdChwb3MpID09PSA5Nikge1xuICAgICAgdGhpcy5maW5pc2hUb2tlbigyNCwgZmlyc3RJbnZhbGlkTG9jID8gbnVsbCA6IG9wZW5pbmcgKyBzdHIgKyBcImBcIik7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuc3RhdGUucG9zKys7XG4gICAgICB0aGlzLmZpbmlzaFRva2VuKDI1LCBmaXJzdEludmFsaWRMb2MgPyBudWxsIDogb3BlbmluZyArIHN0ciArIFwiJHtcIik7XG4gICAgfVxuICB9XG4gIHJlY29yZFN0cmljdE1vZGVFcnJvcnModG9QYXJzZUVycm9yLCBhdCkge1xuICAgIGNvbnN0IGluZGV4ID0gYXQuaW5kZXg7XG4gICAgaWYgKHRoaXMuc3RhdGUuc3RyaWN0ICYmICF0aGlzLnN0YXRlLnN0cmljdEVycm9ycy5oYXMoaW5kZXgpKSB7XG4gICAgICB0aGlzLnJhaXNlKHRvUGFyc2VFcnJvciwgYXQpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnN0YXRlLnN0cmljdEVycm9ycy5zZXQoaW5kZXgsIFt0b1BhcnNlRXJyb3IsIGF0XSk7XG4gICAgfVxuICB9XG4gIHJlYWRXb3JkMShmaXJzdENvZGUpIHtcbiAgICB0aGlzLnN0YXRlLmNvbnRhaW5zRXNjID0gZmFsc2U7XG4gICAgbGV0IHdvcmQgPSBcIlwiO1xuICAgIGNvbnN0IHN0YXJ0ID0gdGhpcy5zdGF0ZS5wb3M7XG4gICAgbGV0IGNodW5rU3RhcnQgPSB0aGlzLnN0YXRlLnBvcztcbiAgICBpZiAoZmlyc3RDb2RlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHRoaXMuc3RhdGUucG9zICs9IGZpcnN0Q29kZSA8PSAweGZmZmYgPyAxIDogMjtcbiAgICB9XG4gICAgd2hpbGUgKHRoaXMuc3RhdGUucG9zIDwgdGhpcy5sZW5ndGgpIHtcbiAgICAgIGNvbnN0IGNoID0gdGhpcy5jb2RlUG9pbnRBdFBvcyh0aGlzLnN0YXRlLnBvcyk7XG4gICAgICBpZiAoaXNJZGVudGlmaWVyQ2hhcihjaCkpIHtcbiAgICAgICAgdGhpcy5zdGF0ZS5wb3MgKz0gY2ggPD0gMHhmZmZmID8gMSA6IDI7XG4gICAgICB9IGVsc2UgaWYgKGNoID09PSA5Mikge1xuICAgICAgICB0aGlzLnN0YXRlLmNvbnRhaW5zRXNjID0gdHJ1ZTtcbiAgICAgICAgd29yZCArPSB0aGlzLmlucHV0LnNsaWNlKGNodW5rU3RhcnQsIHRoaXMuc3RhdGUucG9zKTtcbiAgICAgICAgY29uc3QgZXNjU3RhcnQgPSB0aGlzLnN0YXRlLmN1clBvc2l0aW9uKCk7XG4gICAgICAgIGNvbnN0IGlkZW50aWZpZXJDaGVjayA9IHRoaXMuc3RhdGUucG9zID09PSBzdGFydCA/IGlzSWRlbnRpZmllclN0YXJ0IDogaXNJZGVudGlmaWVyQ2hhcjtcbiAgICAgICAgaWYgKHRoaXMuaW5wdXQuY2hhckNvZGVBdCgrK3RoaXMuc3RhdGUucG9zKSAhPT0gMTE3KSB7XG4gICAgICAgICAgdGhpcy5yYWlzZShFcnJvcnMuTWlzc2luZ1VuaWNvZGVFc2NhcGUsIHRoaXMuc3RhdGUuY3VyUG9zaXRpb24oKSk7XG4gICAgICAgICAgY2h1bmtTdGFydCA9IHRoaXMuc3RhdGUucG9zIC0gMTtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICArK3RoaXMuc3RhdGUucG9zO1xuICAgICAgICBjb25zdCBlc2MgPSB0aGlzLnJlYWRDb2RlUG9pbnQodHJ1ZSk7XG4gICAgICAgIGlmIChlc2MgIT09IG51bGwpIHtcbiAgICAgICAgICBpZiAoIWlkZW50aWZpZXJDaGVjayhlc2MpKSB7XG4gICAgICAgICAgICB0aGlzLnJhaXNlKEVycm9ycy5Fc2NhcGVkQ2hhck5vdEFuSWRlbnRpZmllciwgZXNjU3RhcnQpO1xuICAgICAgICAgIH1cbiAgICAgICAgICB3b3JkICs9IFN0cmluZy5mcm9tQ29kZVBvaW50KGVzYyk7XG4gICAgICAgIH1cbiAgICAgICAgY2h1bmtTdGFydCA9IHRoaXMuc3RhdGUucG9zO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB3b3JkICsgdGhpcy5pbnB1dC5zbGljZShjaHVua1N0YXJ0LCB0aGlzLnN0YXRlLnBvcyk7XG4gIH1cbiAgcmVhZFdvcmQoZmlyc3RDb2RlKSB7XG4gICAgY29uc3Qgd29yZCA9IHRoaXMucmVhZFdvcmQxKGZpcnN0Q29kZSk7XG4gICAgY29uc3QgdHlwZSA9IGtleXdvcmRzJDEuZ2V0KHdvcmQpO1xuICAgIGlmICh0eXBlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHRoaXMuZmluaXNoVG9rZW4odHlwZSwgdG9rZW5MYWJlbE5hbWUodHlwZSkpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmZpbmlzaFRva2VuKDEzMiwgd29yZCk7XG4gICAgfVxuICB9XG4gIGNoZWNrS2V5d29yZEVzY2FwZXMoKSB7XG4gICAgY29uc3Qge1xuICAgICAgdHlwZVxuICAgIH0gPSB0aGlzLnN0YXRlO1xuICAgIGlmICh0b2tlbklzS2V5d29yZCh0eXBlKSAmJiB0aGlzLnN0YXRlLmNvbnRhaW5zRXNjKSB7XG4gICAgICB0aGlzLnJhaXNlKEVycm9ycy5JbnZhbGlkRXNjYXBlZFJlc2VydmVkV29yZCwgdGhpcy5zdGF0ZS5zdGFydExvYywge1xuICAgICAgICByZXNlcnZlZFdvcmQ6IHRva2VuTGFiZWxOYW1lKHR5cGUpXG4gICAgICB9KTtcbiAgICB9XG4gIH1cbiAgcmFpc2UodG9QYXJzZUVycm9yLCBhdCwgZGV0YWlscyA9IHt9KSB7XG4gICAgY29uc3QgbG9jID0gYXQgaW5zdGFuY2VvZiBQb3NpdGlvbiA/IGF0IDogYXQubG9jLnN0YXJ0O1xuICAgIGNvbnN0IGVycm9yID0gdG9QYXJzZUVycm9yKGxvYywgZGV0YWlscyk7XG4gICAgaWYgKCEodGhpcy5vcHRpb25GbGFncyAmIDIwNDgpKSB0aHJvdyBlcnJvcjtcbiAgICBpZiAoIXRoaXMuaXNMb29rYWhlYWQpIHRoaXMuc3RhdGUuZXJyb3JzLnB1c2goZXJyb3IpO1xuICAgIHJldHVybiBlcnJvcjtcbiAgfVxuICByYWlzZU92ZXJ3cml0ZSh0b1BhcnNlRXJyb3IsIGF0LCBkZXRhaWxzID0ge30pIHtcbiAgICBjb25zdCBsb2MgPSBhdCBpbnN0YW5jZW9mIFBvc2l0aW9uID8gYXQgOiBhdC5sb2Muc3RhcnQ7XG4gICAgY29uc3QgcG9zID0gbG9jLmluZGV4O1xuICAgIGNvbnN0IGVycm9ycyA9IHRoaXMuc3RhdGUuZXJyb3JzO1xuICAgIGZvciAobGV0IGkgPSBlcnJvcnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgIGNvbnN0IGVycm9yID0gZXJyb3JzW2ldO1xuICAgICAgaWYgKGVycm9yLmxvYy5pbmRleCA9PT0gcG9zKSB7XG4gICAgICAgIHJldHVybiBlcnJvcnNbaV0gPSB0b1BhcnNlRXJyb3IobG9jLCBkZXRhaWxzKTtcbiAgICAgIH1cbiAgICAgIGlmIChlcnJvci5sb2MuaW5kZXggPCBwb3MpIGJyZWFrO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5yYWlzZSh0b1BhcnNlRXJyb3IsIGF0LCBkZXRhaWxzKTtcbiAgfVxuICB1cGRhdGVDb250ZXh0KHByZXZUeXBlKSB7fVxuICB1bmV4cGVjdGVkKGxvYywgdHlwZSkge1xuICAgIHRocm93IHRoaXMucmFpc2UoRXJyb3JzLlVuZXhwZWN0ZWRUb2tlbiwgbG9jICE9IG51bGwgPyBsb2MgOiB0aGlzLnN0YXRlLnN0YXJ0TG9jLCB7XG4gICAgICBleHBlY3RlZDogdHlwZSA/IHRva2VuTGFiZWxOYW1lKHR5cGUpIDogbnVsbFxuICAgIH0pO1xuICB9XG4gIGV4cGVjdFBsdWdpbihwbHVnaW5OYW1lLCBsb2MpIHtcbiAgICBpZiAodGhpcy5oYXNQbHVnaW4ocGx1Z2luTmFtZSkpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICB0aHJvdyB0aGlzLnJhaXNlKEVycm9ycy5NaXNzaW5nUGx1Z2luLCBsb2MgIT0gbnVsbCA/IGxvYyA6IHRoaXMuc3RhdGUuc3RhcnRMb2MsIHtcbiAgICAgIG1pc3NpbmdQbHVnaW46IFtwbHVnaW5OYW1lXVxuICAgIH0pO1xuICB9XG4gIGV4cGVjdE9uZVBsdWdpbihwbHVnaW5OYW1lcykge1xuICAgIGlmICghcGx1Z2luTmFtZXMuc29tZShuYW1lID0+IHRoaXMuaGFzUGx1Z2luKG5hbWUpKSkge1xuICAgICAgdGhyb3cgdGhpcy5yYWlzZShFcnJvcnMuTWlzc2luZ09uZU9mUGx1Z2lucywgdGhpcy5zdGF0ZS5zdGFydExvYywge1xuICAgICAgICBtaXNzaW5nUGx1Z2luOiBwbHVnaW5OYW1lc1xuICAgICAgfSk7XG4gICAgfVxuICB9XG4gIGVycm9yQnVpbGRlcihlcnJvcikge1xuICAgIHJldHVybiAocG9zLCBsaW5lU3RhcnQsIGN1ckxpbmUpID0+IHtcbiAgICAgIHRoaXMucmFpc2UoZXJyb3IsIGJ1aWxkUG9zaXRpb24ocG9zLCBsaW5lU3RhcnQsIGN1ckxpbmUpKTtcbiAgICB9O1xuICB9XG59XG5jbGFzcyBDbGFzc1Njb3BlIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgdGhpcy5wcml2YXRlTmFtZXMgPSBuZXcgU2V0KCk7XG4gICAgdGhpcy5sb25lQWNjZXNzb3JzID0gbmV3IE1hcCgpO1xuICAgIHRoaXMudW5kZWZpbmVkUHJpdmF0ZU5hbWVzID0gbmV3IE1hcCgpO1xuICB9XG59XG5jbGFzcyBDbGFzc1Njb3BlSGFuZGxlciB7XG4gIGNvbnN0cnVjdG9yKHBhcnNlcikge1xuICAgIHRoaXMucGFyc2VyID0gdm9pZCAwO1xuICAgIHRoaXMuc3RhY2sgPSBbXTtcbiAgICB0aGlzLnVuZGVmaW5lZFByaXZhdGVOYW1lcyA9IG5ldyBNYXAoKTtcbiAgICB0aGlzLnBhcnNlciA9IHBhcnNlcjtcbiAgfVxuICBjdXJyZW50KCkge1xuICAgIHJldHVybiB0aGlzLnN0YWNrW3RoaXMuc3RhY2subGVuZ3RoIC0gMV07XG4gIH1cbiAgZW50ZXIoKSB7XG4gICAgdGhpcy5zdGFjay5wdXNoKG5ldyBDbGFzc1Njb3BlKCkpO1xuICB9XG4gIGV4aXQoKSB7XG4gICAgY29uc3Qgb2xkQ2xhc3NTY29wZSA9IHRoaXMuc3RhY2sucG9wKCk7XG4gICAgY29uc3QgY3VycmVudCA9IHRoaXMuY3VycmVudCgpO1xuICAgIGZvciAoY29uc3QgW25hbWUsIGxvY10gb2YgQXJyYXkuZnJvbShvbGRDbGFzc1Njb3BlLnVuZGVmaW5lZFByaXZhdGVOYW1lcykpIHtcbiAgICAgIGlmIChjdXJyZW50KSB7XG4gICAgICAgIGlmICghY3VycmVudC51bmRlZmluZWRQcml2YXRlTmFtZXMuaGFzKG5hbWUpKSB7XG4gICAgICAgICAgY3VycmVudC51bmRlZmluZWRQcml2YXRlTmFtZXMuc2V0KG5hbWUsIGxvYyk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMucGFyc2VyLnJhaXNlKEVycm9ycy5JbnZhbGlkUHJpdmF0ZUZpZWxkUmVzb2x1dGlvbiwgbG9jLCB7XG4gICAgICAgICAgaWRlbnRpZmllck5hbWU6IG5hbWVcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGRlY2xhcmVQcml2YXRlTmFtZShuYW1lLCBlbGVtZW50VHlwZSwgbG9jKSB7XG4gICAgY29uc3Qge1xuICAgICAgcHJpdmF0ZU5hbWVzLFxuICAgICAgbG9uZUFjY2Vzc29ycyxcbiAgICAgIHVuZGVmaW5lZFByaXZhdGVOYW1lc1xuICAgIH0gPSB0aGlzLmN1cnJlbnQoKTtcbiAgICBsZXQgcmVkZWZpbmVkID0gcHJpdmF0ZU5hbWVzLmhhcyhuYW1lKTtcbiAgICBpZiAoZWxlbWVudFR5cGUgJiAzKSB7XG4gICAgICBjb25zdCBhY2Nlc3NvciA9IHJlZGVmaW5lZCAmJiBsb25lQWNjZXNzb3JzLmdldChuYW1lKTtcbiAgICAgIGlmIChhY2Nlc3Nvcikge1xuICAgICAgICBjb25zdCBvbGRTdGF0aWMgPSBhY2Nlc3NvciAmIDQ7XG4gICAgICAgIGNvbnN0IG5ld1N0YXRpYyA9IGVsZW1lbnRUeXBlICYgNDtcbiAgICAgICAgY29uc3Qgb2xkS2luZCA9IGFjY2Vzc29yICYgMztcbiAgICAgICAgY29uc3QgbmV3S2luZCA9IGVsZW1lbnRUeXBlICYgMztcbiAgICAgICAgcmVkZWZpbmVkID0gb2xkS2luZCA9PT0gbmV3S2luZCB8fCBvbGRTdGF0aWMgIT09IG5ld1N0YXRpYztcbiAgICAgICAgaWYgKCFyZWRlZmluZWQpIGxvbmVBY2Nlc3NvcnMuZGVsZXRlKG5hbWUpO1xuICAgICAgfSBlbHNlIGlmICghcmVkZWZpbmVkKSB7XG4gICAgICAgIGxvbmVBY2Nlc3NvcnMuc2V0KG5hbWUsIGVsZW1lbnRUeXBlKTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHJlZGVmaW5lZCkge1xuICAgICAgdGhpcy5wYXJzZXIucmFpc2UoRXJyb3JzLlByaXZhdGVOYW1lUmVkZWNsYXJhdGlvbiwgbG9jLCB7XG4gICAgICAgIGlkZW50aWZpZXJOYW1lOiBuYW1lXG4gICAgICB9KTtcbiAgICB9XG4gICAgcHJpdmF0ZU5hbWVzLmFkZChuYW1lKTtcbiAgICB1bmRlZmluZWRQcml2YXRlTmFtZXMuZGVsZXRlKG5hbWUpO1xuICB9XG4gIHVzZVByaXZhdGVOYW1lKG5hbWUsIGxvYykge1xuICAgIGxldCBjbGFzc1Njb3BlO1xuICAgIGZvciAoY2xhc3NTY29wZSBvZiB0aGlzLnN0YWNrKSB7XG4gICAgICBpZiAoY2xhc3NTY29wZS5wcml2YXRlTmFtZXMuaGFzKG5hbWUpKSByZXR1cm47XG4gICAgfVxuICAgIGlmIChjbGFzc1Njb3BlKSB7XG4gICAgICBjbGFzc1Njb3BlLnVuZGVmaW5lZFByaXZhdGVOYW1lcy5zZXQobmFtZSwgbG9jKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5wYXJzZXIucmFpc2UoRXJyb3JzLkludmFsaWRQcml2YXRlRmllbGRSZXNvbHV0aW9uLCBsb2MsIHtcbiAgICAgICAgaWRlbnRpZmllck5hbWU6IG5hbWVcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxufVxuY2xhc3MgRXhwcmVzc2lvblNjb3BlIHtcbiAgY29uc3RydWN0b3IodHlwZSA9IDApIHtcbiAgICB0aGlzLnR5cGUgPSB0eXBlO1xuICB9XG4gIGNhbkJlQXJyb3dQYXJhbWV0ZXJEZWNsYXJhdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy50eXBlID09PSAyIHx8IHRoaXMudHlwZSA9PT0gMTtcbiAgfVxuICBpc0NlcnRhaW5seVBhcmFtZXRlckRlY2xhcmF0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLnR5cGUgPT09IDM7XG4gIH1cbn1cbmNsYXNzIEFycm93SGVhZFBhcnNpbmdTY29wZSBleHRlbmRzIEV4cHJlc3Npb25TY29wZSB7XG4gIGNvbnN0cnVjdG9yKHR5cGUpIHtcbiAgICBzdXBlcih0eXBlKTtcbiAgICB0aGlzLmRlY2xhcmF0aW9uRXJyb3JzID0gbmV3IE1hcCgpO1xuICB9XG4gIHJlY29yZERlY2xhcmF0aW9uRXJyb3IoUGFyc2luZ0Vycm9yQ2xhc3MsIGF0KSB7XG4gICAgY29uc3QgaW5kZXggPSBhdC5pbmRleDtcbiAgICB0aGlzLmRlY2xhcmF0aW9uRXJyb3JzLnNldChpbmRleCwgW1BhcnNpbmdFcnJvckNsYXNzLCBhdF0pO1xuICB9XG4gIGNsZWFyRGVjbGFyYXRpb25FcnJvcihpbmRleCkge1xuICAgIHRoaXMuZGVjbGFyYXRpb25FcnJvcnMuZGVsZXRlKGluZGV4KTtcbiAgfVxuICBpdGVyYXRlRXJyb3JzKGl0ZXJhdG9yKSB7XG4gICAgdGhpcy5kZWNsYXJhdGlvbkVycm9ycy5mb3JFYWNoKGl0ZXJhdG9yKTtcbiAgfVxufVxuY2xhc3MgRXhwcmVzc2lvblNjb3BlSGFuZGxlciB7XG4gIGNvbnN0cnVjdG9yKHBhcnNlcikge1xuICAgIHRoaXMucGFyc2VyID0gdm9pZCAwO1xuICAgIHRoaXMuc3RhY2sgPSBbbmV3IEV4cHJlc3Npb25TY29wZSgpXTtcbiAgICB0aGlzLnBhcnNlciA9IHBhcnNlcjtcbiAgfVxuICBlbnRlcihzY29wZSkge1xuICAgIHRoaXMuc3RhY2sucHVzaChzY29wZSk7XG4gIH1cbiAgZXhpdCgpIHtcbiAgICB0aGlzLnN0YWNrLnBvcCgpO1xuICB9XG4gIHJlY29yZFBhcmFtZXRlckluaXRpYWxpemVyRXJyb3IodG9QYXJzZUVycm9yLCBub2RlKSB7XG4gICAgY29uc3Qgb3JpZ2luID0gbm9kZS5sb2Muc3RhcnQ7XG4gICAgY29uc3Qge1xuICAgICAgc3RhY2tcbiAgICB9ID0gdGhpcztcbiAgICBsZXQgaSA9IHN0YWNrLmxlbmd0aCAtIDE7XG4gICAgbGV0IHNjb3BlID0gc3RhY2tbaV07XG4gICAgd2hpbGUgKCFzY29wZS5pc0NlcnRhaW5seVBhcmFtZXRlckRlY2xhcmF0aW9uKCkpIHtcbiAgICAgIGlmIChzY29wZS5jYW5CZUFycm93UGFyYW1ldGVyRGVjbGFyYXRpb24oKSkge1xuICAgICAgICBzY29wZS5yZWNvcmREZWNsYXJhdGlvbkVycm9yKHRvUGFyc2VFcnJvciwgb3JpZ2luKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHNjb3BlID0gc3RhY2tbLS1pXTtcbiAgICB9XG4gICAgdGhpcy5wYXJzZXIucmFpc2UodG9QYXJzZUVycm9yLCBvcmlnaW4pO1xuICB9XG4gIHJlY29yZEFycm93UGFyYW1ldGVyQmluZGluZ0Vycm9yKGVycm9yLCBub2RlKSB7XG4gICAgY29uc3Qge1xuICAgICAgc3RhY2tcbiAgICB9ID0gdGhpcztcbiAgICBjb25zdCBzY29wZSA9IHN0YWNrW3N0YWNrLmxlbmd0aCAtIDFdO1xuICAgIGNvbnN0IG9yaWdpbiA9IG5vZGUubG9jLnN0YXJ0O1xuICAgIGlmIChzY29wZS5pc0NlcnRhaW5seVBhcmFtZXRlckRlY2xhcmF0aW9uKCkpIHtcbiAgICAgIHRoaXMucGFyc2VyLnJhaXNlKGVycm9yLCBvcmlnaW4pO1xuICAgIH0gZWxzZSBpZiAoc2NvcGUuY2FuQmVBcnJvd1BhcmFtZXRlckRlY2xhcmF0aW9uKCkpIHtcbiAgICAgIHNjb3BlLnJlY29yZERlY2xhcmF0aW9uRXJyb3IoZXJyb3IsIG9yaWdpbik7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gIH1cbiAgcmVjb3JkQXN5bmNBcnJvd1BhcmFtZXRlcnNFcnJvcihhdCkge1xuICAgIGNvbnN0IHtcbiAgICAgIHN0YWNrXG4gICAgfSA9IHRoaXM7XG4gICAgbGV0IGkgPSBzdGFjay5sZW5ndGggLSAxO1xuICAgIGxldCBzY29wZSA9IHN0YWNrW2ldO1xuICAgIHdoaWxlIChzY29wZS5jYW5CZUFycm93UGFyYW1ldGVyRGVjbGFyYXRpb24oKSkge1xuICAgICAgaWYgKHNjb3BlLnR5cGUgPT09IDIpIHtcbiAgICAgICAgc2NvcGUucmVjb3JkRGVjbGFyYXRpb25FcnJvcihFcnJvcnMuQXdhaXRCaW5kaW5nSWRlbnRpZmllciwgYXQpO1xuICAgICAgfVxuICAgICAgc2NvcGUgPSBzdGFja1stLWldO1xuICAgIH1cbiAgfVxuICB2YWxpZGF0ZUFzUGF0dGVybigpIHtcbiAgICBjb25zdCB7XG4gICAgICBzdGFja1xuICAgIH0gPSB0aGlzO1xuICAgIGNvbnN0IGN1cnJlbnRTY29wZSA9IHN0YWNrW3N0YWNrLmxlbmd0aCAtIDFdO1xuICAgIGlmICghY3VycmVudFNjb3BlLmNhbkJlQXJyb3dQYXJhbWV0ZXJEZWNsYXJhdGlvbigpKSByZXR1cm47XG4gICAgY3VycmVudFNjb3BlLml0ZXJhdGVFcnJvcnMoKFt0b1BhcnNlRXJyb3IsIGxvY10pID0+IHtcbiAgICAgIHRoaXMucGFyc2VyLnJhaXNlKHRvUGFyc2VFcnJvciwgbG9jKTtcbiAgICAgIGxldCBpID0gc3RhY2subGVuZ3RoIC0gMjtcbiAgICAgIGxldCBzY29wZSA9IHN0YWNrW2ldO1xuICAgICAgd2hpbGUgKHNjb3BlLmNhbkJlQXJyb3dQYXJhbWV0ZXJEZWNsYXJhdGlvbigpKSB7XG4gICAgICAgIHNjb3BlLmNsZWFyRGVjbGFyYXRpb25FcnJvcihsb2MuaW5kZXgpO1xuICAgICAgICBzY29wZSA9IHN0YWNrWy0taV07XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbn1cbmZ1bmN0aW9uIG5ld1BhcmFtZXRlckRlY2xhcmF0aW9uU2NvcGUoKSB7XG4gIHJldHVybiBuZXcgRXhwcmVzc2lvblNjb3BlKDMpO1xufVxuZnVuY3Rpb24gbmV3QXJyb3dIZWFkU2NvcGUoKSB7XG4gIHJldHVybiBuZXcgQXJyb3dIZWFkUGFyc2luZ1Njb3BlKDEpO1xufVxuZnVuY3Rpb24gbmV3QXN5bmNBcnJvd1Njb3BlKCkge1xuICByZXR1cm4gbmV3IEFycm93SGVhZFBhcnNpbmdTY29wZSgyKTtcbn1cbmZ1bmN0aW9uIG5ld0V4cHJlc3Npb25TY29wZSgpIHtcbiAgcmV0dXJuIG5ldyBFeHByZXNzaW9uU2NvcGUoKTtcbn1cbmNsYXNzIFV0aWxQYXJzZXIgZXh0ZW5kcyBUb2tlbml6ZXIge1xuICBhZGRFeHRyYShub2RlLCBrZXksIHZhbHVlLCBlbnVtZXJhYmxlID0gdHJ1ZSkge1xuICAgIGlmICghbm9kZSkgcmV0dXJuO1xuICAgIGxldCB7XG4gICAgICBleHRyYVxuICAgIH0gPSBub2RlO1xuICAgIGlmIChleHRyYSA9PSBudWxsKSB7XG4gICAgICBleHRyYSA9IHt9O1xuICAgICAgbm9kZS5leHRyYSA9IGV4dHJhO1xuICAgIH1cbiAgICBpZiAoZW51bWVyYWJsZSkge1xuICAgICAgZXh0cmFba2V5XSA9IHZhbHVlO1xuICAgIH0gZWxzZSB7XG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXh0cmEsIGtleSwge1xuICAgICAgICBlbnVtZXJhYmxlLFxuICAgICAgICB2YWx1ZVxuICAgICAgfSk7XG4gICAgfVxuICB9XG4gIGlzQ29udGV4dHVhbCh0b2tlbikge1xuICAgIHJldHVybiB0aGlzLnN0YXRlLnR5cGUgPT09IHRva2VuICYmICF0aGlzLnN0YXRlLmNvbnRhaW5zRXNjO1xuICB9XG4gIGlzVW5wYXJzZWRDb250ZXh0dWFsKG5hbWVTdGFydCwgbmFtZSkge1xuICAgIGlmICh0aGlzLmlucHV0LnN0YXJ0c1dpdGgobmFtZSwgbmFtZVN0YXJ0KSkge1xuICAgICAgY29uc3QgbmV4dENoID0gdGhpcy5pbnB1dC5jaGFyQ29kZUF0KG5hbWVTdGFydCArIG5hbWUubGVuZ3RoKTtcbiAgICAgIHJldHVybiAhKGlzSWRlbnRpZmllckNoYXIobmV4dENoKSB8fCAobmV4dENoICYgMHhmYzAwKSA9PT0gMHhkODAwKTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGlzTG9va2FoZWFkQ29udGV4dHVhbChuYW1lKSB7XG4gICAgY29uc3QgbmV4dCA9IHRoaXMubmV4dFRva2VuU3RhcnQoKTtcbiAgICByZXR1cm4gdGhpcy5pc1VucGFyc2VkQ29udGV4dHVhbChuZXh0LCBuYW1lKTtcbiAgfVxuICBlYXRDb250ZXh0dWFsKHRva2VuKSB7XG4gICAgaWYgKHRoaXMuaXNDb250ZXh0dWFsKHRva2VuKSkge1xuICAgICAgdGhpcy5uZXh0KCk7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGV4cGVjdENvbnRleHR1YWwodG9rZW4sIHRvUGFyc2VFcnJvcikge1xuICAgIGlmICghdGhpcy5lYXRDb250ZXh0dWFsKHRva2VuKSkge1xuICAgICAgaWYgKHRvUGFyc2VFcnJvciAhPSBudWxsKSB7XG4gICAgICAgIHRocm93IHRoaXMucmFpc2UodG9QYXJzZUVycm9yLCB0aGlzLnN0YXRlLnN0YXJ0TG9jKTtcbiAgICAgIH1cbiAgICAgIHRoaXMudW5leHBlY3RlZChudWxsLCB0b2tlbik7XG4gICAgfVxuICB9XG4gIGNhbkluc2VydFNlbWljb2xvbigpIHtcbiAgICByZXR1cm4gdGhpcy5tYXRjaCgxNDApIHx8IHRoaXMubWF0Y2goOCkgfHwgdGhpcy5oYXNQcmVjZWRpbmdMaW5lQnJlYWsoKTtcbiAgfVxuICBoYXNQcmVjZWRpbmdMaW5lQnJlYWsoKSB7XG4gICAgcmV0dXJuIGhhc05ld0xpbmUodGhpcy5pbnB1dCwgdGhpcy5vZmZzZXRUb1NvdXJjZVBvcyh0aGlzLnN0YXRlLmxhc3RUb2tFbmRMb2MuaW5kZXgpLCB0aGlzLnN0YXRlLnN0YXJ0KTtcbiAgfVxuICBoYXNGb2xsb3dpbmdMaW5lQnJlYWsoKSB7XG4gICAgcmV0dXJuIGhhc05ld0xpbmUodGhpcy5pbnB1dCwgdGhpcy5zdGF0ZS5lbmQsIHRoaXMubmV4dFRva2VuU3RhcnQoKSk7XG4gIH1cbiAgaXNMaW5lVGVybWluYXRvcigpIHtcbiAgICByZXR1cm4gdGhpcy5lYXQoMTMpIHx8IHRoaXMuY2FuSW5zZXJ0U2VtaWNvbG9uKCk7XG4gIH1cbiAgc2VtaWNvbG9uKGFsbG93QXNpID0gdHJ1ZSkge1xuICAgIGlmIChhbGxvd0FzaSA/IHRoaXMuaXNMaW5lVGVybWluYXRvcigpIDogdGhpcy5lYXQoMTMpKSByZXR1cm47XG4gICAgdGhpcy5yYWlzZShFcnJvcnMuTWlzc2luZ1NlbWljb2xvbiwgdGhpcy5zdGF0ZS5sYXN0VG9rRW5kTG9jKTtcbiAgfVxuICBleHBlY3QodHlwZSwgbG9jKSB7XG4gICAgaWYgKCF0aGlzLmVhdCh0eXBlKSkge1xuICAgICAgdGhpcy51bmV4cGVjdGVkKGxvYywgdHlwZSk7XG4gICAgfVxuICB9XG4gIHRyeVBhcnNlKGZuLCBvbGRTdGF0ZSA9IHRoaXMuc3RhdGUuY2xvbmUoKSkge1xuICAgIGNvbnN0IGFib3J0U2lnbmFsID0ge1xuICAgICAgbm9kZTogbnVsbFxuICAgIH07XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IG5vZGUgPSBmbigobm9kZSA9IG51bGwpID0+IHtcbiAgICAgICAgYWJvcnRTaWduYWwubm9kZSA9IG5vZGU7XG4gICAgICAgIHRocm93IGFib3J0U2lnbmFsO1xuICAgICAgfSk7XG4gICAgICBpZiAodGhpcy5zdGF0ZS5lcnJvcnMubGVuZ3RoID4gb2xkU3RhdGUuZXJyb3JzLmxlbmd0aCkge1xuICAgICAgICBjb25zdCBmYWlsU3RhdGUgPSB0aGlzLnN0YXRlO1xuICAgICAgICB0aGlzLnN0YXRlID0gb2xkU3RhdGU7XG4gICAgICAgIHRoaXMuc3RhdGUudG9rZW5zTGVuZ3RoID0gZmFpbFN0YXRlLnRva2Vuc0xlbmd0aDtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBub2RlLFxuICAgICAgICAgIGVycm9yOiBmYWlsU3RhdGUuZXJyb3JzW29sZFN0YXRlLmVycm9ycy5sZW5ndGhdLFxuICAgICAgICAgIHRocm93bjogZmFsc2UsXG4gICAgICAgICAgYWJvcnRlZDogZmFsc2UsXG4gICAgICAgICAgZmFpbFN0YXRlXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgICByZXR1cm4ge1xuICAgICAgICBub2RlOiBub2RlLFxuICAgICAgICBlcnJvcjogbnVsbCxcbiAgICAgICAgdGhyb3duOiBmYWxzZSxcbiAgICAgICAgYWJvcnRlZDogZmFsc2UsXG4gICAgICAgIGZhaWxTdGF0ZTogbnVsbFxuICAgICAgfTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc3QgZmFpbFN0YXRlID0gdGhpcy5zdGF0ZTtcbiAgICAgIHRoaXMuc3RhdGUgPSBvbGRTdGF0ZTtcbiAgICAgIGlmIChlcnJvciBpbnN0YW5jZW9mIFN5bnRheEVycm9yKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgbm9kZTogbnVsbCxcbiAgICAgICAgICBlcnJvcixcbiAgICAgICAgICB0aHJvd246IHRydWUsXG4gICAgICAgICAgYWJvcnRlZDogZmFsc2UsXG4gICAgICAgICAgZmFpbFN0YXRlXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgICBpZiAoZXJyb3IgPT09IGFib3J0U2lnbmFsKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgbm9kZTogYWJvcnRTaWduYWwubm9kZSxcbiAgICAgICAgICBlcnJvcjogbnVsbCxcbiAgICAgICAgICB0aHJvd246IGZhbHNlLFxuICAgICAgICAgIGFib3J0ZWQ6IHRydWUsXG4gICAgICAgICAgZmFpbFN0YXRlXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgICB0aHJvdyBlcnJvcjtcbiAgICB9XG4gIH1cbiAgY2hlY2tFeHByZXNzaW9uRXJyb3JzKHJlZkV4cHJlc3Npb25FcnJvcnMsIGFuZFRocm93KSB7XG4gICAgaWYgKCFyZWZFeHByZXNzaW9uRXJyb3JzKSByZXR1cm4gZmFsc2U7XG4gICAgY29uc3Qge1xuICAgICAgc2hvcnRoYW5kQXNzaWduTG9jLFxuICAgICAgZG91YmxlUHJvdG9Mb2MsXG4gICAgICBwcml2YXRlS2V5TG9jLFxuICAgICAgb3B0aW9uYWxQYXJhbWV0ZXJzTG9jLFxuICAgICAgdm9pZFBhdHRlcm5Mb2NcbiAgICB9ID0gcmVmRXhwcmVzc2lvbkVycm9ycztcbiAgICBjb25zdCBoYXNFcnJvcnMgPSAhIXNob3J0aGFuZEFzc2lnbkxvYyB8fCAhIWRvdWJsZVByb3RvTG9jIHx8ICEhb3B0aW9uYWxQYXJhbWV0ZXJzTG9jIHx8ICEhcHJpdmF0ZUtleUxvYyB8fCAhIXZvaWRQYXR0ZXJuTG9jO1xuICAgIGlmICghYW5kVGhyb3cpIHtcbiAgICAgIHJldHVybiBoYXNFcnJvcnM7XG4gICAgfVxuICAgIGlmIChzaG9ydGhhbmRBc3NpZ25Mb2MgIT0gbnVsbCkge1xuICAgICAgdGhpcy5yYWlzZShFcnJvcnMuSW52YWxpZENvdmVySW5pdGlhbGl6ZWROYW1lLCBzaG9ydGhhbmRBc3NpZ25Mb2MpO1xuICAgIH1cbiAgICBpZiAoZG91YmxlUHJvdG9Mb2MgIT0gbnVsbCkge1xuICAgICAgdGhpcy5yYWlzZShFcnJvcnMuRHVwbGljYXRlUHJvdG8sIGRvdWJsZVByb3RvTG9jKTtcbiAgICB9XG4gICAgaWYgKHByaXZhdGVLZXlMb2MgIT0gbnVsbCkge1xuICAgICAgdGhpcy5yYWlzZShFcnJvcnMuVW5leHBlY3RlZFByaXZhdGVGaWVsZCwgcHJpdmF0ZUtleUxvYyk7XG4gICAgfVxuICAgIGlmIChvcHRpb25hbFBhcmFtZXRlcnNMb2MgIT0gbnVsbCkge1xuICAgICAgdGhpcy51bmV4cGVjdGVkKG9wdGlvbmFsUGFyYW1ldGVyc0xvYyk7XG4gICAgfVxuICAgIGlmICh2b2lkUGF0dGVybkxvYyAhPSBudWxsKSB7XG4gICAgICB0aGlzLnJhaXNlKEVycm9ycy5JbnZhbGlkQ292ZXJEaXNjYXJkRWxlbWVudCwgdm9pZFBhdHRlcm5Mb2MpO1xuICAgIH1cbiAgfVxuICBpc0xpdGVyYWxQcm9wZXJ0eU5hbWUoKSB7XG4gICAgcmV0dXJuIHRva2VuSXNMaXRlcmFsUHJvcGVydHlOYW1lKHRoaXMuc3RhdGUudHlwZSk7XG4gIH1cbiAgaXNQcml2YXRlTmFtZShub2RlKSB7XG4gICAgcmV0dXJuIG5vZGUudHlwZSA9PT0gXCJQcml2YXRlTmFtZVwiO1xuICB9XG4gIGdldFByaXZhdGVOYW1lU1Yobm9kZSkge1xuICAgIHJldHVybiBub2RlLmlkLm5hbWU7XG4gIH1cbiAgaGFzUHJvcGVydHlBc1ByaXZhdGVOYW1lKG5vZGUpIHtcbiAgICByZXR1cm4gKG5vZGUudHlwZSA9PT0gXCJNZW1iZXJFeHByZXNzaW9uXCIgfHwgbm9kZS50eXBlID09PSBcIk9wdGlvbmFsTWVtYmVyRXhwcmVzc2lvblwiKSAmJiB0aGlzLmlzUHJpdmF0ZU5hbWUobm9kZS5wcm9wZXJ0eSk7XG4gIH1cbiAgaXNPYmplY3RQcm9wZXJ0eShub2RlKSB7XG4gICAgcmV0dXJuIG5vZGUudHlwZSA9PT0gXCJPYmplY3RQcm9wZXJ0eVwiO1xuICB9XG4gIGlzT2JqZWN0TWV0aG9kKG5vZGUpIHtcbiAgICByZXR1cm4gbm9kZS50eXBlID09PSBcIk9iamVjdE1ldGhvZFwiO1xuICB9XG4gIGluaXRpYWxpemVTY29wZXMoaW5Nb2R1bGUgPSB0aGlzLm9wdGlvbnMuc291cmNlVHlwZSA9PT0gXCJtb2R1bGVcIikge1xuICAgIGNvbnN0IG9sZExhYmVscyA9IHRoaXMuc3RhdGUubGFiZWxzO1xuICAgIHRoaXMuc3RhdGUubGFiZWxzID0gW107XG4gICAgY29uc3Qgb2xkRXhwb3J0ZWRJZGVudGlmaWVycyA9IHRoaXMuZXhwb3J0ZWRJZGVudGlmaWVycztcbiAgICB0aGlzLmV4cG9ydGVkSWRlbnRpZmllcnMgPSBuZXcgU2V0KCk7XG4gICAgY29uc3Qgb2xkSW5Nb2R1bGUgPSB0aGlzLmluTW9kdWxlO1xuICAgIHRoaXMuaW5Nb2R1bGUgPSBpbk1vZHVsZTtcbiAgICBjb25zdCBvbGRTY29wZSA9IHRoaXMuc2NvcGU7XG4gICAgY29uc3QgU2NvcGVIYW5kbGVyID0gdGhpcy5nZXRTY29wZUhhbmRsZXIoKTtcbiAgICB0aGlzLnNjb3BlID0gbmV3IFNjb3BlSGFuZGxlcih0aGlzLCBpbk1vZHVsZSk7XG4gICAgY29uc3Qgb2xkUHJvZFBhcmFtID0gdGhpcy5wcm9kUGFyYW07XG4gICAgdGhpcy5wcm9kUGFyYW0gPSBuZXcgUHJvZHVjdGlvblBhcmFtZXRlckhhbmRsZXIoKTtcbiAgICBjb25zdCBvbGRDbGFzc1Njb3BlID0gdGhpcy5jbGFzc1Njb3BlO1xuICAgIHRoaXMuY2xhc3NTY29wZSA9IG5ldyBDbGFzc1Njb3BlSGFuZGxlcih0aGlzKTtcbiAgICBjb25zdCBvbGRFeHByZXNzaW9uU2NvcGUgPSB0aGlzLmV4cHJlc3Npb25TY29wZTtcbiAgICB0aGlzLmV4cHJlc3Npb25TY29wZSA9IG5ldyBFeHByZXNzaW9uU2NvcGVIYW5kbGVyKHRoaXMpO1xuICAgIHJldHVybiAoKSA9PiB7XG4gICAgICB0aGlzLnN0YXRlLmxhYmVscyA9IG9sZExhYmVscztcbiAgICAgIHRoaXMuZXhwb3J0ZWRJZGVudGlmaWVycyA9IG9sZEV4cG9ydGVkSWRlbnRpZmllcnM7XG4gICAgICB0aGlzLmluTW9kdWxlID0gb2xkSW5Nb2R1bGU7XG4gICAgICB0aGlzLnNjb3BlID0gb2xkU2NvcGU7XG4gICAgICB0aGlzLnByb2RQYXJhbSA9IG9sZFByb2RQYXJhbTtcbiAgICAgIHRoaXMuY2xhc3NTY29wZSA9IG9sZENsYXNzU2NvcGU7XG4gICAgICB0aGlzLmV4cHJlc3Npb25TY29wZSA9IG9sZEV4cHJlc3Npb25TY29wZTtcbiAgICB9O1xuICB9XG4gIGVudGVySW5pdGlhbFNjb3BlcygpIHtcbiAgICBsZXQgcGFyYW1GbGFncyA9IDA7XG4gICAgaWYgKHRoaXMuaW5Nb2R1bGUgfHwgdGhpcy5vcHRpb25GbGFncyAmIDEpIHtcbiAgICAgIHBhcmFtRmxhZ3MgfD0gMjtcbiAgICB9XG4gICAgaWYgKHRoaXMub3B0aW9uRmxhZ3MgJiAzMikge1xuICAgICAgcGFyYW1GbGFncyB8PSAxO1xuICAgIH1cbiAgICBjb25zdCBpc0NvbW1vbkpTID0gIXRoaXMuaW5Nb2R1bGUgJiYgdGhpcy5vcHRpb25zLnNvdXJjZVR5cGUgPT09IFwiY29tbW9uanNcIjtcbiAgICBpZiAoaXNDb21tb25KUyB8fCB0aGlzLm9wdGlvbkZsYWdzICYgMikge1xuICAgICAgcGFyYW1GbGFncyB8PSA0O1xuICAgIH1cbiAgICB0aGlzLnByb2RQYXJhbS5lbnRlcihwYXJhbUZsYWdzKTtcbiAgICBsZXQgc2NvcGVGbGFncyA9IGlzQ29tbW9uSlMgPyA1MTQgOiAxO1xuICAgIGlmICh0aGlzLm9wdGlvbkZsYWdzICYgNCkge1xuICAgICAgc2NvcGVGbGFncyB8PSA1MTI7XG4gICAgfVxuICAgIHRoaXMuc2NvcGUuZW50ZXIoc2NvcGVGbGFncyk7XG4gIH1cbiAgY2hlY2tEZXN0cnVjdHVyaW5nUHJpdmF0ZShyZWZFeHByZXNzaW9uRXJyb3JzKSB7XG4gICAgY29uc3Qge1xuICAgICAgcHJpdmF0ZUtleUxvY1xuICAgIH0gPSByZWZFeHByZXNzaW9uRXJyb3JzO1xuICAgIGlmIChwcml2YXRlS2V5TG9jICE9PSBudWxsKSB7XG4gICAgICB0aGlzLmV4cGVjdFBsdWdpbihcImRlc3RydWN0dXJpbmdQcml2YXRlXCIsIHByaXZhdGVLZXlMb2MpO1xuICAgIH1cbiAgfVxufVxuY2xhc3MgRXhwcmVzc2lvbkVycm9ycyB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHRoaXMuc2hvcnRoYW5kQXNzaWduTG9jID0gbnVsbDtcbiAgICB0aGlzLmRvdWJsZVByb3RvTG9jID0gbnVsbDtcbiAgICB0aGlzLnByaXZhdGVLZXlMb2MgPSBudWxsO1xuICAgIHRoaXMub3B0aW9uYWxQYXJhbWV0ZXJzTG9jID0gbnVsbDtcbiAgICB0aGlzLnZvaWRQYXR0ZXJuTG9jID0gbnVsbDtcbiAgfVxufVxuY2xhc3MgTm9kZSB7XG4gIGNvbnN0cnVjdG9yKHBhcnNlciwgcG9zLCBsb2MpIHtcbiAgICB0aGlzLnR5cGUgPSBcIlwiO1xuICAgIHRoaXMuc3RhcnQgPSBwb3M7XG4gICAgdGhpcy5lbmQgPSAwO1xuICAgIHRoaXMubG9jID0gbmV3IFNvdXJjZUxvY2F0aW9uKGxvYyk7XG4gICAgaWYgKChwYXJzZXIgPT0gbnVsbCA/IHZvaWQgMCA6IHBhcnNlci5vcHRpb25GbGFncykgJiAxMjgpIHRoaXMucmFuZ2UgPSBbcG9zLCAwXTtcbiAgICBpZiAocGFyc2VyICE9IG51bGwgJiYgcGFyc2VyLmZpbGVuYW1lKSB0aGlzLmxvYy5maWxlbmFtZSA9IHBhcnNlci5maWxlbmFtZTtcbiAgfVxufVxuY29uc3QgTm9kZVByb3RvdHlwZSA9IE5vZGUucHJvdG90eXBlO1xuTm9kZVByb3RvdHlwZS5fX2Nsb25lID0gZnVuY3Rpb24gKCkge1xuICBjb25zdCBuZXdOb2RlID0gbmV3IE5vZGUodW5kZWZpbmVkLCB0aGlzLnN0YXJ0LCB0aGlzLmxvYy5zdGFydCk7XG4gIGNvbnN0IGtleXMgPSBPYmplY3Qua2V5cyh0aGlzKTtcbiAgZm9yIChsZXQgaSA9IDAsIGxlbmd0aCA9IGtleXMubGVuZ3RoOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICBjb25zdCBrZXkgPSBrZXlzW2ldO1xuICAgIGlmIChrZXkgIT09IFwibGVhZGluZ0NvbW1lbnRzXCIgJiYga2V5ICE9PSBcInRyYWlsaW5nQ29tbWVudHNcIiAmJiBrZXkgIT09IFwiaW5uZXJDb21tZW50c1wiKSB7XG4gICAgICBuZXdOb2RlW2tleV0gPSB0aGlzW2tleV07XG4gICAgfVxuICB9XG4gIHJldHVybiBuZXdOb2RlO1xufTtcbmNsYXNzIE5vZGVVdGlscyBleHRlbmRzIFV0aWxQYXJzZXIge1xuICBzdGFydE5vZGUoKSB7XG4gICAgY29uc3QgbG9jID0gdGhpcy5zdGF0ZS5zdGFydExvYztcbiAgICByZXR1cm4gbmV3IE5vZGUodGhpcywgbG9jLmluZGV4LCBsb2MpO1xuICB9XG4gIHN0YXJ0Tm9kZUF0KGxvYykge1xuICAgIHJldHVybiBuZXcgTm9kZSh0aGlzLCBsb2MuaW5kZXgsIGxvYyk7XG4gIH1cbiAgc3RhcnROb2RlQXROb2RlKHR5cGUpIHtcbiAgICByZXR1cm4gdGhpcy5zdGFydE5vZGVBdCh0eXBlLmxvYy5zdGFydCk7XG4gIH1cbiAgZmluaXNoTm9kZShub2RlLCB0eXBlKSB7XG4gICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZUF0KG5vZGUsIHR5cGUsIHRoaXMuc3RhdGUubGFzdFRva0VuZExvYyk7XG4gIH1cbiAgZmluaXNoTm9kZUF0KG5vZGUsIHR5cGUsIGVuZExvYykge1xuICAgIG5vZGUudHlwZSA9IHR5cGU7XG4gICAgbm9kZS5lbmQgPSBlbmRMb2MuaW5kZXg7XG4gICAgbm9kZS5sb2MuZW5kID0gZW5kTG9jO1xuICAgIGlmICh0aGlzLm9wdGlvbkZsYWdzICYgMTI4KSBub2RlLnJhbmdlWzFdID0gZW5kTG9jLmluZGV4O1xuICAgIGlmICh0aGlzLm9wdGlvbkZsYWdzICYgNDA5Nikge1xuICAgICAgdGhpcy5wcm9jZXNzQ29tbWVudChub2RlKTtcbiAgICB9XG4gICAgcmV0dXJuIG5vZGU7XG4gIH1cbiAgcmVzZXRTdGFydExvY2F0aW9uKG5vZGUsIHN0YXJ0TG9jKSB7XG4gICAgbm9kZS5zdGFydCA9IHN0YXJ0TG9jLmluZGV4O1xuICAgIG5vZGUubG9jLnN0YXJ0ID0gc3RhcnRMb2M7XG4gICAgaWYgKHRoaXMub3B0aW9uRmxhZ3MgJiAxMjgpIG5vZGUucmFuZ2VbMF0gPSBzdGFydExvYy5pbmRleDtcbiAgfVxuICByZXNldEVuZExvY2F0aW9uKG5vZGUsIGVuZExvYyA9IHRoaXMuc3RhdGUubGFzdFRva0VuZExvYykge1xuICAgIG5vZGUuZW5kID0gZW5kTG9jLmluZGV4O1xuICAgIG5vZGUubG9jLmVuZCA9IGVuZExvYztcbiAgICBpZiAodGhpcy5vcHRpb25GbGFncyAmIDEyOCkgbm9kZS5yYW5nZVsxXSA9IGVuZExvYy5pbmRleDtcbiAgfVxuICByZXNldFN0YXJ0TG9jYXRpb25Gcm9tTm9kZShub2RlLCBsb2NhdGlvbk5vZGUpIHtcbiAgICB0aGlzLnJlc2V0U3RhcnRMb2NhdGlvbihub2RlLCBsb2NhdGlvbk5vZGUubG9jLnN0YXJ0KTtcbiAgfVxuICBjYXN0Tm9kZVRvKG5vZGUsIHR5cGUpIHtcbiAgICBub2RlLnR5cGUgPSB0eXBlO1xuICAgIHJldHVybiBub2RlO1xuICB9XG4gIGNsb25lSWRlbnRpZmllcihub2RlKSB7XG4gICAgY29uc3Qge1xuICAgICAgdHlwZSxcbiAgICAgIHN0YXJ0LFxuICAgICAgZW5kLFxuICAgICAgbG9jLFxuICAgICAgcmFuZ2UsXG4gICAgICBuYW1lXG4gICAgfSA9IG5vZGU7XG4gICAgY29uc3QgY2xvbmVkID0gT2JqZWN0LmNyZWF0ZShOb2RlUHJvdG90eXBlKTtcbiAgICBjbG9uZWQudHlwZSA9IHR5cGU7XG4gICAgY2xvbmVkLnN0YXJ0ID0gc3RhcnQ7XG4gICAgY2xvbmVkLmVuZCA9IGVuZDtcbiAgICBjbG9uZWQubG9jID0gbG9jO1xuICAgIGNsb25lZC5yYW5nZSA9IHJhbmdlO1xuICAgIGNsb25lZC5uYW1lID0gbmFtZTtcbiAgICBpZiAobm9kZS5leHRyYSkgY2xvbmVkLmV4dHJhID0gbm9kZS5leHRyYTtcbiAgICByZXR1cm4gY2xvbmVkO1xuICB9XG4gIGNsb25lU3RyaW5nTGl0ZXJhbChub2RlKSB7XG4gICAgY29uc3Qge1xuICAgICAgdHlwZSxcbiAgICAgIHN0YXJ0LFxuICAgICAgZW5kLFxuICAgICAgbG9jLFxuICAgICAgcmFuZ2UsXG4gICAgICBleHRyYVxuICAgIH0gPSBub2RlO1xuICAgIGNvbnN0IGNsb25lZCA9IE9iamVjdC5jcmVhdGUoTm9kZVByb3RvdHlwZSk7XG4gICAgY2xvbmVkLnR5cGUgPSB0eXBlO1xuICAgIGNsb25lZC5zdGFydCA9IHN0YXJ0O1xuICAgIGNsb25lZC5lbmQgPSBlbmQ7XG4gICAgY2xvbmVkLmxvYyA9IGxvYztcbiAgICBjbG9uZWQucmFuZ2UgPSByYW5nZTtcbiAgICBjbG9uZWQuZXh0cmEgPSBleHRyYTtcbiAgICBjbG9uZWQudmFsdWUgPSBub2RlLnZhbHVlO1xuICAgIHJldHVybiBjbG9uZWQ7XG4gIH1cbn1cbmNvbnN0IHVud3JhcFBhcmVudGhlc2l6ZWRFeHByZXNzaW9uID0gbm9kZSA9PiB7XG4gIHJldHVybiBub2RlLnR5cGUgPT09IFwiUGFyZW50aGVzaXplZEV4cHJlc3Npb25cIiA/IHVud3JhcFBhcmVudGhlc2l6ZWRFeHByZXNzaW9uKG5vZGUuZXhwcmVzc2lvbikgOiBub2RlO1xufTtcbmNsYXNzIExWYWxQYXJzZXIgZXh0ZW5kcyBOb2RlVXRpbHMge1xuICB0b0Fzc2lnbmFibGUobm9kZSwgaXNMSFMgPSBmYWxzZSkge1xuICAgIHZhciBfbm9kZSRleHRyYSwgX25vZGUkZXh0cmEzO1xuICAgIGxldCBwYXJlbnRoZXNpemVkID0gdW5kZWZpbmVkO1xuICAgIGlmIChub2RlLnR5cGUgPT09IFwiUGFyZW50aGVzaXplZEV4cHJlc3Npb25cIiB8fCAoX25vZGUkZXh0cmEgPSBub2RlLmV4dHJhKSAhPSBudWxsICYmIF9ub2RlJGV4dHJhLnBhcmVudGhlc2l6ZWQpIHtcbiAgICAgIHBhcmVudGhlc2l6ZWQgPSB1bndyYXBQYXJlbnRoZXNpemVkRXhwcmVzc2lvbihub2RlKTtcbiAgICAgIGlmIChpc0xIUykge1xuICAgICAgICBpZiAocGFyZW50aGVzaXplZC50eXBlID09PSBcIklkZW50aWZpZXJcIikge1xuICAgICAgICAgIHRoaXMuZXhwcmVzc2lvblNjb3BlLnJlY29yZEFycm93UGFyYW1ldGVyQmluZGluZ0Vycm9yKEVycm9ycy5JbnZhbGlkUGFyZW50aGVzaXplZEFzc2lnbm1lbnQsIG5vZGUpO1xuICAgICAgICB9IGVsc2UgaWYgKHBhcmVudGhlc2l6ZWQudHlwZSAhPT0gXCJDYWxsRXhwcmVzc2lvblwiICYmIHBhcmVudGhlc2l6ZWQudHlwZSAhPT0gXCJNZW1iZXJFeHByZXNzaW9uXCIgJiYgIXRoaXMuaXNPcHRpb25hbE1lbWJlckV4cHJlc3Npb24ocGFyZW50aGVzaXplZCkpIHtcbiAgICAgICAgICB0aGlzLnJhaXNlKEVycm9ycy5JbnZhbGlkUGFyZW50aGVzaXplZEFzc2lnbm1lbnQsIG5vZGUpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLnJhaXNlKEVycm9ycy5JbnZhbGlkUGFyZW50aGVzaXplZEFzc2lnbm1lbnQsIG5vZGUpO1xuICAgICAgfVxuICAgIH1cbiAgICBzd2l0Y2ggKG5vZGUudHlwZSkge1xuICAgICAgY2FzZSBcIklkZW50aWZpZXJcIjpcbiAgICAgIGNhc2UgXCJPYmplY3RQYXR0ZXJuXCI6XG4gICAgICBjYXNlIFwiQXJyYXlQYXR0ZXJuXCI6XG4gICAgICBjYXNlIFwiQXNzaWdubWVudFBhdHRlcm5cIjpcbiAgICAgIGNhc2UgXCJSZXN0RWxlbWVudFwiOlxuICAgICAgY2FzZSBcIlZvaWRQYXR0ZXJuXCI6XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBcIk9iamVjdEV4cHJlc3Npb25cIjpcbiAgICAgICAgdGhpcy5jYXN0Tm9kZVRvKG5vZGUsIFwiT2JqZWN0UGF0dGVyblwiKTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDAsIGxlbmd0aCA9IG5vZGUucHJvcGVydGllcy5sZW5ndGgsIGxhc3QgPSBsZW5ndGggLSAxOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICB2YXIgX25vZGUkZXh0cmEyO1xuICAgICAgICAgIGNvbnN0IHByb3AgPSBub2RlLnByb3BlcnRpZXNbaV07XG4gICAgICAgICAgY29uc3QgaXNMYXN0ID0gaSA9PT0gbGFzdDtcbiAgICAgICAgICB0aGlzLnRvQXNzaWduYWJsZU9iamVjdEV4cHJlc3Npb25Qcm9wKHByb3AsIGlzTGFzdCwgaXNMSFMpO1xuICAgICAgICAgIGlmIChpc0xhc3QgJiYgcHJvcC50eXBlID09PSBcIlJlc3RFbGVtZW50XCIgJiYgKF9ub2RlJGV4dHJhMiA9IG5vZGUuZXh0cmEpICE9IG51bGwgJiYgX25vZGUkZXh0cmEyLnRyYWlsaW5nQ29tbWFMb2MpIHtcbiAgICAgICAgICAgIHRoaXMucmFpc2UoRXJyb3JzLlJlc3RUcmFpbGluZ0NvbW1hLCBub2RlLmV4dHJhLnRyYWlsaW5nQ29tbWFMb2MpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgXCJPYmplY3RQcm9wZXJ0eVwiOlxuICAgICAgICB7XG4gICAgICAgICAgY29uc3Qge1xuICAgICAgICAgICAga2V5LFxuICAgICAgICAgICAgdmFsdWVcbiAgICAgICAgICB9ID0gbm9kZTtcbiAgICAgICAgICBpZiAodGhpcy5pc1ByaXZhdGVOYW1lKGtleSkpIHtcbiAgICAgICAgICAgIHRoaXMuY2xhc3NTY29wZS51c2VQcml2YXRlTmFtZSh0aGlzLmdldFByaXZhdGVOYW1lU1Yoa2V5KSwga2V5LmxvYy5zdGFydCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHRoaXMudG9Bc3NpZ25hYmxlKHZhbHVlLCBpc0xIUyk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIGNhc2UgXCJTcHJlYWRFbGVtZW50XCI6XG4gICAgICAgIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnRlcm5hbCBAYmFiZWwvcGFyc2VyIGVycm9yICh0aGlzIGlzIGEgYnVnLCBwbGVhc2UgcmVwb3J0IGl0KS5cIiArIFwiIFNwcmVhZEVsZW1lbnQgc2hvdWxkIGJlIGNvbnZlcnRlZCBieSAudG9Bc3NpZ25hYmxlJ3MgY2FsbGVyLlwiKTtcbiAgICAgICAgfVxuICAgICAgY2FzZSBcIkFycmF5RXhwcmVzc2lvblwiOlxuICAgICAgICB0aGlzLmNhc3ROb2RlVG8obm9kZSwgXCJBcnJheVBhdHRlcm5cIik7XG4gICAgICAgIHRoaXMudG9Bc3NpZ25hYmxlTGlzdChub2RlLmVsZW1lbnRzLCAoX25vZGUkZXh0cmEzID0gbm9kZS5leHRyYSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9ub2RlJGV4dHJhMy50cmFpbGluZ0NvbW1hTG9jLCBpc0xIUyk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBcIkFzc2lnbm1lbnRFeHByZXNzaW9uXCI6XG4gICAgICAgIGlmIChub2RlLm9wZXJhdG9yICE9PSBcIj1cIikge1xuICAgICAgICAgIHRoaXMucmFpc2UoRXJyb3JzLk1pc3NpbmdFcUluQXNzaWdubWVudCwgbm9kZS5sZWZ0LmxvYy5lbmQpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuY2FzdE5vZGVUbyhub2RlLCBcIkFzc2lnbm1lbnRQYXR0ZXJuXCIpO1xuICAgICAgICBkZWxldGUgbm9kZS5vcGVyYXRvcjtcbiAgICAgICAgaWYgKG5vZGUubGVmdC50eXBlID09PSBcIlZvaWRQYXR0ZXJuXCIpIHtcbiAgICAgICAgICB0aGlzLnJhaXNlKEVycm9ycy5Wb2lkUGF0dGVybkluaXRpYWxpemVyLCBub2RlLmxlZnQpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMudG9Bc3NpZ25hYmxlKG5vZGUubGVmdCwgaXNMSFMpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgXCJQYXJlbnRoZXNpemVkRXhwcmVzc2lvblwiOlxuICAgICAgICB0aGlzLnRvQXNzaWduYWJsZShwYXJlbnRoZXNpemVkLCBpc0xIUyk7XG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuICB0b0Fzc2lnbmFibGVPYmplY3RFeHByZXNzaW9uUHJvcChwcm9wLCBpc0xhc3QsIGlzTEhTKSB7XG4gICAgaWYgKHByb3AudHlwZSA9PT0gXCJPYmplY3RNZXRob2RcIikge1xuICAgICAgdGhpcy5yYWlzZShwcm9wLmtpbmQgPT09IFwiZ2V0XCIgfHwgcHJvcC5raW5kID09PSBcInNldFwiID8gRXJyb3JzLlBhdHRlcm5IYXNBY2Nlc3NvciA6IEVycm9ycy5QYXR0ZXJuSGFzTWV0aG9kLCBwcm9wLmtleSk7XG4gICAgfSBlbHNlIGlmIChwcm9wLnR5cGUgPT09IFwiU3ByZWFkRWxlbWVudFwiKSB7XG4gICAgICB0aGlzLmNhc3ROb2RlVG8ocHJvcCwgXCJSZXN0RWxlbWVudFwiKTtcbiAgICAgIGNvbnN0IGFyZyA9IHByb3AuYXJndW1lbnQ7XG4gICAgICB0aGlzLmNoZWNrVG9SZXN0Q29udmVyc2lvbihhcmcsIGZhbHNlKTtcbiAgICAgIHRoaXMudG9Bc3NpZ25hYmxlKGFyZywgaXNMSFMpO1xuICAgICAgaWYgKCFpc0xhc3QpIHtcbiAgICAgICAgdGhpcy5yYWlzZShFcnJvcnMuUmVzdFRyYWlsaW5nQ29tbWEsIHByb3ApO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnRvQXNzaWduYWJsZShwcm9wLCBpc0xIUyk7XG4gICAgfVxuICB9XG4gIHRvQXNzaWduYWJsZUxpc3QoZXhwckxpc3QsIHRyYWlsaW5nQ29tbWFMb2MsIGlzTEhTKSB7XG4gICAgY29uc3QgZW5kID0gZXhwckxpc3QubGVuZ3RoIC0gMTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8PSBlbmQ7IGkrKykge1xuICAgICAgY29uc3QgZWx0ID0gZXhwckxpc3RbaV07XG4gICAgICBpZiAoIWVsdCkgY29udGludWU7XG4gICAgICB0aGlzLnRvQXNzaWduYWJsZUxpc3RJdGVtKGV4cHJMaXN0LCBpLCBpc0xIUyk7XG4gICAgICBpZiAoZWx0LnR5cGUgPT09IFwiUmVzdEVsZW1lbnRcIikge1xuICAgICAgICBpZiAoaSA8IGVuZCkge1xuICAgICAgICAgIHRoaXMucmFpc2UoRXJyb3JzLlJlc3RUcmFpbGluZ0NvbW1hLCBlbHQpO1xuICAgICAgICB9IGVsc2UgaWYgKHRyYWlsaW5nQ29tbWFMb2MpIHtcbiAgICAgICAgICB0aGlzLnJhaXNlKEVycm9ycy5SZXN0VHJhaWxpbmdDb21tYSwgdHJhaWxpbmdDb21tYUxvYyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgdG9Bc3NpZ25hYmxlTGlzdEl0ZW0oZXhwckxpc3QsIGluZGV4LCBpc0xIUykge1xuICAgIGNvbnN0IG5vZGUgPSBleHByTGlzdFtpbmRleF07XG4gICAgaWYgKG5vZGUudHlwZSA9PT0gXCJTcHJlYWRFbGVtZW50XCIpIHtcbiAgICAgIHRoaXMuY2FzdE5vZGVUbyhub2RlLCBcIlJlc3RFbGVtZW50XCIpO1xuICAgICAgY29uc3QgYXJnID0gbm9kZS5hcmd1bWVudDtcbiAgICAgIHRoaXMuY2hlY2tUb1Jlc3RDb252ZXJzaW9uKGFyZywgdHJ1ZSk7XG4gICAgICB0aGlzLnRvQXNzaWduYWJsZShhcmcsIGlzTEhTKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy50b0Fzc2lnbmFibGUobm9kZSwgaXNMSFMpO1xuICAgIH1cbiAgfVxuICBpc0Fzc2lnbmFibGUobm9kZSwgaXNCaW5kaW5nKSB7XG4gICAgc3dpdGNoIChub2RlLnR5cGUpIHtcbiAgICAgIGNhc2UgXCJJZGVudGlmaWVyXCI6XG4gICAgICBjYXNlIFwiT2JqZWN0UGF0dGVyblwiOlxuICAgICAgY2FzZSBcIkFycmF5UGF0dGVyblwiOlxuICAgICAgY2FzZSBcIkFzc2lnbm1lbnRQYXR0ZXJuXCI6XG4gICAgICBjYXNlIFwiUmVzdEVsZW1lbnRcIjpcbiAgICAgIGNhc2UgXCJWb2lkUGF0dGVyblwiOlxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIGNhc2UgXCJPYmplY3RFeHByZXNzaW9uXCI6XG4gICAgICAgIHtcbiAgICAgICAgICBjb25zdCBsYXN0ID0gbm9kZS5wcm9wZXJ0aWVzLmxlbmd0aCAtIDE7XG4gICAgICAgICAgcmV0dXJuIG5vZGUucHJvcGVydGllcy5ldmVyeSgocHJvcCwgaSkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIHByb3AudHlwZSAhPT0gXCJPYmplY3RNZXRob2RcIiAmJiAoaSA9PT0gbGFzdCB8fCBwcm9wLnR5cGUgIT09IFwiU3ByZWFkRWxlbWVudFwiKSAmJiB0aGlzLmlzQXNzaWduYWJsZShwcm9wKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgY2FzZSBcIk9iamVjdFByb3BlcnR5XCI6XG4gICAgICAgIHJldHVybiB0aGlzLmlzQXNzaWduYWJsZShub2RlLnZhbHVlKTtcbiAgICAgIGNhc2UgXCJTcHJlYWRFbGVtZW50XCI6XG4gICAgICAgIHJldHVybiB0aGlzLmlzQXNzaWduYWJsZShub2RlLmFyZ3VtZW50KTtcbiAgICAgIGNhc2UgXCJBcnJheUV4cHJlc3Npb25cIjpcbiAgICAgICAgcmV0dXJuIG5vZGUuZWxlbWVudHMuZXZlcnkoZWxlbWVudCA9PiBlbGVtZW50ID09PSBudWxsIHx8IHRoaXMuaXNBc3NpZ25hYmxlKGVsZW1lbnQpKTtcbiAgICAgIGNhc2UgXCJBc3NpZ25tZW50RXhwcmVzc2lvblwiOlxuICAgICAgICByZXR1cm4gbm9kZS5vcGVyYXRvciA9PT0gXCI9XCI7XG4gICAgICBjYXNlIFwiUGFyZW50aGVzaXplZEV4cHJlc3Npb25cIjpcbiAgICAgICAgcmV0dXJuIHRoaXMuaXNBc3NpZ25hYmxlKG5vZGUuZXhwcmVzc2lvbik7XG4gICAgICBjYXNlIFwiTWVtYmVyRXhwcmVzc2lvblwiOlxuICAgICAgY2FzZSBcIk9wdGlvbmFsTWVtYmVyRXhwcmVzc2lvblwiOlxuICAgICAgICByZXR1cm4gIWlzQmluZGluZztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cbiAgdG9SZWZlcmVuY2VkTGlzdChleHByTGlzdCwgaXNQYXJlbnRoZXNpemVkRXhwcikge1xuICAgIHJldHVybiBleHByTGlzdDtcbiAgfVxuICB0b1JlZmVyZW5jZWRMaXN0RGVlcChleHByTGlzdCwgaXNQYXJlbnRoZXNpemVkRXhwcikge1xuICAgIHRoaXMudG9SZWZlcmVuY2VkTGlzdChleHByTGlzdCwgaXNQYXJlbnRoZXNpemVkRXhwcik7XG4gICAgZm9yIChjb25zdCBleHByIG9mIGV4cHJMaXN0KSB7XG4gICAgICBpZiAoKGV4cHIgPT0gbnVsbCA/IHZvaWQgMCA6IGV4cHIudHlwZSkgPT09IFwiQXJyYXlFeHByZXNzaW9uXCIpIHtcbiAgICAgICAgdGhpcy50b1JlZmVyZW5jZWRMaXN0RGVlcChleHByLmVsZW1lbnRzKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcGFyc2VTcHJlYWQocmVmRXhwcmVzc2lvbkVycm9ycykge1xuICAgIGNvbnN0IG5vZGUgPSB0aGlzLnN0YXJ0Tm9kZSgpO1xuICAgIHRoaXMubmV4dCgpO1xuICAgIG5vZGUuYXJndW1lbnQgPSB0aGlzLnBhcnNlTWF5YmVBc3NpZ25BbGxvd0luKHJlZkV4cHJlc3Npb25FcnJvcnMsIHVuZGVmaW5lZCk7XG4gICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIlNwcmVhZEVsZW1lbnRcIik7XG4gIH1cbiAgcGFyc2VSZXN0QmluZGluZygpIHtcbiAgICBjb25zdCBub2RlID0gdGhpcy5zdGFydE5vZGUoKTtcbiAgICB0aGlzLm5leHQoKTtcbiAgICBjb25zdCBhcmd1bWVudCA9IHRoaXMucGFyc2VCaW5kaW5nQXRvbSgpO1xuICAgIGlmIChhcmd1bWVudC50eXBlID09PSBcIlZvaWRQYXR0ZXJuXCIpIHtcbiAgICAgIHRoaXMucmFpc2UoRXJyb3JzLlVuZXhwZWN0ZWRWb2lkUGF0dGVybiwgYXJndW1lbnQpO1xuICAgIH1cbiAgICBub2RlLmFyZ3VtZW50ID0gYXJndW1lbnQ7XG4gICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIlJlc3RFbGVtZW50XCIpO1xuICB9XG4gIHBhcnNlQmluZGluZ0F0b20oKSB7XG4gICAgc3dpdGNoICh0aGlzLnN0YXRlLnR5cGUpIHtcbiAgICAgIGNhc2UgMDpcbiAgICAgICAge1xuICAgICAgICAgIGNvbnN0IG5vZGUgPSB0aGlzLnN0YXJ0Tm9kZSgpO1xuICAgICAgICAgIHRoaXMubmV4dCgpO1xuICAgICAgICAgIG5vZGUuZWxlbWVudHMgPSB0aGlzLnBhcnNlQmluZGluZ0xpc3QoMywgOTMsIDEpO1xuICAgICAgICAgIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJBcnJheVBhdHRlcm5cIik7XG4gICAgICAgIH1cbiAgICAgIGNhc2UgNTpcbiAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VPYmplY3RMaWtlKDgsIHRydWUpO1xuICAgICAgY2FzZSA4ODpcbiAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VWb2lkUGF0dGVybihudWxsKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMucGFyc2VJZGVudGlmaWVyKCk7XG4gIH1cbiAgcGFyc2VCaW5kaW5nTGlzdChjbG9zZSwgY2xvc2VDaGFyQ29kZSwgZmxhZ3MpIHtcbiAgICBjb25zdCBhbGxvd0VtcHR5ID0gZmxhZ3MgJiAxO1xuICAgIGNvbnN0IGVsdHMgPSBbXTtcbiAgICBsZXQgZmlyc3QgPSB0cnVlO1xuICAgIHdoaWxlICghdGhpcy5lYXQoY2xvc2UpKSB7XG4gICAgICBpZiAoZmlyc3QpIHtcbiAgICAgICAgZmlyc3QgPSBmYWxzZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuZXhwZWN0KDEyKTtcbiAgICAgIH1cbiAgICAgIGlmIChhbGxvd0VtcHR5ICYmIHRoaXMubWF0Y2goMTIpKSB7XG4gICAgICAgIGVsdHMucHVzaChudWxsKTtcbiAgICAgIH0gZWxzZSBpZiAodGhpcy5lYXQoY2xvc2UpKSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfSBlbHNlIGlmICh0aGlzLm1hdGNoKDIxKSkge1xuICAgICAgICBsZXQgcmVzdCA9IHRoaXMucGFyc2VSZXN0QmluZGluZygpO1xuICAgICAgICBpZiAodGhpcy5oYXNQbHVnaW4oXCJmbG93XCIpIHx8IGZsYWdzICYgMikge1xuICAgICAgICAgIHJlc3QgPSB0aGlzLnBhcnNlRnVuY3Rpb25QYXJhbVR5cGUocmVzdCk7XG4gICAgICAgIH1cbiAgICAgICAgZWx0cy5wdXNoKHJlc3QpO1xuICAgICAgICBpZiAoIXRoaXMuY2hlY2tDb21tYUFmdGVyUmVzdChjbG9zZUNoYXJDb2RlKSkge1xuICAgICAgICAgIHRoaXMuZXhwZWN0KGNsb3NlKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc3QgZGVjb3JhdG9ycyA9IFtdO1xuICAgICAgICBpZiAoZmxhZ3MgJiAyKSB7XG4gICAgICAgICAgaWYgKHRoaXMubWF0Y2goMjYpICYmIHRoaXMuaGFzUGx1Z2luKFwiZGVjb3JhdG9yc1wiKSkge1xuICAgICAgICAgICAgdGhpcy5yYWlzZShFcnJvcnMuVW5zdXBwb3J0ZWRQYXJhbWV0ZXJEZWNvcmF0b3IsIHRoaXMuc3RhdGUuc3RhcnRMb2MpO1xuICAgICAgICAgIH1cbiAgICAgICAgICB3aGlsZSAodGhpcy5tYXRjaCgyNikpIHtcbiAgICAgICAgICAgIGRlY29yYXRvcnMucHVzaCh0aGlzLnBhcnNlRGVjb3JhdG9yKCkpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHRzLnB1c2godGhpcy5wYXJzZUJpbmRpbmdFbGVtZW50KGZsYWdzLCBkZWNvcmF0b3JzKSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBlbHRzO1xuICB9XG4gIHBhcnNlQmluZGluZ1Jlc3RQcm9wZXJ0eShwcm9wKSB7XG4gICAgdGhpcy5uZXh0KCk7XG4gICAgaWYgKHRoaXMuaGFzUGx1Z2luKFwiZGlzY2FyZEJpbmRpbmdcIikgJiYgdGhpcy5tYXRjaCg4OCkpIHtcbiAgICAgIHByb3AuYXJndW1lbnQgPSB0aGlzLnBhcnNlVm9pZFBhdHRlcm4obnVsbCk7XG4gICAgICB0aGlzLnJhaXNlKEVycm9ycy5VbmV4cGVjdGVkVm9pZFBhdHRlcm4sIHByb3AuYXJndW1lbnQpO1xuICAgIH0gZWxzZSB7XG4gICAgICBwcm9wLmFyZ3VtZW50ID0gdGhpcy5wYXJzZUlkZW50aWZpZXIoKTtcbiAgICB9XG4gICAgdGhpcy5jaGVja0NvbW1hQWZ0ZXJSZXN0KDEyNSk7XG4gICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShwcm9wLCBcIlJlc3RFbGVtZW50XCIpO1xuICB9XG4gIHBhcnNlQmluZGluZ1Byb3BlcnR5KCkge1xuICAgIGNvbnN0IHtcbiAgICAgIHR5cGUsXG4gICAgICBzdGFydExvY1xuICAgIH0gPSB0aGlzLnN0YXRlO1xuICAgIGlmICh0eXBlID09PSAyMSkge1xuICAgICAgcmV0dXJuIHRoaXMucGFyc2VCaW5kaW5nUmVzdFByb3BlcnR5KHRoaXMuc3RhcnROb2RlKCkpO1xuICAgIH1cbiAgICBjb25zdCBwcm9wID0gdGhpcy5zdGFydE5vZGUoKTtcbiAgICBpZiAodHlwZSA9PT0gMTM5KSB7XG4gICAgICB0aGlzLmV4cGVjdFBsdWdpbihcImRlc3RydWN0dXJpbmdQcml2YXRlXCIsIHN0YXJ0TG9jKTtcbiAgICAgIHRoaXMuY2xhc3NTY29wZS51c2VQcml2YXRlTmFtZSh0aGlzLnN0YXRlLnZhbHVlLCBzdGFydExvYyk7XG4gICAgICBwcm9wLmtleSA9IHRoaXMucGFyc2VQcml2YXRlTmFtZSgpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnBhcnNlUHJvcGVydHlOYW1lKHByb3ApO1xuICAgIH1cbiAgICBwcm9wLm1ldGhvZCA9IGZhbHNlO1xuICAgIHJldHVybiB0aGlzLnBhcnNlT2JqUHJvcFZhbHVlKHByb3AsIHN0YXJ0TG9jLCBmYWxzZSwgZmFsc2UsIHRydWUsIGZhbHNlKTtcbiAgfVxuICBwYXJzZUJpbmRpbmdFbGVtZW50KGZsYWdzLCBkZWNvcmF0b3JzKSB7XG4gICAgY29uc3QgbGVmdCA9IHRoaXMucGFyc2VNYXliZURlZmF1bHQoKTtcbiAgICBpZiAodGhpcy5oYXNQbHVnaW4oXCJmbG93XCIpIHx8IGZsYWdzICYgMikge1xuICAgICAgdGhpcy5wYXJzZUZ1bmN0aW9uUGFyYW1UeXBlKGxlZnQpO1xuICAgIH1cbiAgICBpZiAoZGVjb3JhdG9ycy5sZW5ndGgpIHtcbiAgICAgIGxlZnQuZGVjb3JhdG9ycyA9IGRlY29yYXRvcnM7XG4gICAgICB0aGlzLnJlc2V0U3RhcnRMb2NhdGlvbkZyb21Ob2RlKGxlZnQsIGRlY29yYXRvcnNbMF0pO1xuICAgIH1cbiAgICBjb25zdCBlbHQgPSB0aGlzLnBhcnNlTWF5YmVEZWZhdWx0KGxlZnQubG9jLnN0YXJ0LCBsZWZ0KTtcbiAgICByZXR1cm4gZWx0O1xuICB9XG4gIHBhcnNlRnVuY3Rpb25QYXJhbVR5cGUocGFyYW0pIHtcbiAgICByZXR1cm4gcGFyYW07XG4gIH1cbiAgcGFyc2VNYXliZURlZmF1bHQoc3RhcnRMb2MsIGxlZnQpIHtcbiAgICBzdGFydExvYyAhPSBudWxsID8gc3RhcnRMb2MgOiBzdGFydExvYyA9IHRoaXMuc3RhdGUuc3RhcnRMb2M7XG4gICAgbGVmdCA9IGxlZnQgIT0gbnVsbCA/IGxlZnQgOiB0aGlzLnBhcnNlQmluZGluZ0F0b20oKTtcbiAgICBpZiAoIXRoaXMuZWF0KDI5KSkgcmV0dXJuIGxlZnQ7XG4gICAgY29uc3Qgbm9kZSA9IHRoaXMuc3RhcnROb2RlQXQoc3RhcnRMb2MpO1xuICAgIGlmIChsZWZ0LnR5cGUgPT09IFwiVm9pZFBhdHRlcm5cIikge1xuICAgICAgdGhpcy5yYWlzZShFcnJvcnMuVm9pZFBhdHRlcm5Jbml0aWFsaXplciwgbGVmdCk7XG4gICAgfVxuICAgIG5vZGUubGVmdCA9IGxlZnQ7XG4gICAgbm9kZS5yaWdodCA9IHRoaXMucGFyc2VNYXliZUFzc2lnbkFsbG93SW4oKTtcbiAgICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiQXNzaWdubWVudFBhdHRlcm5cIik7XG4gIH1cbiAgaXNWYWxpZExWYWwodHlwZSwgZGlzYWxsb3dDYWxsRXhwcmVzc2lvbiwgaXNVbnBhcmVudGhlc2l6ZWRJbkFzc2lnbiwgYmluZGluZykge1xuICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgY2FzZSBcIkFzc2lnbm1lbnRQYXR0ZXJuXCI6XG4gICAgICAgIHJldHVybiBcImxlZnRcIjtcbiAgICAgIGNhc2UgXCJSZXN0RWxlbWVudFwiOlxuICAgICAgICByZXR1cm4gXCJhcmd1bWVudFwiO1xuICAgICAgY2FzZSBcIk9iamVjdFByb3BlcnR5XCI6XG4gICAgICAgIHJldHVybiBcInZhbHVlXCI7XG4gICAgICBjYXNlIFwiUGFyZW50aGVzaXplZEV4cHJlc3Npb25cIjpcbiAgICAgICAgcmV0dXJuIFwiZXhwcmVzc2lvblwiO1xuICAgICAgY2FzZSBcIkFycmF5UGF0dGVyblwiOlxuICAgICAgICByZXR1cm4gXCJlbGVtZW50c1wiO1xuICAgICAgY2FzZSBcIk9iamVjdFBhdHRlcm5cIjpcbiAgICAgICAgcmV0dXJuIFwicHJvcGVydGllc1wiO1xuICAgICAgY2FzZSBcIlZvaWRQYXR0ZXJuXCI6XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgY2FzZSBcIkNhbGxFeHByZXNzaW9uXCI6XG4gICAgICAgIGlmICghZGlzYWxsb3dDYWxsRXhwcmVzc2lvbiAmJiAhdGhpcy5zdGF0ZS5zdHJpY3QgJiYgdGhpcy5vcHRpb25GbGFncyAmIDgxOTIpIHtcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgaXNPcHRpb25hbE1lbWJlckV4cHJlc3Npb24oZXhwcmVzc2lvbikge1xuICAgIHJldHVybiBleHByZXNzaW9uLnR5cGUgPT09IFwiT3B0aW9uYWxNZW1iZXJFeHByZXNzaW9uXCI7XG4gIH1cbiAgY2hlY2tMVmFsKGV4cHJlc3Npb24sIGFuY2VzdG9yLCBiaW5kaW5nID0gNjQsIGNoZWNrQ2xhc2hlcyA9IGZhbHNlLCBzdHJpY3RNb2RlQ2hhbmdlZCA9IGZhbHNlLCBoYXNQYXJlbnRoZXNpemVkQW5jZXN0b3IgPSBmYWxzZSwgZGlzYWxsb3dDYWxsRXhwcmVzc2lvbiA9IGZhbHNlKSB7XG4gICAgdmFyIF9leHByZXNzaW9uJGV4dHJhO1xuICAgIGNvbnN0IHR5cGUgPSBleHByZXNzaW9uLnR5cGU7XG4gICAgaWYgKHRoaXMuaXNPYmplY3RNZXRob2QoZXhwcmVzc2lvbikpIHJldHVybjtcbiAgICBjb25zdCBpc09wdGlvbmFsTWVtYmVyRXhwcmVzc2lvbiA9IHRoaXMuaXNPcHRpb25hbE1lbWJlckV4cHJlc3Npb24oZXhwcmVzc2lvbik7XG4gICAgaWYgKGlzT3B0aW9uYWxNZW1iZXJFeHByZXNzaW9uIHx8IHR5cGUgPT09IFwiTWVtYmVyRXhwcmVzc2lvblwiKSB7XG4gICAgICBpZiAoaXNPcHRpb25hbE1lbWJlckV4cHJlc3Npb24pIHtcbiAgICAgICAgdGhpcy5leHBlY3RQbHVnaW4oXCJvcHRpb25hbENoYWluaW5nQXNzaWduXCIsIGV4cHJlc3Npb24ubG9jLnN0YXJ0KTtcbiAgICAgICAgaWYgKGFuY2VzdG9yLnR5cGUgIT09IFwiQXNzaWdubWVudEV4cHJlc3Npb25cIikge1xuICAgICAgICAgIHRoaXMucmFpc2UoRXJyb3JzLkludmFsaWRMaHNPcHRpb25hbENoYWluaW5nLCBleHByZXNzaW9uLCB7XG4gICAgICAgICAgICBhbmNlc3RvclxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoYmluZGluZyAhPT0gNjQpIHtcbiAgICAgICAgdGhpcy5yYWlzZShFcnJvcnMuSW52YWxpZFByb3BlcnR5QmluZGluZ1BhdHRlcm4sIGV4cHJlc3Npb24pO1xuICAgICAgfVxuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAodHlwZSA9PT0gXCJJZGVudGlmaWVyXCIpIHtcbiAgICAgIHRoaXMuY2hlY2tJZGVudGlmaWVyKGV4cHJlc3Npb24sIGJpbmRpbmcsIHN0cmljdE1vZGVDaGFuZ2VkKTtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgbmFtZVxuICAgICAgfSA9IGV4cHJlc3Npb247XG4gICAgICBpZiAoY2hlY2tDbGFzaGVzKSB7XG4gICAgICAgIGlmIChjaGVja0NsYXNoZXMuaGFzKG5hbWUpKSB7XG4gICAgICAgICAgdGhpcy5yYWlzZShFcnJvcnMuUGFyYW1EdXBlLCBleHByZXNzaW9uKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjaGVja0NsYXNoZXMuYWRkKG5hbWUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm47XG4gICAgfSBlbHNlIGlmICh0eXBlID09PSBcIlZvaWRQYXR0ZXJuXCIgJiYgYW5jZXN0b3IudHlwZSA9PT0gXCJDYXRjaENsYXVzZVwiKSB7XG4gICAgICB0aGlzLnJhaXNlKEVycm9ycy5Wb2lkUGF0dGVybkNhdGNoQ2xhdXNlUGFyYW0sIGV4cHJlc3Npb24pO1xuICAgIH1cbiAgICBjb25zdCB1bndyYXBwZWRFeHByZXNzaW9uID0gdW53cmFwUGFyZW50aGVzaXplZEV4cHJlc3Npb24oZXhwcmVzc2lvbik7XG4gICAgZGlzYWxsb3dDYWxsRXhwcmVzc2lvbiB8fCAoZGlzYWxsb3dDYWxsRXhwcmVzc2lvbiA9IHVud3JhcHBlZEV4cHJlc3Npb24udHlwZSA9PT0gXCJDYWxsRXhwcmVzc2lvblwiICYmICh1bndyYXBwZWRFeHByZXNzaW9uLmNhbGxlZS50eXBlID09PSBcIkltcG9ydFwiIHx8IHVud3JhcHBlZEV4cHJlc3Npb24uY2FsbGVlLnR5cGUgPT09IFwiU3VwZXJcIikpO1xuICAgIGNvbnN0IHZhbGlkaXR5ID0gdGhpcy5pc1ZhbGlkTFZhbCh0eXBlLCBkaXNhbGxvd0NhbGxFeHByZXNzaW9uLCAhKGhhc1BhcmVudGhlc2l6ZWRBbmNlc3RvciB8fCAoX2V4cHJlc3Npb24kZXh0cmEgPSBleHByZXNzaW9uLmV4dHJhKSAhPSBudWxsICYmIF9leHByZXNzaW9uJGV4dHJhLnBhcmVudGhlc2l6ZWQpICYmIGFuY2VzdG9yLnR5cGUgPT09IFwiQXNzaWdubWVudEV4cHJlc3Npb25cIiwgYmluZGluZyk7XG4gICAgaWYgKHZhbGlkaXR5ID09PSB0cnVlKSByZXR1cm47XG4gICAgaWYgKHZhbGlkaXR5ID09PSBmYWxzZSkge1xuICAgICAgY29uc3QgUGFyc2VFcnJvckNsYXNzID0gYmluZGluZyA9PT0gNjQgPyBFcnJvcnMuSW52YWxpZExocyA6IEVycm9ycy5JbnZhbGlkTGhzQmluZGluZztcbiAgICAgIHRoaXMucmFpc2UoUGFyc2VFcnJvckNsYXNzLCBleHByZXNzaW9uLCB7XG4gICAgICAgIGFuY2VzdG9yXG4gICAgICB9KTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgbGV0IGtleSwgaXNQYXJlbnRoZXNpemVkRXhwcmVzc2lvbjtcbiAgICBpZiAodHlwZW9mIHZhbGlkaXR5ID09PSBcInN0cmluZ1wiKSB7XG4gICAgICBrZXkgPSB2YWxpZGl0eTtcbiAgICAgIGlzUGFyZW50aGVzaXplZEV4cHJlc3Npb24gPSB0eXBlID09PSBcIlBhcmVudGhlc2l6ZWRFeHByZXNzaW9uXCI7XG4gICAgfSBlbHNlIHtcbiAgICAgIFtrZXksIGlzUGFyZW50aGVzaXplZEV4cHJlc3Npb25dID0gdmFsaWRpdHk7XG4gICAgfVxuICAgIGNvbnN0IG5leHRBbmNlc3RvciA9IHR5cGUgPT09IFwiQXJyYXlQYXR0ZXJuXCIgfHwgdHlwZSA9PT0gXCJPYmplY3RQYXR0ZXJuXCIgPyB7XG4gICAgICB0eXBlXG4gICAgfSA6IGFuY2VzdG9yO1xuICAgIGNvbnN0IHZhbCA9IGV4cHJlc3Npb25ba2V5XTtcbiAgICBpZiAoQXJyYXkuaXNBcnJheSh2YWwpKSB7XG4gICAgICBmb3IgKGNvbnN0IGNoaWxkIG9mIHZhbCkge1xuICAgICAgICBpZiAoY2hpbGQpIHtcbiAgICAgICAgICB0aGlzLmNoZWNrTFZhbChjaGlsZCwgbmV4dEFuY2VzdG9yLCBiaW5kaW5nLCBjaGVja0NsYXNoZXMsIHN0cmljdE1vZGVDaGFuZ2VkLCBpc1BhcmVudGhlc2l6ZWRFeHByZXNzaW9uLCB0cnVlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSBpZiAodmFsKSB7XG4gICAgICB0aGlzLmNoZWNrTFZhbCh2YWwsIG5leHRBbmNlc3RvciwgYmluZGluZywgY2hlY2tDbGFzaGVzLCBzdHJpY3RNb2RlQ2hhbmdlZCwgaXNQYXJlbnRoZXNpemVkRXhwcmVzc2lvbiwgZGlzYWxsb3dDYWxsRXhwcmVzc2lvbik7XG4gICAgfVxuICB9XG4gIGNoZWNrSWRlbnRpZmllcihhdCwgYmluZGluZ1R5cGUsIHN0cmljdE1vZGVDaGFuZ2VkID0gZmFsc2UpIHtcbiAgICBpZiAodGhpcy5zdGF0ZS5zdHJpY3QgJiYgKHN0cmljdE1vZGVDaGFuZ2VkID8gaXNTdHJpY3RCaW5kUmVzZXJ2ZWRXb3JkKGF0Lm5hbWUsIHRoaXMuaW5Nb2R1bGUpIDogaXNTdHJpY3RCaW5kT25seVJlc2VydmVkV29yZChhdC5uYW1lKSkpIHtcbiAgICAgIGlmIChiaW5kaW5nVHlwZSA9PT0gNjQpIHtcbiAgICAgICAgdGhpcy5yYWlzZShFcnJvcnMuU3RyaWN0RXZhbEFyZ3VtZW50cywgYXQsIHtcbiAgICAgICAgICByZWZlcmVuY2VOYW1lOiBhdC5uYW1lXG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5yYWlzZShFcnJvcnMuU3RyaWN0RXZhbEFyZ3VtZW50c0JpbmRpbmcsIGF0LCB7XG4gICAgICAgICAgYmluZGluZ05hbWU6IGF0Lm5hbWVcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChiaW5kaW5nVHlwZSAmIDgxOTIgJiYgYXQubmFtZSA9PT0gXCJsZXRcIikge1xuICAgICAgdGhpcy5yYWlzZShFcnJvcnMuTGV0SW5MZXhpY2FsQmluZGluZywgYXQpO1xuICAgIH1cbiAgICBpZiAoIShiaW5kaW5nVHlwZSAmIDY0KSkge1xuICAgICAgdGhpcy5kZWNsYXJlTmFtZUZyb21JZGVudGlmaWVyKGF0LCBiaW5kaW5nVHlwZSk7XG4gICAgfVxuICB9XG4gIGRlY2xhcmVOYW1lRnJvbUlkZW50aWZpZXIoaWRlbnRpZmllciwgYmluZGluZykge1xuICAgIHRoaXMuc2NvcGUuZGVjbGFyZU5hbWUoaWRlbnRpZmllci5uYW1lLCBiaW5kaW5nLCBpZGVudGlmaWVyLmxvYy5zdGFydCk7XG4gIH1cbiAgY2hlY2tUb1Jlc3RDb252ZXJzaW9uKG5vZGUsIGFsbG93UGF0dGVybikge1xuICAgIHN3aXRjaCAobm9kZS50eXBlKSB7XG4gICAgICBjYXNlIFwiUGFyZW50aGVzaXplZEV4cHJlc3Npb25cIjpcbiAgICAgICAgdGhpcy5jaGVja1RvUmVzdENvbnZlcnNpb24obm9kZS5leHByZXNzaW9uLCBhbGxvd1BhdHRlcm4pO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgXCJJZGVudGlmaWVyXCI6XG4gICAgICBjYXNlIFwiTWVtYmVyRXhwcmVzc2lvblwiOlxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgXCJBcnJheUV4cHJlc3Npb25cIjpcbiAgICAgIGNhc2UgXCJPYmplY3RFeHByZXNzaW9uXCI6XG4gICAgICAgIGlmIChhbGxvd1BhdHRlcm4pIGJyZWFrO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgdGhpcy5yYWlzZShFcnJvcnMuSW52YWxpZFJlc3RBc3NpZ25tZW50UGF0dGVybiwgbm9kZSk7XG4gICAgfVxuICB9XG4gIGNoZWNrQ29tbWFBZnRlclJlc3QoY2xvc2UpIHtcbiAgICBpZiAoIXRoaXMubWF0Y2goMTIpKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHRoaXMucmFpc2UodGhpcy5sb29rYWhlYWRDaGFyQ29kZSgpID09PSBjbG9zZSA/IEVycm9ycy5SZXN0VHJhaWxpbmdDb21tYSA6IEVycm9ycy5FbGVtZW50QWZ0ZXJSZXN0LCB0aGlzLnN0YXRlLnN0YXJ0TG9jKTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxufVxuY29uc3Qga2V5d29yZEFuZFRTUmVsYXRpb25hbE9wZXJhdG9yID0gL2luKD86c3RhbmNlb2YpP3xhc3xzYXRpc2ZpZXMveTtcbmZ1bmN0aW9uIG5vbk51bGwoeCkge1xuICBpZiAoeCA9PSBudWxsKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBVbmV4cGVjdGVkICR7eH0gdmFsdWUuYCk7XG4gIH1cbiAgcmV0dXJuIHg7XG59XG5mdW5jdGlvbiBhc3NlcnQoeCkge1xuICBpZiAoIXgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJBc3NlcnQgZmFpbFwiKTtcbiAgfVxufVxuY29uc3QgVFNFcnJvcnMgPSBQYXJzZUVycm9yRW51bWB0eXBlc2NyaXB0YCh7XG4gIEFic3RyYWN0TWV0aG9kSGFzSW1wbGVtZW50YXRpb246ICh7XG4gICAgbWV0aG9kTmFtZVxuICB9KSA9PiBgTWV0aG9kICcke21ldGhvZE5hbWV9JyBjYW5ub3QgaGF2ZSBhbiBpbXBsZW1lbnRhdGlvbiBiZWNhdXNlIGl0IGlzIG1hcmtlZCBhYnN0cmFjdC5gLFxuICBBYnN0cmFjdFByb3BlcnR5SGFzSW5pdGlhbGl6ZXI6ICh7XG4gICAgcHJvcGVydHlOYW1lXG4gIH0pID0+IGBQcm9wZXJ0eSAnJHtwcm9wZXJ0eU5hbWV9JyBjYW5ub3QgaGF2ZSBhbiBpbml0aWFsaXplciBiZWNhdXNlIGl0IGlzIG1hcmtlZCBhYnN0cmFjdC5gLFxuICBBY2Nlc3NvckNhbm5vdEJlT3B0aW9uYWw6IFwiQW4gJ2FjY2Vzc29yJyBwcm9wZXJ0eSBjYW5ub3QgYmUgZGVjbGFyZWQgb3B0aW9uYWwuXCIsXG4gIEFjY2Vzc29yQ2Fubm90RGVjbGFyZVRoaXNQYXJhbWV0ZXI6IFwiJ2dldCcgYW5kICdzZXQnIGFjY2Vzc29ycyBjYW5ub3QgZGVjbGFyZSAndGhpcycgcGFyYW1ldGVycy5cIixcbiAgQWNjZXNzb3JDYW5ub3RIYXZlVHlwZVBhcmFtZXRlcnM6IFwiQW4gYWNjZXNzb3IgY2Fubm90IGhhdmUgdHlwZSBwYXJhbWV0ZXJzLlwiLFxuICBDbGFzc01ldGhvZEhhc0RlY2xhcmU6IFwiQ2xhc3MgbWV0aG9kcyBjYW5ub3QgaGF2ZSB0aGUgJ2RlY2xhcmUnIG1vZGlmaWVyLlwiLFxuICBDbGFzc01ldGhvZEhhc1JlYWRvbmx5OiBcIkNsYXNzIG1ldGhvZHMgY2Fubm90IGhhdmUgdGhlICdyZWFkb25seScgbW9kaWZpZXIuXCIsXG4gIENvbnN0SW5pdGlhbGl6ZXJNdXN0QmVTdHJpbmdPck51bWVyaWNMaXRlcmFsT3JMaXRlcmFsRW51bVJlZmVyZW5jZTogXCJBICdjb25zdCcgaW5pdGlhbGl6ZXIgaW4gYW4gYW1iaWVudCBjb250ZXh0IG11c3QgYmUgYSBzdHJpbmcgb3IgbnVtZXJpYyBsaXRlcmFsIG9yIGxpdGVyYWwgZW51bSByZWZlcmVuY2UuXCIsXG4gIENvbnN0cnVjdG9ySGFzVHlwZVBhcmFtZXRlcnM6IFwiVHlwZSBwYXJhbWV0ZXJzIGNhbm5vdCBhcHBlYXIgb24gYSBjb25zdHJ1Y3RvciBkZWNsYXJhdGlvbi5cIixcbiAgRGVjbGFyZUFjY2Vzc29yOiAoe1xuICAgIGtpbmRcbiAgfSkgPT4gYCdkZWNsYXJlJyBpcyBub3QgYWxsb3dlZCBpbiAke2tpbmR9dGVycy5gLFxuICBEZWNsYXJlQ2xhc3NGaWVsZEhhc0luaXRpYWxpemVyOiBcIkluaXRpYWxpemVycyBhcmUgbm90IGFsbG93ZWQgaW4gYW1iaWVudCBjb250ZXh0cy5cIixcbiAgRGVjbGFyZUZ1bmN0aW9uSGFzSW1wbGVtZW50YXRpb246IFwiQW4gaW1wbGVtZW50YXRpb24gY2Fubm90IGJlIGRlY2xhcmVkIGluIGFtYmllbnQgY29udGV4dHMuXCIsXG4gIER1cGxpY2F0ZUFjY2Vzc2liaWxpdHlNb2RpZmllcjogKHtcbiAgICBtb2RpZmllclxuICB9KSA9PiBgQWNjZXNzaWJpbGl0eSBtb2RpZmllciBhbHJlYWR5IHNlZW46ICcke21vZGlmaWVyfScuYCxcbiAgRHVwbGljYXRlTW9kaWZpZXI6ICh7XG4gICAgbW9kaWZpZXJcbiAgfSkgPT4gYER1cGxpY2F0ZSBtb2RpZmllcjogJyR7bW9kaWZpZXJ9Jy5gLFxuICBFbXB0eUhlcml0YWdlQ2xhdXNlVHlwZTogKHtcbiAgICB0b2tlblxuICB9KSA9PiBgJyR7dG9rZW59JyBsaXN0IGNhbm5vdCBiZSBlbXB0eS5gLFxuICBFbXB0eVR5cGVBcmd1bWVudHM6IFwiVHlwZSBhcmd1bWVudCBsaXN0IGNhbm5vdCBiZSBlbXB0eS5cIixcbiAgRW1wdHlUeXBlUGFyYW1ldGVyczogXCJUeXBlIHBhcmFtZXRlciBsaXN0IGNhbm5vdCBiZSBlbXB0eS5cIixcbiAgRXhwZWN0ZWRBbWJpZW50QWZ0ZXJFeHBvcnREZWNsYXJlOiBcIidleHBvcnQgZGVjbGFyZScgbXVzdCBiZSBmb2xsb3dlZCBieSBhbiBhbWJpZW50IGRlY2xhcmF0aW9uLlwiLFxuICBJbXBvcnRBbGlhc0hhc0ltcG9ydFR5cGU6IFwiQW4gaW1wb3J0IGFsaWFzIGNhbiBub3QgdXNlICdpbXBvcnQgdHlwZScuXCIsXG4gIEltcG9ydFJlZmxlY3Rpb25IYXNJbXBvcnRUeXBlOiBcIkFuIGBpbXBvcnQgbW9kdWxlYCBkZWNsYXJhdGlvbiBjYW4gbm90IHVzZSBgdHlwZWAgbW9kaWZpZXJcIixcbiAgSW5jb21wYXRpYmxlTW9kaWZpZXJzOiAoe1xuICAgIG1vZGlmaWVyc1xuICB9KSA9PiBgJyR7bW9kaWZpZXJzWzBdfScgbW9kaWZpZXIgY2Fubm90IGJlIHVzZWQgd2l0aCAnJHttb2RpZmllcnNbMV19JyBtb2RpZmllci5gLFxuICBJbmRleFNpZ25hdHVyZUhhc0Fic3RyYWN0OiBcIkluZGV4IHNpZ25hdHVyZXMgY2Fubm90IGhhdmUgdGhlICdhYnN0cmFjdCcgbW9kaWZpZXIuXCIsXG4gIEluZGV4U2lnbmF0dXJlSGFzQWNjZXNzaWJpbGl0eTogKHtcbiAgICBtb2RpZmllclxuICB9KSA9PiBgSW5kZXggc2lnbmF0dXJlcyBjYW5ub3QgaGF2ZSBhbiBhY2Nlc3NpYmlsaXR5IG1vZGlmaWVyICgnJHttb2RpZmllcn0nKS5gLFxuICBJbmRleFNpZ25hdHVyZUhhc0RlY2xhcmU6IFwiSW5kZXggc2lnbmF0dXJlcyBjYW5ub3QgaGF2ZSB0aGUgJ2RlY2xhcmUnIG1vZGlmaWVyLlwiLFxuICBJbmRleFNpZ25hdHVyZUhhc092ZXJyaWRlOiBcIidvdmVycmlkZScgbW9kaWZpZXIgY2Fubm90IGFwcGVhciBvbiBhbiBpbmRleCBzaWduYXR1cmUuXCIsXG4gIEluZGV4U2lnbmF0dXJlSGFzU3RhdGljOiBcIkluZGV4IHNpZ25hdHVyZXMgY2Fubm90IGhhdmUgdGhlICdzdGF0aWMnIG1vZGlmaWVyLlwiLFxuICBJbml0aWFsaXplck5vdEFsbG93ZWRJbkFtYmllbnRDb250ZXh0OiBcIkluaXRpYWxpemVycyBhcmUgbm90IGFsbG93ZWQgaW4gYW1iaWVudCBjb250ZXh0cy5cIixcbiAgSW52YWxpZEhlcml0YWdlQ2xhdXNlVHlwZTogKHtcbiAgICB0b2tlblxuICB9KSA9PiBgJyR7dG9rZW59JyBsaXN0IGNhbiBvbmx5IGluY2x1ZGUgaWRlbnRpZmllcnMgb3IgcXVhbGlmaWVkLW5hbWVzIHdpdGggb3B0aW9uYWwgdHlwZSBhcmd1bWVudHMuYCxcbiAgSW52YWxpZE1vZGlmaWVyT25Bd2FpdFVzaW5nRGVjbGFyYXRpb246IG1vZGlmaWVyID0+IGAnJHttb2RpZmllcn0nIG1vZGlmaWVyIGNhbm5vdCBhcHBlYXIgb24gYW4gYXdhaXQgdXNpbmcgZGVjbGFyYXRpb24uYCxcbiAgSW52YWxpZE1vZGlmaWVyT25UeXBlTWVtYmVyOiAoe1xuICAgIG1vZGlmaWVyXG4gIH0pID0+IGAnJHttb2RpZmllcn0nIG1vZGlmaWVyIGNhbm5vdCBhcHBlYXIgb24gYSB0eXBlIG1lbWJlci5gLFxuICBJbnZhbGlkTW9kaWZpZXJPblR5cGVQYXJhbWV0ZXI6ICh7XG4gICAgbW9kaWZpZXJcbiAgfSkgPT4gYCcke21vZGlmaWVyfScgbW9kaWZpZXIgY2Fubm90IGFwcGVhciBvbiBhIHR5cGUgcGFyYW1ldGVyLmAsXG4gIEludmFsaWRNb2RpZmllck9uVHlwZVBhcmFtZXRlclBvc2l0aW9uczogKHtcbiAgICBtb2RpZmllclxuICB9KSA9PiBgJyR7bW9kaWZpZXJ9JyBtb2RpZmllciBjYW4gb25seSBhcHBlYXIgb24gYSB0eXBlIHBhcmFtZXRlciBvZiBhIGNsYXNzLCBpbnRlcmZhY2Ugb3IgdHlwZSBhbGlhcy5gLFxuICBJbnZhbGlkTW9kaWZpZXJPblVzaW5nRGVjbGFyYXRpb246IG1vZGlmaWVyID0+IGAnJHttb2RpZmllcn0nIG1vZGlmaWVyIGNhbm5vdCBhcHBlYXIgb24gYSB1c2luZyBkZWNsYXJhdGlvbi5gLFxuICBJbnZhbGlkTW9kaWZpZXJzT3JkZXI6ICh7XG4gICAgb3JkZXJlZE1vZGlmaWVyc1xuICB9KSA9PiBgJyR7b3JkZXJlZE1vZGlmaWVyc1swXX0nIG1vZGlmaWVyIG11c3QgcHJlY2VkZSAnJHtvcmRlcmVkTW9kaWZpZXJzWzFdfScgbW9kaWZpZXIuYCxcbiAgSW52YWxpZFByb3BlcnR5QWNjZXNzQWZ0ZXJJbnN0YW50aWF0aW9uRXhwcmVzc2lvbjogXCJJbnZhbGlkIHByb3BlcnR5IGFjY2VzcyBhZnRlciBhbiBpbnN0YW50aWF0aW9uIGV4cHJlc3Npb24uIFwiICsgXCJZb3UgY2FuIGVpdGhlciB3cmFwIHRoZSBpbnN0YW50aWF0aW9uIGV4cHJlc3Npb24gaW4gcGFyZW50aGVzZXMsIG9yIGRlbGV0ZSB0aGUgdHlwZSBhcmd1bWVudHMuXCIsXG4gIEludmFsaWRUdXBsZU1lbWJlckxhYmVsOiBcIlR1cGxlIG1lbWJlcnMgbXVzdCBiZSBsYWJlbGVkIHdpdGggYSBzaW1wbGUgaWRlbnRpZmllci5cIixcbiAgTWlzc2luZ0ludGVyZmFjZU5hbWU6IFwiJ2ludGVyZmFjZScgZGVjbGFyYXRpb25zIG11c3QgYmUgZm9sbG93ZWQgYnkgYW4gaWRlbnRpZmllci5cIixcbiAgTm9uQWJzdHJhY3RDbGFzc0hhc0Fic3RyYWN0TWV0aG9kOiBcIkFic3RyYWN0IG1ldGhvZHMgY2FuIG9ubHkgYXBwZWFyIHdpdGhpbiBhbiBhYnN0cmFjdCBjbGFzcy5cIixcbiAgTm9uQ2xhc3NNZXRob2RQcm9wZXJ0eUhhc0Fic3RyYWN0TW9kaWZpZXI6IFwiJ2Fic3RyYWN0JyBtb2RpZmllciBjYW4gb25seSBhcHBlYXIgb24gYSBjbGFzcywgbWV0aG9kLCBvciBwcm9wZXJ0eSBkZWNsYXJhdGlvbi5cIixcbiAgT3B0aW9uYWxUeXBlQmVmb3JlUmVxdWlyZWQ6IFwiQSByZXF1aXJlZCBlbGVtZW50IGNhbm5vdCBmb2xsb3cgYW4gb3B0aW9uYWwgZWxlbWVudC5cIixcbiAgT3ZlcnJpZGVOb3RJblN1YkNsYXNzOiBcIlRoaXMgbWVtYmVyIGNhbm5vdCBoYXZlIGFuICdvdmVycmlkZScgbW9kaWZpZXIgYmVjYXVzZSBpdHMgY29udGFpbmluZyBjbGFzcyBkb2VzIG5vdCBleHRlbmQgYW5vdGhlciBjbGFzcy5cIixcbiAgUGF0dGVybklzT3B0aW9uYWw6IFwiQSBiaW5kaW5nIHBhdHRlcm4gcGFyYW1ldGVyIGNhbm5vdCBiZSBvcHRpb25hbCBpbiBhbiBpbXBsZW1lbnRhdGlvbiBzaWduYXR1cmUuXCIsXG4gIFByaXZhdGVFbGVtZW50SGFzQWJzdHJhY3Q6IFwiUHJpdmF0ZSBlbGVtZW50cyBjYW5ub3QgaGF2ZSB0aGUgJ2Fic3RyYWN0JyBtb2RpZmllci5cIixcbiAgUHJpdmF0ZUVsZW1lbnRIYXNBY2Nlc3NpYmlsaXR5OiAoe1xuICAgIG1vZGlmaWVyXG4gIH0pID0+IGBQcml2YXRlIGVsZW1lbnRzIGNhbm5vdCBoYXZlIGFuIGFjY2Vzc2liaWxpdHkgbW9kaWZpZXIgKCcke21vZGlmaWVyfScpLmAsXG4gIFJlYWRvbmx5Rm9yTWV0aG9kU2lnbmF0dXJlOiBcIidyZWFkb25seScgbW9kaWZpZXIgY2FuIG9ubHkgYXBwZWFyIG9uIGEgcHJvcGVydHkgZGVjbGFyYXRpb24gb3IgaW5kZXggc2lnbmF0dXJlLlwiLFxuICBSZXNlcnZlZEFycm93VHlwZVBhcmFtOiBcIlRoaXMgc3ludGF4IGlzIHJlc2VydmVkIGluIGZpbGVzIHdpdGggdGhlIC5tdHMgb3IgLmN0cyBleHRlbnNpb24uIEFkZCBhIHRyYWlsaW5nIGNvbW1hLCBhcyBpbiBgPFQsPigpID0+IC4uLmAuXCIsXG4gIFJlc2VydmVkVHlwZUFzc2VydGlvbjogXCJUaGlzIHN5bnRheCBpcyByZXNlcnZlZCBpbiBmaWxlcyB3aXRoIHRoZSAubXRzIG9yIC5jdHMgZXh0ZW5zaW9uLiBVc2UgYW4gYGFzYCBleHByZXNzaW9uIGluc3RlYWQuXCIsXG4gIFNldEFjY2Vzc29yQ2Fubm90SGF2ZU9wdGlvbmFsUGFyYW1ldGVyOiBcIkEgJ3NldCcgYWNjZXNzb3IgY2Fubm90IGhhdmUgYW4gb3B0aW9uYWwgcGFyYW1ldGVyLlwiLFxuICBTZXRBY2Nlc3NvckNhbm5vdEhhdmVSZXN0UGFyYW1ldGVyOiBcIkEgJ3NldCcgYWNjZXNzb3IgY2Fubm90IGhhdmUgcmVzdCBwYXJhbWV0ZXIuXCIsXG4gIFNldEFjY2Vzc29yQ2Fubm90SGF2ZVJldHVyblR5cGU6IFwiQSAnc2V0JyBhY2Nlc3NvciBjYW5ub3QgaGF2ZSBhIHJldHVybiB0eXBlIGFubm90YXRpb24uXCIsXG4gIFNpbmdsZVR5cGVQYXJhbWV0ZXJXaXRob3V0VHJhaWxpbmdDb21tYTogKHtcbiAgICB0eXBlUGFyYW1ldGVyTmFtZVxuICB9KSA9PiBgU2luZ2xlIHR5cGUgcGFyYW1ldGVyICR7dHlwZVBhcmFtZXRlck5hbWV9IHNob3VsZCBoYXZlIGEgdHJhaWxpbmcgY29tbWEuIEV4YW1wbGUgdXNhZ2U6IDwke3R5cGVQYXJhbWV0ZXJOYW1lfSw+LmAsXG4gIFN0YXRpY0Jsb2NrQ2Fubm90SGF2ZU1vZGlmaWVyOiBcIlN0YXRpYyBjbGFzcyBibG9ja3MgY2Fubm90IGhhdmUgYW55IG1vZGlmaWVyLlwiLFxuICBUdXBsZU9wdGlvbmFsQWZ0ZXJUeXBlOiBcIkEgbGFiZWxlZCB0dXBsZSBvcHRpb25hbCBlbGVtZW50IG11c3QgYmUgZGVjbGFyZWQgdXNpbmcgYSBxdWVzdGlvbiBtYXJrIGFmdGVyIHRoZSBuYW1lIGFuZCBiZWZvcmUgdGhlIGNvbG9uIChgbmFtZT86IHR5cGVgKSwgcmF0aGVyIHRoYW4gYWZ0ZXIgdGhlIHR5cGUgKGBuYW1lOiB0eXBlP2ApLlwiLFxuICBUeXBlQW5ub3RhdGlvbkFmdGVyQXNzaWduOiBcIlR5cGUgYW5ub3RhdGlvbnMgbXVzdCBjb21lIGJlZm9yZSBkZWZhdWx0IGFzc2lnbm1lbnRzLCBlLmcuIGluc3RlYWQgb2YgYGFnZSA9IDI1OiBudW1iZXJgIHVzZSBgYWdlOiBudW1iZXIgPSAyNWAuXCIsXG4gIFR5cGVJbXBvcnRDYW5ub3RTcGVjaWZ5RGVmYXVsdEFuZE5hbWVkOiBcIkEgdHlwZS1vbmx5IGltcG9ydCBjYW4gc3BlY2lmeSBhIGRlZmF1bHQgaW1wb3J0IG9yIG5hbWVkIGJpbmRpbmdzLCBidXQgbm90IGJvdGguXCIsXG4gIFR5cGVNb2RpZmllcklzVXNlZEluVHlwZUV4cG9ydHM6IFwiVGhlICd0eXBlJyBtb2RpZmllciBjYW5ub3QgYmUgdXNlZCBvbiBhIG5hbWVkIGV4cG9ydCB3aGVuICdleHBvcnQgdHlwZScgaXMgdXNlZCBvbiBpdHMgZXhwb3J0IHN0YXRlbWVudC5cIixcbiAgVHlwZU1vZGlmaWVySXNVc2VkSW5UeXBlSW1wb3J0czogXCJUaGUgJ3R5cGUnIG1vZGlmaWVyIGNhbm5vdCBiZSB1c2VkIG9uIGEgbmFtZWQgaW1wb3J0IHdoZW4gJ2ltcG9ydCB0eXBlJyBpcyB1c2VkIG9uIGl0cyBpbXBvcnQgc3RhdGVtZW50LlwiLFxuICBVbmV4cGVjdGVkUGFyYW1ldGVyTW9kaWZpZXI6IFwiQSBwYXJhbWV0ZXIgcHJvcGVydHkgaXMgb25seSBhbGxvd2VkIGluIGEgY29uc3RydWN0b3IgaW1wbGVtZW50YXRpb24uXCIsXG4gIFVuZXhwZWN0ZWRSZWFkb25seTogXCIncmVhZG9ubHknIHR5cGUgbW9kaWZpZXIgaXMgb25seSBwZXJtaXR0ZWQgb24gYXJyYXkgYW5kIHR1cGxlIGxpdGVyYWwgdHlwZXMuXCIsXG4gIFVuZXhwZWN0ZWRUeXBlQW5ub3RhdGlvbjogXCJEaWQgbm90IGV4cGVjdCBhIHR5cGUgYW5ub3RhdGlvbiBoZXJlLlwiLFxuICBVbmV4cGVjdGVkVHlwZUNhc3RJblBhcmFtZXRlcjogXCJVbmV4cGVjdGVkIHR5cGUgY2FzdCBpbiBwYXJhbWV0ZXIgcG9zaXRpb24uXCIsXG4gIFVuc3VwcG9ydGVkSW1wb3J0VHlwZUFyZ3VtZW50OiBcIkFyZ3VtZW50IGluIGEgdHlwZSBpbXBvcnQgbXVzdCBiZSBhIHN0cmluZyBsaXRlcmFsLlwiLFxuICBVbnN1cHBvcnRlZFBhcmFtZXRlclByb3BlcnR5S2luZDogXCJBIHBhcmFtZXRlciBwcm9wZXJ0eSBtYXkgbm90IGJlIGRlY2xhcmVkIHVzaW5nIGEgYmluZGluZyBwYXR0ZXJuLlwiLFxuICBVbnN1cHBvcnRlZFNpZ25hdHVyZVBhcmFtZXRlcktpbmQ6ICh7XG4gICAgdHlwZVxuICB9KSA9PiBgTmFtZSBpbiBhIHNpZ25hdHVyZSBtdXN0IGJlIGFuIElkZW50aWZpZXIsIE9iamVjdFBhdHRlcm4gb3IgQXJyYXlQYXR0ZXJuLCBpbnN0ZWFkIGdvdCAke3R5cGV9LmAsXG4gIFVzaW5nRGVjbGFyYXRpb25JbkFtYmllbnRDb250ZXh0OiBraW5kID0+IGAnJHtraW5kfScgZGVjbGFyYXRpb25zIGFyZSBub3QgYWxsb3dlZCBpbiBhbWJpZW50IGNvbnRleHRzLmBcbn0pO1xuZnVuY3Rpb24ga2V5d29yZFR5cGVGcm9tTmFtZSh2YWx1ZSkge1xuICBzd2l0Y2ggKHZhbHVlKSB7XG4gICAgY2FzZSBcImFueVwiOlxuICAgICAgcmV0dXJuIFwiVFNBbnlLZXl3b3JkXCI7XG4gICAgY2FzZSBcImJvb2xlYW5cIjpcbiAgICAgIHJldHVybiBcIlRTQm9vbGVhbktleXdvcmRcIjtcbiAgICBjYXNlIFwiYmlnaW50XCI6XG4gICAgICByZXR1cm4gXCJUU0JpZ0ludEtleXdvcmRcIjtcbiAgICBjYXNlIFwibmV2ZXJcIjpcbiAgICAgIHJldHVybiBcIlRTTmV2ZXJLZXl3b3JkXCI7XG4gICAgY2FzZSBcIm51bWJlclwiOlxuICAgICAgcmV0dXJuIFwiVFNOdW1iZXJLZXl3b3JkXCI7XG4gICAgY2FzZSBcIm9iamVjdFwiOlxuICAgICAgcmV0dXJuIFwiVFNPYmplY3RLZXl3b3JkXCI7XG4gICAgY2FzZSBcInN0cmluZ1wiOlxuICAgICAgcmV0dXJuIFwiVFNTdHJpbmdLZXl3b3JkXCI7XG4gICAgY2FzZSBcInN5bWJvbFwiOlxuICAgICAgcmV0dXJuIFwiVFNTeW1ib2xLZXl3b3JkXCI7XG4gICAgY2FzZSBcInVuZGVmaW5lZFwiOlxuICAgICAgcmV0dXJuIFwiVFNVbmRlZmluZWRLZXl3b3JkXCI7XG4gICAgY2FzZSBcInVua25vd25cIjpcbiAgICAgIHJldHVybiBcIlRTVW5rbm93bktleXdvcmRcIjtcbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgfVxufVxuZnVuY3Rpb24gdHNJc0FjY2Vzc01vZGlmaWVyKG1vZGlmaWVyKSB7XG4gIHJldHVybiBtb2RpZmllciA9PT0gXCJwcml2YXRlXCIgfHwgbW9kaWZpZXIgPT09IFwicHVibGljXCIgfHwgbW9kaWZpZXIgPT09IFwicHJvdGVjdGVkXCI7XG59XG5mdW5jdGlvbiB0c0lzVmFyaWFuY2VBbm5vdGF0aW9ucyhtb2RpZmllcikge1xuICByZXR1cm4gbW9kaWZpZXIgPT09IFwiaW5cIiB8fCBtb2RpZmllciA9PT0gXCJvdXRcIjtcbn1cbnZhciB0eXBlc2NyaXB0ID0gc3VwZXJDbGFzcyA9PiBjbGFzcyBUeXBlU2NyaXB0UGFyc2VyTWl4aW4gZXh0ZW5kcyBzdXBlckNsYXNzIHtcbiAgY29uc3RydWN0b3IoLi4uYXJncykge1xuICAgIHN1cGVyKC4uLmFyZ3MpO1xuICAgIHRoaXMudHNQYXJzZUluT3V0TW9kaWZpZXJzID0gdGhpcy50c1BhcnNlTW9kaWZpZXJzLmJpbmQodGhpcywge1xuICAgICAgYWxsb3dlZE1vZGlmaWVyczogW1wiaW5cIiwgXCJvdXRcIl0sXG4gICAgICBkaXNhbGxvd2VkTW9kaWZpZXJzOiBbXCJjb25zdFwiLCBcInB1YmxpY1wiLCBcInByaXZhdGVcIiwgXCJwcm90ZWN0ZWRcIiwgXCJyZWFkb25seVwiLCBcImRlY2xhcmVcIiwgXCJhYnN0cmFjdFwiLCBcIm92ZXJyaWRlXCJdLFxuICAgICAgZXJyb3JUZW1wbGF0ZTogVFNFcnJvcnMuSW52YWxpZE1vZGlmaWVyT25UeXBlUGFyYW1ldGVyXG4gICAgfSk7XG4gICAgdGhpcy50c1BhcnNlQ29uc3RNb2RpZmllciA9IHRoaXMudHNQYXJzZU1vZGlmaWVycy5iaW5kKHRoaXMsIHtcbiAgICAgIGFsbG93ZWRNb2RpZmllcnM6IFtcImNvbnN0XCJdLFxuICAgICAgZGlzYWxsb3dlZE1vZGlmaWVyczogW1wiaW5cIiwgXCJvdXRcIl0sXG4gICAgICBlcnJvclRlbXBsYXRlOiBUU0Vycm9ycy5JbnZhbGlkTW9kaWZpZXJPblR5cGVQYXJhbWV0ZXJQb3NpdGlvbnNcbiAgICB9KTtcbiAgICB0aGlzLnRzUGFyc2VJbk91dENvbnN0TW9kaWZpZXJzID0gdGhpcy50c1BhcnNlTW9kaWZpZXJzLmJpbmQodGhpcywge1xuICAgICAgYWxsb3dlZE1vZGlmaWVyczogW1wiaW5cIiwgXCJvdXRcIiwgXCJjb25zdFwiXSxcbiAgICAgIGRpc2FsbG93ZWRNb2RpZmllcnM6IFtcInB1YmxpY1wiLCBcInByaXZhdGVcIiwgXCJwcm90ZWN0ZWRcIiwgXCJyZWFkb25seVwiLCBcImRlY2xhcmVcIiwgXCJhYnN0cmFjdFwiLCBcIm92ZXJyaWRlXCJdLFxuICAgICAgZXJyb3JUZW1wbGF0ZTogVFNFcnJvcnMuSW52YWxpZE1vZGlmaWVyT25UeXBlUGFyYW1ldGVyXG4gICAgfSk7XG4gIH1cbiAgZ2V0U2NvcGVIYW5kbGVyKCkge1xuICAgIHJldHVybiBUeXBlU2NyaXB0U2NvcGVIYW5kbGVyO1xuICB9XG4gIHRzSXNJZGVudGlmaWVyKCkge1xuICAgIHJldHVybiB0b2tlbklzSWRlbnRpZmllcih0aGlzLnN0YXRlLnR5cGUpO1xuICB9XG4gIHRzVG9rZW5DYW5Gb2xsb3dNb2RpZmllcigpIHtcbiAgICByZXR1cm4gdGhpcy5tYXRjaCgwKSB8fCB0aGlzLm1hdGNoKDUpIHx8IHRoaXMubWF0Y2goNTUpIHx8IHRoaXMubWF0Y2goMjEpIHx8IHRoaXMubWF0Y2goMTM5KSB8fCB0aGlzLmlzTGl0ZXJhbFByb3BlcnR5TmFtZSgpO1xuICB9XG4gIHRzTmV4dFRva2VuT25TYW1lTGluZUFuZENhbkZvbGxvd01vZGlmaWVyKCkge1xuICAgIHRoaXMubmV4dCgpO1xuICAgIGlmICh0aGlzLmhhc1ByZWNlZGluZ0xpbmVCcmVhaygpKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLnRzVG9rZW5DYW5Gb2xsb3dNb2RpZmllcigpO1xuICB9XG4gIHRzTmV4dFRva2VuQ2FuRm9sbG93TW9kaWZpZXIoKSB7XG4gICAgaWYgKHRoaXMubWF0Y2goMTA2KSkge1xuICAgICAgdGhpcy5uZXh0KCk7XG4gICAgICByZXR1cm4gdGhpcy50c1Rva2VuQ2FuRm9sbG93TW9kaWZpZXIoKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMudHNOZXh0VG9rZW5PblNhbWVMaW5lQW5kQ2FuRm9sbG93TW9kaWZpZXIoKTtcbiAgfVxuICB0c1BhcnNlTW9kaWZpZXIoYWxsb3dlZE1vZGlmaWVycywgc3RvcE9uU3RhcnRPZkNsYXNzU3RhdGljQmxvY2ssIGhhc1NlZW5TdGF0aWNNb2RpZmllcikge1xuICAgIGlmICghdG9rZW5Jc0lkZW50aWZpZXIodGhpcy5zdGF0ZS50eXBlKSAmJiB0aGlzLnN0YXRlLnR5cGUgIT09IDU4ICYmIHRoaXMuc3RhdGUudHlwZSAhPT0gNzUpIHtcbiAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxuICAgIGNvbnN0IG1vZGlmaWVyID0gdGhpcy5zdGF0ZS52YWx1ZTtcbiAgICBpZiAoYWxsb3dlZE1vZGlmaWVycy5pbmNsdWRlcyhtb2RpZmllcikpIHtcbiAgICAgIGlmIChoYXNTZWVuU3RhdGljTW9kaWZpZXIgJiYgdGhpcy5tYXRjaCgxMDYpKSB7XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICB9XG4gICAgICBpZiAoc3RvcE9uU3RhcnRPZkNsYXNzU3RhdGljQmxvY2sgJiYgdGhpcy50c0lzU3RhcnRPZlN0YXRpY0Jsb2NrcygpKSB7XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICB9XG4gICAgICBpZiAodGhpcy50c1RyeVBhcnNlKHRoaXMudHNOZXh0VG9rZW5DYW5Gb2xsb3dNb2RpZmllci5iaW5kKHRoaXMpKSkge1xuICAgICAgICByZXR1cm4gbW9kaWZpZXI7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB1bmRlZmluZWQ7XG4gIH1cbiAgdHNQYXJzZU1vZGlmaWVycyh7XG4gICAgYWxsb3dlZE1vZGlmaWVycyxcbiAgICBkaXNhbGxvd2VkTW9kaWZpZXJzLFxuICAgIHN0b3BPblN0YXJ0T2ZDbGFzc1N0YXRpY0Jsb2NrLFxuICAgIGVycm9yVGVtcGxhdGUgPSBUU0Vycm9ycy5JbnZhbGlkTW9kaWZpZXJPblR5cGVNZW1iZXJcbiAgfSwgbW9kaWZpZWQpIHtcbiAgICBjb25zdCBlbmZvcmNlT3JkZXIgPSAobG9jLCBtb2RpZmllciwgYmVmb3JlLCBhZnRlcikgPT4ge1xuICAgICAgaWYgKG1vZGlmaWVyID09PSBiZWZvcmUgJiYgbW9kaWZpZWRbYWZ0ZXJdKSB7XG4gICAgICAgIHRoaXMucmFpc2UoVFNFcnJvcnMuSW52YWxpZE1vZGlmaWVyc09yZGVyLCBsb2MsIHtcbiAgICAgICAgICBvcmRlcmVkTW9kaWZpZXJzOiBbYmVmb3JlLCBhZnRlcl1cbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfTtcbiAgICBjb25zdCBpbmNvbXBhdGlibGUgPSAobG9jLCBtb2RpZmllciwgbW9kMSwgbW9kMikgPT4ge1xuICAgICAgaWYgKG1vZGlmaWVkW21vZDFdICYmIG1vZGlmaWVyID09PSBtb2QyIHx8IG1vZGlmaWVkW21vZDJdICYmIG1vZGlmaWVyID09PSBtb2QxKSB7XG4gICAgICAgIHRoaXMucmFpc2UoVFNFcnJvcnMuSW5jb21wYXRpYmxlTW9kaWZpZXJzLCBsb2MsIHtcbiAgICAgICAgICBtb2RpZmllcnM6IFttb2QxLCBtb2QyXVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9O1xuICAgIGZvciAoOzspIHtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgc3RhcnRMb2NcbiAgICAgIH0gPSB0aGlzLnN0YXRlO1xuICAgICAgY29uc3QgbW9kaWZpZXIgPSB0aGlzLnRzUGFyc2VNb2RpZmllcihhbGxvd2VkTW9kaWZpZXJzLmNvbmNhdChkaXNhbGxvd2VkTW9kaWZpZXJzICE9IG51bGwgPyBkaXNhbGxvd2VkTW9kaWZpZXJzIDogW10pLCBzdG9wT25TdGFydE9mQ2xhc3NTdGF0aWNCbG9jaywgbW9kaWZpZWQuc3RhdGljKTtcbiAgICAgIGlmICghbW9kaWZpZXIpIGJyZWFrO1xuICAgICAgaWYgKHRzSXNBY2Nlc3NNb2RpZmllcihtb2RpZmllcikpIHtcbiAgICAgICAgaWYgKG1vZGlmaWVkLmFjY2Vzc2liaWxpdHkpIHtcbiAgICAgICAgICB0aGlzLnJhaXNlKFRTRXJyb3JzLkR1cGxpY2F0ZUFjY2Vzc2liaWxpdHlNb2RpZmllciwgc3RhcnRMb2MsIHtcbiAgICAgICAgICAgIG1vZGlmaWVyXG4gICAgICAgICAgfSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZW5mb3JjZU9yZGVyKHN0YXJ0TG9jLCBtb2RpZmllciwgbW9kaWZpZXIsIFwib3ZlcnJpZGVcIik7XG4gICAgICAgICAgZW5mb3JjZU9yZGVyKHN0YXJ0TG9jLCBtb2RpZmllciwgbW9kaWZpZXIsIFwic3RhdGljXCIpO1xuICAgICAgICAgIGVuZm9yY2VPcmRlcihzdGFydExvYywgbW9kaWZpZXIsIG1vZGlmaWVyLCBcInJlYWRvbmx5XCIpO1xuICAgICAgICAgIG1vZGlmaWVkLmFjY2Vzc2liaWxpdHkgPSBtb2RpZmllcjtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmICh0c0lzVmFyaWFuY2VBbm5vdGF0aW9ucyhtb2RpZmllcikpIHtcbiAgICAgICAgaWYgKG1vZGlmaWVkW21vZGlmaWVyXSkge1xuICAgICAgICAgIHRoaXMucmFpc2UoVFNFcnJvcnMuRHVwbGljYXRlTW9kaWZpZXIsIHN0YXJ0TG9jLCB7XG4gICAgICAgICAgICBtb2RpZmllclxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIG1vZGlmaWVkW21vZGlmaWVyXSA9IHRydWU7XG4gICAgICAgIGVuZm9yY2VPcmRlcihzdGFydExvYywgbW9kaWZpZXIsIFwiaW5cIiwgXCJvdXRcIik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoaGFzT3duUHJvcGVydHkuY2FsbChtb2RpZmllZCwgbW9kaWZpZXIpKSB7XG4gICAgICAgICAgdGhpcy5yYWlzZShUU0Vycm9ycy5EdXBsaWNhdGVNb2RpZmllciwgc3RhcnRMb2MsIHtcbiAgICAgICAgICAgIG1vZGlmaWVyXG4gICAgICAgICAgfSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZW5mb3JjZU9yZGVyKHN0YXJ0TG9jLCBtb2RpZmllciwgXCJzdGF0aWNcIiwgXCJyZWFkb25seVwiKTtcbiAgICAgICAgICBlbmZvcmNlT3JkZXIoc3RhcnRMb2MsIG1vZGlmaWVyLCBcInN0YXRpY1wiLCBcIm92ZXJyaWRlXCIpO1xuICAgICAgICAgIGVuZm9yY2VPcmRlcihzdGFydExvYywgbW9kaWZpZXIsIFwib3ZlcnJpZGVcIiwgXCJyZWFkb25seVwiKTtcbiAgICAgICAgICBlbmZvcmNlT3JkZXIoc3RhcnRMb2MsIG1vZGlmaWVyLCBcImFic3RyYWN0XCIsIFwib3ZlcnJpZGVcIik7XG4gICAgICAgICAgaW5jb21wYXRpYmxlKHN0YXJ0TG9jLCBtb2RpZmllciwgXCJkZWNsYXJlXCIsIFwib3ZlcnJpZGVcIik7XG4gICAgICAgICAgaW5jb21wYXRpYmxlKHN0YXJ0TG9jLCBtb2RpZmllciwgXCJzdGF0aWNcIiwgXCJhYnN0cmFjdFwiKTtcbiAgICAgICAgfVxuICAgICAgICBtb2RpZmllZFttb2RpZmllcl0gPSB0cnVlO1xuICAgICAgfVxuICAgICAgaWYgKGRpc2FsbG93ZWRNb2RpZmllcnMgIT0gbnVsbCAmJiBkaXNhbGxvd2VkTW9kaWZpZXJzLmluY2x1ZGVzKG1vZGlmaWVyKSkge1xuICAgICAgICB0aGlzLnJhaXNlKGVycm9yVGVtcGxhdGUsIHN0YXJ0TG9jLCB7XG4gICAgICAgICAgbW9kaWZpZXJcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHRzSXNMaXN0VGVybWluYXRvcihraW5kKSB7XG4gICAgc3dpdGNoIChraW5kKSB7XG4gICAgICBjYXNlIFwiRW51bU1lbWJlcnNcIjpcbiAgICAgIGNhc2UgXCJUeXBlTWVtYmVyc1wiOlxuICAgICAgICByZXR1cm4gdGhpcy5tYXRjaCg4KTtcbiAgICAgIGNhc2UgXCJIZXJpdGFnZUNsYXVzZUVsZW1lbnRcIjpcbiAgICAgICAgcmV0dXJuIHRoaXMubWF0Y2goNSk7XG4gICAgICBjYXNlIFwiVHVwbGVFbGVtZW50VHlwZXNcIjpcbiAgICAgICAgcmV0dXJuIHRoaXMubWF0Y2goMyk7XG4gICAgICBjYXNlIFwiVHlwZVBhcmFtZXRlcnNPckFyZ3VtZW50c1wiOlxuICAgICAgICByZXR1cm4gdGhpcy5tYXRjaCg0OCk7XG4gICAgfVxuICB9XG4gIHRzUGFyc2VMaXN0KGtpbmQsIHBhcnNlRWxlbWVudCkge1xuICAgIGNvbnN0IHJlc3VsdCA9IFtdO1xuICAgIHdoaWxlICghdGhpcy50c0lzTGlzdFRlcm1pbmF0b3Ioa2luZCkpIHtcbiAgICAgIHJlc3VsdC5wdXNoKHBhcnNlRWxlbWVudCgpKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuICB0c1BhcnNlRGVsaW1pdGVkTGlzdChraW5kLCBwYXJzZUVsZW1lbnQsIHJlZlRyYWlsaW5nQ29tbWFQb3MpIHtcbiAgICByZXR1cm4gbm9uTnVsbCh0aGlzLnRzUGFyc2VEZWxpbWl0ZWRMaXN0V29ya2VyKGtpbmQsIHBhcnNlRWxlbWVudCwgdHJ1ZSwgcmVmVHJhaWxpbmdDb21tYVBvcykpO1xuICB9XG4gIHRzUGFyc2VEZWxpbWl0ZWRMaXN0V29ya2VyKGtpbmQsIHBhcnNlRWxlbWVudCwgZXhwZWN0U3VjY2VzcywgcmVmVHJhaWxpbmdDb21tYVBvcykge1xuICAgIGNvbnN0IHJlc3VsdCA9IFtdO1xuICAgIGxldCB0cmFpbGluZ0NvbW1hUG9zID0gLTE7XG4gICAgZm9yICg7Oykge1xuICAgICAgaWYgKHRoaXMudHNJc0xpc3RUZXJtaW5hdG9yKGtpbmQpKSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgdHJhaWxpbmdDb21tYVBvcyA9IC0xO1xuICAgICAgY29uc3QgZWxlbWVudCA9IHBhcnNlRWxlbWVudCgpO1xuICAgICAgaWYgKGVsZW1lbnQgPT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgfVxuICAgICAgcmVzdWx0LnB1c2goZWxlbWVudCk7XG4gICAgICBpZiAodGhpcy5lYXQoMTIpKSB7XG4gICAgICAgIHRyYWlsaW5nQ29tbWFQb3MgPSB0aGlzLnN0YXRlLmxhc3RUb2tTdGFydExvYy5pbmRleDtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBpZiAodGhpcy50c0lzTGlzdFRlcm1pbmF0b3Ioa2luZCkpIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBpZiAoZXhwZWN0U3VjY2Vzcykge1xuICAgICAgICB0aGlzLmV4cGVjdCgxMik7XG4gICAgICB9XG4gICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cbiAgICBpZiAocmVmVHJhaWxpbmdDb21tYVBvcykge1xuICAgICAgcmVmVHJhaWxpbmdDb21tYVBvcy52YWx1ZSA9IHRyYWlsaW5nQ29tbWFQb3M7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cbiAgdHNQYXJzZUJyYWNrZXRlZExpc3Qoa2luZCwgcGFyc2VFbGVtZW50LCBicmFja2V0LCBza2lwRmlyc3RUb2tlbiwgcmVmVHJhaWxpbmdDb21tYVBvcykge1xuICAgIGlmICghc2tpcEZpcnN0VG9rZW4pIHtcbiAgICAgIGlmIChicmFja2V0KSB7XG4gICAgICAgIHRoaXMuZXhwZWN0KDApO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5leHBlY3QoNDcpO1xuICAgICAgfVxuICAgIH1cbiAgICBjb25zdCByZXN1bHQgPSB0aGlzLnRzUGFyc2VEZWxpbWl0ZWRMaXN0KGtpbmQsIHBhcnNlRWxlbWVudCwgcmVmVHJhaWxpbmdDb21tYVBvcyk7XG4gICAgaWYgKGJyYWNrZXQpIHtcbiAgICAgIHRoaXMuZXhwZWN0KDMpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmV4cGVjdCg0OCk7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cbiAgdHNQYXJzZUltcG9ydFR5cGUoKSB7XG4gICAgY29uc3Qgbm9kZSA9IHRoaXMuc3RhcnROb2RlKCk7XG4gICAgdGhpcy5leHBlY3QoODMpO1xuICAgIHRoaXMuZXhwZWN0KDEwKTtcbiAgICBpZiAoIXRoaXMubWF0Y2goMTM0KSkge1xuICAgICAgdGhpcy5yYWlzZShUU0Vycm9ycy5VbnN1cHBvcnRlZEltcG9ydFR5cGVBcmd1bWVudCwgdGhpcy5zdGF0ZS5zdGFydExvYyk7XG4gICAgICBub2RlLmFyZ3VtZW50ID0gc3VwZXIucGFyc2VFeHByQXRvbSgpO1xuICAgIH0gZWxzZSB7XG4gICAgICBub2RlLmFyZ3VtZW50ID0gdGhpcy5wYXJzZVN0cmluZ0xpdGVyYWwodGhpcy5zdGF0ZS52YWx1ZSk7XG4gICAgfVxuICAgIGlmICh0aGlzLmVhdCgxMikpIHtcbiAgICAgIG5vZGUub3B0aW9ucyA9IHRoaXMudHNQYXJzZUltcG9ydFR5cGVPcHRpb25zKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIG5vZGUub3B0aW9ucyA9IG51bGw7XG4gICAgfVxuICAgIHRoaXMuZXhwZWN0KDExKTtcbiAgICBpZiAodGhpcy5lYXQoMTYpKSB7XG4gICAgICBub2RlLnF1YWxpZmllciA9IHRoaXMudHNQYXJzZUVudGl0eU5hbWUoMSB8IDIpO1xuICAgIH1cbiAgICBpZiAodGhpcy5tYXRjaCg0NykpIHtcbiAgICAgIG5vZGUudHlwZVBhcmFtZXRlcnMgPSB0aGlzLnRzUGFyc2VUeXBlQXJndW1lbnRzKCk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJUU0ltcG9ydFR5cGVcIik7XG4gIH1cbiAgdHNQYXJzZUltcG9ydFR5cGVPcHRpb25zKCkge1xuICAgIGNvbnN0IG5vZGUgPSB0aGlzLnN0YXJ0Tm9kZSgpO1xuICAgIHRoaXMuZXhwZWN0KDUpO1xuICAgIGNvbnN0IHdpdGhQcm9wZXJ0eSA9IHRoaXMuc3RhcnROb2RlKCk7XG4gICAgaWYgKHRoaXMuaXNDb250ZXh0dWFsKDc2KSkge1xuICAgICAgd2l0aFByb3BlcnR5Lm1ldGhvZCA9IGZhbHNlO1xuICAgICAgd2l0aFByb3BlcnR5LmtleSA9IHRoaXMucGFyc2VJZGVudGlmaWVyKHRydWUpO1xuICAgICAgd2l0aFByb3BlcnR5LmNvbXB1dGVkID0gZmFsc2U7XG4gICAgICB3aXRoUHJvcGVydHkuc2hvcnRoYW5kID0gZmFsc2U7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMudW5leHBlY3RlZChudWxsLCA3Nik7XG4gICAgfVxuICAgIHRoaXMuZXhwZWN0KDE0KTtcbiAgICB3aXRoUHJvcGVydHkudmFsdWUgPSB0aGlzLnRzUGFyc2VJbXBvcnRUeXBlV2l0aFByb3BlcnR5VmFsdWUoKTtcbiAgICBub2RlLnByb3BlcnRpZXMgPSBbdGhpcy5maW5pc2hPYmplY3RQcm9wZXJ0eSh3aXRoUHJvcGVydHkpXTtcbiAgICB0aGlzLmVhdCgxMik7XG4gICAgdGhpcy5leHBlY3QoOCk7XG4gICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIk9iamVjdEV4cHJlc3Npb25cIik7XG4gIH1cbiAgdHNQYXJzZUltcG9ydFR5cGVXaXRoUHJvcGVydHlWYWx1ZSgpIHtcbiAgICBjb25zdCBub2RlID0gdGhpcy5zdGFydE5vZGUoKTtcbiAgICBjb25zdCBwcm9wZXJ0aWVzID0gW107XG4gICAgdGhpcy5leHBlY3QoNSk7XG4gICAgd2hpbGUgKCF0aGlzLm1hdGNoKDgpKSB7XG4gICAgICBjb25zdCB0eXBlID0gdGhpcy5zdGF0ZS50eXBlO1xuICAgICAgaWYgKHRva2VuSXNJZGVudGlmaWVyKHR5cGUpIHx8IHR5cGUgPT09IDEzNCkge1xuICAgICAgICBwcm9wZXJ0aWVzLnB1c2goc3VwZXIucGFyc2VQcm9wZXJ0eURlZmluaXRpb24obnVsbCkpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy51bmV4cGVjdGVkKCk7XG4gICAgICB9XG4gICAgICB0aGlzLmVhdCgxMik7XG4gICAgfVxuICAgIG5vZGUucHJvcGVydGllcyA9IHByb3BlcnRpZXM7XG4gICAgdGhpcy5uZXh0KCk7XG4gICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIk9iamVjdEV4cHJlc3Npb25cIik7XG4gIH1cbiAgdHNQYXJzZUVudGl0eU5hbWUoZmxhZ3MpIHtcbiAgICBsZXQgZW50aXR5O1xuICAgIGlmIChmbGFncyAmIDEgJiYgdGhpcy5tYXRjaCg3OCkpIHtcbiAgICAgIGlmIChmbGFncyAmIDIpIHtcbiAgICAgICAgZW50aXR5ID0gdGhpcy5wYXJzZUlkZW50aWZpZXIodHJ1ZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zdCBub2RlID0gdGhpcy5zdGFydE5vZGUoKTtcbiAgICAgICAgdGhpcy5uZXh0KCk7XG4gICAgICAgIGVudGl0eSA9IHRoaXMuZmluaXNoTm9kZShub2RlLCBcIlRoaXNFeHByZXNzaW9uXCIpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBlbnRpdHkgPSB0aGlzLnBhcnNlSWRlbnRpZmllcighIShmbGFncyAmIDEpKTtcbiAgICB9XG4gICAgd2hpbGUgKHRoaXMuZWF0KDE2KSkge1xuICAgICAgY29uc3Qgbm9kZSA9IHRoaXMuc3RhcnROb2RlQXROb2RlKGVudGl0eSk7XG4gICAgICBub2RlLmxlZnQgPSBlbnRpdHk7XG4gICAgICBub2RlLnJpZ2h0ID0gdGhpcy5wYXJzZUlkZW50aWZpZXIoISEoZmxhZ3MgJiAxKSk7XG4gICAgICBlbnRpdHkgPSB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJUU1F1YWxpZmllZE5hbWVcIik7XG4gICAgfVxuICAgIHJldHVybiBlbnRpdHk7XG4gIH1cbiAgdHNQYXJzZVR5cGVSZWZlcmVuY2UoKSB7XG4gICAgY29uc3Qgbm9kZSA9IHRoaXMuc3RhcnROb2RlKCk7XG4gICAgbm9kZS50eXBlTmFtZSA9IHRoaXMudHNQYXJzZUVudGl0eU5hbWUoMSk7XG4gICAgaWYgKCF0aGlzLmhhc1ByZWNlZGluZ0xpbmVCcmVhaygpICYmIHRoaXMubWF0Y2goNDcpKSB7XG4gICAgICBub2RlLnR5cGVQYXJhbWV0ZXJzID0gdGhpcy50c1BhcnNlVHlwZUFyZ3VtZW50cygpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiVFNUeXBlUmVmZXJlbmNlXCIpO1xuICB9XG4gIHRzUGFyc2VUaGlzVHlwZVByZWRpY2F0ZShsaHMpIHtcbiAgICB0aGlzLm5leHQoKTtcbiAgICBjb25zdCBub2RlID0gdGhpcy5zdGFydE5vZGVBdE5vZGUobGhzKTtcbiAgICBub2RlLnBhcmFtZXRlck5hbWUgPSBsaHM7XG4gICAgbm9kZS50eXBlQW5ub3RhdGlvbiA9IHRoaXMudHNQYXJzZVR5cGVBbm5vdGF0aW9uKGZhbHNlKTtcbiAgICBub2RlLmFzc2VydHMgPSBmYWxzZTtcbiAgICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiVFNUeXBlUHJlZGljYXRlXCIpO1xuICB9XG4gIHRzUGFyc2VUaGlzVHlwZU5vZGUoKSB7XG4gICAgY29uc3Qgbm9kZSA9IHRoaXMuc3RhcnROb2RlKCk7XG4gICAgdGhpcy5uZXh0KCk7XG4gICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIlRTVGhpc1R5cGVcIik7XG4gIH1cbiAgdHNQYXJzZVR5cGVRdWVyeSgpIHtcbiAgICBjb25zdCBub2RlID0gdGhpcy5zdGFydE5vZGUoKTtcbiAgICB0aGlzLmV4cGVjdCg4Nyk7XG4gICAgaWYgKHRoaXMubWF0Y2goODMpKSB7XG4gICAgICBub2RlLmV4cHJOYW1lID0gdGhpcy50c1BhcnNlSW1wb3J0VHlwZSgpO1xuICAgIH0gZWxzZSB7XG4gICAgICBub2RlLmV4cHJOYW1lID0gdGhpcy50c1BhcnNlRW50aXR5TmFtZSgxIHwgMik7XG4gICAgfVxuICAgIGlmICghdGhpcy5oYXNQcmVjZWRpbmdMaW5lQnJlYWsoKSAmJiB0aGlzLm1hdGNoKDQ3KSkge1xuICAgICAgbm9kZS50eXBlUGFyYW1ldGVycyA9IHRoaXMudHNQYXJzZVR5cGVBcmd1bWVudHMoKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIlRTVHlwZVF1ZXJ5XCIpO1xuICB9XG4gIHRzUGFyc2VUeXBlUGFyYW1ldGVyKHBhcnNlTW9kaWZpZXJzKSB7XG4gICAgY29uc3Qgbm9kZSA9IHRoaXMuc3RhcnROb2RlKCk7XG4gICAgcGFyc2VNb2RpZmllcnMobm9kZSk7XG4gICAgbm9kZS5uYW1lID0gdGhpcy50c1BhcnNlVHlwZVBhcmFtZXRlck5hbWUoKTtcbiAgICBub2RlLmNvbnN0cmFpbnQgPSB0aGlzLnRzRWF0VGhlblBhcnNlVHlwZSg4MSk7XG4gICAgbm9kZS5kZWZhdWx0ID0gdGhpcy50c0VhdFRoZW5QYXJzZVR5cGUoMjkpO1xuICAgIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJUU1R5cGVQYXJhbWV0ZXJcIik7XG4gIH1cbiAgdHNUcnlQYXJzZVR5cGVQYXJhbWV0ZXJzKHBhcnNlTW9kaWZpZXJzKSB7XG4gICAgaWYgKHRoaXMubWF0Y2goNDcpKSB7XG4gICAgICByZXR1cm4gdGhpcy50c1BhcnNlVHlwZVBhcmFtZXRlcnMocGFyc2VNb2RpZmllcnMpO1xuICAgIH1cbiAgfVxuICB0c1BhcnNlVHlwZVBhcmFtZXRlcnMocGFyc2VNb2RpZmllcnMpIHtcbiAgICBjb25zdCBub2RlID0gdGhpcy5zdGFydE5vZGUoKTtcbiAgICBpZiAodGhpcy5tYXRjaCg0NykgfHwgdGhpcy5tYXRjaCgxNDMpKSB7XG4gICAgICB0aGlzLm5leHQoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy51bmV4cGVjdGVkKCk7XG4gICAgfVxuICAgIGNvbnN0IHJlZlRyYWlsaW5nQ29tbWFQb3MgPSB7XG4gICAgICB2YWx1ZTogLTFcbiAgICB9O1xuICAgIG5vZGUucGFyYW1zID0gdGhpcy50c1BhcnNlQnJhY2tldGVkTGlzdChcIlR5cGVQYXJhbWV0ZXJzT3JBcmd1bWVudHNcIiwgdGhpcy50c1BhcnNlVHlwZVBhcmFtZXRlci5iaW5kKHRoaXMsIHBhcnNlTW9kaWZpZXJzKSwgZmFsc2UsIHRydWUsIHJlZlRyYWlsaW5nQ29tbWFQb3MpO1xuICAgIGlmIChub2RlLnBhcmFtcy5sZW5ndGggPT09IDApIHtcbiAgICAgIHRoaXMucmFpc2UoVFNFcnJvcnMuRW1wdHlUeXBlUGFyYW1ldGVycywgbm9kZSk7XG4gICAgfVxuICAgIGlmIChyZWZUcmFpbGluZ0NvbW1hUG9zLnZhbHVlICE9PSAtMSkge1xuICAgICAgdGhpcy5hZGRFeHRyYShub2RlLCBcInRyYWlsaW5nQ29tbWFcIiwgcmVmVHJhaWxpbmdDb21tYVBvcy52YWx1ZSk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJUU1R5cGVQYXJhbWV0ZXJEZWNsYXJhdGlvblwiKTtcbiAgfVxuICB0c0ZpbGxTaWduYXR1cmUocmV0dXJuVG9rZW4sIHNpZ25hdHVyZSkge1xuICAgIGNvbnN0IHJldHVyblRva2VuUmVxdWlyZWQgPSByZXR1cm5Ub2tlbiA9PT0gMTk7XG4gICAgY29uc3QgcGFyYW1zS2V5ID0gXCJwYXJhbWV0ZXJzXCI7XG4gICAgY29uc3QgcmV0dXJuVHlwZUtleSA9IFwidHlwZUFubm90YXRpb25cIjtcbiAgICBzaWduYXR1cmUudHlwZVBhcmFtZXRlcnMgPSB0aGlzLnRzVHJ5UGFyc2VUeXBlUGFyYW1ldGVycyh0aGlzLnRzUGFyc2VDb25zdE1vZGlmaWVyKTtcbiAgICB0aGlzLmV4cGVjdCgxMCk7XG4gICAgc2lnbmF0dXJlW3BhcmFtc0tleV0gPSB0aGlzLnRzUGFyc2VCaW5kaW5nTGlzdEZvclNpZ25hdHVyZSgpO1xuICAgIGlmIChyZXR1cm5Ub2tlblJlcXVpcmVkKSB7XG4gICAgICBzaWduYXR1cmVbcmV0dXJuVHlwZUtleV0gPSB0aGlzLnRzUGFyc2VUeXBlT3JUeXBlUHJlZGljYXRlQW5ub3RhdGlvbihyZXR1cm5Ub2tlbik7XG4gICAgfSBlbHNlIGlmICh0aGlzLm1hdGNoKHJldHVyblRva2VuKSkge1xuICAgICAgc2lnbmF0dXJlW3JldHVyblR5cGVLZXldID0gdGhpcy50c1BhcnNlVHlwZU9yVHlwZVByZWRpY2F0ZUFubm90YXRpb24ocmV0dXJuVG9rZW4pO1xuICAgIH1cbiAgfVxuICB0c1BhcnNlQmluZGluZ0xpc3RGb3JTaWduYXR1cmUoKSB7XG4gICAgY29uc3QgbGlzdCA9IHN1cGVyLnBhcnNlQmluZGluZ0xpc3QoMTEsIDQxLCAyKTtcbiAgICBmb3IgKGNvbnN0IHBhdHRlcm4gb2YgbGlzdCkge1xuICAgICAgY29uc3Qge1xuICAgICAgICB0eXBlXG4gICAgICB9ID0gcGF0dGVybjtcbiAgICAgIGlmICh0eXBlID09PSBcIkFzc2lnbm1lbnRQYXR0ZXJuXCIgfHwgdHlwZSA9PT0gXCJUU1BhcmFtZXRlclByb3BlcnR5XCIpIHtcbiAgICAgICAgdGhpcy5yYWlzZShUU0Vycm9ycy5VbnN1cHBvcnRlZFNpZ25hdHVyZVBhcmFtZXRlcktpbmQsIHBhdHRlcm4sIHtcbiAgICAgICAgICB0eXBlXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbGlzdDtcbiAgfVxuICB0c1BhcnNlVHlwZU1lbWJlclNlbWljb2xvbigpIHtcbiAgICBpZiAoIXRoaXMuZWF0KDEyKSAmJiAhdGhpcy5pc0xpbmVUZXJtaW5hdG9yKCkpIHtcbiAgICAgIHRoaXMuZXhwZWN0KDEzKTtcbiAgICB9XG4gIH1cbiAgdHNQYXJzZVNpZ25hdHVyZU1lbWJlcihraW5kLCBub2RlKSB7XG4gICAgdGhpcy50c0ZpbGxTaWduYXR1cmUoMTQsIG5vZGUpO1xuICAgIHRoaXMudHNQYXJzZVR5cGVNZW1iZXJTZW1pY29sb24oKTtcbiAgICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIGtpbmQpO1xuICB9XG4gIHRzSXNVbmFtYmlndW91c2x5SW5kZXhTaWduYXR1cmUoKSB7XG4gICAgdGhpcy5uZXh0KCk7XG4gICAgaWYgKHRva2VuSXNJZGVudGlmaWVyKHRoaXMuc3RhdGUudHlwZSkpIHtcbiAgICAgIHRoaXMubmV4dCgpO1xuICAgICAgcmV0dXJuIHRoaXMubWF0Y2goMTQpO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgdHNUcnlQYXJzZUluZGV4U2lnbmF0dXJlKG5vZGUpIHtcbiAgICBpZiAoISh0aGlzLm1hdGNoKDApICYmIHRoaXMudHNMb29rQWhlYWQodGhpcy50c0lzVW5hbWJpZ3VvdXNseUluZGV4U2lnbmF0dXJlLmJpbmQodGhpcykpKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLmV4cGVjdCgwKTtcbiAgICBjb25zdCBpZCA9IHRoaXMucGFyc2VJZGVudGlmaWVyKCk7XG4gICAgaWQudHlwZUFubm90YXRpb24gPSB0aGlzLnRzUGFyc2VUeXBlQW5ub3RhdGlvbigpO1xuICAgIHRoaXMucmVzZXRFbmRMb2NhdGlvbihpZCk7XG4gICAgdGhpcy5leHBlY3QoMyk7XG4gICAgbm9kZS5wYXJhbWV0ZXJzID0gW2lkXTtcbiAgICBjb25zdCB0eXBlID0gdGhpcy50c1RyeVBhcnNlVHlwZUFubm90YXRpb24oKTtcbiAgICBpZiAodHlwZSkgbm9kZS50eXBlQW5ub3RhdGlvbiA9IHR5cGU7XG4gICAgdGhpcy50c1BhcnNlVHlwZU1lbWJlclNlbWljb2xvbigpO1xuICAgIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJUU0luZGV4U2lnbmF0dXJlXCIpO1xuICB9XG4gIHRzUGFyc2VQcm9wZXJ0eU9yTWV0aG9kU2lnbmF0dXJlKG5vZGUsIHJlYWRvbmx5KSB7XG4gICAgaWYgKHRoaXMuZWF0KDE3KSkgbm9kZS5vcHRpb25hbCA9IHRydWU7XG4gICAgaWYgKHRoaXMubWF0Y2goMTApIHx8IHRoaXMubWF0Y2goNDcpKSB7XG4gICAgICBpZiAocmVhZG9ubHkpIHtcbiAgICAgICAgdGhpcy5yYWlzZShUU0Vycm9ycy5SZWFkb25seUZvck1ldGhvZFNpZ25hdHVyZSwgbm9kZSk7XG4gICAgICB9XG4gICAgICBjb25zdCBtZXRob2QgPSBub2RlO1xuICAgICAgaWYgKG1ldGhvZC5raW5kICYmIHRoaXMubWF0Y2goNDcpKSB7XG4gICAgICAgIHRoaXMucmFpc2UoVFNFcnJvcnMuQWNjZXNzb3JDYW5ub3RIYXZlVHlwZVBhcmFtZXRlcnMsIHRoaXMuc3RhdGUuY3VyUG9zaXRpb24oKSk7XG4gICAgICB9XG4gICAgICB0aGlzLnRzRmlsbFNpZ25hdHVyZSgxNCwgbWV0aG9kKTtcbiAgICAgIHRoaXMudHNQYXJzZVR5cGVNZW1iZXJTZW1pY29sb24oKTtcbiAgICAgIGNvbnN0IHBhcmFtc0tleSA9IFwicGFyYW1ldGVyc1wiO1xuICAgICAgY29uc3QgcmV0dXJuVHlwZUtleSA9IFwidHlwZUFubm90YXRpb25cIjtcbiAgICAgIGlmIChtZXRob2Qua2luZCA9PT0gXCJnZXRcIikge1xuICAgICAgICBpZiAobWV0aG9kW3BhcmFtc0tleV0ubGVuZ3RoID4gMCkge1xuICAgICAgICAgIHRoaXMucmFpc2UoRXJyb3JzLkJhZEdldHRlckFyaXR5LCB0aGlzLnN0YXRlLmN1clBvc2l0aW9uKCkpO1xuICAgICAgICAgIGlmICh0aGlzLmlzVGhpc1BhcmFtKG1ldGhvZFtwYXJhbXNLZXldWzBdKSkge1xuICAgICAgICAgICAgdGhpcy5yYWlzZShUU0Vycm9ycy5BY2Nlc3NvckNhbm5vdERlY2xhcmVUaGlzUGFyYW1ldGVyLCB0aGlzLnN0YXRlLmN1clBvc2l0aW9uKCkpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChtZXRob2Qua2luZCA9PT0gXCJzZXRcIikge1xuICAgICAgICBpZiAobWV0aG9kW3BhcmFtc0tleV0ubGVuZ3RoICE9PSAxKSB7XG4gICAgICAgICAgdGhpcy5yYWlzZShFcnJvcnMuQmFkU2V0dGVyQXJpdHksIHRoaXMuc3RhdGUuY3VyUG9zaXRpb24oKSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY29uc3QgZmlyc3RQYXJhbWV0ZXIgPSBtZXRob2RbcGFyYW1zS2V5XVswXTtcbiAgICAgICAgICBpZiAodGhpcy5pc1RoaXNQYXJhbShmaXJzdFBhcmFtZXRlcikpIHtcbiAgICAgICAgICAgIHRoaXMucmFpc2UoVFNFcnJvcnMuQWNjZXNzb3JDYW5ub3REZWNsYXJlVGhpc1BhcmFtZXRlciwgdGhpcy5zdGF0ZS5jdXJQb3NpdGlvbigpKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGZpcnN0UGFyYW1ldGVyLnR5cGUgPT09IFwiSWRlbnRpZmllclwiICYmIGZpcnN0UGFyYW1ldGVyLm9wdGlvbmFsKSB7XG4gICAgICAgICAgICB0aGlzLnJhaXNlKFRTRXJyb3JzLlNldEFjY2Vzc29yQ2Fubm90SGF2ZU9wdGlvbmFsUGFyYW1ldGVyLCB0aGlzLnN0YXRlLmN1clBvc2l0aW9uKCkpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoZmlyc3RQYXJhbWV0ZXIudHlwZSA9PT0gXCJSZXN0RWxlbWVudFwiKSB7XG4gICAgICAgICAgICB0aGlzLnJhaXNlKFRTRXJyb3JzLlNldEFjY2Vzc29yQ2Fubm90SGF2ZVJlc3RQYXJhbWV0ZXIsIHRoaXMuc3RhdGUuY3VyUG9zaXRpb24oKSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChtZXRob2RbcmV0dXJuVHlwZUtleV0pIHtcbiAgICAgICAgICB0aGlzLnJhaXNlKFRTRXJyb3JzLlNldEFjY2Vzc29yQ2Fubm90SGF2ZVJldHVyblR5cGUsIG1ldGhvZFtyZXR1cm5UeXBlS2V5XSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG1ldGhvZC5raW5kID0gXCJtZXRob2RcIjtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobWV0aG9kLCBcIlRTTWV0aG9kU2lnbmF0dXJlXCIpO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBwcm9wZXJ0eSA9IG5vZGU7XG4gICAgICBpZiAocmVhZG9ubHkpIHByb3BlcnR5LnJlYWRvbmx5ID0gdHJ1ZTtcbiAgICAgIGNvbnN0IHR5cGUgPSB0aGlzLnRzVHJ5UGFyc2VUeXBlQW5ub3RhdGlvbigpO1xuICAgICAgaWYgKHR5cGUpIHByb3BlcnR5LnR5cGVBbm5vdGF0aW9uID0gdHlwZTtcbiAgICAgIHRoaXMudHNQYXJzZVR5cGVNZW1iZXJTZW1pY29sb24oKTtcbiAgICAgIHJldHVybiB0aGlzLmZpbmlzaE5vZGUocHJvcGVydHksIFwiVFNQcm9wZXJ0eVNpZ25hdHVyZVwiKTtcbiAgICB9XG4gIH1cbiAgdHNQYXJzZVR5cGVNZW1iZXIoKSB7XG4gICAgY29uc3Qgbm9kZSA9IHRoaXMuc3RhcnROb2RlKCk7XG4gICAgaWYgKHRoaXMubWF0Y2goMTApIHx8IHRoaXMubWF0Y2goNDcpKSB7XG4gICAgICByZXR1cm4gdGhpcy50c1BhcnNlU2lnbmF0dXJlTWVtYmVyKFwiVFNDYWxsU2lnbmF0dXJlRGVjbGFyYXRpb25cIiwgbm9kZSk7XG4gICAgfVxuICAgIGlmICh0aGlzLm1hdGNoKDc3KSkge1xuICAgICAgY29uc3QgaWQgPSB0aGlzLnN0YXJ0Tm9kZSgpO1xuICAgICAgdGhpcy5uZXh0KCk7XG4gICAgICBpZiAodGhpcy5tYXRjaCgxMCkgfHwgdGhpcy5tYXRjaCg0NykpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudHNQYXJzZVNpZ25hdHVyZU1lbWJlcihcIlRTQ29uc3RydWN0U2lnbmF0dXJlRGVjbGFyYXRpb25cIiwgbm9kZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBub2RlLmtleSA9IHRoaXMuY3JlYXRlSWRlbnRpZmllcihpZCwgXCJuZXdcIik7XG4gICAgICAgIHJldHVybiB0aGlzLnRzUGFyc2VQcm9wZXJ0eU9yTWV0aG9kU2lnbmF0dXJlKG5vZGUsIGZhbHNlKTtcbiAgICAgIH1cbiAgICB9XG4gICAgdGhpcy50c1BhcnNlTW9kaWZpZXJzKHtcbiAgICAgIGFsbG93ZWRNb2RpZmllcnM6IFtcInJlYWRvbmx5XCJdLFxuICAgICAgZGlzYWxsb3dlZE1vZGlmaWVyczogW1wiZGVjbGFyZVwiLCBcImFic3RyYWN0XCIsIFwicHJpdmF0ZVwiLCBcInByb3RlY3RlZFwiLCBcInB1YmxpY1wiLCBcInN0YXRpY1wiLCBcIm92ZXJyaWRlXCJdXG4gICAgfSwgbm9kZSk7XG4gICAgY29uc3QgaWR4ID0gdGhpcy50c1RyeVBhcnNlSW5kZXhTaWduYXR1cmUobm9kZSk7XG4gICAgaWYgKGlkeCkge1xuICAgICAgcmV0dXJuIGlkeDtcbiAgICB9XG4gICAgc3VwZXIucGFyc2VQcm9wZXJ0eU5hbWUobm9kZSk7XG4gICAgaWYgKCFub2RlLmNvbXB1dGVkICYmIG5vZGUua2V5LnR5cGUgPT09IFwiSWRlbnRpZmllclwiICYmIChub2RlLmtleS5uYW1lID09PSBcImdldFwiIHx8IG5vZGUua2V5Lm5hbWUgPT09IFwic2V0XCIpICYmIHRoaXMudHNUb2tlbkNhbkZvbGxvd01vZGlmaWVyKCkpIHtcbiAgICAgIG5vZGUua2luZCA9IG5vZGUua2V5Lm5hbWU7XG4gICAgICBzdXBlci5wYXJzZVByb3BlcnR5TmFtZShub2RlKTtcbiAgICAgIGlmICghdGhpcy5tYXRjaCgxMCkgJiYgIXRoaXMubWF0Y2goNDcpKSB7XG4gICAgICAgIHRoaXMudW5leHBlY3RlZChudWxsLCAxMCk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0aGlzLnRzUGFyc2VQcm9wZXJ0eU9yTWV0aG9kU2lnbmF0dXJlKG5vZGUsICEhbm9kZS5yZWFkb25seSk7XG4gIH1cbiAgdHNQYXJzZVR5cGVMaXRlcmFsKCkge1xuICAgIGNvbnN0IG5vZGUgPSB0aGlzLnN0YXJ0Tm9kZSgpO1xuICAgIG5vZGUubWVtYmVycyA9IHRoaXMudHNQYXJzZU9iamVjdFR5cGVNZW1iZXJzKCk7XG4gICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIlRTVHlwZUxpdGVyYWxcIik7XG4gIH1cbiAgdHNQYXJzZU9iamVjdFR5cGVNZW1iZXJzKCkge1xuICAgIHRoaXMuZXhwZWN0KDUpO1xuICAgIGNvbnN0IG1lbWJlcnMgPSB0aGlzLnRzUGFyc2VMaXN0KFwiVHlwZU1lbWJlcnNcIiwgdGhpcy50c1BhcnNlVHlwZU1lbWJlci5iaW5kKHRoaXMpKTtcbiAgICB0aGlzLmV4cGVjdCg4KTtcbiAgICByZXR1cm4gbWVtYmVycztcbiAgfVxuICB0c0lzU3RhcnRPZk1hcHBlZFR5cGUoKSB7XG4gICAgdGhpcy5uZXh0KCk7XG4gICAgaWYgKHRoaXMuZWF0KDUzKSkge1xuICAgICAgcmV0dXJuIHRoaXMuaXNDb250ZXh0dWFsKDEyMik7XG4gICAgfVxuICAgIGlmICh0aGlzLmlzQ29udGV4dHVhbCgxMjIpKSB7XG4gICAgICB0aGlzLm5leHQoKTtcbiAgICB9XG4gICAgaWYgKCF0aGlzLm1hdGNoKDApKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHRoaXMubmV4dCgpO1xuICAgIGlmICghdGhpcy50c0lzSWRlbnRpZmllcigpKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHRoaXMubmV4dCgpO1xuICAgIHJldHVybiB0aGlzLm1hdGNoKDU4KTtcbiAgfVxuICB0c1BhcnNlTWFwcGVkVHlwZSgpIHtcbiAgICBjb25zdCBub2RlID0gdGhpcy5zdGFydE5vZGUoKTtcbiAgICB0aGlzLmV4cGVjdCg1KTtcbiAgICBpZiAodGhpcy5tYXRjaCg1MykpIHtcbiAgICAgIG5vZGUucmVhZG9ubHkgPSB0aGlzLnN0YXRlLnZhbHVlO1xuICAgICAgdGhpcy5uZXh0KCk7XG4gICAgICB0aGlzLmV4cGVjdENvbnRleHR1YWwoMTIyKTtcbiAgICB9IGVsc2UgaWYgKHRoaXMuZWF0Q29udGV4dHVhbCgxMjIpKSB7XG4gICAgICBub2RlLnJlYWRvbmx5ID0gdHJ1ZTtcbiAgICB9XG4gICAgdGhpcy5leHBlY3QoMCk7XG4gICAgY29uc3QgdHlwZVBhcmFtZXRlciA9IHRoaXMuc3RhcnROb2RlKCk7XG4gICAgdHlwZVBhcmFtZXRlci5uYW1lID0gdGhpcy50c1BhcnNlVHlwZVBhcmFtZXRlck5hbWUoKTtcbiAgICB0eXBlUGFyYW1ldGVyLmNvbnN0cmFpbnQgPSB0aGlzLnRzRXhwZWN0VGhlblBhcnNlVHlwZSg1OCk7XG4gICAgbm9kZS50eXBlUGFyYW1ldGVyID0gdGhpcy5maW5pc2hOb2RlKHR5cGVQYXJhbWV0ZXIsIFwiVFNUeXBlUGFyYW1ldGVyXCIpO1xuICAgIG5vZGUubmFtZVR5cGUgPSB0aGlzLmVhdENvbnRleHR1YWwoOTMpID8gdGhpcy50c1BhcnNlVHlwZSgpIDogbnVsbDtcbiAgICB0aGlzLmV4cGVjdCgzKTtcbiAgICBpZiAodGhpcy5tYXRjaCg1MykpIHtcbiAgICAgIG5vZGUub3B0aW9uYWwgPSB0aGlzLnN0YXRlLnZhbHVlO1xuICAgICAgdGhpcy5uZXh0KCk7XG4gICAgICB0aGlzLmV4cGVjdCgxNyk7XG4gICAgfSBlbHNlIGlmICh0aGlzLmVhdCgxNykpIHtcbiAgICAgIG5vZGUub3B0aW9uYWwgPSB0cnVlO1xuICAgIH1cbiAgICBub2RlLnR5cGVBbm5vdGF0aW9uID0gdGhpcy50c1RyeVBhcnNlVHlwZSgpO1xuICAgIHRoaXMuc2VtaWNvbG9uKCk7XG4gICAgdGhpcy5leHBlY3QoOCk7XG4gICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIlRTTWFwcGVkVHlwZVwiKTtcbiAgfVxuICB0c1BhcnNlVHVwbGVUeXBlKCkge1xuICAgIGNvbnN0IG5vZGUgPSB0aGlzLnN0YXJ0Tm9kZSgpO1xuICAgIG5vZGUuZWxlbWVudFR5cGVzID0gdGhpcy50c1BhcnNlQnJhY2tldGVkTGlzdChcIlR1cGxlRWxlbWVudFR5cGVzXCIsIHRoaXMudHNQYXJzZVR1cGxlRWxlbWVudFR5cGUuYmluZCh0aGlzKSwgdHJ1ZSwgZmFsc2UpO1xuICAgIGxldCBzZWVuT3B0aW9uYWxFbGVtZW50ID0gZmFsc2U7XG4gICAgbm9kZS5lbGVtZW50VHlwZXMuZm9yRWFjaChlbGVtZW50Tm9kZSA9PiB7XG4gICAgICBjb25zdCB7XG4gICAgICAgIHR5cGVcbiAgICAgIH0gPSBlbGVtZW50Tm9kZTtcbiAgICAgIGlmIChzZWVuT3B0aW9uYWxFbGVtZW50ICYmIHR5cGUgIT09IFwiVFNSZXN0VHlwZVwiICYmIHR5cGUgIT09IFwiVFNPcHRpb25hbFR5cGVcIiAmJiAhKHR5cGUgPT09IFwiVFNOYW1lZFR1cGxlTWVtYmVyXCIgJiYgZWxlbWVudE5vZGUub3B0aW9uYWwpKSB7XG4gICAgICAgIHRoaXMucmFpc2UoVFNFcnJvcnMuT3B0aW9uYWxUeXBlQmVmb3JlUmVxdWlyZWQsIGVsZW1lbnROb2RlKTtcbiAgICAgIH1cbiAgICAgIHNlZW5PcHRpb25hbEVsZW1lbnQgfHwgKHNlZW5PcHRpb25hbEVsZW1lbnQgPSB0eXBlID09PSBcIlRTTmFtZWRUdXBsZU1lbWJlclwiICYmIGVsZW1lbnROb2RlLm9wdGlvbmFsIHx8IHR5cGUgPT09IFwiVFNPcHRpb25hbFR5cGVcIik7XG4gICAgfSk7XG4gICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIlRTVHVwbGVUeXBlXCIpO1xuICB9XG4gIHRzUGFyc2VUdXBsZUVsZW1lbnRUeXBlKCkge1xuICAgIGNvbnN0IHJlc3RTdGFydExvYyA9IHRoaXMuc3RhdGUuc3RhcnRMb2M7XG4gICAgY29uc3QgcmVzdCA9IHRoaXMuZWF0KDIxKTtcbiAgICBjb25zdCB7XG4gICAgICBzdGFydExvY1xuICAgIH0gPSB0aGlzLnN0YXRlO1xuICAgIGxldCBsYWJlbGVkO1xuICAgIGxldCBsYWJlbDtcbiAgICBsZXQgb3B0aW9uYWw7XG4gICAgbGV0IHR5cGU7XG4gICAgY29uc3QgaXNXb3JkID0gdG9rZW5Jc0tleXdvcmRPcklkZW50aWZpZXIodGhpcy5zdGF0ZS50eXBlKTtcbiAgICBjb25zdCBjaEFmdGVyV29yZCA9IGlzV29yZCA/IHRoaXMubG9va2FoZWFkQ2hhckNvZGUoKSA6IG51bGw7XG4gICAgaWYgKGNoQWZ0ZXJXb3JkID09PSA1OCkge1xuICAgICAgbGFiZWxlZCA9IHRydWU7XG4gICAgICBvcHRpb25hbCA9IGZhbHNlO1xuICAgICAgbGFiZWwgPSB0aGlzLnBhcnNlSWRlbnRpZmllcih0cnVlKTtcbiAgICAgIHRoaXMuZXhwZWN0KDE0KTtcbiAgICAgIHR5cGUgPSB0aGlzLnRzUGFyc2VUeXBlKCk7XG4gICAgfSBlbHNlIGlmIChjaEFmdGVyV29yZCA9PT0gNjMpIHtcbiAgICAgIG9wdGlvbmFsID0gdHJ1ZTtcbiAgICAgIGNvbnN0IHdvcmROYW1lID0gdGhpcy5zdGF0ZS52YWx1ZTtcbiAgICAgIGNvbnN0IHR5cGVPckxhYmVsID0gdGhpcy50c1BhcnNlTm9uQXJyYXlUeXBlKCk7XG4gICAgICBpZiAodGhpcy5sb29rYWhlYWRDaGFyQ29kZSgpID09PSA1OCkge1xuICAgICAgICBsYWJlbGVkID0gdHJ1ZTtcbiAgICAgICAgbGFiZWwgPSB0aGlzLmNyZWF0ZUlkZW50aWZpZXIodGhpcy5zdGFydE5vZGVBdChzdGFydExvYyksIHdvcmROYW1lKTtcbiAgICAgICAgdGhpcy5leHBlY3QoMTcpO1xuICAgICAgICB0aGlzLmV4cGVjdCgxNCk7XG4gICAgICAgIHR5cGUgPSB0aGlzLnRzUGFyc2VUeXBlKCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBsYWJlbGVkID0gZmFsc2U7XG4gICAgICAgIHR5cGUgPSB0eXBlT3JMYWJlbDtcbiAgICAgICAgdGhpcy5leHBlY3QoMTcpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB0eXBlID0gdGhpcy50c1BhcnNlVHlwZSgpO1xuICAgICAgb3B0aW9uYWwgPSB0aGlzLmVhdCgxNyk7XG4gICAgICBsYWJlbGVkID0gdGhpcy5lYXQoMTQpO1xuICAgIH1cbiAgICBpZiAobGFiZWxlZCkge1xuICAgICAgbGV0IGxhYmVsZWROb2RlO1xuICAgICAgaWYgKGxhYmVsKSB7XG4gICAgICAgIGxhYmVsZWROb2RlID0gdGhpcy5zdGFydE5vZGVBdChzdGFydExvYyk7XG4gICAgICAgIGxhYmVsZWROb2RlLm9wdGlvbmFsID0gb3B0aW9uYWw7XG4gICAgICAgIGxhYmVsZWROb2RlLmxhYmVsID0gbGFiZWw7XG4gICAgICAgIGxhYmVsZWROb2RlLmVsZW1lbnRUeXBlID0gdHlwZTtcbiAgICAgICAgaWYgKHRoaXMuZWF0KDE3KSkge1xuICAgICAgICAgIGxhYmVsZWROb2RlLm9wdGlvbmFsID0gdHJ1ZTtcbiAgICAgICAgICB0aGlzLnJhaXNlKFRTRXJyb3JzLlR1cGxlT3B0aW9uYWxBZnRlclR5cGUsIHRoaXMuc3RhdGUubGFzdFRva1N0YXJ0TG9jKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbGFiZWxlZE5vZGUgPSB0aGlzLnN0YXJ0Tm9kZUF0KHN0YXJ0TG9jKTtcbiAgICAgICAgbGFiZWxlZE5vZGUub3B0aW9uYWwgPSBvcHRpb25hbDtcbiAgICAgICAgdGhpcy5yYWlzZShUU0Vycm9ycy5JbnZhbGlkVHVwbGVNZW1iZXJMYWJlbCwgdHlwZSk7XG4gICAgICAgIGxhYmVsZWROb2RlLmxhYmVsID0gdHlwZTtcbiAgICAgICAgbGFiZWxlZE5vZGUuZWxlbWVudFR5cGUgPSB0aGlzLnRzUGFyc2VUeXBlKCk7XG4gICAgICB9XG4gICAgICB0eXBlID0gdGhpcy5maW5pc2hOb2RlKGxhYmVsZWROb2RlLCBcIlRTTmFtZWRUdXBsZU1lbWJlclwiKTtcbiAgICB9IGVsc2UgaWYgKG9wdGlvbmFsKSB7XG4gICAgICBjb25zdCBvcHRpb25hbFR5cGVOb2RlID0gdGhpcy5zdGFydE5vZGVBdChzdGFydExvYyk7XG4gICAgICBvcHRpb25hbFR5cGVOb2RlLnR5cGVBbm5vdGF0aW9uID0gdHlwZTtcbiAgICAgIHR5cGUgPSB0aGlzLmZpbmlzaE5vZGUob3B0aW9uYWxUeXBlTm9kZSwgXCJUU09wdGlvbmFsVHlwZVwiKTtcbiAgICB9XG4gICAgaWYgKHJlc3QpIHtcbiAgICAgIGNvbnN0IHJlc3ROb2RlID0gdGhpcy5zdGFydE5vZGVBdChyZXN0U3RhcnRMb2MpO1xuICAgICAgcmVzdE5vZGUudHlwZUFubm90YXRpb24gPSB0eXBlO1xuICAgICAgdHlwZSA9IHRoaXMuZmluaXNoTm9kZShyZXN0Tm9kZSwgXCJUU1Jlc3RUeXBlXCIpO1xuICAgIH1cbiAgICByZXR1cm4gdHlwZTtcbiAgfVxuICB0c1BhcnNlUGFyZW50aGVzaXplZFR5cGUoKSB7XG4gICAgY29uc3Qgbm9kZSA9IHRoaXMuc3RhcnROb2RlKCk7XG4gICAgdGhpcy5leHBlY3QoMTApO1xuICAgIG5vZGUudHlwZUFubm90YXRpb24gPSB0aGlzLnRzUGFyc2VUeXBlKCk7XG4gICAgdGhpcy5leHBlY3QoMTEpO1xuICAgIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJUU1BhcmVudGhlc2l6ZWRUeXBlXCIpO1xuICB9XG4gIHRzUGFyc2VGdW5jdGlvbk9yQ29uc3RydWN0b3JUeXBlKHR5cGUsIGFic3RyYWN0KSB7XG4gICAgY29uc3Qgbm9kZSA9IHRoaXMuc3RhcnROb2RlKCk7XG4gICAgaWYgKHR5cGUgPT09IFwiVFNDb25zdHJ1Y3RvclR5cGVcIikge1xuICAgICAgbm9kZS5hYnN0cmFjdCA9ICEhYWJzdHJhY3Q7XG4gICAgICBpZiAoYWJzdHJhY3QpIHRoaXMubmV4dCgpO1xuICAgICAgdGhpcy5uZXh0KCk7XG4gICAgfVxuICAgIHRoaXMudHNJbkFsbG93Q29uZGl0aW9uYWxUeXBlc0NvbnRleHQoKCkgPT4gdGhpcy50c0ZpbGxTaWduYXR1cmUoMTksIG5vZGUpKTtcbiAgICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIHR5cGUpO1xuICB9XG4gIHRzUGFyc2VMaXRlcmFsVHlwZU5vZGUoKSB7XG4gICAgY29uc3Qgbm9kZSA9IHRoaXMuc3RhcnROb2RlKCk7XG4gICAgc3dpdGNoICh0aGlzLnN0YXRlLnR5cGUpIHtcbiAgICAgIGNhc2UgMTM1OlxuICAgICAgY2FzZSAxMzY6XG4gICAgICBjYXNlIDEzNDpcbiAgICAgIGNhc2UgODU6XG4gICAgICBjYXNlIDg2OlxuICAgICAgICBub2RlLmxpdGVyYWwgPSBzdXBlci5wYXJzZUV4cHJBdG9tKCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgdGhpcy51bmV4cGVjdGVkKCk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJUU0xpdGVyYWxUeXBlXCIpO1xuICB9XG4gIHRzUGFyc2VUZW1wbGF0ZUxpdGVyYWxUeXBlKCkge1xuICAgIGNvbnN0IG5vZGUgPSB0aGlzLnN0YXJ0Tm9kZSgpO1xuICAgIG5vZGUubGl0ZXJhbCA9IHN1cGVyLnBhcnNlVGVtcGxhdGUoZmFsc2UpO1xuICAgIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJUU0xpdGVyYWxUeXBlXCIpO1xuICB9XG4gIHBhcnNlVGVtcGxhdGVTdWJzdGl0dXRpb24oKSB7XG4gICAgaWYgKHRoaXMuc3RhdGUuaW5UeXBlKSByZXR1cm4gdGhpcy50c1BhcnNlVHlwZSgpO1xuICAgIHJldHVybiBzdXBlci5wYXJzZVRlbXBsYXRlU3Vic3RpdHV0aW9uKCk7XG4gIH1cbiAgdHNQYXJzZVRoaXNUeXBlT3JUaGlzVHlwZVByZWRpY2F0ZSgpIHtcbiAgICBjb25zdCB0aGlzS2V5d29yZCA9IHRoaXMudHNQYXJzZVRoaXNUeXBlTm9kZSgpO1xuICAgIGlmICh0aGlzLmlzQ29udGV4dHVhbCgxMTYpICYmICF0aGlzLmhhc1ByZWNlZGluZ0xpbmVCcmVhaygpKSB7XG4gICAgICByZXR1cm4gdGhpcy50c1BhcnNlVGhpc1R5cGVQcmVkaWNhdGUodGhpc0tleXdvcmQpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gdGhpc0tleXdvcmQ7XG4gICAgfVxuICB9XG4gIHRzUGFyc2VOb25BcnJheVR5cGUoKSB7XG4gICAgc3dpdGNoICh0aGlzLnN0YXRlLnR5cGUpIHtcbiAgICAgIGNhc2UgMTM0OlxuICAgICAgY2FzZSAxMzU6XG4gICAgICBjYXNlIDEzNjpcbiAgICAgIGNhc2UgODU6XG4gICAgICBjYXNlIDg2OlxuICAgICAgICByZXR1cm4gdGhpcy50c1BhcnNlTGl0ZXJhbFR5cGVOb2RlKCk7XG4gICAgICBjYXNlIDUzOlxuICAgICAgICBpZiAodGhpcy5zdGF0ZS52YWx1ZSA9PT0gXCItXCIpIHtcbiAgICAgICAgICBjb25zdCBub2RlID0gdGhpcy5zdGFydE5vZGUoKTtcbiAgICAgICAgICBjb25zdCBuZXh0VG9rZW4gPSB0aGlzLmxvb2thaGVhZCgpO1xuICAgICAgICAgIGlmIChuZXh0VG9rZW4udHlwZSAhPT0gMTM1ICYmIG5leHRUb2tlbi50eXBlICE9PSAxMzYpIHtcbiAgICAgICAgICAgIHRoaXMudW5leHBlY3RlZCgpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBub2RlLmxpdGVyYWwgPSB0aGlzLnBhcnNlTWF5YmVVbmFyeSgpO1xuICAgICAgICAgIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJUU0xpdGVyYWxUeXBlXCIpO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSA3ODpcbiAgICAgICAgcmV0dXJuIHRoaXMudHNQYXJzZVRoaXNUeXBlT3JUaGlzVHlwZVByZWRpY2F0ZSgpO1xuICAgICAgY2FzZSA4NzpcbiAgICAgICAgcmV0dXJuIHRoaXMudHNQYXJzZVR5cGVRdWVyeSgpO1xuICAgICAgY2FzZSA4MzpcbiAgICAgICAgcmV0dXJuIHRoaXMudHNQYXJzZUltcG9ydFR5cGUoKTtcbiAgICAgIGNhc2UgNTpcbiAgICAgICAgcmV0dXJuIHRoaXMudHNMb29rQWhlYWQodGhpcy50c0lzU3RhcnRPZk1hcHBlZFR5cGUuYmluZCh0aGlzKSkgPyB0aGlzLnRzUGFyc2VNYXBwZWRUeXBlKCkgOiB0aGlzLnRzUGFyc2VUeXBlTGl0ZXJhbCgpO1xuICAgICAgY2FzZSAwOlxuICAgICAgICByZXR1cm4gdGhpcy50c1BhcnNlVHVwbGVUeXBlKCk7XG4gICAgICBjYXNlIDEwOlxuICAgICAgICByZXR1cm4gdGhpcy50c1BhcnNlUGFyZW50aGVzaXplZFR5cGUoKTtcbiAgICAgIGNhc2UgMjU6XG4gICAgICBjYXNlIDI0OlxuICAgICAgICByZXR1cm4gdGhpcy50c1BhcnNlVGVtcGxhdGVMaXRlcmFsVHlwZSgpO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAge1xuICAgICAgICAgIGNvbnN0IHtcbiAgICAgICAgICAgIHR5cGVcbiAgICAgICAgICB9ID0gdGhpcy5zdGF0ZTtcbiAgICAgICAgICBpZiAodG9rZW5Jc0lkZW50aWZpZXIodHlwZSkgfHwgdHlwZSA9PT0gODggfHwgdHlwZSA9PT0gODQpIHtcbiAgICAgICAgICAgIGNvbnN0IG5vZGVUeXBlID0gdHlwZSA9PT0gODggPyBcIlRTVm9pZEtleXdvcmRcIiA6IHR5cGUgPT09IDg0ID8gXCJUU051bGxLZXl3b3JkXCIgOiBrZXl3b3JkVHlwZUZyb21OYW1lKHRoaXMuc3RhdGUudmFsdWUpO1xuICAgICAgICAgICAgaWYgKG5vZGVUeXBlICE9PSB1bmRlZmluZWQgJiYgdGhpcy5sb29rYWhlYWRDaGFyQ29kZSgpICE9PSA0Nikge1xuICAgICAgICAgICAgICBjb25zdCBub2RlID0gdGhpcy5zdGFydE5vZGUoKTtcbiAgICAgICAgICAgICAgdGhpcy5uZXh0KCk7XG4gICAgICAgICAgICAgIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgbm9kZVR5cGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMudHNQYXJzZVR5cGVSZWZlcmVuY2UoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgdGhyb3cgdGhpcy51bmV4cGVjdGVkKCk7XG4gIH1cbiAgdHNQYXJzZUFycmF5VHlwZU9ySGlnaGVyKCkge1xuICAgIGNvbnN0IHtcbiAgICAgIHN0YXJ0TG9jXG4gICAgfSA9IHRoaXMuc3RhdGU7XG4gICAgbGV0IHR5cGUgPSB0aGlzLnRzUGFyc2VOb25BcnJheVR5cGUoKTtcbiAgICB3aGlsZSAoIXRoaXMuaGFzUHJlY2VkaW5nTGluZUJyZWFrKCkgJiYgdGhpcy5lYXQoMCkpIHtcbiAgICAgIGlmICh0aGlzLm1hdGNoKDMpKSB7XG4gICAgICAgIGNvbnN0IG5vZGUgPSB0aGlzLnN0YXJ0Tm9kZUF0KHN0YXJ0TG9jKTtcbiAgICAgICAgbm9kZS5lbGVtZW50VHlwZSA9IHR5cGU7XG4gICAgICAgIHRoaXMuZXhwZWN0KDMpO1xuICAgICAgICB0eXBlID0gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiVFNBcnJheVR5cGVcIik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zdCBub2RlID0gdGhpcy5zdGFydE5vZGVBdChzdGFydExvYyk7XG4gICAgICAgIG5vZGUub2JqZWN0VHlwZSA9IHR5cGU7XG4gICAgICAgIG5vZGUuaW5kZXhUeXBlID0gdGhpcy50c1BhcnNlVHlwZSgpO1xuICAgICAgICB0aGlzLmV4cGVjdCgzKTtcbiAgICAgICAgdHlwZSA9IHRoaXMuZmluaXNoTm9kZShub2RlLCBcIlRTSW5kZXhlZEFjY2Vzc1R5cGVcIik7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0eXBlO1xuICB9XG4gIHRzUGFyc2VUeXBlT3BlcmF0b3IoKSB7XG4gICAgY29uc3Qgbm9kZSA9IHRoaXMuc3RhcnROb2RlKCk7XG4gICAgY29uc3Qgb3BlcmF0b3IgPSB0aGlzLnN0YXRlLnZhbHVlO1xuICAgIHRoaXMubmV4dCgpO1xuICAgIG5vZGUub3BlcmF0b3IgPSBvcGVyYXRvcjtcbiAgICBub2RlLnR5cGVBbm5vdGF0aW9uID0gdGhpcy50c1BhcnNlVHlwZU9wZXJhdG9yT3JIaWdoZXIoKTtcbiAgICBpZiAob3BlcmF0b3IgPT09IFwicmVhZG9ubHlcIikge1xuICAgICAgdGhpcy50c0NoZWNrVHlwZUFubm90YXRpb25Gb3JSZWFkT25seShub2RlKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIlRTVHlwZU9wZXJhdG9yXCIpO1xuICB9XG4gIHRzQ2hlY2tUeXBlQW5ub3RhdGlvbkZvclJlYWRPbmx5KG5vZGUpIHtcbiAgICBzd2l0Y2ggKG5vZGUudHlwZUFubm90YXRpb24udHlwZSkge1xuICAgICAgY2FzZSBcIlRTVHVwbGVUeXBlXCI6XG4gICAgICBjYXNlIFwiVFNBcnJheVR5cGVcIjpcbiAgICAgICAgcmV0dXJuO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgdGhpcy5yYWlzZShUU0Vycm9ycy5VbmV4cGVjdGVkUmVhZG9ubHksIG5vZGUpO1xuICAgIH1cbiAgfVxuICB0c1BhcnNlSW5mZXJUeXBlKCkge1xuICAgIGNvbnN0IG5vZGUgPSB0aGlzLnN0YXJ0Tm9kZSgpO1xuICAgIHRoaXMuZXhwZWN0Q29udGV4dHVhbCgxMTUpO1xuICAgIGNvbnN0IHR5cGVQYXJhbWV0ZXIgPSB0aGlzLnN0YXJ0Tm9kZSgpO1xuICAgIHR5cGVQYXJhbWV0ZXIubmFtZSA9IHRoaXMudHNQYXJzZVR5cGVQYXJhbWV0ZXJOYW1lKCk7XG4gICAgdHlwZVBhcmFtZXRlci5jb25zdHJhaW50ID0gdGhpcy50c1RyeVBhcnNlKCgpID0+IHRoaXMudHNQYXJzZUNvbnN0cmFpbnRGb3JJbmZlclR5cGUoKSk7XG4gICAgbm9kZS50eXBlUGFyYW1ldGVyID0gdGhpcy5maW5pc2hOb2RlKHR5cGVQYXJhbWV0ZXIsIFwiVFNUeXBlUGFyYW1ldGVyXCIpO1xuICAgIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJUU0luZmVyVHlwZVwiKTtcbiAgfVxuICB0c1BhcnNlQ29uc3RyYWludEZvckluZmVyVHlwZSgpIHtcbiAgICBpZiAodGhpcy5lYXQoODEpKSB7XG4gICAgICBjb25zdCBjb25zdHJhaW50ID0gdGhpcy50c0luRGlzYWxsb3dDb25kaXRpb25hbFR5cGVzQ29udGV4dCgoKSA9PiB0aGlzLnRzUGFyc2VUeXBlKCkpO1xuICAgICAgaWYgKHRoaXMuc3RhdGUuaW5EaXNhbGxvd0NvbmRpdGlvbmFsVHlwZXNDb250ZXh0IHx8ICF0aGlzLm1hdGNoKDE3KSkge1xuICAgICAgICByZXR1cm4gY29uc3RyYWludDtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgdHNQYXJzZVR5cGVPcGVyYXRvck9ySGlnaGVyKCkge1xuICAgIGNvbnN0IGlzVHlwZU9wZXJhdG9yID0gdG9rZW5Jc1RTVHlwZU9wZXJhdG9yKHRoaXMuc3RhdGUudHlwZSkgJiYgIXRoaXMuc3RhdGUuY29udGFpbnNFc2M7XG4gICAgcmV0dXJuIGlzVHlwZU9wZXJhdG9yID8gdGhpcy50c1BhcnNlVHlwZU9wZXJhdG9yKCkgOiB0aGlzLmlzQ29udGV4dHVhbCgxMTUpID8gdGhpcy50c1BhcnNlSW5mZXJUeXBlKCkgOiB0aGlzLnRzSW5BbGxvd0NvbmRpdGlvbmFsVHlwZXNDb250ZXh0KCgpID0+IHRoaXMudHNQYXJzZUFycmF5VHlwZU9ySGlnaGVyKCkpO1xuICB9XG4gIHRzUGFyc2VVbmlvbk9ySW50ZXJzZWN0aW9uVHlwZShraW5kLCBwYXJzZUNvbnN0aXR1ZW50VHlwZSwgb3BlcmF0b3IpIHtcbiAgICBjb25zdCBub2RlID0gdGhpcy5zdGFydE5vZGUoKTtcbiAgICBjb25zdCBoYXNMZWFkaW5nT3BlcmF0b3IgPSB0aGlzLmVhdChvcGVyYXRvcik7XG4gICAgY29uc3QgdHlwZXMgPSBbXTtcbiAgICBkbyB7XG4gICAgICB0eXBlcy5wdXNoKHBhcnNlQ29uc3RpdHVlbnRUeXBlKCkpO1xuICAgIH0gd2hpbGUgKHRoaXMuZWF0KG9wZXJhdG9yKSk7XG4gICAgaWYgKHR5cGVzLmxlbmd0aCA9PT0gMSAmJiAhaGFzTGVhZGluZ09wZXJhdG9yKSB7XG4gICAgICByZXR1cm4gdHlwZXNbMF07XG4gICAgfVxuICAgIG5vZGUudHlwZXMgPSB0eXBlcztcbiAgICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIGtpbmQpO1xuICB9XG4gIHRzUGFyc2VJbnRlcnNlY3Rpb25UeXBlT3JIaWdoZXIoKSB7XG4gICAgcmV0dXJuIHRoaXMudHNQYXJzZVVuaW9uT3JJbnRlcnNlY3Rpb25UeXBlKFwiVFNJbnRlcnNlY3Rpb25UeXBlXCIsIHRoaXMudHNQYXJzZVR5cGVPcGVyYXRvck9ySGlnaGVyLmJpbmQodGhpcyksIDQ1KTtcbiAgfVxuICB0c1BhcnNlVW5pb25UeXBlT3JIaWdoZXIoKSB7XG4gICAgcmV0dXJuIHRoaXMudHNQYXJzZVVuaW9uT3JJbnRlcnNlY3Rpb25UeXBlKFwiVFNVbmlvblR5cGVcIiwgdGhpcy50c1BhcnNlSW50ZXJzZWN0aW9uVHlwZU9ySGlnaGVyLmJpbmQodGhpcyksIDQzKTtcbiAgfVxuICB0c0lzU3RhcnRPZkZ1bmN0aW9uVHlwZSgpIHtcbiAgICBpZiAodGhpcy5tYXRjaCg0NykpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5tYXRjaCgxMCkgJiYgdGhpcy50c0xvb2tBaGVhZCh0aGlzLnRzSXNVbmFtYmlndW91c2x5U3RhcnRPZkZ1bmN0aW9uVHlwZS5iaW5kKHRoaXMpKTtcbiAgfVxuICB0c1NraXBQYXJhbWV0ZXJTdGFydCgpIHtcbiAgICBpZiAodG9rZW5Jc0lkZW50aWZpZXIodGhpcy5zdGF0ZS50eXBlKSB8fCB0aGlzLm1hdGNoKDc4KSkge1xuICAgICAgdGhpcy5uZXh0KCk7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgaWYgKHRoaXMubWF0Y2goNSkpIHtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgZXJyb3JzXG4gICAgICB9ID0gdGhpcy5zdGF0ZTtcbiAgICAgIGNvbnN0IHByZXZpb3VzRXJyb3JDb3VudCA9IGVycm9ycy5sZW5ndGg7XG4gICAgICB0cnkge1xuICAgICAgICB0aGlzLnBhcnNlT2JqZWN0TGlrZSg4LCB0cnVlKTtcbiAgICAgICAgcmV0dXJuIGVycm9ycy5sZW5ndGggPT09IHByZXZpb3VzRXJyb3JDb3VudDtcbiAgICAgIH0gY2F0Y2ggKF91bnVzZWQpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAodGhpcy5tYXRjaCgwKSkge1xuICAgICAgdGhpcy5uZXh0KCk7XG4gICAgICBjb25zdCB7XG4gICAgICAgIGVycm9yc1xuICAgICAgfSA9IHRoaXMuc3RhdGU7XG4gICAgICBjb25zdCBwcmV2aW91c0Vycm9yQ291bnQgPSBlcnJvcnMubGVuZ3RoO1xuICAgICAgdHJ5IHtcbiAgICAgICAgc3VwZXIucGFyc2VCaW5kaW5nTGlzdCgzLCA5MywgMSk7XG4gICAgICAgIHJldHVybiBlcnJvcnMubGVuZ3RoID09PSBwcmV2aW91c0Vycm9yQ291bnQ7XG4gICAgICB9IGNhdGNoIChfdW51c2VkMikge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICB0c0lzVW5hbWJpZ3VvdXNseVN0YXJ0T2ZGdW5jdGlvblR5cGUoKSB7XG4gICAgdGhpcy5uZXh0KCk7XG4gICAgaWYgKHRoaXMubWF0Y2goMTEpIHx8IHRoaXMubWF0Y2goMjEpKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgaWYgKHRoaXMudHNTa2lwUGFyYW1ldGVyU3RhcnQoKSkge1xuICAgICAgaWYgKHRoaXMubWF0Y2goMTQpIHx8IHRoaXMubWF0Y2goMTIpIHx8IHRoaXMubWF0Y2goMTcpIHx8IHRoaXMubWF0Y2goMjkpKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMubWF0Y2goMTEpKSB7XG4gICAgICAgIHRoaXMubmV4dCgpO1xuICAgICAgICBpZiAodGhpcy5tYXRjaCgxOSkpIHtcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgdHNQYXJzZVR5cGVPclR5cGVQcmVkaWNhdGVBbm5vdGF0aW9uKHJldHVyblRva2VuKSB7XG4gICAgcmV0dXJuIHRoaXMudHNJblR5cGUoKCkgPT4ge1xuICAgICAgY29uc3QgdCA9IHRoaXMuc3RhcnROb2RlKCk7XG4gICAgICB0aGlzLmV4cGVjdChyZXR1cm5Ub2tlbik7XG4gICAgICBjb25zdCBub2RlID0gdGhpcy5zdGFydE5vZGUoKTtcbiAgICAgIGNvbnN0IGFzc2VydHMgPSAhIXRoaXMudHNUcnlQYXJzZSh0aGlzLnRzUGFyc2VUeXBlUHJlZGljYXRlQXNzZXJ0cy5iaW5kKHRoaXMpKTtcbiAgICAgIGlmIChhc3NlcnRzICYmIHRoaXMubWF0Y2goNzgpKSB7XG4gICAgICAgIGxldCB0aGlzVHlwZVByZWRpY2F0ZSA9IHRoaXMudHNQYXJzZVRoaXNUeXBlT3JUaGlzVHlwZVByZWRpY2F0ZSgpO1xuICAgICAgICBpZiAodGhpc1R5cGVQcmVkaWNhdGUudHlwZSA9PT0gXCJUU1RoaXNUeXBlXCIpIHtcbiAgICAgICAgICBub2RlLnBhcmFtZXRlck5hbWUgPSB0aGlzVHlwZVByZWRpY2F0ZTtcbiAgICAgICAgICBub2RlLmFzc2VydHMgPSB0cnVlO1xuICAgICAgICAgIG5vZGUudHlwZUFubm90YXRpb24gPSBudWxsO1xuICAgICAgICAgIHRoaXNUeXBlUHJlZGljYXRlID0gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiVFNUeXBlUHJlZGljYXRlXCIpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMucmVzZXRTdGFydExvY2F0aW9uRnJvbU5vZGUodGhpc1R5cGVQcmVkaWNhdGUsIG5vZGUpO1xuICAgICAgICAgIHRoaXNUeXBlUHJlZGljYXRlLmFzc2VydHMgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHQudHlwZUFubm90YXRpb24gPSB0aGlzVHlwZVByZWRpY2F0ZTtcbiAgICAgICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZSh0LCBcIlRTVHlwZUFubm90YXRpb25cIik7XG4gICAgICB9XG4gICAgICBjb25zdCB0eXBlUHJlZGljYXRlVmFyaWFibGUgPSB0aGlzLnRzSXNJZGVudGlmaWVyKCkgJiYgdGhpcy50c1RyeVBhcnNlKHRoaXMudHNQYXJzZVR5cGVQcmVkaWNhdGVQcmVmaXguYmluZCh0aGlzKSk7XG4gICAgICBpZiAoIXR5cGVQcmVkaWNhdGVWYXJpYWJsZSkge1xuICAgICAgICBpZiAoIWFzc2VydHMpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy50c1BhcnNlVHlwZUFubm90YXRpb24oZmFsc2UsIHQpO1xuICAgICAgICB9XG4gICAgICAgIG5vZGUucGFyYW1ldGVyTmFtZSA9IHRoaXMucGFyc2VJZGVudGlmaWVyKCk7XG4gICAgICAgIG5vZGUuYXNzZXJ0cyA9IGFzc2VydHM7XG4gICAgICAgIG5vZGUudHlwZUFubm90YXRpb24gPSBudWxsO1xuICAgICAgICB0LnR5cGVBbm5vdGF0aW9uID0gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiVFNUeXBlUHJlZGljYXRlXCIpO1xuICAgICAgICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKHQsIFwiVFNUeXBlQW5ub3RhdGlvblwiKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHR5cGUgPSB0aGlzLnRzUGFyc2VUeXBlQW5ub3RhdGlvbihmYWxzZSk7XG4gICAgICBub2RlLnBhcmFtZXRlck5hbWUgPSB0eXBlUHJlZGljYXRlVmFyaWFibGU7XG4gICAgICBub2RlLnR5cGVBbm5vdGF0aW9uID0gdHlwZTtcbiAgICAgIG5vZGUuYXNzZXJ0cyA9IGFzc2VydHM7XG4gICAgICB0LnR5cGVBbm5vdGF0aW9uID0gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiVFNUeXBlUHJlZGljYXRlXCIpO1xuICAgICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZSh0LCBcIlRTVHlwZUFubm90YXRpb25cIik7XG4gICAgfSk7XG4gIH1cbiAgdHNUcnlQYXJzZVR5cGVPclR5cGVQcmVkaWNhdGVBbm5vdGF0aW9uKCkge1xuICAgIGlmICh0aGlzLm1hdGNoKDE0KSkge1xuICAgICAgcmV0dXJuIHRoaXMudHNQYXJzZVR5cGVPclR5cGVQcmVkaWNhdGVBbm5vdGF0aW9uKDE0KTtcbiAgICB9XG4gIH1cbiAgdHNUcnlQYXJzZVR5cGVBbm5vdGF0aW9uKCkge1xuICAgIGlmICh0aGlzLm1hdGNoKDE0KSkge1xuICAgICAgcmV0dXJuIHRoaXMudHNQYXJzZVR5cGVBbm5vdGF0aW9uKCk7XG4gICAgfVxuICB9XG4gIHRzVHJ5UGFyc2VUeXBlKCkge1xuICAgIHJldHVybiB0aGlzLnRzRWF0VGhlblBhcnNlVHlwZSgxNCk7XG4gIH1cbiAgdHNQYXJzZVR5cGVQcmVkaWNhdGVQcmVmaXgoKSB7XG4gICAgY29uc3QgaWQgPSB0aGlzLnBhcnNlSWRlbnRpZmllcigpO1xuICAgIGlmICh0aGlzLmlzQ29udGV4dHVhbCgxMTYpICYmICF0aGlzLmhhc1ByZWNlZGluZ0xpbmVCcmVhaygpKSB7XG4gICAgICB0aGlzLm5leHQoKTtcbiAgICAgIHJldHVybiBpZDtcbiAgICB9XG4gIH1cbiAgdHNQYXJzZVR5cGVQcmVkaWNhdGVBc3NlcnRzKCkge1xuICAgIGlmICh0aGlzLnN0YXRlLnR5cGUgIT09IDEwOSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBjb25zdCBjb250YWluc0VzYyA9IHRoaXMuc3RhdGUuY29udGFpbnNFc2M7XG4gICAgdGhpcy5uZXh0KCk7XG4gICAgaWYgKCF0b2tlbklzSWRlbnRpZmllcih0aGlzLnN0YXRlLnR5cGUpICYmICF0aGlzLm1hdGNoKDc4KSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBpZiAoY29udGFpbnNFc2MpIHtcbiAgICAgIHRoaXMucmFpc2UoRXJyb3JzLkludmFsaWRFc2NhcGVkUmVzZXJ2ZWRXb3JkLCB0aGlzLnN0YXRlLmxhc3RUb2tTdGFydExvYywge1xuICAgICAgICByZXNlcnZlZFdvcmQ6IFwiYXNzZXJ0c1wiXG4gICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgdHNQYXJzZVR5cGVBbm5vdGF0aW9uKGVhdENvbG9uID0gdHJ1ZSwgdCA9IHRoaXMuc3RhcnROb2RlKCkpIHtcbiAgICB0aGlzLnRzSW5UeXBlKCgpID0+IHtcbiAgICAgIGlmIChlYXRDb2xvbikgdGhpcy5leHBlY3QoMTQpO1xuICAgICAgdC50eXBlQW5ub3RhdGlvbiA9IHRoaXMudHNQYXJzZVR5cGUoKTtcbiAgICB9KTtcbiAgICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKHQsIFwiVFNUeXBlQW5ub3RhdGlvblwiKTtcbiAgfVxuICB0c1BhcnNlVHlwZSgpIHtcbiAgICBhc3NlcnQodGhpcy5zdGF0ZS5pblR5cGUpO1xuICAgIGNvbnN0IHR5cGUgPSB0aGlzLnRzUGFyc2VOb25Db25kaXRpb25hbFR5cGUoKTtcbiAgICBpZiAodGhpcy5zdGF0ZS5pbkRpc2FsbG93Q29uZGl0aW9uYWxUeXBlc0NvbnRleHQgfHwgdGhpcy5oYXNQcmVjZWRpbmdMaW5lQnJlYWsoKSB8fCAhdGhpcy5lYXQoODEpKSB7XG4gICAgICByZXR1cm4gdHlwZTtcbiAgICB9XG4gICAgY29uc3Qgbm9kZSA9IHRoaXMuc3RhcnROb2RlQXROb2RlKHR5cGUpO1xuICAgIG5vZGUuY2hlY2tUeXBlID0gdHlwZTtcbiAgICBub2RlLmV4dGVuZHNUeXBlID0gdGhpcy50c0luRGlzYWxsb3dDb25kaXRpb25hbFR5cGVzQ29udGV4dCgoKSA9PiB0aGlzLnRzUGFyc2VOb25Db25kaXRpb25hbFR5cGUoKSk7XG4gICAgdGhpcy5leHBlY3QoMTcpO1xuICAgIG5vZGUudHJ1ZVR5cGUgPSB0aGlzLnRzSW5BbGxvd0NvbmRpdGlvbmFsVHlwZXNDb250ZXh0KCgpID0+IHRoaXMudHNQYXJzZVR5cGUoKSk7XG4gICAgdGhpcy5leHBlY3QoMTQpO1xuICAgIG5vZGUuZmFsc2VUeXBlID0gdGhpcy50c0luQWxsb3dDb25kaXRpb25hbFR5cGVzQ29udGV4dCgoKSA9PiB0aGlzLnRzUGFyc2VUeXBlKCkpO1xuICAgIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJUU0NvbmRpdGlvbmFsVHlwZVwiKTtcbiAgfVxuICBpc0Fic3RyYWN0Q29uc3RydWN0b3JTaWduYXR1cmUoKSB7XG4gICAgcmV0dXJuIHRoaXMuaXNDb250ZXh0dWFsKDEyNCkgJiYgdGhpcy5pc0xvb2thaGVhZENvbnRleHR1YWwoXCJuZXdcIik7XG4gIH1cbiAgdHNQYXJzZU5vbkNvbmRpdGlvbmFsVHlwZSgpIHtcbiAgICBpZiAodGhpcy50c0lzU3RhcnRPZkZ1bmN0aW9uVHlwZSgpKSB7XG4gICAgICByZXR1cm4gdGhpcy50c1BhcnNlRnVuY3Rpb25PckNvbnN0cnVjdG9yVHlwZShcIlRTRnVuY3Rpb25UeXBlXCIpO1xuICAgIH1cbiAgICBpZiAodGhpcy5tYXRjaCg3NykpIHtcbiAgICAgIHJldHVybiB0aGlzLnRzUGFyc2VGdW5jdGlvbk9yQ29uc3RydWN0b3JUeXBlKFwiVFNDb25zdHJ1Y3RvclR5cGVcIik7XG4gICAgfSBlbHNlIGlmICh0aGlzLmlzQWJzdHJhY3RDb25zdHJ1Y3RvclNpZ25hdHVyZSgpKSB7XG4gICAgICByZXR1cm4gdGhpcy50c1BhcnNlRnVuY3Rpb25PckNvbnN0cnVjdG9yVHlwZShcIlRTQ29uc3RydWN0b3JUeXBlXCIsIHRydWUpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy50c1BhcnNlVW5pb25UeXBlT3JIaWdoZXIoKTtcbiAgfVxuICB0c1BhcnNlVHlwZUFzc2VydGlvbigpIHtcbiAgICBpZiAodGhpcy5nZXRQbHVnaW5PcHRpb24oXCJ0eXBlc2NyaXB0XCIsIFwiZGlzYWxsb3dBbWJpZ3VvdXNKU1hMaWtlXCIpKSB7XG4gICAgICB0aGlzLnJhaXNlKFRTRXJyb3JzLlJlc2VydmVkVHlwZUFzc2VydGlvbiwgdGhpcy5zdGF0ZS5zdGFydExvYyk7XG4gICAgfVxuICAgIGNvbnN0IG5vZGUgPSB0aGlzLnN0YXJ0Tm9kZSgpO1xuICAgIG5vZGUudHlwZUFubm90YXRpb24gPSB0aGlzLnRzSW5UeXBlKCgpID0+IHtcbiAgICAgIHRoaXMubmV4dCgpO1xuICAgICAgcmV0dXJuIHRoaXMubWF0Y2goNzUpID8gdGhpcy50c1BhcnNlVHlwZVJlZmVyZW5jZSgpIDogdGhpcy50c1BhcnNlVHlwZSgpO1xuICAgIH0pO1xuICAgIHRoaXMuZXhwZWN0KDQ4KTtcbiAgICBub2RlLmV4cHJlc3Npb24gPSB0aGlzLnBhcnNlTWF5YmVVbmFyeSgpO1xuICAgIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJUU1R5cGVBc3NlcnRpb25cIik7XG4gIH1cbiAgdHNQYXJzZUhlcml0YWdlQ2xhdXNlKHRva2VuKSB7XG4gICAgY29uc3Qgb3JpZ2luYWxTdGFydExvYyA9IHRoaXMuc3RhdGUuc3RhcnRMb2M7XG4gICAgY29uc3QgZGVsaW1pdGVkTGlzdCA9IHRoaXMudHNQYXJzZURlbGltaXRlZExpc3QoXCJIZXJpdGFnZUNsYXVzZUVsZW1lbnRcIiwgKCkgPT4ge1xuICAgICAgY29uc3Qgbm9kZSA9IHRoaXMuc3RhcnROb2RlKCk7XG4gICAgICBub2RlLmV4cHJlc3Npb24gPSB0aGlzLnRzUGFyc2VFbnRpdHlOYW1lKDEgfCAyKTtcbiAgICAgIGlmICh0aGlzLm1hdGNoKDQ3KSkge1xuICAgICAgICBub2RlLnR5cGVQYXJhbWV0ZXJzID0gdGhpcy50c1BhcnNlVHlwZUFyZ3VtZW50cygpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIlRTRXhwcmVzc2lvbldpdGhUeXBlQXJndW1lbnRzXCIpO1xuICAgIH0pO1xuICAgIGlmICghZGVsaW1pdGVkTGlzdC5sZW5ndGgpIHtcbiAgICAgIHRoaXMucmFpc2UoVFNFcnJvcnMuRW1wdHlIZXJpdGFnZUNsYXVzZVR5cGUsIG9yaWdpbmFsU3RhcnRMb2MsIHtcbiAgICAgICAgdG9rZW5cbiAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gZGVsaW1pdGVkTGlzdDtcbiAgfVxuICB0c1BhcnNlSW50ZXJmYWNlRGVjbGFyYXRpb24obm9kZSwgcHJvcGVydGllcyA9IHt9KSB7XG4gICAgaWYgKHRoaXMuaGFzRm9sbG93aW5nTGluZUJyZWFrKCkpIHJldHVybiBudWxsO1xuICAgIHRoaXMuZXhwZWN0Q29udGV4dHVhbCgxMjkpO1xuICAgIGlmIChwcm9wZXJ0aWVzLmRlY2xhcmUpIG5vZGUuZGVjbGFyZSA9IHRydWU7XG4gICAgaWYgKHRva2VuSXNJZGVudGlmaWVyKHRoaXMuc3RhdGUudHlwZSkpIHtcbiAgICAgIG5vZGUuaWQgPSB0aGlzLnBhcnNlSWRlbnRpZmllcigpO1xuICAgICAgdGhpcy5jaGVja0lkZW50aWZpZXIobm9kZS5pZCwgMTMwKTtcbiAgICB9IGVsc2Uge1xuICAgICAgbm9kZS5pZCA9IG51bGw7XG4gICAgICB0aGlzLnJhaXNlKFRTRXJyb3JzLk1pc3NpbmdJbnRlcmZhY2VOYW1lLCB0aGlzLnN0YXRlLnN0YXJ0TG9jKTtcbiAgICB9XG4gICAgbm9kZS50eXBlUGFyYW1ldGVycyA9IHRoaXMudHNUcnlQYXJzZVR5cGVQYXJhbWV0ZXJzKHRoaXMudHNQYXJzZUluT3V0Q29uc3RNb2RpZmllcnMpO1xuICAgIGlmICh0aGlzLmVhdCg4MSkpIHtcbiAgICAgIG5vZGUuZXh0ZW5kcyA9IHRoaXMudHNQYXJzZUhlcml0YWdlQ2xhdXNlKFwiZXh0ZW5kc1wiKTtcbiAgICB9XG4gICAgY29uc3QgYm9keSA9IHRoaXMuc3RhcnROb2RlKCk7XG4gICAgYm9keS5ib2R5ID0gdGhpcy50c0luVHlwZSh0aGlzLnRzUGFyc2VPYmplY3RUeXBlTWVtYmVycy5iaW5kKHRoaXMpKTtcbiAgICBub2RlLmJvZHkgPSB0aGlzLmZpbmlzaE5vZGUoYm9keSwgXCJUU0ludGVyZmFjZUJvZHlcIik7XG4gICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIlRTSW50ZXJmYWNlRGVjbGFyYXRpb25cIik7XG4gIH1cbiAgdHNQYXJzZVR5cGVBbGlhc0RlY2xhcmF0aW9uKG5vZGUpIHtcbiAgICBub2RlLmlkID0gdGhpcy5wYXJzZUlkZW50aWZpZXIoKTtcbiAgICB0aGlzLmNoZWNrSWRlbnRpZmllcihub2RlLmlkLCAyKTtcbiAgICBub2RlLnR5cGVBbm5vdGF0aW9uID0gdGhpcy50c0luVHlwZSgoKSA9PiB7XG4gICAgICBub2RlLnR5cGVQYXJhbWV0ZXJzID0gdGhpcy50c1RyeVBhcnNlVHlwZVBhcmFtZXRlcnModGhpcy50c1BhcnNlSW5PdXRNb2RpZmllcnMpO1xuICAgICAgdGhpcy5leHBlY3QoMjkpO1xuICAgICAgaWYgKHRoaXMuaXNDb250ZXh0dWFsKDExNCkgJiYgdGhpcy5sb29rYWhlYWRDaGFyQ29kZSgpICE9PSA0Nikge1xuICAgICAgICBjb25zdCBub2RlID0gdGhpcy5zdGFydE5vZGUoKTtcbiAgICAgICAgdGhpcy5uZXh0KCk7XG4gICAgICAgIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJUU0ludHJpbnNpY0tleXdvcmRcIik7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcy50c1BhcnNlVHlwZSgpO1xuICAgIH0pO1xuICAgIHRoaXMuc2VtaWNvbG9uKCk7XG4gICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIlRTVHlwZUFsaWFzRGVjbGFyYXRpb25cIik7XG4gIH1cbiAgdHNJblRvcExldmVsQ29udGV4dChjYikge1xuICAgIGlmICh0aGlzLmN1ckNvbnRleHQoKSAhPT0gdHlwZXMuYnJhY2UpIHtcbiAgICAgIGNvbnN0IG9sZENvbnRleHQgPSB0aGlzLnN0YXRlLmNvbnRleHQ7XG4gICAgICB0aGlzLnN0YXRlLmNvbnRleHQgPSBbb2xkQ29udGV4dFswXV07XG4gICAgICB0cnkge1xuICAgICAgICByZXR1cm4gY2IoKTtcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIHRoaXMuc3RhdGUuY29udGV4dCA9IG9sZENvbnRleHQ7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBjYigpO1xuICAgIH1cbiAgfVxuICB0c0luVHlwZShjYikge1xuICAgIGNvbnN0IG9sZEluVHlwZSA9IHRoaXMuc3RhdGUuaW5UeXBlO1xuICAgIHRoaXMuc3RhdGUuaW5UeXBlID0gdHJ1ZTtcbiAgICB0cnkge1xuICAgICAgcmV0dXJuIGNiKCk7XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIHRoaXMuc3RhdGUuaW5UeXBlID0gb2xkSW5UeXBlO1xuICAgIH1cbiAgfVxuICB0c0luRGlzYWxsb3dDb25kaXRpb25hbFR5cGVzQ29udGV4dChjYikge1xuICAgIGNvbnN0IG9sZEluRGlzYWxsb3dDb25kaXRpb25hbFR5cGVzQ29udGV4dCA9IHRoaXMuc3RhdGUuaW5EaXNhbGxvd0NvbmRpdGlvbmFsVHlwZXNDb250ZXh0O1xuICAgIHRoaXMuc3RhdGUuaW5EaXNhbGxvd0NvbmRpdGlvbmFsVHlwZXNDb250ZXh0ID0gdHJ1ZTtcbiAgICB0cnkge1xuICAgICAgcmV0dXJuIGNiKCk7XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIHRoaXMuc3RhdGUuaW5EaXNhbGxvd0NvbmRpdGlvbmFsVHlwZXNDb250ZXh0ID0gb2xkSW5EaXNhbGxvd0NvbmRpdGlvbmFsVHlwZXNDb250ZXh0O1xuICAgIH1cbiAgfVxuICB0c0luQWxsb3dDb25kaXRpb25hbFR5cGVzQ29udGV4dChjYikge1xuICAgIGNvbnN0IG9sZEluRGlzYWxsb3dDb25kaXRpb25hbFR5cGVzQ29udGV4dCA9IHRoaXMuc3RhdGUuaW5EaXNhbGxvd0NvbmRpdGlvbmFsVHlwZXNDb250ZXh0O1xuICAgIHRoaXMuc3RhdGUuaW5EaXNhbGxvd0NvbmRpdGlvbmFsVHlwZXNDb250ZXh0ID0gZmFsc2U7XG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiBjYigpO1xuICAgIH0gZmluYWxseSB7XG4gICAgICB0aGlzLnN0YXRlLmluRGlzYWxsb3dDb25kaXRpb25hbFR5cGVzQ29udGV4dCA9IG9sZEluRGlzYWxsb3dDb25kaXRpb25hbFR5cGVzQ29udGV4dDtcbiAgICB9XG4gIH1cbiAgdHNFYXRUaGVuUGFyc2VUeXBlKHRva2VuKSB7XG4gICAgaWYgKHRoaXMubWF0Y2godG9rZW4pKSB7XG4gICAgICByZXR1cm4gdGhpcy50c05leHRUaGVuUGFyc2VUeXBlKCk7XG4gICAgfVxuICB9XG4gIHRzRXhwZWN0VGhlblBhcnNlVHlwZSh0b2tlbikge1xuICAgIHJldHVybiB0aGlzLnRzSW5UeXBlKCgpID0+IHtcbiAgICAgIHRoaXMuZXhwZWN0KHRva2VuKTtcbiAgICAgIHJldHVybiB0aGlzLnRzUGFyc2VUeXBlKCk7XG4gICAgfSk7XG4gIH1cbiAgdHNOZXh0VGhlblBhcnNlVHlwZSgpIHtcbiAgICByZXR1cm4gdGhpcy50c0luVHlwZSgoKSA9PiB7XG4gICAgICB0aGlzLm5leHQoKTtcbiAgICAgIHJldHVybiB0aGlzLnRzUGFyc2VUeXBlKCk7XG4gICAgfSk7XG4gIH1cbiAgdHNQYXJzZUVudW1NZW1iZXIoKSB7XG4gICAgY29uc3Qgbm9kZSA9IHRoaXMuc3RhcnROb2RlKCk7XG4gICAgbm9kZS5pZCA9IHRoaXMubWF0Y2goMTM0KSA/IHN1cGVyLnBhcnNlU3RyaW5nTGl0ZXJhbCh0aGlzLnN0YXRlLnZhbHVlKSA6IHRoaXMucGFyc2VJZGVudGlmaWVyKHRydWUpO1xuICAgIGlmICh0aGlzLmVhdCgyOSkpIHtcbiAgICAgIG5vZGUuaW5pdGlhbGl6ZXIgPSBzdXBlci5wYXJzZU1heWJlQXNzaWduQWxsb3dJbigpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiVFNFbnVtTWVtYmVyXCIpO1xuICB9XG4gIHRzUGFyc2VFbnVtRGVjbGFyYXRpb24obm9kZSwgcHJvcGVydGllcyA9IHt9KSB7XG4gICAgaWYgKHByb3BlcnRpZXMuY29uc3QpIG5vZGUuY29uc3QgPSB0cnVlO1xuICAgIGlmIChwcm9wZXJ0aWVzLmRlY2xhcmUpIG5vZGUuZGVjbGFyZSA9IHRydWU7XG4gICAgdGhpcy5leHBlY3RDb250ZXh0dWFsKDEyNik7XG4gICAgbm9kZS5pZCA9IHRoaXMucGFyc2VJZGVudGlmaWVyKCk7XG4gICAgdGhpcy5jaGVja0lkZW50aWZpZXIobm9kZS5pZCwgbm9kZS5jb25zdCA/IDg5NzEgOiA4NDU5KTtcbiAgICB0aGlzLmV4cGVjdCg1KTtcbiAgICBub2RlLm1lbWJlcnMgPSB0aGlzLnRzUGFyc2VEZWxpbWl0ZWRMaXN0KFwiRW51bU1lbWJlcnNcIiwgdGhpcy50c1BhcnNlRW51bU1lbWJlci5iaW5kKHRoaXMpKTtcbiAgICB0aGlzLmV4cGVjdCg4KTtcbiAgICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiVFNFbnVtRGVjbGFyYXRpb25cIik7XG4gIH1cbiAgdHNQYXJzZUVudW1Cb2R5KCkge1xuICAgIGNvbnN0IG5vZGUgPSB0aGlzLnN0YXJ0Tm9kZSgpO1xuICAgIHRoaXMuZXhwZWN0KDUpO1xuICAgIG5vZGUubWVtYmVycyA9IHRoaXMudHNQYXJzZURlbGltaXRlZExpc3QoXCJFbnVtTWVtYmVyc1wiLCB0aGlzLnRzUGFyc2VFbnVtTWVtYmVyLmJpbmQodGhpcykpO1xuICAgIHRoaXMuZXhwZWN0KDgpO1xuICAgIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJUU0VudW1Cb2R5XCIpO1xuICB9XG4gIHRzUGFyc2VNb2R1bGVCbG9jaygpIHtcbiAgICBjb25zdCBub2RlID0gdGhpcy5zdGFydE5vZGUoKTtcbiAgICB0aGlzLnNjb3BlLmVudGVyKDApO1xuICAgIHRoaXMuZXhwZWN0KDUpO1xuICAgIHN1cGVyLnBhcnNlQmxvY2tPck1vZHVsZUJsb2NrQm9keShub2RlLmJvZHkgPSBbXSwgdW5kZWZpbmVkLCB0cnVlLCA4KTtcbiAgICB0aGlzLnNjb3BlLmV4aXQoKTtcbiAgICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiVFNNb2R1bGVCbG9ja1wiKTtcbiAgfVxuICB0c1BhcnNlTW9kdWxlT3JOYW1lc3BhY2VEZWNsYXJhdGlvbihub2RlLCBuZXN0ZWQgPSBmYWxzZSkge1xuICAgIG5vZGUuaWQgPSB0aGlzLnBhcnNlSWRlbnRpZmllcigpO1xuICAgIGlmICghbmVzdGVkKSB7XG4gICAgICB0aGlzLmNoZWNrSWRlbnRpZmllcihub2RlLmlkLCAxMDI0KTtcbiAgICB9XG4gICAgaWYgKHRoaXMuZWF0KDE2KSkge1xuICAgICAgY29uc3QgaW5uZXIgPSB0aGlzLnN0YXJ0Tm9kZSgpO1xuICAgICAgdGhpcy50c1BhcnNlTW9kdWxlT3JOYW1lc3BhY2VEZWNsYXJhdGlvbihpbm5lciwgdHJ1ZSk7XG4gICAgICBub2RlLmJvZHkgPSBpbm5lcjtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5zY29wZS5lbnRlcigxMDI0KTtcbiAgICAgIHRoaXMucHJvZFBhcmFtLmVudGVyKDApO1xuICAgICAgbm9kZS5ib2R5ID0gdGhpcy50c1BhcnNlTW9kdWxlQmxvY2soKTtcbiAgICAgIHRoaXMucHJvZFBhcmFtLmV4aXQoKTtcbiAgICAgIHRoaXMuc2NvcGUuZXhpdCgpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiVFNNb2R1bGVEZWNsYXJhdGlvblwiKTtcbiAgfVxuICB0c1BhcnNlQW1iaWVudEV4dGVybmFsTW9kdWxlRGVjbGFyYXRpb24obm9kZSkge1xuICAgIGlmICh0aGlzLmlzQ29udGV4dHVhbCgxMTIpKSB7XG4gICAgICBub2RlLmtpbmQgPSBcImdsb2JhbFwiO1xuICAgICAgbm9kZS5nbG9iYWwgPSB0cnVlO1xuICAgICAgbm9kZS5pZCA9IHRoaXMucGFyc2VJZGVudGlmaWVyKCk7XG4gICAgfSBlbHNlIGlmICh0aGlzLm1hdGNoKDEzNCkpIHtcbiAgICAgIG5vZGUua2luZCA9IFwibW9kdWxlXCI7XG4gICAgICBub2RlLmlkID0gc3VwZXIucGFyc2VTdHJpbmdMaXRlcmFsKHRoaXMuc3RhdGUudmFsdWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnVuZXhwZWN0ZWQoKTtcbiAgICB9XG4gICAgaWYgKHRoaXMubWF0Y2goNSkpIHtcbiAgICAgIHRoaXMuc2NvcGUuZW50ZXIoMTAyNCk7XG4gICAgICB0aGlzLnByb2RQYXJhbS5lbnRlcigwKTtcbiAgICAgIG5vZGUuYm9keSA9IHRoaXMudHNQYXJzZU1vZHVsZUJsb2NrKCk7XG4gICAgICB0aGlzLnByb2RQYXJhbS5leGl0KCk7XG4gICAgICB0aGlzLnNjb3BlLmV4aXQoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5zZW1pY29sb24oKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIlRTTW9kdWxlRGVjbGFyYXRpb25cIik7XG4gIH1cbiAgdHNQYXJzZUltcG9ydEVxdWFsc0RlY2xhcmF0aW9uKG5vZGUsIG1heWJlRGVmYXVsdElkZW50aWZpZXIsIGlzRXhwb3J0KSB7XG4gICAgbm9kZS5pc0V4cG9ydCA9IGlzRXhwb3J0IHx8IGZhbHNlO1xuICAgIG5vZGUuaWQgPSBtYXliZURlZmF1bHRJZGVudGlmaWVyIHx8IHRoaXMucGFyc2VJZGVudGlmaWVyKCk7XG4gICAgdGhpcy5jaGVja0lkZW50aWZpZXIobm9kZS5pZCwgNDA5Nik7XG4gICAgdGhpcy5leHBlY3QoMjkpO1xuICAgIGNvbnN0IG1vZHVsZVJlZmVyZW5jZSA9IHRoaXMudHNQYXJzZU1vZHVsZVJlZmVyZW5jZSgpO1xuICAgIGlmIChub2RlLmltcG9ydEtpbmQgPT09IFwidHlwZVwiICYmIG1vZHVsZVJlZmVyZW5jZS50eXBlICE9PSBcIlRTRXh0ZXJuYWxNb2R1bGVSZWZlcmVuY2VcIikge1xuICAgICAgdGhpcy5yYWlzZShUU0Vycm9ycy5JbXBvcnRBbGlhc0hhc0ltcG9ydFR5cGUsIG1vZHVsZVJlZmVyZW5jZSk7XG4gICAgfVxuICAgIG5vZGUubW9kdWxlUmVmZXJlbmNlID0gbW9kdWxlUmVmZXJlbmNlO1xuICAgIHRoaXMuc2VtaWNvbG9uKCk7XG4gICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIlRTSW1wb3J0RXF1YWxzRGVjbGFyYXRpb25cIik7XG4gIH1cbiAgdHNJc0V4dGVybmFsTW9kdWxlUmVmZXJlbmNlKCkge1xuICAgIHJldHVybiB0aGlzLmlzQ29udGV4dHVhbCgxMTkpICYmIHRoaXMubG9va2FoZWFkQ2hhckNvZGUoKSA9PT0gNDA7XG4gIH1cbiAgdHNQYXJzZU1vZHVsZVJlZmVyZW5jZSgpIHtcbiAgICByZXR1cm4gdGhpcy50c0lzRXh0ZXJuYWxNb2R1bGVSZWZlcmVuY2UoKSA/IHRoaXMudHNQYXJzZUV4dGVybmFsTW9kdWxlUmVmZXJlbmNlKCkgOiB0aGlzLnRzUGFyc2VFbnRpdHlOYW1lKDApO1xuICB9XG4gIHRzUGFyc2VFeHRlcm5hbE1vZHVsZVJlZmVyZW5jZSgpIHtcbiAgICBjb25zdCBub2RlID0gdGhpcy5zdGFydE5vZGUoKTtcbiAgICB0aGlzLmV4cGVjdENvbnRleHR1YWwoMTE5KTtcbiAgICB0aGlzLmV4cGVjdCgxMCk7XG4gICAgaWYgKCF0aGlzLm1hdGNoKDEzNCkpIHtcbiAgICAgIHRoaXMudW5leHBlY3RlZCgpO1xuICAgIH1cbiAgICBub2RlLmV4cHJlc3Npb24gPSBzdXBlci5wYXJzZUV4cHJBdG9tKCk7XG4gICAgdGhpcy5leHBlY3QoMTEpO1xuICAgIHRoaXMuc2F3VW5hbWJpZ3VvdXNFU00gPSB0cnVlO1xuICAgIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJUU0V4dGVybmFsTW9kdWxlUmVmZXJlbmNlXCIpO1xuICB9XG4gIHRzTG9va0FoZWFkKGYpIHtcbiAgICBjb25zdCBzdGF0ZSA9IHRoaXMuc3RhdGUuY2xvbmUoKTtcbiAgICBjb25zdCByZXMgPSBmKCk7XG4gICAgdGhpcy5zdGF0ZSA9IHN0YXRlO1xuICAgIHJldHVybiByZXM7XG4gIH1cbiAgdHNUcnlQYXJzZUFuZENhdGNoKGYpIHtcbiAgICBjb25zdCByZXN1bHQgPSB0aGlzLnRyeVBhcnNlKGFib3J0ID0+IGYoKSB8fCBhYm9ydCgpKTtcbiAgICBpZiAocmVzdWx0LmFib3J0ZWQgfHwgIXJlc3VsdC5ub2RlKSByZXR1cm47XG4gICAgaWYgKHJlc3VsdC5lcnJvcikgdGhpcy5zdGF0ZSA9IHJlc3VsdC5mYWlsU3RhdGU7XG4gICAgcmV0dXJuIHJlc3VsdC5ub2RlO1xuICB9XG4gIHRzVHJ5UGFyc2UoZikge1xuICAgIGNvbnN0IHN0YXRlID0gdGhpcy5zdGF0ZS5jbG9uZSgpO1xuICAgIGNvbnN0IHJlc3VsdCA9IGYoKTtcbiAgICBpZiAocmVzdWx0ICE9PSB1bmRlZmluZWQgJiYgcmVzdWx0ICE9PSBmYWxzZSkge1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgdGhpcy5zdGF0ZSA9IHN0YXRlO1xuICB9XG4gIHRzVHJ5UGFyc2VEZWNsYXJlKG5vZGUpIHtcbiAgICBpZiAodGhpcy5pc0xpbmVUZXJtaW5hdG9yKCkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3Qgc3RhcnRUeXBlID0gdGhpcy5zdGF0ZS50eXBlO1xuICAgIHJldHVybiB0aGlzLnRzSW5BbWJpZW50Q29udGV4dCgoKSA9PiB7XG4gICAgICBzd2l0Y2ggKHN0YXJ0VHlwZSkge1xuICAgICAgICBjYXNlIDY4OlxuICAgICAgICAgIG5vZGUuZGVjbGFyZSA9IHRydWU7XG4gICAgICAgICAgcmV0dXJuIHN1cGVyLnBhcnNlRnVuY3Rpb25TdGF0ZW1lbnQobm9kZSwgZmFsc2UsIGZhbHNlKTtcbiAgICAgICAgY2FzZSA4MDpcbiAgICAgICAgICBub2RlLmRlY2xhcmUgPSB0cnVlO1xuICAgICAgICAgIHJldHVybiB0aGlzLnBhcnNlQ2xhc3Mobm9kZSwgdHJ1ZSwgZmFsc2UpO1xuICAgICAgICBjYXNlIDEyNjpcbiAgICAgICAgICByZXR1cm4gdGhpcy50c1BhcnNlRW51bURlY2xhcmF0aW9uKG5vZGUsIHtcbiAgICAgICAgICAgIGRlY2xhcmU6IHRydWVcbiAgICAgICAgICB9KTtcbiAgICAgICAgY2FzZSAxMTI6XG4gICAgICAgICAgcmV0dXJuIHRoaXMudHNQYXJzZUFtYmllbnRFeHRlcm5hbE1vZHVsZURlY2xhcmF0aW9uKG5vZGUpO1xuICAgICAgICBjYXNlIDEwMDpcbiAgICAgICAgICBpZiAodGhpcy5zdGF0ZS5jb250YWluc0VzYykge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgY2FzZSA3NTpcbiAgICAgICAgY2FzZSA3NDpcbiAgICAgICAgICBpZiAoIXRoaXMubWF0Y2goNzUpIHx8ICF0aGlzLmlzTG9va2FoZWFkQ29udGV4dHVhbChcImVudW1cIikpIHtcbiAgICAgICAgICAgIG5vZGUuZGVjbGFyZSA9IHRydWU7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5wYXJzZVZhclN0YXRlbWVudChub2RlLCB0aGlzLnN0YXRlLnZhbHVlLCB0cnVlKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdGhpcy5leHBlY3QoNzUpO1xuICAgICAgICAgIHJldHVybiB0aGlzLnRzUGFyc2VFbnVtRGVjbGFyYXRpb24obm9kZSwge1xuICAgICAgICAgICAgY29uc3Q6IHRydWUsXG4gICAgICAgICAgICBkZWNsYXJlOiB0cnVlXG4gICAgICAgICAgfSk7XG4gICAgICAgIGNhc2UgMTA3OlxuICAgICAgICAgIGlmICh0aGlzLmlzVXNpbmcoKSkge1xuICAgICAgICAgICAgdGhpcy5yYWlzZShUU0Vycm9ycy5JbnZhbGlkTW9kaWZpZXJPblVzaW5nRGVjbGFyYXRpb24sIHRoaXMuc3RhdGUuc3RhcnRMb2MsIFwiZGVjbGFyZVwiKTtcbiAgICAgICAgICAgIG5vZGUuZGVjbGFyZSA9IHRydWU7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5wYXJzZVZhclN0YXRlbWVudChub2RlLCBcInVzaW5nXCIsIHRydWUpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSA5NjpcbiAgICAgICAgICBpZiAodGhpcy5pc0F3YWl0VXNpbmcoKSkge1xuICAgICAgICAgICAgdGhpcy5yYWlzZShUU0Vycm9ycy5JbnZhbGlkTW9kaWZpZXJPbkF3YWl0VXNpbmdEZWNsYXJhdGlvbiwgdGhpcy5zdGF0ZS5zdGFydExvYywgXCJkZWNsYXJlXCIpO1xuICAgICAgICAgICAgbm9kZS5kZWNsYXJlID0gdHJ1ZTtcbiAgICAgICAgICAgIHRoaXMubmV4dCgpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VWYXJTdGF0ZW1lbnQobm9kZSwgXCJhd2FpdCB1c2luZ1wiLCB0cnVlKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMTI5OlxuICAgICAgICAgIHtcbiAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IHRoaXMudHNQYXJzZUludGVyZmFjZURlY2xhcmF0aW9uKG5vZGUsIHtcbiAgICAgICAgICAgICAgZGVjbGFyZTogdHJ1ZVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBpZiAocmVzdWx0KSByZXR1cm4gcmVzdWx0O1xuICAgICAgICAgIH1cbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICBpZiAodG9rZW5Jc0lkZW50aWZpZXIoc3RhcnRUeXBlKSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMudHNQYXJzZURlY2xhcmF0aW9uKG5vZGUsIHRoaXMuc3RhdGUudHlwZSwgdHJ1ZSwgbnVsbCk7XG4gICAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuICB9XG4gIHRzVHJ5UGFyc2VFeHBvcnREZWNsYXJhdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy50c1BhcnNlRGVjbGFyYXRpb24odGhpcy5zdGFydE5vZGUoKSwgdGhpcy5zdGF0ZS50eXBlLCB0cnVlLCBudWxsKTtcbiAgfVxuICB0c1BhcnNlRGVjbGFyYXRpb24obm9kZSwgdHlwZSwgbmV4dCwgZGVjb3JhdG9ycykge1xuICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgY2FzZSAxMjQ6XG4gICAgICAgIGlmICh0aGlzLnRzQ2hlY2tMaW5lVGVybWluYXRvcihuZXh0KSAmJiAodGhpcy5tYXRjaCg4MCkgfHwgdG9rZW5Jc0lkZW50aWZpZXIodGhpcy5zdGF0ZS50eXBlKSkpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy50c1BhcnNlQWJzdHJhY3REZWNsYXJhdGlvbihub2RlLCBkZWNvcmF0b3JzKTtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgMTI3OlxuICAgICAgICBpZiAodGhpcy50c0NoZWNrTGluZVRlcm1pbmF0b3IobmV4dCkpIHtcbiAgICAgICAgICBpZiAodGhpcy5tYXRjaCgxMzQpKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy50c1BhcnNlQW1iaWVudEV4dGVybmFsTW9kdWxlRGVjbGFyYXRpb24obm9kZSk7XG4gICAgICAgICAgfSBlbHNlIGlmICh0b2tlbklzSWRlbnRpZmllcih0aGlzLnN0YXRlLnR5cGUpKSB7XG4gICAgICAgICAgICBub2RlLmtpbmQgPSBcIm1vZHVsZVwiO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMudHNQYXJzZU1vZHVsZU9yTmFtZXNwYWNlRGVjbGFyYXRpb24obm9kZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAxMjg6XG4gICAgICAgIGlmICh0aGlzLnRzQ2hlY2tMaW5lVGVybWluYXRvcihuZXh0KSAmJiB0b2tlbklzSWRlbnRpZmllcih0aGlzLnN0YXRlLnR5cGUpKSB7XG4gICAgICAgICAgbm9kZS5raW5kID0gXCJuYW1lc3BhY2VcIjtcbiAgICAgICAgICByZXR1cm4gdGhpcy50c1BhcnNlTW9kdWxlT3JOYW1lc3BhY2VEZWNsYXJhdGlvbihub2RlKTtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgMTMwOlxuICAgICAgICBpZiAodGhpcy50c0NoZWNrTGluZVRlcm1pbmF0b3IobmV4dCkgJiYgdG9rZW5Jc0lkZW50aWZpZXIodGhpcy5zdGF0ZS50eXBlKSkge1xuICAgICAgICAgIHJldHVybiB0aGlzLnRzUGFyc2VUeXBlQWxpYXNEZWNsYXJhdGlvbihub2RlKTtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICB9XG4gIH1cbiAgdHNDaGVja0xpbmVUZXJtaW5hdG9yKG5leHQpIHtcbiAgICBpZiAobmV4dCkge1xuICAgICAgaWYgKHRoaXMuaGFzRm9sbG93aW5nTGluZUJyZWFrKCkpIHJldHVybiBmYWxzZTtcbiAgICAgIHRoaXMubmV4dCgpO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHJldHVybiAhdGhpcy5pc0xpbmVUZXJtaW5hdG9yKCk7XG4gIH1cbiAgdHNUcnlQYXJzZUdlbmVyaWNBc3luY0Fycm93RnVuY3Rpb24oc3RhcnRMb2MpIHtcbiAgICBpZiAoIXRoaXMubWF0Y2goNDcpKSByZXR1cm47XG4gICAgY29uc3Qgb2xkTWF5YmVJbkFycm93UGFyYW1ldGVycyA9IHRoaXMuc3RhdGUubWF5YmVJbkFycm93UGFyYW1ldGVycztcbiAgICB0aGlzLnN0YXRlLm1heWJlSW5BcnJvd1BhcmFtZXRlcnMgPSB0cnVlO1xuICAgIGNvbnN0IHJlcyA9IHRoaXMudHNUcnlQYXJzZUFuZENhdGNoKCgpID0+IHtcbiAgICAgIGNvbnN0IG5vZGUgPSB0aGlzLnN0YXJ0Tm9kZUF0KHN0YXJ0TG9jKTtcbiAgICAgIG5vZGUudHlwZVBhcmFtZXRlcnMgPSB0aGlzLnRzUGFyc2VUeXBlUGFyYW1ldGVycyh0aGlzLnRzUGFyc2VDb25zdE1vZGlmaWVyKTtcbiAgICAgIHN1cGVyLnBhcnNlRnVuY3Rpb25QYXJhbXMobm9kZSk7XG4gICAgICBub2RlLnJldHVyblR5cGUgPSB0aGlzLnRzVHJ5UGFyc2VUeXBlT3JUeXBlUHJlZGljYXRlQW5ub3RhdGlvbigpO1xuICAgICAgdGhpcy5leHBlY3QoMTkpO1xuICAgICAgcmV0dXJuIG5vZGU7XG4gICAgfSk7XG4gICAgdGhpcy5zdGF0ZS5tYXliZUluQXJyb3dQYXJhbWV0ZXJzID0gb2xkTWF5YmVJbkFycm93UGFyYW1ldGVycztcbiAgICBpZiAoIXJlcykgcmV0dXJuO1xuICAgIHJldHVybiBzdXBlci5wYXJzZUFycm93RXhwcmVzc2lvbihyZXMsIG51bGwsIHRydWUpO1xuICB9XG4gIHRzUGFyc2VUeXBlQXJndW1lbnRzSW5FeHByZXNzaW9uKCkge1xuICAgIGlmICh0aGlzLnJlU2Nhbl9sdCgpICE9PSA0NykgcmV0dXJuO1xuICAgIHJldHVybiB0aGlzLnRzUGFyc2VUeXBlQXJndW1lbnRzKCk7XG4gIH1cbiAgdHNQYXJzZVR5cGVBcmd1bWVudHMoKSB7XG4gICAgY29uc3Qgbm9kZSA9IHRoaXMuc3RhcnROb2RlKCk7XG4gICAgbm9kZS5wYXJhbXMgPSB0aGlzLnRzSW5UeXBlKCgpID0+IHRoaXMudHNJblRvcExldmVsQ29udGV4dCgoKSA9PiB7XG4gICAgICB0aGlzLmV4cGVjdCg0Nyk7XG4gICAgICByZXR1cm4gdGhpcy50c1BhcnNlRGVsaW1pdGVkTGlzdChcIlR5cGVQYXJhbWV0ZXJzT3JBcmd1bWVudHNcIiwgdGhpcy50c1BhcnNlVHlwZS5iaW5kKHRoaXMpKTtcbiAgICB9KSk7XG4gICAgaWYgKG5vZGUucGFyYW1zLmxlbmd0aCA9PT0gMCkge1xuICAgICAgdGhpcy5yYWlzZShUU0Vycm9ycy5FbXB0eVR5cGVBcmd1bWVudHMsIG5vZGUpO1xuICAgIH0gZWxzZSBpZiAoIXRoaXMuc3RhdGUuaW5UeXBlICYmIHRoaXMuY3VyQ29udGV4dCgpID09PSB0eXBlcy5icmFjZSkge1xuICAgICAgdGhpcy5yZVNjYW5fbHRfZ3QoKTtcbiAgICB9XG4gICAgdGhpcy5leHBlY3QoNDgpO1xuICAgIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJUU1R5cGVQYXJhbWV0ZXJJbnN0YW50aWF0aW9uXCIpO1xuICB9XG4gIHRzSXNEZWNsYXJhdGlvblN0YXJ0KCkge1xuICAgIHJldHVybiB0b2tlbklzVFNEZWNsYXJhdGlvblN0YXJ0KHRoaXMuc3RhdGUudHlwZSk7XG4gIH1cbiAgaXNFeHBvcnREZWZhdWx0U3BlY2lmaWVyKCkge1xuICAgIGlmICh0aGlzLnRzSXNEZWNsYXJhdGlvblN0YXJ0KCkpIHJldHVybiBmYWxzZTtcbiAgICByZXR1cm4gc3VwZXIuaXNFeHBvcnREZWZhdWx0U3BlY2lmaWVyKCk7XG4gIH1cbiAgcGFyc2VCaW5kaW5nRWxlbWVudChmbGFncywgZGVjb3JhdG9ycykge1xuICAgIGNvbnN0IHN0YXJ0TG9jID0gZGVjb3JhdG9ycy5sZW5ndGggPyBkZWNvcmF0b3JzWzBdLmxvYy5zdGFydCA6IHRoaXMuc3RhdGUuc3RhcnRMb2M7XG4gICAgY29uc3QgbW9kaWZpZWQgPSB7fTtcbiAgICB0aGlzLnRzUGFyc2VNb2RpZmllcnMoe1xuICAgICAgYWxsb3dlZE1vZGlmaWVyczogW1wicHVibGljXCIsIFwicHJpdmF0ZVwiLCBcInByb3RlY3RlZFwiLCBcIm92ZXJyaWRlXCIsIFwicmVhZG9ubHlcIl1cbiAgICB9LCBtb2RpZmllZCk7XG4gICAgY29uc3QgYWNjZXNzaWJpbGl0eSA9IG1vZGlmaWVkLmFjY2Vzc2liaWxpdHk7XG4gICAgY29uc3Qgb3ZlcnJpZGUgPSBtb2RpZmllZC5vdmVycmlkZTtcbiAgICBjb25zdCByZWFkb25seSA9IG1vZGlmaWVkLnJlYWRvbmx5O1xuICAgIGlmICghKGZsYWdzICYgNCkgJiYgKGFjY2Vzc2liaWxpdHkgfHwgcmVhZG9ubHkgfHwgb3ZlcnJpZGUpKSB7XG4gICAgICB0aGlzLnJhaXNlKFRTRXJyb3JzLlVuZXhwZWN0ZWRQYXJhbWV0ZXJNb2RpZmllciwgc3RhcnRMb2MpO1xuICAgIH1cbiAgICBjb25zdCBsZWZ0ID0gdGhpcy5wYXJzZU1heWJlRGVmYXVsdCgpO1xuICAgIGlmIChmbGFncyAmIDIpIHtcbiAgICAgIHRoaXMucGFyc2VGdW5jdGlvblBhcmFtVHlwZShsZWZ0KTtcbiAgICB9XG4gICAgY29uc3QgZWx0ID0gdGhpcy5wYXJzZU1heWJlRGVmYXVsdChsZWZ0LmxvYy5zdGFydCwgbGVmdCk7XG4gICAgaWYgKGFjY2Vzc2liaWxpdHkgfHwgcmVhZG9ubHkgfHwgb3ZlcnJpZGUpIHtcbiAgICAgIGNvbnN0IHBwID0gdGhpcy5zdGFydE5vZGVBdChzdGFydExvYyk7XG4gICAgICBpZiAoZGVjb3JhdG9ycy5sZW5ndGgpIHtcbiAgICAgICAgcHAuZGVjb3JhdG9ycyA9IGRlY29yYXRvcnM7XG4gICAgICB9XG4gICAgICBpZiAoYWNjZXNzaWJpbGl0eSkgcHAuYWNjZXNzaWJpbGl0eSA9IGFjY2Vzc2liaWxpdHk7XG4gICAgICBpZiAocmVhZG9ubHkpIHBwLnJlYWRvbmx5ID0gcmVhZG9ubHk7XG4gICAgICBpZiAob3ZlcnJpZGUpIHBwLm92ZXJyaWRlID0gb3ZlcnJpZGU7XG4gICAgICBpZiAoZWx0LnR5cGUgIT09IFwiSWRlbnRpZmllclwiICYmIGVsdC50eXBlICE9PSBcIkFzc2lnbm1lbnRQYXR0ZXJuXCIpIHtcbiAgICAgICAgdGhpcy5yYWlzZShUU0Vycm9ycy5VbnN1cHBvcnRlZFBhcmFtZXRlclByb3BlcnR5S2luZCwgcHApO1xuICAgICAgfVxuICAgICAgcHAucGFyYW1ldGVyID0gZWx0O1xuICAgICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShwcCwgXCJUU1BhcmFtZXRlclByb3BlcnR5XCIpO1xuICAgIH1cbiAgICBpZiAoZGVjb3JhdG9ycy5sZW5ndGgpIHtcbiAgICAgIGxlZnQuZGVjb3JhdG9ycyA9IGRlY29yYXRvcnM7XG4gICAgfVxuICAgIHJldHVybiBlbHQ7XG4gIH1cbiAgaXNTaW1wbGVQYXJhbWV0ZXIobm9kZSkge1xuICAgIHJldHVybiBub2RlLnR5cGUgPT09IFwiVFNQYXJhbWV0ZXJQcm9wZXJ0eVwiICYmIHN1cGVyLmlzU2ltcGxlUGFyYW1ldGVyKG5vZGUucGFyYW1ldGVyKSB8fCBzdXBlci5pc1NpbXBsZVBhcmFtZXRlcihub2RlKTtcbiAgfVxuICB0c0Rpc2FsbG93T3B0aW9uYWxQYXR0ZXJuKG5vZGUpIHtcbiAgICBmb3IgKGNvbnN0IHBhcmFtIG9mIG5vZGUucGFyYW1zKSB7XG4gICAgICBpZiAocGFyYW0udHlwZSAhPT0gXCJJZGVudGlmaWVyXCIgJiYgcGFyYW0ub3B0aW9uYWwgJiYgIXRoaXMuc3RhdGUuaXNBbWJpZW50Q29udGV4dCkge1xuICAgICAgICB0aGlzLnJhaXNlKFRTRXJyb3JzLlBhdHRlcm5Jc09wdGlvbmFsLCBwYXJhbSk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHNldEFycm93RnVuY3Rpb25QYXJhbWV0ZXJzKG5vZGUsIHBhcmFtcywgdHJhaWxpbmdDb21tYUxvYykge1xuICAgIHN1cGVyLnNldEFycm93RnVuY3Rpb25QYXJhbWV0ZXJzKG5vZGUsIHBhcmFtcywgdHJhaWxpbmdDb21tYUxvYyk7XG4gICAgdGhpcy50c0Rpc2FsbG93T3B0aW9uYWxQYXR0ZXJuKG5vZGUpO1xuICB9XG4gIHBhcnNlRnVuY3Rpb25Cb2R5QW5kRmluaXNoKG5vZGUsIHR5cGUsIGlzTWV0aG9kID0gZmFsc2UpIHtcbiAgICBpZiAodGhpcy5tYXRjaCgxNCkpIHtcbiAgICAgIG5vZGUucmV0dXJuVHlwZSA9IHRoaXMudHNQYXJzZVR5cGVPclR5cGVQcmVkaWNhdGVBbm5vdGF0aW9uKDE0KTtcbiAgICB9XG4gICAgY29uc3QgYm9kaWxlc3NUeXBlID0gdHlwZSA9PT0gXCJGdW5jdGlvbkRlY2xhcmF0aW9uXCIgPyBcIlRTRGVjbGFyZUZ1bmN0aW9uXCIgOiB0eXBlID09PSBcIkNsYXNzTWV0aG9kXCIgfHwgdHlwZSA9PT0gXCJDbGFzc1ByaXZhdGVNZXRob2RcIiA/IFwiVFNEZWNsYXJlTWV0aG9kXCIgOiB1bmRlZmluZWQ7XG4gICAgaWYgKGJvZGlsZXNzVHlwZSAmJiAhdGhpcy5tYXRjaCg1KSAmJiB0aGlzLmlzTGluZVRlcm1pbmF0b3IoKSkge1xuICAgICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBib2RpbGVzc1R5cGUpO1xuICAgIH1cbiAgICBpZiAoYm9kaWxlc3NUeXBlID09PSBcIlRTRGVjbGFyZUZ1bmN0aW9uXCIgJiYgdGhpcy5zdGF0ZS5pc0FtYmllbnRDb250ZXh0KSB7XG4gICAgICB0aGlzLnJhaXNlKFRTRXJyb3JzLkRlY2xhcmVGdW5jdGlvbkhhc0ltcGxlbWVudGF0aW9uLCBub2RlKTtcbiAgICAgIGlmIChub2RlLmRlY2xhcmUpIHtcbiAgICAgICAgcmV0dXJuIHN1cGVyLnBhcnNlRnVuY3Rpb25Cb2R5QW5kRmluaXNoKG5vZGUsIGJvZGlsZXNzVHlwZSwgaXNNZXRob2QpO1xuICAgICAgfVxuICAgIH1cbiAgICB0aGlzLnRzRGlzYWxsb3dPcHRpb25hbFBhdHRlcm4obm9kZSk7XG4gICAgcmV0dXJuIHN1cGVyLnBhcnNlRnVuY3Rpb25Cb2R5QW5kRmluaXNoKG5vZGUsIHR5cGUsIGlzTWV0aG9kKTtcbiAgfVxuICByZWdpc3RlckZ1bmN0aW9uU3RhdGVtZW50SWQobm9kZSkge1xuICAgIGlmICghbm9kZS5ib2R5ICYmIG5vZGUuaWQpIHtcbiAgICAgIHRoaXMuY2hlY2tJZGVudGlmaWVyKG5vZGUuaWQsIDEwMjQpO1xuICAgIH0gZWxzZSB7XG4gICAgICBzdXBlci5yZWdpc3RlckZ1bmN0aW9uU3RhdGVtZW50SWQobm9kZSk7XG4gICAgfVxuICB9XG4gIHRzQ2hlY2tGb3JJbnZhbGlkVHlwZUNhc3RzKGl0ZW1zKSB7XG4gICAgaXRlbXMuZm9yRWFjaChub2RlID0+IHtcbiAgICAgIGlmICgobm9kZSA9PSBudWxsID8gdm9pZCAwIDogbm9kZS50eXBlKSA9PT0gXCJUU1R5cGVDYXN0RXhwcmVzc2lvblwiKSB7XG4gICAgICAgIHRoaXMucmFpc2UoVFNFcnJvcnMuVW5leHBlY3RlZFR5cGVBbm5vdGF0aW9uLCBub2RlLnR5cGVBbm5vdGF0aW9uKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuICB0b1JlZmVyZW5jZWRMaXN0KGV4cHJMaXN0LCBpc0luUGFyZW5zKSB7XG4gICAgdGhpcy50c0NoZWNrRm9ySW52YWxpZFR5cGVDYXN0cyhleHByTGlzdCk7XG4gICAgcmV0dXJuIGV4cHJMaXN0O1xuICB9XG4gIHBhcnNlQXJyYXlMaWtlKGNsb3NlLCBpc1R1cGxlLCByZWZFeHByZXNzaW9uRXJyb3JzKSB7XG4gICAgY29uc3Qgbm9kZSA9IHN1cGVyLnBhcnNlQXJyYXlMaWtlKGNsb3NlLCBpc1R1cGxlLCByZWZFeHByZXNzaW9uRXJyb3JzKTtcbiAgICBpZiAobm9kZS50eXBlID09PSBcIkFycmF5RXhwcmVzc2lvblwiKSB7XG4gICAgICB0aGlzLnRzQ2hlY2tGb3JJbnZhbGlkVHlwZUNhc3RzKG5vZGUuZWxlbWVudHMpO1xuICAgIH1cbiAgICByZXR1cm4gbm9kZTtcbiAgfVxuICBwYXJzZVN1YnNjcmlwdChiYXNlLCBzdGFydExvYywgbm9DYWxscywgc3RhdGUpIHtcbiAgICBpZiAoIXRoaXMuaGFzUHJlY2VkaW5nTGluZUJyZWFrKCkgJiYgdGhpcy5tYXRjaCgzNSkpIHtcbiAgICAgIHRoaXMuc3RhdGUuY2FuU3RhcnRKU1hFbGVtZW50ID0gZmFsc2U7XG4gICAgICB0aGlzLm5leHQoKTtcbiAgICAgIGNvbnN0IG5vbk51bGxFeHByZXNzaW9uID0gdGhpcy5zdGFydE5vZGVBdChzdGFydExvYyk7XG4gICAgICBub25OdWxsRXhwcmVzc2lvbi5leHByZXNzaW9uID0gYmFzZTtcbiAgICAgIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9uTnVsbEV4cHJlc3Npb24sIFwiVFNOb25OdWxsRXhwcmVzc2lvblwiKTtcbiAgICB9XG4gICAgbGV0IGlzT3B0aW9uYWxDYWxsID0gZmFsc2U7XG4gICAgaWYgKHRoaXMubWF0Y2goMTgpICYmIHRoaXMubG9va2FoZWFkQ2hhckNvZGUoKSA9PT0gNjApIHtcbiAgICAgIGlmIChub0NhbGxzKSB7XG4gICAgICAgIHN0YXRlLnN0b3AgPSB0cnVlO1xuICAgICAgICByZXR1cm4gYmFzZTtcbiAgICAgIH1cbiAgICAgIHN0YXRlLm9wdGlvbmFsQ2hhaW5NZW1iZXIgPSBpc09wdGlvbmFsQ2FsbCA9IHRydWU7XG4gICAgICB0aGlzLm5leHQoKTtcbiAgICB9XG4gICAgaWYgKHRoaXMubWF0Y2goNDcpIHx8IHRoaXMubWF0Y2goNTEpKSB7XG4gICAgICBsZXQgbWlzc2luZ1BhcmVuRXJyb3JMb2M7XG4gICAgICBjb25zdCByZXN1bHQgPSB0aGlzLnRzVHJ5UGFyc2VBbmRDYXRjaCgoKSA9PiB7XG4gICAgICAgIGlmICghbm9DYWxscyAmJiB0aGlzLmF0UG9zc2libGVBc3luY0Fycm93KGJhc2UpKSB7XG4gICAgICAgICAgY29uc3QgYXN5bmNBcnJvd0ZuID0gdGhpcy50c1RyeVBhcnNlR2VuZXJpY0FzeW5jQXJyb3dGdW5jdGlvbihzdGFydExvYyk7XG4gICAgICAgICAgaWYgKGFzeW5jQXJyb3dGbikge1xuICAgICAgICAgICAgc3RhdGUuc3RvcCA9IHRydWU7XG4gICAgICAgICAgICByZXR1cm4gYXN5bmNBcnJvd0ZuO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjb25zdCB0eXBlQXJndW1lbnRzID0gdGhpcy50c1BhcnNlVHlwZUFyZ3VtZW50c0luRXhwcmVzc2lvbigpO1xuICAgICAgICBpZiAoIXR5cGVBcmd1bWVudHMpIHJldHVybjtcbiAgICAgICAgaWYgKGlzT3B0aW9uYWxDYWxsICYmICF0aGlzLm1hdGNoKDEwKSkge1xuICAgICAgICAgIG1pc3NpbmdQYXJlbkVycm9yTG9jID0gdGhpcy5zdGF0ZS5jdXJQb3NpdGlvbigpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAodG9rZW5Jc1RlbXBsYXRlKHRoaXMuc3RhdGUudHlwZSkpIHtcbiAgICAgICAgICBjb25zdCByZXN1bHQgPSBzdXBlci5wYXJzZVRhZ2dlZFRlbXBsYXRlRXhwcmVzc2lvbihiYXNlLCBzdGFydExvYywgc3RhdGUpO1xuICAgICAgICAgIHJlc3VsdC50eXBlUGFyYW1ldGVycyA9IHR5cGVBcmd1bWVudHM7XG4gICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIW5vQ2FsbHMgJiYgdGhpcy5lYXQoMTApKSB7XG4gICAgICAgICAgY29uc3Qgbm9kZSA9IHRoaXMuc3RhcnROb2RlQXQoc3RhcnRMb2MpO1xuICAgICAgICAgIG5vZGUuY2FsbGVlID0gYmFzZTtcbiAgICAgICAgICBub2RlLmFyZ3VtZW50cyA9IHRoaXMucGFyc2VDYWxsRXhwcmVzc2lvbkFyZ3VtZW50cygpO1xuICAgICAgICAgIHRoaXMudHNDaGVja0ZvckludmFsaWRUeXBlQ2FzdHMobm9kZS5hcmd1bWVudHMpO1xuICAgICAgICAgIG5vZGUudHlwZVBhcmFtZXRlcnMgPSB0eXBlQXJndW1lbnRzO1xuICAgICAgICAgIGlmIChzdGF0ZS5vcHRpb25hbENoYWluTWVtYmVyKSB7XG4gICAgICAgICAgICBub2RlLm9wdGlvbmFsID0gaXNPcHRpb25hbENhbGw7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiB0aGlzLmZpbmlzaENhbGxFeHByZXNzaW9uKG5vZGUsIHN0YXRlLm9wdGlvbmFsQ2hhaW5NZW1iZXIpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHRva2VuVHlwZSA9IHRoaXMuc3RhdGUudHlwZTtcbiAgICAgICAgaWYgKHRva2VuVHlwZSA9PT0gNDggfHwgdG9rZW5UeXBlID09PSA1MiB8fCB0b2tlblR5cGUgIT09IDEwICYmIHRva2VuQ2FuU3RhcnRFeHByZXNzaW9uKHRva2VuVHlwZSkgJiYgIXRoaXMuaGFzUHJlY2VkaW5nTGluZUJyZWFrKCkpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgbm9kZSA9IHRoaXMuc3RhcnROb2RlQXQoc3RhcnRMb2MpO1xuICAgICAgICBub2RlLmV4cHJlc3Npb24gPSBiYXNlO1xuICAgICAgICBub2RlLnR5cGVQYXJhbWV0ZXJzID0gdHlwZUFyZ3VtZW50cztcbiAgICAgICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIlRTSW5zdGFudGlhdGlvbkV4cHJlc3Npb25cIik7XG4gICAgICB9KTtcbiAgICAgIGlmIChtaXNzaW5nUGFyZW5FcnJvckxvYykge1xuICAgICAgICB0aGlzLnVuZXhwZWN0ZWQobWlzc2luZ1BhcmVuRXJyb3JMb2MsIDEwKTtcbiAgICAgIH1cbiAgICAgIGlmIChyZXN1bHQpIHtcbiAgICAgICAgaWYgKHJlc3VsdC50eXBlID09PSBcIlRTSW5zdGFudGlhdGlvbkV4cHJlc3Npb25cIikge1xuICAgICAgICAgIGlmICh0aGlzLm1hdGNoKDE2KSB8fCB0aGlzLm1hdGNoKDE4KSAmJiB0aGlzLmxvb2thaGVhZENoYXJDb2RlKCkgIT09IDQwKSB7XG4gICAgICAgICAgICB0aGlzLnJhaXNlKFRTRXJyb3JzLkludmFsaWRQcm9wZXJ0eUFjY2Vzc0FmdGVySW5zdGFudGlhdGlvbkV4cHJlc3Npb24sIHRoaXMuc3RhdGUuc3RhcnRMb2MpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoIXRoaXMubWF0Y2goMTYpICYmICF0aGlzLm1hdGNoKDE4KSkge1xuICAgICAgICAgICAgcmVzdWx0LmV4cHJlc3Npb24gPSBzdXBlci5zdG9wUGFyc2VTdWJzY3JpcHQoYmFzZSwgc3RhdGUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gc3VwZXIucGFyc2VTdWJzY3JpcHQoYmFzZSwgc3RhcnRMb2MsIG5vQ2FsbHMsIHN0YXRlKTtcbiAgfVxuICBwYXJzZU5ld0NhbGxlZShub2RlKSB7XG4gICAgdmFyIF9jYWxsZWUkZXh0cmE7XG4gICAgc3VwZXIucGFyc2VOZXdDYWxsZWUobm9kZSk7XG4gICAgY29uc3Qge1xuICAgICAgY2FsbGVlXG4gICAgfSA9IG5vZGU7XG4gICAgaWYgKGNhbGxlZS50eXBlID09PSBcIlRTSW5zdGFudGlhdGlvbkV4cHJlc3Npb25cIiAmJiAhKChfY2FsbGVlJGV4dHJhID0gY2FsbGVlLmV4dHJhKSAhPSBudWxsICYmIF9jYWxsZWUkZXh0cmEucGFyZW50aGVzaXplZCkpIHtcbiAgICAgIG5vZGUudHlwZVBhcmFtZXRlcnMgPSBjYWxsZWUudHlwZVBhcmFtZXRlcnM7XG4gICAgICBub2RlLmNhbGxlZSA9IGNhbGxlZS5leHByZXNzaW9uO1xuICAgIH1cbiAgfVxuICBwYXJzZUV4cHJPcChsZWZ0LCBsZWZ0U3RhcnRMb2MsIG1pblByZWMpIHtcbiAgICBsZXQgaXNTYXRpc2ZpZXM7XG4gICAgaWYgKHRva2VuT3BlcmF0b3JQcmVjZWRlbmNlKDU4KSA+IG1pblByZWMgJiYgIXRoaXMuaGFzUHJlY2VkaW5nTGluZUJyZWFrKCkgJiYgKHRoaXMuaXNDb250ZXh0dWFsKDkzKSB8fCAoaXNTYXRpc2ZpZXMgPSB0aGlzLmlzQ29udGV4dHVhbCgxMjApKSkpIHtcbiAgICAgIGNvbnN0IG5vZGUgPSB0aGlzLnN0YXJ0Tm9kZUF0KGxlZnRTdGFydExvYyk7XG4gICAgICBub2RlLmV4cHJlc3Npb24gPSBsZWZ0O1xuICAgICAgbm9kZS50eXBlQW5ub3RhdGlvbiA9IHRoaXMudHNJblR5cGUoKCkgPT4ge1xuICAgICAgICB0aGlzLm5leHQoKTtcbiAgICAgICAgaWYgKHRoaXMubWF0Y2goNzUpKSB7XG4gICAgICAgICAgaWYgKGlzU2F0aXNmaWVzKSB7XG4gICAgICAgICAgICB0aGlzLnJhaXNlKEVycm9ycy5VbmV4cGVjdGVkS2V5d29yZCwgdGhpcy5zdGF0ZS5zdGFydExvYywge1xuICAgICAgICAgICAgICBrZXl3b3JkOiBcImNvbnN0XCJcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gdGhpcy50c1BhcnNlVHlwZVJlZmVyZW5jZSgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLnRzUGFyc2VUeXBlKCk7XG4gICAgICB9KTtcbiAgICAgIHRoaXMuZmluaXNoTm9kZShub2RlLCBpc1NhdGlzZmllcyA/IFwiVFNTYXRpc2ZpZXNFeHByZXNzaW9uXCIgOiBcIlRTQXNFeHByZXNzaW9uXCIpO1xuICAgICAgdGhpcy5yZVNjYW5fbHRfZ3QoKTtcbiAgICAgIHJldHVybiB0aGlzLnBhcnNlRXhwck9wKG5vZGUsIGxlZnRTdGFydExvYywgbWluUHJlYyk7XG4gICAgfVxuICAgIHJldHVybiBzdXBlci5wYXJzZUV4cHJPcChsZWZ0LCBsZWZ0U3RhcnRMb2MsIG1pblByZWMpO1xuICB9XG4gIGNoZWNrUmVzZXJ2ZWRXb3JkKHdvcmQsIHN0YXJ0TG9jLCBjaGVja0tleXdvcmRzLCBpc0JpbmRpbmcpIHtcbiAgICBpZiAoIXRoaXMuc3RhdGUuaXNBbWJpZW50Q29udGV4dCkge1xuICAgICAgc3VwZXIuY2hlY2tSZXNlcnZlZFdvcmQod29yZCwgc3RhcnRMb2MsIGNoZWNrS2V5d29yZHMsIGlzQmluZGluZyk7XG4gICAgfVxuICB9XG4gIGNoZWNrSW1wb3J0UmVmbGVjdGlvbihub2RlKSB7XG4gICAgc3VwZXIuY2hlY2tJbXBvcnRSZWZsZWN0aW9uKG5vZGUpO1xuICAgIGlmIChub2RlLm1vZHVsZSAmJiBub2RlLmltcG9ydEtpbmQgIT09IFwidmFsdWVcIikge1xuICAgICAgdGhpcy5yYWlzZShUU0Vycm9ycy5JbXBvcnRSZWZsZWN0aW9uSGFzSW1wb3J0VHlwZSwgbm9kZS5zcGVjaWZpZXJzWzBdLmxvYy5zdGFydCk7XG4gICAgfVxuICB9XG4gIGNoZWNrRHVwbGljYXRlRXhwb3J0cygpIHt9XG4gIGlzUG90ZW50aWFsSW1wb3J0UGhhc2UoaXNFeHBvcnQpIHtcbiAgICBpZiAoc3VwZXIuaXNQb3RlbnRpYWxJbXBvcnRQaGFzZShpc0V4cG9ydCkpIHJldHVybiB0cnVlO1xuICAgIGlmICh0aGlzLmlzQ29udGV4dHVhbCgxMzApKSB7XG4gICAgICBjb25zdCBjaCA9IHRoaXMubG9va2FoZWFkQ2hhckNvZGUoKTtcbiAgICAgIHJldHVybiBpc0V4cG9ydCA/IGNoID09PSAxMjMgfHwgY2ggPT09IDQyIDogY2ggIT09IDYxO1xuICAgIH1cbiAgICByZXR1cm4gIWlzRXhwb3J0ICYmIHRoaXMuaXNDb250ZXh0dWFsKDg3KTtcbiAgfVxuICBhcHBseUltcG9ydFBoYXNlKG5vZGUsIGlzRXhwb3J0LCBwaGFzZSwgbG9jKSB7XG4gICAgc3VwZXIuYXBwbHlJbXBvcnRQaGFzZShub2RlLCBpc0V4cG9ydCwgcGhhc2UsIGxvYyk7XG4gICAgaWYgKGlzRXhwb3J0KSB7XG4gICAgICBub2RlLmV4cG9ydEtpbmQgPSBwaGFzZSA9PT0gXCJ0eXBlXCIgPyBcInR5cGVcIiA6IFwidmFsdWVcIjtcbiAgICB9IGVsc2Uge1xuICAgICAgbm9kZS5pbXBvcnRLaW5kID0gcGhhc2UgPT09IFwidHlwZVwiIHx8IHBoYXNlID09PSBcInR5cGVvZlwiID8gcGhhc2UgOiBcInZhbHVlXCI7XG4gICAgfVxuICB9XG4gIHBhcnNlSW1wb3J0KG5vZGUpIHtcbiAgICBpZiAodGhpcy5tYXRjaCgxMzQpKSB7XG4gICAgICBub2RlLmltcG9ydEtpbmQgPSBcInZhbHVlXCI7XG4gICAgICByZXR1cm4gc3VwZXIucGFyc2VJbXBvcnQobm9kZSk7XG4gICAgfVxuICAgIGxldCBpbXBvcnROb2RlO1xuICAgIGlmICh0b2tlbklzSWRlbnRpZmllcih0aGlzLnN0YXRlLnR5cGUpICYmIHRoaXMubG9va2FoZWFkQ2hhckNvZGUoKSA9PT0gNjEpIHtcbiAgICAgIG5vZGUuaW1wb3J0S2luZCA9IFwidmFsdWVcIjtcbiAgICAgIHJldHVybiB0aGlzLnRzUGFyc2VJbXBvcnRFcXVhbHNEZWNsYXJhdGlvbihub2RlKTtcbiAgICB9IGVsc2UgaWYgKHRoaXMuaXNDb250ZXh0dWFsKDEzMCkpIHtcbiAgICAgIGNvbnN0IG1heWJlRGVmYXVsdElkZW50aWZpZXIgPSB0aGlzLnBhcnNlTWF5YmVJbXBvcnRQaGFzZShub2RlLCBmYWxzZSk7XG4gICAgICBpZiAodGhpcy5sb29rYWhlYWRDaGFyQ29kZSgpID09PSA2MSkge1xuICAgICAgICByZXR1cm4gdGhpcy50c1BhcnNlSW1wb3J0RXF1YWxzRGVjbGFyYXRpb24obm9kZSwgbWF5YmVEZWZhdWx0SWRlbnRpZmllcik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpbXBvcnROb2RlID0gc3VwZXIucGFyc2VJbXBvcnRTcGVjaWZpZXJzQW5kQWZ0ZXIobm9kZSwgbWF5YmVEZWZhdWx0SWRlbnRpZmllcik7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGltcG9ydE5vZGUgPSBzdXBlci5wYXJzZUltcG9ydChub2RlKTtcbiAgICB9XG4gICAgaWYgKGltcG9ydE5vZGUuaW1wb3J0S2luZCA9PT0gXCJ0eXBlXCIgJiYgaW1wb3J0Tm9kZS5zcGVjaWZpZXJzLmxlbmd0aCA+IDEgJiYgaW1wb3J0Tm9kZS5zcGVjaWZpZXJzWzBdLnR5cGUgPT09IFwiSW1wb3J0RGVmYXVsdFNwZWNpZmllclwiKSB7XG4gICAgICB0aGlzLnJhaXNlKFRTRXJyb3JzLlR5cGVJbXBvcnRDYW5ub3RTcGVjaWZ5RGVmYXVsdEFuZE5hbWVkLCBpbXBvcnROb2RlKTtcbiAgICB9XG4gICAgcmV0dXJuIGltcG9ydE5vZGU7XG4gIH1cbiAgcGFyc2VFeHBvcnQobm9kZSwgZGVjb3JhdG9ycykge1xuICAgIGlmICh0aGlzLm1hdGNoKDgzKSkge1xuICAgICAgY29uc3Qgbm9kZUltcG9ydEVxdWFscyA9IG5vZGU7XG4gICAgICB0aGlzLm5leHQoKTtcbiAgICAgIGxldCBtYXliZURlZmF1bHRJZGVudGlmaWVyID0gbnVsbDtcbiAgICAgIGlmICh0aGlzLmlzQ29udGV4dHVhbCgxMzApICYmIHRoaXMuaXNQb3RlbnRpYWxJbXBvcnRQaGFzZShmYWxzZSkpIHtcbiAgICAgICAgbWF5YmVEZWZhdWx0SWRlbnRpZmllciA9IHRoaXMucGFyc2VNYXliZUltcG9ydFBoYXNlKG5vZGVJbXBvcnRFcXVhbHMsIGZhbHNlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG5vZGVJbXBvcnRFcXVhbHMuaW1wb3J0S2luZCA9IFwidmFsdWVcIjtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGRlY2xhcmF0aW9uID0gdGhpcy50c1BhcnNlSW1wb3J0RXF1YWxzRGVjbGFyYXRpb24obm9kZUltcG9ydEVxdWFscywgbWF5YmVEZWZhdWx0SWRlbnRpZmllciwgdHJ1ZSk7XG4gICAgICByZXR1cm4gZGVjbGFyYXRpb247XG4gICAgfSBlbHNlIGlmICh0aGlzLmVhdCgyOSkpIHtcbiAgICAgIGNvbnN0IGFzc2lnbiA9IG5vZGU7XG4gICAgICBhc3NpZ24uZXhwcmVzc2lvbiA9IHN1cGVyLnBhcnNlRXhwcmVzc2lvbigpO1xuICAgICAgdGhpcy5zZW1pY29sb24oKTtcbiAgICAgIHRoaXMuc2F3VW5hbWJpZ3VvdXNFU00gPSB0cnVlO1xuICAgICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShhc3NpZ24sIFwiVFNFeHBvcnRBc3NpZ25tZW50XCIpO1xuICAgIH0gZWxzZSBpZiAodGhpcy5lYXRDb250ZXh0dWFsKDkzKSkge1xuICAgICAgY29uc3QgZGVjbCA9IG5vZGU7XG4gICAgICB0aGlzLmV4cGVjdENvbnRleHR1YWwoMTI4KTtcbiAgICAgIGRlY2wuaWQgPSB0aGlzLnBhcnNlSWRlbnRpZmllcigpO1xuICAgICAgdGhpcy5zZW1pY29sb24oKTtcbiAgICAgIHJldHVybiB0aGlzLmZpbmlzaE5vZGUoZGVjbCwgXCJUU05hbWVzcGFjZUV4cG9ydERlY2xhcmF0aW9uXCIpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gc3VwZXIucGFyc2VFeHBvcnQobm9kZSwgZGVjb3JhdG9ycyk7XG4gICAgfVxuICB9XG4gIGlzQWJzdHJhY3RDbGFzcygpIHtcbiAgICByZXR1cm4gdGhpcy5pc0NvbnRleHR1YWwoMTI0KSAmJiB0aGlzLmlzTG9va2FoZWFkQ29udGV4dHVhbChcImNsYXNzXCIpO1xuICB9XG4gIHBhcnNlRXhwb3J0RGVmYXVsdEV4cHJlc3Npb24oKSB7XG4gICAgaWYgKHRoaXMuaXNBYnN0cmFjdENsYXNzKCkpIHtcbiAgICAgIGNvbnN0IGNscyA9IHRoaXMuc3RhcnROb2RlKCk7XG4gICAgICB0aGlzLm5leHQoKTtcbiAgICAgIGNscy5hYnN0cmFjdCA9IHRydWU7XG4gICAgICByZXR1cm4gdGhpcy5wYXJzZUNsYXNzKGNscywgdHJ1ZSwgdHJ1ZSk7XG4gICAgfVxuICAgIGlmICh0aGlzLm1hdGNoKDEyOSkpIHtcbiAgICAgIGNvbnN0IHJlc3VsdCA9IHRoaXMudHNQYXJzZUludGVyZmFjZURlY2xhcmF0aW9uKHRoaXMuc3RhcnROb2RlKCkpO1xuICAgICAgaWYgKHJlc3VsdCkgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgcmV0dXJuIHN1cGVyLnBhcnNlRXhwb3J0RGVmYXVsdEV4cHJlc3Npb24oKTtcbiAgfVxuICBwYXJzZVZhclN0YXRlbWVudChub2RlLCBraW5kLCBhbGxvd01pc3NpbmdJbml0aWFsaXplciA9IGZhbHNlKSB7XG4gICAgY29uc3Qge1xuICAgICAgaXNBbWJpZW50Q29udGV4dFxuICAgIH0gPSB0aGlzLnN0YXRlO1xuICAgIGNvbnN0IGRlY2xhcmF0aW9uID0gc3VwZXIucGFyc2VWYXJTdGF0ZW1lbnQobm9kZSwga2luZCwgYWxsb3dNaXNzaW5nSW5pdGlhbGl6ZXIgfHwgaXNBbWJpZW50Q29udGV4dCk7XG4gICAgaWYgKCFpc0FtYmllbnRDb250ZXh0KSByZXR1cm4gZGVjbGFyYXRpb247XG4gICAgaWYgKCFub2RlLmRlY2xhcmUgJiYgKGtpbmQgPT09IFwidXNpbmdcIiB8fCBraW5kID09PSBcImF3YWl0IHVzaW5nXCIpKSB7XG4gICAgICB0aGlzLnJhaXNlT3ZlcndyaXRlKFRTRXJyb3JzLlVzaW5nRGVjbGFyYXRpb25JbkFtYmllbnRDb250ZXh0LCBub2RlLCBraW5kKTtcbiAgICAgIHJldHVybiBkZWNsYXJhdGlvbjtcbiAgICB9XG4gICAgZm9yIChjb25zdCB7XG4gICAgICBpZCxcbiAgICAgIGluaXRcbiAgICB9IG9mIGRlY2xhcmF0aW9uLmRlY2xhcmF0aW9ucykge1xuICAgICAgaWYgKCFpbml0KSBjb250aW51ZTtcbiAgICAgIGlmIChraW5kID09PSBcInZhclwiIHx8IGtpbmQgPT09IFwibGV0XCIgfHwgISFpZC50eXBlQW5ub3RhdGlvbikge1xuICAgICAgICB0aGlzLnJhaXNlKFRTRXJyb3JzLkluaXRpYWxpemVyTm90QWxsb3dlZEluQW1iaWVudENvbnRleHQsIGluaXQpO1xuICAgICAgfSBlbHNlIGlmICghaXNWYWxpZEFtYmllbnRDb25zdEluaXRpYWxpemVyKGluaXQsIHRoaXMuaGFzUGx1Z2luKFwiZXN0cmVlXCIpKSkge1xuICAgICAgICB0aGlzLnJhaXNlKFRTRXJyb3JzLkNvbnN0SW5pdGlhbGl6ZXJNdXN0QmVTdHJpbmdPck51bWVyaWNMaXRlcmFsT3JMaXRlcmFsRW51bVJlZmVyZW5jZSwgaW5pdCk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBkZWNsYXJhdGlvbjtcbiAgfVxuICBwYXJzZVN0YXRlbWVudENvbnRlbnQoZmxhZ3MsIGRlY29yYXRvcnMpIHtcbiAgICBpZiAoIXRoaXMuc3RhdGUuY29udGFpbnNFc2MpIHtcbiAgICAgIHN3aXRjaCAodGhpcy5zdGF0ZS50eXBlKSB7XG4gICAgICAgIGNhc2UgNzU6XG4gICAgICAgICAge1xuICAgICAgICAgICAgaWYgKHRoaXMuaXNMb29rYWhlYWRDb250ZXh0dWFsKFwiZW51bVwiKSkge1xuICAgICAgICAgICAgICBjb25zdCBub2RlID0gdGhpcy5zdGFydE5vZGUoKTtcbiAgICAgICAgICAgICAgdGhpcy5leHBlY3QoNzUpO1xuICAgICAgICAgICAgICByZXR1cm4gdGhpcy50c1BhcnNlRW51bURlY2xhcmF0aW9uKG5vZGUsIHtcbiAgICAgICAgICAgICAgICBjb25zdDogdHJ1ZVxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgY2FzZSAxMjQ6XG4gICAgICAgIGNhc2UgMTI1OlxuICAgICAgICAgIHtcbiAgICAgICAgICAgIGlmICh0aGlzLm5leHRUb2tlbklzSWRlbnRpZmllckFuZE5vdFRTUmVsYXRpb25hbE9wZXJhdG9yT25TYW1lTGluZSgpKSB7XG4gICAgICAgICAgICAgIGNvbnN0IHRva2VuID0gdGhpcy5zdGF0ZS50eXBlO1xuICAgICAgICAgICAgICBjb25zdCBub2RlID0gdGhpcy5zdGFydE5vZGUoKTtcbiAgICAgICAgICAgICAgdGhpcy5uZXh0KCk7XG4gICAgICAgICAgICAgIGNvbnN0IGRlY2xhcmF0aW9uID0gdG9rZW4gPT09IDEyNSA/IHRoaXMudHNUcnlQYXJzZURlY2xhcmUobm9kZSkgOiB0aGlzLnRzUGFyc2VBYnN0cmFjdERlY2xhcmF0aW9uKG5vZGUsIGRlY29yYXRvcnMpO1xuICAgICAgICAgICAgICBpZiAoZGVjbGFyYXRpb24pIHtcbiAgICAgICAgICAgICAgICBpZiAodG9rZW4gPT09IDEyNSkge1xuICAgICAgICAgICAgICAgICAgZGVjbGFyYXRpb24uZGVjbGFyZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBkZWNsYXJhdGlvbjtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBub2RlLmV4cHJlc3Npb24gPSB0aGlzLmNyZWF0ZUlkZW50aWZpZXIodGhpcy5zdGFydE5vZGVBdChub2RlLmxvYy5zdGFydCksIHRva2VuID09PSAxMjUgPyBcImRlY2xhcmVcIiA6IFwiYWJzdHJhY3RcIik7XG4gICAgICAgICAgICAgICAgdGhpcy5zZW1pY29sb24oZmFsc2UpO1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJFeHByZXNzaW9uU3RhdGVtZW50XCIpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIGNhc2UgMTI2OlxuICAgICAgICAgIHJldHVybiB0aGlzLnRzUGFyc2VFbnVtRGVjbGFyYXRpb24odGhpcy5zdGFydE5vZGUoKSk7XG4gICAgICAgIGNhc2UgMTEyOlxuICAgICAgICAgIHtcbiAgICAgICAgICAgIGNvbnN0IG5leHRDaCA9IHRoaXMubG9va2FoZWFkQ2hhckNvZGUoKTtcbiAgICAgICAgICAgIGlmIChuZXh0Q2ggPT09IDEyMykge1xuICAgICAgICAgICAgICBjb25zdCBub2RlID0gdGhpcy5zdGFydE5vZGUoKTtcbiAgICAgICAgICAgICAgcmV0dXJuIHRoaXMudHNQYXJzZUFtYmllbnRFeHRlcm5hbE1vZHVsZURlY2xhcmF0aW9uKG5vZGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICBjYXNlIDEyOTpcbiAgICAgICAgICB7XG4gICAgICAgICAgICBjb25zdCByZXN1bHQgPSB0aGlzLnRzUGFyc2VJbnRlcmZhY2VEZWNsYXJhdGlvbih0aGlzLnN0YXJ0Tm9kZSgpKTtcbiAgICAgICAgICAgIGlmIChyZXN1bHQpIHJldHVybiByZXN1bHQ7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIGNhc2UgMTI3OlxuICAgICAgICAgIHtcbiAgICAgICAgICAgIGlmICh0aGlzLm5leHRUb2tlbklzSWRlbnRpZmllck9yU3RyaW5nTGl0ZXJhbE9uU2FtZUxpbmUoKSkge1xuICAgICAgICAgICAgICBjb25zdCBub2RlID0gdGhpcy5zdGFydE5vZGUoKTtcbiAgICAgICAgICAgICAgdGhpcy5uZXh0KCk7XG4gICAgICAgICAgICAgIHJldHVybiB0aGlzLnRzUGFyc2VEZWNsYXJhdGlvbihub2RlLCAxMjcsIGZhbHNlLCBkZWNvcmF0b3JzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgY2FzZSAxMjg6XG4gICAgICAgICAge1xuICAgICAgICAgICAgaWYgKHRoaXMubmV4dFRva2VuSXNJZGVudGlmaWVyT25TYW1lTGluZSgpKSB7XG4gICAgICAgICAgICAgIGNvbnN0IG5vZGUgPSB0aGlzLnN0YXJ0Tm9kZSgpO1xuICAgICAgICAgICAgICB0aGlzLm5leHQoKTtcbiAgICAgICAgICAgICAgcmV0dXJuIHRoaXMudHNQYXJzZURlY2xhcmF0aW9uKG5vZGUsIDEyOCwgZmFsc2UsIGRlY29yYXRvcnMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICBjYXNlIDEzMDpcbiAgICAgICAgICB7XG4gICAgICAgICAgICBpZiAodGhpcy5uZXh0VG9rZW5Jc0lkZW50aWZpZXJPblNhbWVMaW5lKCkpIHtcbiAgICAgICAgICAgICAgY29uc3Qgbm9kZSA9IHRoaXMuc3RhcnROb2RlKCk7XG4gICAgICAgICAgICAgIHRoaXMubmV4dCgpO1xuICAgICAgICAgICAgICByZXR1cm4gdGhpcy50c1BhcnNlVHlwZUFsaWFzRGVjbGFyYXRpb24obm9kZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBzdXBlci5wYXJzZVN0YXRlbWVudENvbnRlbnQoZmxhZ3MsIGRlY29yYXRvcnMpO1xuICB9XG4gIHBhcnNlQWNjZXNzTW9kaWZpZXIoKSB7XG4gICAgcmV0dXJuIHRoaXMudHNQYXJzZU1vZGlmaWVyKFtcInB1YmxpY1wiLCBcInByb3RlY3RlZFwiLCBcInByaXZhdGVcIl0pO1xuICB9XG4gIHRzSGFzU29tZU1vZGlmaWVycyhtZW1iZXIsIG1vZGlmaWVycykge1xuICAgIHJldHVybiBtb2RpZmllcnMuc29tZShtb2RpZmllciA9PiB7XG4gICAgICBpZiAodHNJc0FjY2Vzc01vZGlmaWVyKG1vZGlmaWVyKSkge1xuICAgICAgICByZXR1cm4gbWVtYmVyLmFjY2Vzc2liaWxpdHkgPT09IG1vZGlmaWVyO1xuICAgICAgfVxuICAgICAgcmV0dXJuICEhbWVtYmVyW21vZGlmaWVyXTtcbiAgICB9KTtcbiAgfVxuICB0c0lzU3RhcnRPZlN0YXRpY0Jsb2NrcygpIHtcbiAgICByZXR1cm4gdGhpcy5pc0NvbnRleHR1YWwoMTA2KSAmJiB0aGlzLmxvb2thaGVhZENoYXJDb2RlKCkgPT09IDEyMztcbiAgfVxuICBwYXJzZUNsYXNzTWVtYmVyKGNsYXNzQm9keSwgbWVtYmVyLCBzdGF0ZSkge1xuICAgIGNvbnN0IG1vZGlmaWVycyA9IFtcImRlY2xhcmVcIiwgXCJwcml2YXRlXCIsIFwicHVibGljXCIsIFwicHJvdGVjdGVkXCIsIFwib3ZlcnJpZGVcIiwgXCJhYnN0cmFjdFwiLCBcInJlYWRvbmx5XCIsIFwic3RhdGljXCJdO1xuICAgIHRoaXMudHNQYXJzZU1vZGlmaWVycyh7XG4gICAgICBhbGxvd2VkTW9kaWZpZXJzOiBtb2RpZmllcnMsXG4gICAgICBkaXNhbGxvd2VkTW9kaWZpZXJzOiBbXCJpblwiLCBcIm91dFwiXSxcbiAgICAgIHN0b3BPblN0YXJ0T2ZDbGFzc1N0YXRpY0Jsb2NrOiB0cnVlLFxuICAgICAgZXJyb3JUZW1wbGF0ZTogVFNFcnJvcnMuSW52YWxpZE1vZGlmaWVyT25UeXBlUGFyYW1ldGVyUG9zaXRpb25zXG4gICAgfSwgbWVtYmVyKTtcbiAgICBjb25zdCBjYWxsUGFyc2VDbGFzc01lbWJlcldpdGhJc1N0YXRpYyA9ICgpID0+IHtcbiAgICAgIGlmICh0aGlzLnRzSXNTdGFydE9mU3RhdGljQmxvY2tzKCkpIHtcbiAgICAgICAgdGhpcy5uZXh0KCk7XG4gICAgICAgIHRoaXMubmV4dCgpO1xuICAgICAgICBpZiAodGhpcy50c0hhc1NvbWVNb2RpZmllcnMobWVtYmVyLCBtb2RpZmllcnMpKSB7XG4gICAgICAgICAgdGhpcy5yYWlzZShUU0Vycm9ycy5TdGF0aWNCbG9ja0Nhbm5vdEhhdmVNb2RpZmllciwgdGhpcy5zdGF0ZS5jdXJQb3NpdGlvbigpKTtcbiAgICAgICAgfVxuICAgICAgICBzdXBlci5wYXJzZUNsYXNzU3RhdGljQmxvY2soY2xhc3NCb2R5LCBtZW1iZXIpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5wYXJzZUNsYXNzTWVtYmVyV2l0aElzU3RhdGljKGNsYXNzQm9keSwgbWVtYmVyLCBzdGF0ZSwgISFtZW1iZXIuc3RhdGljKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIGlmIChtZW1iZXIuZGVjbGFyZSkge1xuICAgICAgdGhpcy50c0luQW1iaWVudENvbnRleHQoY2FsbFBhcnNlQ2xhc3NNZW1iZXJXaXRoSXNTdGF0aWMpO1xuICAgIH0gZWxzZSB7XG4gICAgICBjYWxsUGFyc2VDbGFzc01lbWJlcldpdGhJc1N0YXRpYygpO1xuICAgIH1cbiAgfVxuICBwYXJzZUNsYXNzTWVtYmVyV2l0aElzU3RhdGljKGNsYXNzQm9keSwgbWVtYmVyLCBzdGF0ZSwgaXNTdGF0aWMpIHtcbiAgICBjb25zdCBpZHggPSB0aGlzLnRzVHJ5UGFyc2VJbmRleFNpZ25hdHVyZShtZW1iZXIpO1xuICAgIGlmIChpZHgpIHtcbiAgICAgIGNsYXNzQm9keS5ib2R5LnB1c2goaWR4KTtcbiAgICAgIGlmIChtZW1iZXIuYWJzdHJhY3QpIHtcbiAgICAgICAgdGhpcy5yYWlzZShUU0Vycm9ycy5JbmRleFNpZ25hdHVyZUhhc0Fic3RyYWN0LCBtZW1iZXIpO1xuICAgICAgfVxuICAgICAgaWYgKG1lbWJlci5hY2Nlc3NpYmlsaXR5KSB7XG4gICAgICAgIHRoaXMucmFpc2UoVFNFcnJvcnMuSW5kZXhTaWduYXR1cmVIYXNBY2Nlc3NpYmlsaXR5LCBtZW1iZXIsIHtcbiAgICAgICAgICBtb2RpZmllcjogbWVtYmVyLmFjY2Vzc2liaWxpdHlcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICBpZiAobWVtYmVyLmRlY2xhcmUpIHtcbiAgICAgICAgdGhpcy5yYWlzZShUU0Vycm9ycy5JbmRleFNpZ25hdHVyZUhhc0RlY2xhcmUsIG1lbWJlcik7XG4gICAgICB9XG4gICAgICBpZiAobWVtYmVyLm92ZXJyaWRlKSB7XG4gICAgICAgIHRoaXMucmFpc2UoVFNFcnJvcnMuSW5kZXhTaWduYXR1cmVIYXNPdmVycmlkZSwgbWVtYmVyKTtcbiAgICAgIH1cbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKCF0aGlzLnN0YXRlLmluQWJzdHJhY3RDbGFzcyAmJiBtZW1iZXIuYWJzdHJhY3QpIHtcbiAgICAgIHRoaXMucmFpc2UoVFNFcnJvcnMuTm9uQWJzdHJhY3RDbGFzc0hhc0Fic3RyYWN0TWV0aG9kLCBtZW1iZXIpO1xuICAgIH1cbiAgICBpZiAobWVtYmVyLm92ZXJyaWRlKSB7XG4gICAgICBpZiAoIXN0YXRlLmhhZFN1cGVyQ2xhc3MpIHtcbiAgICAgICAgdGhpcy5yYWlzZShUU0Vycm9ycy5PdmVycmlkZU5vdEluU3ViQ2xhc3MsIG1lbWJlcik7XG4gICAgICB9XG4gICAgfVxuICAgIHN1cGVyLnBhcnNlQ2xhc3NNZW1iZXJXaXRoSXNTdGF0aWMoY2xhc3NCb2R5LCBtZW1iZXIsIHN0YXRlLCBpc1N0YXRpYyk7XG4gIH1cbiAgcGFyc2VQb3N0TWVtYmVyTmFtZU1vZGlmaWVycyhtZXRob2RPclByb3ApIHtcbiAgICBjb25zdCBvcHRpb25hbCA9IHRoaXMuZWF0KDE3KTtcbiAgICBpZiAob3B0aW9uYWwpIG1ldGhvZE9yUHJvcC5vcHRpb25hbCA9IHRydWU7XG4gICAgaWYgKG1ldGhvZE9yUHJvcC5yZWFkb25seSAmJiB0aGlzLm1hdGNoKDEwKSkge1xuICAgICAgdGhpcy5yYWlzZShUU0Vycm9ycy5DbGFzc01ldGhvZEhhc1JlYWRvbmx5LCBtZXRob2RPclByb3ApO1xuICAgIH1cbiAgICBpZiAobWV0aG9kT3JQcm9wLmRlY2xhcmUgJiYgdGhpcy5tYXRjaCgxMCkpIHtcbiAgICAgIHRoaXMucmFpc2UoVFNFcnJvcnMuQ2xhc3NNZXRob2RIYXNEZWNsYXJlLCBtZXRob2RPclByb3ApO1xuICAgIH1cbiAgfVxuICBzaG91bGRQYXJzZUV4cG9ydERlY2xhcmF0aW9uKCkge1xuICAgIGlmICh0aGlzLnRzSXNEZWNsYXJhdGlvblN0YXJ0KCkpIHJldHVybiB0cnVlO1xuICAgIHJldHVybiBzdXBlci5zaG91bGRQYXJzZUV4cG9ydERlY2xhcmF0aW9uKCk7XG4gIH1cbiAgcGFyc2VDb25kaXRpb25hbChleHByLCBzdGFydExvYywgcmVmRXhwcmVzc2lvbkVycm9ycykge1xuICAgIGlmICghdGhpcy5tYXRjaCgxNykpIHJldHVybiBleHByO1xuICAgIGlmICh0aGlzLnN0YXRlLm1heWJlSW5BcnJvd1BhcmFtZXRlcnMpIHtcbiAgICAgIGNvbnN0IG5leHRDaCA9IHRoaXMubG9va2FoZWFkQ2hhckNvZGUoKTtcbiAgICAgIGlmIChuZXh0Q2ggPT09IDQ0IHx8IG5leHRDaCA9PT0gNjEgfHwgbmV4dENoID09PSA1OCB8fCBuZXh0Q2ggPT09IDQxKSB7XG4gICAgICAgIHRoaXMuc2V0T3B0aW9uYWxQYXJhbWV0ZXJzRXJyb3IocmVmRXhwcmVzc2lvbkVycm9ycyk7XG4gICAgICAgIHJldHVybiBleHByO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gc3VwZXIucGFyc2VDb25kaXRpb25hbChleHByLCBzdGFydExvYywgcmVmRXhwcmVzc2lvbkVycm9ycyk7XG4gIH1cbiAgcGFyc2VQYXJlbkl0ZW0obm9kZSwgc3RhcnRMb2MpIHtcbiAgICBjb25zdCBuZXdOb2RlID0gc3VwZXIucGFyc2VQYXJlbkl0ZW0obm9kZSwgc3RhcnRMb2MpO1xuICAgIGlmICh0aGlzLmVhdCgxNykpIHtcbiAgICAgIG5ld05vZGUub3B0aW9uYWwgPSB0cnVlO1xuICAgICAgdGhpcy5yZXNldEVuZExvY2F0aW9uKG5vZGUpO1xuICAgIH1cbiAgICBpZiAodGhpcy5tYXRjaCgxNCkpIHtcbiAgICAgIGNvbnN0IHR5cGVDYXN0Tm9kZSA9IHRoaXMuc3RhcnROb2RlQXQoc3RhcnRMb2MpO1xuICAgICAgdHlwZUNhc3ROb2RlLmV4cHJlc3Npb24gPSBub2RlO1xuICAgICAgdHlwZUNhc3ROb2RlLnR5cGVBbm5vdGF0aW9uID0gdGhpcy50c1BhcnNlVHlwZUFubm90YXRpb24oKTtcbiAgICAgIHJldHVybiB0aGlzLmZpbmlzaE5vZGUodHlwZUNhc3ROb2RlLCBcIlRTVHlwZUNhc3RFeHByZXNzaW9uXCIpO1xuICAgIH1cbiAgICByZXR1cm4gbm9kZTtcbiAgfVxuICBwYXJzZUV4cG9ydERlY2xhcmF0aW9uKG5vZGUpIHtcbiAgICBpZiAoIXRoaXMuc3RhdGUuaXNBbWJpZW50Q29udGV4dCAmJiB0aGlzLmlzQ29udGV4dHVhbCgxMjUpKSB7XG4gICAgICByZXR1cm4gdGhpcy50c0luQW1iaWVudENvbnRleHQoKCkgPT4gdGhpcy5wYXJzZUV4cG9ydERlY2xhcmF0aW9uKG5vZGUpKTtcbiAgICB9XG4gICAgY29uc3Qgc3RhcnRMb2MgPSB0aGlzLnN0YXRlLnN0YXJ0TG9jO1xuICAgIGNvbnN0IGlzRGVjbGFyZSA9IHRoaXMuZWF0Q29udGV4dHVhbCgxMjUpO1xuICAgIGlmIChpc0RlY2xhcmUgJiYgKHRoaXMuaXNDb250ZXh0dWFsKDEyNSkgfHwgIXRoaXMuc2hvdWxkUGFyc2VFeHBvcnREZWNsYXJhdGlvbigpKSkge1xuICAgICAgdGhyb3cgdGhpcy5yYWlzZShUU0Vycm9ycy5FeHBlY3RlZEFtYmllbnRBZnRlckV4cG9ydERlY2xhcmUsIHRoaXMuc3RhdGUuc3RhcnRMb2MpO1xuICAgIH1cbiAgICBjb25zdCBpc0lkZW50aWZpZXIgPSB0b2tlbklzSWRlbnRpZmllcih0aGlzLnN0YXRlLnR5cGUpO1xuICAgIGNvbnN0IGRlY2xhcmF0aW9uID0gaXNJZGVudGlmaWVyICYmIHRoaXMudHNUcnlQYXJzZUV4cG9ydERlY2xhcmF0aW9uKCkgfHwgc3VwZXIucGFyc2VFeHBvcnREZWNsYXJhdGlvbihub2RlKTtcbiAgICBpZiAoIWRlY2xhcmF0aW9uKSByZXR1cm4gbnVsbDtcbiAgICBpZiAoZGVjbGFyYXRpb24udHlwZSA9PT0gXCJUU0ludGVyZmFjZURlY2xhcmF0aW9uXCIgfHwgZGVjbGFyYXRpb24udHlwZSA9PT0gXCJUU1R5cGVBbGlhc0RlY2xhcmF0aW9uXCIgfHwgaXNEZWNsYXJlKSB7XG4gICAgICBub2RlLmV4cG9ydEtpbmQgPSBcInR5cGVcIjtcbiAgICB9XG4gICAgaWYgKGlzRGVjbGFyZSAmJiBkZWNsYXJhdGlvbi50eXBlICE9PSBcIlRTSW1wb3J0RXF1YWxzRGVjbGFyYXRpb25cIikge1xuICAgICAgdGhpcy5yZXNldFN0YXJ0TG9jYXRpb24oZGVjbGFyYXRpb24sIHN0YXJ0TG9jKTtcbiAgICAgIGRlY2xhcmF0aW9uLmRlY2xhcmUgPSB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gZGVjbGFyYXRpb247XG4gIH1cbiAgcGFyc2VDbGFzc0lkKG5vZGUsIGlzU3RhdGVtZW50LCBvcHRpb25hbElkLCBiaW5kaW5nVHlwZSkge1xuICAgIGlmICgoIWlzU3RhdGVtZW50IHx8IG9wdGlvbmFsSWQpICYmIHRoaXMuaXNDb250ZXh0dWFsKDExMykpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgc3VwZXIucGFyc2VDbGFzc0lkKG5vZGUsIGlzU3RhdGVtZW50LCBvcHRpb25hbElkLCBub2RlLmRlY2xhcmUgPyAxMDI0IDogODMzMSk7XG4gICAgY29uc3QgdHlwZVBhcmFtZXRlcnMgPSB0aGlzLnRzVHJ5UGFyc2VUeXBlUGFyYW1ldGVycyh0aGlzLnRzUGFyc2VJbk91dENvbnN0TW9kaWZpZXJzKTtcbiAgICBpZiAodHlwZVBhcmFtZXRlcnMpIG5vZGUudHlwZVBhcmFtZXRlcnMgPSB0eXBlUGFyYW1ldGVycztcbiAgfVxuICBwYXJzZUNsYXNzUHJvcGVydHlBbm5vdGF0aW9uKG5vZGUpIHtcbiAgICBpZiAoIW5vZGUub3B0aW9uYWwpIHtcbiAgICAgIGlmICh0aGlzLmVhdCgzNSkpIHtcbiAgICAgICAgbm9kZS5kZWZpbml0ZSA9IHRydWU7XG4gICAgICB9IGVsc2UgaWYgKHRoaXMuZWF0KDE3KSkge1xuICAgICAgICBub2RlLm9wdGlvbmFsID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG4gICAgY29uc3QgdHlwZSA9IHRoaXMudHNUcnlQYXJzZVR5cGVBbm5vdGF0aW9uKCk7XG4gICAgaWYgKHR5cGUpIG5vZGUudHlwZUFubm90YXRpb24gPSB0eXBlO1xuICB9XG4gIHBhcnNlQ2xhc3NQcm9wZXJ0eShub2RlKSB7XG4gICAgdGhpcy5wYXJzZUNsYXNzUHJvcGVydHlBbm5vdGF0aW9uKG5vZGUpO1xuICAgIGlmICh0aGlzLnN0YXRlLmlzQW1iaWVudENvbnRleHQgJiYgIShub2RlLnJlYWRvbmx5ICYmICFub2RlLnR5cGVBbm5vdGF0aW9uKSAmJiB0aGlzLm1hdGNoKDI5KSkge1xuICAgICAgdGhpcy5yYWlzZShUU0Vycm9ycy5EZWNsYXJlQ2xhc3NGaWVsZEhhc0luaXRpYWxpemVyLCB0aGlzLnN0YXRlLnN0YXJ0TG9jKTtcbiAgICB9XG4gICAgaWYgKG5vZGUuYWJzdHJhY3QgJiYgdGhpcy5tYXRjaCgyOSkpIHtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAga2V5XG4gICAgICB9ID0gbm9kZTtcbiAgICAgIHRoaXMucmFpc2UoVFNFcnJvcnMuQWJzdHJhY3RQcm9wZXJ0eUhhc0luaXRpYWxpemVyLCB0aGlzLnN0YXRlLnN0YXJ0TG9jLCB7XG4gICAgICAgIHByb3BlcnR5TmFtZToga2V5LnR5cGUgPT09IFwiSWRlbnRpZmllclwiICYmICFub2RlLmNvbXB1dGVkID8ga2V5Lm5hbWUgOiBgWyR7dGhpcy5pbnB1dC5zbGljZSh0aGlzLm9mZnNldFRvU291cmNlUG9zKGtleS5zdGFydCksIHRoaXMub2Zmc2V0VG9Tb3VyY2VQb3Moa2V5LmVuZCkpfV1gXG4gICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIHN1cGVyLnBhcnNlQ2xhc3NQcm9wZXJ0eShub2RlKTtcbiAgfVxuICBwYXJzZUNsYXNzUHJpdmF0ZVByb3BlcnR5KG5vZGUpIHtcbiAgICBpZiAobm9kZS5hYnN0cmFjdCkge1xuICAgICAgdGhpcy5yYWlzZShUU0Vycm9ycy5Qcml2YXRlRWxlbWVudEhhc0Fic3RyYWN0LCBub2RlKTtcbiAgICB9XG4gICAgaWYgKG5vZGUuYWNjZXNzaWJpbGl0eSkge1xuICAgICAgdGhpcy5yYWlzZShUU0Vycm9ycy5Qcml2YXRlRWxlbWVudEhhc0FjY2Vzc2liaWxpdHksIG5vZGUsIHtcbiAgICAgICAgbW9kaWZpZXI6IG5vZGUuYWNjZXNzaWJpbGl0eVxuICAgICAgfSk7XG4gICAgfVxuICAgIHRoaXMucGFyc2VDbGFzc1Byb3BlcnR5QW5ub3RhdGlvbihub2RlKTtcbiAgICByZXR1cm4gc3VwZXIucGFyc2VDbGFzc1ByaXZhdGVQcm9wZXJ0eShub2RlKTtcbiAgfVxuICBwYXJzZUNsYXNzQWNjZXNzb3JQcm9wZXJ0eShub2RlKSB7XG4gICAgdGhpcy5wYXJzZUNsYXNzUHJvcGVydHlBbm5vdGF0aW9uKG5vZGUpO1xuICAgIGlmIChub2RlLm9wdGlvbmFsKSB7XG4gICAgICB0aGlzLnJhaXNlKFRTRXJyb3JzLkFjY2Vzc29yQ2Fubm90QmVPcHRpb25hbCwgbm9kZSk7XG4gICAgfVxuICAgIHJldHVybiBzdXBlci5wYXJzZUNsYXNzQWNjZXNzb3JQcm9wZXJ0eShub2RlKTtcbiAgfVxuICBwdXNoQ2xhc3NNZXRob2QoY2xhc3NCb2R5LCBtZXRob2QsIGlzR2VuZXJhdG9yLCBpc0FzeW5jLCBpc0NvbnN0cnVjdG9yLCBhbGxvd3NEaXJlY3RTdXBlcikge1xuICAgIGNvbnN0IHR5cGVQYXJhbWV0ZXJzID0gdGhpcy50c1RyeVBhcnNlVHlwZVBhcmFtZXRlcnModGhpcy50c1BhcnNlQ29uc3RNb2RpZmllcik7XG4gICAgaWYgKHR5cGVQYXJhbWV0ZXJzICYmIGlzQ29uc3RydWN0b3IpIHtcbiAgICAgIHRoaXMucmFpc2UoVFNFcnJvcnMuQ29uc3RydWN0b3JIYXNUeXBlUGFyYW1ldGVycywgdHlwZVBhcmFtZXRlcnMpO1xuICAgIH1cbiAgICBjb25zdCB7XG4gICAgICBkZWNsYXJlID0gZmFsc2UsXG4gICAgICBraW5kXG4gICAgfSA9IG1ldGhvZDtcbiAgICBpZiAoZGVjbGFyZSAmJiAoa2luZCA9PT0gXCJnZXRcIiB8fCBraW5kID09PSBcInNldFwiKSkge1xuICAgICAgdGhpcy5yYWlzZShUU0Vycm9ycy5EZWNsYXJlQWNjZXNzb3IsIG1ldGhvZCwge1xuICAgICAgICBraW5kXG4gICAgICB9KTtcbiAgICB9XG4gICAgaWYgKHR5cGVQYXJhbWV0ZXJzKSBtZXRob2QudHlwZVBhcmFtZXRlcnMgPSB0eXBlUGFyYW1ldGVycztcbiAgICBzdXBlci5wdXNoQ2xhc3NNZXRob2QoY2xhc3NCb2R5LCBtZXRob2QsIGlzR2VuZXJhdG9yLCBpc0FzeW5jLCBpc0NvbnN0cnVjdG9yLCBhbGxvd3NEaXJlY3RTdXBlcik7XG4gIH1cbiAgcHVzaENsYXNzUHJpdmF0ZU1ldGhvZChjbGFzc0JvZHksIG1ldGhvZCwgaXNHZW5lcmF0b3IsIGlzQXN5bmMpIHtcbiAgICBjb25zdCB0eXBlUGFyYW1ldGVycyA9IHRoaXMudHNUcnlQYXJzZVR5cGVQYXJhbWV0ZXJzKHRoaXMudHNQYXJzZUNvbnN0TW9kaWZpZXIpO1xuICAgIGlmICh0eXBlUGFyYW1ldGVycykgbWV0aG9kLnR5cGVQYXJhbWV0ZXJzID0gdHlwZVBhcmFtZXRlcnM7XG4gICAgc3VwZXIucHVzaENsYXNzUHJpdmF0ZU1ldGhvZChjbGFzc0JvZHksIG1ldGhvZCwgaXNHZW5lcmF0b3IsIGlzQXN5bmMpO1xuICB9XG4gIGRlY2xhcmVDbGFzc1ByaXZhdGVNZXRob2RJblNjb3BlKG5vZGUsIGtpbmQpIHtcbiAgICBpZiAobm9kZS50eXBlID09PSBcIlRTRGVjbGFyZU1ldGhvZFwiKSByZXR1cm47XG4gICAgaWYgKG5vZGUudHlwZSA9PT0gXCJNZXRob2REZWZpbml0aW9uXCIgJiYgbm9kZS52YWx1ZS5ib2R5ID09IG51bGwpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgc3VwZXIuZGVjbGFyZUNsYXNzUHJpdmF0ZU1ldGhvZEluU2NvcGUobm9kZSwga2luZCk7XG4gIH1cbiAgcGFyc2VDbGFzc1N1cGVyKG5vZGUpIHtcbiAgICBzdXBlci5wYXJzZUNsYXNzU3VwZXIobm9kZSk7XG4gICAgaWYgKG5vZGUuc3VwZXJDbGFzcyAmJiAodGhpcy5tYXRjaCg0NykgfHwgdGhpcy5tYXRjaCg1MSkpKSB7XG4gICAgICBub2RlLnN1cGVyVHlwZVBhcmFtZXRlcnMgPSB0aGlzLnRzUGFyc2VUeXBlQXJndW1lbnRzSW5FeHByZXNzaW9uKCk7XG4gICAgfVxuICAgIGlmICh0aGlzLmVhdENvbnRleHR1YWwoMTEzKSkge1xuICAgICAgbm9kZS5pbXBsZW1lbnRzID0gdGhpcy50c1BhcnNlSGVyaXRhZ2VDbGF1c2UoXCJpbXBsZW1lbnRzXCIpO1xuICAgIH1cbiAgfVxuICBwYXJzZU9ialByb3BWYWx1ZShwcm9wLCBzdGFydExvYywgaXNHZW5lcmF0b3IsIGlzQXN5bmMsIGlzUGF0dGVybiwgaXNBY2Nlc3NvciwgcmVmRXhwcmVzc2lvbkVycm9ycykge1xuICAgIGNvbnN0IHR5cGVQYXJhbWV0ZXJzID0gdGhpcy50c1RyeVBhcnNlVHlwZVBhcmFtZXRlcnModGhpcy50c1BhcnNlQ29uc3RNb2RpZmllcik7XG4gICAgaWYgKHR5cGVQYXJhbWV0ZXJzKSBwcm9wLnR5cGVQYXJhbWV0ZXJzID0gdHlwZVBhcmFtZXRlcnM7XG4gICAgcmV0dXJuIHN1cGVyLnBhcnNlT2JqUHJvcFZhbHVlKHByb3AsIHN0YXJ0TG9jLCBpc0dlbmVyYXRvciwgaXNBc3luYywgaXNQYXR0ZXJuLCBpc0FjY2Vzc29yLCByZWZFeHByZXNzaW9uRXJyb3JzKTtcbiAgfVxuICBwYXJzZUZ1bmN0aW9uUGFyYW1zKG5vZGUsIGlzQ29uc3RydWN0b3IpIHtcbiAgICBjb25zdCB0eXBlUGFyYW1ldGVycyA9IHRoaXMudHNUcnlQYXJzZVR5cGVQYXJhbWV0ZXJzKHRoaXMudHNQYXJzZUNvbnN0TW9kaWZpZXIpO1xuICAgIGlmICh0eXBlUGFyYW1ldGVycykgbm9kZS50eXBlUGFyYW1ldGVycyA9IHR5cGVQYXJhbWV0ZXJzO1xuICAgIHN1cGVyLnBhcnNlRnVuY3Rpb25QYXJhbXMobm9kZSwgaXNDb25zdHJ1Y3Rvcik7XG4gIH1cbiAgcGFyc2VWYXJJZChkZWNsLCBraW5kKSB7XG4gICAgc3VwZXIucGFyc2VWYXJJZChkZWNsLCBraW5kKTtcbiAgICBpZiAoZGVjbC5pZC50eXBlID09PSBcIklkZW50aWZpZXJcIiAmJiAhdGhpcy5oYXNQcmVjZWRpbmdMaW5lQnJlYWsoKSAmJiB0aGlzLmVhdCgzNSkpIHtcbiAgICAgIGRlY2wuZGVmaW5pdGUgPSB0cnVlO1xuICAgIH1cbiAgICBjb25zdCB0eXBlID0gdGhpcy50c1RyeVBhcnNlVHlwZUFubm90YXRpb24oKTtcbiAgICBpZiAodHlwZSkge1xuICAgICAgZGVjbC5pZC50eXBlQW5ub3RhdGlvbiA9IHR5cGU7XG4gICAgICB0aGlzLnJlc2V0RW5kTG9jYXRpb24oZGVjbC5pZCk7XG4gICAgfVxuICB9XG4gIHBhcnNlQXN5bmNBcnJvd0Zyb21DYWxsRXhwcmVzc2lvbihub2RlLCBjYWxsKSB7XG4gICAgaWYgKHRoaXMubWF0Y2goMTQpKSB7XG4gICAgICBub2RlLnJldHVyblR5cGUgPSB0aGlzLnRzUGFyc2VUeXBlQW5ub3RhdGlvbigpO1xuICAgIH1cbiAgICByZXR1cm4gc3VwZXIucGFyc2VBc3luY0Fycm93RnJvbUNhbGxFeHByZXNzaW9uKG5vZGUsIGNhbGwpO1xuICB9XG4gIHBhcnNlTWF5YmVBc3NpZ24ocmVmRXhwcmVzc2lvbkVycm9ycywgYWZ0ZXJMZWZ0UGFyc2UpIHtcbiAgICB2YXIgX2pzeCwgX2pzeDIsIF90eXBlQ2FzdCwgX2pzeDMsIF90eXBlQ2FzdDI7XG4gICAgbGV0IHN0YXRlO1xuICAgIGxldCBqc3g7XG4gICAgbGV0IHR5cGVDYXN0O1xuICAgIGlmICh0aGlzLmhhc1BsdWdpbihcImpzeFwiKSAmJiAodGhpcy5tYXRjaCgxNDMpIHx8IHRoaXMubWF0Y2goNDcpKSkge1xuICAgICAgc3RhdGUgPSB0aGlzLnN0YXRlLmNsb25lKCk7XG4gICAgICBqc3ggPSB0aGlzLnRyeVBhcnNlKCgpID0+IHN1cGVyLnBhcnNlTWF5YmVBc3NpZ24ocmVmRXhwcmVzc2lvbkVycm9ycywgYWZ0ZXJMZWZ0UGFyc2UpLCBzdGF0ZSk7XG4gICAgICBpZiAoIWpzeC5lcnJvcikgcmV0dXJuIGpzeC5ub2RlO1xuICAgICAgY29uc3Qge1xuICAgICAgICBjb250ZXh0XG4gICAgICB9ID0gdGhpcy5zdGF0ZTtcbiAgICAgIGNvbnN0IGN1cnJlbnRDb250ZXh0ID0gY29udGV4dFtjb250ZXh0Lmxlbmd0aCAtIDFdO1xuICAgICAgaWYgKGN1cnJlbnRDb250ZXh0ID09PSB0eXBlcy5qX29UYWcgfHwgY3VycmVudENvbnRleHQgPT09IHR5cGVzLmpfZXhwcikge1xuICAgICAgICBjb250ZXh0LnBvcCgpO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoISgoX2pzeCA9IGpzeCkgIT0gbnVsbCAmJiBfanN4LmVycm9yKSAmJiAhdGhpcy5tYXRjaCg0NykpIHtcbiAgICAgIHJldHVybiBzdXBlci5wYXJzZU1heWJlQXNzaWduKHJlZkV4cHJlc3Npb25FcnJvcnMsIGFmdGVyTGVmdFBhcnNlKTtcbiAgICB9XG4gICAgaWYgKCFzdGF0ZSB8fCBzdGF0ZSA9PT0gdGhpcy5zdGF0ZSkgc3RhdGUgPSB0aGlzLnN0YXRlLmNsb25lKCk7XG4gICAgbGV0IHR5cGVQYXJhbWV0ZXJzO1xuICAgIGNvbnN0IGFycm93ID0gdGhpcy50cnlQYXJzZShhYm9ydCA9PiB7XG4gICAgICB2YXIgX2V4cHIkZXh0cmEsIF90eXBlUGFyYW1ldGVycztcbiAgICAgIHR5cGVQYXJhbWV0ZXJzID0gdGhpcy50c1BhcnNlVHlwZVBhcmFtZXRlcnModGhpcy50c1BhcnNlQ29uc3RNb2RpZmllcik7XG4gICAgICBjb25zdCBleHByID0gc3VwZXIucGFyc2VNYXliZUFzc2lnbihyZWZFeHByZXNzaW9uRXJyb3JzLCBhZnRlckxlZnRQYXJzZSk7XG4gICAgICBpZiAoZXhwci50eXBlICE9PSBcIkFycm93RnVuY3Rpb25FeHByZXNzaW9uXCIgfHwgKF9leHByJGV4dHJhID0gZXhwci5leHRyYSkgIT0gbnVsbCAmJiBfZXhwciRleHRyYS5wYXJlbnRoZXNpemVkKSB7XG4gICAgICAgIGFib3J0KCk7XG4gICAgICB9XG4gICAgICBpZiAoKChfdHlwZVBhcmFtZXRlcnMgPSB0eXBlUGFyYW1ldGVycykgPT0gbnVsbCA/IHZvaWQgMCA6IF90eXBlUGFyYW1ldGVycy5wYXJhbXMubGVuZ3RoKSAhPT0gMCkge1xuICAgICAgICB0aGlzLnJlc2V0U3RhcnRMb2NhdGlvbkZyb21Ob2RlKGV4cHIsIHR5cGVQYXJhbWV0ZXJzKTtcbiAgICAgIH1cbiAgICAgIGV4cHIudHlwZVBhcmFtZXRlcnMgPSB0eXBlUGFyYW1ldGVycztcbiAgICAgIHJldHVybiBleHByO1xuICAgIH0sIHN0YXRlKTtcbiAgICBpZiAoIWFycm93LmVycm9yICYmICFhcnJvdy5hYm9ydGVkKSB7XG4gICAgICBpZiAodHlwZVBhcmFtZXRlcnMpIHRoaXMucmVwb3J0UmVzZXJ2ZWRBcnJvd1R5cGVQYXJhbSh0eXBlUGFyYW1ldGVycyk7XG4gICAgICByZXR1cm4gYXJyb3cubm9kZTtcbiAgICB9XG4gICAgaWYgKCFqc3gpIHtcbiAgICAgIGFzc2VydCghdGhpcy5oYXNQbHVnaW4oXCJqc3hcIikpO1xuICAgICAgdHlwZUNhc3QgPSB0aGlzLnRyeVBhcnNlKCgpID0+IHN1cGVyLnBhcnNlTWF5YmVBc3NpZ24ocmVmRXhwcmVzc2lvbkVycm9ycywgYWZ0ZXJMZWZ0UGFyc2UpLCBzdGF0ZSk7XG4gICAgICBpZiAoIXR5cGVDYXN0LmVycm9yKSByZXR1cm4gdHlwZUNhc3Qubm9kZTtcbiAgICB9XG4gICAgaWYgKChfanN4MiA9IGpzeCkgIT0gbnVsbCAmJiBfanN4Mi5ub2RlKSB7XG4gICAgICB0aGlzLnN0YXRlID0ganN4LmZhaWxTdGF0ZTtcbiAgICAgIHJldHVybiBqc3gubm9kZTtcbiAgICB9XG4gICAgaWYgKGFycm93Lm5vZGUpIHtcbiAgICAgIHRoaXMuc3RhdGUgPSBhcnJvdy5mYWlsU3RhdGU7XG4gICAgICBpZiAodHlwZVBhcmFtZXRlcnMpIHRoaXMucmVwb3J0UmVzZXJ2ZWRBcnJvd1R5cGVQYXJhbSh0eXBlUGFyYW1ldGVycyk7XG4gICAgICByZXR1cm4gYXJyb3cubm9kZTtcbiAgICB9XG4gICAgaWYgKChfdHlwZUNhc3QgPSB0eXBlQ2FzdCkgIT0gbnVsbCAmJiBfdHlwZUNhc3Qubm9kZSkge1xuICAgICAgdGhpcy5zdGF0ZSA9IHR5cGVDYXN0LmZhaWxTdGF0ZTtcbiAgICAgIHJldHVybiB0eXBlQ2FzdC5ub2RlO1xuICAgIH1cbiAgICB0aHJvdyAoKF9qc3gzID0ganN4KSA9PSBudWxsID8gdm9pZCAwIDogX2pzeDMuZXJyb3IpIHx8IGFycm93LmVycm9yIHx8ICgoX3R5cGVDYXN0MiA9IHR5cGVDYXN0KSA9PSBudWxsID8gdm9pZCAwIDogX3R5cGVDYXN0Mi5lcnJvcik7XG4gIH1cbiAgcmVwb3J0UmVzZXJ2ZWRBcnJvd1R5cGVQYXJhbShub2RlKSB7XG4gICAgdmFyIF9ub2RlJGV4dHJhMjtcbiAgICBpZiAobm9kZS5wYXJhbXMubGVuZ3RoID09PSAxICYmICFub2RlLnBhcmFtc1swXS5jb25zdHJhaW50ICYmICEoKF9ub2RlJGV4dHJhMiA9IG5vZGUuZXh0cmEpICE9IG51bGwgJiYgX25vZGUkZXh0cmEyLnRyYWlsaW5nQ29tbWEpICYmIHRoaXMuZ2V0UGx1Z2luT3B0aW9uKFwidHlwZXNjcmlwdFwiLCBcImRpc2FsbG93QW1iaWd1b3VzSlNYTGlrZVwiKSkge1xuICAgICAgdGhpcy5yYWlzZShUU0Vycm9ycy5SZXNlcnZlZEFycm93VHlwZVBhcmFtLCBub2RlKTtcbiAgICB9XG4gIH1cbiAgcGFyc2VNYXliZVVuYXJ5KHJlZkV4cHJlc3Npb25FcnJvcnMsIHNhd1VuYXJ5KSB7XG4gICAgaWYgKCF0aGlzLmhhc1BsdWdpbihcImpzeFwiKSAmJiB0aGlzLm1hdGNoKDQ3KSkge1xuICAgICAgcmV0dXJuIHRoaXMudHNQYXJzZVR5cGVBc3NlcnRpb24oKTtcbiAgICB9XG4gICAgcmV0dXJuIHN1cGVyLnBhcnNlTWF5YmVVbmFyeShyZWZFeHByZXNzaW9uRXJyb3JzLCBzYXdVbmFyeSk7XG4gIH1cbiAgcGFyc2VBcnJvdyhub2RlKSB7XG4gICAgaWYgKHRoaXMubWF0Y2goMTQpKSB7XG4gICAgICBjb25zdCByZXN1bHQgPSB0aGlzLnRyeVBhcnNlKGFib3J0ID0+IHtcbiAgICAgICAgY29uc3QgcmV0dXJuVHlwZSA9IHRoaXMudHNQYXJzZVR5cGVPclR5cGVQcmVkaWNhdGVBbm5vdGF0aW9uKDE0KTtcbiAgICAgICAgaWYgKHRoaXMuY2FuSW5zZXJ0U2VtaWNvbG9uKCkgfHwgIXRoaXMubWF0Y2goMTkpKSBhYm9ydCgpO1xuICAgICAgICByZXR1cm4gcmV0dXJuVHlwZTtcbiAgICAgIH0pO1xuICAgICAgaWYgKHJlc3VsdC5hYm9ydGVkKSByZXR1cm47XG4gICAgICBpZiAoIXJlc3VsdC50aHJvd24pIHtcbiAgICAgICAgaWYgKHJlc3VsdC5lcnJvcikgdGhpcy5zdGF0ZSA9IHJlc3VsdC5mYWlsU3RhdGU7XG4gICAgICAgIG5vZGUucmV0dXJuVHlwZSA9IHJlc3VsdC5ub2RlO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gc3VwZXIucGFyc2VBcnJvdyhub2RlKTtcbiAgfVxuICBwYXJzZUZ1bmN0aW9uUGFyYW1UeXBlKHBhcmFtKSB7XG4gICAgaWYgKHRoaXMuZWF0KDE3KSkge1xuICAgICAgcGFyYW0ub3B0aW9uYWwgPSB0cnVlO1xuICAgIH1cbiAgICBjb25zdCB0eXBlID0gdGhpcy50c1RyeVBhcnNlVHlwZUFubm90YXRpb24oKTtcbiAgICBpZiAodHlwZSkgcGFyYW0udHlwZUFubm90YXRpb24gPSB0eXBlO1xuICAgIHRoaXMucmVzZXRFbmRMb2NhdGlvbihwYXJhbSk7XG4gICAgcmV0dXJuIHBhcmFtO1xuICB9XG4gIGlzQXNzaWduYWJsZShub2RlLCBpc0JpbmRpbmcpIHtcbiAgICBzd2l0Y2ggKG5vZGUudHlwZSkge1xuICAgICAgY2FzZSBcIlRTVHlwZUNhc3RFeHByZXNzaW9uXCI6XG4gICAgICAgIHJldHVybiB0aGlzLmlzQXNzaWduYWJsZShub2RlLmV4cHJlc3Npb24sIGlzQmluZGluZyk7XG4gICAgICBjYXNlIFwiVFNQYXJhbWV0ZXJQcm9wZXJ0eVwiOlxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHJldHVybiBzdXBlci5pc0Fzc2lnbmFibGUobm9kZSwgaXNCaW5kaW5nKTtcbiAgICB9XG4gIH1cbiAgdG9Bc3NpZ25hYmxlKG5vZGUsIGlzTEhTID0gZmFsc2UpIHtcbiAgICBzd2l0Y2ggKG5vZGUudHlwZSkge1xuICAgICAgY2FzZSBcIlBhcmVudGhlc2l6ZWRFeHByZXNzaW9uXCI6XG4gICAgICAgIHRoaXMudG9Bc3NpZ25hYmxlUGFyZW50aGVzaXplZEV4cHJlc3Npb24obm9kZSwgaXNMSFMpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgXCJUU0FzRXhwcmVzc2lvblwiOlxuICAgICAgY2FzZSBcIlRTU2F0aXNmaWVzRXhwcmVzc2lvblwiOlxuICAgICAgY2FzZSBcIlRTTm9uTnVsbEV4cHJlc3Npb25cIjpcbiAgICAgIGNhc2UgXCJUU1R5cGVBc3NlcnRpb25cIjpcbiAgICAgICAgaWYgKGlzTEhTKSB7XG4gICAgICAgICAgdGhpcy5leHByZXNzaW9uU2NvcGUucmVjb3JkQXJyb3dQYXJhbWV0ZXJCaW5kaW5nRXJyb3IoVFNFcnJvcnMuVW5leHBlY3RlZFR5cGVDYXN0SW5QYXJhbWV0ZXIsIG5vZGUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMucmFpc2UoVFNFcnJvcnMuVW5leHBlY3RlZFR5cGVDYXN0SW5QYXJhbWV0ZXIsIG5vZGUpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMudG9Bc3NpZ25hYmxlKG5vZGUuZXhwcmVzc2lvbiwgaXNMSFMpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgXCJBc3NpZ25tZW50RXhwcmVzc2lvblwiOlxuICAgICAgICBpZiAoIWlzTEhTICYmIG5vZGUubGVmdC50eXBlID09PSBcIlRTVHlwZUNhc3RFeHByZXNzaW9uXCIpIHtcbiAgICAgICAgICBub2RlLmxlZnQgPSB0aGlzLnR5cGVDYXN0VG9QYXJhbWV0ZXIobm9kZS5sZWZ0KTtcbiAgICAgICAgfVxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgc3VwZXIudG9Bc3NpZ25hYmxlKG5vZGUsIGlzTEhTKTtcbiAgICB9XG4gIH1cbiAgdG9Bc3NpZ25hYmxlUGFyZW50aGVzaXplZEV4cHJlc3Npb24obm9kZSwgaXNMSFMpIHtcbiAgICBzd2l0Y2ggKG5vZGUuZXhwcmVzc2lvbi50eXBlKSB7XG4gICAgICBjYXNlIFwiVFNBc0V4cHJlc3Npb25cIjpcbiAgICAgIGNhc2UgXCJUU1NhdGlzZmllc0V4cHJlc3Npb25cIjpcbiAgICAgIGNhc2UgXCJUU05vbk51bGxFeHByZXNzaW9uXCI6XG4gICAgICBjYXNlIFwiVFNUeXBlQXNzZXJ0aW9uXCI6XG4gICAgICBjYXNlIFwiUGFyZW50aGVzaXplZEV4cHJlc3Npb25cIjpcbiAgICAgICAgdGhpcy50b0Fzc2lnbmFibGUobm9kZS5leHByZXNzaW9uLCBpc0xIUyk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgc3VwZXIudG9Bc3NpZ25hYmxlKG5vZGUsIGlzTEhTKTtcbiAgICB9XG4gIH1cbiAgY2hlY2tUb1Jlc3RDb252ZXJzaW9uKG5vZGUsIGFsbG93UGF0dGVybikge1xuICAgIHN3aXRjaCAobm9kZS50eXBlKSB7XG4gICAgICBjYXNlIFwiVFNBc0V4cHJlc3Npb25cIjpcbiAgICAgIGNhc2UgXCJUU1NhdGlzZmllc0V4cHJlc3Npb25cIjpcbiAgICAgIGNhc2UgXCJUU1R5cGVBc3NlcnRpb25cIjpcbiAgICAgIGNhc2UgXCJUU05vbk51bGxFeHByZXNzaW9uXCI6XG4gICAgICAgIHRoaXMuY2hlY2tUb1Jlc3RDb252ZXJzaW9uKG5vZGUuZXhwcmVzc2lvbiwgZmFsc2UpO1xuICAgICAgICBicmVhaztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHN1cGVyLmNoZWNrVG9SZXN0Q29udmVyc2lvbihub2RlLCBhbGxvd1BhdHRlcm4pO1xuICAgIH1cbiAgfVxuICBpc1ZhbGlkTFZhbCh0eXBlLCBkaXNhbGxvd0NhbGxFeHByZXNzaW9uLCBpc1VucGFyZW50aGVzaXplZEluQXNzaWduLCBiaW5kaW5nKSB7XG4gICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICBjYXNlIFwiVFNUeXBlQ2FzdEV4cHJlc3Npb25cIjpcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICBjYXNlIFwiVFNQYXJhbWV0ZXJQcm9wZXJ0eVwiOlxuICAgICAgICByZXR1cm4gXCJwYXJhbWV0ZXJcIjtcbiAgICAgIGNhc2UgXCJUU05vbk51bGxFeHByZXNzaW9uXCI6XG4gICAgICAgIHJldHVybiBcImV4cHJlc3Npb25cIjtcbiAgICAgIGNhc2UgXCJUU0FzRXhwcmVzc2lvblwiOlxuICAgICAgY2FzZSBcIlRTU2F0aXNmaWVzRXhwcmVzc2lvblwiOlxuICAgICAgY2FzZSBcIlRTVHlwZUFzc2VydGlvblwiOlxuICAgICAgICByZXR1cm4gKGJpbmRpbmcgIT09IDY0IHx8ICFpc1VucGFyZW50aGVzaXplZEluQXNzaWduKSAmJiBbXCJleHByZXNzaW9uXCIsIHRydWVdO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcmV0dXJuIHN1cGVyLmlzVmFsaWRMVmFsKHR5cGUsIGRpc2FsbG93Q2FsbEV4cHJlc3Npb24sIGlzVW5wYXJlbnRoZXNpemVkSW5Bc3NpZ24sIGJpbmRpbmcpO1xuICAgIH1cbiAgfVxuICBwYXJzZUJpbmRpbmdBdG9tKCkge1xuICAgIGlmICh0aGlzLnN0YXRlLnR5cGUgPT09IDc4KSB7XG4gICAgICByZXR1cm4gdGhpcy5wYXJzZUlkZW50aWZpZXIodHJ1ZSk7XG4gICAgfVxuICAgIHJldHVybiBzdXBlci5wYXJzZUJpbmRpbmdBdG9tKCk7XG4gIH1cbiAgcGFyc2VNYXliZURlY29yYXRvckFyZ3VtZW50cyhleHByLCBzdGFydExvYykge1xuICAgIGlmICh0aGlzLm1hdGNoKDQ3KSB8fCB0aGlzLm1hdGNoKDUxKSkge1xuICAgICAgY29uc3QgdHlwZUFyZ3VtZW50cyA9IHRoaXMudHNQYXJzZVR5cGVBcmd1bWVudHNJbkV4cHJlc3Npb24oKTtcbiAgICAgIGlmICh0aGlzLm1hdGNoKDEwKSkge1xuICAgICAgICBjb25zdCBjYWxsID0gc3VwZXIucGFyc2VNYXliZURlY29yYXRvckFyZ3VtZW50cyhleHByLCBzdGFydExvYyk7XG4gICAgICAgIGNhbGwudHlwZVBhcmFtZXRlcnMgPSB0eXBlQXJndW1lbnRzO1xuICAgICAgICByZXR1cm4gY2FsbDtcbiAgICAgIH1cbiAgICAgIHRoaXMudW5leHBlY3RlZChudWxsLCAxMCk7XG4gICAgfVxuICAgIHJldHVybiBzdXBlci5wYXJzZU1heWJlRGVjb3JhdG9yQXJndW1lbnRzKGV4cHIsIHN0YXJ0TG9jKTtcbiAgfVxuICBjaGVja0NvbW1hQWZ0ZXJSZXN0KGNsb3NlKSB7XG4gICAgaWYgKHRoaXMuc3RhdGUuaXNBbWJpZW50Q29udGV4dCAmJiB0aGlzLm1hdGNoKDEyKSAmJiB0aGlzLmxvb2thaGVhZENoYXJDb2RlKCkgPT09IGNsb3NlKSB7XG4gICAgICB0aGlzLm5leHQoKTtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuIHN1cGVyLmNoZWNrQ29tbWFBZnRlclJlc3QoY2xvc2UpO1xuICB9XG4gIGlzQ2xhc3NNZXRob2QoKSB7XG4gICAgcmV0dXJuIHRoaXMubWF0Y2goNDcpIHx8IHN1cGVyLmlzQ2xhc3NNZXRob2QoKTtcbiAgfVxuICBpc0NsYXNzUHJvcGVydHkoKSB7XG4gICAgcmV0dXJuIHRoaXMubWF0Y2goMzUpIHx8IHRoaXMubWF0Y2goMTQpIHx8IHN1cGVyLmlzQ2xhc3NQcm9wZXJ0eSgpO1xuICB9XG4gIHBhcnNlTWF5YmVEZWZhdWx0KHN0YXJ0TG9jLCBsZWZ0KSB7XG4gICAgY29uc3Qgbm9kZSA9IHN1cGVyLnBhcnNlTWF5YmVEZWZhdWx0KHN0YXJ0TG9jLCBsZWZ0KTtcbiAgICBpZiAobm9kZS50eXBlID09PSBcIkFzc2lnbm1lbnRQYXR0ZXJuXCIgJiYgbm9kZS50eXBlQW5ub3RhdGlvbiAmJiBub2RlLnJpZ2h0LnN0YXJ0IDwgbm9kZS50eXBlQW5ub3RhdGlvbi5zdGFydCkge1xuICAgICAgdGhpcy5yYWlzZShUU0Vycm9ycy5UeXBlQW5ub3RhdGlvbkFmdGVyQXNzaWduLCBub2RlLnR5cGVBbm5vdGF0aW9uKTtcbiAgICB9XG4gICAgcmV0dXJuIG5vZGU7XG4gIH1cbiAgZ2V0VG9rZW5Gcm9tQ29kZShjb2RlKSB7XG4gICAgaWYgKHRoaXMuc3RhdGUuaW5UeXBlKSB7XG4gICAgICBpZiAoY29kZSA9PT0gNjIpIHtcbiAgICAgICAgdGhpcy5maW5pc2hPcCg0OCwgMSk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGlmIChjb2RlID09PSA2MCkge1xuICAgICAgICB0aGlzLmZpbmlzaE9wKDQ3LCAxKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgIH1cbiAgICBzdXBlci5nZXRUb2tlbkZyb21Db2RlKGNvZGUpO1xuICB9XG4gIHJlU2Nhbl9sdF9ndCgpIHtcbiAgICBjb25zdCB7XG4gICAgICB0eXBlXG4gICAgfSA9IHRoaXMuc3RhdGU7XG4gICAgaWYgKHR5cGUgPT09IDQ3KSB7XG4gICAgICB0aGlzLnN0YXRlLnBvcyAtPSAxO1xuICAgICAgdGhpcy5yZWFkVG9rZW5fbHQoKTtcbiAgICB9IGVsc2UgaWYgKHR5cGUgPT09IDQ4KSB7XG4gICAgICB0aGlzLnN0YXRlLnBvcyAtPSAxO1xuICAgICAgdGhpcy5yZWFkVG9rZW5fZ3QoKTtcbiAgICB9XG4gIH1cbiAgcmVTY2FuX2x0KCkge1xuICAgIGNvbnN0IHtcbiAgICAgIHR5cGVcbiAgICB9ID0gdGhpcy5zdGF0ZTtcbiAgICBpZiAodHlwZSA9PT0gNTEpIHtcbiAgICAgIHRoaXMuc3RhdGUucG9zIC09IDI7XG4gICAgICB0aGlzLmZpbmlzaE9wKDQ3LCAxKTtcbiAgICAgIHJldHVybiA0NztcbiAgICB9XG4gICAgcmV0dXJuIHR5cGU7XG4gIH1cbiAgdG9Bc3NpZ25hYmxlTGlzdEl0ZW0oZXhwckxpc3QsIGluZGV4LCBpc0xIUykge1xuICAgIGNvbnN0IG5vZGUgPSBleHByTGlzdFtpbmRleF07XG4gICAgaWYgKG5vZGUudHlwZSA9PT0gXCJUU1R5cGVDYXN0RXhwcmVzc2lvblwiKSB7XG4gICAgICBleHByTGlzdFtpbmRleF0gPSB0aGlzLnR5cGVDYXN0VG9QYXJhbWV0ZXIobm9kZSk7XG4gICAgfVxuICAgIHN1cGVyLnRvQXNzaWduYWJsZUxpc3RJdGVtKGV4cHJMaXN0LCBpbmRleCwgaXNMSFMpO1xuICB9XG4gIHR5cGVDYXN0VG9QYXJhbWV0ZXIobm9kZSkge1xuICAgIG5vZGUuZXhwcmVzc2lvbi50eXBlQW5ub3RhdGlvbiA9IG5vZGUudHlwZUFubm90YXRpb247XG4gICAgdGhpcy5yZXNldEVuZExvY2F0aW9uKG5vZGUuZXhwcmVzc2lvbiwgbm9kZS50eXBlQW5ub3RhdGlvbi5sb2MuZW5kKTtcbiAgICByZXR1cm4gbm9kZS5leHByZXNzaW9uO1xuICB9XG4gIHNob3VsZFBhcnNlQXJyb3cocGFyYW1zKSB7XG4gICAgaWYgKHRoaXMubWF0Y2goMTQpKSB7XG4gICAgICByZXR1cm4gcGFyYW1zLmV2ZXJ5KGV4cHIgPT4gdGhpcy5pc0Fzc2lnbmFibGUoZXhwciwgdHJ1ZSkpO1xuICAgIH1cbiAgICByZXR1cm4gc3VwZXIuc2hvdWxkUGFyc2VBcnJvdyhwYXJhbXMpO1xuICB9XG4gIHNob3VsZFBhcnNlQXN5bmNBcnJvdygpIHtcbiAgICByZXR1cm4gdGhpcy5tYXRjaCgxNCkgfHwgc3VwZXIuc2hvdWxkUGFyc2VBc3luY0Fycm93KCk7XG4gIH1cbiAgY2FuSGF2ZUxlYWRpbmdEZWNvcmF0b3IoKSB7XG4gICAgcmV0dXJuIHN1cGVyLmNhbkhhdmVMZWFkaW5nRGVjb3JhdG9yKCkgfHwgdGhpcy5pc0Fic3RyYWN0Q2xhc3MoKTtcbiAgfVxuICBqc3hQYXJzZU9wZW5pbmdFbGVtZW50QWZ0ZXJOYW1lKG5vZGUpIHtcbiAgICBpZiAodGhpcy5tYXRjaCg0NykgfHwgdGhpcy5tYXRjaCg1MSkpIHtcbiAgICAgIGNvbnN0IHR5cGVBcmd1bWVudHMgPSB0aGlzLnRzVHJ5UGFyc2VBbmRDYXRjaCgoKSA9PiB0aGlzLnRzUGFyc2VUeXBlQXJndW1lbnRzSW5FeHByZXNzaW9uKCkpO1xuICAgICAgaWYgKHR5cGVBcmd1bWVudHMpIHtcbiAgICAgICAgbm9kZS50eXBlUGFyYW1ldGVycyA9IHR5cGVBcmd1bWVudHM7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBzdXBlci5qc3hQYXJzZU9wZW5pbmdFbGVtZW50QWZ0ZXJOYW1lKG5vZGUpO1xuICB9XG4gIGdldEdldHRlclNldHRlckV4cGVjdGVkUGFyYW1Db3VudChtZXRob2QpIHtcbiAgICBjb25zdCBiYXNlQ291bnQgPSBzdXBlci5nZXRHZXR0ZXJTZXR0ZXJFeHBlY3RlZFBhcmFtQ291bnQobWV0aG9kKTtcbiAgICBjb25zdCBwYXJhbXMgPSB0aGlzLmdldE9iamVjdE9yQ2xhc3NNZXRob2RQYXJhbXMobWV0aG9kKTtcbiAgICBjb25zdCBmaXJzdFBhcmFtID0gcGFyYW1zWzBdO1xuICAgIGNvbnN0IGhhc0NvbnRleHRQYXJhbSA9IGZpcnN0UGFyYW0gJiYgdGhpcy5pc1RoaXNQYXJhbShmaXJzdFBhcmFtKTtcbiAgICByZXR1cm4gaGFzQ29udGV4dFBhcmFtID8gYmFzZUNvdW50ICsgMSA6IGJhc2VDb3VudDtcbiAgfVxuICBwYXJzZUNhdGNoQ2xhdXNlUGFyYW0oKSB7XG4gICAgY29uc3QgcGFyYW0gPSBzdXBlci5wYXJzZUNhdGNoQ2xhdXNlUGFyYW0oKTtcbiAgICBjb25zdCB0eXBlID0gdGhpcy50c1RyeVBhcnNlVHlwZUFubm90YXRpb24oKTtcbiAgICBpZiAodHlwZSkge1xuICAgICAgcGFyYW0udHlwZUFubm90YXRpb24gPSB0eXBlO1xuICAgICAgdGhpcy5yZXNldEVuZExvY2F0aW9uKHBhcmFtKTtcbiAgICB9XG4gICAgcmV0dXJuIHBhcmFtO1xuICB9XG4gIHRzSW5BbWJpZW50Q29udGV4dChjYikge1xuICAgIGNvbnN0IHtcbiAgICAgIGlzQW1iaWVudENvbnRleHQ6IG9sZElzQW1iaWVudENvbnRleHQsXG4gICAgICBzdHJpY3Q6IG9sZFN0cmljdFxuICAgIH0gPSB0aGlzLnN0YXRlO1xuICAgIHRoaXMuc3RhdGUuaXNBbWJpZW50Q29udGV4dCA9IHRydWU7XG4gICAgdGhpcy5zdGF0ZS5zdHJpY3QgPSBmYWxzZTtcbiAgICB0cnkge1xuICAgICAgcmV0dXJuIGNiKCk7XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIHRoaXMuc3RhdGUuaXNBbWJpZW50Q29udGV4dCA9IG9sZElzQW1iaWVudENvbnRleHQ7XG4gICAgICB0aGlzLnN0YXRlLnN0cmljdCA9IG9sZFN0cmljdDtcbiAgICB9XG4gIH1cbiAgcGFyc2VDbGFzcyhub2RlLCBpc1N0YXRlbWVudCwgb3B0aW9uYWxJZCkge1xuICAgIGNvbnN0IG9sZEluQWJzdHJhY3RDbGFzcyA9IHRoaXMuc3RhdGUuaW5BYnN0cmFjdENsYXNzO1xuICAgIHRoaXMuc3RhdGUuaW5BYnN0cmFjdENsYXNzID0gISFub2RlLmFic3RyYWN0O1xuICAgIHRyeSB7XG4gICAgICByZXR1cm4gc3VwZXIucGFyc2VDbGFzcyhub2RlLCBpc1N0YXRlbWVudCwgb3B0aW9uYWxJZCk7XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIHRoaXMuc3RhdGUuaW5BYnN0cmFjdENsYXNzID0gb2xkSW5BYnN0cmFjdENsYXNzO1xuICAgIH1cbiAgfVxuICB0c1BhcnNlQWJzdHJhY3REZWNsYXJhdGlvbihub2RlLCBkZWNvcmF0b3JzKSB7XG4gICAgaWYgKHRoaXMubWF0Y2goODApKSB7XG4gICAgICBub2RlLmFic3RyYWN0ID0gdHJ1ZTtcbiAgICAgIHJldHVybiB0aGlzLm1heWJlVGFrZURlY29yYXRvcnMoZGVjb3JhdG9ycywgdGhpcy5wYXJzZUNsYXNzKG5vZGUsIHRydWUsIGZhbHNlKSk7XG4gICAgfSBlbHNlIGlmICh0aGlzLmlzQ29udGV4dHVhbCgxMjkpKSB7XG4gICAgICBpZiAoIXRoaXMuaGFzRm9sbG93aW5nTGluZUJyZWFrKCkpIHtcbiAgICAgICAgbm9kZS5hYnN0cmFjdCA9IHRydWU7XG4gICAgICAgIHRoaXMucmFpc2UoVFNFcnJvcnMuTm9uQ2xhc3NNZXRob2RQcm9wZXJ0eUhhc0Fic3RyYWN0TW9kaWZpZXIsIG5vZGUpO1xuICAgICAgICByZXR1cm4gdGhpcy50c1BhcnNlSW50ZXJmYWNlRGVjbGFyYXRpb24obm9kZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICB9XG4gICAgdGhyb3cgdGhpcy51bmV4cGVjdGVkKG51bGwsIDgwKTtcbiAgfVxuICBwYXJzZU1ldGhvZChub2RlLCBpc0dlbmVyYXRvciwgaXNBc3luYywgaXNDb25zdHJ1Y3RvciwgYWxsb3dEaXJlY3RTdXBlciwgdHlwZSwgaW5DbGFzc1Njb3BlKSB7XG4gICAgY29uc3QgbWV0aG9kID0gc3VwZXIucGFyc2VNZXRob2Qobm9kZSwgaXNHZW5lcmF0b3IsIGlzQXN5bmMsIGlzQ29uc3RydWN0b3IsIGFsbG93RGlyZWN0U3VwZXIsIHR5cGUsIGluQ2xhc3NTY29wZSk7XG4gICAgaWYgKG1ldGhvZC5hYnN0cmFjdCB8fCBtZXRob2QudHlwZSA9PT0gXCJUU0Fic3RyYWN0TWV0aG9kRGVmaW5pdGlvblwiKSB7XG4gICAgICBjb25zdCBoYXNFc3RyZWVQbHVnaW4gPSB0aGlzLmhhc1BsdWdpbihcImVzdHJlZVwiKTtcbiAgICAgIGNvbnN0IG1ldGhvZEZuID0gaGFzRXN0cmVlUGx1Z2luID8gbWV0aG9kLnZhbHVlIDogbWV0aG9kO1xuICAgICAgaWYgKG1ldGhvZEZuLmJvZHkpIHtcbiAgICAgICAgY29uc3Qge1xuICAgICAgICAgIGtleVxuICAgICAgICB9ID0gbWV0aG9kO1xuICAgICAgICB0aGlzLnJhaXNlKFRTRXJyb3JzLkFic3RyYWN0TWV0aG9kSGFzSW1wbGVtZW50YXRpb24sIG1ldGhvZCwge1xuICAgICAgICAgIG1ldGhvZE5hbWU6IGtleS50eXBlID09PSBcIklkZW50aWZpZXJcIiAmJiAhbWV0aG9kLmNvbXB1dGVkID8ga2V5Lm5hbWUgOiBgWyR7dGhpcy5pbnB1dC5zbGljZSh0aGlzLm9mZnNldFRvU291cmNlUG9zKGtleS5zdGFydCksIHRoaXMub2Zmc2V0VG9Tb3VyY2VQb3Moa2V5LmVuZCkpfV1gXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbWV0aG9kO1xuICB9XG4gIHRzUGFyc2VUeXBlUGFyYW1ldGVyTmFtZSgpIHtcbiAgICBjb25zdCB0eXBlTmFtZSA9IHRoaXMucGFyc2VJZGVudGlmaWVyKCk7XG4gICAgcmV0dXJuIHR5cGVOYW1lLm5hbWU7XG4gIH1cbiAgc2hvdWxkUGFyc2VBc0FtYmllbnRDb250ZXh0KCkge1xuICAgIHJldHVybiAhIXRoaXMuZ2V0UGx1Z2luT3B0aW9uKFwidHlwZXNjcmlwdFwiLCBcImR0c1wiKTtcbiAgfVxuICBwYXJzZSgpIHtcbiAgICBpZiAodGhpcy5zaG91bGRQYXJzZUFzQW1iaWVudENvbnRleHQoKSkge1xuICAgICAgdGhpcy5zdGF0ZS5pc0FtYmllbnRDb250ZXh0ID0gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIHN1cGVyLnBhcnNlKCk7XG4gIH1cbiAgZ2V0RXhwcmVzc2lvbigpIHtcbiAgICBpZiAodGhpcy5zaG91bGRQYXJzZUFzQW1iaWVudENvbnRleHQoKSkge1xuICAgICAgdGhpcy5zdGF0ZS5pc0FtYmllbnRDb250ZXh0ID0gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIHN1cGVyLmdldEV4cHJlc3Npb24oKTtcbiAgfVxuICBwYXJzZUV4cG9ydFNwZWNpZmllcihub2RlLCBpc1N0cmluZywgaXNJblR5cGVFeHBvcnQsIGlzTWF5YmVUeXBlT25seSkge1xuICAgIGlmICghaXNTdHJpbmcgJiYgaXNNYXliZVR5cGVPbmx5KSB7XG4gICAgICB0aGlzLnBhcnNlVHlwZU9ubHlJbXBvcnRFeHBvcnRTcGVjaWZpZXIobm9kZSwgZmFsc2UsIGlzSW5UeXBlRXhwb3J0KTtcbiAgICAgIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJFeHBvcnRTcGVjaWZpZXJcIik7XG4gICAgfVxuICAgIG5vZGUuZXhwb3J0S2luZCA9IFwidmFsdWVcIjtcbiAgICByZXR1cm4gc3VwZXIucGFyc2VFeHBvcnRTcGVjaWZpZXIobm9kZSwgaXNTdHJpbmcsIGlzSW5UeXBlRXhwb3J0LCBpc01heWJlVHlwZU9ubHkpO1xuICB9XG4gIHBhcnNlSW1wb3J0U3BlY2lmaWVyKHNwZWNpZmllciwgaW1wb3J0ZWRJc1N0cmluZywgaXNJblR5cGVPbmx5SW1wb3J0LCBpc01heWJlVHlwZU9ubHksIGJpbmRpbmdUeXBlKSB7XG4gICAgaWYgKCFpbXBvcnRlZElzU3RyaW5nICYmIGlzTWF5YmVUeXBlT25seSkge1xuICAgICAgdGhpcy5wYXJzZVR5cGVPbmx5SW1wb3J0RXhwb3J0U3BlY2lmaWVyKHNwZWNpZmllciwgdHJ1ZSwgaXNJblR5cGVPbmx5SW1wb3J0KTtcbiAgICAgIHJldHVybiB0aGlzLmZpbmlzaE5vZGUoc3BlY2lmaWVyLCBcIkltcG9ydFNwZWNpZmllclwiKTtcbiAgICB9XG4gICAgc3BlY2lmaWVyLmltcG9ydEtpbmQgPSBcInZhbHVlXCI7XG4gICAgcmV0dXJuIHN1cGVyLnBhcnNlSW1wb3J0U3BlY2lmaWVyKHNwZWNpZmllciwgaW1wb3J0ZWRJc1N0cmluZywgaXNJblR5cGVPbmx5SW1wb3J0LCBpc01heWJlVHlwZU9ubHksIGlzSW5UeXBlT25seUltcG9ydCA/IDQwOTggOiA0MDk2KTtcbiAgfVxuICBwYXJzZVR5cGVPbmx5SW1wb3J0RXhwb3J0U3BlY2lmaWVyKG5vZGUsIGlzSW1wb3J0LCBpc0luVHlwZU9ubHlJbXBvcnRFeHBvcnQpIHtcbiAgICBjb25zdCBsZWZ0T2ZBc0tleSA9IGlzSW1wb3J0ID8gXCJpbXBvcnRlZFwiIDogXCJsb2NhbFwiO1xuICAgIGNvbnN0IHJpZ2h0T2ZBc0tleSA9IGlzSW1wb3J0ID8gXCJsb2NhbFwiIDogXCJleHBvcnRlZFwiO1xuICAgIGxldCBsZWZ0T2ZBcyA9IG5vZGVbbGVmdE9mQXNLZXldO1xuICAgIGxldCByaWdodE9mQXM7XG4gICAgbGV0IGhhc1R5cGVTcGVjaWZpZXIgPSBmYWxzZTtcbiAgICBsZXQgY2FuUGFyc2VBc0tleXdvcmQgPSB0cnVlO1xuICAgIGNvbnN0IGxvYyA9IGxlZnRPZkFzLmxvYy5zdGFydDtcbiAgICBpZiAodGhpcy5pc0NvbnRleHR1YWwoOTMpKSB7XG4gICAgICBjb25zdCBmaXJzdEFzID0gdGhpcy5wYXJzZUlkZW50aWZpZXIoKTtcbiAgICAgIGlmICh0aGlzLmlzQ29udGV4dHVhbCg5MykpIHtcbiAgICAgICAgY29uc3Qgc2Vjb25kQXMgPSB0aGlzLnBhcnNlSWRlbnRpZmllcigpO1xuICAgICAgICBpZiAodG9rZW5Jc0tleXdvcmRPcklkZW50aWZpZXIodGhpcy5zdGF0ZS50eXBlKSkge1xuICAgICAgICAgIGhhc1R5cGVTcGVjaWZpZXIgPSB0cnVlO1xuICAgICAgICAgIGxlZnRPZkFzID0gZmlyc3RBcztcbiAgICAgICAgICByaWdodE9mQXMgPSBpc0ltcG9ydCA/IHRoaXMucGFyc2VJZGVudGlmaWVyKCkgOiB0aGlzLnBhcnNlTW9kdWxlRXhwb3J0TmFtZSgpO1xuICAgICAgICAgIGNhblBhcnNlQXNLZXl3b3JkID0gZmFsc2U7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmlnaHRPZkFzID0gc2Vjb25kQXM7XG4gICAgICAgICAgY2FuUGFyc2VBc0tleXdvcmQgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmICh0b2tlbklzS2V5d29yZE9ySWRlbnRpZmllcih0aGlzLnN0YXRlLnR5cGUpKSB7XG4gICAgICAgIGNhblBhcnNlQXNLZXl3b3JkID0gZmFsc2U7XG4gICAgICAgIHJpZ2h0T2ZBcyA9IGlzSW1wb3J0ID8gdGhpcy5wYXJzZUlkZW50aWZpZXIoKSA6IHRoaXMucGFyc2VNb2R1bGVFeHBvcnROYW1lKCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBoYXNUeXBlU3BlY2lmaWVyID0gdHJ1ZTtcbiAgICAgICAgbGVmdE9mQXMgPSBmaXJzdEFzO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAodG9rZW5Jc0tleXdvcmRPcklkZW50aWZpZXIodGhpcy5zdGF0ZS50eXBlKSkge1xuICAgICAgaGFzVHlwZVNwZWNpZmllciA9IHRydWU7XG4gICAgICBpZiAoaXNJbXBvcnQpIHtcbiAgICAgICAgbGVmdE9mQXMgPSB0aGlzLnBhcnNlSWRlbnRpZmllcih0cnVlKTtcbiAgICAgICAgaWYgKCF0aGlzLmlzQ29udGV4dHVhbCg5MykpIHtcbiAgICAgICAgICB0aGlzLmNoZWNrUmVzZXJ2ZWRXb3JkKGxlZnRPZkFzLm5hbWUsIGxlZnRPZkFzLmxvYy5zdGFydCwgdHJ1ZSwgdHJ1ZSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGxlZnRPZkFzID0gdGhpcy5wYXJzZU1vZHVsZUV4cG9ydE5hbWUoKTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGhhc1R5cGVTcGVjaWZpZXIgJiYgaXNJblR5cGVPbmx5SW1wb3J0RXhwb3J0KSB7XG4gICAgICB0aGlzLnJhaXNlKGlzSW1wb3J0ID8gVFNFcnJvcnMuVHlwZU1vZGlmaWVySXNVc2VkSW5UeXBlSW1wb3J0cyA6IFRTRXJyb3JzLlR5cGVNb2RpZmllcklzVXNlZEluVHlwZUV4cG9ydHMsIGxvYyk7XG4gICAgfVxuICAgIG5vZGVbbGVmdE9mQXNLZXldID0gbGVmdE9mQXM7XG4gICAgbm9kZVtyaWdodE9mQXNLZXldID0gcmlnaHRPZkFzO1xuICAgIGNvbnN0IGtpbmRLZXkgPSBpc0ltcG9ydCA/IFwiaW1wb3J0S2luZFwiIDogXCJleHBvcnRLaW5kXCI7XG4gICAgbm9kZVtraW5kS2V5XSA9IGhhc1R5cGVTcGVjaWZpZXIgPyBcInR5cGVcIiA6IFwidmFsdWVcIjtcbiAgICBpZiAoY2FuUGFyc2VBc0tleXdvcmQgJiYgdGhpcy5lYXRDb250ZXh0dWFsKDkzKSkge1xuICAgICAgbm9kZVtyaWdodE9mQXNLZXldID0gaXNJbXBvcnQgPyB0aGlzLnBhcnNlSWRlbnRpZmllcigpIDogdGhpcy5wYXJzZU1vZHVsZUV4cG9ydE5hbWUoKTtcbiAgICB9XG4gICAgaWYgKCFub2RlW3JpZ2h0T2ZBc0tleV0pIHtcbiAgICAgIG5vZGVbcmlnaHRPZkFzS2V5XSA9IHRoaXMuY2xvbmVJZGVudGlmaWVyKG5vZGVbbGVmdE9mQXNLZXldKTtcbiAgICB9XG4gICAgaWYgKGlzSW1wb3J0KSB7XG4gICAgICB0aGlzLmNoZWNrSWRlbnRpZmllcihub2RlW3JpZ2h0T2ZBc0tleV0sIGhhc1R5cGVTcGVjaWZpZXIgPyA0MDk4IDogNDA5Nik7XG4gICAgfVxuICB9XG4gIGZpbGxPcHRpb25hbFByb3BlcnRpZXNGb3JUU0VTTGludChub2RlKSB7XG4gICAgdmFyIF9ub2RlJGRpcmVjdGl2ZSwgX25vZGUkZGVjb3JhdG9ycywgX25vZGUkb3B0aW9uYWwsIF9ub2RlJHR5cGVBbm5vdGF0aW9uLCBfbm9kZSRhY2Nlc3NpYmlsaXR5LCBfbm9kZSRkZWNvcmF0b3JzMiwgX25vZGUkb3ZlcnJpZGUsIF9ub2RlJHJlYWRvbmx5LCBfbm9kZSRzdGF0aWMsIF9ub2RlJGRlY2xhcmUsIF9ub2RlJHJldHVyblR5cGUsIF9ub2RlJHR5cGVQYXJhbWV0ZXJzLCBfbm9kZSRvcHRpb25hbDIsIF9ub2RlJG9wdGlvbmFsMywgX25vZGUkYWNjZXNzaWJpbGl0eTIsIF9ub2RlJHJlYWRvbmx5MiwgX25vZGUkc3RhdGljMiwgX25vZGUkZGVjbGFyZTIsIF9ub2RlJGRlZmluaXRlLCBfbm9kZSRyZWFkb25seTMsIF9ub2RlJHR5cGVBbm5vdGF0aW9uMiwgX25vZGUkYWNjZXNzaWJpbGl0eTMsIF9ub2RlJGRlY29yYXRvcnMzLCBfbm9kZSRvdmVycmlkZTIsIF9ub2RlJG9wdGlvbmFsNCwgX25vZGUkaWQsIF9ub2RlJGFic3RyYWN0LCBfbm9kZSRkZWNsYXJlMywgX25vZGUkZGVjb3JhdG9yczQsIF9ub2RlJGltcGxlbWVudHMsIF9ub2RlJHN1cGVyVHlwZUFyZ3VtZSwgX25vZGUkdHlwZVBhcmFtZXRlcnMyLCBfbm9kZSRkZWNsYXJlNCwgX25vZGUkZGVmaW5pdGUyLCBfbm9kZSRjb25zdCwgX25vZGUkZGVjbGFyZTUsIF9ub2RlJGNvbXB1dGVkLCBfbm9kZSRxdWFsaWZpZXIsIF9ub2RlJG9wdGlvbnMsIF9ub2RlJGRlY2xhcmU2LCBfbm9kZSRleHRlbmRzLCBfbm9kZSRvcHRpb25hbDUsIF9ub2RlJHJlYWRvbmx5NCwgX25vZGUkZGVjbGFyZTcsIF9ub2RlJGdsb2JhbCwgX25vZGUkY29uc3QyLCBfbm9kZSRpbiwgX25vZGUkb3V0O1xuICAgIHN3aXRjaCAobm9kZS50eXBlKSB7XG4gICAgICBjYXNlIFwiRXhwcmVzc2lvblN0YXRlbWVudFwiOlxuICAgICAgICAoX25vZGUkZGlyZWN0aXZlID0gbm9kZS5kaXJlY3RpdmUpICE9IG51bGwgPyBfbm9kZSRkaXJlY3RpdmUgOiBub2RlLmRpcmVjdGl2ZSA9IHVuZGVmaW5lZDtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgY2FzZSBcIlJlc3RFbGVtZW50XCI6XG4gICAgICAgIG5vZGUudmFsdWUgPSB1bmRlZmluZWQ7XG4gICAgICBjYXNlIFwiSWRlbnRpZmllclwiOlxuICAgICAgY2FzZSBcIkFycmF5UGF0dGVyblwiOlxuICAgICAgY2FzZSBcIkFzc2lnbm1lbnRQYXR0ZXJuXCI6XG4gICAgICBjYXNlIFwiT2JqZWN0UGF0dGVyblwiOlxuICAgICAgICAoX25vZGUkZGVjb3JhdG9ycyA9IG5vZGUuZGVjb3JhdG9ycykgIT0gbnVsbCA/IF9ub2RlJGRlY29yYXRvcnMgOiBub2RlLmRlY29yYXRvcnMgPSBbXTtcbiAgICAgICAgKF9ub2RlJG9wdGlvbmFsID0gbm9kZS5vcHRpb25hbCkgIT0gbnVsbCA/IF9ub2RlJG9wdGlvbmFsIDogbm9kZS5vcHRpb25hbCA9IGZhbHNlO1xuICAgICAgICAoX25vZGUkdHlwZUFubm90YXRpb24gPSBub2RlLnR5cGVBbm5vdGF0aW9uKSAhPSBudWxsID8gX25vZGUkdHlwZUFubm90YXRpb24gOiBub2RlLnR5cGVBbm5vdGF0aW9uID0gdW5kZWZpbmVkO1xuICAgICAgICByZXR1cm47XG4gICAgICBjYXNlIFwiVFNQYXJhbWV0ZXJQcm9wZXJ0eVwiOlxuICAgICAgICAoX25vZGUkYWNjZXNzaWJpbGl0eSA9IG5vZGUuYWNjZXNzaWJpbGl0eSkgIT0gbnVsbCA/IF9ub2RlJGFjY2Vzc2liaWxpdHkgOiBub2RlLmFjY2Vzc2liaWxpdHkgPSB1bmRlZmluZWQ7XG4gICAgICAgIChfbm9kZSRkZWNvcmF0b3JzMiA9IG5vZGUuZGVjb3JhdG9ycykgIT0gbnVsbCA/IF9ub2RlJGRlY29yYXRvcnMyIDogbm9kZS5kZWNvcmF0b3JzID0gW107XG4gICAgICAgIChfbm9kZSRvdmVycmlkZSA9IG5vZGUub3ZlcnJpZGUpICE9IG51bGwgPyBfbm9kZSRvdmVycmlkZSA6IG5vZGUub3ZlcnJpZGUgPSBmYWxzZTtcbiAgICAgICAgKF9ub2RlJHJlYWRvbmx5ID0gbm9kZS5yZWFkb25seSkgIT0gbnVsbCA/IF9ub2RlJHJlYWRvbmx5IDogbm9kZS5yZWFkb25seSA9IGZhbHNlO1xuICAgICAgICAoX25vZGUkc3RhdGljID0gbm9kZS5zdGF0aWMpICE9IG51bGwgPyBfbm9kZSRzdGF0aWMgOiBub2RlLnN0YXRpYyA9IGZhbHNlO1xuICAgICAgICByZXR1cm47XG4gICAgICBjYXNlIFwiVFNFbXB0eUJvZHlGdW5jdGlvbkV4cHJlc3Npb25cIjpcbiAgICAgICAgbm9kZS5ib2R5ID0gbnVsbDtcbiAgICAgIGNhc2UgXCJUU0RlY2xhcmVGdW5jdGlvblwiOlxuICAgICAgY2FzZSBcIkZ1bmN0aW9uRGVjbGFyYXRpb25cIjpcbiAgICAgIGNhc2UgXCJGdW5jdGlvbkV4cHJlc3Npb25cIjpcbiAgICAgIGNhc2UgXCJDbGFzc01ldGhvZFwiOlxuICAgICAgY2FzZSBcIkNsYXNzUHJpdmF0ZU1ldGhvZFwiOlxuICAgICAgICAoX25vZGUkZGVjbGFyZSA9IG5vZGUuZGVjbGFyZSkgIT0gbnVsbCA/IF9ub2RlJGRlY2xhcmUgOiBub2RlLmRlY2xhcmUgPSBmYWxzZTtcbiAgICAgICAgKF9ub2RlJHJldHVyblR5cGUgPSBub2RlLnJldHVyblR5cGUpICE9IG51bGwgPyBfbm9kZSRyZXR1cm5UeXBlIDogbm9kZS5yZXR1cm5UeXBlID0gdW5kZWZpbmVkO1xuICAgICAgICAoX25vZGUkdHlwZVBhcmFtZXRlcnMgPSBub2RlLnR5cGVQYXJhbWV0ZXJzKSAhPSBudWxsID8gX25vZGUkdHlwZVBhcmFtZXRlcnMgOiBub2RlLnR5cGVQYXJhbWV0ZXJzID0gdW5kZWZpbmVkO1xuICAgICAgICByZXR1cm47XG4gICAgICBjYXNlIFwiUHJvcGVydHlcIjpcbiAgICAgICAgKF9ub2RlJG9wdGlvbmFsMiA9IG5vZGUub3B0aW9uYWwpICE9IG51bGwgPyBfbm9kZSRvcHRpb25hbDIgOiBub2RlLm9wdGlvbmFsID0gZmFsc2U7XG4gICAgICAgIHJldHVybjtcbiAgICAgIGNhc2UgXCJUU01ldGhvZFNpZ25hdHVyZVwiOlxuICAgICAgY2FzZSBcIlRTUHJvcGVydHlTaWduYXR1cmVcIjpcbiAgICAgICAgKF9ub2RlJG9wdGlvbmFsMyA9IG5vZGUub3B0aW9uYWwpICE9IG51bGwgPyBfbm9kZSRvcHRpb25hbDMgOiBub2RlLm9wdGlvbmFsID0gZmFsc2U7XG4gICAgICBjYXNlIFwiVFNJbmRleFNpZ25hdHVyZVwiOlxuICAgICAgICAoX25vZGUkYWNjZXNzaWJpbGl0eTIgPSBub2RlLmFjY2Vzc2liaWxpdHkpICE9IG51bGwgPyBfbm9kZSRhY2Nlc3NpYmlsaXR5MiA6IG5vZGUuYWNjZXNzaWJpbGl0eSA9IHVuZGVmaW5lZDtcbiAgICAgICAgKF9ub2RlJHJlYWRvbmx5MiA9IG5vZGUucmVhZG9ubHkpICE9IG51bGwgPyBfbm9kZSRyZWFkb25seTIgOiBub2RlLnJlYWRvbmx5ID0gZmFsc2U7XG4gICAgICAgIChfbm9kZSRzdGF0aWMyID0gbm9kZS5zdGF0aWMpICE9IG51bGwgPyBfbm9kZSRzdGF0aWMyIDogbm9kZS5zdGF0aWMgPSBmYWxzZTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgY2FzZSBcIlRTQWJzdHJhY3RQcm9wZXJ0eURlZmluaXRpb25cIjpcbiAgICAgIGNhc2UgXCJQcm9wZXJ0eURlZmluaXRpb25cIjpcbiAgICAgIGNhc2UgXCJUU0Fic3RyYWN0QWNjZXNzb3JQcm9wZXJ0eVwiOlxuICAgICAgY2FzZSBcIkFjY2Vzc29yUHJvcGVydHlcIjpcbiAgICAgICAgKF9ub2RlJGRlY2xhcmUyID0gbm9kZS5kZWNsYXJlKSAhPSBudWxsID8gX25vZGUkZGVjbGFyZTIgOiBub2RlLmRlY2xhcmUgPSBmYWxzZTtcbiAgICAgICAgKF9ub2RlJGRlZmluaXRlID0gbm9kZS5kZWZpbml0ZSkgIT0gbnVsbCA/IF9ub2RlJGRlZmluaXRlIDogbm9kZS5kZWZpbml0ZSA9IGZhbHNlO1xuICAgICAgICAoX25vZGUkcmVhZG9ubHkzID0gbm9kZS5yZWFkb25seSkgIT0gbnVsbCA/IF9ub2RlJHJlYWRvbmx5MyA6IG5vZGUucmVhZG9ubHkgPSBmYWxzZTtcbiAgICAgICAgKF9ub2RlJHR5cGVBbm5vdGF0aW9uMiA9IG5vZGUudHlwZUFubm90YXRpb24pICE9IG51bGwgPyBfbm9kZSR0eXBlQW5ub3RhdGlvbjIgOiBub2RlLnR5cGVBbm5vdGF0aW9uID0gdW5kZWZpbmVkO1xuICAgICAgY2FzZSBcIlRTQWJzdHJhY3RNZXRob2REZWZpbml0aW9uXCI6XG4gICAgICBjYXNlIFwiTWV0aG9kRGVmaW5pdGlvblwiOlxuICAgICAgICAoX25vZGUkYWNjZXNzaWJpbGl0eTMgPSBub2RlLmFjY2Vzc2liaWxpdHkpICE9IG51bGwgPyBfbm9kZSRhY2Nlc3NpYmlsaXR5MyA6IG5vZGUuYWNjZXNzaWJpbGl0eSA9IHVuZGVmaW5lZDtcbiAgICAgICAgKF9ub2RlJGRlY29yYXRvcnMzID0gbm9kZS5kZWNvcmF0b3JzKSAhPSBudWxsID8gX25vZGUkZGVjb3JhdG9yczMgOiBub2RlLmRlY29yYXRvcnMgPSBbXTtcbiAgICAgICAgKF9ub2RlJG92ZXJyaWRlMiA9IG5vZGUub3ZlcnJpZGUpICE9IG51bGwgPyBfbm9kZSRvdmVycmlkZTIgOiBub2RlLm92ZXJyaWRlID0gZmFsc2U7XG4gICAgICAgIChfbm9kZSRvcHRpb25hbDQgPSBub2RlLm9wdGlvbmFsKSAhPSBudWxsID8gX25vZGUkb3B0aW9uYWw0IDogbm9kZS5vcHRpb25hbCA9IGZhbHNlO1xuICAgICAgICByZXR1cm47XG4gICAgICBjYXNlIFwiQ2xhc3NFeHByZXNzaW9uXCI6XG4gICAgICAgIChfbm9kZSRpZCA9IG5vZGUuaWQpICE9IG51bGwgPyBfbm9kZSRpZCA6IG5vZGUuaWQgPSBudWxsO1xuICAgICAgY2FzZSBcIkNsYXNzRGVjbGFyYXRpb25cIjpcbiAgICAgICAgKF9ub2RlJGFic3RyYWN0ID0gbm9kZS5hYnN0cmFjdCkgIT0gbnVsbCA/IF9ub2RlJGFic3RyYWN0IDogbm9kZS5hYnN0cmFjdCA9IGZhbHNlO1xuICAgICAgICAoX25vZGUkZGVjbGFyZTMgPSBub2RlLmRlY2xhcmUpICE9IG51bGwgPyBfbm9kZSRkZWNsYXJlMyA6IG5vZGUuZGVjbGFyZSA9IGZhbHNlO1xuICAgICAgICAoX25vZGUkZGVjb3JhdG9yczQgPSBub2RlLmRlY29yYXRvcnMpICE9IG51bGwgPyBfbm9kZSRkZWNvcmF0b3JzNCA6IG5vZGUuZGVjb3JhdG9ycyA9IFtdO1xuICAgICAgICAoX25vZGUkaW1wbGVtZW50cyA9IG5vZGUuaW1wbGVtZW50cykgIT0gbnVsbCA/IF9ub2RlJGltcGxlbWVudHMgOiBub2RlLmltcGxlbWVudHMgPSBbXTtcbiAgICAgICAgKF9ub2RlJHN1cGVyVHlwZUFyZ3VtZSA9IG5vZGUuc3VwZXJUeXBlQXJndW1lbnRzKSAhPSBudWxsID8gX25vZGUkc3VwZXJUeXBlQXJndW1lIDogbm9kZS5zdXBlclR5cGVBcmd1bWVudHMgPSB1bmRlZmluZWQ7XG4gICAgICAgIChfbm9kZSR0eXBlUGFyYW1ldGVyczIgPSBub2RlLnR5cGVQYXJhbWV0ZXJzKSAhPSBudWxsID8gX25vZGUkdHlwZVBhcmFtZXRlcnMyIDogbm9kZS50eXBlUGFyYW1ldGVycyA9IHVuZGVmaW5lZDtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgY2FzZSBcIlRTVHlwZUFsaWFzRGVjbGFyYXRpb25cIjpcbiAgICAgIGNhc2UgXCJWYXJpYWJsZURlY2xhcmF0aW9uXCI6XG4gICAgICAgIChfbm9kZSRkZWNsYXJlNCA9IG5vZGUuZGVjbGFyZSkgIT0gbnVsbCA/IF9ub2RlJGRlY2xhcmU0IDogbm9kZS5kZWNsYXJlID0gZmFsc2U7XG4gICAgICAgIHJldHVybjtcbiAgICAgIGNhc2UgXCJWYXJpYWJsZURlY2xhcmF0b3JcIjpcbiAgICAgICAgKF9ub2RlJGRlZmluaXRlMiA9IG5vZGUuZGVmaW5pdGUpICE9IG51bGwgPyBfbm9kZSRkZWZpbml0ZTIgOiBub2RlLmRlZmluaXRlID0gZmFsc2U7XG4gICAgICAgIHJldHVybjtcbiAgICAgIGNhc2UgXCJUU0VudW1EZWNsYXJhdGlvblwiOlxuICAgICAgICAoX25vZGUkY29uc3QgPSBub2RlLmNvbnN0KSAhPSBudWxsID8gX25vZGUkY29uc3QgOiBub2RlLmNvbnN0ID0gZmFsc2U7XG4gICAgICAgIChfbm9kZSRkZWNsYXJlNSA9IG5vZGUuZGVjbGFyZSkgIT0gbnVsbCA/IF9ub2RlJGRlY2xhcmU1IDogbm9kZS5kZWNsYXJlID0gZmFsc2U7XG4gICAgICAgIHJldHVybjtcbiAgICAgIGNhc2UgXCJUU0VudW1NZW1iZXJcIjpcbiAgICAgICAgKF9ub2RlJGNvbXB1dGVkID0gbm9kZS5jb21wdXRlZCkgIT0gbnVsbCA/IF9ub2RlJGNvbXB1dGVkIDogbm9kZS5jb21wdXRlZCA9IGZhbHNlO1xuICAgICAgICByZXR1cm47XG4gICAgICBjYXNlIFwiVFNJbXBvcnRUeXBlXCI6XG4gICAgICAgIChfbm9kZSRxdWFsaWZpZXIgPSBub2RlLnF1YWxpZmllcikgIT0gbnVsbCA/IF9ub2RlJHF1YWxpZmllciA6IG5vZGUucXVhbGlmaWVyID0gbnVsbDtcbiAgICAgICAgKF9ub2RlJG9wdGlvbnMgPSBub2RlLm9wdGlvbnMpICE9IG51bGwgPyBfbm9kZSRvcHRpb25zIDogbm9kZS5vcHRpb25zID0gbnVsbDtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgY2FzZSBcIlRTSW50ZXJmYWNlRGVjbGFyYXRpb25cIjpcbiAgICAgICAgKF9ub2RlJGRlY2xhcmU2ID0gbm9kZS5kZWNsYXJlKSAhPSBudWxsID8gX25vZGUkZGVjbGFyZTYgOiBub2RlLmRlY2xhcmUgPSBmYWxzZTtcbiAgICAgICAgKF9ub2RlJGV4dGVuZHMgPSBub2RlLmV4dGVuZHMpICE9IG51bGwgPyBfbm9kZSRleHRlbmRzIDogbm9kZS5leHRlbmRzID0gW107XG4gICAgICAgIHJldHVybjtcbiAgICAgIGNhc2UgXCJUU01hcHBlZFR5cGVcIjpcbiAgICAgICAgKF9ub2RlJG9wdGlvbmFsNSA9IG5vZGUub3B0aW9uYWwpICE9IG51bGwgPyBfbm9kZSRvcHRpb25hbDUgOiBub2RlLm9wdGlvbmFsID0gZmFsc2U7XG4gICAgICAgIChfbm9kZSRyZWFkb25seTQgPSBub2RlLnJlYWRvbmx5KSAhPSBudWxsID8gX25vZGUkcmVhZG9ubHk0IDogbm9kZS5yZWFkb25seSA9IHVuZGVmaW5lZDtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgY2FzZSBcIlRTTW9kdWxlRGVjbGFyYXRpb25cIjpcbiAgICAgICAgKF9ub2RlJGRlY2xhcmU3ID0gbm9kZS5kZWNsYXJlKSAhPSBudWxsID8gX25vZGUkZGVjbGFyZTcgOiBub2RlLmRlY2xhcmUgPSBmYWxzZTtcbiAgICAgICAgKF9ub2RlJGdsb2JhbCA9IG5vZGUuZ2xvYmFsKSAhPSBudWxsID8gX25vZGUkZ2xvYmFsIDogbm9kZS5nbG9iYWwgPSBub2RlLmtpbmQgPT09IFwiZ2xvYmFsXCI7XG4gICAgICAgIHJldHVybjtcbiAgICAgIGNhc2UgXCJUU1R5cGVQYXJhbWV0ZXJcIjpcbiAgICAgICAgKF9ub2RlJGNvbnN0MiA9IG5vZGUuY29uc3QpICE9IG51bGwgPyBfbm9kZSRjb25zdDIgOiBub2RlLmNvbnN0ID0gZmFsc2U7XG4gICAgICAgIChfbm9kZSRpbiA9IG5vZGUuaW4pICE9IG51bGwgPyBfbm9kZSRpbiA6IG5vZGUuaW4gPSBmYWxzZTtcbiAgICAgICAgKF9ub2RlJG91dCA9IG5vZGUub3V0KSAhPSBudWxsID8gX25vZGUkb3V0IDogbm9kZS5vdXQgPSBmYWxzZTtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgfVxuICBjaFN0YXJ0c0JpbmRpbmdJZGVudGlmaWVyQW5kTm90UmVsYXRpb25hbE9wZXJhdG9yKGNoLCBwb3MpIHtcbiAgICBpZiAoaXNJZGVudGlmaWVyU3RhcnQoY2gpKSB7XG4gICAgICBrZXl3b3JkQW5kVFNSZWxhdGlvbmFsT3BlcmF0b3IubGFzdEluZGV4ID0gcG9zO1xuICAgICAgaWYgKGtleXdvcmRBbmRUU1JlbGF0aW9uYWxPcGVyYXRvci50ZXN0KHRoaXMuaW5wdXQpKSB7XG4gICAgICAgIGNvbnN0IGVuZENoID0gdGhpcy5jb2RlUG9pbnRBdFBvcyhrZXl3b3JkQW5kVFNSZWxhdGlvbmFsT3BlcmF0b3IubGFzdEluZGV4KTtcbiAgICAgICAgaWYgKCFpc0lkZW50aWZpZXJDaGFyKGVuZENoKSAmJiBlbmRDaCAhPT0gOTIpIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gZWxzZSBpZiAoY2ggPT09IDkyKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuICBuZXh0VG9rZW5Jc0lkZW50aWZpZXJBbmROb3RUU1JlbGF0aW9uYWxPcGVyYXRvck9uU2FtZUxpbmUoKSB7XG4gICAgY29uc3QgbmV4dCA9IHRoaXMubmV4dFRva2VuSW5MaW5lU3RhcnQoKTtcbiAgICBjb25zdCBuZXh0Q2ggPSB0aGlzLmNvZGVQb2ludEF0UG9zKG5leHQpO1xuICAgIHJldHVybiB0aGlzLmNoU3RhcnRzQmluZGluZ0lkZW50aWZpZXJBbmROb3RSZWxhdGlvbmFsT3BlcmF0b3IobmV4dENoLCBuZXh0KTtcbiAgfVxuICBuZXh0VG9rZW5Jc0lkZW50aWZpZXJPclN0cmluZ0xpdGVyYWxPblNhbWVMaW5lKCkge1xuICAgIGNvbnN0IG5leHQgPSB0aGlzLm5leHRUb2tlbkluTGluZVN0YXJ0KCk7XG4gICAgY29uc3QgbmV4dENoID0gdGhpcy5jb2RlUG9pbnRBdFBvcyhuZXh0KTtcbiAgICByZXR1cm4gdGhpcy5jaFN0YXJ0c0JpbmRpbmdJZGVudGlmaWVyKG5leHRDaCwgbmV4dCkgfHwgbmV4dENoID09PSAzNCB8fCBuZXh0Q2ggPT09IDM5O1xuICB9XG59O1xuZnVuY3Rpb24gaXNQb3NzaWJseUxpdGVyYWxFbnVtKGV4cHJlc3Npb24pIHtcbiAgaWYgKGV4cHJlc3Npb24udHlwZSAhPT0gXCJNZW1iZXJFeHByZXNzaW9uXCIpIHJldHVybiBmYWxzZTtcbiAgY29uc3Qge1xuICAgIGNvbXB1dGVkLFxuICAgIHByb3BlcnR5XG4gIH0gPSBleHByZXNzaW9uO1xuICBpZiAoY29tcHV0ZWQgJiYgcHJvcGVydHkudHlwZSAhPT0gXCJTdHJpbmdMaXRlcmFsXCIgJiYgKHByb3BlcnR5LnR5cGUgIT09IFwiVGVtcGxhdGVMaXRlcmFsXCIgfHwgcHJvcGVydHkuZXhwcmVzc2lvbnMubGVuZ3RoID4gMCkpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgcmV0dXJuIGlzVW5jb21wdXRlZE1lbWJlckV4cHJlc3Npb25DaGFpbihleHByZXNzaW9uLm9iamVjdCk7XG59XG5mdW5jdGlvbiBpc1ZhbGlkQW1iaWVudENvbnN0SW5pdGlhbGl6ZXIoZXhwcmVzc2lvbiwgZXN0cmVlKSB7XG4gIHZhciBfZXhwcmVzc2lvbiRleHRyYTtcbiAgY29uc3Qge1xuICAgIHR5cGVcbiAgfSA9IGV4cHJlc3Npb247XG4gIGlmICgoX2V4cHJlc3Npb24kZXh0cmEgPSBleHByZXNzaW9uLmV4dHJhKSAhPSBudWxsICYmIF9leHByZXNzaW9uJGV4dHJhLnBhcmVudGhlc2l6ZWQpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgaWYgKGVzdHJlZSkge1xuICAgIGlmICh0eXBlID09PSBcIkxpdGVyYWxcIikge1xuICAgICAgY29uc3Qge1xuICAgICAgICB2YWx1ZVxuICAgICAgfSA9IGV4cHJlc3Npb247XG4gICAgICBpZiAodHlwZW9mIHZhbHVlID09PSBcInN0cmluZ1wiIHx8IHR5cGVvZiB2YWx1ZSA9PT0gXCJib29sZWFuXCIpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGlmICh0eXBlID09PSBcIlN0cmluZ0xpdGVyYWxcIiB8fCB0eXBlID09PSBcIkJvb2xlYW5MaXRlcmFsXCIpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfVxuICBpZiAoaXNOdW1iZXIoZXhwcmVzc2lvbiwgZXN0cmVlKSB8fCBpc05lZ2F0aXZlTnVtYmVyKGV4cHJlc3Npb24sIGVzdHJlZSkpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICBpZiAodHlwZSA9PT0gXCJUZW1wbGF0ZUxpdGVyYWxcIiAmJiBleHByZXNzaW9uLmV4cHJlc3Npb25zLmxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIGlmIChpc1Bvc3NpYmx5TGl0ZXJhbEVudW0oZXhwcmVzc2lvbikpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICByZXR1cm4gZmFsc2U7XG59XG5mdW5jdGlvbiBpc051bWJlcihleHByZXNzaW9uLCBlc3RyZWUpIHtcbiAgaWYgKGVzdHJlZSkge1xuICAgIHJldHVybiBleHByZXNzaW9uLnR5cGUgPT09IFwiTGl0ZXJhbFwiICYmICh0eXBlb2YgZXhwcmVzc2lvbi52YWx1ZSA9PT0gXCJudW1iZXJcIiB8fCBcImJpZ2ludFwiIGluIGV4cHJlc3Npb24pO1xuICB9XG4gIHJldHVybiBleHByZXNzaW9uLnR5cGUgPT09IFwiTnVtZXJpY0xpdGVyYWxcIiB8fCBleHByZXNzaW9uLnR5cGUgPT09IFwiQmlnSW50TGl0ZXJhbFwiO1xufVxuZnVuY3Rpb24gaXNOZWdhdGl2ZU51bWJlcihleHByZXNzaW9uLCBlc3RyZWUpIHtcbiAgaWYgKGV4cHJlc3Npb24udHlwZSA9PT0gXCJVbmFyeUV4cHJlc3Npb25cIikge1xuICAgIGNvbnN0IHtcbiAgICAgIG9wZXJhdG9yLFxuICAgICAgYXJndW1lbnRcbiAgICB9ID0gZXhwcmVzc2lvbjtcbiAgICBpZiAob3BlcmF0b3IgPT09IFwiLVwiICYmIGlzTnVtYmVyKGFyZ3VtZW50LCBlc3RyZWUpKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufVxuZnVuY3Rpb24gaXNVbmNvbXB1dGVkTWVtYmVyRXhwcmVzc2lvbkNoYWluKGV4cHJlc3Npb24pIHtcbiAgaWYgKGV4cHJlc3Npb24udHlwZSA9PT0gXCJJZGVudGlmaWVyXCIpIHJldHVybiB0cnVlO1xuICBpZiAoZXhwcmVzc2lvbi50eXBlICE9PSBcIk1lbWJlckV4cHJlc3Npb25cIiB8fCBleHByZXNzaW9uLmNvbXB1dGVkKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHJldHVybiBpc1VuY29tcHV0ZWRNZW1iZXJFeHByZXNzaW9uQ2hhaW4oZXhwcmVzc2lvbi5vYmplY3QpO1xufVxuY29uc3QgUGxhY2Vob2xkZXJFcnJvcnMgPSBQYXJzZUVycm9yRW51bWBwbGFjZWhvbGRlcnNgKHtcbiAgQ2xhc3NOYW1lSXNSZXF1aXJlZDogXCJBIGNsYXNzIG5hbWUgaXMgcmVxdWlyZWQuXCIsXG4gIFVuZXhwZWN0ZWRTcGFjZTogXCJVbmV4cGVjdGVkIHNwYWNlIGluIHBsYWNlaG9sZGVyLlwiXG59KTtcbnZhciBwbGFjZWhvbGRlcnMgPSBzdXBlckNsYXNzID0+IGNsYXNzIFBsYWNlaG9sZGVyc1BhcnNlck1peGluIGV4dGVuZHMgc3VwZXJDbGFzcyB7XG4gIHBhcnNlUGxhY2Vob2xkZXIoZXhwZWN0ZWROb2RlKSB7XG4gICAgaWYgKHRoaXMubWF0Y2goMTMzKSkge1xuICAgICAgY29uc3Qgbm9kZSA9IHRoaXMuc3RhcnROb2RlKCk7XG4gICAgICB0aGlzLm5leHQoKTtcbiAgICAgIHRoaXMuYXNzZXJ0Tm9TcGFjZSgpO1xuICAgICAgbm9kZS5uYW1lID0gc3VwZXIucGFyc2VJZGVudGlmaWVyKHRydWUpO1xuICAgICAgdGhpcy5hc3NlcnROb1NwYWNlKCk7XG4gICAgICB0aGlzLmV4cGVjdCgxMzMpO1xuICAgICAgcmV0dXJuIHRoaXMuZmluaXNoUGxhY2Vob2xkZXIobm9kZSwgZXhwZWN0ZWROb2RlKTtcbiAgICB9XG4gIH1cbiAgZmluaXNoUGxhY2Vob2xkZXIobm9kZSwgZXhwZWN0ZWROb2RlKSB7XG4gICAgbGV0IHBsYWNlaG9sZGVyID0gbm9kZTtcbiAgICBpZiAoIXBsYWNlaG9sZGVyLmV4cGVjdGVkTm9kZSB8fCAhcGxhY2Vob2xkZXIudHlwZSkge1xuICAgICAgcGxhY2Vob2xkZXIgPSB0aGlzLmZpbmlzaE5vZGUocGxhY2Vob2xkZXIsIFwiUGxhY2Vob2xkZXJcIik7XG4gICAgfVxuICAgIHBsYWNlaG9sZGVyLmV4cGVjdGVkTm9kZSA9IGV4cGVjdGVkTm9kZTtcbiAgICByZXR1cm4gcGxhY2Vob2xkZXI7XG4gIH1cbiAgZ2V0VG9rZW5Gcm9tQ29kZShjb2RlKSB7XG4gICAgaWYgKGNvZGUgPT09IDM3ICYmIHRoaXMuaW5wdXQuY2hhckNvZGVBdCh0aGlzLnN0YXRlLnBvcyArIDEpID09PSAzNykge1xuICAgICAgdGhpcy5maW5pc2hPcCgxMzMsIDIpO1xuICAgIH0gZWxzZSB7XG4gICAgICBzdXBlci5nZXRUb2tlbkZyb21Db2RlKGNvZGUpO1xuICAgIH1cbiAgfVxuICBwYXJzZUV4cHJBdG9tKHJlZkV4cHJlc3Npb25FcnJvcnMpIHtcbiAgICByZXR1cm4gdGhpcy5wYXJzZVBsYWNlaG9sZGVyKFwiRXhwcmVzc2lvblwiKSB8fCBzdXBlci5wYXJzZUV4cHJBdG9tKHJlZkV4cHJlc3Npb25FcnJvcnMpO1xuICB9XG4gIHBhcnNlSWRlbnRpZmllcihsaWJlcmFsKSB7XG4gICAgcmV0dXJuIHRoaXMucGFyc2VQbGFjZWhvbGRlcihcIklkZW50aWZpZXJcIikgfHwgc3VwZXIucGFyc2VJZGVudGlmaWVyKGxpYmVyYWwpO1xuICB9XG4gIGNoZWNrUmVzZXJ2ZWRXb3JkKHdvcmQsIHN0YXJ0TG9jLCBjaGVja0tleXdvcmRzLCBpc0JpbmRpbmcpIHtcbiAgICBpZiAod29yZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBzdXBlci5jaGVja1Jlc2VydmVkV29yZCh3b3JkLCBzdGFydExvYywgY2hlY2tLZXl3b3JkcywgaXNCaW5kaW5nKTtcbiAgICB9XG4gIH1cbiAgY2xvbmVJZGVudGlmaWVyKG5vZGUpIHtcbiAgICBjb25zdCBjbG9uZWQgPSBzdXBlci5jbG9uZUlkZW50aWZpZXIobm9kZSk7XG4gICAgaWYgKGNsb25lZC50eXBlID09PSBcIlBsYWNlaG9sZGVyXCIpIHtcbiAgICAgIGNsb25lZC5leHBlY3RlZE5vZGUgPSBub2RlLmV4cGVjdGVkTm9kZTtcbiAgICB9XG4gICAgcmV0dXJuIGNsb25lZDtcbiAgfVxuICBjbG9uZVN0cmluZ0xpdGVyYWwobm9kZSkge1xuICAgIGlmIChub2RlLnR5cGUgPT09IFwiUGxhY2Vob2xkZXJcIikge1xuICAgICAgcmV0dXJuIHRoaXMuY2xvbmVJZGVudGlmaWVyKG5vZGUpO1xuICAgIH1cbiAgICByZXR1cm4gc3VwZXIuY2xvbmVTdHJpbmdMaXRlcmFsKG5vZGUpO1xuICB9XG4gIHBhcnNlQmluZGluZ0F0b20oKSB7XG4gICAgcmV0dXJuIHRoaXMucGFyc2VQbGFjZWhvbGRlcihcIlBhdHRlcm5cIikgfHwgc3VwZXIucGFyc2VCaW5kaW5nQXRvbSgpO1xuICB9XG4gIGlzVmFsaWRMVmFsKHR5cGUsIGRpc2FsbG93Q2FsbEV4cHJlc3Npb24sIGlzUGFyZW50aGVzaXplZCwgYmluZGluZykge1xuICAgIHJldHVybiB0eXBlID09PSBcIlBsYWNlaG9sZGVyXCIgfHwgc3VwZXIuaXNWYWxpZExWYWwodHlwZSwgZGlzYWxsb3dDYWxsRXhwcmVzc2lvbiwgaXNQYXJlbnRoZXNpemVkLCBiaW5kaW5nKTtcbiAgfVxuICB0b0Fzc2lnbmFibGUobm9kZSwgaXNMSFMpIHtcbiAgICBpZiAobm9kZSAmJiBub2RlLnR5cGUgPT09IFwiUGxhY2Vob2xkZXJcIiAmJiBub2RlLmV4cGVjdGVkTm9kZSA9PT0gXCJFeHByZXNzaW9uXCIpIHtcbiAgICAgIG5vZGUuZXhwZWN0ZWROb2RlID0gXCJQYXR0ZXJuXCI7XG4gICAgfSBlbHNlIHtcbiAgICAgIHN1cGVyLnRvQXNzaWduYWJsZShub2RlLCBpc0xIUyk7XG4gICAgfVxuICB9XG4gIGNoU3RhcnRzQmluZGluZ0lkZW50aWZpZXIoY2gsIHBvcykge1xuICAgIGlmIChzdXBlci5jaFN0YXJ0c0JpbmRpbmdJZGVudGlmaWVyKGNoLCBwb3MpKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgY29uc3QgbmV4dCA9IHRoaXMubmV4dFRva2VuU3RhcnQoKTtcbiAgICBpZiAodGhpcy5pbnB1dC5jaGFyQ29kZUF0KG5leHQpID09PSAzNyAmJiB0aGlzLmlucHV0LmNoYXJDb2RlQXQobmV4dCArIDEpID09PSAzNykge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICB2ZXJpZnlCcmVha0NvbnRpbnVlKG5vZGUsIGlzQnJlYWspIHtcbiAgICB2YXIgX25vZGUkbGFiZWw7XG4gICAgaWYgKCgoX25vZGUkbGFiZWwgPSBub2RlLmxhYmVsKSA9PSBudWxsID8gdm9pZCAwIDogX25vZGUkbGFiZWwudHlwZSkgPT09IFwiUGxhY2Vob2xkZXJcIikgcmV0dXJuO1xuICAgIHN1cGVyLnZlcmlmeUJyZWFrQ29udGludWUobm9kZSwgaXNCcmVhayk7XG4gIH1cbiAgcGFyc2VFeHByZXNzaW9uU3RhdGVtZW50KG5vZGUsIGV4cHIpIHtcbiAgICB2YXIgX2V4cHIkZXh0cmE7XG4gICAgaWYgKGV4cHIudHlwZSAhPT0gXCJQbGFjZWhvbGRlclwiIHx8IChfZXhwciRleHRyYSA9IGV4cHIuZXh0cmEpICE9IG51bGwgJiYgX2V4cHIkZXh0cmEucGFyZW50aGVzaXplZCkge1xuICAgICAgcmV0dXJuIHN1cGVyLnBhcnNlRXhwcmVzc2lvblN0YXRlbWVudChub2RlLCBleHByKTtcbiAgICB9XG4gICAgaWYgKHRoaXMubWF0Y2goMTQpKSB7XG4gICAgICBjb25zdCBzdG10ID0gbm9kZTtcbiAgICAgIHN0bXQubGFiZWwgPSB0aGlzLmZpbmlzaFBsYWNlaG9sZGVyKGV4cHIsIFwiSWRlbnRpZmllclwiKTtcbiAgICAgIHRoaXMubmV4dCgpO1xuICAgICAgc3RtdC5ib2R5ID0gc3VwZXIucGFyc2VTdGF0ZW1lbnRPclNsb3BweUFubmV4QkZ1bmN0aW9uRGVjbGFyYXRpb24oKTtcbiAgICAgIHJldHVybiB0aGlzLmZpbmlzaE5vZGUoc3RtdCwgXCJMYWJlbGVkU3RhdGVtZW50XCIpO1xuICAgIH1cbiAgICB0aGlzLnNlbWljb2xvbigpO1xuICAgIGNvbnN0IHN0bXRQbGFjZWhvbGRlciA9IG5vZGU7XG4gICAgc3RtdFBsYWNlaG9sZGVyLm5hbWUgPSBleHByLm5hbWU7XG4gICAgcmV0dXJuIHRoaXMuZmluaXNoUGxhY2Vob2xkZXIoc3RtdFBsYWNlaG9sZGVyLCBcIlN0YXRlbWVudFwiKTtcbiAgfVxuICBwYXJzZUJsb2NrKGFsbG93RGlyZWN0aXZlcywgY3JlYXRlTmV3TGV4aWNhbFNjb3BlLCBhZnRlckJsb2NrUGFyc2UpIHtcbiAgICByZXR1cm4gdGhpcy5wYXJzZVBsYWNlaG9sZGVyKFwiQmxvY2tTdGF0ZW1lbnRcIikgfHwgc3VwZXIucGFyc2VCbG9jayhhbGxvd0RpcmVjdGl2ZXMsIGNyZWF0ZU5ld0xleGljYWxTY29wZSwgYWZ0ZXJCbG9ja1BhcnNlKTtcbiAgfVxuICBwYXJzZUZ1bmN0aW9uSWQocmVxdWlyZUlkKSB7XG4gICAgcmV0dXJuIHRoaXMucGFyc2VQbGFjZWhvbGRlcihcIklkZW50aWZpZXJcIikgfHwgc3VwZXIucGFyc2VGdW5jdGlvbklkKHJlcXVpcmVJZCk7XG4gIH1cbiAgcGFyc2VDbGFzcyhub2RlLCBpc1N0YXRlbWVudCwgb3B0aW9uYWxJZCkge1xuICAgIGNvbnN0IHR5cGUgPSBpc1N0YXRlbWVudCA/IFwiQ2xhc3NEZWNsYXJhdGlvblwiIDogXCJDbGFzc0V4cHJlc3Npb25cIjtcbiAgICB0aGlzLm5leHQoKTtcbiAgICBjb25zdCBvbGRTdHJpY3QgPSB0aGlzLnN0YXRlLnN0cmljdDtcbiAgICBjb25zdCBwbGFjZWhvbGRlciA9IHRoaXMucGFyc2VQbGFjZWhvbGRlcihcIklkZW50aWZpZXJcIik7XG4gICAgaWYgKHBsYWNlaG9sZGVyKSB7XG4gICAgICBpZiAodGhpcy5tYXRjaCg4MSkgfHwgdGhpcy5tYXRjaCgxMzMpIHx8IHRoaXMubWF0Y2goNSkpIHtcbiAgICAgICAgbm9kZS5pZCA9IHBsYWNlaG9sZGVyO1xuICAgICAgfSBlbHNlIGlmIChvcHRpb25hbElkIHx8ICFpc1N0YXRlbWVudCkge1xuICAgICAgICBub2RlLmlkID0gbnVsbDtcbiAgICAgICAgbm9kZS5ib2R5ID0gdGhpcy5maW5pc2hQbGFjZWhvbGRlcihwbGFjZWhvbGRlciwgXCJDbGFzc0JvZHlcIik7XG4gICAgICAgIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgdHlwZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyB0aGlzLnJhaXNlKFBsYWNlaG9sZGVyRXJyb3JzLkNsYXNzTmFtZUlzUmVxdWlyZWQsIHRoaXMuc3RhdGUuc3RhcnRMb2MpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnBhcnNlQ2xhc3NJZChub2RlLCBpc1N0YXRlbWVudCwgb3B0aW9uYWxJZCk7XG4gICAgfVxuICAgIHN1cGVyLnBhcnNlQ2xhc3NTdXBlcihub2RlKTtcbiAgICBub2RlLmJvZHkgPSB0aGlzLnBhcnNlUGxhY2Vob2xkZXIoXCJDbGFzc0JvZHlcIikgfHwgc3VwZXIucGFyc2VDbGFzc0JvZHkoISFub2RlLnN1cGVyQ2xhc3MsIG9sZFN0cmljdCk7XG4gICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCB0eXBlKTtcbiAgfVxuICBwYXJzZUV4cG9ydChub2RlLCBkZWNvcmF0b3JzKSB7XG4gICAgY29uc3QgcGxhY2Vob2xkZXIgPSB0aGlzLnBhcnNlUGxhY2Vob2xkZXIoXCJJZGVudGlmaWVyXCIpO1xuICAgIGlmICghcGxhY2Vob2xkZXIpIHJldHVybiBzdXBlci5wYXJzZUV4cG9ydChub2RlLCBkZWNvcmF0b3JzKTtcbiAgICBjb25zdCBub2RlMiA9IG5vZGU7XG4gICAgaWYgKCF0aGlzLmlzQ29udGV4dHVhbCg5OCkgJiYgIXRoaXMubWF0Y2goMTIpKSB7XG4gICAgICBub2RlMi5zcGVjaWZpZXJzID0gW107XG4gICAgICBub2RlMi5zb3VyY2UgPSBudWxsO1xuICAgICAgbm9kZTIuZGVjbGFyYXRpb24gPSB0aGlzLmZpbmlzaFBsYWNlaG9sZGVyKHBsYWNlaG9sZGVyLCBcIkRlY2xhcmF0aW9uXCIpO1xuICAgICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlMiwgXCJFeHBvcnROYW1lZERlY2xhcmF0aW9uXCIpO1xuICAgIH1cbiAgICB0aGlzLmV4cGVjdFBsdWdpbihcImV4cG9ydERlZmF1bHRGcm9tXCIpO1xuICAgIGNvbnN0IHNwZWNpZmllciA9IHRoaXMuc3RhcnROb2RlKCk7XG4gICAgc3BlY2lmaWVyLmV4cG9ydGVkID0gcGxhY2Vob2xkZXI7XG4gICAgbm9kZTIuc3BlY2lmaWVycyA9IFt0aGlzLmZpbmlzaE5vZGUoc3BlY2lmaWVyLCBcIkV4cG9ydERlZmF1bHRTcGVjaWZpZXJcIildO1xuICAgIHJldHVybiBzdXBlci5wYXJzZUV4cG9ydChub2RlMiwgZGVjb3JhdG9ycyk7XG4gIH1cbiAgaXNFeHBvcnREZWZhdWx0U3BlY2lmaWVyKCkge1xuICAgIGlmICh0aGlzLm1hdGNoKDY1KSkge1xuICAgICAgY29uc3QgbmV4dCA9IHRoaXMubmV4dFRva2VuU3RhcnQoKTtcbiAgICAgIGlmICh0aGlzLmlzVW5wYXJzZWRDb250ZXh0dWFsKG5leHQsIFwiZnJvbVwiKSkge1xuICAgICAgICBpZiAodGhpcy5pbnB1dC5zdGFydHNXaXRoKHRva2VuTGFiZWxOYW1lKDEzMyksIHRoaXMubmV4dFRva2VuU3RhcnRTaW5jZShuZXh0ICsgNCkpKSB7XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHN1cGVyLmlzRXhwb3J0RGVmYXVsdFNwZWNpZmllcigpO1xuICB9XG4gIG1heWJlUGFyc2VFeHBvcnREZWZhdWx0U3BlY2lmaWVyKG5vZGUsIG1heWJlRGVmYXVsdElkZW50aWZpZXIpIHtcbiAgICB2YXIgX3NwZWNpZmllcnM7XG4gICAgaWYgKChfc3BlY2lmaWVycyA9IG5vZGUuc3BlY2lmaWVycykgIT0gbnVsbCAmJiBfc3BlY2lmaWVycy5sZW5ndGgpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gc3VwZXIubWF5YmVQYXJzZUV4cG9ydERlZmF1bHRTcGVjaWZpZXIobm9kZSwgbWF5YmVEZWZhdWx0SWRlbnRpZmllcik7XG4gIH1cbiAgY2hlY2tFeHBvcnQobm9kZSkge1xuICAgIGNvbnN0IHtcbiAgICAgIHNwZWNpZmllcnNcbiAgICB9ID0gbm9kZTtcbiAgICBpZiAoc3BlY2lmaWVycyAhPSBudWxsICYmIHNwZWNpZmllcnMubGVuZ3RoKSB7XG4gICAgICBub2RlLnNwZWNpZmllcnMgPSBzcGVjaWZpZXJzLmZpbHRlcihub2RlID0+IG5vZGUuZXhwb3J0ZWQudHlwZSA9PT0gXCJQbGFjZWhvbGRlclwiKTtcbiAgICB9XG4gICAgc3VwZXIuY2hlY2tFeHBvcnQobm9kZSk7XG4gICAgbm9kZS5zcGVjaWZpZXJzID0gc3BlY2lmaWVycztcbiAgfVxuICBwYXJzZUltcG9ydChub2RlKSB7XG4gICAgY29uc3QgcGxhY2Vob2xkZXIgPSB0aGlzLnBhcnNlUGxhY2Vob2xkZXIoXCJJZGVudGlmaWVyXCIpO1xuICAgIGlmICghcGxhY2Vob2xkZXIpIHJldHVybiBzdXBlci5wYXJzZUltcG9ydChub2RlKTtcbiAgICBub2RlLnNwZWNpZmllcnMgPSBbXTtcbiAgICBpZiAoIXRoaXMuaXNDb250ZXh0dWFsKDk4KSAmJiAhdGhpcy5tYXRjaCgxMikpIHtcbiAgICAgIG5vZGUuc291cmNlID0gdGhpcy5maW5pc2hQbGFjZWhvbGRlcihwbGFjZWhvbGRlciwgXCJTdHJpbmdMaXRlcmFsXCIpO1xuICAgICAgdGhpcy5zZW1pY29sb24oKTtcbiAgICAgIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJJbXBvcnREZWNsYXJhdGlvblwiKTtcbiAgICB9XG4gICAgY29uc3Qgc3BlY2lmaWVyID0gdGhpcy5zdGFydE5vZGVBdE5vZGUocGxhY2Vob2xkZXIpO1xuICAgIHNwZWNpZmllci5sb2NhbCA9IHBsYWNlaG9sZGVyO1xuICAgIG5vZGUuc3BlY2lmaWVycy5wdXNoKHRoaXMuZmluaXNoTm9kZShzcGVjaWZpZXIsIFwiSW1wb3J0RGVmYXVsdFNwZWNpZmllclwiKSk7XG4gICAgaWYgKHRoaXMuZWF0KDEyKSkge1xuICAgICAgY29uc3QgaGFzU3RhckltcG9ydCA9IHRoaXMubWF5YmVQYXJzZVN0YXJJbXBvcnRTcGVjaWZpZXIobm9kZSk7XG4gICAgICBpZiAoIWhhc1N0YXJJbXBvcnQpIHRoaXMucGFyc2VOYW1lZEltcG9ydFNwZWNpZmllcnMobm9kZSk7XG4gICAgfVxuICAgIHRoaXMuZXhwZWN0Q29udGV4dHVhbCg5OCk7XG4gICAgbm9kZS5zb3VyY2UgPSB0aGlzLnBhcnNlSW1wb3J0U291cmNlKCk7XG4gICAgdGhpcy5zZW1pY29sb24oKTtcbiAgICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiSW1wb3J0RGVjbGFyYXRpb25cIik7XG4gIH1cbiAgcGFyc2VJbXBvcnRTb3VyY2UoKSB7XG4gICAgcmV0dXJuIHRoaXMucGFyc2VQbGFjZWhvbGRlcihcIlN0cmluZ0xpdGVyYWxcIikgfHwgc3VwZXIucGFyc2VJbXBvcnRTb3VyY2UoKTtcbiAgfVxuICBhc3NlcnROb1NwYWNlKCkge1xuICAgIGlmICh0aGlzLnN0YXRlLnN0YXJ0ID4gdGhpcy5vZmZzZXRUb1NvdXJjZVBvcyh0aGlzLnN0YXRlLmxhc3RUb2tFbmRMb2MuaW5kZXgpKSB7XG4gICAgICB0aGlzLnJhaXNlKFBsYWNlaG9sZGVyRXJyb3JzLlVuZXhwZWN0ZWRTcGFjZSwgdGhpcy5zdGF0ZS5sYXN0VG9rRW5kTG9jKTtcbiAgICB9XG4gIH1cbn07XG52YXIgdjhpbnRyaW5zaWMgPSBzdXBlckNsYXNzID0+IGNsYXNzIFY4SW50cmluc2ljTWl4aW4gZXh0ZW5kcyBzdXBlckNsYXNzIHtcbiAgcGFyc2VWOEludHJpbnNpYygpIHtcbiAgICBpZiAodGhpcy5tYXRjaCg1NCkpIHtcbiAgICAgIGNvbnN0IHY4SW50cmluc2ljU3RhcnRMb2MgPSB0aGlzLnN0YXRlLnN0YXJ0TG9jO1xuICAgICAgY29uc3Qgbm9kZSA9IHRoaXMuc3RhcnROb2RlKCk7XG4gICAgICB0aGlzLm5leHQoKTtcbiAgICAgIGlmICh0b2tlbklzSWRlbnRpZmllcih0aGlzLnN0YXRlLnR5cGUpKSB7XG4gICAgICAgIGNvbnN0IG5hbWUgPSB0aGlzLnBhcnNlSWRlbnRpZmllck5hbWUoKTtcbiAgICAgICAgY29uc3QgaWRlbnRpZmllciA9IHRoaXMuY3JlYXRlSWRlbnRpZmllcihub2RlLCBuYW1lKTtcbiAgICAgICAgdGhpcy5jYXN0Tm9kZVRvKGlkZW50aWZpZXIsIFwiVjhJbnRyaW5zaWNJZGVudGlmaWVyXCIpO1xuICAgICAgICBpZiAodGhpcy5tYXRjaCgxMCkpIHtcbiAgICAgICAgICByZXR1cm4gaWRlbnRpZmllcjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdGhpcy51bmV4cGVjdGVkKHY4SW50cmluc2ljU3RhcnRMb2MpO1xuICAgIH1cbiAgfVxuICBwYXJzZUV4cHJBdG9tKHJlZkV4cHJlc3Npb25FcnJvcnMpIHtcbiAgICByZXR1cm4gdGhpcy5wYXJzZVY4SW50cmluc2ljKCkgfHwgc3VwZXIucGFyc2VFeHByQXRvbShyZWZFeHByZXNzaW9uRXJyb3JzKTtcbiAgfVxufTtcbmNvbnN0IFBJUEVMSU5FX1BST1BPU0FMUyA9IFtcIm1pbmltYWxcIiwgXCJmc2hhcnBcIiwgXCJoYWNrXCIsIFwic21hcnRcIl07XG5jb25zdCBUT1BJQ19UT0tFTlMgPSBbXCJeXlwiLCBcIkBAXCIsIFwiXlwiLCBcIiVcIiwgXCIjXCJdO1xuZnVuY3Rpb24gdmFsaWRhdGVQbHVnaW5zKHBsdWdpbnNNYXApIHtcbiAgaWYgKHBsdWdpbnNNYXAuaGFzKFwiZGVjb3JhdG9yc1wiKSkge1xuICAgIGlmIChwbHVnaW5zTWFwLmhhcyhcImRlY29yYXRvcnMtbGVnYWN5XCIpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3QgdXNlIHRoZSBkZWNvcmF0b3JzIGFuZCBkZWNvcmF0b3JzLWxlZ2FjeSBwbHVnaW4gdG9nZXRoZXJcIik7XG4gICAgfVxuICAgIGNvbnN0IGRlY29yYXRvcnNCZWZvcmVFeHBvcnQgPSBwbHVnaW5zTWFwLmdldChcImRlY29yYXRvcnNcIikuZGVjb3JhdG9yc0JlZm9yZUV4cG9ydDtcbiAgICBpZiAoZGVjb3JhdG9yc0JlZm9yZUV4cG9ydCAhPSBudWxsICYmIHR5cGVvZiBkZWNvcmF0b3JzQmVmb3JlRXhwb3J0ICE9PSBcImJvb2xlYW5cIikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiJ2RlY29yYXRvcnNCZWZvcmVFeHBvcnQnIG11c3QgYmUgYSBib29sZWFuLCBpZiBzcGVjaWZpZWQuXCIpO1xuICAgIH1cbiAgICBjb25zdCBhbGxvd0NhbGxQYXJlbnRoZXNpemVkID0gcGx1Z2luc01hcC5nZXQoXCJkZWNvcmF0b3JzXCIpLmFsbG93Q2FsbFBhcmVudGhlc2l6ZWQ7XG4gICAgaWYgKGFsbG93Q2FsbFBhcmVudGhlc2l6ZWQgIT0gbnVsbCAmJiB0eXBlb2YgYWxsb3dDYWxsUGFyZW50aGVzaXplZCAhPT0gXCJib29sZWFuXCIpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIidhbGxvd0NhbGxQYXJlbnRoZXNpemVkJyBtdXN0IGJlIGEgYm9vbGVhbi5cIik7XG4gICAgfVxuICB9XG4gIGlmIChwbHVnaW5zTWFwLmhhcyhcImZsb3dcIikgJiYgcGx1Z2luc01hcC5oYXMoXCJ0eXBlc2NyaXB0XCIpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IGNvbWJpbmUgZmxvdyBhbmQgdHlwZXNjcmlwdCBwbHVnaW5zLlwiKTtcbiAgfVxuICBpZiAocGx1Z2luc01hcC5oYXMoXCJwbGFjZWhvbGRlcnNcIikgJiYgcGx1Z2luc01hcC5oYXMoXCJ2OGludHJpbnNpY1wiKSkge1xuICAgIHRocm93IG5ldyBFcnJvcihcIkNhbm5vdCBjb21iaW5lIHBsYWNlaG9sZGVycyBhbmQgdjhpbnRyaW5zaWMgcGx1Z2lucy5cIik7XG4gIH1cbiAgaWYgKHBsdWdpbnNNYXAuaGFzKFwicGlwZWxpbmVPcGVyYXRvclwiKSkge1xuICAgIHZhciBfcGx1Z2luc01hcCRnZXQyO1xuICAgIGNvbnN0IHByb3Bvc2FsID0gcGx1Z2luc01hcC5nZXQoXCJwaXBlbGluZU9wZXJhdG9yXCIpLnByb3Bvc2FsO1xuICAgIGlmICghUElQRUxJTkVfUFJPUE9TQUxTLmluY2x1ZGVzKHByb3Bvc2FsKSkge1xuICAgICAgY29uc3QgcHJvcG9zYWxMaXN0ID0gUElQRUxJTkVfUFJPUE9TQUxTLm1hcChwID0+IGBcIiR7cH1cImApLmpvaW4oXCIsIFwiKTtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgXCJwaXBlbGluZU9wZXJhdG9yXCIgcmVxdWlyZXMgXCJwcm9wb3NhbFwiIG9wdGlvbiB3aG9zZSB2YWx1ZSBtdXN0IGJlIG9uZSBvZjogJHtwcm9wb3NhbExpc3R9LmApO1xuICAgIH1cbiAgICBpZiAocHJvcG9zYWwgPT09IFwiaGFja1wiKSB7XG4gICAgICB2YXIgX3BsdWdpbnNNYXAkZ2V0O1xuICAgICAgaWYgKHBsdWdpbnNNYXAuaGFzKFwicGxhY2Vob2xkZXJzXCIpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbm5vdCBjb21iaW5lIHBsYWNlaG9sZGVycyBwbHVnaW4gYW5kIEhhY2stc3R5bGUgcGlwZXMuXCIpO1xuICAgICAgfVxuICAgICAgaWYgKHBsdWdpbnNNYXAuaGFzKFwidjhpbnRyaW5zaWNcIikpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IGNvbWJpbmUgdjhpbnRyaW5zaWMgcGx1Z2luIGFuZCBIYWNrLXN0eWxlIHBpcGVzLlwiKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHRvcGljVG9rZW4gPSBwbHVnaW5zTWFwLmdldChcInBpcGVsaW5lT3BlcmF0b3JcIikudG9waWNUb2tlbjtcbiAgICAgIGlmICghVE9QSUNfVE9LRU5TLmluY2x1ZGVzKHRvcGljVG9rZW4pKSB7XG4gICAgICAgIGNvbnN0IHRva2VuTGlzdCA9IFRPUElDX1RPS0VOUy5tYXAodCA9PiBgXCIke3R9XCJgKS5qb2luKFwiLCBcIik7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgXCJwaXBlbGluZU9wZXJhdG9yXCIgaW4gXCJwcm9wb3NhbFwiOiBcImhhY2tcIiBtb2RlIGFsc28gcmVxdWlyZXMgYSBcInRvcGljVG9rZW5cIiBvcHRpb24gd2hvc2UgdmFsdWUgbXVzdCBiZSBvbmUgb2Y6ICR7dG9rZW5MaXN0fS5gKTtcbiAgICAgIH1cbiAgICAgIGlmICh0b3BpY1Rva2VuID09PSBcIiNcIiAmJiAoKF9wbHVnaW5zTWFwJGdldCA9IHBsdWdpbnNNYXAuZ2V0KFwicmVjb3JkQW5kVHVwbGVcIikpID09IG51bGwgPyB2b2lkIDAgOiBfcGx1Z2luc01hcCRnZXQuc3ludGF4VHlwZSkgPT09IFwiaGFzaFwiKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgUGx1Z2luIGNvbmZsaWN0IGJldHdlZW4gXFxgW1wicGlwZWxpbmVPcGVyYXRvclwiLCB7IHByb3Bvc2FsOiBcImhhY2tcIiwgdG9waWNUb2tlbjogXCIjXCIgfV1cXGAgYW5kIFxcYCR7SlNPTi5zdHJpbmdpZnkoW1wicmVjb3JkQW5kVHVwbGVcIiwgcGx1Z2luc01hcC5nZXQoXCJyZWNvcmRBbmRUdXBsZVwiKV0pfVxcYC5gKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHByb3Bvc2FsID09PSBcInNtYXJ0XCIgJiYgKChfcGx1Z2luc01hcCRnZXQyID0gcGx1Z2luc01hcC5nZXQoXCJyZWNvcmRBbmRUdXBsZVwiKSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9wbHVnaW5zTWFwJGdldDIuc3ludGF4VHlwZSkgPT09IFwiaGFzaFwiKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYFBsdWdpbiBjb25mbGljdCBiZXR3ZWVuIFxcYFtcInBpcGVsaW5lT3BlcmF0b3JcIiwgeyBwcm9wb3NhbDogXCJzbWFydFwiIH1dXFxgIGFuZCBcXGAke0pTT04uc3RyaW5naWZ5KFtcInJlY29yZEFuZFR1cGxlXCIsIHBsdWdpbnNNYXAuZ2V0KFwicmVjb3JkQW5kVHVwbGVcIildKX1cXGAuYCk7XG4gICAgfVxuICB9XG4gIGlmIChwbHVnaW5zTWFwLmhhcyhcIm1vZHVsZUF0dHJpYnV0ZXNcIikpIHtcbiAgICBpZiAocGx1Z2luc01hcC5oYXMoXCJkZXByZWNhdGVkSW1wb3J0QXNzZXJ0XCIpIHx8IHBsdWdpbnNNYXAuaGFzKFwiaW1wb3J0QXNzZXJ0aW9uc1wiKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IGNvbWJpbmUgaW1wb3J0QXNzZXJ0aW9ucywgZGVwcmVjYXRlZEltcG9ydEFzc2VydCBhbmQgbW9kdWxlQXR0cmlidXRlcyBwbHVnaW5zLlwiKTtcbiAgICB9XG4gICAgY29uc3QgbW9kdWxlQXR0cmlidXRlc1ZlcnNpb25QbHVnaW5PcHRpb24gPSBwbHVnaW5zTWFwLmdldChcIm1vZHVsZUF0dHJpYnV0ZXNcIikudmVyc2lvbjtcbiAgICBpZiAobW9kdWxlQXR0cmlidXRlc1ZlcnNpb25QbHVnaW5PcHRpb24gIT09IFwibWF5LTIwMjBcIikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVGhlICdtb2R1bGVBdHRyaWJ1dGVzJyBwbHVnaW4gcmVxdWlyZXMgYSAndmVyc2lvbicgb3B0aW9uLFwiICsgXCIgcmVwcmVzZW50aW5nIHRoZSBsYXN0IHByb3Bvc2FsIHVwZGF0ZS4gQ3VycmVudGx5LCB0aGVcIiArIFwiIG9ubHkgc3VwcG9ydGVkIHZhbHVlIGlzICdtYXktMjAyMCcuXCIpO1xuICAgIH1cbiAgfVxuICBpZiAocGx1Z2luc01hcC5oYXMoXCJpbXBvcnRBc3NlcnRpb25zXCIpKSB7XG4gICAgaWYgKHBsdWdpbnNNYXAuaGFzKFwiZGVwcmVjYXRlZEltcG9ydEFzc2VydFwiKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IGNvbWJpbmUgaW1wb3J0QXNzZXJ0aW9ucyBhbmQgZGVwcmVjYXRlZEltcG9ydEFzc2VydCBwbHVnaW5zLlwiKTtcbiAgICB9XG4gIH1cbiAgaWYgKHBsdWdpbnNNYXAuaGFzKFwiZGVwcmVjYXRlZEltcG9ydEFzc2VydFwiKSkgO2Vsc2UgaWYgKHBsdWdpbnNNYXAuaGFzKFwiaW1wb3J0QXR0cmlidXRlc1wiKSAmJiBwbHVnaW5zTWFwLmdldChcImltcG9ydEF0dHJpYnV0ZXNcIikuZGVwcmVjYXRlZEFzc2VydFN5bnRheCkge1xuICAgIHBsdWdpbnNNYXAuc2V0KFwiZGVwcmVjYXRlZEltcG9ydEFzc2VydFwiLCB7fSk7XG4gIH1cbiAgaWYgKHBsdWdpbnNNYXAuaGFzKFwicmVjb3JkQW5kVHVwbGVcIikpIHtcbiAgICBjb25zdCBzeW50YXhUeXBlID0gcGx1Z2luc01hcC5nZXQoXCJyZWNvcmRBbmRUdXBsZVwiKS5zeW50YXhUeXBlO1xuICAgIGlmIChzeW50YXhUeXBlICE9IG51bGwpIHtcbiAgICAgIGNvbnN0IFJFQ09SRF9BTkRfVFVQTEVfU1lOVEFYX1RZUEVTID0gW1wiaGFzaFwiLCBcImJhclwiXTtcbiAgICAgIGlmICghUkVDT1JEX0FORF9UVVBMRV9TWU5UQVhfVFlQRVMuaW5jbHVkZXMoc3ludGF4VHlwZSkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVGhlICdzeW50YXhUeXBlJyBvcHRpb24gb2YgdGhlICdyZWNvcmRBbmRUdXBsZScgcGx1Z2luIG11c3QgYmUgb25lIG9mOiBcIiArIFJFQ09SRF9BTkRfVFVQTEVfU1lOVEFYX1RZUEVTLm1hcChwID0+IGAnJHtwfSdgKS5qb2luKFwiLCBcIikpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBpZiAocGx1Z2luc01hcC5oYXMoXCJhc3luY0RvRXhwcmVzc2lvbnNcIikgJiYgIXBsdWdpbnNNYXAuaGFzKFwiZG9FeHByZXNzaW9uc1wiKSkge1xuICAgIGNvbnN0IGVycm9yID0gbmV3IEVycm9yKFwiJ2FzeW5jRG9FeHByZXNzaW9ucycgcmVxdWlyZXMgJ2RvRXhwcmVzc2lvbnMnLCBwbGVhc2UgYWRkICdkb0V4cHJlc3Npb25zJyB0byBwYXJzZXIgcGx1Z2lucy5cIik7XG4gICAgZXJyb3IubWlzc2luZ1BsdWdpbnMgPSBcImRvRXhwcmVzc2lvbnNcIjtcbiAgICB0aHJvdyBlcnJvcjtcbiAgfVxuICBpZiAocGx1Z2luc01hcC5oYXMoXCJvcHRpb25hbENoYWluaW5nQXNzaWduXCIpICYmIHBsdWdpbnNNYXAuZ2V0KFwib3B0aW9uYWxDaGFpbmluZ0Fzc2lnblwiKS52ZXJzaW9uICE9PSBcIjIwMjMtMDdcIikge1xuICAgIHRocm93IG5ldyBFcnJvcihcIlRoZSAnb3B0aW9uYWxDaGFpbmluZ0Fzc2lnbicgcGx1Z2luIHJlcXVpcmVzIGEgJ3ZlcnNpb24nIG9wdGlvbixcIiArIFwiIHJlcHJlc2VudGluZyB0aGUgbGFzdCBwcm9wb3NhbCB1cGRhdGUuIEN1cnJlbnRseSwgdGhlXCIgKyBcIiBvbmx5IHN1cHBvcnRlZCB2YWx1ZSBpcyAnMjAyMy0wNycuXCIpO1xuICB9XG4gIGlmIChwbHVnaW5zTWFwLmhhcyhcImRpc2NhcmRCaW5kaW5nXCIpICYmIHBsdWdpbnNNYXAuZ2V0KFwiZGlzY2FyZEJpbmRpbmdcIikuc3ludGF4VHlwZSAhPT0gXCJ2b2lkXCIpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJUaGUgJ2Rpc2NhcmRCaW5kaW5nJyBwbHVnaW4gcmVxdWlyZXMgYSAnc3ludGF4VHlwZScgb3B0aW9uLiBDdXJyZW50bHkgdGhlIG9ubHkgc3VwcG9ydGVkIHZhbHVlIGlzICd2b2lkJy5cIik7XG4gIH1cbn1cbmNvbnN0IG1peGluUGx1Z2lucyA9IHtcbiAgZXN0cmVlLFxuICBqc3gsXG4gIGZsb3csXG4gIHR5cGVzY3JpcHQsXG4gIHY4aW50cmluc2ljLFxuICBwbGFjZWhvbGRlcnNcbn07XG5jb25zdCBtaXhpblBsdWdpbk5hbWVzID0gT2JqZWN0LmtleXMobWl4aW5QbHVnaW5zKTtcbmNsYXNzIEV4cHJlc3Npb25QYXJzZXIgZXh0ZW5kcyBMVmFsUGFyc2VyIHtcbiAgY2hlY2tQcm90byhwcm9wLCBpc1JlY29yZCwgc2F3UHJvdG8sIHJlZkV4cHJlc3Npb25FcnJvcnMpIHtcbiAgICBpZiAocHJvcC50eXBlID09PSBcIlNwcmVhZEVsZW1lbnRcIiB8fCB0aGlzLmlzT2JqZWN0TWV0aG9kKHByb3ApIHx8IHByb3AuY29tcHV0ZWQgfHwgcHJvcC5zaG9ydGhhbmQpIHtcbiAgICAgIHJldHVybiBzYXdQcm90bztcbiAgICB9XG4gICAgY29uc3Qga2V5ID0gcHJvcC5rZXk7XG4gICAgY29uc3QgbmFtZSA9IGtleS50eXBlID09PSBcIklkZW50aWZpZXJcIiA/IGtleS5uYW1lIDoga2V5LnZhbHVlO1xuICAgIGlmIChuYW1lID09PSBcIl9fcHJvdG9fX1wiKSB7XG4gICAgICBpZiAoaXNSZWNvcmQpIHtcbiAgICAgICAgdGhpcy5yYWlzZShFcnJvcnMuUmVjb3JkTm9Qcm90bywga2V5KTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgICBpZiAoc2F3UHJvdG8pIHtcbiAgICAgICAgaWYgKHJlZkV4cHJlc3Npb25FcnJvcnMpIHtcbiAgICAgICAgICBpZiAocmVmRXhwcmVzc2lvbkVycm9ycy5kb3VibGVQcm90b0xvYyA9PT0gbnVsbCkge1xuICAgICAgICAgICAgcmVmRXhwcmVzc2lvbkVycm9ycy5kb3VibGVQcm90b0xvYyA9IGtleS5sb2Muc3RhcnQ7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMucmFpc2UoRXJyb3JzLkR1cGxpY2F0ZVByb3RvLCBrZXkpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIHNhd1Byb3RvO1xuICB9XG4gIHNob3VsZEV4aXREZXNjZW5kaW5nKGV4cHIsIHBvdGVudGlhbEFycm93QXQpIHtcbiAgICByZXR1cm4gZXhwci50eXBlID09PSBcIkFycm93RnVuY3Rpb25FeHByZXNzaW9uXCIgJiYgdGhpcy5vZmZzZXRUb1NvdXJjZVBvcyhleHByLnN0YXJ0KSA9PT0gcG90ZW50aWFsQXJyb3dBdDtcbiAgfVxuICBnZXRFeHByZXNzaW9uKCkge1xuICAgIHRoaXMuZW50ZXJJbml0aWFsU2NvcGVzKCk7XG4gICAgdGhpcy5uZXh0VG9rZW4oKTtcbiAgICBpZiAodGhpcy5tYXRjaCgxNDApKSB7XG4gICAgICB0aHJvdyB0aGlzLnJhaXNlKEVycm9ycy5QYXJzZUV4cHJlc3Npb25FbXB0eUlucHV0LCB0aGlzLnN0YXRlLnN0YXJ0TG9jKTtcbiAgICB9XG4gICAgY29uc3QgZXhwciA9IHRoaXMucGFyc2VFeHByZXNzaW9uKCk7XG4gICAgaWYgKCF0aGlzLm1hdGNoKDE0MCkpIHtcbiAgICAgIHRocm93IHRoaXMucmFpc2UoRXJyb3JzLlBhcnNlRXhwcmVzc2lvbkV4cGVjdHNFT0YsIHRoaXMuc3RhdGUuc3RhcnRMb2MsIHtcbiAgICAgICAgdW5leHBlY3RlZDogdGhpcy5pbnB1dC5jb2RlUG9pbnRBdCh0aGlzLnN0YXRlLnN0YXJ0KVxuICAgICAgfSk7XG4gICAgfVxuICAgIHRoaXMuZmluYWxpemVSZW1haW5pbmdDb21tZW50cygpO1xuICAgIGV4cHIuY29tbWVudHMgPSB0aGlzLmNvbW1lbnRzO1xuICAgIGV4cHIuZXJyb3JzID0gdGhpcy5zdGF0ZS5lcnJvcnM7XG4gICAgaWYgKHRoaXMub3B0aW9uRmxhZ3MgJiAyNTYpIHtcbiAgICAgIGV4cHIudG9rZW5zID0gdGhpcy50b2tlbnM7XG4gICAgfVxuICAgIHJldHVybiBleHByO1xuICB9XG4gIHBhcnNlRXhwcmVzc2lvbihkaXNhbGxvd0luLCByZWZFeHByZXNzaW9uRXJyb3JzKSB7XG4gICAgaWYgKGRpc2FsbG93SW4pIHtcbiAgICAgIHJldHVybiB0aGlzLmRpc2FsbG93SW5BbmQoKCkgPT4gdGhpcy5wYXJzZUV4cHJlc3Npb25CYXNlKHJlZkV4cHJlc3Npb25FcnJvcnMpKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuYWxsb3dJbkFuZCgoKSA9PiB0aGlzLnBhcnNlRXhwcmVzc2lvbkJhc2UocmVmRXhwcmVzc2lvbkVycm9ycykpO1xuICB9XG4gIHBhcnNlRXhwcmVzc2lvbkJhc2UocmVmRXhwcmVzc2lvbkVycm9ycykge1xuICAgIGNvbnN0IHN0YXJ0TG9jID0gdGhpcy5zdGF0ZS5zdGFydExvYztcbiAgICBjb25zdCBleHByID0gdGhpcy5wYXJzZU1heWJlQXNzaWduKHJlZkV4cHJlc3Npb25FcnJvcnMpO1xuICAgIGlmICh0aGlzLm1hdGNoKDEyKSkge1xuICAgICAgY29uc3Qgbm9kZSA9IHRoaXMuc3RhcnROb2RlQXQoc3RhcnRMb2MpO1xuICAgICAgbm9kZS5leHByZXNzaW9ucyA9IFtleHByXTtcbiAgICAgIHdoaWxlICh0aGlzLmVhdCgxMikpIHtcbiAgICAgICAgbm9kZS5leHByZXNzaW9ucy5wdXNoKHRoaXMucGFyc2VNYXliZUFzc2lnbihyZWZFeHByZXNzaW9uRXJyb3JzKSk7XG4gICAgICB9XG4gICAgICB0aGlzLnRvUmVmZXJlbmNlZExpc3Qobm9kZS5leHByZXNzaW9ucyk7XG4gICAgICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiU2VxdWVuY2VFeHByZXNzaW9uXCIpO1xuICAgIH1cbiAgICByZXR1cm4gZXhwcjtcbiAgfVxuICBwYXJzZU1heWJlQXNzaWduRGlzYWxsb3dJbihyZWZFeHByZXNzaW9uRXJyb3JzLCBhZnRlckxlZnRQYXJzZSkge1xuICAgIHJldHVybiB0aGlzLmRpc2FsbG93SW5BbmQoKCkgPT4gdGhpcy5wYXJzZU1heWJlQXNzaWduKHJlZkV4cHJlc3Npb25FcnJvcnMsIGFmdGVyTGVmdFBhcnNlKSk7XG4gIH1cbiAgcGFyc2VNYXliZUFzc2lnbkFsbG93SW4ocmVmRXhwcmVzc2lvbkVycm9ycywgYWZ0ZXJMZWZ0UGFyc2UpIHtcbiAgICByZXR1cm4gdGhpcy5hbGxvd0luQW5kKCgpID0+IHRoaXMucGFyc2VNYXliZUFzc2lnbihyZWZFeHByZXNzaW9uRXJyb3JzLCBhZnRlckxlZnRQYXJzZSkpO1xuICB9XG4gIHNldE9wdGlvbmFsUGFyYW1ldGVyc0Vycm9yKHJlZkV4cHJlc3Npb25FcnJvcnMpIHtcbiAgICByZWZFeHByZXNzaW9uRXJyb3JzLm9wdGlvbmFsUGFyYW1ldGVyc0xvYyA9IHRoaXMuc3RhdGUuc3RhcnRMb2M7XG4gIH1cbiAgcGFyc2VNYXliZUFzc2lnbihyZWZFeHByZXNzaW9uRXJyb3JzLCBhZnRlckxlZnRQYXJzZSkge1xuICAgIGNvbnN0IHN0YXJ0TG9jID0gdGhpcy5zdGF0ZS5zdGFydExvYztcbiAgICBjb25zdCBpc1lpZWxkID0gdGhpcy5pc0NvbnRleHR1YWwoMTA4KTtcbiAgICBpZiAoaXNZaWVsZCkge1xuICAgICAgaWYgKHRoaXMucHJvZFBhcmFtLmhhc1lpZWxkKSB7XG4gICAgICAgIHRoaXMubmV4dCgpO1xuICAgICAgICBsZXQgbGVmdCA9IHRoaXMucGFyc2VZaWVsZChzdGFydExvYyk7XG4gICAgICAgIGlmIChhZnRlckxlZnRQYXJzZSkge1xuICAgICAgICAgIGxlZnQgPSBhZnRlckxlZnRQYXJzZS5jYWxsKHRoaXMsIGxlZnQsIHN0YXJ0TG9jKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbGVmdDtcbiAgICAgIH1cbiAgICB9XG4gICAgbGV0IG93bkV4cHJlc3Npb25FcnJvcnM7XG4gICAgaWYgKHJlZkV4cHJlc3Npb25FcnJvcnMpIHtcbiAgICAgIG93bkV4cHJlc3Npb25FcnJvcnMgPSBmYWxzZTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmVmRXhwcmVzc2lvbkVycm9ycyA9IG5ldyBFeHByZXNzaW9uRXJyb3JzKCk7XG4gICAgICBvd25FeHByZXNzaW9uRXJyb3JzID0gdHJ1ZTtcbiAgICB9XG4gICAgY29uc3Qge1xuICAgICAgdHlwZVxuICAgIH0gPSB0aGlzLnN0YXRlO1xuICAgIGlmICh0eXBlID09PSAxMCB8fCB0b2tlbklzSWRlbnRpZmllcih0eXBlKSkge1xuICAgICAgdGhpcy5zdGF0ZS5wb3RlbnRpYWxBcnJvd0F0ID0gdGhpcy5zdGF0ZS5zdGFydDtcbiAgICB9XG4gICAgbGV0IGxlZnQgPSB0aGlzLnBhcnNlTWF5YmVDb25kaXRpb25hbChyZWZFeHByZXNzaW9uRXJyb3JzKTtcbiAgICBpZiAoYWZ0ZXJMZWZ0UGFyc2UpIHtcbiAgICAgIGxlZnQgPSBhZnRlckxlZnRQYXJzZS5jYWxsKHRoaXMsIGxlZnQsIHN0YXJ0TG9jKTtcbiAgICB9XG4gICAgaWYgKHRva2VuSXNBc3NpZ25tZW50KHRoaXMuc3RhdGUudHlwZSkpIHtcbiAgICAgIGNvbnN0IG5vZGUgPSB0aGlzLnN0YXJ0Tm9kZUF0KHN0YXJ0TG9jKTtcbiAgICAgIGNvbnN0IG9wZXJhdG9yID0gdGhpcy5zdGF0ZS52YWx1ZTtcbiAgICAgIG5vZGUub3BlcmF0b3IgPSBvcGVyYXRvcjtcbiAgICAgIGlmICh0aGlzLm1hdGNoKDI5KSkge1xuICAgICAgICB0aGlzLnRvQXNzaWduYWJsZShsZWZ0LCB0cnVlKTtcbiAgICAgICAgbm9kZS5sZWZ0ID0gbGVmdDtcbiAgICAgICAgY29uc3Qgc3RhcnRJbmRleCA9IHN0YXJ0TG9jLmluZGV4O1xuICAgICAgICBpZiAocmVmRXhwcmVzc2lvbkVycm9ycy5kb3VibGVQcm90b0xvYyAhPSBudWxsICYmIHJlZkV4cHJlc3Npb25FcnJvcnMuZG91YmxlUHJvdG9Mb2MuaW5kZXggPj0gc3RhcnRJbmRleCkge1xuICAgICAgICAgIHJlZkV4cHJlc3Npb25FcnJvcnMuZG91YmxlUHJvdG9Mb2MgPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGlmIChyZWZFeHByZXNzaW9uRXJyb3JzLnNob3J0aGFuZEFzc2lnbkxvYyAhPSBudWxsICYmIHJlZkV4cHJlc3Npb25FcnJvcnMuc2hvcnRoYW5kQXNzaWduTG9jLmluZGV4ID49IHN0YXJ0SW5kZXgpIHtcbiAgICAgICAgICByZWZFeHByZXNzaW9uRXJyb3JzLnNob3J0aGFuZEFzc2lnbkxvYyA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHJlZkV4cHJlc3Npb25FcnJvcnMucHJpdmF0ZUtleUxvYyAhPSBudWxsICYmIHJlZkV4cHJlc3Npb25FcnJvcnMucHJpdmF0ZUtleUxvYy5pbmRleCA+PSBzdGFydEluZGV4KSB7XG4gICAgICAgICAgdGhpcy5jaGVja0Rlc3RydWN0dXJpbmdQcml2YXRlKHJlZkV4cHJlc3Npb25FcnJvcnMpO1xuICAgICAgICAgIHJlZkV4cHJlc3Npb25FcnJvcnMucHJpdmF0ZUtleUxvYyA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHJlZkV4cHJlc3Npb25FcnJvcnMudm9pZFBhdHRlcm5Mb2MgIT0gbnVsbCAmJiByZWZFeHByZXNzaW9uRXJyb3JzLnZvaWRQYXR0ZXJuTG9jLmluZGV4ID49IHN0YXJ0SW5kZXgpIHtcbiAgICAgICAgICByZWZFeHByZXNzaW9uRXJyb3JzLnZvaWRQYXR0ZXJuTG9jID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbm9kZS5sZWZ0ID0gbGVmdDtcbiAgICAgIH1cbiAgICAgIHRoaXMubmV4dCgpO1xuICAgICAgbm9kZS5yaWdodCA9IHRoaXMucGFyc2VNYXliZUFzc2lnbigpO1xuICAgICAgdGhpcy5jaGVja0xWYWwobGVmdCwgdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiQXNzaWdubWVudEV4cHJlc3Npb25cIiksIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgb3BlcmF0b3IgPT09IFwifHw9XCIgfHwgb3BlcmF0b3IgPT09IFwiJiY9XCIgfHwgb3BlcmF0b3IgPT09IFwiPz89XCIpO1xuICAgICAgcmV0dXJuIG5vZGU7XG4gICAgfSBlbHNlIGlmIChvd25FeHByZXNzaW9uRXJyb3JzKSB7XG4gICAgICB0aGlzLmNoZWNrRXhwcmVzc2lvbkVycm9ycyhyZWZFeHByZXNzaW9uRXJyb3JzLCB0cnVlKTtcbiAgICB9XG4gICAgaWYgKGlzWWllbGQpIHtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgdHlwZVxuICAgICAgfSA9IHRoaXMuc3RhdGU7XG4gICAgICBjb25zdCBzdGFydHNFeHByID0gdGhpcy5oYXNQbHVnaW4oXCJ2OGludHJpbnNpY1wiKSA/IHRva2VuQ2FuU3RhcnRFeHByZXNzaW9uKHR5cGUpIDogdG9rZW5DYW5TdGFydEV4cHJlc3Npb24odHlwZSkgJiYgIXRoaXMubWF0Y2goNTQpO1xuICAgICAgaWYgKHN0YXJ0c0V4cHIgJiYgIXRoaXMuaXNBbWJpZ3VvdXNQcmVmaXhPcklkZW50aWZpZXIoKSkge1xuICAgICAgICB0aGlzLnJhaXNlT3ZlcndyaXRlKEVycm9ycy5ZaWVsZE5vdEluR2VuZXJhdG9yRnVuY3Rpb24sIHN0YXJ0TG9jKTtcbiAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VZaWVsZChzdGFydExvYyk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBsZWZ0O1xuICB9XG4gIHBhcnNlTWF5YmVDb25kaXRpb25hbChyZWZFeHByZXNzaW9uRXJyb3JzKSB7XG4gICAgY29uc3Qgc3RhcnRMb2MgPSB0aGlzLnN0YXRlLnN0YXJ0TG9jO1xuICAgIGNvbnN0IHBvdGVudGlhbEFycm93QXQgPSB0aGlzLnN0YXRlLnBvdGVudGlhbEFycm93QXQ7XG4gICAgY29uc3QgZXhwciA9IHRoaXMucGFyc2VFeHByT3BzKHJlZkV4cHJlc3Npb25FcnJvcnMpO1xuICAgIGlmICh0aGlzLnNob3VsZEV4aXREZXNjZW5kaW5nKGV4cHIsIHBvdGVudGlhbEFycm93QXQpKSB7XG4gICAgICByZXR1cm4gZXhwcjtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMucGFyc2VDb25kaXRpb25hbChleHByLCBzdGFydExvYywgcmVmRXhwcmVzc2lvbkVycm9ycyk7XG4gIH1cbiAgcGFyc2VDb25kaXRpb25hbChleHByLCBzdGFydExvYywgcmVmRXhwcmVzc2lvbkVycm9ycykge1xuICAgIGlmICh0aGlzLmVhdCgxNykpIHtcbiAgICAgIGNvbnN0IG5vZGUgPSB0aGlzLnN0YXJ0Tm9kZUF0KHN0YXJ0TG9jKTtcbiAgICAgIG5vZGUudGVzdCA9IGV4cHI7XG4gICAgICBub2RlLmNvbnNlcXVlbnQgPSB0aGlzLnBhcnNlTWF5YmVBc3NpZ25BbGxvd0luKCk7XG4gICAgICB0aGlzLmV4cGVjdCgxNCk7XG4gICAgICBub2RlLmFsdGVybmF0ZSA9IHRoaXMucGFyc2VNYXliZUFzc2lnbigpO1xuICAgICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIkNvbmRpdGlvbmFsRXhwcmVzc2lvblwiKTtcbiAgICB9XG4gICAgcmV0dXJuIGV4cHI7XG4gIH1cbiAgcGFyc2VNYXliZVVuYXJ5T3JQcml2YXRlKHJlZkV4cHJlc3Npb25FcnJvcnMpIHtcbiAgICByZXR1cm4gdGhpcy5tYXRjaCgxMzkpID8gdGhpcy5wYXJzZVByaXZhdGVOYW1lKCkgOiB0aGlzLnBhcnNlTWF5YmVVbmFyeShyZWZFeHByZXNzaW9uRXJyb3JzKTtcbiAgfVxuICBwYXJzZUV4cHJPcHMocmVmRXhwcmVzc2lvbkVycm9ycykge1xuICAgIGNvbnN0IHN0YXJ0TG9jID0gdGhpcy5zdGF0ZS5zdGFydExvYztcbiAgICBjb25zdCBwb3RlbnRpYWxBcnJvd0F0ID0gdGhpcy5zdGF0ZS5wb3RlbnRpYWxBcnJvd0F0O1xuICAgIGNvbnN0IGV4cHIgPSB0aGlzLnBhcnNlTWF5YmVVbmFyeU9yUHJpdmF0ZShyZWZFeHByZXNzaW9uRXJyb3JzKTtcbiAgICBpZiAodGhpcy5zaG91bGRFeGl0RGVzY2VuZGluZyhleHByLCBwb3RlbnRpYWxBcnJvd0F0KSkge1xuICAgICAgcmV0dXJuIGV4cHI7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLnBhcnNlRXhwck9wKGV4cHIsIHN0YXJ0TG9jLCAtMSk7XG4gIH1cbiAgcGFyc2VFeHByT3AobGVmdCwgbGVmdFN0YXJ0TG9jLCBtaW5QcmVjKSB7XG4gICAgaWYgKHRoaXMuaXNQcml2YXRlTmFtZShsZWZ0KSkge1xuICAgICAgY29uc3QgdmFsdWUgPSB0aGlzLmdldFByaXZhdGVOYW1lU1YobGVmdCk7XG4gICAgICBpZiAobWluUHJlYyA+PSB0b2tlbk9wZXJhdG9yUHJlY2VkZW5jZSg1OCkgfHwgIXRoaXMucHJvZFBhcmFtLmhhc0luIHx8ICF0aGlzLm1hdGNoKDU4KSkge1xuICAgICAgICB0aGlzLnJhaXNlKEVycm9ycy5Qcml2YXRlSW5FeHBlY3RlZEluLCBsZWZ0LCB7XG4gICAgICAgICAgaWRlbnRpZmllck5hbWU6IHZhbHVlXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgdGhpcy5jbGFzc1Njb3BlLnVzZVByaXZhdGVOYW1lKHZhbHVlLCBsZWZ0LmxvYy5zdGFydCk7XG4gICAgfVxuICAgIGNvbnN0IG9wID0gdGhpcy5zdGF0ZS50eXBlO1xuICAgIGlmICh0b2tlbklzT3BlcmF0b3Iob3ApICYmICh0aGlzLnByb2RQYXJhbS5oYXNJbiB8fCAhdGhpcy5tYXRjaCg1OCkpKSB7XG4gICAgICBsZXQgcHJlYyA9IHRva2VuT3BlcmF0b3JQcmVjZWRlbmNlKG9wKTtcbiAgICAgIGlmIChwcmVjID4gbWluUHJlYykge1xuICAgICAgICBpZiAob3AgPT09IDM5KSB7XG4gICAgICAgICAgdGhpcy5leHBlY3RQbHVnaW4oXCJwaXBlbGluZU9wZXJhdG9yXCIpO1xuICAgICAgICAgIGlmICh0aGlzLnN0YXRlLmluRlNoYXJwUGlwZWxpbmVEaXJlY3RCb2R5KSB7XG4gICAgICAgICAgICByZXR1cm4gbGVmdDtcbiAgICAgICAgICB9XG4gICAgICAgICAgdGhpcy5jaGVja1BpcGVsaW5lQXRJbmZpeE9wZXJhdG9yKGxlZnQsIGxlZnRTdGFydExvYyk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgbm9kZSA9IHRoaXMuc3RhcnROb2RlQXQobGVmdFN0YXJ0TG9jKTtcbiAgICAgICAgbm9kZS5sZWZ0ID0gbGVmdDtcbiAgICAgICAgbm9kZS5vcGVyYXRvciA9IHRoaXMuc3RhdGUudmFsdWU7XG4gICAgICAgIGNvbnN0IGxvZ2ljYWwgPSBvcCA9PT0gNDEgfHwgb3AgPT09IDQyO1xuICAgICAgICBjb25zdCBjb2FsZXNjZSA9IG9wID09PSA0MDtcbiAgICAgICAgaWYgKGNvYWxlc2NlKSB7XG4gICAgICAgICAgcHJlYyA9IHRva2VuT3BlcmF0b3JQcmVjZWRlbmNlKDQyKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLm5leHQoKTtcbiAgICAgICAgaWYgKG9wID09PSAzOSAmJiB0aGlzLmhhc1BsdWdpbihbXCJwaXBlbGluZU9wZXJhdG9yXCIsIHtcbiAgICAgICAgICBwcm9wb3NhbDogXCJtaW5pbWFsXCJcbiAgICAgICAgfV0pKSB7XG4gICAgICAgICAgaWYgKHRoaXMuc3RhdGUudHlwZSA9PT0gOTYgJiYgdGhpcy5wcm9kUGFyYW0uaGFzQXdhaXQpIHtcbiAgICAgICAgICAgIHRocm93IHRoaXMucmFpc2UoRXJyb3JzLlVuZXhwZWN0ZWRBd2FpdEFmdGVyUGlwZWxpbmVCb2R5LCB0aGlzLnN0YXRlLnN0YXJ0TG9jKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgbm9kZS5yaWdodCA9IHRoaXMucGFyc2VFeHByT3BSaWdodEV4cHIob3AsIHByZWMpO1xuICAgICAgICBjb25zdCBmaW5pc2hlZE5vZGUgPSB0aGlzLmZpbmlzaE5vZGUobm9kZSwgbG9naWNhbCB8fCBjb2FsZXNjZSA/IFwiTG9naWNhbEV4cHJlc3Npb25cIiA6IFwiQmluYXJ5RXhwcmVzc2lvblwiKTtcbiAgICAgICAgY29uc3QgbmV4dE9wID0gdGhpcy5zdGF0ZS50eXBlO1xuICAgICAgICBpZiAoY29hbGVzY2UgJiYgKG5leHRPcCA9PT0gNDEgfHwgbmV4dE9wID09PSA0MikgfHwgbG9naWNhbCAmJiBuZXh0T3AgPT09IDQwKSB7XG4gICAgICAgICAgdGhyb3cgdGhpcy5yYWlzZShFcnJvcnMuTWl4aW5nQ29hbGVzY2VXaXRoTG9naWNhbCwgdGhpcy5zdGF0ZS5zdGFydExvYyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VFeHByT3AoZmluaXNoZWROb2RlLCBsZWZ0U3RhcnRMb2MsIG1pblByZWMpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbGVmdDtcbiAgfVxuICBwYXJzZUV4cHJPcFJpZ2h0RXhwcihvcCwgcHJlYykge1xuICAgIGNvbnN0IHN0YXJ0TG9jID0gdGhpcy5zdGF0ZS5zdGFydExvYztcbiAgICBzd2l0Y2ggKG9wKSB7XG4gICAgICBjYXNlIDM5OlxuICAgICAgICBzd2l0Y2ggKHRoaXMuZ2V0UGx1Z2luT3B0aW9uKFwicGlwZWxpbmVPcGVyYXRvclwiLCBcInByb3Bvc2FsXCIpKSB7XG4gICAgICAgICAgY2FzZSBcImhhY2tcIjpcbiAgICAgICAgICAgIHJldHVybiB0aGlzLndpdGhUb3BpY0JpbmRpbmdDb250ZXh0KCgpID0+IHtcbiAgICAgICAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VIYWNrUGlwZUJvZHkoKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIGNhc2UgXCJmc2hhcnBcIjpcbiAgICAgICAgICAgIHJldHVybiB0aGlzLndpdGhTb2xvQXdhaXRQZXJtaXR0aW5nQ29udGV4dCgoKSA9PiB7XG4gICAgICAgICAgICAgIHJldHVybiB0aGlzLnBhcnNlRlNoYXJwUGlwZWxpbmVCb2R5KHByZWMpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuZ2V0UGx1Z2luT3B0aW9uKFwicGlwZWxpbmVPcGVyYXRvclwiLCBcInByb3Bvc2FsXCIpID09PSBcInNtYXJ0XCIpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy53aXRoVG9waWNCaW5kaW5nQ29udGV4dCgoKSA9PiB7XG4gICAgICAgICAgICBpZiAodGhpcy5wcm9kUGFyYW0uaGFzWWllbGQgJiYgdGhpcy5pc0NvbnRleHR1YWwoMTA4KSkge1xuICAgICAgICAgICAgICB0aHJvdyB0aGlzLnJhaXNlKEVycm9ycy5QaXBlQm9keUlzVGlnaHRlciwgdGhpcy5zdGF0ZS5zdGFydExvYyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5wYXJzZVNtYXJ0UGlwZWxpbmVCb2R5SW5TdHlsZSh0aGlzLnBhcnNlRXhwck9wQmFzZVJpZ2h0RXhwcihvcCwgcHJlYyksIHN0YXJ0TG9jKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VFeHByT3BCYXNlUmlnaHRFeHByKG9wLCBwcmVjKTtcbiAgICB9XG4gIH1cbiAgcGFyc2VFeHByT3BCYXNlUmlnaHRFeHByKG9wLCBwcmVjKSB7XG4gICAgY29uc3Qgc3RhcnRMb2MgPSB0aGlzLnN0YXRlLnN0YXJ0TG9jO1xuICAgIHJldHVybiB0aGlzLnBhcnNlRXhwck9wKHRoaXMucGFyc2VNYXliZVVuYXJ5T3JQcml2YXRlKCksIHN0YXJ0TG9jLCB0b2tlbklzUmlnaHRBc3NvY2lhdGl2ZShvcCkgPyBwcmVjIC0gMSA6IHByZWMpO1xuICB9XG4gIHBhcnNlSGFja1BpcGVCb2R5KCkge1xuICAgIHZhciBfYm9keSRleHRyYTtcbiAgICBjb25zdCB7XG4gICAgICBzdGFydExvY1xuICAgIH0gPSB0aGlzLnN0YXRlO1xuICAgIGNvbnN0IGJvZHkgPSB0aGlzLnBhcnNlTWF5YmVBc3NpZ24oKTtcbiAgICBjb25zdCByZXF1aXJlZFBhcmVudGhlc2VzID0gVW5wYXJlbnRoZXNpemVkUGlwZUJvZHlEZXNjcmlwdGlvbnMuaGFzKGJvZHkudHlwZSk7XG4gICAgaWYgKHJlcXVpcmVkUGFyZW50aGVzZXMgJiYgISgoX2JvZHkkZXh0cmEgPSBib2R5LmV4dHJhKSAhPSBudWxsICYmIF9ib2R5JGV4dHJhLnBhcmVudGhlc2l6ZWQpKSB7XG4gICAgICB0aGlzLnJhaXNlKEVycm9ycy5QaXBlVW5wYXJlbnRoZXNpemVkQm9keSwgc3RhcnRMb2MsIHtcbiAgICAgICAgdHlwZTogYm9keS50eXBlXG4gICAgICB9KTtcbiAgICB9XG4gICAgaWYgKCF0aGlzLnRvcGljUmVmZXJlbmNlV2FzVXNlZEluQ3VycmVudENvbnRleHQoKSkge1xuICAgICAgdGhpcy5yYWlzZShFcnJvcnMuUGlwZVRvcGljVW51c2VkLCBzdGFydExvYyk7XG4gICAgfVxuICAgIHJldHVybiBib2R5O1xuICB9XG4gIGNoZWNrRXhwb25lbnRpYWxBZnRlclVuYXJ5KG5vZGUpIHtcbiAgICBpZiAodGhpcy5tYXRjaCg1NykpIHtcbiAgICAgIHRoaXMucmFpc2UoRXJyb3JzLlVuZXhwZWN0ZWRUb2tlblVuYXJ5RXhwb25lbnRpYXRpb24sIG5vZGUuYXJndW1lbnQpO1xuICAgIH1cbiAgfVxuICBwYXJzZU1heWJlVW5hcnkocmVmRXhwcmVzc2lvbkVycm9ycywgc2F3VW5hcnkpIHtcbiAgICBjb25zdCBzdGFydExvYyA9IHRoaXMuc3RhdGUuc3RhcnRMb2M7XG4gICAgY29uc3QgaXNBd2FpdCA9IHRoaXMuaXNDb250ZXh0dWFsKDk2KTtcbiAgICBpZiAoaXNBd2FpdCAmJiB0aGlzLnJlY29yZEF3YWl0SWZBbGxvd2VkKCkpIHtcbiAgICAgIHRoaXMubmV4dCgpO1xuICAgICAgY29uc3QgZXhwciA9IHRoaXMucGFyc2VBd2FpdChzdGFydExvYyk7XG4gICAgICBpZiAoIXNhd1VuYXJ5KSB0aGlzLmNoZWNrRXhwb25lbnRpYWxBZnRlclVuYXJ5KGV4cHIpO1xuICAgICAgcmV0dXJuIGV4cHI7XG4gICAgfVxuICAgIGNvbnN0IHVwZGF0ZSA9IHRoaXMubWF0Y2goMzQpO1xuICAgIGNvbnN0IG5vZGUgPSB0aGlzLnN0YXJ0Tm9kZSgpO1xuICAgIGlmICh0b2tlbklzUHJlZml4KHRoaXMuc3RhdGUudHlwZSkpIHtcbiAgICAgIG5vZGUub3BlcmF0b3IgPSB0aGlzLnN0YXRlLnZhbHVlO1xuICAgICAgbm9kZS5wcmVmaXggPSB0cnVlO1xuICAgICAgaWYgKHRoaXMubWF0Y2goNzIpKSB7XG4gICAgICAgIHRoaXMuZXhwZWN0UGx1Z2luKFwidGhyb3dFeHByZXNzaW9uc1wiKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGlzRGVsZXRlID0gdGhpcy5tYXRjaCg4OSk7XG4gICAgICB0aGlzLm5leHQoKTtcbiAgICAgIG5vZGUuYXJndW1lbnQgPSB0aGlzLnBhcnNlTWF5YmVVbmFyeShudWxsLCB0cnVlKTtcbiAgICAgIHRoaXMuY2hlY2tFeHByZXNzaW9uRXJyb3JzKHJlZkV4cHJlc3Npb25FcnJvcnMsIHRydWUpO1xuICAgICAgaWYgKHRoaXMuc3RhdGUuc3RyaWN0ICYmIGlzRGVsZXRlKSB7XG4gICAgICAgIGNvbnN0IGFyZyA9IG5vZGUuYXJndW1lbnQ7XG4gICAgICAgIGlmIChhcmcudHlwZSA9PT0gXCJJZGVudGlmaWVyXCIpIHtcbiAgICAgICAgICB0aGlzLnJhaXNlKEVycm9ycy5TdHJpY3REZWxldGUsIG5vZGUpO1xuICAgICAgICB9IGVsc2UgaWYgKHRoaXMuaGFzUHJvcGVydHlBc1ByaXZhdGVOYW1lKGFyZykpIHtcbiAgICAgICAgICB0aGlzLnJhaXNlKEVycm9ycy5EZWxldGVQcml2YXRlRmllbGQsIG5vZGUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoIXVwZGF0ZSkge1xuICAgICAgICBpZiAoIXNhd1VuYXJ5KSB7XG4gICAgICAgICAgdGhpcy5jaGVja0V4cG9uZW50aWFsQWZ0ZXJVbmFyeShub2RlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiVW5hcnlFeHByZXNzaW9uXCIpO1xuICAgICAgfVxuICAgIH1cbiAgICBjb25zdCBleHByID0gdGhpcy5wYXJzZVVwZGF0ZShub2RlLCB1cGRhdGUsIHJlZkV4cHJlc3Npb25FcnJvcnMpO1xuICAgIGlmIChpc0F3YWl0KSB7XG4gICAgICBjb25zdCB7XG4gICAgICAgIHR5cGVcbiAgICAgIH0gPSB0aGlzLnN0YXRlO1xuICAgICAgY29uc3Qgc3RhcnRzRXhwciA9IHRoaXMuaGFzUGx1Z2luKFwidjhpbnRyaW5zaWNcIikgPyB0b2tlbkNhblN0YXJ0RXhwcmVzc2lvbih0eXBlKSA6IHRva2VuQ2FuU3RhcnRFeHByZXNzaW9uKHR5cGUpICYmICF0aGlzLm1hdGNoKDU0KTtcbiAgICAgIGlmIChzdGFydHNFeHByICYmICF0aGlzLmlzQW1iaWd1b3VzUHJlZml4T3JJZGVudGlmaWVyKCkpIHtcbiAgICAgICAgdGhpcy5yYWlzZU92ZXJ3cml0ZShFcnJvcnMuQXdhaXROb3RJbkFzeW5jQ29udGV4dCwgc3RhcnRMb2MpO1xuICAgICAgICByZXR1cm4gdGhpcy5wYXJzZUF3YWl0KHN0YXJ0TG9jKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGV4cHI7XG4gIH1cbiAgcGFyc2VVcGRhdGUobm9kZSwgdXBkYXRlLCByZWZFeHByZXNzaW9uRXJyb3JzKSB7XG4gICAgaWYgKHVwZGF0ZSkge1xuICAgICAgY29uc3QgdXBkYXRlRXhwcmVzc2lvbk5vZGUgPSBub2RlO1xuICAgICAgdGhpcy5jaGVja0xWYWwodXBkYXRlRXhwcmVzc2lvbk5vZGUuYXJndW1lbnQsIHRoaXMuZmluaXNoTm9kZSh1cGRhdGVFeHByZXNzaW9uTm9kZSwgXCJVcGRhdGVFeHByZXNzaW9uXCIpKTtcbiAgICAgIHJldHVybiBub2RlO1xuICAgIH1cbiAgICBjb25zdCBzdGFydExvYyA9IHRoaXMuc3RhdGUuc3RhcnRMb2M7XG4gICAgbGV0IGV4cHIgPSB0aGlzLnBhcnNlRXhwclN1YnNjcmlwdHMocmVmRXhwcmVzc2lvbkVycm9ycyk7XG4gICAgaWYgKHRoaXMuY2hlY2tFeHByZXNzaW9uRXJyb3JzKHJlZkV4cHJlc3Npb25FcnJvcnMsIGZhbHNlKSkgcmV0dXJuIGV4cHI7XG4gICAgd2hpbGUgKHRva2VuSXNQb3N0Zml4KHRoaXMuc3RhdGUudHlwZSkgJiYgIXRoaXMuY2FuSW5zZXJ0U2VtaWNvbG9uKCkpIHtcbiAgICAgIGNvbnN0IG5vZGUgPSB0aGlzLnN0YXJ0Tm9kZUF0KHN0YXJ0TG9jKTtcbiAgICAgIG5vZGUub3BlcmF0b3IgPSB0aGlzLnN0YXRlLnZhbHVlO1xuICAgICAgbm9kZS5wcmVmaXggPSBmYWxzZTtcbiAgICAgIG5vZGUuYXJndW1lbnQgPSBleHByO1xuICAgICAgdGhpcy5uZXh0KCk7XG4gICAgICB0aGlzLmNoZWNrTFZhbChleHByLCBleHByID0gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiVXBkYXRlRXhwcmVzc2lvblwiKSk7XG4gICAgfVxuICAgIHJldHVybiBleHByO1xuICB9XG4gIHBhcnNlRXhwclN1YnNjcmlwdHMocmVmRXhwcmVzc2lvbkVycm9ycykge1xuICAgIGNvbnN0IHN0YXJ0TG9jID0gdGhpcy5zdGF0ZS5zdGFydExvYztcbiAgICBjb25zdCBwb3RlbnRpYWxBcnJvd0F0ID0gdGhpcy5zdGF0ZS5wb3RlbnRpYWxBcnJvd0F0O1xuICAgIGNvbnN0IGV4cHIgPSB0aGlzLnBhcnNlRXhwckF0b20ocmVmRXhwcmVzc2lvbkVycm9ycyk7XG4gICAgaWYgKHRoaXMuc2hvdWxkRXhpdERlc2NlbmRpbmcoZXhwciwgcG90ZW50aWFsQXJyb3dBdCkpIHtcbiAgICAgIHJldHVybiBleHByO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5wYXJzZVN1YnNjcmlwdHMoZXhwciwgc3RhcnRMb2MpO1xuICB9XG4gIHBhcnNlU3Vic2NyaXB0cyhiYXNlLCBzdGFydExvYywgbm9DYWxscykge1xuICAgIGNvbnN0IHN0YXRlID0ge1xuICAgICAgb3B0aW9uYWxDaGFpbk1lbWJlcjogZmFsc2UsXG4gICAgICBtYXliZUFzeW5jQXJyb3c6IHRoaXMuYXRQb3NzaWJsZUFzeW5jQXJyb3coYmFzZSksXG4gICAgICBzdG9wOiBmYWxzZVxuICAgIH07XG4gICAgZG8ge1xuICAgICAgYmFzZSA9IHRoaXMucGFyc2VTdWJzY3JpcHQoYmFzZSwgc3RhcnRMb2MsIG5vQ2FsbHMsIHN0YXRlKTtcbiAgICAgIHN0YXRlLm1heWJlQXN5bmNBcnJvdyA9IGZhbHNlO1xuICAgIH0gd2hpbGUgKCFzdGF0ZS5zdG9wKTtcbiAgICByZXR1cm4gYmFzZTtcbiAgfVxuICBwYXJzZVN1YnNjcmlwdChiYXNlLCBzdGFydExvYywgbm9DYWxscywgc3RhdGUpIHtcbiAgICBjb25zdCB7XG4gICAgICB0eXBlXG4gICAgfSA9IHRoaXMuc3RhdGU7XG4gICAgaWYgKCFub0NhbGxzICYmIHR5cGUgPT09IDE1KSB7XG4gICAgICByZXR1cm4gdGhpcy5wYXJzZUJpbmQoYmFzZSwgc3RhcnRMb2MsIG5vQ2FsbHMsIHN0YXRlKTtcbiAgICB9IGVsc2UgaWYgKHRva2VuSXNUZW1wbGF0ZSh0eXBlKSkge1xuICAgICAgcmV0dXJuIHRoaXMucGFyc2VUYWdnZWRUZW1wbGF0ZUV4cHJlc3Npb24oYmFzZSwgc3RhcnRMb2MsIHN0YXRlKTtcbiAgICB9XG4gICAgbGV0IG9wdGlvbmFsID0gZmFsc2U7XG4gICAgaWYgKHR5cGUgPT09IDE4KSB7XG4gICAgICBpZiAobm9DYWxscykge1xuICAgICAgICB0aGlzLnJhaXNlKEVycm9ycy5PcHRpb25hbENoYWluaW5nTm9OZXcsIHRoaXMuc3RhdGUuc3RhcnRMb2MpO1xuICAgICAgICBpZiAodGhpcy5sb29rYWhlYWRDaGFyQ29kZSgpID09PSA0MCkge1xuICAgICAgICAgIHJldHVybiB0aGlzLnN0b3BQYXJzZVN1YnNjcmlwdChiYXNlLCBzdGF0ZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHN0YXRlLm9wdGlvbmFsQ2hhaW5NZW1iZXIgPSBvcHRpb25hbCA9IHRydWU7XG4gICAgICB0aGlzLm5leHQoKTtcbiAgICB9XG4gICAgaWYgKCFub0NhbGxzICYmIHRoaXMubWF0Y2goMTApKSB7XG4gICAgICByZXR1cm4gdGhpcy5wYXJzZUNvdmVyQ2FsbEFuZEFzeW5jQXJyb3dIZWFkKGJhc2UsIHN0YXJ0TG9jLCBzdGF0ZSwgb3B0aW9uYWwpO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBjb21wdXRlZCA9IHRoaXMuZWF0KDApO1xuICAgICAgaWYgKGNvbXB1dGVkIHx8IG9wdGlvbmFsIHx8IHRoaXMuZWF0KDE2KSkge1xuICAgICAgICByZXR1cm4gdGhpcy5wYXJzZU1lbWJlcihiYXNlLCBzdGFydExvYywgc3RhdGUsIGNvbXB1dGVkLCBvcHRpb25hbCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gdGhpcy5zdG9wUGFyc2VTdWJzY3JpcHQoYmFzZSwgc3RhdGUpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBzdG9wUGFyc2VTdWJzY3JpcHQoYmFzZSwgc3RhdGUpIHtcbiAgICBzdGF0ZS5zdG9wID0gdHJ1ZTtcbiAgICByZXR1cm4gYmFzZTtcbiAgfVxuICBwYXJzZU1lbWJlcihiYXNlLCBzdGFydExvYywgc3RhdGUsIGNvbXB1dGVkLCBvcHRpb25hbCkge1xuICAgIGNvbnN0IG5vZGUgPSB0aGlzLnN0YXJ0Tm9kZUF0KHN0YXJ0TG9jKTtcbiAgICBub2RlLm9iamVjdCA9IGJhc2U7XG4gICAgbm9kZS5jb21wdXRlZCA9IGNvbXB1dGVkO1xuICAgIGlmIChjb21wdXRlZCkge1xuICAgICAgbm9kZS5wcm9wZXJ0eSA9IHRoaXMucGFyc2VFeHByZXNzaW9uKCk7XG4gICAgICB0aGlzLmV4cGVjdCgzKTtcbiAgICB9IGVsc2UgaWYgKHRoaXMubWF0Y2goMTM5KSkge1xuICAgICAgaWYgKGJhc2UudHlwZSA9PT0gXCJTdXBlclwiKSB7XG4gICAgICAgIHRoaXMucmFpc2UoRXJyb3JzLlN1cGVyUHJpdmF0ZUZpZWxkLCBzdGFydExvYyk7XG4gICAgICB9XG4gICAgICB0aGlzLmNsYXNzU2NvcGUudXNlUHJpdmF0ZU5hbWUodGhpcy5zdGF0ZS52YWx1ZSwgdGhpcy5zdGF0ZS5zdGFydExvYyk7XG4gICAgICBub2RlLnByb3BlcnR5ID0gdGhpcy5wYXJzZVByaXZhdGVOYW1lKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIG5vZGUucHJvcGVydHkgPSB0aGlzLnBhcnNlSWRlbnRpZmllcih0cnVlKTtcbiAgICB9XG4gICAgaWYgKHN0YXRlLm9wdGlvbmFsQ2hhaW5NZW1iZXIpIHtcbiAgICAgIG5vZGUub3B0aW9uYWwgPSBvcHRpb25hbDtcbiAgICAgIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJPcHRpb25hbE1lbWJlckV4cHJlc3Npb25cIik7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJNZW1iZXJFeHByZXNzaW9uXCIpO1xuICAgIH1cbiAgfVxuICBwYXJzZUJpbmQoYmFzZSwgc3RhcnRMb2MsIG5vQ2FsbHMsIHN0YXRlKSB7XG4gICAgY29uc3Qgbm9kZSA9IHRoaXMuc3RhcnROb2RlQXQoc3RhcnRMb2MpO1xuICAgIG5vZGUub2JqZWN0ID0gYmFzZTtcbiAgICB0aGlzLm5leHQoKTtcbiAgICBub2RlLmNhbGxlZSA9IHRoaXMucGFyc2VOb0NhbGxFeHByKCk7XG4gICAgc3RhdGUuc3RvcCA9IHRydWU7XG4gICAgcmV0dXJuIHRoaXMucGFyc2VTdWJzY3JpcHRzKHRoaXMuZmluaXNoTm9kZShub2RlLCBcIkJpbmRFeHByZXNzaW9uXCIpLCBzdGFydExvYywgbm9DYWxscyk7XG4gIH1cbiAgcGFyc2VDb3ZlckNhbGxBbmRBc3luY0Fycm93SGVhZChiYXNlLCBzdGFydExvYywgc3RhdGUsIG9wdGlvbmFsKSB7XG4gICAgY29uc3Qgb2xkTWF5YmVJbkFycm93UGFyYW1ldGVycyA9IHRoaXMuc3RhdGUubWF5YmVJbkFycm93UGFyYW1ldGVycztcbiAgICBsZXQgcmVmRXhwcmVzc2lvbkVycm9ycyA9IG51bGw7XG4gICAgdGhpcy5zdGF0ZS5tYXliZUluQXJyb3dQYXJhbWV0ZXJzID0gdHJ1ZTtcbiAgICB0aGlzLm5leHQoKTtcbiAgICBjb25zdCBub2RlID0gdGhpcy5zdGFydE5vZGVBdChzdGFydExvYyk7XG4gICAgbm9kZS5jYWxsZWUgPSBiYXNlO1xuICAgIGNvbnN0IHtcbiAgICAgIG1heWJlQXN5bmNBcnJvdyxcbiAgICAgIG9wdGlvbmFsQ2hhaW5NZW1iZXJcbiAgICB9ID0gc3RhdGU7XG4gICAgaWYgKG1heWJlQXN5bmNBcnJvdykge1xuICAgICAgdGhpcy5leHByZXNzaW9uU2NvcGUuZW50ZXIobmV3QXN5bmNBcnJvd1Njb3BlKCkpO1xuICAgICAgcmVmRXhwcmVzc2lvbkVycm9ycyA9IG5ldyBFeHByZXNzaW9uRXJyb3JzKCk7XG4gICAgfVxuICAgIGlmIChvcHRpb25hbENoYWluTWVtYmVyKSB7XG4gICAgICBub2RlLm9wdGlvbmFsID0gb3B0aW9uYWw7XG4gICAgfVxuICAgIGlmIChvcHRpb25hbCkge1xuICAgICAgbm9kZS5hcmd1bWVudHMgPSB0aGlzLnBhcnNlQ2FsbEV4cHJlc3Npb25Bcmd1bWVudHMoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgbm9kZS5hcmd1bWVudHMgPSB0aGlzLnBhcnNlQ2FsbEV4cHJlc3Npb25Bcmd1bWVudHMoYmFzZS50eXBlICE9PSBcIlN1cGVyXCIsIG5vZGUsIHJlZkV4cHJlc3Npb25FcnJvcnMpO1xuICAgIH1cbiAgICBsZXQgZmluaXNoZWROb2RlID0gdGhpcy5maW5pc2hDYWxsRXhwcmVzc2lvbihub2RlLCBvcHRpb25hbENoYWluTWVtYmVyKTtcbiAgICBpZiAobWF5YmVBc3luY0Fycm93ICYmIHRoaXMuc2hvdWxkUGFyc2VBc3luY0Fycm93KCkgJiYgIW9wdGlvbmFsKSB7XG4gICAgICBzdGF0ZS5zdG9wID0gdHJ1ZTtcbiAgICAgIHRoaXMuY2hlY2tEZXN0cnVjdHVyaW5nUHJpdmF0ZShyZWZFeHByZXNzaW9uRXJyb3JzKTtcbiAgICAgIHRoaXMuZXhwcmVzc2lvblNjb3BlLnZhbGlkYXRlQXNQYXR0ZXJuKCk7XG4gICAgICB0aGlzLmV4cHJlc3Npb25TY29wZS5leGl0KCk7XG4gICAgICBmaW5pc2hlZE5vZGUgPSB0aGlzLnBhcnNlQXN5bmNBcnJvd0Zyb21DYWxsRXhwcmVzc2lvbih0aGlzLnN0YXJ0Tm9kZUF0KHN0YXJ0TG9jKSwgZmluaXNoZWROb2RlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKG1heWJlQXN5bmNBcnJvdykge1xuICAgICAgICB0aGlzLmNoZWNrRXhwcmVzc2lvbkVycm9ycyhyZWZFeHByZXNzaW9uRXJyb3JzLCB0cnVlKTtcbiAgICAgICAgdGhpcy5leHByZXNzaW9uU2NvcGUuZXhpdCgpO1xuICAgICAgfVxuICAgICAgdGhpcy50b1JlZmVyZW5jZWRBcmd1bWVudHMoZmluaXNoZWROb2RlKTtcbiAgICB9XG4gICAgdGhpcy5zdGF0ZS5tYXliZUluQXJyb3dQYXJhbWV0ZXJzID0gb2xkTWF5YmVJbkFycm93UGFyYW1ldGVycztcbiAgICByZXR1cm4gZmluaXNoZWROb2RlO1xuICB9XG4gIHRvUmVmZXJlbmNlZEFyZ3VtZW50cyhub2RlLCBpc1BhcmVudGhlc2l6ZWRFeHByKSB7XG4gICAgdGhpcy50b1JlZmVyZW5jZWRMaXN0RGVlcChub2RlLmFyZ3VtZW50cywgaXNQYXJlbnRoZXNpemVkRXhwcik7XG4gIH1cbiAgcGFyc2VUYWdnZWRUZW1wbGF0ZUV4cHJlc3Npb24oYmFzZSwgc3RhcnRMb2MsIHN0YXRlKSB7XG4gICAgY29uc3Qgbm9kZSA9IHRoaXMuc3RhcnROb2RlQXQoc3RhcnRMb2MpO1xuICAgIG5vZGUudGFnID0gYmFzZTtcbiAgICBub2RlLnF1YXNpID0gdGhpcy5wYXJzZVRlbXBsYXRlKHRydWUpO1xuICAgIGlmIChzdGF0ZS5vcHRpb25hbENoYWluTWVtYmVyKSB7XG4gICAgICB0aGlzLnJhaXNlKEVycm9ycy5PcHRpb25hbENoYWluaW5nTm9UZW1wbGF0ZSwgc3RhcnRMb2MpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiVGFnZ2VkVGVtcGxhdGVFeHByZXNzaW9uXCIpO1xuICB9XG4gIGF0UG9zc2libGVBc3luY0Fycm93KGJhc2UpIHtcbiAgICByZXR1cm4gYmFzZS50eXBlID09PSBcIklkZW50aWZpZXJcIiAmJiBiYXNlLm5hbWUgPT09IFwiYXN5bmNcIiAmJiB0aGlzLnN0YXRlLmxhc3RUb2tFbmRMb2MuaW5kZXggPT09IGJhc2UuZW5kICYmICF0aGlzLmNhbkluc2VydFNlbWljb2xvbigpICYmIGJhc2UuZW5kIC0gYmFzZS5zdGFydCA9PT0gNSAmJiB0aGlzLm9mZnNldFRvU291cmNlUG9zKGJhc2Uuc3RhcnQpID09PSB0aGlzLnN0YXRlLnBvdGVudGlhbEFycm93QXQ7XG4gIH1cbiAgZmluaXNoQ2FsbEV4cHJlc3Npb24obm9kZSwgb3B0aW9uYWwpIHtcbiAgICBpZiAobm9kZS5jYWxsZWUudHlwZSA9PT0gXCJJbXBvcnRcIikge1xuICAgICAgaWYgKG5vZGUuYXJndW1lbnRzLmxlbmd0aCA9PT0gMCB8fCBub2RlLmFyZ3VtZW50cy5sZW5ndGggPiAyKSB7XG4gICAgICAgIHRoaXMucmFpc2UoRXJyb3JzLkltcG9ydENhbGxBcml0eSwgbm9kZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBmb3IgKGNvbnN0IGFyZyBvZiBub2RlLmFyZ3VtZW50cykge1xuICAgICAgICAgIGlmIChhcmcudHlwZSA9PT0gXCJTcHJlYWRFbGVtZW50XCIpIHtcbiAgICAgICAgICAgIHRoaXMucmFpc2UoRXJyb3JzLkltcG9ydENhbGxTcHJlYWRBcmd1bWVudCwgYXJnKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBvcHRpb25hbCA/IFwiT3B0aW9uYWxDYWxsRXhwcmVzc2lvblwiIDogXCJDYWxsRXhwcmVzc2lvblwiKTtcbiAgfVxuICBwYXJzZUNhbGxFeHByZXNzaW9uQXJndW1lbnRzKGFsbG93UGxhY2Vob2xkZXIsIG5vZGVGb3JFeHRyYSwgcmVmRXhwcmVzc2lvbkVycm9ycykge1xuICAgIGNvbnN0IGVsdHMgPSBbXTtcbiAgICBsZXQgZmlyc3QgPSB0cnVlO1xuICAgIGNvbnN0IG9sZEluRlNoYXJwUGlwZWxpbmVEaXJlY3RCb2R5ID0gdGhpcy5zdGF0ZS5pbkZTaGFycFBpcGVsaW5lRGlyZWN0Qm9keTtcbiAgICB0aGlzLnN0YXRlLmluRlNoYXJwUGlwZWxpbmVEaXJlY3RCb2R5ID0gZmFsc2U7XG4gICAgd2hpbGUgKCF0aGlzLmVhdCgxMSkpIHtcbiAgICAgIGlmIChmaXJzdCkge1xuICAgICAgICBmaXJzdCA9IGZhbHNlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5leHBlY3QoMTIpO1xuICAgICAgICBpZiAodGhpcy5tYXRjaCgxMSkpIHtcbiAgICAgICAgICBpZiAobm9kZUZvckV4dHJhKSB7XG4gICAgICAgICAgICB0aGlzLmFkZFRyYWlsaW5nQ29tbWFFeHRyYVRvTm9kZShub2RlRm9yRXh0cmEpO1xuICAgICAgICAgIH1cbiAgICAgICAgICB0aGlzLm5leHQoKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgZWx0cy5wdXNoKHRoaXMucGFyc2VFeHByTGlzdEl0ZW0oMTEsIGZhbHNlLCByZWZFeHByZXNzaW9uRXJyb3JzLCBhbGxvd1BsYWNlaG9sZGVyKSk7XG4gICAgfVxuICAgIHRoaXMuc3RhdGUuaW5GU2hhcnBQaXBlbGluZURpcmVjdEJvZHkgPSBvbGRJbkZTaGFycFBpcGVsaW5lRGlyZWN0Qm9keTtcbiAgICByZXR1cm4gZWx0cztcbiAgfVxuICBzaG91bGRQYXJzZUFzeW5jQXJyb3coKSB7XG4gICAgcmV0dXJuIHRoaXMubWF0Y2goMTkpICYmICF0aGlzLmNhbkluc2VydFNlbWljb2xvbigpO1xuICB9XG4gIHBhcnNlQXN5bmNBcnJvd0Zyb21DYWxsRXhwcmVzc2lvbihub2RlLCBjYWxsKSB7XG4gICAgdmFyIF9jYWxsJGV4dHJhO1xuICAgIHRoaXMucmVzZXRQcmV2aW91c05vZGVUcmFpbGluZ0NvbW1lbnRzKGNhbGwpO1xuICAgIHRoaXMuZXhwZWN0KDE5KTtcbiAgICB0aGlzLnBhcnNlQXJyb3dFeHByZXNzaW9uKG5vZGUsIGNhbGwuYXJndW1lbnRzLCB0cnVlLCAoX2NhbGwkZXh0cmEgPSBjYWxsLmV4dHJhKSA9PSBudWxsID8gdm9pZCAwIDogX2NhbGwkZXh0cmEudHJhaWxpbmdDb21tYUxvYyk7XG4gICAgaWYgKGNhbGwuaW5uZXJDb21tZW50cykge1xuICAgICAgc2V0SW5uZXJDb21tZW50cyhub2RlLCBjYWxsLmlubmVyQ29tbWVudHMpO1xuICAgIH1cbiAgICBpZiAoY2FsbC5jYWxsZWUudHJhaWxpbmdDb21tZW50cykge1xuICAgICAgc2V0SW5uZXJDb21tZW50cyhub2RlLCBjYWxsLmNhbGxlZS50cmFpbGluZ0NvbW1lbnRzKTtcbiAgICB9XG4gICAgcmV0dXJuIG5vZGU7XG4gIH1cbiAgcGFyc2VOb0NhbGxFeHByKCkge1xuICAgIGNvbnN0IHN0YXJ0TG9jID0gdGhpcy5zdGF0ZS5zdGFydExvYztcbiAgICByZXR1cm4gdGhpcy5wYXJzZVN1YnNjcmlwdHModGhpcy5wYXJzZUV4cHJBdG9tKCksIHN0YXJ0TG9jLCB0cnVlKTtcbiAgfVxuICBwYXJzZUV4cHJBdG9tKHJlZkV4cHJlc3Npb25FcnJvcnMpIHtcbiAgICBsZXQgbm9kZTtcbiAgICBsZXQgZGVjb3JhdG9ycyA9IG51bGw7XG4gICAgY29uc3Qge1xuICAgICAgdHlwZVxuICAgIH0gPSB0aGlzLnN0YXRlO1xuICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgY2FzZSA3OTpcbiAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VTdXBlcigpO1xuICAgICAgY2FzZSA4MzpcbiAgICAgICAgbm9kZSA9IHRoaXMuc3RhcnROb2RlKCk7XG4gICAgICAgIHRoaXMubmV4dCgpO1xuICAgICAgICBpZiAodGhpcy5tYXRjaCgxNikpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5wYXJzZUltcG9ydE1ldGFQcm9wZXJ0eU9yUGhhc2VDYWxsKG5vZGUpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLm1hdGNoKDEwKSkge1xuICAgICAgICAgIGlmICh0aGlzLm9wdGlvbkZsYWdzICYgNTEyKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5wYXJzZUltcG9ydENhbGwobm9kZSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJJbXBvcnRcIik7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMucmFpc2UoRXJyb3JzLlVuc3VwcG9ydGVkSW1wb3J0LCB0aGlzLnN0YXRlLmxhc3RUb2tTdGFydExvYyk7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIkltcG9ydFwiKTtcbiAgICAgICAgfVxuICAgICAgY2FzZSA3ODpcbiAgICAgICAgbm9kZSA9IHRoaXMuc3RhcnROb2RlKCk7XG4gICAgICAgIHRoaXMubmV4dCgpO1xuICAgICAgICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiVGhpc0V4cHJlc3Npb25cIik7XG4gICAgICBjYXNlIDkwOlxuICAgICAgICB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VEbyh0aGlzLnN0YXJ0Tm9kZSgpLCBmYWxzZSk7XG4gICAgICAgIH1cbiAgICAgIGNhc2UgNTY6XG4gICAgICBjYXNlIDMxOlxuICAgICAgICB7XG4gICAgICAgICAgdGhpcy5yZWFkUmVnZXhwKCk7XG4gICAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VSZWdFeHBMaXRlcmFsKHRoaXMuc3RhdGUudmFsdWUpO1xuICAgICAgICB9XG4gICAgICBjYXNlIDEzNTpcbiAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VOdW1lcmljTGl0ZXJhbCh0aGlzLnN0YXRlLnZhbHVlKTtcbiAgICAgIGNhc2UgMTM2OlxuICAgICAgICByZXR1cm4gdGhpcy5wYXJzZUJpZ0ludExpdGVyYWwodGhpcy5zdGF0ZS52YWx1ZSk7XG4gICAgICBjYXNlIDEzNDpcbiAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VTdHJpbmdMaXRlcmFsKHRoaXMuc3RhdGUudmFsdWUpO1xuICAgICAgY2FzZSA4NDpcbiAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VOdWxsTGl0ZXJhbCgpO1xuICAgICAgY2FzZSA4NTpcbiAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VCb29sZWFuTGl0ZXJhbCh0cnVlKTtcbiAgICAgIGNhc2UgODY6XG4gICAgICAgIHJldHVybiB0aGlzLnBhcnNlQm9vbGVhbkxpdGVyYWwoZmFsc2UpO1xuICAgICAgY2FzZSAxMDpcbiAgICAgICAge1xuICAgICAgICAgIGNvbnN0IGNhbkJlQXJyb3cgPSB0aGlzLnN0YXRlLnBvdGVudGlhbEFycm93QXQgPT09IHRoaXMuc3RhdGUuc3RhcnQ7XG4gICAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VQYXJlbkFuZERpc3Rpbmd1aXNoRXhwcmVzc2lvbihjYW5CZUFycm93KTtcbiAgICAgICAgfVxuICAgICAgY2FzZSAwOlxuICAgICAgICB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VBcnJheUxpa2UoMywgZmFsc2UsIHJlZkV4cHJlc3Npb25FcnJvcnMpO1xuICAgICAgICB9XG4gICAgICBjYXNlIDU6XG4gICAgICAgIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5wYXJzZU9iamVjdExpa2UoOCwgZmFsc2UsIGZhbHNlLCByZWZFeHByZXNzaW9uRXJyb3JzKTtcbiAgICAgICAgfVxuICAgICAgY2FzZSA2ODpcbiAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VGdW5jdGlvbk9yRnVuY3Rpb25TZW50KCk7XG4gICAgICBjYXNlIDI2OlxuICAgICAgICBkZWNvcmF0b3JzID0gdGhpcy5wYXJzZURlY29yYXRvcnMoKTtcbiAgICAgIGNhc2UgODA6XG4gICAgICAgIHJldHVybiB0aGlzLnBhcnNlQ2xhc3ModGhpcy5tYXliZVRha2VEZWNvcmF0b3JzKGRlY29yYXRvcnMsIHRoaXMuc3RhcnROb2RlKCkpLCBmYWxzZSk7XG4gICAgICBjYXNlIDc3OlxuICAgICAgICByZXR1cm4gdGhpcy5wYXJzZU5ld09yTmV3VGFyZ2V0KCk7XG4gICAgICBjYXNlIDI1OlxuICAgICAgY2FzZSAyNDpcbiAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VUZW1wbGF0ZShmYWxzZSk7XG4gICAgICBjYXNlIDE1OlxuICAgICAgICB7XG4gICAgICAgICAgbm9kZSA9IHRoaXMuc3RhcnROb2RlKCk7XG4gICAgICAgICAgdGhpcy5uZXh0KCk7XG4gICAgICAgICAgbm9kZS5vYmplY3QgPSBudWxsO1xuICAgICAgICAgIGNvbnN0IGNhbGxlZSA9IG5vZGUuY2FsbGVlID0gdGhpcy5wYXJzZU5vQ2FsbEV4cHIoKTtcbiAgICAgICAgICBpZiAoY2FsbGVlLnR5cGUgPT09IFwiTWVtYmVyRXhwcmVzc2lvblwiKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiQmluZEV4cHJlc3Npb25cIik7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IHRoaXMucmFpc2UoRXJyb3JzLlVuc3VwcG9ydGVkQmluZCwgY2FsbGVlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIGNhc2UgMTM5OlxuICAgICAgICB7XG4gICAgICAgICAgdGhpcy5yYWlzZShFcnJvcnMuUHJpdmF0ZUluRXhwZWN0ZWRJbiwgdGhpcy5zdGF0ZS5zdGFydExvYywge1xuICAgICAgICAgICAgaWRlbnRpZmllck5hbWU6IHRoaXMuc3RhdGUudmFsdWVcbiAgICAgICAgICB9KTtcbiAgICAgICAgICByZXR1cm4gdGhpcy5wYXJzZVByaXZhdGVOYW1lKCk7XG4gICAgICAgIH1cbiAgICAgIGNhc2UgMzM6XG4gICAgICAgIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5wYXJzZVRvcGljUmVmZXJlbmNlVGhlbkVxdWFsc1NpZ24oNTQsIFwiJVwiKTtcbiAgICAgICAgfVxuICAgICAgY2FzZSAzMjpcbiAgICAgICAge1xuICAgICAgICAgIHJldHVybiB0aGlzLnBhcnNlVG9waWNSZWZlcmVuY2VUaGVuRXF1YWxzU2lnbig0NCwgXCJeXCIpO1xuICAgICAgICB9XG4gICAgICBjYXNlIDM3OlxuICAgICAgY2FzZSAzODpcbiAgICAgICAge1xuICAgICAgICAgIHJldHVybiB0aGlzLnBhcnNlVG9waWNSZWZlcmVuY2UoXCJoYWNrXCIpO1xuICAgICAgICB9XG4gICAgICBjYXNlIDQ0OlxuICAgICAgY2FzZSA1NDpcbiAgICAgIGNhc2UgMjc6XG4gICAgICAgIHtcbiAgICAgICAgICBjb25zdCBwaXBlUHJvcG9zYWwgPSB0aGlzLmdldFBsdWdpbk9wdGlvbihcInBpcGVsaW5lT3BlcmF0b3JcIiwgXCJwcm9wb3NhbFwiKTtcbiAgICAgICAgICBpZiAocGlwZVByb3Bvc2FsKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5wYXJzZVRvcGljUmVmZXJlbmNlKHBpcGVQcm9wb3NhbCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHRocm93IHRoaXMudW5leHBlY3RlZCgpO1xuICAgICAgICB9XG4gICAgICBjYXNlIDQ3OlxuICAgICAgICB7XG4gICAgICAgICAgY29uc3QgbG9va2FoZWFkQ2ggPSB0aGlzLmlucHV0LmNvZGVQb2ludEF0KHRoaXMubmV4dFRva2VuU3RhcnQoKSk7XG4gICAgICAgICAgaWYgKGlzSWRlbnRpZmllclN0YXJ0KGxvb2thaGVhZENoKSB8fCBsb29rYWhlYWRDaCA9PT0gNjIpIHtcbiAgICAgICAgICAgIHRocm93IHRoaXMuZXhwZWN0T25lUGx1Z2luKFtcImpzeFwiLCBcImZsb3dcIiwgXCJ0eXBlc2NyaXB0XCJdKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdGhyb3cgdGhpcy51bmV4cGVjdGVkKCk7XG4gICAgICAgIH1cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGlmICh0eXBlID09PSAxMzcpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5wYXJzZURlY2ltYWxMaXRlcmFsKHRoaXMuc3RhdGUudmFsdWUpO1xuICAgICAgICB9IGVsc2UgaWYgKHR5cGUgPT09IDIgfHwgdHlwZSA9PT0gMSkge1xuICAgICAgICAgIHJldHVybiB0aGlzLnBhcnNlQXJyYXlMaWtlKHRoaXMuc3RhdGUudHlwZSA9PT0gMiA/IDQgOiAzLCB0cnVlKTtcbiAgICAgICAgfSBlbHNlIGlmICh0eXBlID09PSA2IHx8IHR5cGUgPT09IDcpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5wYXJzZU9iamVjdExpa2UodGhpcy5zdGF0ZS50eXBlID09PSA2ID8gOSA6IDgsIGZhbHNlLCB0cnVlKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodG9rZW5Jc0lkZW50aWZpZXIodHlwZSkpIHtcbiAgICAgICAgICBpZiAodGhpcy5pc0NvbnRleHR1YWwoMTI3KSAmJiB0aGlzLmxvb2thaGVhZEluTGluZUNoYXJDb2RlKCkgPT09IDEyMykge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VNb2R1bGVFeHByZXNzaW9uKCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNvbnN0IGNhbkJlQXJyb3cgPSB0aGlzLnN0YXRlLnBvdGVudGlhbEFycm93QXQgPT09IHRoaXMuc3RhdGUuc3RhcnQ7XG4gICAgICAgICAgY29uc3QgY29udGFpbnNFc2MgPSB0aGlzLnN0YXRlLmNvbnRhaW5zRXNjO1xuICAgICAgICAgIGNvbnN0IGlkID0gdGhpcy5wYXJzZUlkZW50aWZpZXIoKTtcbiAgICAgICAgICBpZiAoIWNvbnRhaW5zRXNjICYmIGlkLm5hbWUgPT09IFwiYXN5bmNcIiAmJiAhdGhpcy5jYW5JbnNlcnRTZW1pY29sb24oKSkge1xuICAgICAgICAgICAgY29uc3Qge1xuICAgICAgICAgICAgICB0eXBlXG4gICAgICAgICAgICB9ID0gdGhpcy5zdGF0ZTtcbiAgICAgICAgICAgIGlmICh0eXBlID09PSA2OCkge1xuICAgICAgICAgICAgICB0aGlzLnJlc2V0UHJldmlvdXNOb2RlVHJhaWxpbmdDb21tZW50cyhpZCk7XG4gICAgICAgICAgICAgIHRoaXMubmV4dCgpO1xuICAgICAgICAgICAgICByZXR1cm4gdGhpcy5wYXJzZUFzeW5jRnVuY3Rpb25FeHByZXNzaW9uKHRoaXMuc3RhcnROb2RlQXROb2RlKGlkKSk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHRva2VuSXNJZGVudGlmaWVyKHR5cGUpKSB7XG4gICAgICAgICAgICAgIGlmICh0aGlzLmxvb2thaGVhZENoYXJDb2RlKCkgPT09IDYxKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VBc3luY0Fycm93VW5hcnlGdW5jdGlvbih0aGlzLnN0YXJ0Tm9kZUF0Tm9kZShpZCkpO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiBpZDtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIGlmICh0eXBlID09PSA5MCkge1xuICAgICAgICAgICAgICB0aGlzLnJlc2V0UHJldmlvdXNOb2RlVHJhaWxpbmdDb21tZW50cyhpZCk7XG4gICAgICAgICAgICAgIHJldHVybiB0aGlzLnBhcnNlRG8odGhpcy5zdGFydE5vZGVBdE5vZGUoaWQpLCB0cnVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGNhbkJlQXJyb3cgJiYgdGhpcy5tYXRjaCgxOSkgJiYgIXRoaXMuY2FuSW5zZXJ0U2VtaWNvbG9uKCkpIHtcbiAgICAgICAgICAgIHRoaXMubmV4dCgpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VBcnJvd0V4cHJlc3Npb24odGhpcy5zdGFydE5vZGVBdE5vZGUoaWQpLCBbaWRdLCBmYWxzZSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBpZDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aHJvdyB0aGlzLnVuZXhwZWN0ZWQoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgfVxuICBwYXJzZVRvcGljUmVmZXJlbmNlVGhlbkVxdWFsc1NpZ24odG9waWNUb2tlblR5cGUsIHRvcGljVG9rZW5WYWx1ZSkge1xuICAgIGNvbnN0IHBpcGVQcm9wb3NhbCA9IHRoaXMuZ2V0UGx1Z2luT3B0aW9uKFwicGlwZWxpbmVPcGVyYXRvclwiLCBcInByb3Bvc2FsXCIpO1xuICAgIGlmIChwaXBlUHJvcG9zYWwpIHtcbiAgICAgIHRoaXMuc3RhdGUudHlwZSA9IHRvcGljVG9rZW5UeXBlO1xuICAgICAgdGhpcy5zdGF0ZS52YWx1ZSA9IHRvcGljVG9rZW5WYWx1ZTtcbiAgICAgIHRoaXMuc3RhdGUucG9zLS07XG4gICAgICB0aGlzLnN0YXRlLmVuZC0tO1xuICAgICAgdGhpcy5zdGF0ZS5lbmRMb2MgPSBjcmVhdGVQb3NpdGlvbldpdGhDb2x1bW5PZmZzZXQodGhpcy5zdGF0ZS5lbmRMb2MsIC0xKTtcbiAgICAgIHJldHVybiB0aGlzLnBhcnNlVG9waWNSZWZlcmVuY2UocGlwZVByb3Bvc2FsKTtcbiAgICB9XG4gICAgdGhyb3cgdGhpcy51bmV4cGVjdGVkKCk7XG4gIH1cbiAgcGFyc2VUb3BpY1JlZmVyZW5jZShwaXBlUHJvcG9zYWwpIHtcbiAgICBjb25zdCBub2RlID0gdGhpcy5zdGFydE5vZGUoKTtcbiAgICBjb25zdCBzdGFydExvYyA9IHRoaXMuc3RhdGUuc3RhcnRMb2M7XG4gICAgY29uc3QgdG9rZW5UeXBlID0gdGhpcy5zdGF0ZS50eXBlO1xuICAgIHRoaXMubmV4dCgpO1xuICAgIHJldHVybiB0aGlzLmZpbmlzaFRvcGljUmVmZXJlbmNlKG5vZGUsIHN0YXJ0TG9jLCBwaXBlUHJvcG9zYWwsIHRva2VuVHlwZSk7XG4gIH1cbiAgZmluaXNoVG9waWNSZWZlcmVuY2Uobm9kZSwgc3RhcnRMb2MsIHBpcGVQcm9wb3NhbCwgdG9rZW5UeXBlKSB7XG4gICAgaWYgKHRoaXMudGVzdFRvcGljUmVmZXJlbmNlQ29uZmlndXJhdGlvbihwaXBlUHJvcG9zYWwsIHN0YXJ0TG9jLCB0b2tlblR5cGUpKSB7XG4gICAgICBpZiAocGlwZVByb3Bvc2FsID09PSBcImhhY2tcIikge1xuICAgICAgICBpZiAoIXRoaXMudG9waWNSZWZlcmVuY2VJc0FsbG93ZWRJbkN1cnJlbnRDb250ZXh0KCkpIHtcbiAgICAgICAgICB0aGlzLnJhaXNlKEVycm9ycy5QaXBlVG9waWNVbmJvdW5kLCBzdGFydExvYyk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5yZWdpc3RlclRvcGljUmVmZXJlbmNlKCk7XG4gICAgICAgIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJUb3BpY1JlZmVyZW5jZVwiKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmICghdGhpcy50b3BpY1JlZmVyZW5jZUlzQWxsb3dlZEluQ3VycmVudENvbnRleHQoKSkge1xuICAgICAgICAgIHRoaXMucmFpc2UoRXJyb3JzLlByaW1hcnlUb3BpY05vdEFsbG93ZWQsIHN0YXJ0TG9jKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnJlZ2lzdGVyVG9waWNSZWZlcmVuY2UoKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIlBpcGVsaW5lUHJpbWFyeVRvcGljUmVmZXJlbmNlXCIpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyB0aGlzLnJhaXNlKEVycm9ycy5QaXBlVG9waWNVbmNvbmZpZ3VyZWRUb2tlbiwgc3RhcnRMb2MsIHtcbiAgICAgICAgdG9rZW46IHRva2VuTGFiZWxOYW1lKHRva2VuVHlwZSlcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuICB0ZXN0VG9waWNSZWZlcmVuY2VDb25maWd1cmF0aW9uKHBpcGVQcm9wb3NhbCwgc3RhcnRMb2MsIHRva2VuVHlwZSkge1xuICAgIHN3aXRjaCAocGlwZVByb3Bvc2FsKSB7XG4gICAgICBjYXNlIFwiaGFja1wiOlxuICAgICAgICB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuaGFzUGx1Z2luKFtcInBpcGVsaW5lT3BlcmF0b3JcIiwge1xuICAgICAgICAgICAgdG9waWNUb2tlbjogdG9rZW5MYWJlbE5hbWUodG9rZW5UeXBlKVxuICAgICAgICAgIH1dKTtcbiAgICAgICAgfVxuICAgICAgY2FzZSBcInNtYXJ0XCI6XG4gICAgICAgIHJldHVybiB0b2tlblR5cGUgPT09IDI3O1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgdGhyb3cgdGhpcy5yYWlzZShFcnJvcnMuUGlwZVRvcGljUmVxdWlyZXNIYWNrUGlwZXMsIHN0YXJ0TG9jKTtcbiAgICB9XG4gIH1cbiAgcGFyc2VBc3luY0Fycm93VW5hcnlGdW5jdGlvbihub2RlKSB7XG4gICAgdGhpcy5wcm9kUGFyYW0uZW50ZXIoZnVuY3Rpb25GbGFncyh0cnVlLCB0aGlzLnByb2RQYXJhbS5oYXNZaWVsZCkpO1xuICAgIGNvbnN0IHBhcmFtcyA9IFt0aGlzLnBhcnNlSWRlbnRpZmllcigpXTtcbiAgICB0aGlzLnByb2RQYXJhbS5leGl0KCk7XG4gICAgaWYgKHRoaXMuaGFzUHJlY2VkaW5nTGluZUJyZWFrKCkpIHtcbiAgICAgIHRoaXMucmFpc2UoRXJyb3JzLkxpbmVUZXJtaW5hdG9yQmVmb3JlQXJyb3csIHRoaXMuc3RhdGUuY3VyUG9zaXRpb24oKSk7XG4gICAgfVxuICAgIHRoaXMuZXhwZWN0KDE5KTtcbiAgICByZXR1cm4gdGhpcy5wYXJzZUFycm93RXhwcmVzc2lvbihub2RlLCBwYXJhbXMsIHRydWUpO1xuICB9XG4gIHBhcnNlRG8obm9kZSwgaXNBc3luYykge1xuICAgIHRoaXMuZXhwZWN0UGx1Z2luKFwiZG9FeHByZXNzaW9uc1wiKTtcbiAgICBpZiAoaXNBc3luYykge1xuICAgICAgdGhpcy5leHBlY3RQbHVnaW4oXCJhc3luY0RvRXhwcmVzc2lvbnNcIik7XG4gICAgfVxuICAgIG5vZGUuYXN5bmMgPSBpc0FzeW5jO1xuICAgIHRoaXMubmV4dCgpO1xuICAgIGNvbnN0IG9sZExhYmVscyA9IHRoaXMuc3RhdGUubGFiZWxzO1xuICAgIHRoaXMuc3RhdGUubGFiZWxzID0gW107XG4gICAgaWYgKGlzQXN5bmMpIHtcbiAgICAgIHRoaXMucHJvZFBhcmFtLmVudGVyKDIpO1xuICAgICAgbm9kZS5ib2R5ID0gdGhpcy5wYXJzZUJsb2NrKCk7XG4gICAgICB0aGlzLnByb2RQYXJhbS5leGl0KCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIG5vZGUuYm9keSA9IHRoaXMucGFyc2VCbG9jaygpO1xuICAgIH1cbiAgICB0aGlzLnN0YXRlLmxhYmVscyA9IG9sZExhYmVscztcbiAgICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiRG9FeHByZXNzaW9uXCIpO1xuICB9XG4gIHBhcnNlU3VwZXIoKSB7XG4gICAgY29uc3Qgbm9kZSA9IHRoaXMuc3RhcnROb2RlKCk7XG4gICAgdGhpcy5uZXh0KCk7XG4gICAgaWYgKHRoaXMubWF0Y2goMTApICYmICF0aGlzLnNjb3BlLmFsbG93RGlyZWN0U3VwZXIpIHtcbiAgICAgIGlmICghKHRoaXMub3B0aW9uRmxhZ3MgJiAxNikpIHtcbiAgICAgICAgdGhpcy5yYWlzZShFcnJvcnMuU3VwZXJOb3RBbGxvd2VkLCBub2RlKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKCF0aGlzLnNjb3BlLmFsbG93U3VwZXIpIHtcbiAgICAgIGlmICghKHRoaXMub3B0aW9uRmxhZ3MgJiAxNikpIHtcbiAgICAgICAgdGhpcy5yYWlzZShFcnJvcnMuVW5leHBlY3RlZFN1cGVyLCBub2RlKTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKCF0aGlzLm1hdGNoKDEwKSAmJiAhdGhpcy5tYXRjaCgwKSAmJiAhdGhpcy5tYXRjaCgxNikpIHtcbiAgICAgIHRoaXMucmFpc2UoRXJyb3JzLlVuc3VwcG9ydGVkU3VwZXIsIG5vZGUpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiU3VwZXJcIik7XG4gIH1cbiAgcGFyc2VQcml2YXRlTmFtZSgpIHtcbiAgICBjb25zdCBub2RlID0gdGhpcy5zdGFydE5vZGUoKTtcbiAgICBjb25zdCBpZCA9IHRoaXMuc3RhcnROb2RlQXQoY3JlYXRlUG9zaXRpb25XaXRoQ29sdW1uT2Zmc2V0KHRoaXMuc3RhdGUuc3RhcnRMb2MsIDEpKTtcbiAgICBjb25zdCBuYW1lID0gdGhpcy5zdGF0ZS52YWx1ZTtcbiAgICB0aGlzLm5leHQoKTtcbiAgICBub2RlLmlkID0gdGhpcy5jcmVhdGVJZGVudGlmaWVyKGlkLCBuYW1lKTtcbiAgICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiUHJpdmF0ZU5hbWVcIik7XG4gIH1cbiAgcGFyc2VGdW5jdGlvbk9yRnVuY3Rpb25TZW50KCkge1xuICAgIGNvbnN0IG5vZGUgPSB0aGlzLnN0YXJ0Tm9kZSgpO1xuICAgIHRoaXMubmV4dCgpO1xuICAgIGlmICh0aGlzLnByb2RQYXJhbS5oYXNZaWVsZCAmJiB0aGlzLm1hdGNoKDE2KSkge1xuICAgICAgY29uc3QgbWV0YSA9IHRoaXMuY3JlYXRlSWRlbnRpZmllcih0aGlzLnN0YXJ0Tm9kZUF0Tm9kZShub2RlKSwgXCJmdW5jdGlvblwiKTtcbiAgICAgIHRoaXMubmV4dCgpO1xuICAgICAgaWYgKHRoaXMubWF0Y2goMTAzKSkge1xuICAgICAgICB0aGlzLmV4cGVjdFBsdWdpbihcImZ1bmN0aW9uU2VudFwiKTtcbiAgICAgIH0gZWxzZSBpZiAoIXRoaXMuaGFzUGx1Z2luKFwiZnVuY3Rpb25TZW50XCIpKSB7XG4gICAgICAgIHRoaXMudW5leHBlY3RlZCgpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXMucGFyc2VNZXRhUHJvcGVydHkobm9kZSwgbWV0YSwgXCJzZW50XCIpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5wYXJzZUZ1bmN0aW9uKG5vZGUpO1xuICB9XG4gIHBhcnNlTWV0YVByb3BlcnR5KG5vZGUsIG1ldGEsIHByb3BlcnR5TmFtZSkge1xuICAgIG5vZGUubWV0YSA9IG1ldGE7XG4gICAgY29uc3QgY29udGFpbnNFc2MgPSB0aGlzLnN0YXRlLmNvbnRhaW5zRXNjO1xuICAgIG5vZGUucHJvcGVydHkgPSB0aGlzLnBhcnNlSWRlbnRpZmllcih0cnVlKTtcbiAgICBpZiAobm9kZS5wcm9wZXJ0eS5uYW1lICE9PSBwcm9wZXJ0eU5hbWUgfHwgY29udGFpbnNFc2MpIHtcbiAgICAgIHRoaXMucmFpc2UoRXJyb3JzLlVuc3VwcG9ydGVkTWV0YVByb3BlcnR5LCBub2RlLnByb3BlcnR5LCB7XG4gICAgICAgIHRhcmdldDogbWV0YS5uYW1lLFxuICAgICAgICBvbmx5VmFsaWRQcm9wZXJ0eU5hbWU6IHByb3BlcnR5TmFtZVxuICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJNZXRhUHJvcGVydHlcIik7XG4gIH1cbiAgcGFyc2VJbXBvcnRNZXRhUHJvcGVydHlPclBoYXNlQ2FsbChub2RlKSB7XG4gICAgdGhpcy5uZXh0KCk7XG4gICAgaWYgKHRoaXMuaXNDb250ZXh0dWFsKDEwNSkgfHwgdGhpcy5pc0NvbnRleHR1YWwoOTcpKSB7XG4gICAgICBjb25zdCBpc1NvdXJjZSA9IHRoaXMuaXNDb250ZXh0dWFsKDEwNSk7XG4gICAgICB0aGlzLmV4cGVjdFBsdWdpbihpc1NvdXJjZSA/IFwic291cmNlUGhhc2VJbXBvcnRzXCIgOiBcImRlZmVycmVkSW1wb3J0RXZhbHVhdGlvblwiKTtcbiAgICAgIHRoaXMubmV4dCgpO1xuICAgICAgbm9kZS5waGFzZSA9IGlzU291cmNlID8gXCJzb3VyY2VcIiA6IFwiZGVmZXJcIjtcbiAgICAgIHJldHVybiB0aGlzLnBhcnNlSW1wb3J0Q2FsbChub2RlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgaWQgPSB0aGlzLmNyZWF0ZUlkZW50aWZpZXJBdCh0aGlzLnN0YXJ0Tm9kZUF0Tm9kZShub2RlKSwgXCJpbXBvcnRcIiwgdGhpcy5zdGF0ZS5sYXN0VG9rU3RhcnRMb2MpO1xuICAgICAgaWYgKHRoaXMuaXNDb250ZXh0dWFsKDEwMSkpIHtcbiAgICAgICAgaWYgKCF0aGlzLmluTW9kdWxlKSB7XG4gICAgICAgICAgdGhpcy5yYWlzZShFcnJvcnMuSW1wb3J0TWV0YU91dHNpZGVNb2R1bGUsIGlkKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnNhd1VuYW1iaWd1b3VzRVNNID0gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzLnBhcnNlTWV0YVByb3BlcnR5KG5vZGUsIGlkLCBcIm1ldGFcIik7XG4gICAgfVxuICB9XG4gIHBhcnNlTGl0ZXJhbEF0Tm9kZSh2YWx1ZSwgdHlwZSwgbm9kZSkge1xuICAgIHRoaXMuYWRkRXh0cmEobm9kZSwgXCJyYXdWYWx1ZVwiLCB2YWx1ZSk7XG4gICAgdGhpcy5hZGRFeHRyYShub2RlLCBcInJhd1wiLCB0aGlzLmlucHV0LnNsaWNlKHRoaXMub2Zmc2V0VG9Tb3VyY2VQb3Mobm9kZS5zdGFydCksIHRoaXMuc3RhdGUuZW5kKSk7XG4gICAgbm9kZS52YWx1ZSA9IHZhbHVlO1xuICAgIHRoaXMubmV4dCgpO1xuICAgIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgdHlwZSk7XG4gIH1cbiAgcGFyc2VMaXRlcmFsKHZhbHVlLCB0eXBlKSB7XG4gICAgY29uc3Qgbm9kZSA9IHRoaXMuc3RhcnROb2RlKCk7XG4gICAgcmV0dXJuIHRoaXMucGFyc2VMaXRlcmFsQXROb2RlKHZhbHVlLCB0eXBlLCBub2RlKTtcbiAgfVxuICBwYXJzZVN0cmluZ0xpdGVyYWwodmFsdWUpIHtcbiAgICByZXR1cm4gdGhpcy5wYXJzZUxpdGVyYWwodmFsdWUsIFwiU3RyaW5nTGl0ZXJhbFwiKTtcbiAgfVxuICBwYXJzZU51bWVyaWNMaXRlcmFsKHZhbHVlKSB7XG4gICAgcmV0dXJuIHRoaXMucGFyc2VMaXRlcmFsKHZhbHVlLCBcIk51bWVyaWNMaXRlcmFsXCIpO1xuICB9XG4gIHBhcnNlQmlnSW50TGl0ZXJhbCh2YWx1ZSkge1xuICAgIHJldHVybiB0aGlzLnBhcnNlTGl0ZXJhbCh2YWx1ZSwgXCJCaWdJbnRMaXRlcmFsXCIpO1xuICB9XG4gIHBhcnNlRGVjaW1hbExpdGVyYWwodmFsdWUpIHtcbiAgICByZXR1cm4gdGhpcy5wYXJzZUxpdGVyYWwodmFsdWUsIFwiRGVjaW1hbExpdGVyYWxcIik7XG4gIH1cbiAgcGFyc2VSZWdFeHBMaXRlcmFsKHZhbHVlKSB7XG4gICAgY29uc3Qgbm9kZSA9IHRoaXMuc3RhcnROb2RlKCk7XG4gICAgdGhpcy5hZGRFeHRyYShub2RlLCBcInJhd1wiLCB0aGlzLmlucHV0LnNsaWNlKHRoaXMub2Zmc2V0VG9Tb3VyY2VQb3Mobm9kZS5zdGFydCksIHRoaXMuc3RhdGUuZW5kKSk7XG4gICAgbm9kZS5wYXR0ZXJuID0gdmFsdWUucGF0dGVybjtcbiAgICBub2RlLmZsYWdzID0gdmFsdWUuZmxhZ3M7XG4gICAgdGhpcy5uZXh0KCk7XG4gICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIlJlZ0V4cExpdGVyYWxcIik7XG4gIH1cbiAgcGFyc2VCb29sZWFuTGl0ZXJhbCh2YWx1ZSkge1xuICAgIGNvbnN0IG5vZGUgPSB0aGlzLnN0YXJ0Tm9kZSgpO1xuICAgIG5vZGUudmFsdWUgPSB2YWx1ZTtcbiAgICB0aGlzLm5leHQoKTtcbiAgICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiQm9vbGVhbkxpdGVyYWxcIik7XG4gIH1cbiAgcGFyc2VOdWxsTGl0ZXJhbCgpIHtcbiAgICBjb25zdCBub2RlID0gdGhpcy5zdGFydE5vZGUoKTtcbiAgICB0aGlzLm5leHQoKTtcbiAgICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiTnVsbExpdGVyYWxcIik7XG4gIH1cbiAgcGFyc2VQYXJlbkFuZERpc3Rpbmd1aXNoRXhwcmVzc2lvbihjYW5CZUFycm93KSB7XG4gICAgY29uc3Qgc3RhcnRMb2MgPSB0aGlzLnN0YXRlLnN0YXJ0TG9jO1xuICAgIGxldCB2YWw7XG4gICAgdGhpcy5uZXh0KCk7XG4gICAgdGhpcy5leHByZXNzaW9uU2NvcGUuZW50ZXIobmV3QXJyb3dIZWFkU2NvcGUoKSk7XG4gICAgY29uc3Qgb2xkTWF5YmVJbkFycm93UGFyYW1ldGVycyA9IHRoaXMuc3RhdGUubWF5YmVJbkFycm93UGFyYW1ldGVycztcbiAgICBjb25zdCBvbGRJbkZTaGFycFBpcGVsaW5lRGlyZWN0Qm9keSA9IHRoaXMuc3RhdGUuaW5GU2hhcnBQaXBlbGluZURpcmVjdEJvZHk7XG4gICAgdGhpcy5zdGF0ZS5tYXliZUluQXJyb3dQYXJhbWV0ZXJzID0gdHJ1ZTtcbiAgICB0aGlzLnN0YXRlLmluRlNoYXJwUGlwZWxpbmVEaXJlY3RCb2R5ID0gZmFsc2U7XG4gICAgY29uc3QgaW5uZXJTdGFydExvYyA9IHRoaXMuc3RhdGUuc3RhcnRMb2M7XG4gICAgY29uc3QgZXhwckxpc3QgPSBbXTtcbiAgICBjb25zdCByZWZFeHByZXNzaW9uRXJyb3JzID0gbmV3IEV4cHJlc3Npb25FcnJvcnMoKTtcbiAgICBsZXQgZmlyc3QgPSB0cnVlO1xuICAgIGxldCBzcHJlYWRTdGFydExvYztcbiAgICBsZXQgb3B0aW9uYWxDb21tYVN0YXJ0TG9jO1xuICAgIHdoaWxlICghdGhpcy5tYXRjaCgxMSkpIHtcbiAgICAgIGlmIChmaXJzdCkge1xuICAgICAgICBmaXJzdCA9IGZhbHNlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5leHBlY3QoMTIsIHJlZkV4cHJlc3Npb25FcnJvcnMub3B0aW9uYWxQYXJhbWV0ZXJzTG9jID09PSBudWxsID8gbnVsbCA6IHJlZkV4cHJlc3Npb25FcnJvcnMub3B0aW9uYWxQYXJhbWV0ZXJzTG9jKTtcbiAgICAgICAgaWYgKHRoaXMubWF0Y2goMTEpKSB7XG4gICAgICAgICAgb3B0aW9uYWxDb21tYVN0YXJ0TG9jID0gdGhpcy5zdGF0ZS5zdGFydExvYztcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKHRoaXMubWF0Y2goMjEpKSB7XG4gICAgICAgIGNvbnN0IHNwcmVhZE5vZGVTdGFydExvYyA9IHRoaXMuc3RhdGUuc3RhcnRMb2M7XG4gICAgICAgIHNwcmVhZFN0YXJ0TG9jID0gdGhpcy5zdGF0ZS5zdGFydExvYztcbiAgICAgICAgZXhwckxpc3QucHVzaCh0aGlzLnBhcnNlUGFyZW5JdGVtKHRoaXMucGFyc2VSZXN0QmluZGluZygpLCBzcHJlYWROb2RlU3RhcnRMb2MpKTtcbiAgICAgICAgaWYgKCF0aGlzLmNoZWNrQ29tbWFBZnRlclJlc3QoNDEpKSB7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGV4cHJMaXN0LnB1c2godGhpcy5wYXJzZU1heWJlQXNzaWduQWxsb3dJbk9yVm9pZFBhdHRlcm4oMTEsIHJlZkV4cHJlc3Npb25FcnJvcnMsIHRoaXMucGFyc2VQYXJlbkl0ZW0pKTtcbiAgICAgIH1cbiAgICB9XG4gICAgY29uc3QgaW5uZXJFbmRMb2MgPSB0aGlzLnN0YXRlLmxhc3RUb2tFbmRMb2M7XG4gICAgdGhpcy5leHBlY3QoMTEpO1xuICAgIHRoaXMuc3RhdGUubWF5YmVJbkFycm93UGFyYW1ldGVycyA9IG9sZE1heWJlSW5BcnJvd1BhcmFtZXRlcnM7XG4gICAgdGhpcy5zdGF0ZS5pbkZTaGFycFBpcGVsaW5lRGlyZWN0Qm9keSA9IG9sZEluRlNoYXJwUGlwZWxpbmVEaXJlY3RCb2R5O1xuICAgIGxldCBhcnJvd05vZGUgPSB0aGlzLnN0YXJ0Tm9kZUF0KHN0YXJ0TG9jKTtcbiAgICBpZiAoY2FuQmVBcnJvdyAmJiB0aGlzLnNob3VsZFBhcnNlQXJyb3coZXhwckxpc3QpICYmIChhcnJvd05vZGUgPSB0aGlzLnBhcnNlQXJyb3coYXJyb3dOb2RlKSkpIHtcbiAgICAgIHRoaXMuY2hlY2tEZXN0cnVjdHVyaW5nUHJpdmF0ZShyZWZFeHByZXNzaW9uRXJyb3JzKTtcbiAgICAgIHRoaXMuZXhwcmVzc2lvblNjb3BlLnZhbGlkYXRlQXNQYXR0ZXJuKCk7XG4gICAgICB0aGlzLmV4cHJlc3Npb25TY29wZS5leGl0KCk7XG4gICAgICB0aGlzLnBhcnNlQXJyb3dFeHByZXNzaW9uKGFycm93Tm9kZSwgZXhwckxpc3QsIGZhbHNlKTtcbiAgICAgIHJldHVybiBhcnJvd05vZGU7XG4gICAgfVxuICAgIHRoaXMuZXhwcmVzc2lvblNjb3BlLmV4aXQoKTtcbiAgICBpZiAoIWV4cHJMaXN0Lmxlbmd0aCkge1xuICAgICAgdGhpcy51bmV4cGVjdGVkKHRoaXMuc3RhdGUubGFzdFRva1N0YXJ0TG9jKTtcbiAgICB9XG4gICAgaWYgKG9wdGlvbmFsQ29tbWFTdGFydExvYykgdGhpcy51bmV4cGVjdGVkKG9wdGlvbmFsQ29tbWFTdGFydExvYyk7XG4gICAgaWYgKHNwcmVhZFN0YXJ0TG9jKSB0aGlzLnVuZXhwZWN0ZWQoc3ByZWFkU3RhcnRMb2MpO1xuICAgIHRoaXMuY2hlY2tFeHByZXNzaW9uRXJyb3JzKHJlZkV4cHJlc3Npb25FcnJvcnMsIHRydWUpO1xuICAgIHRoaXMudG9SZWZlcmVuY2VkTGlzdERlZXAoZXhwckxpc3QsIHRydWUpO1xuICAgIGlmIChleHByTGlzdC5sZW5ndGggPiAxKSB7XG4gICAgICB2YWwgPSB0aGlzLnN0YXJ0Tm9kZUF0KGlubmVyU3RhcnRMb2MpO1xuICAgICAgdmFsLmV4cHJlc3Npb25zID0gZXhwckxpc3Q7XG4gICAgICB0aGlzLmZpbmlzaE5vZGUodmFsLCBcIlNlcXVlbmNlRXhwcmVzc2lvblwiKTtcbiAgICAgIHRoaXMucmVzZXRFbmRMb2NhdGlvbih2YWwsIGlubmVyRW5kTG9jKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFsID0gZXhwckxpc3RbMF07XG4gICAgfVxuICAgIHJldHVybiB0aGlzLndyYXBQYXJlbnRoZXNpcyhzdGFydExvYywgdmFsKTtcbiAgfVxuICB3cmFwUGFyZW50aGVzaXMoc3RhcnRMb2MsIGV4cHJlc3Npb24pIHtcbiAgICBpZiAoISh0aGlzLm9wdGlvbkZsYWdzICYgMTAyNCkpIHtcbiAgICAgIHRoaXMuYWRkRXh0cmEoZXhwcmVzc2lvbiwgXCJwYXJlbnRoZXNpemVkXCIsIHRydWUpO1xuICAgICAgdGhpcy5hZGRFeHRyYShleHByZXNzaW9uLCBcInBhcmVuU3RhcnRcIiwgc3RhcnRMb2MuaW5kZXgpO1xuICAgICAgdGhpcy50YWtlU3Vycm91bmRpbmdDb21tZW50cyhleHByZXNzaW9uLCBzdGFydExvYy5pbmRleCwgdGhpcy5zdGF0ZS5sYXN0VG9rRW5kTG9jLmluZGV4KTtcbiAgICAgIHJldHVybiBleHByZXNzaW9uO1xuICAgIH1cbiAgICBjb25zdCBwYXJlbkV4cHJlc3Npb24gPSB0aGlzLnN0YXJ0Tm9kZUF0KHN0YXJ0TG9jKTtcbiAgICBwYXJlbkV4cHJlc3Npb24uZXhwcmVzc2lvbiA9IGV4cHJlc3Npb247XG4gICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShwYXJlbkV4cHJlc3Npb24sIFwiUGFyZW50aGVzaXplZEV4cHJlc3Npb25cIik7XG4gIH1cbiAgc2hvdWxkUGFyc2VBcnJvdyhwYXJhbXMpIHtcbiAgICByZXR1cm4gIXRoaXMuY2FuSW5zZXJ0U2VtaWNvbG9uKCk7XG4gIH1cbiAgcGFyc2VBcnJvdyhub2RlKSB7XG4gICAgaWYgKHRoaXMuZWF0KDE5KSkge1xuICAgICAgcmV0dXJuIG5vZGU7XG4gICAgfVxuICB9XG4gIHBhcnNlUGFyZW5JdGVtKG5vZGUsIHN0YXJ0TG9jKSB7XG4gICAgcmV0dXJuIG5vZGU7XG4gIH1cbiAgcGFyc2VOZXdPck5ld1RhcmdldCgpIHtcbiAgICBjb25zdCBub2RlID0gdGhpcy5zdGFydE5vZGUoKTtcbiAgICB0aGlzLm5leHQoKTtcbiAgICBpZiAodGhpcy5tYXRjaCgxNikpIHtcbiAgICAgIGNvbnN0IG1ldGEgPSB0aGlzLmNyZWF0ZUlkZW50aWZpZXIodGhpcy5zdGFydE5vZGVBdE5vZGUobm9kZSksIFwibmV3XCIpO1xuICAgICAgdGhpcy5uZXh0KCk7XG4gICAgICBjb25zdCBtZXRhUHJvcCA9IHRoaXMucGFyc2VNZXRhUHJvcGVydHkobm9kZSwgbWV0YSwgXCJ0YXJnZXRcIik7XG4gICAgICBpZiAoIXRoaXMuc2NvcGUuYWxsb3dOZXdUYXJnZXQpIHtcbiAgICAgICAgdGhpcy5yYWlzZShFcnJvcnMuVW5leHBlY3RlZE5ld1RhcmdldCwgbWV0YVByb3ApO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG1ldGFQcm9wO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5wYXJzZU5ldyhub2RlKTtcbiAgfVxuICBwYXJzZU5ldyhub2RlKSB7XG4gICAgdGhpcy5wYXJzZU5ld0NhbGxlZShub2RlKTtcbiAgICBpZiAodGhpcy5lYXQoMTApKSB7XG4gICAgICBjb25zdCBhcmdzID0gdGhpcy5wYXJzZUV4cHJMaXN0KDExKTtcbiAgICAgIHRoaXMudG9SZWZlcmVuY2VkTGlzdChhcmdzKTtcbiAgICAgIG5vZGUuYXJndW1lbnRzID0gYXJncztcbiAgICB9IGVsc2Uge1xuICAgICAgbm9kZS5hcmd1bWVudHMgPSBbXTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIk5ld0V4cHJlc3Npb25cIik7XG4gIH1cbiAgcGFyc2VOZXdDYWxsZWUobm9kZSkge1xuICAgIGNvbnN0IGlzSW1wb3J0ID0gdGhpcy5tYXRjaCg4Myk7XG4gICAgY29uc3QgY2FsbGVlID0gdGhpcy5wYXJzZU5vQ2FsbEV4cHIoKTtcbiAgICBub2RlLmNhbGxlZSA9IGNhbGxlZTtcbiAgICBpZiAoaXNJbXBvcnQgJiYgKGNhbGxlZS50eXBlID09PSBcIkltcG9ydFwiIHx8IGNhbGxlZS50eXBlID09PSBcIkltcG9ydEV4cHJlc3Npb25cIikpIHtcbiAgICAgIHRoaXMucmFpc2UoRXJyb3JzLkltcG9ydENhbGxOb3ROZXdFeHByZXNzaW9uLCBjYWxsZWUpO1xuICAgIH1cbiAgfVxuICBwYXJzZVRlbXBsYXRlRWxlbWVudChpc1RhZ2dlZCkge1xuICAgIGNvbnN0IHtcbiAgICAgIHN0YXJ0LFxuICAgICAgc3RhcnRMb2MsXG4gICAgICBlbmQsXG4gICAgICB2YWx1ZVxuICAgIH0gPSB0aGlzLnN0YXRlO1xuICAgIGNvbnN0IGVsZW1TdGFydCA9IHN0YXJ0ICsgMTtcbiAgICBjb25zdCBlbGVtID0gdGhpcy5zdGFydE5vZGVBdChjcmVhdGVQb3NpdGlvbldpdGhDb2x1bW5PZmZzZXQoc3RhcnRMb2MsIDEpKTtcbiAgICBpZiAodmFsdWUgPT09IG51bGwpIHtcbiAgICAgIGlmICghaXNUYWdnZWQpIHtcbiAgICAgICAgdGhpcy5yYWlzZShFcnJvcnMuSW52YWxpZEVzY2FwZVNlcXVlbmNlVGVtcGxhdGUsIGNyZWF0ZVBvc2l0aW9uV2l0aENvbHVtbk9mZnNldCh0aGlzLnN0YXRlLmZpcnN0SW52YWxpZFRlbXBsYXRlRXNjYXBlUG9zLCAxKSk7XG4gICAgICB9XG4gICAgfVxuICAgIGNvbnN0IGlzVGFpbCA9IHRoaXMubWF0Y2goMjQpO1xuICAgIGNvbnN0IGVuZE9mZnNldCA9IGlzVGFpbCA/IC0xIDogLTI7XG4gICAgY29uc3QgZWxlbUVuZCA9IGVuZCArIGVuZE9mZnNldDtcbiAgICBlbGVtLnZhbHVlID0ge1xuICAgICAgcmF3OiB0aGlzLmlucHV0LnNsaWNlKGVsZW1TdGFydCwgZWxlbUVuZCkucmVwbGFjZSgvXFxyXFxuPy9nLCBcIlxcblwiKSxcbiAgICAgIGNvb2tlZDogdmFsdWUgPT09IG51bGwgPyBudWxsIDogdmFsdWUuc2xpY2UoMSwgZW5kT2Zmc2V0KVxuICAgIH07XG4gICAgZWxlbS50YWlsID0gaXNUYWlsO1xuICAgIHRoaXMubmV4dCgpO1xuICAgIGNvbnN0IGZpbmlzaGVkTm9kZSA9IHRoaXMuZmluaXNoTm9kZShlbGVtLCBcIlRlbXBsYXRlRWxlbWVudFwiKTtcbiAgICB0aGlzLnJlc2V0RW5kTG9jYXRpb24oZmluaXNoZWROb2RlLCBjcmVhdGVQb3NpdGlvbldpdGhDb2x1bW5PZmZzZXQodGhpcy5zdGF0ZS5sYXN0VG9rRW5kTG9jLCBlbmRPZmZzZXQpKTtcbiAgICByZXR1cm4gZmluaXNoZWROb2RlO1xuICB9XG4gIHBhcnNlVGVtcGxhdGUoaXNUYWdnZWQpIHtcbiAgICBjb25zdCBub2RlID0gdGhpcy5zdGFydE5vZGUoKTtcbiAgICBsZXQgY3VyRWx0ID0gdGhpcy5wYXJzZVRlbXBsYXRlRWxlbWVudChpc1RhZ2dlZCk7XG4gICAgY29uc3QgcXVhc2lzID0gW2N1ckVsdF07XG4gICAgY29uc3Qgc3Vic3RpdHV0aW9ucyA9IFtdO1xuICAgIHdoaWxlICghY3VyRWx0LnRhaWwpIHtcbiAgICAgIHN1YnN0aXR1dGlvbnMucHVzaCh0aGlzLnBhcnNlVGVtcGxhdGVTdWJzdGl0dXRpb24oKSk7XG4gICAgICB0aGlzLnJlYWRUZW1wbGF0ZUNvbnRpbnVhdGlvbigpO1xuICAgICAgcXVhc2lzLnB1c2goY3VyRWx0ID0gdGhpcy5wYXJzZVRlbXBsYXRlRWxlbWVudChpc1RhZ2dlZCkpO1xuICAgIH1cbiAgICBub2RlLmV4cHJlc3Npb25zID0gc3Vic3RpdHV0aW9ucztcbiAgICBub2RlLnF1YXNpcyA9IHF1YXNpcztcbiAgICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiVGVtcGxhdGVMaXRlcmFsXCIpO1xuICB9XG4gIHBhcnNlVGVtcGxhdGVTdWJzdGl0dXRpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMucGFyc2VFeHByZXNzaW9uKCk7XG4gIH1cbiAgcGFyc2VPYmplY3RMaWtlKGNsb3NlLCBpc1BhdHRlcm4sIGlzUmVjb3JkLCByZWZFeHByZXNzaW9uRXJyb3JzKSB7XG4gICAgaWYgKGlzUmVjb3JkKSB7XG4gICAgICB0aGlzLmV4cGVjdFBsdWdpbihcInJlY29yZEFuZFR1cGxlXCIpO1xuICAgIH1cbiAgICBjb25zdCBvbGRJbkZTaGFycFBpcGVsaW5lRGlyZWN0Qm9keSA9IHRoaXMuc3RhdGUuaW5GU2hhcnBQaXBlbGluZURpcmVjdEJvZHk7XG4gICAgdGhpcy5zdGF0ZS5pbkZTaGFycFBpcGVsaW5lRGlyZWN0Qm9keSA9IGZhbHNlO1xuICAgIGxldCBzYXdQcm90byA9IGZhbHNlO1xuICAgIGxldCBmaXJzdCA9IHRydWU7XG4gICAgY29uc3Qgbm9kZSA9IHRoaXMuc3RhcnROb2RlKCk7XG4gICAgbm9kZS5wcm9wZXJ0aWVzID0gW107XG4gICAgdGhpcy5uZXh0KCk7XG4gICAgd2hpbGUgKCF0aGlzLm1hdGNoKGNsb3NlKSkge1xuICAgICAgaWYgKGZpcnN0KSB7XG4gICAgICAgIGZpcnN0ID0gZmFsc2U7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmV4cGVjdCgxMik7XG4gICAgICAgIGlmICh0aGlzLm1hdGNoKGNsb3NlKSkge1xuICAgICAgICAgIHRoaXMuYWRkVHJhaWxpbmdDb21tYUV4dHJhVG9Ob2RlKG5vZGUpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBsZXQgcHJvcDtcbiAgICAgIGlmIChpc1BhdHRlcm4pIHtcbiAgICAgICAgcHJvcCA9IHRoaXMucGFyc2VCaW5kaW5nUHJvcGVydHkoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHByb3AgPSB0aGlzLnBhcnNlUHJvcGVydHlEZWZpbml0aW9uKHJlZkV4cHJlc3Npb25FcnJvcnMpO1xuICAgICAgICBzYXdQcm90byA9IHRoaXMuY2hlY2tQcm90byhwcm9wLCBpc1JlY29yZCwgc2F3UHJvdG8sIHJlZkV4cHJlc3Npb25FcnJvcnMpO1xuICAgICAgfVxuICAgICAgaWYgKGlzUmVjb3JkICYmICF0aGlzLmlzT2JqZWN0UHJvcGVydHkocHJvcCkgJiYgcHJvcC50eXBlICE9PSBcIlNwcmVhZEVsZW1lbnRcIikge1xuICAgICAgICB0aGlzLnJhaXNlKEVycm9ycy5JbnZhbGlkUmVjb3JkUHJvcGVydHksIHByb3ApO1xuICAgICAgfVxuICAgICAgaWYgKHByb3Auc2hvcnRoYW5kKSB7XG4gICAgICAgIHRoaXMuYWRkRXh0cmEocHJvcCwgXCJzaG9ydGhhbmRcIiwgdHJ1ZSk7XG4gICAgICB9XG4gICAgICBub2RlLnByb3BlcnRpZXMucHVzaChwcm9wKTtcbiAgICB9XG4gICAgdGhpcy5uZXh0KCk7XG4gICAgdGhpcy5zdGF0ZS5pbkZTaGFycFBpcGVsaW5lRGlyZWN0Qm9keSA9IG9sZEluRlNoYXJwUGlwZWxpbmVEaXJlY3RCb2R5O1xuICAgIGxldCB0eXBlID0gXCJPYmplY3RFeHByZXNzaW9uXCI7XG4gICAgaWYgKGlzUGF0dGVybikge1xuICAgICAgdHlwZSA9IFwiT2JqZWN0UGF0dGVyblwiO1xuICAgIH0gZWxzZSBpZiAoaXNSZWNvcmQpIHtcbiAgICAgIHR5cGUgPSBcIlJlY29yZEV4cHJlc3Npb25cIjtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCB0eXBlKTtcbiAgfVxuICBhZGRUcmFpbGluZ0NvbW1hRXh0cmFUb05vZGUobm9kZSkge1xuICAgIHRoaXMuYWRkRXh0cmEobm9kZSwgXCJ0cmFpbGluZ0NvbW1hXCIsIHRoaXMuc3RhdGUubGFzdFRva1N0YXJ0TG9jLmluZGV4KTtcbiAgICB0aGlzLmFkZEV4dHJhKG5vZGUsIFwidHJhaWxpbmdDb21tYUxvY1wiLCB0aGlzLnN0YXRlLmxhc3RUb2tTdGFydExvYywgZmFsc2UpO1xuICB9XG4gIG1heWJlQXN5bmNPckFjY2Vzc29yUHJvcChwcm9wKSB7XG4gICAgcmV0dXJuICFwcm9wLmNvbXB1dGVkICYmIHByb3Aua2V5LnR5cGUgPT09IFwiSWRlbnRpZmllclwiICYmICh0aGlzLmlzTGl0ZXJhbFByb3BlcnR5TmFtZSgpIHx8IHRoaXMubWF0Y2goMCkgfHwgdGhpcy5tYXRjaCg1NSkpO1xuICB9XG4gIHBhcnNlUHJvcGVydHlEZWZpbml0aW9uKHJlZkV4cHJlc3Npb25FcnJvcnMpIHtcbiAgICBsZXQgZGVjb3JhdG9ycyA9IFtdO1xuICAgIGlmICh0aGlzLm1hdGNoKDI2KSkge1xuICAgICAgaWYgKHRoaXMuaGFzUGx1Z2luKFwiZGVjb3JhdG9yc1wiKSkge1xuICAgICAgICB0aGlzLnJhaXNlKEVycm9ycy5VbnN1cHBvcnRlZFByb3BlcnR5RGVjb3JhdG9yLCB0aGlzLnN0YXRlLnN0YXJ0TG9jKTtcbiAgICAgIH1cbiAgICAgIHdoaWxlICh0aGlzLm1hdGNoKDI2KSkge1xuICAgICAgICBkZWNvcmF0b3JzLnB1c2godGhpcy5wYXJzZURlY29yYXRvcigpKTtcbiAgICAgIH1cbiAgICB9XG4gICAgY29uc3QgcHJvcCA9IHRoaXMuc3RhcnROb2RlKCk7XG4gICAgbGV0IGlzQXN5bmMgPSBmYWxzZTtcbiAgICBsZXQgaXNBY2Nlc3NvciA9IGZhbHNlO1xuICAgIGxldCBzdGFydExvYztcbiAgICBpZiAodGhpcy5tYXRjaCgyMSkpIHtcbiAgICAgIGlmIChkZWNvcmF0b3JzLmxlbmd0aCkgdGhpcy51bmV4cGVjdGVkKCk7XG4gICAgICByZXR1cm4gdGhpcy5wYXJzZVNwcmVhZCgpO1xuICAgIH1cbiAgICBpZiAoZGVjb3JhdG9ycy5sZW5ndGgpIHtcbiAgICAgIHByb3AuZGVjb3JhdG9ycyA9IGRlY29yYXRvcnM7XG4gICAgICBkZWNvcmF0b3JzID0gW107XG4gICAgfVxuICAgIHByb3AubWV0aG9kID0gZmFsc2U7XG4gICAgaWYgKHJlZkV4cHJlc3Npb25FcnJvcnMpIHtcbiAgICAgIHN0YXJ0TG9jID0gdGhpcy5zdGF0ZS5zdGFydExvYztcbiAgICB9XG4gICAgbGV0IGlzR2VuZXJhdG9yID0gdGhpcy5lYXQoNTUpO1xuICAgIHRoaXMucGFyc2VQcm9wZXJ0eU5hbWVQcmVmaXhPcGVyYXRvcihwcm9wKTtcbiAgICBjb25zdCBjb250YWluc0VzYyA9IHRoaXMuc3RhdGUuY29udGFpbnNFc2M7XG4gICAgdGhpcy5wYXJzZVByb3BlcnR5TmFtZShwcm9wLCByZWZFeHByZXNzaW9uRXJyb3JzKTtcbiAgICBpZiAoIWlzR2VuZXJhdG9yICYmICFjb250YWluc0VzYyAmJiB0aGlzLm1heWJlQXN5bmNPckFjY2Vzc29yUHJvcChwcm9wKSkge1xuICAgICAgY29uc3Qge1xuICAgICAgICBrZXlcbiAgICAgIH0gPSBwcm9wO1xuICAgICAgY29uc3Qga2V5TmFtZSA9IGtleS5uYW1lO1xuICAgICAgaWYgKGtleU5hbWUgPT09IFwiYXN5bmNcIiAmJiAhdGhpcy5oYXNQcmVjZWRpbmdMaW5lQnJlYWsoKSkge1xuICAgICAgICBpc0FzeW5jID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5yZXNldFByZXZpb3VzTm9kZVRyYWlsaW5nQ29tbWVudHMoa2V5KTtcbiAgICAgICAgaXNHZW5lcmF0b3IgPSB0aGlzLmVhdCg1NSk7XG4gICAgICAgIHRoaXMucGFyc2VQcm9wZXJ0eU5hbWUocHJvcCk7XG4gICAgICB9XG4gICAgICBpZiAoa2V5TmFtZSA9PT0gXCJnZXRcIiB8fCBrZXlOYW1lID09PSBcInNldFwiKSB7XG4gICAgICAgIGlzQWNjZXNzb3IgPSB0cnVlO1xuICAgICAgICB0aGlzLnJlc2V0UHJldmlvdXNOb2RlVHJhaWxpbmdDb21tZW50cyhrZXkpO1xuICAgICAgICBwcm9wLmtpbmQgPSBrZXlOYW1lO1xuICAgICAgICBpZiAodGhpcy5tYXRjaCg1NSkpIHtcbiAgICAgICAgICBpc0dlbmVyYXRvciA9IHRydWU7XG4gICAgICAgICAgdGhpcy5yYWlzZShFcnJvcnMuQWNjZXNzb3JJc0dlbmVyYXRvciwgdGhpcy5zdGF0ZS5jdXJQb3NpdGlvbigpLCB7XG4gICAgICAgICAgICBraW5kOiBrZXlOYW1lXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgdGhpcy5uZXh0KCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5wYXJzZVByb3BlcnR5TmFtZShwcm9wKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRoaXMucGFyc2VPYmpQcm9wVmFsdWUocHJvcCwgc3RhcnRMb2MsIGlzR2VuZXJhdG9yLCBpc0FzeW5jLCBmYWxzZSwgaXNBY2Nlc3NvciwgcmVmRXhwcmVzc2lvbkVycm9ycyk7XG4gIH1cbiAgZ2V0R2V0dGVyU2V0dGVyRXhwZWN0ZWRQYXJhbUNvdW50KG1ldGhvZCkge1xuICAgIHJldHVybiBtZXRob2Qua2luZCA9PT0gXCJnZXRcIiA/IDAgOiAxO1xuICB9XG4gIGdldE9iamVjdE9yQ2xhc3NNZXRob2RQYXJhbXMobWV0aG9kKSB7XG4gICAgcmV0dXJuIG1ldGhvZC5wYXJhbXM7XG4gIH1cbiAgY2hlY2tHZXR0ZXJTZXR0ZXJQYXJhbXMobWV0aG9kKSB7XG4gICAgdmFyIF9wYXJhbXM7XG4gICAgY29uc3QgcGFyYW1Db3VudCA9IHRoaXMuZ2V0R2V0dGVyU2V0dGVyRXhwZWN0ZWRQYXJhbUNvdW50KG1ldGhvZCk7XG4gICAgY29uc3QgcGFyYW1zID0gdGhpcy5nZXRPYmplY3RPckNsYXNzTWV0aG9kUGFyYW1zKG1ldGhvZCk7XG4gICAgaWYgKHBhcmFtcy5sZW5ndGggIT09IHBhcmFtQ291bnQpIHtcbiAgICAgIHRoaXMucmFpc2UobWV0aG9kLmtpbmQgPT09IFwiZ2V0XCIgPyBFcnJvcnMuQmFkR2V0dGVyQXJpdHkgOiBFcnJvcnMuQmFkU2V0dGVyQXJpdHksIG1ldGhvZCk7XG4gICAgfVxuICAgIGlmIChtZXRob2Qua2luZCA9PT0gXCJzZXRcIiAmJiAoKF9wYXJhbXMgPSBwYXJhbXNbcGFyYW1zLmxlbmd0aCAtIDFdKSA9PSBudWxsID8gdm9pZCAwIDogX3BhcmFtcy50eXBlKSA9PT0gXCJSZXN0RWxlbWVudFwiKSB7XG4gICAgICB0aGlzLnJhaXNlKEVycm9ycy5CYWRTZXR0ZXJSZXN0UGFyYW1ldGVyLCBtZXRob2QpO1xuICAgIH1cbiAgfVxuICBwYXJzZU9iamVjdE1ldGhvZChwcm9wLCBpc0dlbmVyYXRvciwgaXNBc3luYywgaXNQYXR0ZXJuLCBpc0FjY2Vzc29yKSB7XG4gICAgaWYgKGlzQWNjZXNzb3IpIHtcbiAgICAgIGNvbnN0IGZpbmlzaGVkUHJvcCA9IHRoaXMucGFyc2VNZXRob2QocHJvcCwgaXNHZW5lcmF0b3IsIGZhbHNlLCBmYWxzZSwgZmFsc2UsIFwiT2JqZWN0TWV0aG9kXCIpO1xuICAgICAgdGhpcy5jaGVja0dldHRlclNldHRlclBhcmFtcyhmaW5pc2hlZFByb3ApO1xuICAgICAgcmV0dXJuIGZpbmlzaGVkUHJvcDtcbiAgICB9XG4gICAgaWYgKGlzQXN5bmMgfHwgaXNHZW5lcmF0b3IgfHwgdGhpcy5tYXRjaCgxMCkpIHtcbiAgICAgIGlmIChpc1BhdHRlcm4pIHRoaXMudW5leHBlY3RlZCgpO1xuICAgICAgcHJvcC5raW5kID0gXCJtZXRob2RcIjtcbiAgICAgIHByb3AubWV0aG9kID0gdHJ1ZTtcbiAgICAgIHJldHVybiB0aGlzLnBhcnNlTWV0aG9kKHByb3AsIGlzR2VuZXJhdG9yLCBpc0FzeW5jLCBmYWxzZSwgZmFsc2UsIFwiT2JqZWN0TWV0aG9kXCIpO1xuICAgIH1cbiAgfVxuICBwYXJzZU9iamVjdFByb3BlcnR5KHByb3AsIHN0YXJ0TG9jLCBpc1BhdHRlcm4sIHJlZkV4cHJlc3Npb25FcnJvcnMpIHtcbiAgICBwcm9wLnNob3J0aGFuZCA9IGZhbHNlO1xuICAgIGlmICh0aGlzLmVhdCgxNCkpIHtcbiAgICAgIHByb3AudmFsdWUgPSBpc1BhdHRlcm4gPyB0aGlzLnBhcnNlTWF5YmVEZWZhdWx0KHRoaXMuc3RhdGUuc3RhcnRMb2MpIDogdGhpcy5wYXJzZU1heWJlQXNzaWduQWxsb3dJbk9yVm9pZFBhdHRlcm4oOCwgcmVmRXhwcmVzc2lvbkVycm9ycyk7XG4gICAgICByZXR1cm4gdGhpcy5maW5pc2hPYmplY3RQcm9wZXJ0eShwcm9wKTtcbiAgICB9XG4gICAgaWYgKCFwcm9wLmNvbXB1dGVkICYmIHByb3Aua2V5LnR5cGUgPT09IFwiSWRlbnRpZmllclwiKSB7XG4gICAgICB0aGlzLmNoZWNrUmVzZXJ2ZWRXb3JkKHByb3Aua2V5Lm5hbWUsIHByb3Aua2V5LmxvYy5zdGFydCwgdHJ1ZSwgZmFsc2UpO1xuICAgICAgaWYgKGlzUGF0dGVybikge1xuICAgICAgICBwcm9wLnZhbHVlID0gdGhpcy5wYXJzZU1heWJlRGVmYXVsdChzdGFydExvYywgdGhpcy5jbG9uZUlkZW50aWZpZXIocHJvcC5rZXkpKTtcbiAgICAgIH0gZWxzZSBpZiAodGhpcy5tYXRjaCgyOSkpIHtcbiAgICAgICAgY29uc3Qgc2hvcnRoYW5kQXNzaWduTG9jID0gdGhpcy5zdGF0ZS5zdGFydExvYztcbiAgICAgICAgaWYgKHJlZkV4cHJlc3Npb25FcnJvcnMgIT0gbnVsbCkge1xuICAgICAgICAgIGlmIChyZWZFeHByZXNzaW9uRXJyb3JzLnNob3J0aGFuZEFzc2lnbkxvYyA9PT0gbnVsbCkge1xuICAgICAgICAgICAgcmVmRXhwcmVzc2lvbkVycm9ycy5zaG9ydGhhbmRBc3NpZ25Mb2MgPSBzaG9ydGhhbmRBc3NpZ25Mb2M7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMucmFpc2UoRXJyb3JzLkludmFsaWRDb3ZlckluaXRpYWxpemVkTmFtZSwgc2hvcnRoYW5kQXNzaWduTG9jKTtcbiAgICAgICAgfVxuICAgICAgICBwcm9wLnZhbHVlID0gdGhpcy5wYXJzZU1heWJlRGVmYXVsdChzdGFydExvYywgdGhpcy5jbG9uZUlkZW50aWZpZXIocHJvcC5rZXkpKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHByb3AudmFsdWUgPSB0aGlzLmNsb25lSWRlbnRpZmllcihwcm9wLmtleSk7XG4gICAgICB9XG4gICAgICBwcm9wLnNob3J0aGFuZCA9IHRydWU7XG4gICAgICByZXR1cm4gdGhpcy5maW5pc2hPYmplY3RQcm9wZXJ0eShwcm9wKTtcbiAgICB9XG4gIH1cbiAgZmluaXNoT2JqZWN0UHJvcGVydHkobm9kZSkge1xuICAgIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJPYmplY3RQcm9wZXJ0eVwiKTtcbiAgfVxuICBwYXJzZU9ialByb3BWYWx1ZShwcm9wLCBzdGFydExvYywgaXNHZW5lcmF0b3IsIGlzQXN5bmMsIGlzUGF0dGVybiwgaXNBY2Nlc3NvciwgcmVmRXhwcmVzc2lvbkVycm9ycykge1xuICAgIGNvbnN0IG5vZGUgPSB0aGlzLnBhcnNlT2JqZWN0TWV0aG9kKHByb3AsIGlzR2VuZXJhdG9yLCBpc0FzeW5jLCBpc1BhdHRlcm4sIGlzQWNjZXNzb3IpIHx8IHRoaXMucGFyc2VPYmplY3RQcm9wZXJ0eShwcm9wLCBzdGFydExvYywgaXNQYXR0ZXJuLCByZWZFeHByZXNzaW9uRXJyb3JzKTtcbiAgICBpZiAoIW5vZGUpIHRoaXMudW5leHBlY3RlZCgpO1xuICAgIHJldHVybiBub2RlO1xuICB9XG4gIHBhcnNlUHJvcGVydHlOYW1lKHByb3AsIHJlZkV4cHJlc3Npb25FcnJvcnMpIHtcbiAgICBpZiAodGhpcy5lYXQoMCkpIHtcbiAgICAgIHByb3AuY29tcHV0ZWQgPSB0cnVlO1xuICAgICAgcHJvcC5rZXkgPSB0aGlzLnBhcnNlTWF5YmVBc3NpZ25BbGxvd0luKCk7XG4gICAgICB0aGlzLmV4cGVjdCgzKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3Qge1xuICAgICAgICB0eXBlLFxuICAgICAgICB2YWx1ZVxuICAgICAgfSA9IHRoaXMuc3RhdGU7XG4gICAgICBsZXQga2V5O1xuICAgICAgaWYgKHRva2VuSXNLZXl3b3JkT3JJZGVudGlmaWVyKHR5cGUpKSB7XG4gICAgICAgIGtleSA9IHRoaXMucGFyc2VJZGVudGlmaWVyKHRydWUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICAgICAgY2FzZSAxMzU6XG4gICAgICAgICAgICBrZXkgPSB0aGlzLnBhcnNlTnVtZXJpY0xpdGVyYWwodmFsdWUpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSAxMzQ6XG4gICAgICAgICAgICBrZXkgPSB0aGlzLnBhcnNlU3RyaW5nTGl0ZXJhbCh2YWx1ZSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIDEzNjpcbiAgICAgICAgICAgIGtleSA9IHRoaXMucGFyc2VCaWdJbnRMaXRlcmFsKHZhbHVlKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgMTM5OlxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICBjb25zdCBwcml2YXRlS2V5TG9jID0gdGhpcy5zdGF0ZS5zdGFydExvYztcbiAgICAgICAgICAgICAgaWYgKHJlZkV4cHJlc3Npb25FcnJvcnMgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGlmIChyZWZFeHByZXNzaW9uRXJyb3JzLnByaXZhdGVLZXlMb2MgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgIHJlZkV4cHJlc3Npb25FcnJvcnMucHJpdmF0ZUtleUxvYyA9IHByaXZhdGVLZXlMb2M7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMucmFpc2UoRXJyb3JzLlVuZXhwZWN0ZWRQcml2YXRlRmllbGQsIHByaXZhdGVLZXlMb2MpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGtleSA9IHRoaXMucGFyc2VQcml2YXRlTmFtZSgpO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgaWYgKHR5cGUgPT09IDEzNykge1xuICAgICAgICAgICAgICBrZXkgPSB0aGlzLnBhcnNlRGVjaW1hbExpdGVyYWwodmFsdWUpO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMudW5leHBlY3RlZCgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBwcm9wLmtleSA9IGtleTtcbiAgICAgIGlmICh0eXBlICE9PSAxMzkpIHtcbiAgICAgICAgcHJvcC5jb21wdXRlZCA9IGZhbHNlO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBpbml0RnVuY3Rpb24obm9kZSwgaXNBc3luYykge1xuICAgIG5vZGUuaWQgPSBudWxsO1xuICAgIG5vZGUuZ2VuZXJhdG9yID0gZmFsc2U7XG4gICAgbm9kZS5hc3luYyA9IGlzQXN5bmM7XG4gIH1cbiAgcGFyc2VNZXRob2Qobm9kZSwgaXNHZW5lcmF0b3IsIGlzQXN5bmMsIGlzQ29uc3RydWN0b3IsIGFsbG93RGlyZWN0U3VwZXIsIHR5cGUsIGluQ2xhc3NTY29wZSA9IGZhbHNlKSB7XG4gICAgdGhpcy5pbml0RnVuY3Rpb24obm9kZSwgaXNBc3luYyk7XG4gICAgbm9kZS5nZW5lcmF0b3IgPSBpc0dlbmVyYXRvcjtcbiAgICB0aGlzLnNjb3BlLmVudGVyKDUxNCB8IDE2IHwgKGluQ2xhc3NTY29wZSA/IDU3NiA6IDApIHwgKGFsbG93RGlyZWN0U3VwZXIgPyAzMiA6IDApKTtcbiAgICB0aGlzLnByb2RQYXJhbS5lbnRlcihmdW5jdGlvbkZsYWdzKGlzQXN5bmMsIG5vZGUuZ2VuZXJhdG9yKSk7XG4gICAgdGhpcy5wYXJzZUZ1bmN0aW9uUGFyYW1zKG5vZGUsIGlzQ29uc3RydWN0b3IpO1xuICAgIGNvbnN0IGZpbmlzaGVkTm9kZSA9IHRoaXMucGFyc2VGdW5jdGlvbkJvZHlBbmRGaW5pc2gobm9kZSwgdHlwZSwgdHJ1ZSk7XG4gICAgdGhpcy5wcm9kUGFyYW0uZXhpdCgpO1xuICAgIHRoaXMuc2NvcGUuZXhpdCgpO1xuICAgIHJldHVybiBmaW5pc2hlZE5vZGU7XG4gIH1cbiAgcGFyc2VBcnJheUxpa2UoY2xvc2UsIGlzVHVwbGUsIHJlZkV4cHJlc3Npb25FcnJvcnMpIHtcbiAgICBpZiAoaXNUdXBsZSkge1xuICAgICAgdGhpcy5leHBlY3RQbHVnaW4oXCJyZWNvcmRBbmRUdXBsZVwiKTtcbiAgICB9XG4gICAgY29uc3Qgb2xkSW5GU2hhcnBQaXBlbGluZURpcmVjdEJvZHkgPSB0aGlzLnN0YXRlLmluRlNoYXJwUGlwZWxpbmVEaXJlY3RCb2R5O1xuICAgIHRoaXMuc3RhdGUuaW5GU2hhcnBQaXBlbGluZURpcmVjdEJvZHkgPSBmYWxzZTtcbiAgICBjb25zdCBub2RlID0gdGhpcy5zdGFydE5vZGUoKTtcbiAgICB0aGlzLm5leHQoKTtcbiAgICBub2RlLmVsZW1lbnRzID0gdGhpcy5wYXJzZUV4cHJMaXN0KGNsb3NlLCAhaXNUdXBsZSwgcmVmRXhwcmVzc2lvbkVycm9ycywgbm9kZSk7XG4gICAgdGhpcy5zdGF0ZS5pbkZTaGFycFBpcGVsaW5lRGlyZWN0Qm9keSA9IG9sZEluRlNoYXJwUGlwZWxpbmVEaXJlY3RCb2R5O1xuICAgIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgaXNUdXBsZSA/IFwiVHVwbGVFeHByZXNzaW9uXCIgOiBcIkFycmF5RXhwcmVzc2lvblwiKTtcbiAgfVxuICBwYXJzZUFycm93RXhwcmVzc2lvbihub2RlLCBwYXJhbXMsIGlzQXN5bmMsIHRyYWlsaW5nQ29tbWFMb2MpIHtcbiAgICB0aGlzLnNjb3BlLmVudGVyKDUxNCB8IDQpO1xuICAgIGxldCBmbGFncyA9IGZ1bmN0aW9uRmxhZ3MoaXNBc3luYywgZmFsc2UpO1xuICAgIGlmICghdGhpcy5tYXRjaCg1KSAmJiB0aGlzLnByb2RQYXJhbS5oYXNJbikge1xuICAgICAgZmxhZ3MgfD0gODtcbiAgICB9XG4gICAgdGhpcy5wcm9kUGFyYW0uZW50ZXIoZmxhZ3MpO1xuICAgIHRoaXMuaW5pdEZ1bmN0aW9uKG5vZGUsIGlzQXN5bmMpO1xuICAgIGNvbnN0IG9sZE1heWJlSW5BcnJvd1BhcmFtZXRlcnMgPSB0aGlzLnN0YXRlLm1heWJlSW5BcnJvd1BhcmFtZXRlcnM7XG4gICAgaWYgKHBhcmFtcykge1xuICAgICAgdGhpcy5zdGF0ZS5tYXliZUluQXJyb3dQYXJhbWV0ZXJzID0gdHJ1ZTtcbiAgICAgIHRoaXMuc2V0QXJyb3dGdW5jdGlvblBhcmFtZXRlcnMobm9kZSwgcGFyYW1zLCB0cmFpbGluZ0NvbW1hTG9jKTtcbiAgICB9XG4gICAgdGhpcy5zdGF0ZS5tYXliZUluQXJyb3dQYXJhbWV0ZXJzID0gZmFsc2U7XG4gICAgdGhpcy5wYXJzZUZ1bmN0aW9uQm9keShub2RlLCB0cnVlKTtcbiAgICB0aGlzLnByb2RQYXJhbS5leGl0KCk7XG4gICAgdGhpcy5zY29wZS5leGl0KCk7XG4gICAgdGhpcy5zdGF0ZS5tYXliZUluQXJyb3dQYXJhbWV0ZXJzID0gb2xkTWF5YmVJbkFycm93UGFyYW1ldGVycztcbiAgICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiQXJyb3dGdW5jdGlvbkV4cHJlc3Npb25cIik7XG4gIH1cbiAgc2V0QXJyb3dGdW5jdGlvblBhcmFtZXRlcnMobm9kZSwgcGFyYW1zLCB0cmFpbGluZ0NvbW1hTG9jKSB7XG4gICAgdGhpcy50b0Fzc2lnbmFibGVMaXN0KHBhcmFtcywgdHJhaWxpbmdDb21tYUxvYywgZmFsc2UpO1xuICAgIG5vZGUucGFyYW1zID0gcGFyYW1zO1xuICB9XG4gIHBhcnNlRnVuY3Rpb25Cb2R5QW5kRmluaXNoKG5vZGUsIHR5cGUsIGlzTWV0aG9kID0gZmFsc2UpIHtcbiAgICB0aGlzLnBhcnNlRnVuY3Rpb25Cb2R5KG5vZGUsIGZhbHNlLCBpc01ldGhvZCk7XG4gICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCB0eXBlKTtcbiAgfVxuICBwYXJzZUZ1bmN0aW9uQm9keShub2RlLCBhbGxvd0V4cHJlc3Npb24sIGlzTWV0aG9kID0gZmFsc2UpIHtcbiAgICBjb25zdCBpc0V4cHJlc3Npb24gPSBhbGxvd0V4cHJlc3Npb24gJiYgIXRoaXMubWF0Y2goNSk7XG4gICAgdGhpcy5leHByZXNzaW9uU2NvcGUuZW50ZXIobmV3RXhwcmVzc2lvblNjb3BlKCkpO1xuICAgIGlmIChpc0V4cHJlc3Npb24pIHtcbiAgICAgIG5vZGUuYm9keSA9IHRoaXMucGFyc2VNYXliZUFzc2lnbigpO1xuICAgICAgdGhpcy5jaGVja1BhcmFtcyhub2RlLCBmYWxzZSwgYWxsb3dFeHByZXNzaW9uLCBmYWxzZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IG9sZFN0cmljdCA9IHRoaXMuc3RhdGUuc3RyaWN0O1xuICAgICAgY29uc3Qgb2xkTGFiZWxzID0gdGhpcy5zdGF0ZS5sYWJlbHM7XG4gICAgICB0aGlzLnN0YXRlLmxhYmVscyA9IFtdO1xuICAgICAgdGhpcy5wcm9kUGFyYW0uZW50ZXIodGhpcy5wcm9kUGFyYW0uY3VycmVudEZsYWdzKCkgfCA0KTtcbiAgICAgIG5vZGUuYm9keSA9IHRoaXMucGFyc2VCbG9jayh0cnVlLCBmYWxzZSwgaGFzU3RyaWN0TW9kZURpcmVjdGl2ZSA9PiB7XG4gICAgICAgIGNvbnN0IG5vblNpbXBsZSA9ICF0aGlzLmlzU2ltcGxlUGFyYW1MaXN0KG5vZGUucGFyYW1zKTtcbiAgICAgICAgaWYgKGhhc1N0cmljdE1vZGVEaXJlY3RpdmUgJiYgbm9uU2ltcGxlKSB7XG4gICAgICAgICAgdGhpcy5yYWlzZShFcnJvcnMuSWxsZWdhbExhbmd1YWdlTW9kZURpcmVjdGl2ZSwgKG5vZGUua2luZCA9PT0gXCJtZXRob2RcIiB8fCBub2RlLmtpbmQgPT09IFwiY29uc3RydWN0b3JcIikgJiYgISFub2RlLmtleSA/IG5vZGUua2V5LmxvYy5lbmQgOiBub2RlKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBzdHJpY3RNb2RlQ2hhbmdlZCA9ICFvbGRTdHJpY3QgJiYgdGhpcy5zdGF0ZS5zdHJpY3Q7XG4gICAgICAgIHRoaXMuY2hlY2tQYXJhbXMobm9kZSwgIXRoaXMuc3RhdGUuc3RyaWN0ICYmICFhbGxvd0V4cHJlc3Npb24gJiYgIWlzTWV0aG9kICYmICFub25TaW1wbGUsIGFsbG93RXhwcmVzc2lvbiwgc3RyaWN0TW9kZUNoYW5nZWQpO1xuICAgICAgICBpZiAodGhpcy5zdGF0ZS5zdHJpY3QgJiYgbm9kZS5pZCkge1xuICAgICAgICAgIHRoaXMuY2hlY2tJZGVudGlmaWVyKG5vZGUuaWQsIDY1LCBzdHJpY3RNb2RlQ2hhbmdlZCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgdGhpcy5wcm9kUGFyYW0uZXhpdCgpO1xuICAgICAgdGhpcy5zdGF0ZS5sYWJlbHMgPSBvbGRMYWJlbHM7XG4gICAgfVxuICAgIHRoaXMuZXhwcmVzc2lvblNjb3BlLmV4aXQoKTtcbiAgfVxuICBpc1NpbXBsZVBhcmFtZXRlcihub2RlKSB7XG4gICAgcmV0dXJuIG5vZGUudHlwZSA9PT0gXCJJZGVudGlmaWVyXCI7XG4gIH1cbiAgaXNTaW1wbGVQYXJhbUxpc3QocGFyYW1zKSB7XG4gICAgZm9yIChsZXQgaSA9IDAsIGxlbiA9IHBhcmFtcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgaWYgKCF0aGlzLmlzU2ltcGxlUGFyYW1ldGVyKHBhcmFtc1tpXSkpIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgY2hlY2tQYXJhbXMobm9kZSwgYWxsb3dEdXBsaWNhdGVzLCBpc0Fycm93RnVuY3Rpb24sIHN0cmljdE1vZGVDaGFuZ2VkID0gdHJ1ZSkge1xuICAgIGNvbnN0IGNoZWNrQ2xhc2hlcyA9ICFhbGxvd0R1cGxpY2F0ZXMgJiYgbmV3IFNldCgpO1xuICAgIGNvbnN0IGZvcm1hbFBhcmFtZXRlcnMgPSB7XG4gICAgICB0eXBlOiBcIkZvcm1hbFBhcmFtZXRlcnNcIlxuICAgIH07XG4gICAgZm9yIChjb25zdCBwYXJhbSBvZiBub2RlLnBhcmFtcykge1xuICAgICAgdGhpcy5jaGVja0xWYWwocGFyYW0sIGZvcm1hbFBhcmFtZXRlcnMsIDUsIGNoZWNrQ2xhc2hlcywgc3RyaWN0TW9kZUNoYW5nZWQpO1xuICAgIH1cbiAgfVxuICBwYXJzZUV4cHJMaXN0KGNsb3NlLCBhbGxvd0VtcHR5LCByZWZFeHByZXNzaW9uRXJyb3JzLCBub2RlRm9yRXh0cmEpIHtcbiAgICBjb25zdCBlbHRzID0gW107XG4gICAgbGV0IGZpcnN0ID0gdHJ1ZTtcbiAgICB3aGlsZSAoIXRoaXMuZWF0KGNsb3NlKSkge1xuICAgICAgaWYgKGZpcnN0KSB7XG4gICAgICAgIGZpcnN0ID0gZmFsc2U7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmV4cGVjdCgxMik7XG4gICAgICAgIGlmICh0aGlzLm1hdGNoKGNsb3NlKSkge1xuICAgICAgICAgIGlmIChub2RlRm9yRXh0cmEpIHtcbiAgICAgICAgICAgIHRoaXMuYWRkVHJhaWxpbmdDb21tYUV4dHJhVG9Ob2RlKG5vZGVGb3JFeHRyYSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHRoaXMubmV4dCgpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBlbHRzLnB1c2godGhpcy5wYXJzZUV4cHJMaXN0SXRlbShjbG9zZSwgYWxsb3dFbXB0eSwgcmVmRXhwcmVzc2lvbkVycm9ycykpO1xuICAgIH1cbiAgICByZXR1cm4gZWx0cztcbiAgfVxuICBwYXJzZUV4cHJMaXN0SXRlbShjbG9zZSwgYWxsb3dFbXB0eSwgcmVmRXhwcmVzc2lvbkVycm9ycywgYWxsb3dQbGFjZWhvbGRlcikge1xuICAgIGxldCBlbHQ7XG4gICAgaWYgKHRoaXMubWF0Y2goMTIpKSB7XG4gICAgICBpZiAoIWFsbG93RW1wdHkpIHtcbiAgICAgICAgdGhpcy5yYWlzZShFcnJvcnMuVW5leHBlY3RlZFRva2VuLCB0aGlzLnN0YXRlLmN1clBvc2l0aW9uKCksIHtcbiAgICAgICAgICB1bmV4cGVjdGVkOiBcIixcIlxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIGVsdCA9IG51bGw7XG4gICAgfSBlbHNlIGlmICh0aGlzLm1hdGNoKDIxKSkge1xuICAgICAgY29uc3Qgc3ByZWFkTm9kZVN0YXJ0TG9jID0gdGhpcy5zdGF0ZS5zdGFydExvYztcbiAgICAgIGVsdCA9IHRoaXMucGFyc2VQYXJlbkl0ZW0odGhpcy5wYXJzZVNwcmVhZChyZWZFeHByZXNzaW9uRXJyb3JzKSwgc3ByZWFkTm9kZVN0YXJ0TG9jKTtcbiAgICB9IGVsc2UgaWYgKHRoaXMubWF0Y2goMTcpKSB7XG4gICAgICB0aGlzLmV4cGVjdFBsdWdpbihcInBhcnRpYWxBcHBsaWNhdGlvblwiKTtcbiAgICAgIGlmICghYWxsb3dQbGFjZWhvbGRlcikge1xuICAgICAgICB0aGlzLnJhaXNlKEVycm9ycy5VbmV4cGVjdGVkQXJndW1lbnRQbGFjZWhvbGRlciwgdGhpcy5zdGF0ZS5zdGFydExvYyk7XG4gICAgICB9XG4gICAgICBjb25zdCBub2RlID0gdGhpcy5zdGFydE5vZGUoKTtcbiAgICAgIHRoaXMubmV4dCgpO1xuICAgICAgZWx0ID0gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiQXJndW1lbnRQbGFjZWhvbGRlclwiKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZWx0ID0gdGhpcy5wYXJzZU1heWJlQXNzaWduQWxsb3dJbk9yVm9pZFBhdHRlcm4oY2xvc2UsIHJlZkV4cHJlc3Npb25FcnJvcnMsIHRoaXMucGFyc2VQYXJlbkl0ZW0pO1xuICAgIH1cbiAgICByZXR1cm4gZWx0O1xuICB9XG4gIHBhcnNlSWRlbnRpZmllcihsaWJlcmFsKSB7XG4gICAgY29uc3Qgbm9kZSA9IHRoaXMuc3RhcnROb2RlKCk7XG4gICAgY29uc3QgbmFtZSA9IHRoaXMucGFyc2VJZGVudGlmaWVyTmFtZShsaWJlcmFsKTtcbiAgICByZXR1cm4gdGhpcy5jcmVhdGVJZGVudGlmaWVyKG5vZGUsIG5hbWUpO1xuICB9XG4gIGNyZWF0ZUlkZW50aWZpZXIobm9kZSwgbmFtZSkge1xuICAgIG5vZGUubmFtZSA9IG5hbWU7XG4gICAgbm9kZS5sb2MuaWRlbnRpZmllck5hbWUgPSBuYW1lO1xuICAgIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJJZGVudGlmaWVyXCIpO1xuICB9XG4gIGNyZWF0ZUlkZW50aWZpZXJBdChub2RlLCBuYW1lLCBlbmRMb2MpIHtcbiAgICBub2RlLm5hbWUgPSBuYW1lO1xuICAgIG5vZGUubG9jLmlkZW50aWZpZXJOYW1lID0gbmFtZTtcbiAgICByZXR1cm4gdGhpcy5maW5pc2hOb2RlQXQobm9kZSwgXCJJZGVudGlmaWVyXCIsIGVuZExvYyk7XG4gIH1cbiAgcGFyc2VJZGVudGlmaWVyTmFtZShsaWJlcmFsKSB7XG4gICAgbGV0IG5hbWU7XG4gICAgY29uc3Qge1xuICAgICAgc3RhcnRMb2MsXG4gICAgICB0eXBlXG4gICAgfSA9IHRoaXMuc3RhdGU7XG4gICAgaWYgKHRva2VuSXNLZXl3b3JkT3JJZGVudGlmaWVyKHR5cGUpKSB7XG4gICAgICBuYW1lID0gdGhpcy5zdGF0ZS52YWx1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy51bmV4cGVjdGVkKCk7XG4gICAgfVxuICAgIGNvbnN0IHRva2VuSXNLZXl3b3JkID0gdG9rZW5LZXl3b3JkT3JJZGVudGlmaWVySXNLZXl3b3JkKHR5cGUpO1xuICAgIGlmIChsaWJlcmFsKSB7XG4gICAgICBpZiAodG9rZW5Jc0tleXdvcmQpIHtcbiAgICAgICAgdGhpcy5yZXBsYWNlVG9rZW4oMTMyKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5jaGVja1Jlc2VydmVkV29yZChuYW1lLCBzdGFydExvYywgdG9rZW5Jc0tleXdvcmQsIGZhbHNlKTtcbiAgICB9XG4gICAgdGhpcy5uZXh0KCk7XG4gICAgcmV0dXJuIG5hbWU7XG4gIH1cbiAgY2hlY2tSZXNlcnZlZFdvcmQod29yZCwgc3RhcnRMb2MsIGNoZWNrS2V5d29yZHMsIGlzQmluZGluZykge1xuICAgIGlmICh3b3JkLmxlbmd0aCA+IDEwKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICghY2FuQmVSZXNlcnZlZFdvcmQod29yZCkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKGNoZWNrS2V5d29yZHMgJiYgaXNLZXl3b3JkKHdvcmQpKSB7XG4gICAgICB0aGlzLnJhaXNlKEVycm9ycy5VbmV4cGVjdGVkS2V5d29yZCwgc3RhcnRMb2MsIHtcbiAgICAgICAga2V5d29yZDogd29yZFxuICAgICAgfSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHJlc2VydmVkVGVzdCA9ICF0aGlzLnN0YXRlLnN0cmljdCA/IGlzUmVzZXJ2ZWRXb3JkIDogaXNCaW5kaW5nID8gaXNTdHJpY3RCaW5kUmVzZXJ2ZWRXb3JkIDogaXNTdHJpY3RSZXNlcnZlZFdvcmQ7XG4gICAgaWYgKHJlc2VydmVkVGVzdCh3b3JkLCB0aGlzLmluTW9kdWxlKSkge1xuICAgICAgdGhpcy5yYWlzZShFcnJvcnMuVW5leHBlY3RlZFJlc2VydmVkV29yZCwgc3RhcnRMb2MsIHtcbiAgICAgICAgcmVzZXJ2ZWRXb3JkOiB3b3JkXG4gICAgICB9KTtcbiAgICAgIHJldHVybjtcbiAgICB9IGVsc2UgaWYgKHdvcmQgPT09IFwieWllbGRcIikge1xuICAgICAgaWYgKHRoaXMucHJvZFBhcmFtLmhhc1lpZWxkKSB7XG4gICAgICAgIHRoaXMucmFpc2UoRXJyb3JzLllpZWxkQmluZGluZ0lkZW50aWZpZXIsIHN0YXJ0TG9jKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAod29yZCA9PT0gXCJhd2FpdFwiKSB7XG4gICAgICBpZiAodGhpcy5wcm9kUGFyYW0uaGFzQXdhaXQpIHtcbiAgICAgICAgdGhpcy5yYWlzZShFcnJvcnMuQXdhaXRCaW5kaW5nSWRlbnRpZmllciwgc3RhcnRMb2MpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5zY29wZS5pblN0YXRpY0Jsb2NrKSB7XG4gICAgICAgIHRoaXMucmFpc2UoRXJyb3JzLkF3YWl0QmluZGluZ0lkZW50aWZpZXJJblN0YXRpY0Jsb2NrLCBzdGFydExvYyk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHRoaXMuZXhwcmVzc2lvblNjb3BlLnJlY29yZEFzeW5jQXJyb3dQYXJhbWV0ZXJzRXJyb3Ioc3RhcnRMb2MpO1xuICAgIH0gZWxzZSBpZiAod29yZCA9PT0gXCJhcmd1bWVudHNcIikge1xuICAgICAgaWYgKHRoaXMuc2NvcGUuaW5DbGFzc0FuZE5vdEluTm9uQXJyb3dGdW5jdGlvbikge1xuICAgICAgICB0aGlzLnJhaXNlKEVycm9ycy5Bcmd1bWVudHNJbkNsYXNzLCBzdGFydExvYyk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmVjb3JkQXdhaXRJZkFsbG93ZWQoKSB7XG4gICAgY29uc3QgaXNBd2FpdEFsbG93ZWQgPSB0aGlzLnByb2RQYXJhbS5oYXNBd2FpdDtcbiAgICBpZiAoaXNBd2FpdEFsbG93ZWQgJiYgIXRoaXMuc2NvcGUuaW5GdW5jdGlvbikge1xuICAgICAgdGhpcy5zdGF0ZS5oYXNUb3BMZXZlbEF3YWl0ID0gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGlzQXdhaXRBbGxvd2VkO1xuICB9XG4gIHBhcnNlQXdhaXQoc3RhcnRMb2MpIHtcbiAgICBjb25zdCBub2RlID0gdGhpcy5zdGFydE5vZGVBdChzdGFydExvYyk7XG4gICAgdGhpcy5leHByZXNzaW9uU2NvcGUucmVjb3JkUGFyYW1ldGVySW5pdGlhbGl6ZXJFcnJvcihFcnJvcnMuQXdhaXRFeHByZXNzaW9uRm9ybWFsUGFyYW1ldGVyLCBub2RlKTtcbiAgICBpZiAodGhpcy5lYXQoNTUpKSB7XG4gICAgICB0aGlzLnJhaXNlKEVycm9ycy5PYnNvbGV0ZUF3YWl0U3Rhciwgbm9kZSk7XG4gICAgfVxuICAgIGlmICghdGhpcy5zY29wZS5pbkZ1bmN0aW9uICYmICEodGhpcy5vcHRpb25GbGFncyAmIDEpKSB7XG4gICAgICBpZiAodGhpcy5pc0FtYmlndW91c1ByZWZpeE9ySWRlbnRpZmllcigpKSB7XG4gICAgICAgIHRoaXMuYW1iaWd1b3VzU2NyaXB0RGlmZmVyZW50QXN0ID0gdHJ1ZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuc2F3VW5hbWJpZ3VvdXNFU00gPSB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoIXRoaXMuc3RhdGUuc29sb0F3YWl0KSB7XG4gICAgICBub2RlLmFyZ3VtZW50ID0gdGhpcy5wYXJzZU1heWJlVW5hcnkobnVsbCwgdHJ1ZSk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJBd2FpdEV4cHJlc3Npb25cIik7XG4gIH1cbiAgaXNBbWJpZ3VvdXNQcmVmaXhPcklkZW50aWZpZXIoKSB7XG4gICAgaWYgKHRoaXMuaGFzUHJlY2VkaW5nTGluZUJyZWFrKCkpIHJldHVybiB0cnVlO1xuICAgIGNvbnN0IHtcbiAgICAgIHR5cGVcbiAgICB9ID0gdGhpcy5zdGF0ZTtcbiAgICByZXR1cm4gdHlwZSA9PT0gNTMgfHwgdHlwZSA9PT0gMTAgfHwgdHlwZSA9PT0gMCB8fCB0b2tlbklzVGVtcGxhdGUodHlwZSkgfHwgdHlwZSA9PT0gMTAyICYmICF0aGlzLnN0YXRlLmNvbnRhaW5zRXNjIHx8IHR5cGUgPT09IDEzOCB8fCB0eXBlID09PSA1NiB8fCB0aGlzLmhhc1BsdWdpbihcInY4aW50cmluc2ljXCIpICYmIHR5cGUgPT09IDU0O1xuICB9XG4gIHBhcnNlWWllbGQoc3RhcnRMb2MpIHtcbiAgICBjb25zdCBub2RlID0gdGhpcy5zdGFydE5vZGVBdChzdGFydExvYyk7XG4gICAgdGhpcy5leHByZXNzaW9uU2NvcGUucmVjb3JkUGFyYW1ldGVySW5pdGlhbGl6ZXJFcnJvcihFcnJvcnMuWWllbGRJblBhcmFtZXRlciwgbm9kZSk7XG4gICAgbGV0IGRlbGVnYXRpbmcgPSBmYWxzZTtcbiAgICBsZXQgYXJndW1lbnQgPSBudWxsO1xuICAgIGlmICghdGhpcy5oYXNQcmVjZWRpbmdMaW5lQnJlYWsoKSkge1xuICAgICAgZGVsZWdhdGluZyA9IHRoaXMuZWF0KDU1KTtcbiAgICAgIHN3aXRjaCAodGhpcy5zdGF0ZS50eXBlKSB7XG4gICAgICAgIGNhc2UgMTM6XG4gICAgICAgIGNhc2UgMTQwOlxuICAgICAgICBjYXNlIDg6XG4gICAgICAgIGNhc2UgMTE6XG4gICAgICAgIGNhc2UgMzpcbiAgICAgICAgY2FzZSA5OlxuICAgICAgICBjYXNlIDE0OlxuICAgICAgICBjYXNlIDEyOlxuICAgICAgICAgIGlmICghZGVsZWdhdGluZykgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgYXJndW1lbnQgPSB0aGlzLnBhcnNlTWF5YmVBc3NpZ24oKTtcbiAgICAgIH1cbiAgICB9XG4gICAgbm9kZS5kZWxlZ2F0ZSA9IGRlbGVnYXRpbmc7XG4gICAgbm9kZS5hcmd1bWVudCA9IGFyZ3VtZW50O1xuICAgIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJZaWVsZEV4cHJlc3Npb25cIik7XG4gIH1cbiAgcGFyc2VJbXBvcnRDYWxsKG5vZGUpIHtcbiAgICB0aGlzLm5leHQoKTtcbiAgICBub2RlLnNvdXJjZSA9IHRoaXMucGFyc2VNYXliZUFzc2lnbkFsbG93SW4oKTtcbiAgICBub2RlLm9wdGlvbnMgPSBudWxsO1xuICAgIGlmICh0aGlzLmVhdCgxMikpIHtcbiAgICAgIGlmICghdGhpcy5tYXRjaCgxMSkpIHtcbiAgICAgICAgbm9kZS5vcHRpb25zID0gdGhpcy5wYXJzZU1heWJlQXNzaWduQWxsb3dJbigpO1xuICAgICAgICBpZiAodGhpcy5lYXQoMTIpKSB7XG4gICAgICAgICAgdGhpcy5hZGRUcmFpbGluZ0NvbW1hRXh0cmFUb05vZGUobm9kZS5vcHRpb25zKTtcbiAgICAgICAgICBpZiAoIXRoaXMubWF0Y2goMTEpKSB7XG4gICAgICAgICAgICBkbyB7XG4gICAgICAgICAgICAgIHRoaXMucGFyc2VNYXliZUFzc2lnbkFsbG93SW4oKTtcbiAgICAgICAgICAgIH0gd2hpbGUgKHRoaXMuZWF0KDEyKSAmJiAhdGhpcy5tYXRjaCgxMSkpO1xuICAgICAgICAgICAgdGhpcy5yYWlzZShFcnJvcnMuSW1wb3J0Q2FsbEFyaXR5LCBub2RlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuYWRkVHJhaWxpbmdDb21tYUV4dHJhVG9Ob2RlKG5vZGUuc291cmNlKTtcbiAgICAgIH1cbiAgICB9XG4gICAgdGhpcy5leHBlY3QoMTEpO1xuICAgIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJJbXBvcnRFeHByZXNzaW9uXCIpO1xuICB9XG4gIGNoZWNrUGlwZWxpbmVBdEluZml4T3BlcmF0b3IobGVmdCwgbGVmdFN0YXJ0TG9jKSB7XG4gICAgaWYgKHRoaXMuaGFzUGx1Z2luKFtcInBpcGVsaW5lT3BlcmF0b3JcIiwge1xuICAgICAgcHJvcG9zYWw6IFwic21hcnRcIlxuICAgIH1dKSkge1xuICAgICAgaWYgKGxlZnQudHlwZSA9PT0gXCJTZXF1ZW5jZUV4cHJlc3Npb25cIikge1xuICAgICAgICB0aGlzLnJhaXNlKEVycm9ycy5QaXBlbGluZUhlYWRTZXF1ZW5jZUV4cHJlc3Npb24sIGxlZnRTdGFydExvYyk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHBhcnNlU21hcnRQaXBlbGluZUJvZHlJblN0eWxlKGNoaWxkRXhwciwgc3RhcnRMb2MpIHtcbiAgICBpZiAodGhpcy5pc1NpbXBsZVJlZmVyZW5jZShjaGlsZEV4cHIpKSB7XG4gICAgICBjb25zdCBib2R5Tm9kZSA9IHRoaXMuc3RhcnROb2RlQXQoc3RhcnRMb2MpO1xuICAgICAgYm9keU5vZGUuY2FsbGVlID0gY2hpbGRFeHByO1xuICAgICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShib2R5Tm9kZSwgXCJQaXBlbGluZUJhcmVGdW5jdGlvblwiKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgYm9keU5vZGUgPSB0aGlzLnN0YXJ0Tm9kZUF0KHN0YXJ0TG9jKTtcbiAgICAgIHRoaXMuY2hlY2tTbWFydFBpcGVUb3BpY0JvZHlFYXJseUVycm9ycyhzdGFydExvYyk7XG4gICAgICBib2R5Tm9kZS5leHByZXNzaW9uID0gY2hpbGRFeHByO1xuICAgICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShib2R5Tm9kZSwgXCJQaXBlbGluZVRvcGljRXhwcmVzc2lvblwiKTtcbiAgICB9XG4gIH1cbiAgaXNTaW1wbGVSZWZlcmVuY2UoZXhwcmVzc2lvbikge1xuICAgIHN3aXRjaCAoZXhwcmVzc2lvbi50eXBlKSB7XG4gICAgICBjYXNlIFwiTWVtYmVyRXhwcmVzc2lvblwiOlxuICAgICAgICByZXR1cm4gIWV4cHJlc3Npb24uY29tcHV0ZWQgJiYgdGhpcy5pc1NpbXBsZVJlZmVyZW5jZShleHByZXNzaW9uLm9iamVjdCk7XG4gICAgICBjYXNlIFwiSWRlbnRpZmllclwiOlxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cbiAgY2hlY2tTbWFydFBpcGVUb3BpY0JvZHlFYXJseUVycm9ycyhzdGFydExvYykge1xuICAgIGlmICh0aGlzLm1hdGNoKDE5KSkge1xuICAgICAgdGhyb3cgdGhpcy5yYWlzZShFcnJvcnMuUGlwZWxpbmVCb2R5Tm9BcnJvdywgdGhpcy5zdGF0ZS5zdGFydExvYyk7XG4gICAgfVxuICAgIGlmICghdGhpcy50b3BpY1JlZmVyZW5jZVdhc1VzZWRJbkN1cnJlbnRDb250ZXh0KCkpIHtcbiAgICAgIHRoaXMucmFpc2UoRXJyb3JzLlBpcGVsaW5lVG9waWNVbnVzZWQsIHN0YXJ0TG9jKTtcbiAgICB9XG4gIH1cbiAgd2l0aFRvcGljQmluZGluZ0NvbnRleHQoY2FsbGJhY2spIHtcbiAgICBjb25zdCBvdXRlckNvbnRleHRUb3BpY1N0YXRlID0gdGhpcy5zdGF0ZS50b3BpY0NvbnRleHQ7XG4gICAgdGhpcy5zdGF0ZS50b3BpY0NvbnRleHQgPSB7XG4gICAgICBtYXhOdW1PZlJlc29sdmFibGVUb3BpY3M6IDEsXG4gICAgICBtYXhUb3BpY0luZGV4OiBudWxsXG4gICAgfTtcbiAgICB0cnkge1xuICAgICAgcmV0dXJuIGNhbGxiYWNrKCk7XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIHRoaXMuc3RhdGUudG9waWNDb250ZXh0ID0gb3V0ZXJDb250ZXh0VG9waWNTdGF0ZTtcbiAgICB9XG4gIH1cbiAgd2l0aFNtYXJ0TWl4VG9waWNGb3JiaWRkaW5nQ29udGV4dChjYWxsYmFjaykge1xuICAgIGlmICh0aGlzLmhhc1BsdWdpbihbXCJwaXBlbGluZU9wZXJhdG9yXCIsIHtcbiAgICAgIHByb3Bvc2FsOiBcInNtYXJ0XCJcbiAgICB9XSkpIHtcbiAgICAgIGNvbnN0IG91dGVyQ29udGV4dFRvcGljU3RhdGUgPSB0aGlzLnN0YXRlLnRvcGljQ29udGV4dDtcbiAgICAgIHRoaXMuc3RhdGUudG9waWNDb250ZXh0ID0ge1xuICAgICAgICBtYXhOdW1PZlJlc29sdmFibGVUb3BpY3M6IDAsXG4gICAgICAgIG1heFRvcGljSW5kZXg6IG51bGxcbiAgICAgIH07XG4gICAgICB0cnkge1xuICAgICAgICByZXR1cm4gY2FsbGJhY2soKTtcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIHRoaXMuc3RhdGUudG9waWNDb250ZXh0ID0gb3V0ZXJDb250ZXh0VG9waWNTdGF0ZTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIGNhbGxiYWNrKCk7XG4gICAgfVxuICB9XG4gIHdpdGhTb2xvQXdhaXRQZXJtaXR0aW5nQ29udGV4dChjYWxsYmFjaykge1xuICAgIGNvbnN0IG91dGVyQ29udGV4dFNvbG9Bd2FpdFN0YXRlID0gdGhpcy5zdGF0ZS5zb2xvQXdhaXQ7XG4gICAgdGhpcy5zdGF0ZS5zb2xvQXdhaXQgPSB0cnVlO1xuICAgIHRyeSB7XG4gICAgICByZXR1cm4gY2FsbGJhY2soKTtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgdGhpcy5zdGF0ZS5zb2xvQXdhaXQgPSBvdXRlckNvbnRleHRTb2xvQXdhaXRTdGF0ZTtcbiAgICB9XG4gIH1cbiAgYWxsb3dJbkFuZChjYWxsYmFjaykge1xuICAgIGNvbnN0IGZsYWdzID0gdGhpcy5wcm9kUGFyYW0uY3VycmVudEZsYWdzKCk7XG4gICAgY29uc3QgcHJvZFBhcmFtVG9TZXQgPSA4ICYgfmZsYWdzO1xuICAgIGlmIChwcm9kUGFyYW1Ub1NldCkge1xuICAgICAgdGhpcy5wcm9kUGFyYW0uZW50ZXIoZmxhZ3MgfCA4KTtcbiAgICAgIHRyeSB7XG4gICAgICAgIHJldHVybiBjYWxsYmFjaygpO1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgdGhpcy5wcm9kUGFyYW0uZXhpdCgpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gY2FsbGJhY2soKTtcbiAgfVxuICBkaXNhbGxvd0luQW5kKGNhbGxiYWNrKSB7XG4gICAgY29uc3QgZmxhZ3MgPSB0aGlzLnByb2RQYXJhbS5jdXJyZW50RmxhZ3MoKTtcbiAgICBjb25zdCBwcm9kUGFyYW1Ub0NsZWFyID0gOCAmIGZsYWdzO1xuICAgIGlmIChwcm9kUGFyYW1Ub0NsZWFyKSB7XG4gICAgICB0aGlzLnByb2RQYXJhbS5lbnRlcihmbGFncyAmIH44KTtcbiAgICAgIHRyeSB7XG4gICAgICAgIHJldHVybiBjYWxsYmFjaygpO1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgdGhpcy5wcm9kUGFyYW0uZXhpdCgpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gY2FsbGJhY2soKTtcbiAgfVxuICByZWdpc3RlclRvcGljUmVmZXJlbmNlKCkge1xuICAgIHRoaXMuc3RhdGUudG9waWNDb250ZXh0Lm1heFRvcGljSW5kZXggPSAwO1xuICB9XG4gIHRvcGljUmVmZXJlbmNlSXNBbGxvd2VkSW5DdXJyZW50Q29udGV4dCgpIHtcbiAgICByZXR1cm4gdGhpcy5zdGF0ZS50b3BpY0NvbnRleHQubWF4TnVtT2ZSZXNvbHZhYmxlVG9waWNzID49IDE7XG4gIH1cbiAgdG9waWNSZWZlcmVuY2VXYXNVc2VkSW5DdXJyZW50Q29udGV4dCgpIHtcbiAgICByZXR1cm4gdGhpcy5zdGF0ZS50b3BpY0NvbnRleHQubWF4VG9waWNJbmRleCAhPSBudWxsICYmIHRoaXMuc3RhdGUudG9waWNDb250ZXh0Lm1heFRvcGljSW5kZXggPj0gMDtcbiAgfVxuICBwYXJzZUZTaGFycFBpcGVsaW5lQm9keShwcmVjKSB7XG4gICAgY29uc3Qgc3RhcnRMb2MgPSB0aGlzLnN0YXRlLnN0YXJ0TG9jO1xuICAgIHRoaXMuc3RhdGUucG90ZW50aWFsQXJyb3dBdCA9IHRoaXMuc3RhdGUuc3RhcnQ7XG4gICAgY29uc3Qgb2xkSW5GU2hhcnBQaXBlbGluZURpcmVjdEJvZHkgPSB0aGlzLnN0YXRlLmluRlNoYXJwUGlwZWxpbmVEaXJlY3RCb2R5O1xuICAgIHRoaXMuc3RhdGUuaW5GU2hhcnBQaXBlbGluZURpcmVjdEJvZHkgPSB0cnVlO1xuICAgIGNvbnN0IHJldCA9IHRoaXMucGFyc2VFeHByT3AodGhpcy5wYXJzZU1heWJlVW5hcnlPclByaXZhdGUoKSwgc3RhcnRMb2MsIHByZWMpO1xuICAgIHRoaXMuc3RhdGUuaW5GU2hhcnBQaXBlbGluZURpcmVjdEJvZHkgPSBvbGRJbkZTaGFycFBpcGVsaW5lRGlyZWN0Qm9keTtcbiAgICByZXR1cm4gcmV0O1xuICB9XG4gIHBhcnNlTW9kdWxlRXhwcmVzc2lvbigpIHtcbiAgICB0aGlzLmV4cGVjdFBsdWdpbihcIm1vZHVsZUJsb2Nrc1wiKTtcbiAgICBjb25zdCBub2RlID0gdGhpcy5zdGFydE5vZGUoKTtcbiAgICB0aGlzLm5leHQoKTtcbiAgICBpZiAoIXRoaXMubWF0Y2goNSkpIHtcbiAgICAgIHRoaXMudW5leHBlY3RlZChudWxsLCA1KTtcbiAgICB9XG4gICAgY29uc3QgcHJvZ3JhbSA9IHRoaXMuc3RhcnROb2RlQXQodGhpcy5zdGF0ZS5lbmRMb2MpO1xuICAgIHRoaXMubmV4dCgpO1xuICAgIGNvbnN0IHJldmVydFNjb3BlcyA9IHRoaXMuaW5pdGlhbGl6ZVNjb3Blcyh0cnVlKTtcbiAgICB0aGlzLmVudGVySW5pdGlhbFNjb3BlcygpO1xuICAgIHRyeSB7XG4gICAgICBub2RlLmJvZHkgPSB0aGlzLnBhcnNlUHJvZ3JhbShwcm9ncmFtLCA4LCBcIm1vZHVsZVwiKTtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgcmV2ZXJ0U2NvcGVzKCk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJNb2R1bGVFeHByZXNzaW9uXCIpO1xuICB9XG4gIHBhcnNlVm9pZFBhdHRlcm4ocmVmRXhwcmVzc2lvbkVycm9ycykge1xuICAgIHRoaXMuZXhwZWN0UGx1Z2luKFwiZGlzY2FyZEJpbmRpbmdcIik7XG4gICAgY29uc3Qgbm9kZSA9IHRoaXMuc3RhcnROb2RlKCk7XG4gICAgaWYgKHJlZkV4cHJlc3Npb25FcnJvcnMgIT0gbnVsbCkge1xuICAgICAgcmVmRXhwcmVzc2lvbkVycm9ycy52b2lkUGF0dGVybkxvYyA9IHRoaXMuc3RhdGUuc3RhcnRMb2M7XG4gICAgfVxuICAgIHRoaXMubmV4dCgpO1xuICAgIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJWb2lkUGF0dGVyblwiKTtcbiAgfVxuICBwYXJzZU1heWJlQXNzaWduQWxsb3dJbk9yVm9pZFBhdHRlcm4oY2xvc2UsIHJlZkV4cHJlc3Npb25FcnJvcnMsIGFmdGVyTGVmdFBhcnNlKSB7XG4gICAgaWYgKHJlZkV4cHJlc3Npb25FcnJvcnMgIT0gbnVsbCAmJiB0aGlzLm1hdGNoKDg4KSkge1xuICAgICAgY29uc3QgbmV4dENvZGUgPSB0aGlzLmxvb2thaGVhZENoYXJDb2RlKCk7XG4gICAgICBpZiAobmV4dENvZGUgPT09IDQ0IHx8IG5leHRDb2RlID09PSAoY2xvc2UgPT09IDMgPyA5MyA6IGNsb3NlID09PSA4ID8gMTI1IDogNDEpIHx8IG5leHRDb2RlID09PSA2MSkge1xuICAgICAgICByZXR1cm4gdGhpcy5wYXJzZU1heWJlRGVmYXVsdCh0aGlzLnN0YXRlLnN0YXJ0TG9jLCB0aGlzLnBhcnNlVm9pZFBhdHRlcm4ocmVmRXhwcmVzc2lvbkVycm9ycykpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdGhpcy5wYXJzZU1heWJlQXNzaWduQWxsb3dJbihyZWZFeHByZXNzaW9uRXJyb3JzLCBhZnRlckxlZnRQYXJzZSk7XG4gIH1cbiAgcGFyc2VQcm9wZXJ0eU5hbWVQcmVmaXhPcGVyYXRvcihwcm9wKSB7fVxufVxuY29uc3QgbG9vcExhYmVsID0ge1xuICAgIGtpbmQ6IDFcbiAgfSxcbiAgc3dpdGNoTGFiZWwgPSB7XG4gICAga2luZDogMlxuICB9O1xuY29uc3QgbG9uZVN1cnJvZ2F0ZSA9IC9bXFx1RDgwMC1cXHVERkZGXS91O1xuY29uc3Qga2V5d29yZFJlbGF0aW9uYWxPcGVyYXRvciA9IC9pbig/OnN0YW5jZW9mKT8veTtcbmZ1bmN0aW9uIGJhYmVsN0NvbXBhdFRva2Vucyh0b2tlbnMsIGlucHV0LCBzdGFydEluZGV4KSB7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgdG9rZW5zLmxlbmd0aDsgaSsrKSB7XG4gICAgY29uc3QgdG9rZW4gPSB0b2tlbnNbaV07XG4gICAgY29uc3Qge1xuICAgICAgdHlwZVxuICAgIH0gPSB0b2tlbjtcbiAgICBpZiAodHlwZW9mIHR5cGUgPT09IFwibnVtYmVyXCIpIHtcbiAgICAgIGlmICh0eXBlID09PSAxMzkpIHtcbiAgICAgICAgY29uc3Qge1xuICAgICAgICAgIGxvYyxcbiAgICAgICAgICBzdGFydCxcbiAgICAgICAgICB2YWx1ZSxcbiAgICAgICAgICBlbmRcbiAgICAgICAgfSA9IHRva2VuO1xuICAgICAgICBjb25zdCBoYXNoRW5kUG9zID0gc3RhcnQgKyAxO1xuICAgICAgICBjb25zdCBoYXNoRW5kTG9jID0gY3JlYXRlUG9zaXRpb25XaXRoQ29sdW1uT2Zmc2V0KGxvYy5zdGFydCwgMSk7XG4gICAgICAgIHRva2Vucy5zcGxpY2UoaSwgMSwgbmV3IFRva2VuKHtcbiAgICAgICAgICB0eXBlOiBnZXRFeHBvcnRlZFRva2VuKDI3KSxcbiAgICAgICAgICB2YWx1ZTogXCIjXCIsXG4gICAgICAgICAgc3RhcnQ6IHN0YXJ0LFxuICAgICAgICAgIGVuZDogaGFzaEVuZFBvcyxcbiAgICAgICAgICBzdGFydExvYzogbG9jLnN0YXJ0LFxuICAgICAgICAgIGVuZExvYzogaGFzaEVuZExvY1xuICAgICAgICB9KSwgbmV3IFRva2VuKHtcbiAgICAgICAgICB0eXBlOiBnZXRFeHBvcnRlZFRva2VuKDEzMiksXG4gICAgICAgICAgdmFsdWU6IHZhbHVlLFxuICAgICAgICAgIHN0YXJ0OiBoYXNoRW5kUG9zLFxuICAgICAgICAgIGVuZDogZW5kLFxuICAgICAgICAgIHN0YXJ0TG9jOiBoYXNoRW5kTG9jLFxuICAgICAgICAgIGVuZExvYzogbG9jLmVuZFxuICAgICAgICB9KSk7XG4gICAgICAgIGkrKztcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBpZiAodG9rZW5Jc1RlbXBsYXRlKHR5cGUpKSB7XG4gICAgICAgIGNvbnN0IHtcbiAgICAgICAgICBsb2MsXG4gICAgICAgICAgc3RhcnQsXG4gICAgICAgICAgdmFsdWUsXG4gICAgICAgICAgZW5kXG4gICAgICAgIH0gPSB0b2tlbjtcbiAgICAgICAgY29uc3QgYmFja3F1b3RlRW5kID0gc3RhcnQgKyAxO1xuICAgICAgICBjb25zdCBiYWNrcXVvdGVFbmRMb2MgPSBjcmVhdGVQb3NpdGlvbldpdGhDb2x1bW5PZmZzZXQobG9jLnN0YXJ0LCAxKTtcbiAgICAgICAgbGV0IHN0YXJ0VG9rZW47XG4gICAgICAgIGlmIChpbnB1dC5jaGFyQ29kZUF0KHN0YXJ0IC0gc3RhcnRJbmRleCkgPT09IDk2KSB7XG4gICAgICAgICAgc3RhcnRUb2tlbiA9IG5ldyBUb2tlbih7XG4gICAgICAgICAgICB0eXBlOiBnZXRFeHBvcnRlZFRva2VuKDIyKSxcbiAgICAgICAgICAgIHZhbHVlOiBcImBcIixcbiAgICAgICAgICAgIHN0YXJ0OiBzdGFydCxcbiAgICAgICAgICAgIGVuZDogYmFja3F1b3RlRW5kLFxuICAgICAgICAgICAgc3RhcnRMb2M6IGxvYy5zdGFydCxcbiAgICAgICAgICAgIGVuZExvYzogYmFja3F1b3RlRW5kTG9jXG4gICAgICAgICAgfSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgc3RhcnRUb2tlbiA9IG5ldyBUb2tlbih7XG4gICAgICAgICAgICB0eXBlOiBnZXRFeHBvcnRlZFRva2VuKDgpLFxuICAgICAgICAgICAgdmFsdWU6IFwifVwiLFxuICAgICAgICAgICAgc3RhcnQ6IHN0YXJ0LFxuICAgICAgICAgICAgZW5kOiBiYWNrcXVvdGVFbmQsXG4gICAgICAgICAgICBzdGFydExvYzogbG9jLnN0YXJ0LFxuICAgICAgICAgICAgZW5kTG9jOiBiYWNrcXVvdGVFbmRMb2NcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgdGVtcGxhdGVWYWx1ZSwgdGVtcGxhdGVFbGVtZW50RW5kLCB0ZW1wbGF0ZUVsZW1lbnRFbmRMb2MsIGVuZFRva2VuO1xuICAgICAgICBpZiAodHlwZSA9PT0gMjQpIHtcbiAgICAgICAgICB0ZW1wbGF0ZUVsZW1lbnRFbmQgPSBlbmQgLSAxO1xuICAgICAgICAgIHRlbXBsYXRlRWxlbWVudEVuZExvYyA9IGNyZWF0ZVBvc2l0aW9uV2l0aENvbHVtbk9mZnNldChsb2MuZW5kLCAtMSk7XG4gICAgICAgICAgdGVtcGxhdGVWYWx1ZSA9IHZhbHVlID09PSBudWxsID8gbnVsbCA6IHZhbHVlLnNsaWNlKDEsIC0xKTtcbiAgICAgICAgICBlbmRUb2tlbiA9IG5ldyBUb2tlbih7XG4gICAgICAgICAgICB0eXBlOiBnZXRFeHBvcnRlZFRva2VuKDIyKSxcbiAgICAgICAgICAgIHZhbHVlOiBcImBcIixcbiAgICAgICAgICAgIHN0YXJ0OiB0ZW1wbGF0ZUVsZW1lbnRFbmQsXG4gICAgICAgICAgICBlbmQ6IGVuZCxcbiAgICAgICAgICAgIHN0YXJ0TG9jOiB0ZW1wbGF0ZUVsZW1lbnRFbmRMb2MsXG4gICAgICAgICAgICBlbmRMb2M6IGxvYy5lbmRcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0ZW1wbGF0ZUVsZW1lbnRFbmQgPSBlbmQgLSAyO1xuICAgICAgICAgIHRlbXBsYXRlRWxlbWVudEVuZExvYyA9IGNyZWF0ZVBvc2l0aW9uV2l0aENvbHVtbk9mZnNldChsb2MuZW5kLCAtMik7XG4gICAgICAgICAgdGVtcGxhdGVWYWx1ZSA9IHZhbHVlID09PSBudWxsID8gbnVsbCA6IHZhbHVlLnNsaWNlKDEsIC0yKTtcbiAgICAgICAgICBlbmRUb2tlbiA9IG5ldyBUb2tlbih7XG4gICAgICAgICAgICB0eXBlOiBnZXRFeHBvcnRlZFRva2VuKDIzKSxcbiAgICAgICAgICAgIHZhbHVlOiBcIiR7XCIsXG4gICAgICAgICAgICBzdGFydDogdGVtcGxhdGVFbGVtZW50RW5kLFxuICAgICAgICAgICAgZW5kOiBlbmQsXG4gICAgICAgICAgICBzdGFydExvYzogdGVtcGxhdGVFbGVtZW50RW5kTG9jLFxuICAgICAgICAgICAgZW5kTG9jOiBsb2MuZW5kXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgdG9rZW5zLnNwbGljZShpLCAxLCBzdGFydFRva2VuLCBuZXcgVG9rZW4oe1xuICAgICAgICAgIHR5cGU6IGdldEV4cG9ydGVkVG9rZW4oMjApLFxuICAgICAgICAgIHZhbHVlOiB0ZW1wbGF0ZVZhbHVlLFxuICAgICAgICAgIHN0YXJ0OiBiYWNrcXVvdGVFbmQsXG4gICAgICAgICAgZW5kOiB0ZW1wbGF0ZUVsZW1lbnRFbmQsXG4gICAgICAgICAgc3RhcnRMb2M6IGJhY2txdW90ZUVuZExvYyxcbiAgICAgICAgICBlbmRMb2M6IHRlbXBsYXRlRWxlbWVudEVuZExvY1xuICAgICAgICB9KSwgZW5kVG9rZW4pO1xuICAgICAgICBpICs9IDI7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgdG9rZW4udHlwZSA9IGdldEV4cG9ydGVkVG9rZW4odHlwZSk7XG4gICAgfVxuICB9XG4gIHJldHVybiB0b2tlbnM7XG59XG5jbGFzcyBTdGF0ZW1lbnRQYXJzZXIgZXh0ZW5kcyBFeHByZXNzaW9uUGFyc2VyIHtcbiAgcGFyc2VUb3BMZXZlbChmaWxlLCBwcm9ncmFtKSB7XG4gICAgZmlsZS5wcm9ncmFtID0gdGhpcy5wYXJzZVByb2dyYW0ocHJvZ3JhbSwgMTQwLCB0aGlzLm9wdGlvbnMuc291cmNlVHlwZSA9PT0gXCJtb2R1bGVcIiA/IFwibW9kdWxlXCIgOiBcInNjcmlwdFwiKTtcbiAgICBmaWxlLmNvbW1lbnRzID0gdGhpcy5jb21tZW50cztcbiAgICBpZiAodGhpcy5vcHRpb25GbGFncyAmIDI1Nikge1xuICAgICAgZmlsZS50b2tlbnMgPSBiYWJlbDdDb21wYXRUb2tlbnModGhpcy50b2tlbnMsIHRoaXMuaW5wdXQsIHRoaXMuc3RhcnRJbmRleCk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLmZpbmlzaE5vZGUoZmlsZSwgXCJGaWxlXCIpO1xuICB9XG4gIHBhcnNlUHJvZ3JhbShwcm9ncmFtLCBlbmQsIHNvdXJjZVR5cGUpIHtcbiAgICBwcm9ncmFtLnNvdXJjZVR5cGUgPSBzb3VyY2VUeXBlO1xuICAgIHByb2dyYW0uaW50ZXJwcmV0ZXIgPSB0aGlzLnBhcnNlSW50ZXJwcmV0ZXJEaXJlY3RpdmUoKTtcbiAgICB0aGlzLnBhcnNlQmxvY2tCb2R5KHByb2dyYW0sIHRydWUsIHRydWUsIGVuZCk7XG4gICAgaWYgKHRoaXMuaW5Nb2R1bGUpIHtcbiAgICAgIGlmICghKHRoaXMub3B0aW9uRmxhZ3MgJiA2NCkgJiYgdGhpcy5zY29wZS51bmRlZmluZWRFeHBvcnRzLnNpemUgPiAwKSB7XG4gICAgICAgIGZvciAoY29uc3QgW2xvY2FsTmFtZSwgYXRdIG9mIEFycmF5LmZyb20odGhpcy5zY29wZS51bmRlZmluZWRFeHBvcnRzKSkge1xuICAgICAgICAgIHRoaXMucmFpc2UoRXJyb3JzLk1vZHVsZUV4cG9ydFVuZGVmaW5lZCwgYXQsIHtcbiAgICAgICAgICAgIGxvY2FsTmFtZVxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICB0aGlzLmFkZEV4dHJhKHByb2dyYW0sIFwidG9wTGV2ZWxBd2FpdFwiLCB0aGlzLnN0YXRlLmhhc1RvcExldmVsQXdhaXQpO1xuICAgIH1cbiAgICBsZXQgZmluaXNoZWRQcm9ncmFtO1xuICAgIGlmIChlbmQgPT09IDE0MCkge1xuICAgICAgZmluaXNoZWRQcm9ncmFtID0gdGhpcy5maW5pc2hOb2RlKHByb2dyYW0sIFwiUHJvZ3JhbVwiKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZmluaXNoZWRQcm9ncmFtID0gdGhpcy5maW5pc2hOb2RlQXQocHJvZ3JhbSwgXCJQcm9ncmFtXCIsIGNyZWF0ZVBvc2l0aW9uV2l0aENvbHVtbk9mZnNldCh0aGlzLnN0YXRlLnN0YXJ0TG9jLCAtMSkpO1xuICAgIH1cbiAgICByZXR1cm4gZmluaXNoZWRQcm9ncmFtO1xuICB9XG4gIHN0bXRUb0RpcmVjdGl2ZShzdG10KSB7XG4gICAgY29uc3QgZGlyZWN0aXZlID0gdGhpcy5jYXN0Tm9kZVRvKHN0bXQsIFwiRGlyZWN0aXZlXCIpO1xuICAgIGNvbnN0IGRpcmVjdGl2ZUxpdGVyYWwgPSB0aGlzLmNhc3ROb2RlVG8oc3RtdC5leHByZXNzaW9uLCBcIkRpcmVjdGl2ZUxpdGVyYWxcIik7XG4gICAgY29uc3QgZXhwcmVzc2lvblZhbHVlID0gZGlyZWN0aXZlTGl0ZXJhbC52YWx1ZTtcbiAgICBjb25zdCByYXcgPSB0aGlzLmlucHV0LnNsaWNlKHRoaXMub2Zmc2V0VG9Tb3VyY2VQb3MoZGlyZWN0aXZlTGl0ZXJhbC5zdGFydCksIHRoaXMub2Zmc2V0VG9Tb3VyY2VQb3MoZGlyZWN0aXZlTGl0ZXJhbC5lbmQpKTtcbiAgICBjb25zdCB2YWwgPSBkaXJlY3RpdmVMaXRlcmFsLnZhbHVlID0gcmF3LnNsaWNlKDEsIC0xKTtcbiAgICB0aGlzLmFkZEV4dHJhKGRpcmVjdGl2ZUxpdGVyYWwsIFwicmF3XCIsIHJhdyk7XG4gICAgdGhpcy5hZGRFeHRyYShkaXJlY3RpdmVMaXRlcmFsLCBcInJhd1ZhbHVlXCIsIHZhbCk7XG4gICAgdGhpcy5hZGRFeHRyYShkaXJlY3RpdmVMaXRlcmFsLCBcImV4cHJlc3Npb25WYWx1ZVwiLCBleHByZXNzaW9uVmFsdWUpO1xuICAgIGRpcmVjdGl2ZS52YWx1ZSA9IGRpcmVjdGl2ZUxpdGVyYWw7XG4gICAgZGVsZXRlIHN0bXQuZXhwcmVzc2lvbjtcbiAgICByZXR1cm4gZGlyZWN0aXZlO1xuICB9XG4gIHBhcnNlSW50ZXJwcmV0ZXJEaXJlY3RpdmUoKSB7XG4gICAgaWYgKCF0aGlzLm1hdGNoKDI4KSkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGNvbnN0IG5vZGUgPSB0aGlzLnN0YXJ0Tm9kZSgpO1xuICAgIG5vZGUudmFsdWUgPSB0aGlzLnN0YXRlLnZhbHVlO1xuICAgIHRoaXMubmV4dCgpO1xuICAgIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJJbnRlcnByZXRlckRpcmVjdGl2ZVwiKTtcbiAgfVxuICBpc0xldCgpIHtcbiAgICBpZiAoIXRoaXMuaXNDb250ZXh0dWFsKDEwMCkpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuaGFzRm9sbG93aW5nQmluZGluZ0F0b20oKTtcbiAgfVxuICBpc1VzaW5nKCkge1xuICAgIGlmICghdGhpcy5pc0NvbnRleHR1YWwoMTA3KSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5uZXh0VG9rZW5Jc0lkZW50aWZpZXJPblNhbWVMaW5lKCk7XG4gIH1cbiAgaXNGb3JVc2luZygpIHtcbiAgICBpZiAoIXRoaXMuaXNDb250ZXh0dWFsKDEwNykpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgY29uc3QgbmV4dCA9IHRoaXMubmV4dFRva2VuSW5MaW5lU3RhcnQoKTtcbiAgICBjb25zdCBuZXh0Q2ggPSB0aGlzLmNvZGVQb2ludEF0UG9zKG5leHQpO1xuICAgIGlmICh0aGlzLmlzVW5wYXJzZWRDb250ZXh0dWFsKG5leHQsIFwib2ZcIikpIHtcbiAgICAgIGNvbnN0IG5leHRDaGFyQWZ0ZXJPZiA9IHRoaXMubG9va2FoZWFkQ2hhckNvZGVTaW5jZShuZXh0ICsgMik7XG4gICAgICBpZiAobmV4dENoYXJBZnRlck9mICE9PSA2MSAmJiBuZXh0Q2hhckFmdGVyT2YgIT09IDU4ICYmIG5leHRDaGFyQWZ0ZXJPZiAhPT0gNTkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAodGhpcy5jaFN0YXJ0c0JpbmRpbmdJZGVudGlmaWVyKG5leHRDaCwgbmV4dCkgfHwgdGhpcy5pc1VucGFyc2VkQ29udGV4dHVhbChuZXh0LCBcInZvaWRcIikpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgbmV4dFRva2VuSXNJZGVudGlmaWVyT25TYW1lTGluZSgpIHtcbiAgICBjb25zdCBuZXh0ID0gdGhpcy5uZXh0VG9rZW5JbkxpbmVTdGFydCgpO1xuICAgIGNvbnN0IG5leHRDaCA9IHRoaXMuY29kZVBvaW50QXRQb3MobmV4dCk7XG4gICAgcmV0dXJuIHRoaXMuY2hTdGFydHNCaW5kaW5nSWRlbnRpZmllcihuZXh0Q2gsIG5leHQpO1xuICB9XG4gIGlzQXdhaXRVc2luZygpIHtcbiAgICBpZiAoIXRoaXMuaXNDb250ZXh0dWFsKDk2KSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBsZXQgbmV4dCA9IHRoaXMubmV4dFRva2VuSW5MaW5lU3RhcnQoKTtcbiAgICBpZiAodGhpcy5pc1VucGFyc2VkQ29udGV4dHVhbChuZXh0LCBcInVzaW5nXCIpKSB7XG4gICAgICBuZXh0ID0gdGhpcy5uZXh0VG9rZW5JbkxpbmVTdGFydFNpbmNlKG5leHQgKyA1KTtcbiAgICAgIGNvbnN0IG5leHRDaCA9IHRoaXMuY29kZVBvaW50QXRQb3MobmV4dCk7XG4gICAgICBpZiAodGhpcy5jaFN0YXJ0c0JpbmRpbmdJZGVudGlmaWVyKG5leHRDaCwgbmV4dCkpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBjaFN0YXJ0c0JpbmRpbmdJZGVudGlmaWVyKGNoLCBwb3MpIHtcbiAgICBpZiAoaXNJZGVudGlmaWVyU3RhcnQoY2gpKSB7XG4gICAgICBrZXl3b3JkUmVsYXRpb25hbE9wZXJhdG9yLmxhc3RJbmRleCA9IHBvcztcbiAgICAgIGlmIChrZXl3b3JkUmVsYXRpb25hbE9wZXJhdG9yLnRlc3QodGhpcy5pbnB1dCkpIHtcbiAgICAgICAgY29uc3QgZW5kQ2ggPSB0aGlzLmNvZGVQb2ludEF0UG9zKGtleXdvcmRSZWxhdGlvbmFsT3BlcmF0b3IubGFzdEluZGV4KTtcbiAgICAgICAgaWYgKCFpc0lkZW50aWZpZXJDaGFyKGVuZENoKSAmJiBlbmRDaCAhPT0gOTIpIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gZWxzZSBpZiAoY2ggPT09IDkyKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuICBjaFN0YXJ0c0JpbmRpbmdQYXR0ZXJuKGNoKSB7XG4gICAgcmV0dXJuIGNoID09PSA5MSB8fCBjaCA9PT0gMTIzO1xuICB9XG4gIGhhc0ZvbGxvd2luZ0JpbmRpbmdBdG9tKCkge1xuICAgIGNvbnN0IG5leHQgPSB0aGlzLm5leHRUb2tlblN0YXJ0KCk7XG4gICAgY29uc3QgbmV4dENoID0gdGhpcy5jb2RlUG9pbnRBdFBvcyhuZXh0KTtcbiAgICByZXR1cm4gdGhpcy5jaFN0YXJ0c0JpbmRpbmdQYXR0ZXJuKG5leHRDaCkgfHwgdGhpcy5jaFN0YXJ0c0JpbmRpbmdJZGVudGlmaWVyKG5leHRDaCwgbmV4dCk7XG4gIH1cbiAgaGFzSW5MaW5lRm9sbG93aW5nQmluZGluZ0lkZW50aWZpZXJPckJyYWNlKCkge1xuICAgIGNvbnN0IG5leHQgPSB0aGlzLm5leHRUb2tlbkluTGluZVN0YXJ0KCk7XG4gICAgY29uc3QgbmV4dENoID0gdGhpcy5jb2RlUG9pbnRBdFBvcyhuZXh0KTtcbiAgICByZXR1cm4gbmV4dENoID09PSAxMjMgfHwgdGhpcy5jaFN0YXJ0c0JpbmRpbmdJZGVudGlmaWVyKG5leHRDaCwgbmV4dCk7XG4gIH1cbiAgYWxsb3dzVXNpbmcoKSB7XG4gICAgcmV0dXJuICh0aGlzLnNjb3BlLmluTW9kdWxlIHx8ICF0aGlzLnNjb3BlLmluVG9wTGV2ZWwpICYmICF0aGlzLnNjb3BlLmluQmFyZUNhc2VTdGF0ZW1lbnQ7XG4gIH1cbiAgcGFyc2VNb2R1bGVJdGVtKCkge1xuICAgIHJldHVybiB0aGlzLnBhcnNlU3RhdGVtZW50TGlrZSgxIHwgMiB8IDQgfCA4KTtcbiAgfVxuICBwYXJzZVN0YXRlbWVudExpc3RJdGVtKCkge1xuICAgIHJldHVybiB0aGlzLnBhcnNlU3RhdGVtZW50TGlrZSgyIHwgNCB8ICghdGhpcy5vcHRpb25zLmFubmV4QiB8fCB0aGlzLnN0YXRlLnN0cmljdCA/IDAgOiA4KSk7XG4gIH1cbiAgcGFyc2VTdGF0ZW1lbnRPclNsb3BweUFubmV4QkZ1bmN0aW9uRGVjbGFyYXRpb24oYWxsb3dMYWJlbGVkRnVuY3Rpb24gPSBmYWxzZSkge1xuICAgIGxldCBmbGFncyA9IDA7XG4gICAgaWYgKHRoaXMub3B0aW9ucy5hbm5leEIgJiYgIXRoaXMuc3RhdGUuc3RyaWN0KSB7XG4gICAgICBmbGFncyB8PSA0O1xuICAgICAgaWYgKGFsbG93TGFiZWxlZEZ1bmN0aW9uKSB7XG4gICAgICAgIGZsYWdzIHw9IDg7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0aGlzLnBhcnNlU3RhdGVtZW50TGlrZShmbGFncyk7XG4gIH1cbiAgcGFyc2VTdGF0ZW1lbnQoKSB7XG4gICAgcmV0dXJuIHRoaXMucGFyc2VTdGF0ZW1lbnRMaWtlKDApO1xuICB9XG4gIHBhcnNlU3RhdGVtZW50TGlrZShmbGFncykge1xuICAgIGxldCBkZWNvcmF0b3JzID0gbnVsbDtcbiAgICBpZiAodGhpcy5tYXRjaCgyNikpIHtcbiAgICAgIGRlY29yYXRvcnMgPSB0aGlzLnBhcnNlRGVjb3JhdG9ycyh0cnVlKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMucGFyc2VTdGF0ZW1lbnRDb250ZW50KGZsYWdzLCBkZWNvcmF0b3JzKTtcbiAgfVxuICBwYXJzZVN0YXRlbWVudENvbnRlbnQoZmxhZ3MsIGRlY29yYXRvcnMpIHtcbiAgICBjb25zdCBzdGFydFR5cGUgPSB0aGlzLnN0YXRlLnR5cGU7XG4gICAgY29uc3Qgbm9kZSA9IHRoaXMuc3RhcnROb2RlKCk7XG4gICAgY29uc3QgYWxsb3dEZWNsYXJhdGlvbiA9ICEhKGZsYWdzICYgMik7XG4gICAgY29uc3QgYWxsb3dGdW5jdGlvbkRlY2xhcmF0aW9uID0gISEoZmxhZ3MgJiA0KTtcbiAgICBjb25zdCB0b3BMZXZlbCA9IGZsYWdzICYgMTtcbiAgICBzd2l0Y2ggKHN0YXJ0VHlwZSkge1xuICAgICAgY2FzZSA2MDpcbiAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VCcmVha0NvbnRpbnVlU3RhdGVtZW50KG5vZGUsIHRydWUpO1xuICAgICAgY2FzZSA2MzpcbiAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VCcmVha0NvbnRpbnVlU3RhdGVtZW50KG5vZGUsIGZhbHNlKTtcbiAgICAgIGNhc2UgNjQ6XG4gICAgICAgIHJldHVybiB0aGlzLnBhcnNlRGVidWdnZXJTdGF0ZW1lbnQobm9kZSk7XG4gICAgICBjYXNlIDkwOlxuICAgICAgICByZXR1cm4gdGhpcy5wYXJzZURvV2hpbGVTdGF0ZW1lbnQobm9kZSk7XG4gICAgICBjYXNlIDkxOlxuICAgICAgICByZXR1cm4gdGhpcy5wYXJzZUZvclN0YXRlbWVudChub2RlKTtcbiAgICAgIGNhc2UgNjg6XG4gICAgICAgIGlmICh0aGlzLmxvb2thaGVhZENoYXJDb2RlKCkgPT09IDQ2KSBicmVhaztcbiAgICAgICAgaWYgKCFhbGxvd0Z1bmN0aW9uRGVjbGFyYXRpb24pIHtcbiAgICAgICAgICB0aGlzLnJhaXNlKHRoaXMuc3RhdGUuc3RyaWN0ID8gRXJyb3JzLlN0cmljdEZ1bmN0aW9uIDogdGhpcy5vcHRpb25zLmFubmV4QiA/IEVycm9ycy5TbG9wcHlGdW5jdGlvbkFubmV4QiA6IEVycm9ycy5TbG9wcHlGdW5jdGlvbiwgdGhpcy5zdGF0ZS5zdGFydExvYyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VGdW5jdGlvblN0YXRlbWVudChub2RlLCBmYWxzZSwgIWFsbG93RGVjbGFyYXRpb24gJiYgYWxsb3dGdW5jdGlvbkRlY2xhcmF0aW9uKTtcbiAgICAgIGNhc2UgODA6XG4gICAgICAgIGlmICghYWxsb3dEZWNsYXJhdGlvbikgdGhpcy51bmV4cGVjdGVkKCk7XG4gICAgICAgIHJldHVybiB0aGlzLnBhcnNlQ2xhc3ModGhpcy5tYXliZVRha2VEZWNvcmF0b3JzKGRlY29yYXRvcnMsIG5vZGUpLCB0cnVlKTtcbiAgICAgIGNhc2UgNjk6XG4gICAgICAgIHJldHVybiB0aGlzLnBhcnNlSWZTdGF0ZW1lbnQobm9kZSk7XG4gICAgICBjYXNlIDcwOlxuICAgICAgICByZXR1cm4gdGhpcy5wYXJzZVJldHVyblN0YXRlbWVudChub2RlKTtcbiAgICAgIGNhc2UgNzE6XG4gICAgICAgIHJldHVybiB0aGlzLnBhcnNlU3dpdGNoU3RhdGVtZW50KG5vZGUpO1xuICAgICAgY2FzZSA3MjpcbiAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VUaHJvd1N0YXRlbWVudChub2RlKTtcbiAgICAgIGNhc2UgNzM6XG4gICAgICAgIHJldHVybiB0aGlzLnBhcnNlVHJ5U3RhdGVtZW50KG5vZGUpO1xuICAgICAgY2FzZSA5NjpcbiAgICAgICAgaWYgKHRoaXMuaXNBd2FpdFVzaW5nKCkpIHtcbiAgICAgICAgICBpZiAoIXRoaXMuYWxsb3dzVXNpbmcoKSkge1xuICAgICAgICAgICAgdGhpcy5yYWlzZShFcnJvcnMuVW5leHBlY3RlZFVzaW5nRGVjbGFyYXRpb24sIG5vZGUpO1xuICAgICAgICAgIH0gZWxzZSBpZiAoIWFsbG93RGVjbGFyYXRpb24pIHtcbiAgICAgICAgICAgIHRoaXMucmFpc2UoRXJyb3JzLlVuZXhwZWN0ZWRMZXhpY2FsRGVjbGFyYXRpb24sIG5vZGUpO1xuICAgICAgICAgIH0gZWxzZSBpZiAoIXRoaXMucmVjb3JkQXdhaXRJZkFsbG93ZWQoKSkge1xuICAgICAgICAgICAgdGhpcy5yYWlzZShFcnJvcnMuQXdhaXRVc2luZ05vdEluQXN5bmNDb250ZXh0LCBub2RlKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdGhpcy5uZXh0KCk7XG4gICAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VWYXJTdGF0ZW1lbnQobm9kZSwgXCJhd2FpdCB1c2luZ1wiKTtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgMTA3OlxuICAgICAgICBpZiAodGhpcy5zdGF0ZS5jb250YWluc0VzYyB8fCAhdGhpcy5oYXNJbkxpbmVGb2xsb3dpbmdCaW5kaW5nSWRlbnRpZmllck9yQnJhY2UoKSkge1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGlmICghdGhpcy5hbGxvd3NVc2luZygpKSB7XG4gICAgICAgICAgdGhpcy5yYWlzZShFcnJvcnMuVW5leHBlY3RlZFVzaW5nRGVjbGFyYXRpb24sIHRoaXMuc3RhdGUuc3RhcnRMb2MpO1xuICAgICAgICB9IGVsc2UgaWYgKCFhbGxvd0RlY2xhcmF0aW9uKSB7XG4gICAgICAgICAgdGhpcy5yYWlzZShFcnJvcnMuVW5leHBlY3RlZExleGljYWxEZWNsYXJhdGlvbiwgdGhpcy5zdGF0ZS5zdGFydExvYyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VWYXJTdGF0ZW1lbnQobm9kZSwgXCJ1c2luZ1wiKTtcbiAgICAgIGNhc2UgMTAwOlxuICAgICAgICB7XG4gICAgICAgICAgaWYgKHRoaXMuc3RhdGUuY29udGFpbnNFc2MpIHtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjb25zdCBuZXh0ID0gdGhpcy5uZXh0VG9rZW5TdGFydCgpO1xuICAgICAgICAgIGNvbnN0IG5leHRDaCA9IHRoaXMuY29kZVBvaW50QXRQb3MobmV4dCk7XG4gICAgICAgICAgaWYgKG5leHRDaCAhPT0gOTEpIHtcbiAgICAgICAgICAgIGlmICghYWxsb3dEZWNsYXJhdGlvbiAmJiB0aGlzLmhhc0ZvbGxvd2luZ0xpbmVCcmVhaygpKSBicmVhaztcbiAgICAgICAgICAgIGlmICghdGhpcy5jaFN0YXJ0c0JpbmRpbmdJZGVudGlmaWVyKG5leHRDaCwgbmV4dCkgJiYgbmV4dENoICE9PSAxMjMpIHtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICBjYXNlIDc1OlxuICAgICAgICB7XG4gICAgICAgICAgaWYgKCFhbGxvd0RlY2xhcmF0aW9uKSB7XG4gICAgICAgICAgICB0aGlzLnJhaXNlKEVycm9ycy5VbmV4cGVjdGVkTGV4aWNhbERlY2xhcmF0aW9uLCB0aGlzLnN0YXRlLnN0YXJ0TG9jKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIGNhc2UgNzQ6XG4gICAgICAgIHtcbiAgICAgICAgICBjb25zdCBraW5kID0gdGhpcy5zdGF0ZS52YWx1ZTtcbiAgICAgICAgICByZXR1cm4gdGhpcy5wYXJzZVZhclN0YXRlbWVudChub2RlLCBraW5kKTtcbiAgICAgICAgfVxuICAgICAgY2FzZSA5MjpcbiAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VXaGlsZVN0YXRlbWVudChub2RlKTtcbiAgICAgIGNhc2UgNzY6XG4gICAgICAgIHJldHVybiB0aGlzLnBhcnNlV2l0aFN0YXRlbWVudChub2RlKTtcbiAgICAgIGNhc2UgNTpcbiAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VCbG9jaygpO1xuICAgICAgY2FzZSAxMzpcbiAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VFbXB0eVN0YXRlbWVudChub2RlKTtcbiAgICAgIGNhc2UgODM6XG4gICAgICAgIHtcbiAgICAgICAgICBjb25zdCBuZXh0VG9rZW5DaGFyQ29kZSA9IHRoaXMubG9va2FoZWFkQ2hhckNvZGUoKTtcbiAgICAgICAgICBpZiAobmV4dFRva2VuQ2hhckNvZGUgPT09IDQwIHx8IG5leHRUb2tlbkNoYXJDb2RlID09PSA0Nikge1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICBjYXNlIDgyOlxuICAgICAgICB7XG4gICAgICAgICAgaWYgKCEodGhpcy5vcHRpb25GbGFncyAmIDgpICYmICF0b3BMZXZlbCkge1xuICAgICAgICAgICAgdGhpcy5yYWlzZShFcnJvcnMuVW5leHBlY3RlZEltcG9ydEV4cG9ydCwgdGhpcy5zdGF0ZS5zdGFydExvYyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHRoaXMubmV4dCgpO1xuICAgICAgICAgIGxldCByZXN1bHQ7XG4gICAgICAgICAgaWYgKHN0YXJ0VHlwZSA9PT0gODMpIHtcbiAgICAgICAgICAgIHJlc3VsdCA9IHRoaXMucGFyc2VJbXBvcnQobm9kZSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJlc3VsdCA9IHRoaXMucGFyc2VFeHBvcnQobm9kZSwgZGVjb3JhdG9ycyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHRoaXMuYXNzZXJ0TW9kdWxlTm9kZUFsbG93ZWQocmVzdWx0KTtcbiAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9XG4gICAgICBkZWZhdWx0OlxuICAgICAgICB7XG4gICAgICAgICAgaWYgKHRoaXMuaXNBc3luY0Z1bmN0aW9uKCkpIHtcbiAgICAgICAgICAgIGlmICghYWxsb3dEZWNsYXJhdGlvbikge1xuICAgICAgICAgICAgICB0aGlzLnJhaXNlKEVycm9ycy5Bc3luY0Z1bmN0aW9uSW5TaW5nbGVTdGF0ZW1lbnRDb250ZXh0LCB0aGlzLnN0YXRlLnN0YXJ0TG9jKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMubmV4dCgpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VGdW5jdGlvblN0YXRlbWVudChub2RlLCB0cnVlLCAhYWxsb3dEZWNsYXJhdGlvbiAmJiBhbGxvd0Z1bmN0aW9uRGVjbGFyYXRpb24pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBjb25zdCBtYXliZU5hbWUgPSB0aGlzLnN0YXRlLnZhbHVlO1xuICAgIGNvbnN0IGV4cHIgPSB0aGlzLnBhcnNlRXhwcmVzc2lvbigpO1xuICAgIGlmICh0b2tlbklzSWRlbnRpZmllcihzdGFydFR5cGUpICYmIGV4cHIudHlwZSA9PT0gXCJJZGVudGlmaWVyXCIgJiYgdGhpcy5lYXQoMTQpKSB7XG4gICAgICByZXR1cm4gdGhpcy5wYXJzZUxhYmVsZWRTdGF0ZW1lbnQobm9kZSwgbWF5YmVOYW1lLCBleHByLCBmbGFncyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiB0aGlzLnBhcnNlRXhwcmVzc2lvblN0YXRlbWVudChub2RlLCBleHByLCBkZWNvcmF0b3JzKTtcbiAgICB9XG4gIH1cbiAgYXNzZXJ0TW9kdWxlTm9kZUFsbG93ZWQobm9kZSkge1xuICAgIGlmICghKHRoaXMub3B0aW9uRmxhZ3MgJiA4KSAmJiAhdGhpcy5pbk1vZHVsZSkge1xuICAgICAgdGhpcy5yYWlzZShFcnJvcnMuSW1wb3J0T3V0c2lkZU1vZHVsZSwgbm9kZSk7XG4gICAgfVxuICB9XG4gIGRlY29yYXRvcnNFbmFibGVkQmVmb3JlRXhwb3J0KCkge1xuICAgIGlmICh0aGlzLmhhc1BsdWdpbihcImRlY29yYXRvcnMtbGVnYWN5XCIpKSByZXR1cm4gdHJ1ZTtcbiAgICByZXR1cm4gdGhpcy5oYXNQbHVnaW4oXCJkZWNvcmF0b3JzXCIpICYmIHRoaXMuZ2V0UGx1Z2luT3B0aW9uKFwiZGVjb3JhdG9yc1wiLCBcImRlY29yYXRvcnNCZWZvcmVFeHBvcnRcIikgIT09IGZhbHNlO1xuICB9XG4gIG1heWJlVGFrZURlY29yYXRvcnMobWF5YmVEZWNvcmF0b3JzLCBjbGFzc05vZGUsIGV4cG9ydE5vZGUpIHtcbiAgICBpZiAobWF5YmVEZWNvcmF0b3JzKSB7XG4gICAgICB2YXIgX2NsYXNzTm9kZSRkZWNvcmF0b3JzO1xuICAgICAgaWYgKChfY2xhc3NOb2RlJGRlY29yYXRvcnMgPSBjbGFzc05vZGUuZGVjb3JhdG9ycykgIT0gbnVsbCAmJiBfY2xhc3NOb2RlJGRlY29yYXRvcnMubGVuZ3RoKSB7XG4gICAgICAgIGlmICh0eXBlb2YgdGhpcy5nZXRQbHVnaW5PcHRpb24oXCJkZWNvcmF0b3JzXCIsIFwiZGVjb3JhdG9yc0JlZm9yZUV4cG9ydFwiKSAhPT0gXCJib29sZWFuXCIpIHtcbiAgICAgICAgICB0aGlzLnJhaXNlKEVycm9ycy5EZWNvcmF0b3JzQmVmb3JlQWZ0ZXJFeHBvcnQsIGNsYXNzTm9kZS5kZWNvcmF0b3JzWzBdKTtcbiAgICAgICAgfVxuICAgICAgICBjbGFzc05vZGUuZGVjb3JhdG9ycy51bnNoaWZ0KC4uLm1heWJlRGVjb3JhdG9ycyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjbGFzc05vZGUuZGVjb3JhdG9ycyA9IG1heWJlRGVjb3JhdG9ycztcbiAgICAgIH1cbiAgICAgIHRoaXMucmVzZXRTdGFydExvY2F0aW9uRnJvbU5vZGUoY2xhc3NOb2RlLCBtYXliZURlY29yYXRvcnNbMF0pO1xuICAgICAgaWYgKGV4cG9ydE5vZGUpIHRoaXMucmVzZXRTdGFydExvY2F0aW9uRnJvbU5vZGUoZXhwb3J0Tm9kZSwgY2xhc3NOb2RlKTtcbiAgICB9XG4gICAgcmV0dXJuIGNsYXNzTm9kZTtcbiAgfVxuICBjYW5IYXZlTGVhZGluZ0RlY29yYXRvcigpIHtcbiAgICByZXR1cm4gdGhpcy5tYXRjaCg4MCk7XG4gIH1cbiAgcGFyc2VEZWNvcmF0b3JzKGFsbG93RXhwb3J0KSB7XG4gICAgY29uc3QgZGVjb3JhdG9ycyA9IFtdO1xuICAgIGRvIHtcbiAgICAgIGRlY29yYXRvcnMucHVzaCh0aGlzLnBhcnNlRGVjb3JhdG9yKCkpO1xuICAgIH0gd2hpbGUgKHRoaXMubWF0Y2goMjYpKTtcbiAgICBpZiAodGhpcy5tYXRjaCg4MikpIHtcbiAgICAgIGlmICghYWxsb3dFeHBvcnQpIHtcbiAgICAgICAgdGhpcy51bmV4cGVjdGVkKCk7XG4gICAgICB9XG4gICAgICBpZiAoIXRoaXMuZGVjb3JhdG9yc0VuYWJsZWRCZWZvcmVFeHBvcnQoKSkge1xuICAgICAgICB0aGlzLnJhaXNlKEVycm9ycy5EZWNvcmF0b3JFeHBvcnRDbGFzcywgdGhpcy5zdGF0ZS5zdGFydExvYyk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmICghdGhpcy5jYW5IYXZlTGVhZGluZ0RlY29yYXRvcigpKSB7XG4gICAgICB0aHJvdyB0aGlzLnJhaXNlKEVycm9ycy5VbmV4cGVjdGVkTGVhZGluZ0RlY29yYXRvciwgdGhpcy5zdGF0ZS5zdGFydExvYyk7XG4gICAgfVxuICAgIHJldHVybiBkZWNvcmF0b3JzO1xuICB9XG4gIHBhcnNlRGVjb3JhdG9yKCkge1xuICAgIHRoaXMuZXhwZWN0T25lUGx1Z2luKFtcImRlY29yYXRvcnNcIiwgXCJkZWNvcmF0b3JzLWxlZ2FjeVwiXSk7XG4gICAgY29uc3Qgbm9kZSA9IHRoaXMuc3RhcnROb2RlKCk7XG4gICAgdGhpcy5uZXh0KCk7XG4gICAgaWYgKHRoaXMuaGFzUGx1Z2luKFwiZGVjb3JhdG9yc1wiKSkge1xuICAgICAgY29uc3Qgc3RhcnRMb2MgPSB0aGlzLnN0YXRlLnN0YXJ0TG9jO1xuICAgICAgbGV0IGV4cHI7XG4gICAgICBpZiAodGhpcy5tYXRjaCgxMCkpIHtcbiAgICAgICAgY29uc3Qgc3RhcnRMb2MgPSB0aGlzLnN0YXRlLnN0YXJ0TG9jO1xuICAgICAgICB0aGlzLm5leHQoKTtcbiAgICAgICAgZXhwciA9IHRoaXMucGFyc2VFeHByZXNzaW9uKCk7XG4gICAgICAgIHRoaXMuZXhwZWN0KDExKTtcbiAgICAgICAgZXhwciA9IHRoaXMud3JhcFBhcmVudGhlc2lzKHN0YXJ0TG9jLCBleHByKTtcbiAgICAgICAgY29uc3QgcGFyYW1zU3RhcnRMb2MgPSB0aGlzLnN0YXRlLnN0YXJ0TG9jO1xuICAgICAgICBub2RlLmV4cHJlc3Npb24gPSB0aGlzLnBhcnNlTWF5YmVEZWNvcmF0b3JBcmd1bWVudHMoZXhwciwgc3RhcnRMb2MpO1xuICAgICAgICBpZiAodGhpcy5nZXRQbHVnaW5PcHRpb24oXCJkZWNvcmF0b3JzXCIsIFwiYWxsb3dDYWxsUGFyZW50aGVzaXplZFwiKSA9PT0gZmFsc2UgJiYgbm9kZS5leHByZXNzaW9uICE9PSBleHByKSB7XG4gICAgICAgICAgdGhpcy5yYWlzZShFcnJvcnMuRGVjb3JhdG9yQXJndW1lbnRzT3V0c2lkZVBhcmVudGhlc2VzLCBwYXJhbXNTdGFydExvYyk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGV4cHIgPSB0aGlzLnBhcnNlSWRlbnRpZmllcihmYWxzZSk7XG4gICAgICAgIHdoaWxlICh0aGlzLmVhdCgxNikpIHtcbiAgICAgICAgICBjb25zdCBub2RlID0gdGhpcy5zdGFydE5vZGVBdChzdGFydExvYyk7XG4gICAgICAgICAgbm9kZS5vYmplY3QgPSBleHByO1xuICAgICAgICAgIGlmICh0aGlzLm1hdGNoKDEzOSkpIHtcbiAgICAgICAgICAgIHRoaXMuY2xhc3NTY29wZS51c2VQcml2YXRlTmFtZSh0aGlzLnN0YXRlLnZhbHVlLCB0aGlzLnN0YXRlLnN0YXJ0TG9jKTtcbiAgICAgICAgICAgIG5vZGUucHJvcGVydHkgPSB0aGlzLnBhcnNlUHJpdmF0ZU5hbWUoKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbm9kZS5wcm9wZXJ0eSA9IHRoaXMucGFyc2VJZGVudGlmaWVyKHRydWUpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBub2RlLmNvbXB1dGVkID0gZmFsc2U7XG4gICAgICAgICAgZXhwciA9IHRoaXMuZmluaXNoTm9kZShub2RlLCBcIk1lbWJlckV4cHJlc3Npb25cIik7XG4gICAgICAgIH1cbiAgICAgICAgbm9kZS5leHByZXNzaW9uID0gdGhpcy5wYXJzZU1heWJlRGVjb3JhdG9yQXJndW1lbnRzKGV4cHIsIHN0YXJ0TG9jKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgbm9kZS5leHByZXNzaW9uID0gdGhpcy5wYXJzZUV4cHJTdWJzY3JpcHRzKCk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJEZWNvcmF0b3JcIik7XG4gIH1cbiAgcGFyc2VNYXliZURlY29yYXRvckFyZ3VtZW50cyhleHByLCBzdGFydExvYykge1xuICAgIGlmICh0aGlzLmVhdCgxMCkpIHtcbiAgICAgIGNvbnN0IG5vZGUgPSB0aGlzLnN0YXJ0Tm9kZUF0KHN0YXJ0TG9jKTtcbiAgICAgIG5vZGUuY2FsbGVlID0gZXhwcjtcbiAgICAgIG5vZGUuYXJndW1lbnRzID0gdGhpcy5wYXJzZUNhbGxFeHByZXNzaW9uQXJndW1lbnRzKCk7XG4gICAgICB0aGlzLnRvUmVmZXJlbmNlZExpc3Qobm9kZS5hcmd1bWVudHMpO1xuICAgICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIkNhbGxFeHByZXNzaW9uXCIpO1xuICAgIH1cbiAgICByZXR1cm4gZXhwcjtcbiAgfVxuICBwYXJzZUJyZWFrQ29udGludWVTdGF0ZW1lbnQobm9kZSwgaXNCcmVhaykge1xuICAgIHRoaXMubmV4dCgpO1xuICAgIGlmICh0aGlzLmlzTGluZVRlcm1pbmF0b3IoKSkge1xuICAgICAgbm9kZS5sYWJlbCA9IG51bGw7XG4gICAgfSBlbHNlIHtcbiAgICAgIG5vZGUubGFiZWwgPSB0aGlzLnBhcnNlSWRlbnRpZmllcigpO1xuICAgICAgdGhpcy5zZW1pY29sb24oKTtcbiAgICB9XG4gICAgdGhpcy52ZXJpZnlCcmVha0NvbnRpbnVlKG5vZGUsIGlzQnJlYWspO1xuICAgIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgaXNCcmVhayA/IFwiQnJlYWtTdGF0ZW1lbnRcIiA6IFwiQ29udGludWVTdGF0ZW1lbnRcIik7XG4gIH1cbiAgdmVyaWZ5QnJlYWtDb250aW51ZShub2RlLCBpc0JyZWFrKSB7XG4gICAgbGV0IGk7XG4gICAgZm9yIChpID0gMDsgaSA8IHRoaXMuc3RhdGUubGFiZWxzLmxlbmd0aDsgKytpKSB7XG4gICAgICBjb25zdCBsYWIgPSB0aGlzLnN0YXRlLmxhYmVsc1tpXTtcbiAgICAgIGlmIChub2RlLmxhYmVsID09IG51bGwgfHwgbGFiLm5hbWUgPT09IG5vZGUubGFiZWwubmFtZSkge1xuICAgICAgICBpZiAobGFiLmtpbmQgIT0gbnVsbCAmJiAoaXNCcmVhayB8fCBsYWIua2luZCA9PT0gMSkpIHtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBpZiAobm9kZS5sYWJlbCAmJiBpc0JyZWFrKSBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGkgPT09IHRoaXMuc3RhdGUubGFiZWxzLmxlbmd0aCkge1xuICAgICAgY29uc3QgdHlwZSA9IGlzQnJlYWsgPyBcIkJyZWFrU3RhdGVtZW50XCIgOiBcIkNvbnRpbnVlU3RhdGVtZW50XCI7XG4gICAgICB0aGlzLnJhaXNlKEVycm9ycy5JbGxlZ2FsQnJlYWtDb250aW51ZSwgbm9kZSwge1xuICAgICAgICB0eXBlXG4gICAgICB9KTtcbiAgICB9XG4gIH1cbiAgcGFyc2VEZWJ1Z2dlclN0YXRlbWVudChub2RlKSB7XG4gICAgdGhpcy5uZXh0KCk7XG4gICAgdGhpcy5zZW1pY29sb24oKTtcbiAgICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiRGVidWdnZXJTdGF0ZW1lbnRcIik7XG4gIH1cbiAgcGFyc2VIZWFkZXJFeHByZXNzaW9uKCkge1xuICAgIHRoaXMuZXhwZWN0KDEwKTtcbiAgICBjb25zdCB2YWwgPSB0aGlzLnBhcnNlRXhwcmVzc2lvbigpO1xuICAgIHRoaXMuZXhwZWN0KDExKTtcbiAgICByZXR1cm4gdmFsO1xuICB9XG4gIHBhcnNlRG9XaGlsZVN0YXRlbWVudChub2RlKSB7XG4gICAgdGhpcy5uZXh0KCk7XG4gICAgdGhpcy5zdGF0ZS5sYWJlbHMucHVzaChsb29wTGFiZWwpO1xuICAgIG5vZGUuYm9keSA9IHRoaXMud2l0aFNtYXJ0TWl4VG9waWNGb3JiaWRkaW5nQ29udGV4dCgoKSA9PiB0aGlzLnBhcnNlU3RhdGVtZW50KCkpO1xuICAgIHRoaXMuc3RhdGUubGFiZWxzLnBvcCgpO1xuICAgIHRoaXMuZXhwZWN0KDkyKTtcbiAgICBub2RlLnRlc3QgPSB0aGlzLnBhcnNlSGVhZGVyRXhwcmVzc2lvbigpO1xuICAgIHRoaXMuZWF0KDEzKTtcbiAgICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiRG9XaGlsZVN0YXRlbWVudFwiKTtcbiAgfVxuICBwYXJzZUZvclN0YXRlbWVudChub2RlKSB7XG4gICAgdGhpcy5uZXh0KCk7XG4gICAgdGhpcy5zdGF0ZS5sYWJlbHMucHVzaChsb29wTGFiZWwpO1xuICAgIGxldCBhd2FpdEF0ID0gbnVsbDtcbiAgICBpZiAodGhpcy5pc0NvbnRleHR1YWwoOTYpICYmIHRoaXMucmVjb3JkQXdhaXRJZkFsbG93ZWQoKSkge1xuICAgICAgYXdhaXRBdCA9IHRoaXMuc3RhdGUuc3RhcnRMb2M7XG4gICAgICB0aGlzLm5leHQoKTtcbiAgICB9XG4gICAgdGhpcy5zY29wZS5lbnRlcigwKTtcbiAgICB0aGlzLmV4cGVjdCgxMCk7XG4gICAgaWYgKHRoaXMubWF0Y2goMTMpKSB7XG4gICAgICBpZiAoYXdhaXRBdCAhPT0gbnVsbCkge1xuICAgICAgICB0aGlzLnVuZXhwZWN0ZWQoYXdhaXRBdCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcy5wYXJzZUZvcihub2RlLCBudWxsKTtcbiAgICB9XG4gICAgY29uc3Qgc3RhcnRzV2l0aExldCA9IHRoaXMuaXNDb250ZXh0dWFsKDEwMCk7XG4gICAge1xuICAgICAgY29uc3Qgc3RhcnRzV2l0aEF3YWl0VXNpbmcgPSB0aGlzLmlzQXdhaXRVc2luZygpO1xuICAgICAgY29uc3Qgc3RhcnNXaXRoVXNpbmdEZWNsYXJhdGlvbiA9IHN0YXJ0c1dpdGhBd2FpdFVzaW5nIHx8IHRoaXMuaXNGb3JVc2luZygpO1xuICAgICAgY29uc3QgaXNMZXRPclVzaW5nID0gc3RhcnRzV2l0aExldCAmJiB0aGlzLmhhc0ZvbGxvd2luZ0JpbmRpbmdBdG9tKCkgfHwgc3RhcnNXaXRoVXNpbmdEZWNsYXJhdGlvbjtcbiAgICAgIGlmICh0aGlzLm1hdGNoKDc0KSB8fCB0aGlzLm1hdGNoKDc1KSB8fCBpc0xldE9yVXNpbmcpIHtcbiAgICAgICAgY29uc3QgaW5pdE5vZGUgPSB0aGlzLnN0YXJ0Tm9kZSgpO1xuICAgICAgICBsZXQga2luZDtcbiAgICAgICAgaWYgKHN0YXJ0c1dpdGhBd2FpdFVzaW5nKSB7XG4gICAgICAgICAga2luZCA9IFwiYXdhaXQgdXNpbmdcIjtcbiAgICAgICAgICBpZiAoIXRoaXMucmVjb3JkQXdhaXRJZkFsbG93ZWQoKSkge1xuICAgICAgICAgICAgdGhpcy5yYWlzZShFcnJvcnMuQXdhaXRVc2luZ05vdEluQXN5bmNDb250ZXh0LCB0aGlzLnN0YXRlLnN0YXJ0TG9jKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdGhpcy5uZXh0KCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAga2luZCA9IHRoaXMuc3RhdGUudmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5uZXh0KCk7XG4gICAgICAgIHRoaXMucGFyc2VWYXIoaW5pdE5vZGUsIHRydWUsIGtpbmQpO1xuICAgICAgICBjb25zdCBpbml0ID0gdGhpcy5maW5pc2hOb2RlKGluaXROb2RlLCBcIlZhcmlhYmxlRGVjbGFyYXRpb25cIik7XG4gICAgICAgIGNvbnN0IGlzRm9ySW4gPSB0aGlzLm1hdGNoKDU4KTtcbiAgICAgICAgaWYgKGlzRm9ySW4gJiYgc3RhcnNXaXRoVXNpbmdEZWNsYXJhdGlvbikge1xuICAgICAgICAgIHRoaXMucmFpc2UoRXJyb3JzLkZvckluVXNpbmcsIGluaXQpO1xuICAgICAgICB9XG4gICAgICAgIGlmICgoaXNGb3JJbiB8fCB0aGlzLmlzQ29udGV4dHVhbCgxMDIpKSAmJiBpbml0LmRlY2xhcmF0aW9ucy5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5wYXJzZUZvckluKG5vZGUsIGluaXQsIGF3YWl0QXQpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChhd2FpdEF0ICE9PSBudWxsKSB7XG4gICAgICAgICAgdGhpcy51bmV4cGVjdGVkKGF3YWl0QXQpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLnBhcnNlRm9yKG5vZGUsIGluaXQpO1xuICAgICAgfVxuICAgIH1cbiAgICBjb25zdCBzdGFydHNXaXRoQXN5bmMgPSB0aGlzLmlzQ29udGV4dHVhbCg5NSk7XG4gICAgY29uc3QgcmVmRXhwcmVzc2lvbkVycm9ycyA9IG5ldyBFeHByZXNzaW9uRXJyb3JzKCk7XG4gICAgY29uc3QgaW5pdCA9IHRoaXMucGFyc2VFeHByZXNzaW9uKHRydWUsIHJlZkV4cHJlc3Npb25FcnJvcnMpO1xuICAgIGNvbnN0IGlzRm9yT2YgPSB0aGlzLmlzQ29udGV4dHVhbCgxMDIpO1xuICAgIGlmIChpc0Zvck9mKSB7XG4gICAgICBpZiAoc3RhcnRzV2l0aExldCkge1xuICAgICAgICB0aGlzLnJhaXNlKEVycm9ycy5Gb3JPZkxldCwgaW5pdCk7XG4gICAgICB9XG4gICAgICBpZiAoYXdhaXRBdCA9PT0gbnVsbCAmJiBzdGFydHNXaXRoQXN5bmMgJiYgaW5pdC50eXBlID09PSBcIklkZW50aWZpZXJcIikge1xuICAgICAgICB0aGlzLnJhaXNlKEVycm9ycy5Gb3JPZkFzeW5jLCBpbml0KTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGlzRm9yT2YgfHwgdGhpcy5tYXRjaCg1OCkpIHtcbiAgICAgIHRoaXMuY2hlY2tEZXN0cnVjdHVyaW5nUHJpdmF0ZShyZWZFeHByZXNzaW9uRXJyb3JzKTtcbiAgICAgIHRoaXMudG9Bc3NpZ25hYmxlKGluaXQsIHRydWUpO1xuICAgICAgY29uc3QgdHlwZSA9IGlzRm9yT2YgPyBcIkZvck9mU3RhdGVtZW50XCIgOiBcIkZvckluU3RhdGVtZW50XCI7XG4gICAgICB0aGlzLmNoZWNrTFZhbChpbml0LCB7XG4gICAgICAgIHR5cGVcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIHRoaXMucGFyc2VGb3JJbihub2RlLCBpbml0LCBhd2FpdEF0KTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5jaGVja0V4cHJlc3Npb25FcnJvcnMocmVmRXhwcmVzc2lvbkVycm9ycywgdHJ1ZSk7XG4gICAgfVxuICAgIGlmIChhd2FpdEF0ICE9PSBudWxsKSB7XG4gICAgICB0aGlzLnVuZXhwZWN0ZWQoYXdhaXRBdCk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLnBhcnNlRm9yKG5vZGUsIGluaXQpO1xuICB9XG4gIHBhcnNlRnVuY3Rpb25TdGF0ZW1lbnQobm9kZSwgaXNBc3luYywgaXNIYW5naW5nRGVjbGFyYXRpb24pIHtcbiAgICB0aGlzLm5leHQoKTtcbiAgICByZXR1cm4gdGhpcy5wYXJzZUZ1bmN0aW9uKG5vZGUsIDEgfCAoaXNIYW5naW5nRGVjbGFyYXRpb24gPyAyIDogMCkgfCAoaXNBc3luYyA/IDggOiAwKSk7XG4gIH1cbiAgcGFyc2VJZlN0YXRlbWVudChub2RlKSB7XG4gICAgdGhpcy5uZXh0KCk7XG4gICAgbm9kZS50ZXN0ID0gdGhpcy5wYXJzZUhlYWRlckV4cHJlc3Npb24oKTtcbiAgICBub2RlLmNvbnNlcXVlbnQgPSB0aGlzLnBhcnNlU3RhdGVtZW50T3JTbG9wcHlBbm5leEJGdW5jdGlvbkRlY2xhcmF0aW9uKCk7XG4gICAgbm9kZS5hbHRlcm5hdGUgPSB0aGlzLmVhdCg2NikgPyB0aGlzLnBhcnNlU3RhdGVtZW50T3JTbG9wcHlBbm5leEJGdW5jdGlvbkRlY2xhcmF0aW9uKCkgOiBudWxsO1xuICAgIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJJZlN0YXRlbWVudFwiKTtcbiAgfVxuICBwYXJzZVJldHVyblN0YXRlbWVudChub2RlKSB7XG4gICAgaWYgKCF0aGlzLnByb2RQYXJhbS5oYXNSZXR1cm4pIHtcbiAgICAgIHRoaXMucmFpc2UoRXJyb3JzLklsbGVnYWxSZXR1cm4sIHRoaXMuc3RhdGUuc3RhcnRMb2MpO1xuICAgIH1cbiAgICB0aGlzLm5leHQoKTtcbiAgICBpZiAodGhpcy5pc0xpbmVUZXJtaW5hdG9yKCkpIHtcbiAgICAgIG5vZGUuYXJndW1lbnQgPSBudWxsO1xuICAgIH0gZWxzZSB7XG4gICAgICBub2RlLmFyZ3VtZW50ID0gdGhpcy5wYXJzZUV4cHJlc3Npb24oKTtcbiAgICAgIHRoaXMuc2VtaWNvbG9uKCk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJSZXR1cm5TdGF0ZW1lbnRcIik7XG4gIH1cbiAgcGFyc2VTd2l0Y2hTdGF0ZW1lbnQobm9kZSkge1xuICAgIHRoaXMubmV4dCgpO1xuICAgIG5vZGUuZGlzY3JpbWluYW50ID0gdGhpcy5wYXJzZUhlYWRlckV4cHJlc3Npb24oKTtcbiAgICBjb25zdCBjYXNlcyA9IG5vZGUuY2FzZXMgPSBbXTtcbiAgICB0aGlzLmV4cGVjdCg1KTtcbiAgICB0aGlzLnN0YXRlLmxhYmVscy5wdXNoKHN3aXRjaExhYmVsKTtcbiAgICB0aGlzLnNjb3BlLmVudGVyKDI1Nik7XG4gICAgbGV0IGN1cjtcbiAgICBmb3IgKGxldCBzYXdEZWZhdWx0OyAhdGhpcy5tYXRjaCg4KTspIHtcbiAgICAgIGlmICh0aGlzLm1hdGNoKDYxKSB8fCB0aGlzLm1hdGNoKDY1KSkge1xuICAgICAgICBjb25zdCBpc0Nhc2UgPSB0aGlzLm1hdGNoKDYxKTtcbiAgICAgICAgaWYgKGN1cikgdGhpcy5maW5pc2hOb2RlKGN1ciwgXCJTd2l0Y2hDYXNlXCIpO1xuICAgICAgICBjYXNlcy5wdXNoKGN1ciA9IHRoaXMuc3RhcnROb2RlKCkpO1xuICAgICAgICBjdXIuY29uc2VxdWVudCA9IFtdO1xuICAgICAgICB0aGlzLm5leHQoKTtcbiAgICAgICAgaWYgKGlzQ2FzZSkge1xuICAgICAgICAgIGN1ci50ZXN0ID0gdGhpcy5wYXJzZUV4cHJlc3Npb24oKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpZiAoc2F3RGVmYXVsdCkge1xuICAgICAgICAgICAgdGhpcy5yYWlzZShFcnJvcnMuTXVsdGlwbGVEZWZhdWx0c0luU3dpdGNoLCB0aGlzLnN0YXRlLmxhc3RUb2tTdGFydExvYyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHNhd0RlZmF1bHQgPSB0cnVlO1xuICAgICAgICAgIGN1ci50ZXN0ID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmV4cGVjdCgxNCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoY3VyKSB7XG4gICAgICAgICAgY3VyLmNvbnNlcXVlbnQucHVzaCh0aGlzLnBhcnNlU3RhdGVtZW50TGlzdEl0ZW0oKSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy51bmV4cGVjdGVkKCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgdGhpcy5zY29wZS5leGl0KCk7XG4gICAgaWYgKGN1cikgdGhpcy5maW5pc2hOb2RlKGN1ciwgXCJTd2l0Y2hDYXNlXCIpO1xuICAgIHRoaXMubmV4dCgpO1xuICAgIHRoaXMuc3RhdGUubGFiZWxzLnBvcCgpO1xuICAgIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJTd2l0Y2hTdGF0ZW1lbnRcIik7XG4gIH1cbiAgcGFyc2VUaHJvd1N0YXRlbWVudChub2RlKSB7XG4gICAgdGhpcy5uZXh0KCk7XG4gICAgaWYgKHRoaXMuaGFzUHJlY2VkaW5nTGluZUJyZWFrKCkpIHtcbiAgICAgIHRoaXMucmFpc2UoRXJyb3JzLk5ld2xpbmVBZnRlclRocm93LCB0aGlzLnN0YXRlLmxhc3RUb2tFbmRMb2MpO1xuICAgIH1cbiAgICBub2RlLmFyZ3VtZW50ID0gdGhpcy5wYXJzZUV4cHJlc3Npb24oKTtcbiAgICB0aGlzLnNlbWljb2xvbigpO1xuICAgIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJUaHJvd1N0YXRlbWVudFwiKTtcbiAgfVxuICBwYXJzZUNhdGNoQ2xhdXNlUGFyYW0oKSB7XG4gICAgY29uc3QgcGFyYW0gPSB0aGlzLnBhcnNlQmluZGluZ0F0b20oKTtcbiAgICB0aGlzLnNjb3BlLmVudGVyKHRoaXMub3B0aW9ucy5hbm5leEIgJiYgcGFyYW0udHlwZSA9PT0gXCJJZGVudGlmaWVyXCIgPyA4IDogMCk7XG4gICAgdGhpcy5jaGVja0xWYWwocGFyYW0sIHtcbiAgICAgIHR5cGU6IFwiQ2F0Y2hDbGF1c2VcIlxuICAgIH0sIDkpO1xuICAgIHJldHVybiBwYXJhbTtcbiAgfVxuICBwYXJzZVRyeVN0YXRlbWVudChub2RlKSB7XG4gICAgdGhpcy5uZXh0KCk7XG4gICAgbm9kZS5ibG9jayA9IHRoaXMucGFyc2VCbG9jaygpO1xuICAgIG5vZGUuaGFuZGxlciA9IG51bGw7XG4gICAgaWYgKHRoaXMubWF0Y2goNjIpKSB7XG4gICAgICBjb25zdCBjbGF1c2UgPSB0aGlzLnN0YXJ0Tm9kZSgpO1xuICAgICAgdGhpcy5uZXh0KCk7XG4gICAgICBpZiAodGhpcy5tYXRjaCgxMCkpIHtcbiAgICAgICAgdGhpcy5leHBlY3QoMTApO1xuICAgICAgICBjbGF1c2UucGFyYW0gPSB0aGlzLnBhcnNlQ2F0Y2hDbGF1c2VQYXJhbSgpO1xuICAgICAgICB0aGlzLmV4cGVjdCgxMSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjbGF1c2UucGFyYW0gPSBudWxsO1xuICAgICAgICB0aGlzLnNjb3BlLmVudGVyKDApO1xuICAgICAgfVxuICAgICAgY2xhdXNlLmJvZHkgPSB0aGlzLndpdGhTbWFydE1peFRvcGljRm9yYmlkZGluZ0NvbnRleHQoKCkgPT4gdGhpcy5wYXJzZUJsb2NrKGZhbHNlLCBmYWxzZSkpO1xuICAgICAgdGhpcy5zY29wZS5leGl0KCk7XG4gICAgICBub2RlLmhhbmRsZXIgPSB0aGlzLmZpbmlzaE5vZGUoY2xhdXNlLCBcIkNhdGNoQ2xhdXNlXCIpO1xuICAgIH1cbiAgICBub2RlLmZpbmFsaXplciA9IHRoaXMuZWF0KDY3KSA/IHRoaXMucGFyc2VCbG9jaygpIDogbnVsbDtcbiAgICBpZiAoIW5vZGUuaGFuZGxlciAmJiAhbm9kZS5maW5hbGl6ZXIpIHtcbiAgICAgIHRoaXMucmFpc2UoRXJyb3JzLk5vQ2F0Y2hPckZpbmFsbHksIG5vZGUpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiVHJ5U3RhdGVtZW50XCIpO1xuICB9XG4gIHBhcnNlVmFyU3RhdGVtZW50KG5vZGUsIGtpbmQsIGFsbG93TWlzc2luZ0luaXRpYWxpemVyID0gZmFsc2UpIHtcbiAgICB0aGlzLm5leHQoKTtcbiAgICB0aGlzLnBhcnNlVmFyKG5vZGUsIGZhbHNlLCBraW5kLCBhbGxvd01pc3NpbmdJbml0aWFsaXplcik7XG4gICAgdGhpcy5zZW1pY29sb24oKTtcbiAgICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiVmFyaWFibGVEZWNsYXJhdGlvblwiKTtcbiAgfVxuICBwYXJzZVdoaWxlU3RhdGVtZW50KG5vZGUpIHtcbiAgICB0aGlzLm5leHQoKTtcbiAgICBub2RlLnRlc3QgPSB0aGlzLnBhcnNlSGVhZGVyRXhwcmVzc2lvbigpO1xuICAgIHRoaXMuc3RhdGUubGFiZWxzLnB1c2gobG9vcExhYmVsKTtcbiAgICBub2RlLmJvZHkgPSB0aGlzLndpdGhTbWFydE1peFRvcGljRm9yYmlkZGluZ0NvbnRleHQoKCkgPT4gdGhpcy5wYXJzZVN0YXRlbWVudCgpKTtcbiAgICB0aGlzLnN0YXRlLmxhYmVscy5wb3AoKTtcbiAgICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiV2hpbGVTdGF0ZW1lbnRcIik7XG4gIH1cbiAgcGFyc2VXaXRoU3RhdGVtZW50KG5vZGUpIHtcbiAgICBpZiAodGhpcy5zdGF0ZS5zdHJpY3QpIHtcbiAgICAgIHRoaXMucmFpc2UoRXJyb3JzLlN0cmljdFdpdGgsIHRoaXMuc3RhdGUuc3RhcnRMb2MpO1xuICAgIH1cbiAgICB0aGlzLm5leHQoKTtcbiAgICBub2RlLm9iamVjdCA9IHRoaXMucGFyc2VIZWFkZXJFeHByZXNzaW9uKCk7XG4gICAgbm9kZS5ib2R5ID0gdGhpcy53aXRoU21hcnRNaXhUb3BpY0ZvcmJpZGRpbmdDb250ZXh0KCgpID0+IHRoaXMucGFyc2VTdGF0ZW1lbnQoKSk7XG4gICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIldpdGhTdGF0ZW1lbnRcIik7XG4gIH1cbiAgcGFyc2VFbXB0eVN0YXRlbWVudChub2RlKSB7XG4gICAgdGhpcy5uZXh0KCk7XG4gICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIkVtcHR5U3RhdGVtZW50XCIpO1xuICB9XG4gIHBhcnNlTGFiZWxlZFN0YXRlbWVudChub2RlLCBtYXliZU5hbWUsIGV4cHIsIGZsYWdzKSB7XG4gICAgZm9yIChjb25zdCBsYWJlbCBvZiB0aGlzLnN0YXRlLmxhYmVscykge1xuICAgICAgaWYgKGxhYmVsLm5hbWUgPT09IG1heWJlTmFtZSkge1xuICAgICAgICB0aGlzLnJhaXNlKEVycm9ycy5MYWJlbFJlZGVjbGFyYXRpb24sIGV4cHIsIHtcbiAgICAgICAgICBsYWJlbE5hbWU6IG1heWJlTmFtZVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG4gICAgY29uc3Qga2luZCA9IHRva2VuSXNMb29wKHRoaXMuc3RhdGUudHlwZSkgPyAxIDogdGhpcy5tYXRjaCg3MSkgPyAyIDogbnVsbDtcbiAgICBmb3IgKGxldCBpID0gdGhpcy5zdGF0ZS5sYWJlbHMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgIGNvbnN0IGxhYmVsID0gdGhpcy5zdGF0ZS5sYWJlbHNbaV07XG4gICAgICBpZiAobGFiZWwuc3RhdGVtZW50U3RhcnQgPT09IG5vZGUuc3RhcnQpIHtcbiAgICAgICAgbGFiZWwuc3RhdGVtZW50U3RhcnQgPSB0aGlzLnNvdXJjZVRvT2Zmc2V0UG9zKHRoaXMuc3RhdGUuc3RhcnQpO1xuICAgICAgICBsYWJlbC5raW5kID0ga2luZDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgICB0aGlzLnN0YXRlLmxhYmVscy5wdXNoKHtcbiAgICAgIG5hbWU6IG1heWJlTmFtZSxcbiAgICAgIGtpbmQ6IGtpbmQsXG4gICAgICBzdGF0ZW1lbnRTdGFydDogdGhpcy5zb3VyY2VUb09mZnNldFBvcyh0aGlzLnN0YXRlLnN0YXJ0KVxuICAgIH0pO1xuICAgIG5vZGUuYm9keSA9IGZsYWdzICYgOCA/IHRoaXMucGFyc2VTdGF0ZW1lbnRPclNsb3BweUFubmV4QkZ1bmN0aW9uRGVjbGFyYXRpb24odHJ1ZSkgOiB0aGlzLnBhcnNlU3RhdGVtZW50KCk7XG4gICAgdGhpcy5zdGF0ZS5sYWJlbHMucG9wKCk7XG4gICAgbm9kZS5sYWJlbCA9IGV4cHI7XG4gICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIkxhYmVsZWRTdGF0ZW1lbnRcIik7XG4gIH1cbiAgcGFyc2VFeHByZXNzaW9uU3RhdGVtZW50KG5vZGUsIGV4cHIsIGRlY29yYXRvcnMpIHtcbiAgICBub2RlLmV4cHJlc3Npb24gPSBleHByO1xuICAgIHRoaXMuc2VtaWNvbG9uKCk7XG4gICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIkV4cHJlc3Npb25TdGF0ZW1lbnRcIik7XG4gIH1cbiAgcGFyc2VCbG9jayhhbGxvd0RpcmVjdGl2ZXMgPSBmYWxzZSwgY3JlYXRlTmV3TGV4aWNhbFNjb3BlID0gdHJ1ZSwgYWZ0ZXJCbG9ja1BhcnNlKSB7XG4gICAgY29uc3Qgbm9kZSA9IHRoaXMuc3RhcnROb2RlKCk7XG4gICAgaWYgKGFsbG93RGlyZWN0aXZlcykge1xuICAgICAgdGhpcy5zdGF0ZS5zdHJpY3RFcnJvcnMuY2xlYXIoKTtcbiAgICB9XG4gICAgdGhpcy5leHBlY3QoNSk7XG4gICAgaWYgKGNyZWF0ZU5ld0xleGljYWxTY29wZSkge1xuICAgICAgdGhpcy5zY29wZS5lbnRlcigwKTtcbiAgICB9XG4gICAgdGhpcy5wYXJzZUJsb2NrQm9keShub2RlLCBhbGxvd0RpcmVjdGl2ZXMsIGZhbHNlLCA4LCBhZnRlckJsb2NrUGFyc2UpO1xuICAgIGlmIChjcmVhdGVOZXdMZXhpY2FsU2NvcGUpIHtcbiAgICAgIHRoaXMuc2NvcGUuZXhpdCgpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiQmxvY2tTdGF0ZW1lbnRcIik7XG4gIH1cbiAgaXNWYWxpZERpcmVjdGl2ZShzdG10KSB7XG4gICAgcmV0dXJuIHN0bXQudHlwZSA9PT0gXCJFeHByZXNzaW9uU3RhdGVtZW50XCIgJiYgc3RtdC5leHByZXNzaW9uLnR5cGUgPT09IFwiU3RyaW5nTGl0ZXJhbFwiICYmICFzdG10LmV4cHJlc3Npb24uZXh0cmEucGFyZW50aGVzaXplZDtcbiAgfVxuICBwYXJzZUJsb2NrQm9keShub2RlLCBhbGxvd0RpcmVjdGl2ZXMsIHRvcExldmVsLCBlbmQsIGFmdGVyQmxvY2tQYXJzZSkge1xuICAgIGNvbnN0IGJvZHkgPSBub2RlLmJvZHkgPSBbXTtcbiAgICBjb25zdCBkaXJlY3RpdmVzID0gbm9kZS5kaXJlY3RpdmVzID0gW107XG4gICAgdGhpcy5wYXJzZUJsb2NrT3JNb2R1bGVCbG9ja0JvZHkoYm9keSwgYWxsb3dEaXJlY3RpdmVzID8gZGlyZWN0aXZlcyA6IHVuZGVmaW5lZCwgdG9wTGV2ZWwsIGVuZCwgYWZ0ZXJCbG9ja1BhcnNlKTtcbiAgfVxuICBwYXJzZUJsb2NrT3JNb2R1bGVCbG9ja0JvZHkoYm9keSwgZGlyZWN0aXZlcywgdG9wTGV2ZWwsIGVuZCwgYWZ0ZXJCbG9ja1BhcnNlKSB7XG4gICAgY29uc3Qgb2xkU3RyaWN0ID0gdGhpcy5zdGF0ZS5zdHJpY3Q7XG4gICAgbGV0IGhhc1N0cmljdE1vZGVEaXJlY3RpdmUgPSBmYWxzZTtcbiAgICBsZXQgcGFyc2VkTm9uRGlyZWN0aXZlID0gZmFsc2U7XG4gICAgd2hpbGUgKCF0aGlzLm1hdGNoKGVuZCkpIHtcbiAgICAgIGNvbnN0IHN0bXQgPSB0b3BMZXZlbCA/IHRoaXMucGFyc2VNb2R1bGVJdGVtKCkgOiB0aGlzLnBhcnNlU3RhdGVtZW50TGlzdEl0ZW0oKTtcbiAgICAgIGlmIChkaXJlY3RpdmVzICYmICFwYXJzZWROb25EaXJlY3RpdmUpIHtcbiAgICAgICAgaWYgKHRoaXMuaXNWYWxpZERpcmVjdGl2ZShzdG10KSkge1xuICAgICAgICAgIGNvbnN0IGRpcmVjdGl2ZSA9IHRoaXMuc3RtdFRvRGlyZWN0aXZlKHN0bXQpO1xuICAgICAgICAgIGRpcmVjdGl2ZXMucHVzaChkaXJlY3RpdmUpO1xuICAgICAgICAgIGlmICghaGFzU3RyaWN0TW9kZURpcmVjdGl2ZSAmJiBkaXJlY3RpdmUudmFsdWUudmFsdWUgPT09IFwidXNlIHN0cmljdFwiKSB7XG4gICAgICAgICAgICBoYXNTdHJpY3RNb2RlRGlyZWN0aXZlID0gdHJ1ZTtcbiAgICAgICAgICAgIHRoaXMuc2V0U3RyaWN0KHRydWUpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBwYXJzZWROb25EaXJlY3RpdmUgPSB0cnVlO1xuICAgICAgICB0aGlzLnN0YXRlLnN0cmljdEVycm9ycy5jbGVhcigpO1xuICAgICAgfVxuICAgICAgYm9keS5wdXNoKHN0bXQpO1xuICAgIH1cbiAgICBhZnRlckJsb2NrUGFyc2UgPT0gbnVsbCB8fCBhZnRlckJsb2NrUGFyc2UuY2FsbCh0aGlzLCBoYXNTdHJpY3RNb2RlRGlyZWN0aXZlKTtcbiAgICBpZiAoIW9sZFN0cmljdCkge1xuICAgICAgdGhpcy5zZXRTdHJpY3QoZmFsc2UpO1xuICAgIH1cbiAgICB0aGlzLm5leHQoKTtcbiAgfVxuICBwYXJzZUZvcihub2RlLCBpbml0KSB7XG4gICAgbm9kZS5pbml0ID0gaW5pdDtcbiAgICB0aGlzLnNlbWljb2xvbihmYWxzZSk7XG4gICAgbm9kZS50ZXN0ID0gdGhpcy5tYXRjaCgxMykgPyBudWxsIDogdGhpcy5wYXJzZUV4cHJlc3Npb24oKTtcbiAgICB0aGlzLnNlbWljb2xvbihmYWxzZSk7XG4gICAgbm9kZS51cGRhdGUgPSB0aGlzLm1hdGNoKDExKSA/IG51bGwgOiB0aGlzLnBhcnNlRXhwcmVzc2lvbigpO1xuICAgIHRoaXMuZXhwZWN0KDExKTtcbiAgICBub2RlLmJvZHkgPSB0aGlzLndpdGhTbWFydE1peFRvcGljRm9yYmlkZGluZ0NvbnRleHQoKCkgPT4gdGhpcy5wYXJzZVN0YXRlbWVudCgpKTtcbiAgICB0aGlzLnNjb3BlLmV4aXQoKTtcbiAgICB0aGlzLnN0YXRlLmxhYmVscy5wb3AoKTtcbiAgICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiRm9yU3RhdGVtZW50XCIpO1xuICB9XG4gIHBhcnNlRm9ySW4obm9kZSwgaW5pdCwgYXdhaXRBdCkge1xuICAgIGNvbnN0IGlzRm9ySW4gPSB0aGlzLm1hdGNoKDU4KTtcbiAgICB0aGlzLm5leHQoKTtcbiAgICBpZiAoaXNGb3JJbikge1xuICAgICAgaWYgKGF3YWl0QXQgIT09IG51bGwpIHRoaXMudW5leHBlY3RlZChhd2FpdEF0KTtcbiAgICB9IGVsc2Uge1xuICAgICAgbm9kZS5hd2FpdCA9IGF3YWl0QXQgIT09IG51bGw7XG4gICAgfVxuICAgIGlmIChpbml0LnR5cGUgPT09IFwiVmFyaWFibGVEZWNsYXJhdGlvblwiICYmIGluaXQuZGVjbGFyYXRpb25zWzBdLmluaXQgIT0gbnVsbCAmJiAoIWlzRm9ySW4gfHwgIXRoaXMub3B0aW9ucy5hbm5leEIgfHwgdGhpcy5zdGF0ZS5zdHJpY3QgfHwgaW5pdC5raW5kICE9PSBcInZhclwiIHx8IGluaXQuZGVjbGFyYXRpb25zWzBdLmlkLnR5cGUgIT09IFwiSWRlbnRpZmllclwiKSkge1xuICAgICAgdGhpcy5yYWlzZShFcnJvcnMuRm9ySW5PZkxvb3BJbml0aWFsaXplciwgaW5pdCwge1xuICAgICAgICB0eXBlOiBpc0ZvckluID8gXCJGb3JJblN0YXRlbWVudFwiIDogXCJGb3JPZlN0YXRlbWVudFwiXG4gICAgICB9KTtcbiAgICB9XG4gICAgaWYgKGluaXQudHlwZSA9PT0gXCJBc3NpZ25tZW50UGF0dGVyblwiKSB7XG4gICAgICB0aGlzLnJhaXNlKEVycm9ycy5JbnZhbGlkTGhzLCBpbml0LCB7XG4gICAgICAgIGFuY2VzdG9yOiB7XG4gICAgICAgICAgdHlwZTogXCJGb3JTdGF0ZW1lbnRcIlxuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG4gICAgbm9kZS5sZWZ0ID0gaW5pdDtcbiAgICBub2RlLnJpZ2h0ID0gaXNGb3JJbiA/IHRoaXMucGFyc2VFeHByZXNzaW9uKCkgOiB0aGlzLnBhcnNlTWF5YmVBc3NpZ25BbGxvd0luKCk7XG4gICAgdGhpcy5leHBlY3QoMTEpO1xuICAgIG5vZGUuYm9keSA9IHRoaXMud2l0aFNtYXJ0TWl4VG9waWNGb3JiaWRkaW5nQ29udGV4dCgoKSA9PiB0aGlzLnBhcnNlU3RhdGVtZW50KCkpO1xuICAgIHRoaXMuc2NvcGUuZXhpdCgpO1xuICAgIHRoaXMuc3RhdGUubGFiZWxzLnBvcCgpO1xuICAgIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgaXNGb3JJbiA/IFwiRm9ySW5TdGF0ZW1lbnRcIiA6IFwiRm9yT2ZTdGF0ZW1lbnRcIik7XG4gIH1cbiAgcGFyc2VWYXIobm9kZSwgaXNGb3IsIGtpbmQsIGFsbG93TWlzc2luZ0luaXRpYWxpemVyID0gZmFsc2UpIHtcbiAgICBjb25zdCBkZWNsYXJhdGlvbnMgPSBub2RlLmRlY2xhcmF0aW9ucyA9IFtdO1xuICAgIG5vZGUua2luZCA9IGtpbmQ7XG4gICAgZm9yICg7Oykge1xuICAgICAgY29uc3QgZGVjbCA9IHRoaXMuc3RhcnROb2RlKCk7XG4gICAgICB0aGlzLnBhcnNlVmFySWQoZGVjbCwga2luZCk7XG4gICAgICBkZWNsLmluaXQgPSAhdGhpcy5lYXQoMjkpID8gbnVsbCA6IGlzRm9yID8gdGhpcy5wYXJzZU1heWJlQXNzaWduRGlzYWxsb3dJbigpIDogdGhpcy5wYXJzZU1heWJlQXNzaWduQWxsb3dJbigpO1xuICAgICAgaWYgKGRlY2wuaW5pdCA9PT0gbnVsbCAmJiAhYWxsb3dNaXNzaW5nSW5pdGlhbGl6ZXIpIHtcbiAgICAgICAgaWYgKGRlY2wuaWQudHlwZSAhPT0gXCJJZGVudGlmaWVyXCIgJiYgIShpc0ZvciAmJiAodGhpcy5tYXRjaCg1OCkgfHwgdGhpcy5pc0NvbnRleHR1YWwoMTAyKSkpKSB7XG4gICAgICAgICAgdGhpcy5yYWlzZShFcnJvcnMuRGVjbGFyYXRpb25NaXNzaW5nSW5pdGlhbGl6ZXIsIHRoaXMuc3RhdGUubGFzdFRva0VuZExvYywge1xuICAgICAgICAgICAga2luZDogXCJkZXN0cnVjdHVyaW5nXCJcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIGlmICgoa2luZCA9PT0gXCJjb25zdFwiIHx8IGtpbmQgPT09IFwidXNpbmdcIiB8fCBraW5kID09PSBcImF3YWl0IHVzaW5nXCIpICYmICEodGhpcy5tYXRjaCg1OCkgfHwgdGhpcy5pc0NvbnRleHR1YWwoMTAyKSkpIHtcbiAgICAgICAgICB0aGlzLnJhaXNlKEVycm9ycy5EZWNsYXJhdGlvbk1pc3NpbmdJbml0aWFsaXplciwgdGhpcy5zdGF0ZS5sYXN0VG9rRW5kTG9jLCB7XG4gICAgICAgICAgICBraW5kXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGRlY2xhcmF0aW9ucy5wdXNoKHRoaXMuZmluaXNoTm9kZShkZWNsLCBcIlZhcmlhYmxlRGVjbGFyYXRvclwiKSk7XG4gICAgICBpZiAoIXRoaXMuZWF0KDEyKSkgYnJlYWs7XG4gICAgfVxuICAgIHJldHVybiBub2RlO1xuICB9XG4gIHBhcnNlVmFySWQoZGVjbCwga2luZCkge1xuICAgIGNvbnN0IGlkID0gdGhpcy5wYXJzZUJpbmRpbmdBdG9tKCk7XG4gICAgaWYgKGtpbmQgPT09IFwidXNpbmdcIiB8fCBraW5kID09PSBcImF3YWl0IHVzaW5nXCIpIHtcbiAgICAgIGlmIChpZC50eXBlID09PSBcIkFycmF5UGF0dGVyblwiIHx8IGlkLnR5cGUgPT09IFwiT2JqZWN0UGF0dGVyblwiKSB7XG4gICAgICAgIHRoaXMucmFpc2UoRXJyb3JzLlVzaW5nRGVjbGFyYXRpb25IYXNCaW5kaW5nUGF0dGVybiwgaWQubG9jLnN0YXJ0KTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKGlkLnR5cGUgPT09IFwiVm9pZFBhdHRlcm5cIikge1xuICAgICAgICB0aGlzLnJhaXNlKEVycm9ycy5VbmV4cGVjdGVkVm9pZFBhdHRlcm4sIGlkLmxvYy5zdGFydCk7XG4gICAgICB9XG4gICAgfVxuICAgIHRoaXMuY2hlY2tMVmFsKGlkLCB7XG4gICAgICB0eXBlOiBcIlZhcmlhYmxlRGVjbGFyYXRvclwiXG4gICAgfSwga2luZCA9PT0gXCJ2YXJcIiA/IDUgOiA4MjAxKTtcbiAgICBkZWNsLmlkID0gaWQ7XG4gIH1cbiAgcGFyc2VBc3luY0Z1bmN0aW9uRXhwcmVzc2lvbihub2RlKSB7XG4gICAgcmV0dXJuIHRoaXMucGFyc2VGdW5jdGlvbihub2RlLCA4KTtcbiAgfVxuICBwYXJzZUZ1bmN0aW9uKG5vZGUsIGZsYWdzID0gMCkge1xuICAgIGNvbnN0IGhhbmdpbmdEZWNsYXJhdGlvbiA9IGZsYWdzICYgMjtcbiAgICBjb25zdCBpc0RlY2xhcmF0aW9uID0gISEoZmxhZ3MgJiAxKTtcbiAgICBjb25zdCByZXF1aXJlSWQgPSBpc0RlY2xhcmF0aW9uICYmICEoZmxhZ3MgJiA0KTtcbiAgICBjb25zdCBpc0FzeW5jID0gISEoZmxhZ3MgJiA4KTtcbiAgICB0aGlzLmluaXRGdW5jdGlvbihub2RlLCBpc0FzeW5jKTtcbiAgICBpZiAodGhpcy5tYXRjaCg1NSkpIHtcbiAgICAgIGlmIChoYW5naW5nRGVjbGFyYXRpb24pIHtcbiAgICAgICAgdGhpcy5yYWlzZShFcnJvcnMuR2VuZXJhdG9ySW5TaW5nbGVTdGF0ZW1lbnRDb250ZXh0LCB0aGlzLnN0YXRlLnN0YXJ0TG9jKTtcbiAgICAgIH1cbiAgICAgIHRoaXMubmV4dCgpO1xuICAgICAgbm9kZS5nZW5lcmF0b3IgPSB0cnVlO1xuICAgIH1cbiAgICBpZiAoaXNEZWNsYXJhdGlvbikge1xuICAgICAgbm9kZS5pZCA9IHRoaXMucGFyc2VGdW5jdGlvbklkKHJlcXVpcmVJZCk7XG4gICAgfVxuICAgIGNvbnN0IG9sZE1heWJlSW5BcnJvd1BhcmFtZXRlcnMgPSB0aGlzLnN0YXRlLm1heWJlSW5BcnJvd1BhcmFtZXRlcnM7XG4gICAgdGhpcy5zdGF0ZS5tYXliZUluQXJyb3dQYXJhbWV0ZXJzID0gZmFsc2U7XG4gICAgdGhpcy5zY29wZS5lbnRlcig1MTQpO1xuICAgIHRoaXMucHJvZFBhcmFtLmVudGVyKGZ1bmN0aW9uRmxhZ3MoaXNBc3luYywgbm9kZS5nZW5lcmF0b3IpKTtcbiAgICBpZiAoIWlzRGVjbGFyYXRpb24pIHtcbiAgICAgIG5vZGUuaWQgPSB0aGlzLnBhcnNlRnVuY3Rpb25JZCgpO1xuICAgIH1cbiAgICB0aGlzLnBhcnNlRnVuY3Rpb25QYXJhbXMobm9kZSwgZmFsc2UpO1xuICAgIHRoaXMud2l0aFNtYXJ0TWl4VG9waWNGb3JiaWRkaW5nQ29udGV4dCgoKSA9PiB7XG4gICAgICB0aGlzLnBhcnNlRnVuY3Rpb25Cb2R5QW5kRmluaXNoKG5vZGUsIGlzRGVjbGFyYXRpb24gPyBcIkZ1bmN0aW9uRGVjbGFyYXRpb25cIiA6IFwiRnVuY3Rpb25FeHByZXNzaW9uXCIpO1xuICAgIH0pO1xuICAgIHRoaXMucHJvZFBhcmFtLmV4aXQoKTtcbiAgICB0aGlzLnNjb3BlLmV4aXQoKTtcbiAgICBpZiAoaXNEZWNsYXJhdGlvbiAmJiAhaGFuZ2luZ0RlY2xhcmF0aW9uKSB7XG4gICAgICB0aGlzLnJlZ2lzdGVyRnVuY3Rpb25TdGF0ZW1lbnRJZChub2RlKTtcbiAgICB9XG4gICAgdGhpcy5zdGF0ZS5tYXliZUluQXJyb3dQYXJhbWV0ZXJzID0gb2xkTWF5YmVJbkFycm93UGFyYW1ldGVycztcbiAgICByZXR1cm4gbm9kZTtcbiAgfVxuICBwYXJzZUZ1bmN0aW9uSWQocmVxdWlyZUlkKSB7XG4gICAgcmV0dXJuIHJlcXVpcmVJZCB8fCB0b2tlbklzSWRlbnRpZmllcih0aGlzLnN0YXRlLnR5cGUpID8gdGhpcy5wYXJzZUlkZW50aWZpZXIoKSA6IG51bGw7XG4gIH1cbiAgcGFyc2VGdW5jdGlvblBhcmFtcyhub2RlLCBpc0NvbnN0cnVjdG9yKSB7XG4gICAgdGhpcy5leHBlY3QoMTApO1xuICAgIHRoaXMuZXhwcmVzc2lvblNjb3BlLmVudGVyKG5ld1BhcmFtZXRlckRlY2xhcmF0aW9uU2NvcGUoKSk7XG4gICAgbm9kZS5wYXJhbXMgPSB0aGlzLnBhcnNlQmluZGluZ0xpc3QoMTEsIDQxLCAyIHwgKGlzQ29uc3RydWN0b3IgPyA0IDogMCkpO1xuICAgIHRoaXMuZXhwcmVzc2lvblNjb3BlLmV4aXQoKTtcbiAgfVxuICByZWdpc3RlckZ1bmN0aW9uU3RhdGVtZW50SWQobm9kZSkge1xuICAgIGlmICghbm9kZS5pZCkgcmV0dXJuO1xuICAgIHRoaXMuc2NvcGUuZGVjbGFyZU5hbWUobm9kZS5pZC5uYW1lLCAhdGhpcy5vcHRpb25zLmFubmV4QiB8fCB0aGlzLnN0YXRlLnN0cmljdCB8fCBub2RlLmdlbmVyYXRvciB8fCBub2RlLmFzeW5jID8gdGhpcy5zY29wZS50cmVhdEZ1bmN0aW9uc0FzVmFyID8gNSA6IDgyMDEgOiAxNywgbm9kZS5pZC5sb2Muc3RhcnQpO1xuICB9XG4gIHBhcnNlQ2xhc3Mobm9kZSwgaXNTdGF0ZW1lbnQsIG9wdGlvbmFsSWQpIHtcbiAgICB0aGlzLm5leHQoKTtcbiAgICBjb25zdCBvbGRTdHJpY3QgPSB0aGlzLnN0YXRlLnN0cmljdDtcbiAgICB0aGlzLnN0YXRlLnN0cmljdCA9IHRydWU7XG4gICAgdGhpcy5wYXJzZUNsYXNzSWQobm9kZSwgaXNTdGF0ZW1lbnQsIG9wdGlvbmFsSWQpO1xuICAgIHRoaXMucGFyc2VDbGFzc1N1cGVyKG5vZGUpO1xuICAgIG5vZGUuYm9keSA9IHRoaXMucGFyc2VDbGFzc0JvZHkoISFub2RlLnN1cGVyQ2xhc3MsIG9sZFN0cmljdCk7XG4gICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBpc1N0YXRlbWVudCA/IFwiQ2xhc3NEZWNsYXJhdGlvblwiIDogXCJDbGFzc0V4cHJlc3Npb25cIik7XG4gIH1cbiAgaXNDbGFzc1Byb3BlcnR5KCkge1xuICAgIHJldHVybiB0aGlzLm1hdGNoKDI5KSB8fCB0aGlzLm1hdGNoKDEzKSB8fCB0aGlzLm1hdGNoKDgpO1xuICB9XG4gIGlzQ2xhc3NNZXRob2QoKSB7XG4gICAgcmV0dXJuIHRoaXMubWF0Y2goMTApO1xuICB9XG4gIG5hbWVJc0NvbnN0cnVjdG9yKGtleSkge1xuICAgIHJldHVybiBrZXkudHlwZSA9PT0gXCJJZGVudGlmaWVyXCIgJiYga2V5Lm5hbWUgPT09IFwiY29uc3RydWN0b3JcIiB8fCBrZXkudHlwZSA9PT0gXCJTdHJpbmdMaXRlcmFsXCIgJiYga2V5LnZhbHVlID09PSBcImNvbnN0cnVjdG9yXCI7XG4gIH1cbiAgaXNOb25zdGF0aWNDb25zdHJ1Y3RvcihtZXRob2QpIHtcbiAgICByZXR1cm4gIW1ldGhvZC5jb21wdXRlZCAmJiAhbWV0aG9kLnN0YXRpYyAmJiB0aGlzLm5hbWVJc0NvbnN0cnVjdG9yKG1ldGhvZC5rZXkpO1xuICB9XG4gIHBhcnNlQ2xhc3NCb2R5KGhhZFN1cGVyQ2xhc3MsIG9sZFN0cmljdCkge1xuICAgIHRoaXMuY2xhc3NTY29wZS5lbnRlcigpO1xuICAgIGNvbnN0IHN0YXRlID0ge1xuICAgICAgaGFkQ29uc3RydWN0b3I6IGZhbHNlLFxuICAgICAgaGFkU3VwZXJDbGFzc1xuICAgIH07XG4gICAgbGV0IGRlY29yYXRvcnMgPSBbXTtcbiAgICBjb25zdCBjbGFzc0JvZHkgPSB0aGlzLnN0YXJ0Tm9kZSgpO1xuICAgIGNsYXNzQm9keS5ib2R5ID0gW107XG4gICAgdGhpcy5leHBlY3QoNSk7XG4gICAgdGhpcy53aXRoU21hcnRNaXhUb3BpY0ZvcmJpZGRpbmdDb250ZXh0KCgpID0+IHtcbiAgICAgIHdoaWxlICghdGhpcy5tYXRjaCg4KSkge1xuICAgICAgICBpZiAodGhpcy5lYXQoMTMpKSB7XG4gICAgICAgICAgaWYgKGRlY29yYXRvcnMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgdGhyb3cgdGhpcy5yYWlzZShFcnJvcnMuRGVjb3JhdG9yU2VtaWNvbG9uLCB0aGlzLnN0YXRlLmxhc3RUb2tFbmRMb2MpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5tYXRjaCgyNikpIHtcbiAgICAgICAgICBkZWNvcmF0b3JzLnB1c2godGhpcy5wYXJzZURlY29yYXRvcigpKTtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBtZW1iZXIgPSB0aGlzLnN0YXJ0Tm9kZSgpO1xuICAgICAgICBpZiAoZGVjb3JhdG9ycy5sZW5ndGgpIHtcbiAgICAgICAgICBtZW1iZXIuZGVjb3JhdG9ycyA9IGRlY29yYXRvcnM7XG4gICAgICAgICAgdGhpcy5yZXNldFN0YXJ0TG9jYXRpb25Gcm9tTm9kZShtZW1iZXIsIGRlY29yYXRvcnNbMF0pO1xuICAgICAgICAgIGRlY29yYXRvcnMgPSBbXTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnBhcnNlQ2xhc3NNZW1iZXIoY2xhc3NCb2R5LCBtZW1iZXIsIHN0YXRlKTtcbiAgICAgICAgaWYgKG1lbWJlci5raW5kID09PSBcImNvbnN0cnVjdG9yXCIgJiYgbWVtYmVyLmRlY29yYXRvcnMgJiYgbWVtYmVyLmRlY29yYXRvcnMubGVuZ3RoID4gMCkge1xuICAgICAgICAgIHRoaXMucmFpc2UoRXJyb3JzLkRlY29yYXRvckNvbnN0cnVjdG9yLCBtZW1iZXIpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG4gICAgdGhpcy5zdGF0ZS5zdHJpY3QgPSBvbGRTdHJpY3Q7XG4gICAgdGhpcy5uZXh0KCk7XG4gICAgaWYgKGRlY29yYXRvcnMubGVuZ3RoKSB7XG4gICAgICB0aHJvdyB0aGlzLnJhaXNlKEVycm9ycy5UcmFpbGluZ0RlY29yYXRvciwgdGhpcy5zdGF0ZS5zdGFydExvYyk7XG4gICAgfVxuICAgIHRoaXMuY2xhc3NTY29wZS5leGl0KCk7XG4gICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShjbGFzc0JvZHksIFwiQ2xhc3NCb2R5XCIpO1xuICB9XG4gIHBhcnNlQ2xhc3NNZW1iZXJGcm9tTW9kaWZpZXIoY2xhc3NCb2R5LCBtZW1iZXIpIHtcbiAgICBjb25zdCBrZXkgPSB0aGlzLnBhcnNlSWRlbnRpZmllcih0cnVlKTtcbiAgICBpZiAodGhpcy5pc0NsYXNzTWV0aG9kKCkpIHtcbiAgICAgIGNvbnN0IG1ldGhvZCA9IG1lbWJlcjtcbiAgICAgIG1ldGhvZC5raW5kID0gXCJtZXRob2RcIjtcbiAgICAgIG1ldGhvZC5jb21wdXRlZCA9IGZhbHNlO1xuICAgICAgbWV0aG9kLmtleSA9IGtleTtcbiAgICAgIG1ldGhvZC5zdGF0aWMgPSBmYWxzZTtcbiAgICAgIHRoaXMucHVzaENsYXNzTWV0aG9kKGNsYXNzQm9keSwgbWV0aG9kLCBmYWxzZSwgZmFsc2UsIGZhbHNlLCBmYWxzZSk7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGVsc2UgaWYgKHRoaXMuaXNDbGFzc1Byb3BlcnR5KCkpIHtcbiAgICAgIGNvbnN0IHByb3AgPSBtZW1iZXI7XG4gICAgICBwcm9wLmNvbXB1dGVkID0gZmFsc2U7XG4gICAgICBwcm9wLmtleSA9IGtleTtcbiAgICAgIHByb3Auc3RhdGljID0gZmFsc2U7XG4gICAgICBjbGFzc0JvZHkuYm9keS5wdXNoKHRoaXMucGFyc2VDbGFzc1Byb3BlcnR5KHByb3ApKTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICB0aGlzLnJlc2V0UHJldmlvdXNOb2RlVHJhaWxpbmdDb21tZW50cyhrZXkpO1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBwYXJzZUNsYXNzTWVtYmVyKGNsYXNzQm9keSwgbWVtYmVyLCBzdGF0ZSkge1xuICAgIGNvbnN0IGlzU3RhdGljID0gdGhpcy5pc0NvbnRleHR1YWwoMTA2KTtcbiAgICBpZiAoaXNTdGF0aWMpIHtcbiAgICAgIGlmICh0aGlzLnBhcnNlQ2xhc3NNZW1iZXJGcm9tTW9kaWZpZXIoY2xhc3NCb2R5LCBtZW1iZXIpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLmVhdCg1KSkge1xuICAgICAgICB0aGlzLnBhcnNlQ2xhc3NTdGF0aWNCbG9jayhjbGFzc0JvZHksIG1lbWJlcik7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICB9XG4gICAgdGhpcy5wYXJzZUNsYXNzTWVtYmVyV2l0aElzU3RhdGljKGNsYXNzQm9keSwgbWVtYmVyLCBzdGF0ZSwgaXNTdGF0aWMpO1xuICB9XG4gIHBhcnNlQ2xhc3NNZW1iZXJXaXRoSXNTdGF0aWMoY2xhc3NCb2R5LCBtZW1iZXIsIHN0YXRlLCBpc1N0YXRpYykge1xuICAgIGNvbnN0IHB1YmxpY01ldGhvZCA9IG1lbWJlcjtcbiAgICBjb25zdCBwcml2YXRlTWV0aG9kID0gbWVtYmVyO1xuICAgIGNvbnN0IHB1YmxpY1Byb3AgPSBtZW1iZXI7XG4gICAgY29uc3QgcHJpdmF0ZVByb3AgPSBtZW1iZXI7XG4gICAgY29uc3QgYWNjZXNzb3JQcm9wID0gbWVtYmVyO1xuICAgIGNvbnN0IG1ldGhvZCA9IHB1YmxpY01ldGhvZDtcbiAgICBjb25zdCBwdWJsaWNNZW1iZXIgPSBwdWJsaWNNZXRob2Q7XG4gICAgbWVtYmVyLnN0YXRpYyA9IGlzU3RhdGljO1xuICAgIHRoaXMucGFyc2VQcm9wZXJ0eU5hbWVQcmVmaXhPcGVyYXRvcihtZW1iZXIpO1xuICAgIGlmICh0aGlzLmVhdCg1NSkpIHtcbiAgICAgIG1ldGhvZC5raW5kID0gXCJtZXRob2RcIjtcbiAgICAgIGNvbnN0IGlzUHJpdmF0ZU5hbWUgPSB0aGlzLm1hdGNoKDEzOSk7XG4gICAgICB0aGlzLnBhcnNlQ2xhc3NFbGVtZW50TmFtZShtZXRob2QpO1xuICAgICAgdGhpcy5wYXJzZVBvc3RNZW1iZXJOYW1lTW9kaWZpZXJzKG1ldGhvZCk7XG4gICAgICBpZiAoaXNQcml2YXRlTmFtZSkge1xuICAgICAgICB0aGlzLnB1c2hDbGFzc1ByaXZhdGVNZXRob2QoY2xhc3NCb2R5LCBwcml2YXRlTWV0aG9kLCB0cnVlLCBmYWxzZSk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLmlzTm9uc3RhdGljQ29uc3RydWN0b3IocHVibGljTWV0aG9kKSkge1xuICAgICAgICB0aGlzLnJhaXNlKEVycm9ycy5Db25zdHJ1Y3RvcklzR2VuZXJhdG9yLCBwdWJsaWNNZXRob2Qua2V5KTtcbiAgICAgIH1cbiAgICAgIHRoaXMucHVzaENsYXNzTWV0aG9kKGNsYXNzQm9keSwgcHVibGljTWV0aG9kLCB0cnVlLCBmYWxzZSwgZmFsc2UsIGZhbHNlKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgaXNDb250ZXh0dWFsID0gIXRoaXMuc3RhdGUuY29udGFpbnNFc2MgJiYgdG9rZW5Jc0lkZW50aWZpZXIodGhpcy5zdGF0ZS50eXBlKTtcbiAgICBjb25zdCBrZXkgPSB0aGlzLnBhcnNlQ2xhc3NFbGVtZW50TmFtZShtZW1iZXIpO1xuICAgIGNvbnN0IG1heWJlQ29udGV4dHVhbEt3ID0gaXNDb250ZXh0dWFsID8ga2V5Lm5hbWUgOiBudWxsO1xuICAgIGNvbnN0IGlzUHJpdmF0ZSA9IHRoaXMuaXNQcml2YXRlTmFtZShrZXkpO1xuICAgIGNvbnN0IG1heWJlUXVlc3Rpb25Ub2tlblN0YXJ0TG9jID0gdGhpcy5zdGF0ZS5zdGFydExvYztcbiAgICB0aGlzLnBhcnNlUG9zdE1lbWJlck5hbWVNb2RpZmllcnMocHVibGljTWVtYmVyKTtcbiAgICBpZiAodGhpcy5pc0NsYXNzTWV0aG9kKCkpIHtcbiAgICAgIG1ldGhvZC5raW5kID0gXCJtZXRob2RcIjtcbiAgICAgIGlmIChpc1ByaXZhdGUpIHtcbiAgICAgICAgdGhpcy5wdXNoQ2xhc3NQcml2YXRlTWV0aG9kKGNsYXNzQm9keSwgcHJpdmF0ZU1ldGhvZCwgZmFsc2UsIGZhbHNlKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgY29uc3QgaXNDb25zdHJ1Y3RvciA9IHRoaXMuaXNOb25zdGF0aWNDb25zdHJ1Y3RvcihwdWJsaWNNZXRob2QpO1xuICAgICAgbGV0IGFsbG93c0RpcmVjdFN1cGVyID0gZmFsc2U7XG4gICAgICBpZiAoaXNDb25zdHJ1Y3Rvcikge1xuICAgICAgICBwdWJsaWNNZXRob2Qua2luZCA9IFwiY29uc3RydWN0b3JcIjtcbiAgICAgICAgaWYgKHN0YXRlLmhhZENvbnN0cnVjdG9yICYmICF0aGlzLmhhc1BsdWdpbihcInR5cGVzY3JpcHRcIikpIHtcbiAgICAgICAgICB0aGlzLnJhaXNlKEVycm9ycy5EdXBsaWNhdGVDb25zdHJ1Y3Rvciwga2V5KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaXNDb25zdHJ1Y3RvciAmJiB0aGlzLmhhc1BsdWdpbihcInR5cGVzY3JpcHRcIikgJiYgbWVtYmVyLm92ZXJyaWRlKSB7XG4gICAgICAgICAgdGhpcy5yYWlzZShFcnJvcnMuT3ZlcnJpZGVPbkNvbnN0cnVjdG9yLCBrZXkpO1xuICAgICAgICB9XG4gICAgICAgIHN0YXRlLmhhZENvbnN0cnVjdG9yID0gdHJ1ZTtcbiAgICAgICAgYWxsb3dzRGlyZWN0U3VwZXIgPSBzdGF0ZS5oYWRTdXBlckNsYXNzO1xuICAgICAgfVxuICAgICAgdGhpcy5wdXNoQ2xhc3NNZXRob2QoY2xhc3NCb2R5LCBwdWJsaWNNZXRob2QsIGZhbHNlLCBmYWxzZSwgaXNDb25zdHJ1Y3RvciwgYWxsb3dzRGlyZWN0U3VwZXIpO1xuICAgIH0gZWxzZSBpZiAodGhpcy5pc0NsYXNzUHJvcGVydHkoKSkge1xuICAgICAgaWYgKGlzUHJpdmF0ZSkge1xuICAgICAgICB0aGlzLnB1c2hDbGFzc1ByaXZhdGVQcm9wZXJ0eShjbGFzc0JvZHksIHByaXZhdGVQcm9wKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMucHVzaENsYXNzUHJvcGVydHkoY2xhc3NCb2R5LCBwdWJsaWNQcm9wKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKG1heWJlQ29udGV4dHVhbEt3ID09PSBcImFzeW5jXCIgJiYgIXRoaXMuaXNMaW5lVGVybWluYXRvcigpKSB7XG4gICAgICB0aGlzLnJlc2V0UHJldmlvdXNOb2RlVHJhaWxpbmdDb21tZW50cyhrZXkpO1xuICAgICAgY29uc3QgaXNHZW5lcmF0b3IgPSB0aGlzLmVhdCg1NSk7XG4gICAgICBpZiAocHVibGljTWVtYmVyLm9wdGlvbmFsKSB7XG4gICAgICAgIHRoaXMudW5leHBlY3RlZChtYXliZVF1ZXN0aW9uVG9rZW5TdGFydExvYyk7XG4gICAgICB9XG4gICAgICBtZXRob2Qua2luZCA9IFwibWV0aG9kXCI7XG4gICAgICBjb25zdCBpc1ByaXZhdGUgPSB0aGlzLm1hdGNoKDEzOSk7XG4gICAgICB0aGlzLnBhcnNlQ2xhc3NFbGVtZW50TmFtZShtZXRob2QpO1xuICAgICAgdGhpcy5wYXJzZVBvc3RNZW1iZXJOYW1lTW9kaWZpZXJzKHB1YmxpY01lbWJlcik7XG4gICAgICBpZiAoaXNQcml2YXRlKSB7XG4gICAgICAgIHRoaXMucHVzaENsYXNzUHJpdmF0ZU1ldGhvZChjbGFzc0JvZHksIHByaXZhdGVNZXRob2QsIGlzR2VuZXJhdG9yLCB0cnVlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmICh0aGlzLmlzTm9uc3RhdGljQ29uc3RydWN0b3IocHVibGljTWV0aG9kKSkge1xuICAgICAgICAgIHRoaXMucmFpc2UoRXJyb3JzLkNvbnN0cnVjdG9ySXNBc3luYywgcHVibGljTWV0aG9kLmtleSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5wdXNoQ2xhc3NNZXRob2QoY2xhc3NCb2R5LCBwdWJsaWNNZXRob2QsIGlzR2VuZXJhdG9yLCB0cnVlLCBmYWxzZSwgZmFsc2UpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoKG1heWJlQ29udGV4dHVhbEt3ID09PSBcImdldFwiIHx8IG1heWJlQ29udGV4dHVhbEt3ID09PSBcInNldFwiKSAmJiAhKHRoaXMubWF0Y2goNTUpICYmIHRoaXMuaXNMaW5lVGVybWluYXRvcigpKSkge1xuICAgICAgdGhpcy5yZXNldFByZXZpb3VzTm9kZVRyYWlsaW5nQ29tbWVudHMoa2V5KTtcbiAgICAgIG1ldGhvZC5raW5kID0gbWF5YmVDb250ZXh0dWFsS3c7XG4gICAgICBjb25zdCBpc1ByaXZhdGUgPSB0aGlzLm1hdGNoKDEzOSk7XG4gICAgICB0aGlzLnBhcnNlQ2xhc3NFbGVtZW50TmFtZShwdWJsaWNNZXRob2QpO1xuICAgICAgaWYgKGlzUHJpdmF0ZSkge1xuICAgICAgICB0aGlzLnB1c2hDbGFzc1ByaXZhdGVNZXRob2QoY2xhc3NCb2R5LCBwcml2YXRlTWV0aG9kLCBmYWxzZSwgZmFsc2UpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKHRoaXMuaXNOb25zdGF0aWNDb25zdHJ1Y3RvcihwdWJsaWNNZXRob2QpKSB7XG4gICAgICAgICAgdGhpcy5yYWlzZShFcnJvcnMuQ29uc3RydWN0b3JJc0FjY2Vzc29yLCBwdWJsaWNNZXRob2Qua2V5KTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnB1c2hDbGFzc01ldGhvZChjbGFzc0JvZHksIHB1YmxpY01ldGhvZCwgZmFsc2UsIGZhbHNlLCBmYWxzZSwgZmFsc2UpO1xuICAgICAgfVxuICAgICAgdGhpcy5jaGVja0dldHRlclNldHRlclBhcmFtcyhwdWJsaWNNZXRob2QpO1xuICAgIH0gZWxzZSBpZiAobWF5YmVDb250ZXh0dWFsS3cgPT09IFwiYWNjZXNzb3JcIiAmJiAhdGhpcy5pc0xpbmVUZXJtaW5hdG9yKCkpIHtcbiAgICAgIHRoaXMuZXhwZWN0UGx1Z2luKFwiZGVjb3JhdG9yQXV0b0FjY2Vzc29yc1wiKTtcbiAgICAgIHRoaXMucmVzZXRQcmV2aW91c05vZGVUcmFpbGluZ0NvbW1lbnRzKGtleSk7XG4gICAgICBjb25zdCBpc1ByaXZhdGUgPSB0aGlzLm1hdGNoKDEzOSk7XG4gICAgICB0aGlzLnBhcnNlQ2xhc3NFbGVtZW50TmFtZShwdWJsaWNQcm9wKTtcbiAgICAgIHRoaXMucHVzaENsYXNzQWNjZXNzb3JQcm9wZXJ0eShjbGFzc0JvZHksIGFjY2Vzc29yUHJvcCwgaXNQcml2YXRlKTtcbiAgICB9IGVsc2UgaWYgKHRoaXMuaXNMaW5lVGVybWluYXRvcigpKSB7XG4gICAgICBpZiAoaXNQcml2YXRlKSB7XG4gICAgICAgIHRoaXMucHVzaENsYXNzUHJpdmF0ZVByb3BlcnR5KGNsYXNzQm9keSwgcHJpdmF0ZVByb3ApO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5wdXNoQ2xhc3NQcm9wZXJ0eShjbGFzc0JvZHksIHB1YmxpY1Byb3ApO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnVuZXhwZWN0ZWQoKTtcbiAgICB9XG4gIH1cbiAgcGFyc2VDbGFzc0VsZW1lbnROYW1lKG1lbWJlcikge1xuICAgIGNvbnN0IHtcbiAgICAgIHR5cGUsXG4gICAgICB2YWx1ZVxuICAgIH0gPSB0aGlzLnN0YXRlO1xuICAgIGlmICgodHlwZSA9PT0gMTMyIHx8IHR5cGUgPT09IDEzNCkgJiYgbWVtYmVyLnN0YXRpYyAmJiB2YWx1ZSA9PT0gXCJwcm90b3R5cGVcIikge1xuICAgICAgdGhpcy5yYWlzZShFcnJvcnMuU3RhdGljUHJvdG90eXBlLCB0aGlzLnN0YXRlLnN0YXJ0TG9jKTtcbiAgICB9XG4gICAgaWYgKHR5cGUgPT09IDEzOSkge1xuICAgICAgaWYgKHZhbHVlID09PSBcImNvbnN0cnVjdG9yXCIpIHtcbiAgICAgICAgdGhpcy5yYWlzZShFcnJvcnMuQ29uc3RydWN0b3JDbGFzc1ByaXZhdGVGaWVsZCwgdGhpcy5zdGF0ZS5zdGFydExvYyk7XG4gICAgICB9XG4gICAgICBjb25zdCBrZXkgPSB0aGlzLnBhcnNlUHJpdmF0ZU5hbWUoKTtcbiAgICAgIG1lbWJlci5rZXkgPSBrZXk7XG4gICAgICByZXR1cm4ga2V5O1xuICAgIH1cbiAgICB0aGlzLnBhcnNlUHJvcGVydHlOYW1lKG1lbWJlcik7XG4gICAgcmV0dXJuIG1lbWJlci5rZXk7XG4gIH1cbiAgcGFyc2VDbGFzc1N0YXRpY0Jsb2NrKGNsYXNzQm9keSwgbWVtYmVyKSB7XG4gICAgdmFyIF9tZW1iZXIkZGVjb3JhdG9ycztcbiAgICB0aGlzLnNjb3BlLmVudGVyKDU3NiB8IDEyOCB8IDE2KTtcbiAgICBjb25zdCBvbGRMYWJlbHMgPSB0aGlzLnN0YXRlLmxhYmVscztcbiAgICB0aGlzLnN0YXRlLmxhYmVscyA9IFtdO1xuICAgIHRoaXMucHJvZFBhcmFtLmVudGVyKDApO1xuICAgIGNvbnN0IGJvZHkgPSBtZW1iZXIuYm9keSA9IFtdO1xuICAgIHRoaXMucGFyc2VCbG9ja09yTW9kdWxlQmxvY2tCb2R5KGJvZHksIHVuZGVmaW5lZCwgZmFsc2UsIDgpO1xuICAgIHRoaXMucHJvZFBhcmFtLmV4aXQoKTtcbiAgICB0aGlzLnNjb3BlLmV4aXQoKTtcbiAgICB0aGlzLnN0YXRlLmxhYmVscyA9IG9sZExhYmVscztcbiAgICBjbGFzc0JvZHkuYm9keS5wdXNoKHRoaXMuZmluaXNoTm9kZShtZW1iZXIsIFwiU3RhdGljQmxvY2tcIikpO1xuICAgIGlmICgoX21lbWJlciRkZWNvcmF0b3JzID0gbWVtYmVyLmRlY29yYXRvcnMpICE9IG51bGwgJiYgX21lbWJlciRkZWNvcmF0b3JzLmxlbmd0aCkge1xuICAgICAgdGhpcy5yYWlzZShFcnJvcnMuRGVjb3JhdG9yU3RhdGljQmxvY2ssIG1lbWJlcik7XG4gICAgfVxuICB9XG4gIHB1c2hDbGFzc1Byb3BlcnR5KGNsYXNzQm9keSwgcHJvcCkge1xuICAgIGlmICghcHJvcC5jb21wdXRlZCAmJiB0aGlzLm5hbWVJc0NvbnN0cnVjdG9yKHByb3Aua2V5KSkge1xuICAgICAgdGhpcy5yYWlzZShFcnJvcnMuQ29uc3RydWN0b3JDbGFzc0ZpZWxkLCBwcm9wLmtleSk7XG4gICAgfVxuICAgIGNsYXNzQm9keS5ib2R5LnB1c2godGhpcy5wYXJzZUNsYXNzUHJvcGVydHkocHJvcCkpO1xuICB9XG4gIHB1c2hDbGFzc1ByaXZhdGVQcm9wZXJ0eShjbGFzc0JvZHksIHByb3ApIHtcbiAgICBjb25zdCBub2RlID0gdGhpcy5wYXJzZUNsYXNzUHJpdmF0ZVByb3BlcnR5KHByb3ApO1xuICAgIGNsYXNzQm9keS5ib2R5LnB1c2gobm9kZSk7XG4gICAgdGhpcy5jbGFzc1Njb3BlLmRlY2xhcmVQcml2YXRlTmFtZSh0aGlzLmdldFByaXZhdGVOYW1lU1Yobm9kZS5rZXkpLCAwLCBub2RlLmtleS5sb2Muc3RhcnQpO1xuICB9XG4gIHB1c2hDbGFzc0FjY2Vzc29yUHJvcGVydHkoY2xhc3NCb2R5LCBwcm9wLCBpc1ByaXZhdGUpIHtcbiAgICBpZiAoIWlzUHJpdmF0ZSAmJiAhcHJvcC5jb21wdXRlZCAmJiB0aGlzLm5hbWVJc0NvbnN0cnVjdG9yKHByb3Aua2V5KSkge1xuICAgICAgdGhpcy5yYWlzZShFcnJvcnMuQ29uc3RydWN0b3JDbGFzc0ZpZWxkLCBwcm9wLmtleSk7XG4gICAgfVxuICAgIGNvbnN0IG5vZGUgPSB0aGlzLnBhcnNlQ2xhc3NBY2Nlc3NvclByb3BlcnR5KHByb3ApO1xuICAgIGNsYXNzQm9keS5ib2R5LnB1c2gobm9kZSk7XG4gICAgaWYgKGlzUHJpdmF0ZSkge1xuICAgICAgdGhpcy5jbGFzc1Njb3BlLmRlY2xhcmVQcml2YXRlTmFtZSh0aGlzLmdldFByaXZhdGVOYW1lU1Yobm9kZS5rZXkpLCAwLCBub2RlLmtleS5sb2Muc3RhcnQpO1xuICAgIH1cbiAgfVxuICBwdXNoQ2xhc3NNZXRob2QoY2xhc3NCb2R5LCBtZXRob2QsIGlzR2VuZXJhdG9yLCBpc0FzeW5jLCBpc0NvbnN0cnVjdG9yLCBhbGxvd3NEaXJlY3RTdXBlcikge1xuICAgIGNsYXNzQm9keS5ib2R5LnB1c2godGhpcy5wYXJzZU1ldGhvZChtZXRob2QsIGlzR2VuZXJhdG9yLCBpc0FzeW5jLCBpc0NvbnN0cnVjdG9yLCBhbGxvd3NEaXJlY3RTdXBlciwgXCJDbGFzc01ldGhvZFwiLCB0cnVlKSk7XG4gIH1cbiAgcHVzaENsYXNzUHJpdmF0ZU1ldGhvZChjbGFzc0JvZHksIG1ldGhvZCwgaXNHZW5lcmF0b3IsIGlzQXN5bmMpIHtcbiAgICBjb25zdCBub2RlID0gdGhpcy5wYXJzZU1ldGhvZChtZXRob2QsIGlzR2VuZXJhdG9yLCBpc0FzeW5jLCBmYWxzZSwgZmFsc2UsIFwiQ2xhc3NQcml2YXRlTWV0aG9kXCIsIHRydWUpO1xuICAgIGNsYXNzQm9keS5ib2R5LnB1c2gobm9kZSk7XG4gICAgY29uc3Qga2luZCA9IG5vZGUua2luZCA9PT0gXCJnZXRcIiA/IG5vZGUuc3RhdGljID8gNiA6IDIgOiBub2RlLmtpbmQgPT09IFwic2V0XCIgPyBub2RlLnN0YXRpYyA/IDUgOiAxIDogMDtcbiAgICB0aGlzLmRlY2xhcmVDbGFzc1ByaXZhdGVNZXRob2RJblNjb3BlKG5vZGUsIGtpbmQpO1xuICB9XG4gIGRlY2xhcmVDbGFzc1ByaXZhdGVNZXRob2RJblNjb3BlKG5vZGUsIGtpbmQpIHtcbiAgICB0aGlzLmNsYXNzU2NvcGUuZGVjbGFyZVByaXZhdGVOYW1lKHRoaXMuZ2V0UHJpdmF0ZU5hbWVTVihub2RlLmtleSksIGtpbmQsIG5vZGUua2V5LmxvYy5zdGFydCk7XG4gIH1cbiAgcGFyc2VQb3N0TWVtYmVyTmFtZU1vZGlmaWVycyhtZXRob2RPclByb3ApIHt9XG4gIHBhcnNlQ2xhc3NQcml2YXRlUHJvcGVydHkobm9kZSkge1xuICAgIHRoaXMucGFyc2VJbml0aWFsaXplcihub2RlKTtcbiAgICB0aGlzLnNlbWljb2xvbigpO1xuICAgIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJDbGFzc1ByaXZhdGVQcm9wZXJ0eVwiKTtcbiAgfVxuICBwYXJzZUNsYXNzUHJvcGVydHkobm9kZSkge1xuICAgIHRoaXMucGFyc2VJbml0aWFsaXplcihub2RlKTtcbiAgICB0aGlzLnNlbWljb2xvbigpO1xuICAgIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJDbGFzc1Byb3BlcnR5XCIpO1xuICB9XG4gIHBhcnNlQ2xhc3NBY2Nlc3NvclByb3BlcnR5KG5vZGUpIHtcbiAgICB0aGlzLnBhcnNlSW5pdGlhbGl6ZXIobm9kZSk7XG4gICAgdGhpcy5zZW1pY29sb24oKTtcbiAgICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiQ2xhc3NBY2Nlc3NvclByb3BlcnR5XCIpO1xuICB9XG4gIHBhcnNlSW5pdGlhbGl6ZXIobm9kZSkge1xuICAgIHRoaXMuc2NvcGUuZW50ZXIoNTc2IHwgMTYpO1xuICAgIHRoaXMuZXhwcmVzc2lvblNjb3BlLmVudGVyKG5ld0V4cHJlc3Npb25TY29wZSgpKTtcbiAgICB0aGlzLnByb2RQYXJhbS5lbnRlcigwKTtcbiAgICBub2RlLnZhbHVlID0gdGhpcy5lYXQoMjkpID8gdGhpcy5wYXJzZU1heWJlQXNzaWduQWxsb3dJbigpIDogbnVsbDtcbiAgICB0aGlzLmV4cHJlc3Npb25TY29wZS5leGl0KCk7XG4gICAgdGhpcy5wcm9kUGFyYW0uZXhpdCgpO1xuICAgIHRoaXMuc2NvcGUuZXhpdCgpO1xuICB9XG4gIHBhcnNlQ2xhc3NJZChub2RlLCBpc1N0YXRlbWVudCwgb3B0aW9uYWxJZCwgYmluZGluZ1R5cGUgPSA4MzMxKSB7XG4gICAgaWYgKHRva2VuSXNJZGVudGlmaWVyKHRoaXMuc3RhdGUudHlwZSkpIHtcbiAgICAgIG5vZGUuaWQgPSB0aGlzLnBhcnNlSWRlbnRpZmllcigpO1xuICAgICAgaWYgKGlzU3RhdGVtZW50KSB7XG4gICAgICAgIHRoaXMuZGVjbGFyZU5hbWVGcm9tSWRlbnRpZmllcihub2RlLmlkLCBiaW5kaW5nVHlwZSk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChvcHRpb25hbElkIHx8ICFpc1N0YXRlbWVudCkge1xuICAgICAgICBub2RlLmlkID0gbnVsbDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IHRoaXMucmFpc2UoRXJyb3JzLk1pc3NpbmdDbGFzc05hbWUsIHRoaXMuc3RhdGUuc3RhcnRMb2MpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBwYXJzZUNsYXNzU3VwZXIobm9kZSkge1xuICAgIG5vZGUuc3VwZXJDbGFzcyA9IHRoaXMuZWF0KDgxKSA/IHRoaXMucGFyc2VFeHByU3Vic2NyaXB0cygpIDogbnVsbDtcbiAgfVxuICBwYXJzZUV4cG9ydChub2RlLCBkZWNvcmF0b3JzKSB7XG4gICAgY29uc3QgbWF5YmVEZWZhdWx0SWRlbnRpZmllciA9IHRoaXMucGFyc2VNYXliZUltcG9ydFBoYXNlKG5vZGUsIHRydWUpO1xuICAgIGNvbnN0IGhhc0RlZmF1bHQgPSB0aGlzLm1heWJlUGFyc2VFeHBvcnREZWZhdWx0U3BlY2lmaWVyKG5vZGUsIG1heWJlRGVmYXVsdElkZW50aWZpZXIpO1xuICAgIGNvbnN0IHBhcnNlQWZ0ZXJEZWZhdWx0ID0gIWhhc0RlZmF1bHQgfHwgdGhpcy5lYXQoMTIpO1xuICAgIGNvbnN0IGhhc1N0YXIgPSBwYXJzZUFmdGVyRGVmYXVsdCAmJiB0aGlzLmVhdEV4cG9ydFN0YXIobm9kZSk7XG4gICAgY29uc3QgaGFzTmFtZXNwYWNlID0gaGFzU3RhciAmJiB0aGlzLm1heWJlUGFyc2VFeHBvcnROYW1lc3BhY2VTcGVjaWZpZXIobm9kZSk7XG4gICAgY29uc3QgcGFyc2VBZnRlck5hbWVzcGFjZSA9IHBhcnNlQWZ0ZXJEZWZhdWx0ICYmICghaGFzTmFtZXNwYWNlIHx8IHRoaXMuZWF0KDEyKSk7XG4gICAgY29uc3QgaXNGcm9tUmVxdWlyZWQgPSBoYXNEZWZhdWx0IHx8IGhhc1N0YXI7XG4gICAgaWYgKGhhc1N0YXIgJiYgIWhhc05hbWVzcGFjZSkge1xuICAgICAgaWYgKGhhc0RlZmF1bHQpIHRoaXMudW5leHBlY3RlZCgpO1xuICAgICAgaWYgKGRlY29yYXRvcnMpIHtcbiAgICAgICAgdGhyb3cgdGhpcy5yYWlzZShFcnJvcnMuVW5zdXBwb3J0ZWREZWNvcmF0b3JFeHBvcnQsIG5vZGUpO1xuICAgICAgfVxuICAgICAgdGhpcy5wYXJzZUV4cG9ydEZyb20obm9kZSwgdHJ1ZSk7XG4gICAgICB0aGlzLnNhd1VuYW1iaWd1b3VzRVNNID0gdHJ1ZTtcbiAgICAgIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJFeHBvcnRBbGxEZWNsYXJhdGlvblwiKTtcbiAgICB9XG4gICAgY29uc3QgaGFzU3BlY2lmaWVycyA9IHRoaXMubWF5YmVQYXJzZUV4cG9ydE5hbWVkU3BlY2lmaWVycyhub2RlKTtcbiAgICBpZiAoaGFzRGVmYXVsdCAmJiBwYXJzZUFmdGVyRGVmYXVsdCAmJiAhaGFzU3RhciAmJiAhaGFzU3BlY2lmaWVycykge1xuICAgICAgdGhpcy51bmV4cGVjdGVkKG51bGwsIDUpO1xuICAgIH1cbiAgICBpZiAoaGFzTmFtZXNwYWNlICYmIHBhcnNlQWZ0ZXJOYW1lc3BhY2UpIHtcbiAgICAgIHRoaXMudW5leHBlY3RlZChudWxsLCA5OCk7XG4gICAgfVxuICAgIGxldCBoYXNEZWNsYXJhdGlvbjtcbiAgICBpZiAoaXNGcm9tUmVxdWlyZWQgfHwgaGFzU3BlY2lmaWVycykge1xuICAgICAgaGFzRGVjbGFyYXRpb24gPSBmYWxzZTtcbiAgICAgIGlmIChkZWNvcmF0b3JzKSB7XG4gICAgICAgIHRocm93IHRoaXMucmFpc2UoRXJyb3JzLlVuc3VwcG9ydGVkRGVjb3JhdG9yRXhwb3J0LCBub2RlKTtcbiAgICAgIH1cbiAgICAgIHRoaXMucGFyc2VFeHBvcnRGcm9tKG5vZGUsIGlzRnJvbVJlcXVpcmVkKTtcbiAgICB9IGVsc2Uge1xuICAgICAgaGFzRGVjbGFyYXRpb24gPSB0aGlzLm1heWJlUGFyc2VFeHBvcnREZWNsYXJhdGlvbihub2RlKTtcbiAgICB9XG4gICAgaWYgKGlzRnJvbVJlcXVpcmVkIHx8IGhhc1NwZWNpZmllcnMgfHwgaGFzRGVjbGFyYXRpb24pIHtcbiAgICAgIHZhciBfbm9kZTIkZGVjbGFyYXRpb247XG4gICAgICBjb25zdCBub2RlMiA9IG5vZGU7XG4gICAgICB0aGlzLmNoZWNrRXhwb3J0KG5vZGUyLCB0cnVlLCBmYWxzZSwgISFub2RlMi5zb3VyY2UpO1xuICAgICAgaWYgKCgoX25vZGUyJGRlY2xhcmF0aW9uID0gbm9kZTIuZGVjbGFyYXRpb24pID09IG51bGwgPyB2b2lkIDAgOiBfbm9kZTIkZGVjbGFyYXRpb24udHlwZSkgPT09IFwiQ2xhc3NEZWNsYXJhdGlvblwiKSB7XG4gICAgICAgIHRoaXMubWF5YmVUYWtlRGVjb3JhdG9ycyhkZWNvcmF0b3JzLCBub2RlMi5kZWNsYXJhdGlvbiwgbm9kZTIpO1xuICAgICAgfSBlbHNlIGlmIChkZWNvcmF0b3JzKSB7XG4gICAgICAgIHRocm93IHRoaXMucmFpc2UoRXJyb3JzLlVuc3VwcG9ydGVkRGVjb3JhdG9yRXhwb3J0LCBub2RlKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuc2F3VW5hbWJpZ3VvdXNFU00gPSB0cnVlO1xuICAgICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlMiwgXCJFeHBvcnROYW1lZERlY2xhcmF0aW9uXCIpO1xuICAgIH1cbiAgICBpZiAodGhpcy5lYXQoNjUpKSB7XG4gICAgICBjb25zdCBub2RlMiA9IG5vZGU7XG4gICAgICBjb25zdCBkZWNsID0gdGhpcy5wYXJzZUV4cG9ydERlZmF1bHRFeHByZXNzaW9uKCk7XG4gICAgICBub2RlMi5kZWNsYXJhdGlvbiA9IGRlY2w7XG4gICAgICBpZiAoZGVjbC50eXBlID09PSBcIkNsYXNzRGVjbGFyYXRpb25cIikge1xuICAgICAgICB0aGlzLm1heWJlVGFrZURlY29yYXRvcnMoZGVjb3JhdG9ycywgZGVjbCwgbm9kZTIpO1xuICAgICAgfSBlbHNlIGlmIChkZWNvcmF0b3JzKSB7XG4gICAgICAgIHRocm93IHRoaXMucmFpc2UoRXJyb3JzLlVuc3VwcG9ydGVkRGVjb3JhdG9yRXhwb3J0LCBub2RlKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuY2hlY2tFeHBvcnQobm9kZTIsIHRydWUsIHRydWUpO1xuICAgICAgdGhpcy5zYXdVbmFtYmlndW91c0VTTSA9IHRydWU7XG4gICAgICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUyLCBcIkV4cG9ydERlZmF1bHREZWNsYXJhdGlvblwiKTtcbiAgICB9XG4gICAgdGhyb3cgdGhpcy51bmV4cGVjdGVkKG51bGwsIDUpO1xuICB9XG4gIGVhdEV4cG9ydFN0YXIobm9kZSkge1xuICAgIHJldHVybiB0aGlzLmVhdCg1NSk7XG4gIH1cbiAgbWF5YmVQYXJzZUV4cG9ydERlZmF1bHRTcGVjaWZpZXIobm9kZSwgbWF5YmVEZWZhdWx0SWRlbnRpZmllcikge1xuICAgIGlmIChtYXliZURlZmF1bHRJZGVudGlmaWVyIHx8IHRoaXMuaXNFeHBvcnREZWZhdWx0U3BlY2lmaWVyKCkpIHtcbiAgICAgIHRoaXMuZXhwZWN0UGx1Z2luKFwiZXhwb3J0RGVmYXVsdEZyb21cIiwgbWF5YmVEZWZhdWx0SWRlbnRpZmllciA9PSBudWxsID8gdm9pZCAwIDogbWF5YmVEZWZhdWx0SWRlbnRpZmllci5sb2Muc3RhcnQpO1xuICAgICAgY29uc3QgaWQgPSBtYXliZURlZmF1bHRJZGVudGlmaWVyIHx8IHRoaXMucGFyc2VJZGVudGlmaWVyKHRydWUpO1xuICAgICAgY29uc3Qgc3BlY2lmaWVyID0gdGhpcy5zdGFydE5vZGVBdE5vZGUoaWQpO1xuICAgICAgc3BlY2lmaWVyLmV4cG9ydGVkID0gaWQ7XG4gICAgICBub2RlLnNwZWNpZmllcnMgPSBbdGhpcy5maW5pc2hOb2RlKHNwZWNpZmllciwgXCJFeHBvcnREZWZhdWx0U3BlY2lmaWVyXCIpXTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgbWF5YmVQYXJzZUV4cG9ydE5hbWVzcGFjZVNwZWNpZmllcihub2RlKSB7XG4gICAgaWYgKHRoaXMuaXNDb250ZXh0dWFsKDkzKSkge1xuICAgICAgdmFyIF9yZWYsIF9yZWYkc3BlY2lmaWVycztcbiAgICAgIChfcmVmJHNwZWNpZmllcnMgPSAoX3JlZiA9IG5vZGUpLnNwZWNpZmllcnMpICE9IG51bGwgPyBfcmVmJHNwZWNpZmllcnMgOiBfcmVmLnNwZWNpZmllcnMgPSBbXTtcbiAgICAgIGNvbnN0IHNwZWNpZmllciA9IHRoaXMuc3RhcnROb2RlQXQodGhpcy5zdGF0ZS5sYXN0VG9rU3RhcnRMb2MpO1xuICAgICAgdGhpcy5uZXh0KCk7XG4gICAgICBzcGVjaWZpZXIuZXhwb3J0ZWQgPSB0aGlzLnBhcnNlTW9kdWxlRXhwb3J0TmFtZSgpO1xuICAgICAgbm9kZS5zcGVjaWZpZXJzLnB1c2godGhpcy5maW5pc2hOb2RlKHNwZWNpZmllciwgXCJFeHBvcnROYW1lc3BhY2VTcGVjaWZpZXJcIikpO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBtYXliZVBhcnNlRXhwb3J0TmFtZWRTcGVjaWZpZXJzKG5vZGUpIHtcbiAgICBpZiAodGhpcy5tYXRjaCg1KSkge1xuICAgICAgY29uc3Qgbm9kZTIgPSBub2RlO1xuICAgICAgaWYgKCFub2RlMi5zcGVjaWZpZXJzKSBub2RlMi5zcGVjaWZpZXJzID0gW107XG4gICAgICBjb25zdCBpc1R5cGVFeHBvcnQgPSBub2RlMi5leHBvcnRLaW5kID09PSBcInR5cGVcIjtcbiAgICAgIG5vZGUyLnNwZWNpZmllcnMucHVzaCguLi50aGlzLnBhcnNlRXhwb3J0U3BlY2lmaWVycyhpc1R5cGVFeHBvcnQpKTtcbiAgICAgIG5vZGUyLnNvdXJjZSA9IG51bGw7XG4gICAgICBpZiAodGhpcy5oYXNQbHVnaW4oXCJpbXBvcnRBc3NlcnRpb25zXCIpKSB7XG4gICAgICAgIG5vZGUyLmFzc2VydGlvbnMgPSBbXTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG5vZGUyLmF0dHJpYnV0ZXMgPSBbXTtcbiAgICAgIH1cbiAgICAgIG5vZGUyLmRlY2xhcmF0aW9uID0gbnVsbDtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgbWF5YmVQYXJzZUV4cG9ydERlY2xhcmF0aW9uKG5vZGUpIHtcbiAgICBpZiAodGhpcy5zaG91bGRQYXJzZUV4cG9ydERlY2xhcmF0aW9uKCkpIHtcbiAgICAgIG5vZGUuc3BlY2lmaWVycyA9IFtdO1xuICAgICAgbm9kZS5zb3VyY2UgPSBudWxsO1xuICAgICAgaWYgKHRoaXMuaGFzUGx1Z2luKFwiaW1wb3J0QXNzZXJ0aW9uc1wiKSkge1xuICAgICAgICBub2RlLmFzc2VydGlvbnMgPSBbXTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG5vZGUuYXR0cmlidXRlcyA9IFtdO1xuICAgICAgfVxuICAgICAgbm9kZS5kZWNsYXJhdGlvbiA9IHRoaXMucGFyc2VFeHBvcnREZWNsYXJhdGlvbihub2RlKTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgaXNBc3luY0Z1bmN0aW9uKCkge1xuICAgIGlmICghdGhpcy5pc0NvbnRleHR1YWwoOTUpKSByZXR1cm4gZmFsc2U7XG4gICAgY29uc3QgbmV4dCA9IHRoaXMubmV4dFRva2VuSW5MaW5lU3RhcnQoKTtcbiAgICByZXR1cm4gdGhpcy5pc1VucGFyc2VkQ29udGV4dHVhbChuZXh0LCBcImZ1bmN0aW9uXCIpO1xuICB9XG4gIHBhcnNlRXhwb3J0RGVmYXVsdEV4cHJlc3Npb24oKSB7XG4gICAgY29uc3QgZXhwciA9IHRoaXMuc3RhcnROb2RlKCk7XG4gICAgaWYgKHRoaXMubWF0Y2goNjgpKSB7XG4gICAgICB0aGlzLm5leHQoKTtcbiAgICAgIHJldHVybiB0aGlzLnBhcnNlRnVuY3Rpb24oZXhwciwgMSB8IDQpO1xuICAgIH0gZWxzZSBpZiAodGhpcy5pc0FzeW5jRnVuY3Rpb24oKSkge1xuICAgICAgdGhpcy5uZXh0KCk7XG4gICAgICB0aGlzLm5leHQoKTtcbiAgICAgIHJldHVybiB0aGlzLnBhcnNlRnVuY3Rpb24oZXhwciwgMSB8IDQgfCA4KTtcbiAgICB9XG4gICAgaWYgKHRoaXMubWF0Y2goODApKSB7XG4gICAgICByZXR1cm4gdGhpcy5wYXJzZUNsYXNzKGV4cHIsIHRydWUsIHRydWUpO1xuICAgIH1cbiAgICBpZiAodGhpcy5tYXRjaCgyNikpIHtcbiAgICAgIGlmICh0aGlzLmhhc1BsdWdpbihcImRlY29yYXRvcnNcIikgJiYgdGhpcy5nZXRQbHVnaW5PcHRpb24oXCJkZWNvcmF0b3JzXCIsIFwiZGVjb3JhdG9yc0JlZm9yZUV4cG9ydFwiKSA9PT0gdHJ1ZSkge1xuICAgICAgICB0aGlzLnJhaXNlKEVycm9ycy5EZWNvcmF0b3JCZWZvcmVFeHBvcnQsIHRoaXMuc3RhdGUuc3RhcnRMb2MpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXMucGFyc2VDbGFzcyh0aGlzLm1heWJlVGFrZURlY29yYXRvcnModGhpcy5wYXJzZURlY29yYXRvcnMoZmFsc2UpLCB0aGlzLnN0YXJ0Tm9kZSgpKSwgdHJ1ZSwgdHJ1ZSk7XG4gICAgfVxuICAgIGlmICh0aGlzLm1hdGNoKDc1KSB8fCB0aGlzLm1hdGNoKDc0KSB8fCB0aGlzLmlzTGV0KCkgfHwgdGhpcy5pc1VzaW5nKCkgfHwgdGhpcy5pc0F3YWl0VXNpbmcoKSkge1xuICAgICAgdGhyb3cgdGhpcy5yYWlzZShFcnJvcnMuVW5zdXBwb3J0ZWREZWZhdWx0RXhwb3J0LCB0aGlzLnN0YXRlLnN0YXJ0TG9jKTtcbiAgICB9XG4gICAgY29uc3QgcmVzID0gdGhpcy5wYXJzZU1heWJlQXNzaWduQWxsb3dJbigpO1xuICAgIHRoaXMuc2VtaWNvbG9uKCk7XG4gICAgcmV0dXJuIHJlcztcbiAgfVxuICBwYXJzZUV4cG9ydERlY2xhcmF0aW9uKG5vZGUpIHtcbiAgICBpZiAodGhpcy5tYXRjaCg4MCkpIHtcbiAgICAgIGNvbnN0IG5vZGUgPSB0aGlzLnBhcnNlQ2xhc3ModGhpcy5zdGFydE5vZGUoKSwgdHJ1ZSwgZmFsc2UpO1xuICAgICAgcmV0dXJuIG5vZGU7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLnBhcnNlU3RhdGVtZW50TGlzdEl0ZW0oKTtcbiAgfVxuICBpc0V4cG9ydERlZmF1bHRTcGVjaWZpZXIoKSB7XG4gICAgY29uc3Qge1xuICAgICAgdHlwZVxuICAgIH0gPSB0aGlzLnN0YXRlO1xuICAgIGlmICh0b2tlbklzSWRlbnRpZmllcih0eXBlKSkge1xuICAgICAgaWYgKHR5cGUgPT09IDk1ICYmICF0aGlzLnN0YXRlLmNvbnRhaW5zRXNjIHx8IHR5cGUgPT09IDEwMCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICBpZiAoKHR5cGUgPT09IDEzMCB8fCB0eXBlID09PSAxMjkpICYmICF0aGlzLnN0YXRlLmNvbnRhaW5zRXNjKSB7XG4gICAgICAgIGNvbnN0IG5leHQgPSB0aGlzLm5leHRUb2tlblN0YXJ0KCk7XG4gICAgICAgIGNvbnN0IG5leHRDaGFyID0gdGhpcy5pbnB1dC5jaGFyQ29kZUF0KG5leHQpO1xuICAgICAgICBpZiAobmV4dENoYXIgPT09IDEyMyB8fCB0aGlzLmNoU3RhcnRzQmluZGluZ0lkZW50aWZpZXIobmV4dENoYXIsIG5leHQpICYmICF0aGlzLmlucHV0LnN0YXJ0c1dpdGgoXCJmcm9tXCIsIG5leHQpKSB7XG4gICAgICAgICAgdGhpcy5leHBlY3RPbmVQbHVnaW4oW1wiZmxvd1wiLCBcInR5cGVzY3JpcHRcIl0pO1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoIXRoaXMubWF0Y2goNjUpKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGNvbnN0IG5leHQgPSB0aGlzLm5leHRUb2tlblN0YXJ0KCk7XG4gICAgY29uc3QgaGFzRnJvbSA9IHRoaXMuaXNVbnBhcnNlZENvbnRleHR1YWwobmV4dCwgXCJmcm9tXCIpO1xuICAgIGlmICh0aGlzLmlucHV0LmNoYXJDb2RlQXQobmV4dCkgPT09IDQ0IHx8IHRva2VuSXNJZGVudGlmaWVyKHRoaXMuc3RhdGUudHlwZSkgJiYgaGFzRnJvbSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGlmICh0aGlzLm1hdGNoKDY1KSAmJiBoYXNGcm9tKSB7XG4gICAgICBjb25zdCBuZXh0QWZ0ZXJGcm9tID0gdGhpcy5pbnB1dC5jaGFyQ29kZUF0KHRoaXMubmV4dFRva2VuU3RhcnRTaW5jZShuZXh0ICsgNCkpO1xuICAgICAgcmV0dXJuIG5leHRBZnRlckZyb20gPT09IDM0IHx8IG5leHRBZnRlckZyb20gPT09IDM5O1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgcGFyc2VFeHBvcnRGcm9tKG5vZGUsIGV4cGVjdCkge1xuICAgIGlmICh0aGlzLmVhdENvbnRleHR1YWwoOTgpKSB7XG4gICAgICBub2RlLnNvdXJjZSA9IHRoaXMucGFyc2VJbXBvcnRTb3VyY2UoKTtcbiAgICAgIHRoaXMuY2hlY2tFeHBvcnQobm9kZSk7XG4gICAgICB0aGlzLm1heWJlUGFyc2VJbXBvcnRBdHRyaWJ1dGVzKG5vZGUpO1xuICAgICAgdGhpcy5jaGVja0pTT05Nb2R1bGVJbXBvcnQobm9kZSk7XG4gICAgfSBlbHNlIGlmIChleHBlY3QpIHtcbiAgICAgIHRoaXMudW5leHBlY3RlZCgpO1xuICAgIH1cbiAgICB0aGlzLnNlbWljb2xvbigpO1xuICB9XG4gIHNob3VsZFBhcnNlRXhwb3J0RGVjbGFyYXRpb24oKSB7XG4gICAgY29uc3Qge1xuICAgICAgdHlwZVxuICAgIH0gPSB0aGlzLnN0YXRlO1xuICAgIGlmICh0eXBlID09PSAyNikge1xuICAgICAgdGhpcy5leHBlY3RPbmVQbHVnaW4oW1wiZGVjb3JhdG9yc1wiLCBcImRlY29yYXRvcnMtbGVnYWN5XCJdKTtcbiAgICAgIGlmICh0aGlzLmhhc1BsdWdpbihcImRlY29yYXRvcnNcIikpIHtcbiAgICAgICAgaWYgKHRoaXMuZ2V0UGx1Z2luT3B0aW9uKFwiZGVjb3JhdG9yc1wiLCBcImRlY29yYXRvcnNCZWZvcmVFeHBvcnRcIikgPT09IHRydWUpIHtcbiAgICAgICAgICB0aGlzLnJhaXNlKEVycm9ycy5EZWNvcmF0b3JCZWZvcmVFeHBvcnQsIHRoaXMuc3RhdGUuc3RhcnRMb2MpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAodGhpcy5pc1VzaW5nKCkpIHtcbiAgICAgIHRoaXMucmFpc2UoRXJyb3JzLlVzaW5nRGVjbGFyYXRpb25FeHBvcnQsIHRoaXMuc3RhdGUuc3RhcnRMb2MpO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGlmICh0aGlzLmlzQXdhaXRVc2luZygpKSB7XG4gICAgICB0aGlzLnJhaXNlKEVycm9ycy5Vc2luZ0RlY2xhcmF0aW9uRXhwb3J0LCB0aGlzLnN0YXRlLnN0YXJ0TG9jKTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gdHlwZSA9PT0gNzQgfHwgdHlwZSA9PT0gNzUgfHwgdHlwZSA9PT0gNjggfHwgdHlwZSA9PT0gODAgfHwgdGhpcy5pc0xldCgpIHx8IHRoaXMuaXNBc3luY0Z1bmN0aW9uKCk7XG4gIH1cbiAgY2hlY2tFeHBvcnQobm9kZSwgY2hlY2tOYW1lcywgaXNEZWZhdWx0LCBpc0Zyb20pIHtcbiAgICBpZiAoY2hlY2tOYW1lcykge1xuICAgICAgdmFyIF9ub2RlJHNwZWNpZmllcnM7XG4gICAgICBpZiAoaXNEZWZhdWx0KSB7XG4gICAgICAgIHRoaXMuY2hlY2tEdXBsaWNhdGVFeHBvcnRzKG5vZGUsIFwiZGVmYXVsdFwiKTtcbiAgICAgICAgaWYgKHRoaXMuaGFzUGx1Z2luKFwiZXhwb3J0RGVmYXVsdEZyb21cIikpIHtcbiAgICAgICAgICB2YXIgX2RlY2xhcmF0aW9uJGV4dHJhO1xuICAgICAgICAgIGNvbnN0IGRlY2xhcmF0aW9uID0gbm9kZS5kZWNsYXJhdGlvbjtcbiAgICAgICAgICBpZiAoZGVjbGFyYXRpb24udHlwZSA9PT0gXCJJZGVudGlmaWVyXCIgJiYgZGVjbGFyYXRpb24ubmFtZSA9PT0gXCJmcm9tXCIgJiYgZGVjbGFyYXRpb24uZW5kIC0gZGVjbGFyYXRpb24uc3RhcnQgPT09IDQgJiYgISgoX2RlY2xhcmF0aW9uJGV4dHJhID0gZGVjbGFyYXRpb24uZXh0cmEpICE9IG51bGwgJiYgX2RlY2xhcmF0aW9uJGV4dHJhLnBhcmVudGhlc2l6ZWQpKSB7XG4gICAgICAgICAgICB0aGlzLnJhaXNlKEVycm9ycy5FeHBvcnREZWZhdWx0RnJvbUFzSWRlbnRpZmllciwgZGVjbGFyYXRpb24pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmICgoX25vZGUkc3BlY2lmaWVycyA9IG5vZGUuc3BlY2lmaWVycykgIT0gbnVsbCAmJiBfbm9kZSRzcGVjaWZpZXJzLmxlbmd0aCkge1xuICAgICAgICBmb3IgKGNvbnN0IHNwZWNpZmllciBvZiBub2RlLnNwZWNpZmllcnMpIHtcbiAgICAgICAgICBjb25zdCB7XG4gICAgICAgICAgICBleHBvcnRlZFxuICAgICAgICAgIH0gPSBzcGVjaWZpZXI7XG4gICAgICAgICAgY29uc3QgZXhwb3J0TmFtZSA9IGV4cG9ydGVkLnR5cGUgPT09IFwiSWRlbnRpZmllclwiID8gZXhwb3J0ZWQubmFtZSA6IGV4cG9ydGVkLnZhbHVlO1xuICAgICAgICAgIHRoaXMuY2hlY2tEdXBsaWNhdGVFeHBvcnRzKHNwZWNpZmllciwgZXhwb3J0TmFtZSk7XG4gICAgICAgICAgaWYgKCFpc0Zyb20gJiYgc3BlY2lmaWVyLmxvY2FsKSB7XG4gICAgICAgICAgICBjb25zdCB7XG4gICAgICAgICAgICAgIGxvY2FsXG4gICAgICAgICAgICB9ID0gc3BlY2lmaWVyO1xuICAgICAgICAgICAgaWYgKGxvY2FsLnR5cGUgIT09IFwiSWRlbnRpZmllclwiKSB7XG4gICAgICAgICAgICAgIHRoaXMucmFpc2UoRXJyb3JzLkV4cG9ydEJpbmRpbmdJc1N0cmluZywgc3BlY2lmaWVyLCB7XG4gICAgICAgICAgICAgICAgbG9jYWxOYW1lOiBsb2NhbC52YWx1ZSxcbiAgICAgICAgICAgICAgICBleHBvcnROYW1lXG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgdGhpcy5jaGVja1Jlc2VydmVkV29yZChsb2NhbC5uYW1lLCBsb2NhbC5sb2Muc3RhcnQsIHRydWUsIGZhbHNlKTtcbiAgICAgICAgICAgICAgdGhpcy5zY29wZS5jaGVja0xvY2FsRXhwb3J0KGxvY2FsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAobm9kZS5kZWNsYXJhdGlvbikge1xuICAgICAgICBjb25zdCBkZWNsID0gbm9kZS5kZWNsYXJhdGlvbjtcbiAgICAgICAgaWYgKGRlY2wudHlwZSA9PT0gXCJGdW5jdGlvbkRlY2xhcmF0aW9uXCIgfHwgZGVjbC50eXBlID09PSBcIkNsYXNzRGVjbGFyYXRpb25cIikge1xuICAgICAgICAgIGNvbnN0IHtcbiAgICAgICAgICAgIGlkXG4gICAgICAgICAgfSA9IGRlY2w7XG4gICAgICAgICAgaWYgKCFpZCkgdGhyb3cgbmV3IEVycm9yKFwiQXNzZXJ0aW9uIGZhaWx1cmVcIik7XG4gICAgICAgICAgdGhpcy5jaGVja0R1cGxpY2F0ZUV4cG9ydHMobm9kZSwgaWQubmFtZSk7XG4gICAgICAgIH0gZWxzZSBpZiAoZGVjbC50eXBlID09PSBcIlZhcmlhYmxlRGVjbGFyYXRpb25cIikge1xuICAgICAgICAgIGZvciAoY29uc3QgZGVjbGFyYXRpb24gb2YgZGVjbC5kZWNsYXJhdGlvbnMpIHtcbiAgICAgICAgICAgIHRoaXMuY2hlY2tEZWNsYXJhdGlvbihkZWNsYXJhdGlvbi5pZCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGNoZWNrRGVjbGFyYXRpb24obm9kZSkge1xuICAgIGlmIChub2RlLnR5cGUgPT09IFwiSWRlbnRpZmllclwiKSB7XG4gICAgICB0aGlzLmNoZWNrRHVwbGljYXRlRXhwb3J0cyhub2RlLCBub2RlLm5hbWUpO1xuICAgIH0gZWxzZSBpZiAobm9kZS50eXBlID09PSBcIk9iamVjdFBhdHRlcm5cIikge1xuICAgICAgZm9yIChjb25zdCBwcm9wIG9mIG5vZGUucHJvcGVydGllcykge1xuICAgICAgICB0aGlzLmNoZWNrRGVjbGFyYXRpb24ocHJvcCk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChub2RlLnR5cGUgPT09IFwiQXJyYXlQYXR0ZXJuXCIpIHtcbiAgICAgIGZvciAoY29uc3QgZWxlbSBvZiBub2RlLmVsZW1lbnRzKSB7XG4gICAgICAgIGlmIChlbGVtKSB7XG4gICAgICAgICAgdGhpcy5jaGVja0RlY2xhcmF0aW9uKGVsZW0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChub2RlLnR5cGUgPT09IFwiT2JqZWN0UHJvcGVydHlcIikge1xuICAgICAgdGhpcy5jaGVja0RlY2xhcmF0aW9uKG5vZGUudmFsdWUpO1xuICAgIH0gZWxzZSBpZiAobm9kZS50eXBlID09PSBcIlJlc3RFbGVtZW50XCIpIHtcbiAgICAgIHRoaXMuY2hlY2tEZWNsYXJhdGlvbihub2RlLmFyZ3VtZW50KTtcbiAgICB9IGVsc2UgaWYgKG5vZGUudHlwZSA9PT0gXCJBc3NpZ25tZW50UGF0dGVyblwiKSB7XG4gICAgICB0aGlzLmNoZWNrRGVjbGFyYXRpb24obm9kZS5sZWZ0KTtcbiAgICB9XG4gIH1cbiAgY2hlY2tEdXBsaWNhdGVFeHBvcnRzKG5vZGUsIGV4cG9ydE5hbWUpIHtcbiAgICBpZiAodGhpcy5leHBvcnRlZElkZW50aWZpZXJzLmhhcyhleHBvcnROYW1lKSkge1xuICAgICAgaWYgKGV4cG9ydE5hbWUgPT09IFwiZGVmYXVsdFwiKSB7XG4gICAgICAgIHRoaXMucmFpc2UoRXJyb3JzLkR1cGxpY2F0ZURlZmF1bHRFeHBvcnQsIG5vZGUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5yYWlzZShFcnJvcnMuRHVwbGljYXRlRXhwb3J0LCBub2RlLCB7XG4gICAgICAgICAgZXhwb3J0TmFtZVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG4gICAgdGhpcy5leHBvcnRlZElkZW50aWZpZXJzLmFkZChleHBvcnROYW1lKTtcbiAgfVxuICBwYXJzZUV4cG9ydFNwZWNpZmllcnMoaXNJblR5cGVFeHBvcnQpIHtcbiAgICBjb25zdCBub2RlcyA9IFtdO1xuICAgIGxldCBmaXJzdCA9IHRydWU7XG4gICAgdGhpcy5leHBlY3QoNSk7XG4gICAgd2hpbGUgKCF0aGlzLmVhdCg4KSkge1xuICAgICAgaWYgKGZpcnN0KSB7XG4gICAgICAgIGZpcnN0ID0gZmFsc2U7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmV4cGVjdCgxMik7XG4gICAgICAgIGlmICh0aGlzLmVhdCg4KSkgYnJlYWs7XG4gICAgICB9XG4gICAgICBjb25zdCBpc01heWJlVHlwZU9ubHkgPSB0aGlzLmlzQ29udGV4dHVhbCgxMzApO1xuICAgICAgY29uc3QgaXNTdHJpbmcgPSB0aGlzLm1hdGNoKDEzNCk7XG4gICAgICBjb25zdCBub2RlID0gdGhpcy5zdGFydE5vZGUoKTtcbiAgICAgIG5vZGUubG9jYWwgPSB0aGlzLnBhcnNlTW9kdWxlRXhwb3J0TmFtZSgpO1xuICAgICAgbm9kZXMucHVzaCh0aGlzLnBhcnNlRXhwb3J0U3BlY2lmaWVyKG5vZGUsIGlzU3RyaW5nLCBpc0luVHlwZUV4cG9ydCwgaXNNYXliZVR5cGVPbmx5KSk7XG4gICAgfVxuICAgIHJldHVybiBub2RlcztcbiAgfVxuICBwYXJzZUV4cG9ydFNwZWNpZmllcihub2RlLCBpc1N0cmluZywgaXNJblR5cGVFeHBvcnQsIGlzTWF5YmVUeXBlT25seSkge1xuICAgIGlmICh0aGlzLmVhdENvbnRleHR1YWwoOTMpKSB7XG4gICAgICBub2RlLmV4cG9ydGVkID0gdGhpcy5wYXJzZU1vZHVsZUV4cG9ydE5hbWUoKTtcbiAgICB9IGVsc2UgaWYgKGlzU3RyaW5nKSB7XG4gICAgICBub2RlLmV4cG9ydGVkID0gdGhpcy5jbG9uZVN0cmluZ0xpdGVyYWwobm9kZS5sb2NhbCk7XG4gICAgfSBlbHNlIGlmICghbm9kZS5leHBvcnRlZCkge1xuICAgICAgbm9kZS5leHBvcnRlZCA9IHRoaXMuY2xvbmVJZGVudGlmaWVyKG5vZGUubG9jYWwpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiRXhwb3J0U3BlY2lmaWVyXCIpO1xuICB9XG4gIHBhcnNlTW9kdWxlRXhwb3J0TmFtZSgpIHtcbiAgICBpZiAodGhpcy5tYXRjaCgxMzQpKSB7XG4gICAgICBjb25zdCByZXN1bHQgPSB0aGlzLnBhcnNlU3RyaW5nTGl0ZXJhbCh0aGlzLnN0YXRlLnZhbHVlKTtcbiAgICAgIGNvbnN0IHN1cnJvZ2F0ZSA9IGxvbmVTdXJyb2dhdGUuZXhlYyhyZXN1bHQudmFsdWUpO1xuICAgICAgaWYgKHN1cnJvZ2F0ZSkge1xuICAgICAgICB0aGlzLnJhaXNlKEVycm9ycy5Nb2R1bGVFeHBvcnROYW1lSGFzTG9uZVN1cnJvZ2F0ZSwgcmVzdWx0LCB7XG4gICAgICAgICAgc3Vycm9nYXRlQ2hhckNvZGU6IHN1cnJvZ2F0ZVswXS5jaGFyQ29kZUF0KDApXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMucGFyc2VJZGVudGlmaWVyKHRydWUpO1xuICB9XG4gIGlzSlNPTk1vZHVsZUltcG9ydChub2RlKSB7XG4gICAgaWYgKG5vZGUuYXNzZXJ0aW9ucyAhPSBudWxsKSB7XG4gICAgICByZXR1cm4gbm9kZS5hc3NlcnRpb25zLnNvbWUoKHtcbiAgICAgICAga2V5LFxuICAgICAgICB2YWx1ZVxuICAgICAgfSkgPT4ge1xuICAgICAgICByZXR1cm4gdmFsdWUudmFsdWUgPT09IFwianNvblwiICYmIChrZXkudHlwZSA9PT0gXCJJZGVudGlmaWVyXCIgPyBrZXkubmFtZSA9PT0gXCJ0eXBlXCIgOiBrZXkudmFsdWUgPT09IFwidHlwZVwiKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgY2hlY2tJbXBvcnRSZWZsZWN0aW9uKG5vZGUpIHtcbiAgICBjb25zdCB7XG4gICAgICBzcGVjaWZpZXJzXG4gICAgfSA9IG5vZGU7XG4gICAgY29uc3Qgc2luZ2xlQmluZGluZ1R5cGUgPSBzcGVjaWZpZXJzLmxlbmd0aCA9PT0gMSA/IHNwZWNpZmllcnNbMF0udHlwZSA6IG51bGw7XG4gICAgaWYgKG5vZGUucGhhc2UgPT09IFwic291cmNlXCIpIHtcbiAgICAgIGlmIChzaW5nbGVCaW5kaW5nVHlwZSAhPT0gXCJJbXBvcnREZWZhdWx0U3BlY2lmaWVyXCIpIHtcbiAgICAgICAgdGhpcy5yYWlzZShFcnJvcnMuU291cmNlUGhhc2VJbXBvcnRSZXF1aXJlc0RlZmF1bHQsIHNwZWNpZmllcnNbMF0ubG9jLnN0YXJ0KTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKG5vZGUucGhhc2UgPT09IFwiZGVmZXJcIikge1xuICAgICAgaWYgKHNpbmdsZUJpbmRpbmdUeXBlICE9PSBcIkltcG9ydE5hbWVzcGFjZVNwZWNpZmllclwiKSB7XG4gICAgICAgIHRoaXMucmFpc2UoRXJyb3JzLkRlZmVySW1wb3J0UmVxdWlyZXNOYW1lc3BhY2UsIHNwZWNpZmllcnNbMF0ubG9jLnN0YXJ0KTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKG5vZGUubW9kdWxlKSB7XG4gICAgICB2YXIgX25vZGUkYXNzZXJ0aW9ucztcbiAgICAgIGlmIChzaW5nbGVCaW5kaW5nVHlwZSAhPT0gXCJJbXBvcnREZWZhdWx0U3BlY2lmaWVyXCIpIHtcbiAgICAgICAgdGhpcy5yYWlzZShFcnJvcnMuSW1wb3J0UmVmbGVjdGlvbk5vdEJpbmRpbmcsIHNwZWNpZmllcnNbMF0ubG9jLnN0YXJ0KTtcbiAgICAgIH1cbiAgICAgIGlmICgoKF9ub2RlJGFzc2VydGlvbnMgPSBub2RlLmFzc2VydGlvbnMpID09IG51bGwgPyB2b2lkIDAgOiBfbm9kZSRhc3NlcnRpb25zLmxlbmd0aCkgPiAwKSB7XG4gICAgICAgIHRoaXMucmFpc2UoRXJyb3JzLkltcG9ydFJlZmxlY3Rpb25IYXNBc3NlcnRpb24sIHNwZWNpZmllcnNbMF0ubG9jLnN0YXJ0KTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgY2hlY2tKU09OTW9kdWxlSW1wb3J0KG5vZGUpIHtcbiAgICBpZiAodGhpcy5pc0pTT05Nb2R1bGVJbXBvcnQobm9kZSkgJiYgbm9kZS50eXBlICE9PSBcIkV4cG9ydEFsbERlY2xhcmF0aW9uXCIpIHtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgc3BlY2lmaWVyc1xuICAgICAgfSA9IG5vZGU7XG4gICAgICBpZiAoc3BlY2lmaWVycyAhPSBudWxsKSB7XG4gICAgICAgIGNvbnN0IG5vbkRlZmF1bHROYW1lZFNwZWNpZmllciA9IHNwZWNpZmllcnMuZmluZChzcGVjaWZpZXIgPT4ge1xuICAgICAgICAgIGxldCBpbXBvcnRlZDtcbiAgICAgICAgICBpZiAoc3BlY2lmaWVyLnR5cGUgPT09IFwiRXhwb3J0U3BlY2lmaWVyXCIpIHtcbiAgICAgICAgICAgIGltcG9ydGVkID0gc3BlY2lmaWVyLmxvY2FsO1xuICAgICAgICAgIH0gZWxzZSBpZiAoc3BlY2lmaWVyLnR5cGUgPT09IFwiSW1wb3J0U3BlY2lmaWVyXCIpIHtcbiAgICAgICAgICAgIGltcG9ydGVkID0gc3BlY2lmaWVyLmltcG9ydGVkO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoaW1wb3J0ZWQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmV0dXJuIGltcG9ydGVkLnR5cGUgPT09IFwiSWRlbnRpZmllclwiID8gaW1wb3J0ZWQubmFtZSAhPT0gXCJkZWZhdWx0XCIgOiBpbXBvcnRlZC52YWx1ZSAhPT0gXCJkZWZhdWx0XCI7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgaWYgKG5vbkRlZmF1bHROYW1lZFNwZWNpZmllciAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgdGhpcy5yYWlzZShFcnJvcnMuSW1wb3J0SlNPTkJpbmRpbmdOb3REZWZhdWx0LCBub25EZWZhdWx0TmFtZWRTcGVjaWZpZXIubG9jLnN0YXJ0KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuICBpc1BvdGVudGlhbEltcG9ydFBoYXNlKGlzRXhwb3J0KSB7XG4gICAgaWYgKGlzRXhwb3J0KSByZXR1cm4gZmFsc2U7XG4gICAgcmV0dXJuIHRoaXMuaXNDb250ZXh0dWFsKDEwNSkgfHwgdGhpcy5pc0NvbnRleHR1YWwoOTcpIHx8IHRoaXMuaXNDb250ZXh0dWFsKDEyNyk7XG4gIH1cbiAgYXBwbHlJbXBvcnRQaGFzZShub2RlLCBpc0V4cG9ydCwgcGhhc2UsIGxvYykge1xuICAgIGlmIChpc0V4cG9ydCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAocGhhc2UgPT09IFwibW9kdWxlXCIpIHtcbiAgICAgIHRoaXMuZXhwZWN0UGx1Z2luKFwiaW1wb3J0UmVmbGVjdGlvblwiLCBsb2MpO1xuICAgICAgbm9kZS5tb2R1bGUgPSB0cnVlO1xuICAgIH0gZWxzZSBpZiAodGhpcy5oYXNQbHVnaW4oXCJpbXBvcnRSZWZsZWN0aW9uXCIpKSB7XG4gICAgICBub2RlLm1vZHVsZSA9IGZhbHNlO1xuICAgIH1cbiAgICBpZiAocGhhc2UgPT09IFwic291cmNlXCIpIHtcbiAgICAgIHRoaXMuZXhwZWN0UGx1Z2luKFwic291cmNlUGhhc2VJbXBvcnRzXCIsIGxvYyk7XG4gICAgICBub2RlLnBoYXNlID0gXCJzb3VyY2VcIjtcbiAgICB9IGVsc2UgaWYgKHBoYXNlID09PSBcImRlZmVyXCIpIHtcbiAgICAgIHRoaXMuZXhwZWN0UGx1Z2luKFwiZGVmZXJyZWRJbXBvcnRFdmFsdWF0aW9uXCIsIGxvYyk7XG4gICAgICBub2RlLnBoYXNlID0gXCJkZWZlclwiO1xuICAgIH0gZWxzZSBpZiAodGhpcy5oYXNQbHVnaW4oXCJzb3VyY2VQaGFzZUltcG9ydHNcIikpIHtcbiAgICAgIG5vZGUucGhhc2UgPSBudWxsO1xuICAgIH1cbiAgfVxuICBwYXJzZU1heWJlSW1wb3J0UGhhc2Uobm9kZSwgaXNFeHBvcnQpIHtcbiAgICBpZiAoIXRoaXMuaXNQb3RlbnRpYWxJbXBvcnRQaGFzZShpc0V4cG9ydCkpIHtcbiAgICAgIHRoaXMuYXBwbHlJbXBvcnRQaGFzZShub2RlLCBpc0V4cG9ydCwgbnVsbCk7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgY29uc3QgcGhhc2VJZGVudGlmaWVyID0gdGhpcy5zdGFydE5vZGUoKTtcbiAgICBjb25zdCBwaGFzZUlkZW50aWZpZXJOYW1lID0gdGhpcy5wYXJzZUlkZW50aWZpZXJOYW1lKHRydWUpO1xuICAgIGNvbnN0IHtcbiAgICAgIHR5cGVcbiAgICB9ID0gdGhpcy5zdGF0ZTtcbiAgICBjb25zdCBpc0ltcG9ydFBoYXNlID0gdG9rZW5Jc0tleXdvcmRPcklkZW50aWZpZXIodHlwZSkgPyB0eXBlICE9PSA5OCB8fCB0aGlzLmxvb2thaGVhZENoYXJDb2RlKCkgPT09IDEwMiA6IHR5cGUgIT09IDEyO1xuICAgIGlmIChpc0ltcG9ydFBoYXNlKSB7XG4gICAgICB0aGlzLmFwcGx5SW1wb3J0UGhhc2Uobm9kZSwgaXNFeHBvcnQsIHBoYXNlSWRlbnRpZmllck5hbWUsIHBoYXNlSWRlbnRpZmllci5sb2Muc3RhcnQpO1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuYXBwbHlJbXBvcnRQaGFzZShub2RlLCBpc0V4cG9ydCwgbnVsbCk7XG4gICAgICByZXR1cm4gdGhpcy5jcmVhdGVJZGVudGlmaWVyKHBoYXNlSWRlbnRpZmllciwgcGhhc2VJZGVudGlmaWVyTmFtZSk7XG4gICAgfVxuICB9XG4gIGlzUHJlY2VkaW5nSWRJbXBvcnRQaGFzZShwaGFzZSkge1xuICAgIGNvbnN0IHtcbiAgICAgIHR5cGVcbiAgICB9ID0gdGhpcy5zdGF0ZTtcbiAgICByZXR1cm4gdG9rZW5Jc0lkZW50aWZpZXIodHlwZSkgPyB0eXBlICE9PSA5OCB8fCB0aGlzLmxvb2thaGVhZENoYXJDb2RlKCkgPT09IDEwMiA6IHR5cGUgIT09IDEyO1xuICB9XG4gIHBhcnNlSW1wb3J0KG5vZGUpIHtcbiAgICBpZiAodGhpcy5tYXRjaCgxMzQpKSB7XG4gICAgICByZXR1cm4gdGhpcy5wYXJzZUltcG9ydFNvdXJjZUFuZEF0dHJpYnV0ZXMobm9kZSk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLnBhcnNlSW1wb3J0U3BlY2lmaWVyc0FuZEFmdGVyKG5vZGUsIHRoaXMucGFyc2VNYXliZUltcG9ydFBoYXNlKG5vZGUsIGZhbHNlKSk7XG4gIH1cbiAgcGFyc2VJbXBvcnRTcGVjaWZpZXJzQW5kQWZ0ZXIobm9kZSwgbWF5YmVEZWZhdWx0SWRlbnRpZmllcikge1xuICAgIG5vZGUuc3BlY2lmaWVycyA9IFtdO1xuICAgIGNvbnN0IGhhc0RlZmF1bHQgPSB0aGlzLm1heWJlUGFyc2VEZWZhdWx0SW1wb3J0U3BlY2lmaWVyKG5vZGUsIG1heWJlRGVmYXVsdElkZW50aWZpZXIpO1xuICAgIGNvbnN0IHBhcnNlTmV4dCA9ICFoYXNEZWZhdWx0IHx8IHRoaXMuZWF0KDEyKTtcbiAgICBjb25zdCBoYXNTdGFyID0gcGFyc2VOZXh0ICYmIHRoaXMubWF5YmVQYXJzZVN0YXJJbXBvcnRTcGVjaWZpZXIobm9kZSk7XG4gICAgaWYgKHBhcnNlTmV4dCAmJiAhaGFzU3RhcikgdGhpcy5wYXJzZU5hbWVkSW1wb3J0U3BlY2lmaWVycyhub2RlKTtcbiAgICB0aGlzLmV4cGVjdENvbnRleHR1YWwoOTgpO1xuICAgIHJldHVybiB0aGlzLnBhcnNlSW1wb3J0U291cmNlQW5kQXR0cmlidXRlcyhub2RlKTtcbiAgfVxuICBwYXJzZUltcG9ydFNvdXJjZUFuZEF0dHJpYnV0ZXMobm9kZSkge1xuICAgIHZhciBfbm9kZSRzcGVjaWZpZXJzMjtcbiAgICAoX25vZGUkc3BlY2lmaWVyczIgPSBub2RlLnNwZWNpZmllcnMpICE9IG51bGwgPyBfbm9kZSRzcGVjaWZpZXJzMiA6IG5vZGUuc3BlY2lmaWVycyA9IFtdO1xuICAgIG5vZGUuc291cmNlID0gdGhpcy5wYXJzZUltcG9ydFNvdXJjZSgpO1xuICAgIHRoaXMubWF5YmVQYXJzZUltcG9ydEF0dHJpYnV0ZXMobm9kZSk7XG4gICAgdGhpcy5jaGVja0ltcG9ydFJlZmxlY3Rpb24obm9kZSk7XG4gICAgdGhpcy5jaGVja0pTT05Nb2R1bGVJbXBvcnQobm9kZSk7XG4gICAgdGhpcy5zZW1pY29sb24oKTtcbiAgICB0aGlzLnNhd1VuYW1iaWd1b3VzRVNNID0gdHJ1ZTtcbiAgICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiSW1wb3J0RGVjbGFyYXRpb25cIik7XG4gIH1cbiAgcGFyc2VJbXBvcnRTb3VyY2UoKSB7XG4gICAgaWYgKCF0aGlzLm1hdGNoKDEzNCkpIHRoaXMudW5leHBlY3RlZCgpO1xuICAgIHJldHVybiB0aGlzLnBhcnNlRXhwckF0b20oKTtcbiAgfVxuICBwYXJzZUltcG9ydFNwZWNpZmllckxvY2FsKG5vZGUsIHNwZWNpZmllciwgdHlwZSkge1xuICAgIHNwZWNpZmllci5sb2NhbCA9IHRoaXMucGFyc2VJZGVudGlmaWVyKCk7XG4gICAgbm9kZS5zcGVjaWZpZXJzLnB1c2godGhpcy5maW5pc2hJbXBvcnRTcGVjaWZpZXIoc3BlY2lmaWVyLCB0eXBlKSk7XG4gIH1cbiAgZmluaXNoSW1wb3J0U3BlY2lmaWVyKHNwZWNpZmllciwgdHlwZSwgYmluZGluZ1R5cGUgPSA4MjAxKSB7XG4gICAgdGhpcy5jaGVja0xWYWwoc3BlY2lmaWVyLmxvY2FsLCB7XG4gICAgICB0eXBlXG4gICAgfSwgYmluZGluZ1R5cGUpO1xuICAgIHJldHVybiB0aGlzLmZpbmlzaE5vZGUoc3BlY2lmaWVyLCB0eXBlKTtcbiAgfVxuICBwYXJzZUltcG9ydEF0dHJpYnV0ZXMoKSB7XG4gICAgdGhpcy5leHBlY3QoNSk7XG4gICAgY29uc3QgYXR0cnMgPSBbXTtcbiAgICBjb25zdCBhdHRyTmFtZXMgPSBuZXcgU2V0KCk7XG4gICAgZG8ge1xuICAgICAgaWYgKHRoaXMubWF0Y2goOCkpIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBjb25zdCBub2RlID0gdGhpcy5zdGFydE5vZGUoKTtcbiAgICAgIGNvbnN0IGtleU5hbWUgPSB0aGlzLnN0YXRlLnZhbHVlO1xuICAgICAgaWYgKGF0dHJOYW1lcy5oYXMoa2V5TmFtZSkpIHtcbiAgICAgICAgdGhpcy5yYWlzZShFcnJvcnMuTW9kdWxlQXR0cmlidXRlc1dpdGhEdXBsaWNhdGVLZXlzLCB0aGlzLnN0YXRlLnN0YXJ0TG9jLCB7XG4gICAgICAgICAga2V5OiBrZXlOYW1lXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgYXR0ck5hbWVzLmFkZChrZXlOYW1lKTtcbiAgICAgIGlmICh0aGlzLm1hdGNoKDEzNCkpIHtcbiAgICAgICAgbm9kZS5rZXkgPSB0aGlzLnBhcnNlU3RyaW5nTGl0ZXJhbChrZXlOYW1lKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG5vZGUua2V5ID0gdGhpcy5wYXJzZUlkZW50aWZpZXIodHJ1ZSk7XG4gICAgICB9XG4gICAgICB0aGlzLmV4cGVjdCgxNCk7XG4gICAgICBpZiAoIXRoaXMubWF0Y2goMTM0KSkge1xuICAgICAgICB0aHJvdyB0aGlzLnJhaXNlKEVycm9ycy5Nb2R1bGVBdHRyaWJ1dGVJbnZhbGlkVmFsdWUsIHRoaXMuc3RhdGUuc3RhcnRMb2MpO1xuICAgICAgfVxuICAgICAgbm9kZS52YWx1ZSA9IHRoaXMucGFyc2VTdHJpbmdMaXRlcmFsKHRoaXMuc3RhdGUudmFsdWUpO1xuICAgICAgYXR0cnMucHVzaCh0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJJbXBvcnRBdHRyaWJ1dGVcIikpO1xuICAgIH0gd2hpbGUgKHRoaXMuZWF0KDEyKSk7XG4gICAgdGhpcy5leHBlY3QoOCk7XG4gICAgcmV0dXJuIGF0dHJzO1xuICB9XG4gIHBhcnNlTW9kdWxlQXR0cmlidXRlcygpIHtcbiAgICBjb25zdCBhdHRycyA9IFtdO1xuICAgIGNvbnN0IGF0dHJpYnV0ZXMgPSBuZXcgU2V0KCk7XG4gICAgZG8ge1xuICAgICAgY29uc3Qgbm9kZSA9IHRoaXMuc3RhcnROb2RlKCk7XG4gICAgICBub2RlLmtleSA9IHRoaXMucGFyc2VJZGVudGlmaWVyKHRydWUpO1xuICAgICAgaWYgKG5vZGUua2V5Lm5hbWUgIT09IFwidHlwZVwiKSB7XG4gICAgICAgIHRoaXMucmFpc2UoRXJyb3JzLk1vZHVsZUF0dHJpYnV0ZURpZmZlcmVudEZyb21UeXBlLCBub2RlLmtleSk7XG4gICAgICB9XG4gICAgICBpZiAoYXR0cmlidXRlcy5oYXMobm9kZS5rZXkubmFtZSkpIHtcbiAgICAgICAgdGhpcy5yYWlzZShFcnJvcnMuTW9kdWxlQXR0cmlidXRlc1dpdGhEdXBsaWNhdGVLZXlzLCBub2RlLmtleSwge1xuICAgICAgICAgIGtleTogbm9kZS5rZXkubmFtZVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIGF0dHJpYnV0ZXMuYWRkKG5vZGUua2V5Lm5hbWUpO1xuICAgICAgdGhpcy5leHBlY3QoMTQpO1xuICAgICAgaWYgKCF0aGlzLm1hdGNoKDEzNCkpIHtcbiAgICAgICAgdGhyb3cgdGhpcy5yYWlzZShFcnJvcnMuTW9kdWxlQXR0cmlidXRlSW52YWxpZFZhbHVlLCB0aGlzLnN0YXRlLnN0YXJ0TG9jKTtcbiAgICAgIH1cbiAgICAgIG5vZGUudmFsdWUgPSB0aGlzLnBhcnNlU3RyaW5nTGl0ZXJhbCh0aGlzLnN0YXRlLnZhbHVlKTtcbiAgICAgIGF0dHJzLnB1c2godGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiSW1wb3J0QXR0cmlidXRlXCIpKTtcbiAgICB9IHdoaWxlICh0aGlzLmVhdCgxMikpO1xuICAgIHJldHVybiBhdHRycztcbiAgfVxuICBtYXliZVBhcnNlSW1wb3J0QXR0cmlidXRlcyhub2RlKSB7XG4gICAgbGV0IGF0dHJpYnV0ZXM7XG4gICAgdmFyIHVzZVdpdGggPSBmYWxzZTtcbiAgICBpZiAodGhpcy5tYXRjaCg3NikpIHtcbiAgICAgIGlmICh0aGlzLmhhc1ByZWNlZGluZ0xpbmVCcmVhaygpICYmIHRoaXMubG9va2FoZWFkQ2hhckNvZGUoKSA9PT0gNDApIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdGhpcy5uZXh0KCk7XG4gICAgICBpZiAodGhpcy5oYXNQbHVnaW4oXCJtb2R1bGVBdHRyaWJ1dGVzXCIpKSB7XG4gICAgICAgIGF0dHJpYnV0ZXMgPSB0aGlzLnBhcnNlTW9kdWxlQXR0cmlidXRlcygpO1xuICAgICAgICB0aGlzLmFkZEV4dHJhKG5vZGUsIFwiZGVwcmVjYXRlZFdpdGhMZWdhY3lTeW50YXhcIiwgdHJ1ZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBhdHRyaWJ1dGVzID0gdGhpcy5wYXJzZUltcG9ydEF0dHJpYnV0ZXMoKTtcbiAgICAgIH1cbiAgICAgIHVzZVdpdGggPSB0cnVlO1xuICAgIH0gZWxzZSBpZiAodGhpcy5pc0NvbnRleHR1YWwoOTQpICYmICF0aGlzLmhhc1ByZWNlZGluZ0xpbmVCcmVhaygpKSB7XG4gICAgICBpZiAoIXRoaXMuaGFzUGx1Z2luKFwiZGVwcmVjYXRlZEltcG9ydEFzc2VydFwiKSAmJiAhdGhpcy5oYXNQbHVnaW4oXCJpbXBvcnRBc3NlcnRpb25zXCIpKSB7XG4gICAgICAgIHRoaXMucmFpc2UoRXJyb3JzLkltcG9ydEF0dHJpYnV0ZXNVc2VBc3NlcnQsIHRoaXMuc3RhdGUuc3RhcnRMb2MpO1xuICAgICAgfVxuICAgICAgaWYgKCF0aGlzLmhhc1BsdWdpbihcImltcG9ydEFzc2VydGlvbnNcIikpIHtcbiAgICAgICAgdGhpcy5hZGRFeHRyYShub2RlLCBcImRlcHJlY2F0ZWRBc3NlcnRTeW50YXhcIiwgdHJ1ZSk7XG4gICAgICB9XG4gICAgICB0aGlzLm5leHQoKTtcbiAgICAgIGF0dHJpYnV0ZXMgPSB0aGlzLnBhcnNlSW1wb3J0QXR0cmlidXRlcygpO1xuICAgIH0gZWxzZSB7XG4gICAgICBhdHRyaWJ1dGVzID0gW107XG4gICAgfVxuICAgIGlmICghdXNlV2l0aCAmJiB0aGlzLmhhc1BsdWdpbihcImltcG9ydEFzc2VydGlvbnNcIikpIHtcbiAgICAgIG5vZGUuYXNzZXJ0aW9ucyA9IGF0dHJpYnV0ZXM7XG4gICAgfSBlbHNlIHtcbiAgICAgIG5vZGUuYXR0cmlidXRlcyA9IGF0dHJpYnV0ZXM7XG4gICAgfVxuICB9XG4gIG1heWJlUGFyc2VEZWZhdWx0SW1wb3J0U3BlY2lmaWVyKG5vZGUsIG1heWJlRGVmYXVsdElkZW50aWZpZXIpIHtcbiAgICBpZiAobWF5YmVEZWZhdWx0SWRlbnRpZmllcikge1xuICAgICAgY29uc3Qgc3BlY2lmaWVyID0gdGhpcy5zdGFydE5vZGVBdE5vZGUobWF5YmVEZWZhdWx0SWRlbnRpZmllcik7XG4gICAgICBzcGVjaWZpZXIubG9jYWwgPSBtYXliZURlZmF1bHRJZGVudGlmaWVyO1xuICAgICAgbm9kZS5zcGVjaWZpZXJzLnB1c2godGhpcy5maW5pc2hJbXBvcnRTcGVjaWZpZXIoc3BlY2lmaWVyLCBcIkltcG9ydERlZmF1bHRTcGVjaWZpZXJcIikpO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBlbHNlIGlmICh0b2tlbklzS2V5d29yZE9ySWRlbnRpZmllcih0aGlzLnN0YXRlLnR5cGUpKSB7XG4gICAgICB0aGlzLnBhcnNlSW1wb3J0U3BlY2lmaWVyTG9jYWwobm9kZSwgdGhpcy5zdGFydE5vZGUoKSwgXCJJbXBvcnREZWZhdWx0U3BlY2lmaWVyXCIpO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBtYXliZVBhcnNlU3RhckltcG9ydFNwZWNpZmllcihub2RlKSB7XG4gICAgaWYgKHRoaXMubWF0Y2goNTUpKSB7XG4gICAgICBjb25zdCBzcGVjaWZpZXIgPSB0aGlzLnN0YXJ0Tm9kZSgpO1xuICAgICAgdGhpcy5uZXh0KCk7XG4gICAgICB0aGlzLmV4cGVjdENvbnRleHR1YWwoOTMpO1xuICAgICAgdGhpcy5wYXJzZUltcG9ydFNwZWNpZmllckxvY2FsKG5vZGUsIHNwZWNpZmllciwgXCJJbXBvcnROYW1lc3BhY2VTcGVjaWZpZXJcIik7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHBhcnNlTmFtZWRJbXBvcnRTcGVjaWZpZXJzKG5vZGUpIHtcbiAgICBsZXQgZmlyc3QgPSB0cnVlO1xuICAgIHRoaXMuZXhwZWN0KDUpO1xuICAgIHdoaWxlICghdGhpcy5lYXQoOCkpIHtcbiAgICAgIGlmIChmaXJzdCkge1xuICAgICAgICBmaXJzdCA9IGZhbHNlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKHRoaXMuZWF0KDE0KSkge1xuICAgICAgICAgIHRocm93IHRoaXMucmFpc2UoRXJyb3JzLkRlc3RydWN0dXJlTmFtZWRJbXBvcnQsIHRoaXMuc3RhdGUuc3RhcnRMb2MpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZXhwZWN0KDEyKTtcbiAgICAgICAgaWYgKHRoaXMuZWF0KDgpKSBicmVhaztcbiAgICAgIH1cbiAgICAgIGNvbnN0IHNwZWNpZmllciA9IHRoaXMuc3RhcnROb2RlKCk7XG4gICAgICBjb25zdCBpbXBvcnRlZElzU3RyaW5nID0gdGhpcy5tYXRjaCgxMzQpO1xuICAgICAgY29uc3QgaXNNYXliZVR5cGVPbmx5ID0gdGhpcy5pc0NvbnRleHR1YWwoMTMwKTtcbiAgICAgIHNwZWNpZmllci5pbXBvcnRlZCA9IHRoaXMucGFyc2VNb2R1bGVFeHBvcnROYW1lKCk7XG4gICAgICBjb25zdCBpbXBvcnRTcGVjaWZpZXIgPSB0aGlzLnBhcnNlSW1wb3J0U3BlY2lmaWVyKHNwZWNpZmllciwgaW1wb3J0ZWRJc1N0cmluZywgbm9kZS5pbXBvcnRLaW5kID09PSBcInR5cGVcIiB8fCBub2RlLmltcG9ydEtpbmQgPT09IFwidHlwZW9mXCIsIGlzTWF5YmVUeXBlT25seSwgdW5kZWZpbmVkKTtcbiAgICAgIG5vZGUuc3BlY2lmaWVycy5wdXNoKGltcG9ydFNwZWNpZmllcik7XG4gICAgfVxuICB9XG4gIHBhcnNlSW1wb3J0U3BlY2lmaWVyKHNwZWNpZmllciwgaW1wb3J0ZWRJc1N0cmluZywgaXNJblR5cGVPbmx5SW1wb3J0LCBpc01heWJlVHlwZU9ubHksIGJpbmRpbmdUeXBlKSB7XG4gICAgaWYgKHRoaXMuZWF0Q29udGV4dHVhbCg5MykpIHtcbiAgICAgIHNwZWNpZmllci5sb2NhbCA9IHRoaXMucGFyc2VJZGVudGlmaWVyKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgaW1wb3J0ZWRcbiAgICAgIH0gPSBzcGVjaWZpZXI7XG4gICAgICBpZiAoaW1wb3J0ZWRJc1N0cmluZykge1xuICAgICAgICB0aHJvdyB0aGlzLnJhaXNlKEVycm9ycy5JbXBvcnRCaW5kaW5nSXNTdHJpbmcsIHNwZWNpZmllciwge1xuICAgICAgICAgIGltcG9ydE5hbWU6IGltcG9ydGVkLnZhbHVlXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgdGhpcy5jaGVja1Jlc2VydmVkV29yZChpbXBvcnRlZC5uYW1lLCBzcGVjaWZpZXIubG9jLnN0YXJ0LCB0cnVlLCB0cnVlKTtcbiAgICAgIGlmICghc3BlY2lmaWVyLmxvY2FsKSB7XG4gICAgICAgIHNwZWNpZmllci5sb2NhbCA9IHRoaXMuY2xvbmVJZGVudGlmaWVyKGltcG9ydGVkKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuZmluaXNoSW1wb3J0U3BlY2lmaWVyKHNwZWNpZmllciwgXCJJbXBvcnRTcGVjaWZpZXJcIiwgYmluZGluZ1R5cGUpO1xuICB9XG4gIGlzVGhpc1BhcmFtKHBhcmFtKSB7XG4gICAgcmV0dXJuIHBhcmFtLnR5cGUgPT09IFwiSWRlbnRpZmllclwiICYmIHBhcmFtLm5hbWUgPT09IFwidGhpc1wiO1xuICB9XG59XG5jbGFzcyBQYXJzZXIgZXh0ZW5kcyBTdGF0ZW1lbnRQYXJzZXIge1xuICBjb25zdHJ1Y3RvcihvcHRpb25zLCBpbnB1dCwgcGx1Z2luc01hcCkge1xuICAgIGNvbnN0IG5vcm1hbGl6ZWRPcHRpb25zID0gZ2V0T3B0aW9ucyhvcHRpb25zKTtcbiAgICBzdXBlcihub3JtYWxpemVkT3B0aW9ucywgaW5wdXQpO1xuICAgIHRoaXMub3B0aW9ucyA9IG5vcm1hbGl6ZWRPcHRpb25zO1xuICAgIHRoaXMuaW5pdGlhbGl6ZVNjb3BlcygpO1xuICAgIHRoaXMucGx1Z2lucyA9IHBsdWdpbnNNYXA7XG4gICAgdGhpcy5maWxlbmFtZSA9IG5vcm1hbGl6ZWRPcHRpb25zLnNvdXJjZUZpbGVuYW1lO1xuICAgIHRoaXMuc3RhcnRJbmRleCA9IG5vcm1hbGl6ZWRPcHRpb25zLnN0YXJ0SW5kZXg7XG4gICAgbGV0IG9wdGlvbkZsYWdzID0gMDtcbiAgICBpZiAobm9ybWFsaXplZE9wdGlvbnMuYWxsb3dBd2FpdE91dHNpZGVGdW5jdGlvbikge1xuICAgICAgb3B0aW9uRmxhZ3MgfD0gMTtcbiAgICB9XG4gICAgaWYgKG5vcm1hbGl6ZWRPcHRpb25zLmFsbG93UmV0dXJuT3V0c2lkZUZ1bmN0aW9uKSB7XG4gICAgICBvcHRpb25GbGFncyB8PSAyO1xuICAgIH1cbiAgICBpZiAobm9ybWFsaXplZE9wdGlvbnMuYWxsb3dJbXBvcnRFeHBvcnRFdmVyeXdoZXJlKSB7XG4gICAgICBvcHRpb25GbGFncyB8PSA4O1xuICAgIH1cbiAgICBpZiAobm9ybWFsaXplZE9wdGlvbnMuYWxsb3dTdXBlck91dHNpZGVNZXRob2QpIHtcbiAgICAgIG9wdGlvbkZsYWdzIHw9IDE2O1xuICAgIH1cbiAgICBpZiAobm9ybWFsaXplZE9wdGlvbnMuYWxsb3dVbmRlY2xhcmVkRXhwb3J0cykge1xuICAgICAgb3B0aW9uRmxhZ3MgfD0gNjQ7XG4gICAgfVxuICAgIGlmIChub3JtYWxpemVkT3B0aW9ucy5hbGxvd05ld1RhcmdldE91dHNpZGVGdW5jdGlvbikge1xuICAgICAgb3B0aW9uRmxhZ3MgfD0gNDtcbiAgICB9XG4gICAgaWYgKG5vcm1hbGl6ZWRPcHRpb25zLmFsbG93WWllbGRPdXRzaWRlRnVuY3Rpb24pIHtcbiAgICAgIG9wdGlvbkZsYWdzIHw9IDMyO1xuICAgIH1cbiAgICBpZiAobm9ybWFsaXplZE9wdGlvbnMucmFuZ2VzKSB7XG4gICAgICBvcHRpb25GbGFncyB8PSAxMjg7XG4gICAgfVxuICAgIGlmIChub3JtYWxpemVkT3B0aW9ucy50b2tlbnMpIHtcbiAgICAgIG9wdGlvbkZsYWdzIHw9IDI1NjtcbiAgICB9XG4gICAgaWYgKG5vcm1hbGl6ZWRPcHRpb25zLmNyZWF0ZUltcG9ydEV4cHJlc3Npb25zKSB7XG4gICAgICBvcHRpb25GbGFncyB8PSA1MTI7XG4gICAgfVxuICAgIGlmIChub3JtYWxpemVkT3B0aW9ucy5jcmVhdGVQYXJlbnRoZXNpemVkRXhwcmVzc2lvbnMpIHtcbiAgICAgIG9wdGlvbkZsYWdzIHw9IDEwMjQ7XG4gICAgfVxuICAgIGlmIChub3JtYWxpemVkT3B0aW9ucy5lcnJvclJlY292ZXJ5KSB7XG4gICAgICBvcHRpb25GbGFncyB8PSAyMDQ4O1xuICAgIH1cbiAgICBpZiAobm9ybWFsaXplZE9wdGlvbnMuYXR0YWNoQ29tbWVudCkge1xuICAgICAgb3B0aW9uRmxhZ3MgfD0gNDA5NjtcbiAgICB9XG4gICAgaWYgKG5vcm1hbGl6ZWRPcHRpb25zLmFubmV4Qikge1xuICAgICAgb3B0aW9uRmxhZ3MgfD0gODE5MjtcbiAgICB9XG4gICAgdGhpcy5vcHRpb25GbGFncyA9IG9wdGlvbkZsYWdzO1xuICB9XG4gIGdldFNjb3BlSGFuZGxlcigpIHtcbiAgICByZXR1cm4gU2NvcGVIYW5kbGVyO1xuICB9XG4gIHBhcnNlKCkge1xuICAgIHRoaXMuZW50ZXJJbml0aWFsU2NvcGVzKCk7XG4gICAgY29uc3QgZmlsZSA9IHRoaXMuc3RhcnROb2RlKCk7XG4gICAgY29uc3QgcHJvZ3JhbSA9IHRoaXMuc3RhcnROb2RlKCk7XG4gICAgdGhpcy5uZXh0VG9rZW4oKTtcbiAgICBmaWxlLmVycm9ycyA9IG51bGw7XG4gICAgY29uc3QgcmVzdWx0ID0gdGhpcy5wYXJzZVRvcExldmVsKGZpbGUsIHByb2dyYW0pO1xuICAgIHJlc3VsdC5lcnJvcnMgPSB0aGlzLnN0YXRlLmVycm9ycztcbiAgICByZXN1bHQuY29tbWVudHMubGVuZ3RoID0gdGhpcy5zdGF0ZS5jb21tZW50c0xlbjtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG59XG5mdW5jdGlvbiBwYXJzZShpbnB1dCwgb3B0aW9ucykge1xuICB2YXIgX29wdGlvbnM7XG4gIGlmICgoKF9vcHRpb25zID0gb3B0aW9ucykgPT0gbnVsbCA/IHZvaWQgMCA6IF9vcHRpb25zLnNvdXJjZVR5cGUpID09PSBcInVuYW1iaWd1b3VzXCIpIHtcbiAgICBvcHRpb25zID0gT2JqZWN0LmFzc2lnbih7fSwgb3B0aW9ucyk7XG4gICAgdHJ5IHtcbiAgICAgIG9wdGlvbnMuc291cmNlVHlwZSA9IFwibW9kdWxlXCI7XG4gICAgICBjb25zdCBwYXJzZXIgPSBnZXRQYXJzZXIob3B0aW9ucywgaW5wdXQpO1xuICAgICAgY29uc3QgYXN0ID0gcGFyc2VyLnBhcnNlKCk7XG4gICAgICBpZiAocGFyc2VyLnNhd1VuYW1iaWd1b3VzRVNNKSB7XG4gICAgICAgIHJldHVybiBhc3Q7XG4gICAgICB9XG4gICAgICBpZiAocGFyc2VyLmFtYmlndW91c1NjcmlwdERpZmZlcmVudEFzdCkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIG9wdGlvbnMuc291cmNlVHlwZSA9IFwic2NyaXB0XCI7XG4gICAgICAgICAgcmV0dXJuIGdldFBhcnNlcihvcHRpb25zLCBpbnB1dCkucGFyc2UoKTtcbiAgICAgICAgfSBjYXRjaCAoX3VudXNlZCkge31cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGFzdC5wcm9ncmFtLnNvdXJjZVR5cGUgPSBcInNjcmlwdFwiO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGFzdDtcbiAgICB9IGNhdGNoIChtb2R1bGVFcnJvcikge1xuICAgICAgdHJ5IHtcbiAgICAgICAgb3B0aW9ucy5zb3VyY2VUeXBlID0gXCJzY3JpcHRcIjtcbiAgICAgICAgcmV0dXJuIGdldFBhcnNlcihvcHRpb25zLCBpbnB1dCkucGFyc2UoKTtcbiAgICAgIH0gY2F0Y2ggKF91bnVzZWQyKSB7fVxuICAgICAgdGhyb3cgbW9kdWxlRXJyb3I7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHJldHVybiBnZXRQYXJzZXIob3B0aW9ucywgaW5wdXQpLnBhcnNlKCk7XG4gIH1cbn1cbmZ1bmN0aW9uIHBhcnNlRXhwcmVzc2lvbihpbnB1dCwgb3B0aW9ucykge1xuICBjb25zdCBwYXJzZXIgPSBnZXRQYXJzZXIob3B0aW9ucywgaW5wdXQpO1xuICBpZiAocGFyc2VyLm9wdGlvbnMuc3RyaWN0TW9kZSkge1xuICAgIHBhcnNlci5zdGF0ZS5zdHJpY3QgPSB0cnVlO1xuICB9XG4gIHJldHVybiBwYXJzZXIuZ2V0RXhwcmVzc2lvbigpO1xufVxuZnVuY3Rpb24gZ2VuZXJhdGVFeHBvcnRlZFRva2VuVHlwZXMoaW50ZXJuYWxUb2tlblR5cGVzKSB7XG4gIGNvbnN0IHRva2VuVHlwZXMgPSB7fTtcbiAgZm9yIChjb25zdCB0eXBlTmFtZSBvZiBPYmplY3Qua2V5cyhpbnRlcm5hbFRva2VuVHlwZXMpKSB7XG4gICAgdG9rZW5UeXBlc1t0eXBlTmFtZV0gPSBnZXRFeHBvcnRlZFRva2VuKGludGVybmFsVG9rZW5UeXBlc1t0eXBlTmFtZV0pO1xuICB9XG4gIHJldHVybiB0b2tlblR5cGVzO1xufVxuY29uc3QgdG9rVHlwZXMgPSBnZW5lcmF0ZUV4cG9ydGVkVG9rZW5UeXBlcyh0dCk7XG5mdW5jdGlvbiBnZXRQYXJzZXIob3B0aW9ucywgaW5wdXQpIHtcbiAgbGV0IGNscyA9IFBhcnNlcjtcbiAgY29uc3QgcGx1Z2luc01hcCA9IG5ldyBNYXAoKTtcbiAgaWYgKG9wdGlvbnMgIT0gbnVsbCAmJiBvcHRpb25zLnBsdWdpbnMpIHtcbiAgICBmb3IgKGNvbnN0IHBsdWdpbiBvZiBvcHRpb25zLnBsdWdpbnMpIHtcbiAgICAgIGxldCBuYW1lLCBvcHRzO1xuICAgICAgaWYgKHR5cGVvZiBwbHVnaW4gPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgbmFtZSA9IHBsdWdpbjtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIFtuYW1lLCBvcHRzXSA9IHBsdWdpbjtcbiAgICAgIH1cbiAgICAgIGlmICghcGx1Z2luc01hcC5oYXMobmFtZSkpIHtcbiAgICAgICAgcGx1Z2luc01hcC5zZXQobmFtZSwgb3B0cyB8fCB7fSk7XG4gICAgICB9XG4gICAgfVxuICAgIHZhbGlkYXRlUGx1Z2lucyhwbHVnaW5zTWFwKTtcbiAgICBjbHMgPSBnZXRQYXJzZXJDbGFzcyhwbHVnaW5zTWFwKTtcbiAgfVxuICByZXR1cm4gbmV3IGNscyhvcHRpb25zLCBpbnB1dCwgcGx1Z2luc01hcCk7XG59XG5jb25zdCBwYXJzZXJDbGFzc0NhY2hlID0gbmV3IE1hcCgpO1xuZnVuY3Rpb24gZ2V0UGFyc2VyQ2xhc3MocGx1Z2luc01hcCkge1xuICBjb25zdCBwbHVnaW5MaXN0ID0gW107XG4gIGZvciAoY29uc3QgbmFtZSBvZiBtaXhpblBsdWdpbk5hbWVzKSB7XG4gICAgaWYgKHBsdWdpbnNNYXAuaGFzKG5hbWUpKSB7XG4gICAgICBwbHVnaW5MaXN0LnB1c2gobmFtZSk7XG4gICAgfVxuICB9XG4gIGNvbnN0IGtleSA9IHBsdWdpbkxpc3Quam9pbihcInxcIik7XG4gIGxldCBjbHMgPSBwYXJzZXJDbGFzc0NhY2hlLmdldChrZXkpO1xuICBpZiAoIWNscykge1xuICAgIGNscyA9IFBhcnNlcjtcbiAgICBmb3IgKGNvbnN0IHBsdWdpbiBvZiBwbHVnaW5MaXN0KSB7XG4gICAgICBjbHMgPSBtaXhpblBsdWdpbnNbcGx1Z2luXShjbHMpO1xuICAgIH1cbiAgICBwYXJzZXJDbGFzc0NhY2hlLnNldChrZXksIGNscyk7XG4gIH1cbiAgcmV0dXJuIGNscztcbn1cbmV4cG9ydHMucGFyc2UgPSBwYXJzZTtcbmV4cG9ydHMucGFyc2VFeHByZXNzaW9uID0gcGFyc2VFeHByZXNzaW9uO1xuZXhwb3J0cy50b2tUeXBlcyA9IHRva1R5cGVzO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@babel/parser/lib/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@babel/template/lib/builder.js":
/*!*****************************************************!*\
  !*** ./node_modules/@babel/template/lib/builder.js ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports[\"default\"] = createTemplateBuilder;\nvar _options = __webpack_require__(/*! ./options.js */ \"(ssr)/./node_modules/@babel/template/lib/options.js\");\nvar _string = __webpack_require__(/*! ./string.js */ \"(ssr)/./node_modules/@babel/template/lib/string.js\");\nvar _literal = __webpack_require__(/*! ./literal.js */ \"(ssr)/./node_modules/@babel/template/lib/literal.js\");\nconst NO_PLACEHOLDER = (0, _options.validate)({\n  placeholderPattern: false\n});\nfunction createTemplateBuilder(formatter, defaultOpts) {\n  const templateFnCache = new WeakMap();\n  const templateAstCache = new WeakMap();\n  const cachedOpts = defaultOpts || (0, _options.validate)(null);\n  return Object.assign((tpl, ...args) => {\n    if (typeof tpl === \"string\") {\n      if (args.length > 1) throw new Error(\"Unexpected extra params.\");\n      return extendedTrace((0, _string.default)(formatter, tpl, (0, _options.merge)(cachedOpts, (0, _options.validate)(args[0]))));\n    } else if (Array.isArray(tpl)) {\n      let builder = templateFnCache.get(tpl);\n      if (!builder) {\n        builder = (0, _literal.default)(formatter, tpl, cachedOpts);\n        templateFnCache.set(tpl, builder);\n      }\n      return extendedTrace(builder(args));\n    } else if (typeof tpl === \"object\" && tpl) {\n      if (args.length > 0) throw new Error(\"Unexpected extra params.\");\n      return createTemplateBuilder(formatter, (0, _options.merge)(cachedOpts, (0, _options.validate)(tpl)));\n    }\n    throw new Error(`Unexpected template param ${typeof tpl}`);\n  }, {\n    ast: (tpl, ...args) => {\n      if (typeof tpl === \"string\") {\n        if (args.length > 1) throw new Error(\"Unexpected extra params.\");\n        return (0, _string.default)(formatter, tpl, (0, _options.merge)((0, _options.merge)(cachedOpts, (0, _options.validate)(args[0])), NO_PLACEHOLDER))();\n      } else if (Array.isArray(tpl)) {\n        let builder = templateAstCache.get(tpl);\n        if (!builder) {\n          builder = (0, _literal.default)(formatter, tpl, (0, _options.merge)(cachedOpts, NO_PLACEHOLDER));\n          templateAstCache.set(tpl, builder);\n        }\n        return builder(args)();\n      }\n      throw new Error(`Unexpected template param ${typeof tpl}`);\n    }\n  });\n}\nfunction extendedTrace(fn) {\n  let rootStack = \"\";\n  try {\n    throw new Error();\n  } catch (error) {\n    if (error.stack) {\n      rootStack = error.stack.split(\"\\n\").slice(3).join(\"\\n\");\n    }\n  }\n  return arg => {\n    try {\n      return fn(arg);\n    } catch (err) {\n      err.stack += `\\n    =============\\n${rootStack}`;\n      throw err;\n    }\n  };\n}\n\n//# sourceMappingURL=builder.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGJhYmVsL3RlbXBsYXRlL2xpYi9idWlsZGVyLmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViLDhDQUE2QztBQUM3QztBQUNBLENBQUMsRUFBQztBQUNGLGtCQUFlO0FBQ2YsZUFBZSxtQkFBTyxDQUFDLHlFQUFjO0FBQ3JDLGNBQWMsbUJBQU8sQ0FBQyx1RUFBYTtBQUNuQyxlQUFlLG1CQUFPLENBQUMseUVBQWM7QUFDckM7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQSxpREFBaUQsV0FBVztBQUM1RCxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtREFBbUQsV0FBVztBQUM5RDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOLDJDQUEyQyxVQUFVO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBOztBQUVBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcmVwby12aXN1YWxpemVyLy4vbm9kZV9tb2R1bGVzL0BiYWJlbC90ZW1wbGF0ZS9saWIvYnVpbGRlci5qcz83NWZkIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5kZWZhdWx0ID0gY3JlYXRlVGVtcGxhdGVCdWlsZGVyO1xudmFyIF9vcHRpb25zID0gcmVxdWlyZShcIi4vb3B0aW9ucy5qc1wiKTtcbnZhciBfc3RyaW5nID0gcmVxdWlyZShcIi4vc3RyaW5nLmpzXCIpO1xudmFyIF9saXRlcmFsID0gcmVxdWlyZShcIi4vbGl0ZXJhbC5qc1wiKTtcbmNvbnN0IE5PX1BMQUNFSE9MREVSID0gKDAsIF9vcHRpb25zLnZhbGlkYXRlKSh7XG4gIHBsYWNlaG9sZGVyUGF0dGVybjogZmFsc2Vcbn0pO1xuZnVuY3Rpb24gY3JlYXRlVGVtcGxhdGVCdWlsZGVyKGZvcm1hdHRlciwgZGVmYXVsdE9wdHMpIHtcbiAgY29uc3QgdGVtcGxhdGVGbkNhY2hlID0gbmV3IFdlYWtNYXAoKTtcbiAgY29uc3QgdGVtcGxhdGVBc3RDYWNoZSA9IG5ldyBXZWFrTWFwKCk7XG4gIGNvbnN0IGNhY2hlZE9wdHMgPSBkZWZhdWx0T3B0cyB8fCAoMCwgX29wdGlvbnMudmFsaWRhdGUpKG51bGwpO1xuICByZXR1cm4gT2JqZWN0LmFzc2lnbigodHBsLCAuLi5hcmdzKSA9PiB7XG4gICAgaWYgKHR5cGVvZiB0cGwgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgIGlmIChhcmdzLmxlbmd0aCA+IDEpIHRocm93IG5ldyBFcnJvcihcIlVuZXhwZWN0ZWQgZXh0cmEgcGFyYW1zLlwiKTtcbiAgICAgIHJldHVybiBleHRlbmRlZFRyYWNlKCgwLCBfc3RyaW5nLmRlZmF1bHQpKGZvcm1hdHRlciwgdHBsLCAoMCwgX29wdGlvbnMubWVyZ2UpKGNhY2hlZE9wdHMsICgwLCBfb3B0aW9ucy52YWxpZGF0ZSkoYXJnc1swXSkpKSk7XG4gICAgfSBlbHNlIGlmIChBcnJheS5pc0FycmF5KHRwbCkpIHtcbiAgICAgIGxldCBidWlsZGVyID0gdGVtcGxhdGVGbkNhY2hlLmdldCh0cGwpO1xuICAgICAgaWYgKCFidWlsZGVyKSB7XG4gICAgICAgIGJ1aWxkZXIgPSAoMCwgX2xpdGVyYWwuZGVmYXVsdCkoZm9ybWF0dGVyLCB0cGwsIGNhY2hlZE9wdHMpO1xuICAgICAgICB0ZW1wbGF0ZUZuQ2FjaGUuc2V0KHRwbCwgYnVpbGRlcik7XG4gICAgICB9XG4gICAgICByZXR1cm4gZXh0ZW5kZWRUcmFjZShidWlsZGVyKGFyZ3MpKTtcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiB0cGwgPT09IFwib2JqZWN0XCIgJiYgdHBsKSB7XG4gICAgICBpZiAoYXJncy5sZW5ndGggPiAwKSB0aHJvdyBuZXcgRXJyb3IoXCJVbmV4cGVjdGVkIGV4dHJhIHBhcmFtcy5cIik7XG4gICAgICByZXR1cm4gY3JlYXRlVGVtcGxhdGVCdWlsZGVyKGZvcm1hdHRlciwgKDAsIF9vcHRpb25zLm1lcmdlKShjYWNoZWRPcHRzLCAoMCwgX29wdGlvbnMudmFsaWRhdGUpKHRwbCkpKTtcbiAgICB9XG4gICAgdGhyb3cgbmV3IEVycm9yKGBVbmV4cGVjdGVkIHRlbXBsYXRlIHBhcmFtICR7dHlwZW9mIHRwbH1gKTtcbiAgfSwge1xuICAgIGFzdDogKHRwbCwgLi4uYXJncykgPT4ge1xuICAgICAgaWYgKHR5cGVvZiB0cGwgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgaWYgKGFyZ3MubGVuZ3RoID4gMSkgdGhyb3cgbmV3IEVycm9yKFwiVW5leHBlY3RlZCBleHRyYSBwYXJhbXMuXCIpO1xuICAgICAgICByZXR1cm4gKDAsIF9zdHJpbmcuZGVmYXVsdCkoZm9ybWF0dGVyLCB0cGwsICgwLCBfb3B0aW9ucy5tZXJnZSkoKDAsIF9vcHRpb25zLm1lcmdlKShjYWNoZWRPcHRzLCAoMCwgX29wdGlvbnMudmFsaWRhdGUpKGFyZ3NbMF0pKSwgTk9fUExBQ0VIT0xERVIpKSgpO1xuICAgICAgfSBlbHNlIGlmIChBcnJheS5pc0FycmF5KHRwbCkpIHtcbiAgICAgICAgbGV0IGJ1aWxkZXIgPSB0ZW1wbGF0ZUFzdENhY2hlLmdldCh0cGwpO1xuICAgICAgICBpZiAoIWJ1aWxkZXIpIHtcbiAgICAgICAgICBidWlsZGVyID0gKDAsIF9saXRlcmFsLmRlZmF1bHQpKGZvcm1hdHRlciwgdHBsLCAoMCwgX29wdGlvbnMubWVyZ2UpKGNhY2hlZE9wdHMsIE5PX1BMQUNFSE9MREVSKSk7XG4gICAgICAgICAgdGVtcGxhdGVBc3RDYWNoZS5zZXQodHBsLCBidWlsZGVyKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYnVpbGRlcihhcmdzKSgpO1xuICAgICAgfVxuICAgICAgdGhyb3cgbmV3IEVycm9yKGBVbmV4cGVjdGVkIHRlbXBsYXRlIHBhcmFtICR7dHlwZW9mIHRwbH1gKTtcbiAgICB9XG4gIH0pO1xufVxuZnVuY3Rpb24gZXh0ZW5kZWRUcmFjZShmbikge1xuICBsZXQgcm9vdFN0YWNrID0gXCJcIjtcbiAgdHJ5IHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoKTtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICBpZiAoZXJyb3Iuc3RhY2spIHtcbiAgICAgIHJvb3RTdGFjayA9IGVycm9yLnN0YWNrLnNwbGl0KFwiXFxuXCIpLnNsaWNlKDMpLmpvaW4oXCJcXG5cIik7XG4gICAgfVxuICB9XG4gIHJldHVybiBhcmcgPT4ge1xuICAgIHRyeSB7XG4gICAgICByZXR1cm4gZm4oYXJnKTtcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIGVyci5zdGFjayArPSBgXFxuICAgID09PT09PT09PT09PT1cXG4ke3Jvb3RTdGFja31gO1xuICAgICAgdGhyb3cgZXJyO1xuICAgIH1cbiAgfTtcbn1cblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YnVpbGRlci5qcy5tYXBcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@babel/template/lib/builder.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@babel/template/lib/formatters.js":
/*!********************************************************!*\
  !*** ./node_modules/@babel/template/lib/formatters.js ***!
  \********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports.statements = exports.statement = exports.smart = exports.program = exports.expression = void 0;\nvar _t = __webpack_require__(/*! @babel/types */ \"(ssr)/./node_modules/@babel/types/lib/index.js\");\nconst {\n  assertExpressionStatement\n} = _t;\nfunction makeStatementFormatter(fn) {\n  return {\n    code: str => `/* @babel/template */;\\n${str}`,\n    validate: () => {},\n    unwrap: ast => {\n      return fn(ast.program.body.slice(1));\n    }\n  };\n}\nconst smart = exports.smart = makeStatementFormatter(body => {\n  if (body.length > 1) {\n    return body;\n  } else {\n    return body[0];\n  }\n});\nconst statements = exports.statements = makeStatementFormatter(body => body);\nconst statement = exports.statement = makeStatementFormatter(body => {\n  if (body.length === 0) {\n    throw new Error(\"Found nothing to return.\");\n  }\n  if (body.length > 1) {\n    throw new Error(\"Found multiple statements but wanted one\");\n  }\n  return body[0];\n});\nconst expression = exports.expression = {\n  code: str => `(\\n${str}\\n)`,\n  validate: ast => {\n    if (ast.program.body.length > 1) {\n      throw new Error(\"Found multiple statements but wanted one\");\n    }\n    if (expression.unwrap(ast).start === 0) {\n      throw new Error(\"Parse result included parens.\");\n    }\n  },\n  unwrap: ({\n    program\n  }) => {\n    const [stmt] = program.body;\n    assertExpressionStatement(stmt);\n    return stmt.expression;\n  }\n};\nconst program = exports.program = {\n  code: str => str,\n  validate: () => {},\n  unwrap: ast => ast.program\n};\n\n//# sourceMappingURL=formatters.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGJhYmVsL3RlbXBsYXRlL2xpYi9mb3JtYXR0ZXJzLmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViLDhDQUE2QztBQUM3QztBQUNBLENBQUMsRUFBQztBQUNGLGtCQUFrQixHQUFHLGlCQUFpQixHQUFHLGFBQWEsR0FBRyxlQUFlLEdBQUcsa0JBQWtCO0FBQzdGLFNBQVMsbUJBQU8sQ0FBQyxvRUFBYztBQUMvQjtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQSx3Q0FBd0MsSUFBSSxJQUFJO0FBQ2hELHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxhQUFhO0FBQzNCO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBLENBQUM7QUFDRCxtQkFBbUIsa0JBQWtCO0FBQ3JDLGtCQUFrQixpQkFBaUI7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0QsbUJBQW1CLGtCQUFrQjtBQUNyQyxxQkFBcUIsSUFBSTtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsZUFBZTtBQUMvQjtBQUNBLG9CQUFvQjtBQUNwQjtBQUNBOztBQUVBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcmVwby12aXN1YWxpemVyLy4vbm9kZV9tb2R1bGVzL0BiYWJlbC90ZW1wbGF0ZS9saWIvZm9ybWF0dGVycy5qcz8xNDQ3Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5zdGF0ZW1lbnRzID0gZXhwb3J0cy5zdGF0ZW1lbnQgPSBleHBvcnRzLnNtYXJ0ID0gZXhwb3J0cy5wcm9ncmFtID0gZXhwb3J0cy5leHByZXNzaW9uID0gdm9pZCAwO1xudmFyIF90ID0gcmVxdWlyZShcIkBiYWJlbC90eXBlc1wiKTtcbmNvbnN0IHtcbiAgYXNzZXJ0RXhwcmVzc2lvblN0YXRlbWVudFxufSA9IF90O1xuZnVuY3Rpb24gbWFrZVN0YXRlbWVudEZvcm1hdHRlcihmbikge1xuICByZXR1cm4ge1xuICAgIGNvZGU6IHN0ciA9PiBgLyogQGJhYmVsL3RlbXBsYXRlICovO1xcbiR7c3RyfWAsXG4gICAgdmFsaWRhdGU6ICgpID0+IHt9LFxuICAgIHVud3JhcDogYXN0ID0+IHtcbiAgICAgIHJldHVybiBmbihhc3QucHJvZ3JhbS5ib2R5LnNsaWNlKDEpKTtcbiAgICB9XG4gIH07XG59XG5jb25zdCBzbWFydCA9IGV4cG9ydHMuc21hcnQgPSBtYWtlU3RhdGVtZW50Rm9ybWF0dGVyKGJvZHkgPT4ge1xuICBpZiAoYm9keS5sZW5ndGggPiAxKSB7XG4gICAgcmV0dXJuIGJvZHk7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGJvZHlbMF07XG4gIH1cbn0pO1xuY29uc3Qgc3RhdGVtZW50cyA9IGV4cG9ydHMuc3RhdGVtZW50cyA9IG1ha2VTdGF0ZW1lbnRGb3JtYXR0ZXIoYm9keSA9PiBib2R5KTtcbmNvbnN0IHN0YXRlbWVudCA9IGV4cG9ydHMuc3RhdGVtZW50ID0gbWFrZVN0YXRlbWVudEZvcm1hdHRlcihib2R5ID0+IHtcbiAgaWYgKGJvZHkubGVuZ3RoID09PSAwKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiRm91bmQgbm90aGluZyB0byByZXR1cm4uXCIpO1xuICB9XG4gIGlmIChib2R5Lmxlbmd0aCA+IDEpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJGb3VuZCBtdWx0aXBsZSBzdGF0ZW1lbnRzIGJ1dCB3YW50ZWQgb25lXCIpO1xuICB9XG4gIHJldHVybiBib2R5WzBdO1xufSk7XG5jb25zdCBleHByZXNzaW9uID0gZXhwb3J0cy5leHByZXNzaW9uID0ge1xuICBjb2RlOiBzdHIgPT4gYChcXG4ke3N0cn1cXG4pYCxcbiAgdmFsaWRhdGU6IGFzdCA9PiB7XG4gICAgaWYgKGFzdC5wcm9ncmFtLmJvZHkubGVuZ3RoID4gMSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRm91bmQgbXVsdGlwbGUgc3RhdGVtZW50cyBidXQgd2FudGVkIG9uZVwiKTtcbiAgICB9XG4gICAgaWYgKGV4cHJlc3Npb24udW53cmFwKGFzdCkuc3RhcnQgPT09IDApIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIlBhcnNlIHJlc3VsdCBpbmNsdWRlZCBwYXJlbnMuXCIpO1xuICAgIH1cbiAgfSxcbiAgdW53cmFwOiAoe1xuICAgIHByb2dyYW1cbiAgfSkgPT4ge1xuICAgIGNvbnN0IFtzdG10XSA9IHByb2dyYW0uYm9keTtcbiAgICBhc3NlcnRFeHByZXNzaW9uU3RhdGVtZW50KHN0bXQpO1xuICAgIHJldHVybiBzdG10LmV4cHJlc3Npb247XG4gIH1cbn07XG5jb25zdCBwcm9ncmFtID0gZXhwb3J0cy5wcm9ncmFtID0ge1xuICBjb2RlOiBzdHIgPT4gc3RyLFxuICB2YWxpZGF0ZTogKCkgPT4ge30sXG4gIHVud3JhcDogYXN0ID0+IGFzdC5wcm9ncmFtXG59O1xuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1mb3JtYXR0ZXJzLmpzLm1hcFxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@babel/template/lib/formatters.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@babel/template/lib/index.js":
/*!***************************************************!*\
  !*** ./node_modules/@babel/template/lib/index.js ***!
  \***************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports.statements = exports.statement = exports.smart = exports.program = exports.expression = exports[\"default\"] = void 0;\nvar formatters = __webpack_require__(/*! ./formatters.js */ \"(ssr)/./node_modules/@babel/template/lib/formatters.js\");\nvar _builder = __webpack_require__(/*! ./builder.js */ \"(ssr)/./node_modules/@babel/template/lib/builder.js\");\nconst smart = exports.smart = (0, _builder.default)(formatters.smart);\nconst statement = exports.statement = (0, _builder.default)(formatters.statement);\nconst statements = exports.statements = (0, _builder.default)(formatters.statements);\nconst expression = exports.expression = (0, _builder.default)(formatters.expression);\nconst program = exports.program = (0, _builder.default)(formatters.program);\nvar _default = exports[\"default\"] = Object.assign(smart.bind(undefined), {\n  smart,\n  statement,\n  statements,\n  expression,\n  program,\n  ast: smart.ast\n});\n\n//# sourceMappingURL=index.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGJhYmVsL3RlbXBsYXRlL2xpYi9pbmRleC5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYiw4Q0FBNkM7QUFDN0M7QUFDQSxDQUFDLEVBQUM7QUFDRixrQkFBa0IsR0FBRyxpQkFBaUIsR0FBRyxhQUFhLEdBQUcsZUFBZSxHQUFHLGtCQUFrQixHQUFHLGtCQUFlO0FBQy9HLGlCQUFpQixtQkFBTyxDQUFDLCtFQUFpQjtBQUMxQyxlQUFlLG1CQUFPLENBQUMseUVBQWM7QUFDckMsY0FBYyxhQUFhO0FBQzNCLGtCQUFrQixpQkFBaUI7QUFDbkMsbUJBQW1CLGtCQUFrQjtBQUNyQyxtQkFBbUIsa0JBQWtCO0FBQ3JDLGdCQUFnQixlQUFlO0FBQy9CLGVBQWUsa0JBQWU7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRCIsInNvdXJjZXMiOlsid2VicGFjazovL3JlcG8tdmlzdWFsaXplci8uL25vZGVfbW9kdWxlcy9AYmFiZWwvdGVtcGxhdGUvbGliL2luZGV4LmpzPzI5ZjMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLnN0YXRlbWVudHMgPSBleHBvcnRzLnN0YXRlbWVudCA9IGV4cG9ydHMuc21hcnQgPSBleHBvcnRzLnByb2dyYW0gPSBleHBvcnRzLmV4cHJlc3Npb24gPSBleHBvcnRzLmRlZmF1bHQgPSB2b2lkIDA7XG52YXIgZm9ybWF0dGVycyA9IHJlcXVpcmUoXCIuL2Zvcm1hdHRlcnMuanNcIik7XG52YXIgX2J1aWxkZXIgPSByZXF1aXJlKFwiLi9idWlsZGVyLmpzXCIpO1xuY29uc3Qgc21hcnQgPSBleHBvcnRzLnNtYXJ0ID0gKDAsIF9idWlsZGVyLmRlZmF1bHQpKGZvcm1hdHRlcnMuc21hcnQpO1xuY29uc3Qgc3RhdGVtZW50ID0gZXhwb3J0cy5zdGF0ZW1lbnQgPSAoMCwgX2J1aWxkZXIuZGVmYXVsdCkoZm9ybWF0dGVycy5zdGF0ZW1lbnQpO1xuY29uc3Qgc3RhdGVtZW50cyA9IGV4cG9ydHMuc3RhdGVtZW50cyA9ICgwLCBfYnVpbGRlci5kZWZhdWx0KShmb3JtYXR0ZXJzLnN0YXRlbWVudHMpO1xuY29uc3QgZXhwcmVzc2lvbiA9IGV4cG9ydHMuZXhwcmVzc2lvbiA9ICgwLCBfYnVpbGRlci5kZWZhdWx0KShmb3JtYXR0ZXJzLmV4cHJlc3Npb24pO1xuY29uc3QgcHJvZ3JhbSA9IGV4cG9ydHMucHJvZ3JhbSA9ICgwLCBfYnVpbGRlci5kZWZhdWx0KShmb3JtYXR0ZXJzLnByb2dyYW0pO1xudmFyIF9kZWZhdWx0ID0gZXhwb3J0cy5kZWZhdWx0ID0gT2JqZWN0LmFzc2lnbihzbWFydC5iaW5kKHVuZGVmaW5lZCksIHtcbiAgc21hcnQsXG4gIHN0YXRlbWVudCxcbiAgc3RhdGVtZW50cyxcbiAgZXhwcmVzc2lvbixcbiAgcHJvZ3JhbSxcbiAgYXN0OiBzbWFydC5hc3Rcbn0pO1xuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXBcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@babel/template/lib/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@babel/template/lib/literal.js":
/*!*****************************************************!*\
  !*** ./node_modules/@babel/template/lib/literal.js ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports[\"default\"] = literalTemplate;\nvar _options = __webpack_require__(/*! ./options.js */ \"(ssr)/./node_modules/@babel/template/lib/options.js\");\nvar _parse = __webpack_require__(/*! ./parse.js */ \"(ssr)/./node_modules/@babel/template/lib/parse.js\");\nvar _populate = __webpack_require__(/*! ./populate.js */ \"(ssr)/./node_modules/@babel/template/lib/populate.js\");\nfunction literalTemplate(formatter, tpl, opts) {\n  const {\n    metadata,\n    names\n  } = buildLiteralData(formatter, tpl, opts);\n  return arg => {\n    const defaultReplacements = {};\n    arg.forEach((replacement, i) => {\n      defaultReplacements[names[i]] = replacement;\n    });\n    return arg => {\n      const replacements = (0, _options.normalizeReplacements)(arg);\n      if (replacements) {\n        Object.keys(replacements).forEach(key => {\n          if (hasOwnProperty.call(defaultReplacements, key)) {\n            throw new Error(\"Unexpected replacement overlap.\");\n          }\n        });\n      }\n      return formatter.unwrap((0, _populate.default)(metadata, replacements ? Object.assign(replacements, defaultReplacements) : defaultReplacements));\n    };\n  };\n}\nfunction buildLiteralData(formatter, tpl, opts) {\n  let prefix = \"BABEL_TPL$\";\n  const raw = tpl.join(\"\");\n  do {\n    prefix = \"$$\" + prefix;\n  } while (raw.includes(prefix));\n  const {\n    names,\n    code\n  } = buildTemplateCode(tpl, prefix);\n  const metadata = (0, _parse.default)(formatter, formatter.code(code), {\n    parser: opts.parser,\n    placeholderWhitelist: new Set(names.concat(opts.placeholderWhitelist ? Array.from(opts.placeholderWhitelist) : [])),\n    placeholderPattern: opts.placeholderPattern,\n    preserveComments: opts.preserveComments,\n    syntacticPlaceholders: opts.syntacticPlaceholders\n  });\n  return {\n    metadata,\n    names\n  };\n}\nfunction buildTemplateCode(tpl, prefix) {\n  const names = [];\n  let code = tpl[0];\n  for (let i = 1; i < tpl.length; i++) {\n    const value = `${prefix}${i - 1}`;\n    names.push(value);\n    code += value + tpl[i];\n  }\n  return {\n    names,\n    code\n  };\n}\n\n//# sourceMappingURL=literal.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGJhYmVsL3RlbXBsYXRlL2xpYi9saXRlcmFsLmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViLDhDQUE2QztBQUM3QztBQUNBLENBQUMsRUFBQztBQUNGLGtCQUFlO0FBQ2YsZUFBZSxtQkFBTyxDQUFDLHlFQUFjO0FBQ3JDLGFBQWEsbUJBQU8sQ0FBQyxxRUFBWTtBQUNqQyxnQkFBZ0IsbUJBQU8sQ0FBQywyRUFBZTtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsZ0JBQWdCO0FBQ2xDLHFCQUFxQixPQUFPLEVBQUUsTUFBTTtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcmVwby12aXN1YWxpemVyLy4vbm9kZV9tb2R1bGVzL0BiYWJlbC90ZW1wbGF0ZS9saWIvbGl0ZXJhbC5qcz85ZGQ2Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5kZWZhdWx0ID0gbGl0ZXJhbFRlbXBsYXRlO1xudmFyIF9vcHRpb25zID0gcmVxdWlyZShcIi4vb3B0aW9ucy5qc1wiKTtcbnZhciBfcGFyc2UgPSByZXF1aXJlKFwiLi9wYXJzZS5qc1wiKTtcbnZhciBfcG9wdWxhdGUgPSByZXF1aXJlKFwiLi9wb3B1bGF0ZS5qc1wiKTtcbmZ1bmN0aW9uIGxpdGVyYWxUZW1wbGF0ZShmb3JtYXR0ZXIsIHRwbCwgb3B0cykge1xuICBjb25zdCB7XG4gICAgbWV0YWRhdGEsXG4gICAgbmFtZXNcbiAgfSA9IGJ1aWxkTGl0ZXJhbERhdGEoZm9ybWF0dGVyLCB0cGwsIG9wdHMpO1xuICByZXR1cm4gYXJnID0+IHtcbiAgICBjb25zdCBkZWZhdWx0UmVwbGFjZW1lbnRzID0ge307XG4gICAgYXJnLmZvckVhY2goKHJlcGxhY2VtZW50LCBpKSA9PiB7XG4gICAgICBkZWZhdWx0UmVwbGFjZW1lbnRzW25hbWVzW2ldXSA9IHJlcGxhY2VtZW50O1xuICAgIH0pO1xuICAgIHJldHVybiBhcmcgPT4ge1xuICAgICAgY29uc3QgcmVwbGFjZW1lbnRzID0gKDAsIF9vcHRpb25zLm5vcm1hbGl6ZVJlcGxhY2VtZW50cykoYXJnKTtcbiAgICAgIGlmIChyZXBsYWNlbWVudHMpIHtcbiAgICAgICAgT2JqZWN0LmtleXMocmVwbGFjZW1lbnRzKS5mb3JFYWNoKGtleSA9PiB7XG4gICAgICAgICAgaWYgKGhhc093blByb3BlcnR5LmNhbGwoZGVmYXVsdFJlcGxhY2VtZW50cywga2V5KSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVW5leHBlY3RlZCByZXBsYWNlbWVudCBvdmVybGFwLlwiKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGZvcm1hdHRlci51bndyYXAoKDAsIF9wb3B1bGF0ZS5kZWZhdWx0KShtZXRhZGF0YSwgcmVwbGFjZW1lbnRzID8gT2JqZWN0LmFzc2lnbihyZXBsYWNlbWVudHMsIGRlZmF1bHRSZXBsYWNlbWVudHMpIDogZGVmYXVsdFJlcGxhY2VtZW50cykpO1xuICAgIH07XG4gIH07XG59XG5mdW5jdGlvbiBidWlsZExpdGVyYWxEYXRhKGZvcm1hdHRlciwgdHBsLCBvcHRzKSB7XG4gIGxldCBwcmVmaXggPSBcIkJBQkVMX1RQTCRcIjtcbiAgY29uc3QgcmF3ID0gdHBsLmpvaW4oXCJcIik7XG4gIGRvIHtcbiAgICBwcmVmaXggPSBcIiQkXCIgKyBwcmVmaXg7XG4gIH0gd2hpbGUgKHJhdy5pbmNsdWRlcyhwcmVmaXgpKTtcbiAgY29uc3Qge1xuICAgIG5hbWVzLFxuICAgIGNvZGVcbiAgfSA9IGJ1aWxkVGVtcGxhdGVDb2RlKHRwbCwgcHJlZml4KTtcbiAgY29uc3QgbWV0YWRhdGEgPSAoMCwgX3BhcnNlLmRlZmF1bHQpKGZvcm1hdHRlciwgZm9ybWF0dGVyLmNvZGUoY29kZSksIHtcbiAgICBwYXJzZXI6IG9wdHMucGFyc2VyLFxuICAgIHBsYWNlaG9sZGVyV2hpdGVsaXN0OiBuZXcgU2V0KG5hbWVzLmNvbmNhdChvcHRzLnBsYWNlaG9sZGVyV2hpdGVsaXN0ID8gQXJyYXkuZnJvbShvcHRzLnBsYWNlaG9sZGVyV2hpdGVsaXN0KSA6IFtdKSksXG4gICAgcGxhY2Vob2xkZXJQYXR0ZXJuOiBvcHRzLnBsYWNlaG9sZGVyUGF0dGVybixcbiAgICBwcmVzZXJ2ZUNvbW1lbnRzOiBvcHRzLnByZXNlcnZlQ29tbWVudHMsXG4gICAgc3ludGFjdGljUGxhY2Vob2xkZXJzOiBvcHRzLnN5bnRhY3RpY1BsYWNlaG9sZGVyc1xuICB9KTtcbiAgcmV0dXJuIHtcbiAgICBtZXRhZGF0YSxcbiAgICBuYW1lc1xuICB9O1xufVxuZnVuY3Rpb24gYnVpbGRUZW1wbGF0ZUNvZGUodHBsLCBwcmVmaXgpIHtcbiAgY29uc3QgbmFtZXMgPSBbXTtcbiAgbGV0IGNvZGUgPSB0cGxbMF07XG4gIGZvciAobGV0IGkgPSAxOyBpIDwgdHBsLmxlbmd0aDsgaSsrKSB7XG4gICAgY29uc3QgdmFsdWUgPSBgJHtwcmVmaXh9JHtpIC0gMX1gO1xuICAgIG5hbWVzLnB1c2godmFsdWUpO1xuICAgIGNvZGUgKz0gdmFsdWUgKyB0cGxbaV07XG4gIH1cbiAgcmV0dXJuIHtcbiAgICBuYW1lcyxcbiAgICBjb2RlXG4gIH07XG59XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWxpdGVyYWwuanMubWFwXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@babel/template/lib/literal.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@babel/template/lib/options.js":
/*!*****************************************************!*\
  !*** ./node_modules/@babel/template/lib/options.js ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports.merge = merge;\nexports.normalizeReplacements = normalizeReplacements;\nexports.validate = validate;\nconst _excluded = [\"placeholderWhitelist\", \"placeholderPattern\", \"preserveComments\", \"syntacticPlaceholders\"];\nfunction _objectWithoutPropertiesLoose(r, e) { if (null == r) return {}; var t = {}; for (var n in r) if ({}.hasOwnProperty.call(r, n)) { if (-1 !== e.indexOf(n)) continue; t[n] = r[n]; } return t; }\nfunction merge(a, b) {\n  const {\n    placeholderWhitelist = a.placeholderWhitelist,\n    placeholderPattern = a.placeholderPattern,\n    preserveComments = a.preserveComments,\n    syntacticPlaceholders = a.syntacticPlaceholders\n  } = b;\n  return {\n    parser: Object.assign({}, a.parser, b.parser),\n    placeholderWhitelist,\n    placeholderPattern,\n    preserveComments,\n    syntacticPlaceholders\n  };\n}\nfunction validate(opts) {\n  if (opts != null && typeof opts !== \"object\") {\n    throw new Error(\"Unknown template options.\");\n  }\n  const _ref = opts || {},\n    {\n      placeholderWhitelist,\n      placeholderPattern,\n      preserveComments,\n      syntacticPlaceholders\n    } = _ref,\n    parser = _objectWithoutPropertiesLoose(_ref, _excluded);\n  if (placeholderWhitelist != null && !(placeholderWhitelist instanceof Set)) {\n    throw new Error(\"'.placeholderWhitelist' must be a Set, null, or undefined\");\n  }\n  if (placeholderPattern != null && !(placeholderPattern instanceof RegExp) && placeholderPattern !== false) {\n    throw new Error(\"'.placeholderPattern' must be a RegExp, false, null, or undefined\");\n  }\n  if (preserveComments != null && typeof preserveComments !== \"boolean\") {\n    throw new Error(\"'.preserveComments' must be a boolean, null, or undefined\");\n  }\n  if (syntacticPlaceholders != null && typeof syntacticPlaceholders !== \"boolean\") {\n    throw new Error(\"'.syntacticPlaceholders' must be a boolean, null, or undefined\");\n  }\n  if (syntacticPlaceholders === true && (placeholderWhitelist != null || placeholderPattern != null)) {\n    throw new Error(\"'.placeholderWhitelist' and '.placeholderPattern' aren't compatible\" + \" with '.syntacticPlaceholders: true'\");\n  }\n  return {\n    parser,\n    placeholderWhitelist: placeholderWhitelist || undefined,\n    placeholderPattern: placeholderPattern == null ? undefined : placeholderPattern,\n    preserveComments: preserveComments == null ? undefined : preserveComments,\n    syntacticPlaceholders: syntacticPlaceholders == null ? undefined : syntacticPlaceholders\n  };\n}\nfunction normalizeReplacements(replacements) {\n  if (Array.isArray(replacements)) {\n    return replacements.reduce((acc, replacement, i) => {\n      acc[\"$\" + i] = replacement;\n      return acc;\n    }, {});\n  } else if (typeof replacements === \"object\" || replacements == null) {\n    return replacements || undefined;\n  }\n  throw new Error(\"Template replacements must be an array, object, null, or undefined\");\n}\n\n//# sourceMappingURL=options.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGJhYmVsL3RlbXBsYXRlL2xpYi9vcHRpb25zLmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViLDhDQUE2QztBQUM3QztBQUNBLENBQUMsRUFBQztBQUNGLGFBQWE7QUFDYiw2QkFBNkI7QUFDN0IsZ0JBQWdCO0FBQ2hCO0FBQ0EsK0NBQStDLDBCQUEwQixZQUFZLHVCQUF1Qiw4QkFBOEIsbUNBQW1DLGVBQWU7QUFDNUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsNEJBQTRCO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUssSUFBSTtBQUNULElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTs7QUFFQSIsInNvdXJjZXMiOlsid2VicGFjazovL3JlcG8tdmlzdWFsaXplci8uL25vZGVfbW9kdWxlcy9AYmFiZWwvdGVtcGxhdGUvbGliL29wdGlvbnMuanM/ODJkNiJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMubWVyZ2UgPSBtZXJnZTtcbmV4cG9ydHMubm9ybWFsaXplUmVwbGFjZW1lbnRzID0gbm9ybWFsaXplUmVwbGFjZW1lbnRzO1xuZXhwb3J0cy52YWxpZGF0ZSA9IHZhbGlkYXRlO1xuY29uc3QgX2V4Y2x1ZGVkID0gW1wicGxhY2Vob2xkZXJXaGl0ZWxpc3RcIiwgXCJwbGFjZWhvbGRlclBhdHRlcm5cIiwgXCJwcmVzZXJ2ZUNvbW1lbnRzXCIsIFwic3ludGFjdGljUGxhY2Vob2xkZXJzXCJdO1xuZnVuY3Rpb24gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzTG9vc2UociwgZSkgeyBpZiAobnVsbCA9PSByKSByZXR1cm4ge307IHZhciB0ID0ge307IGZvciAodmFyIG4gaW4gcikgaWYgKHt9Lmhhc093blByb3BlcnR5LmNhbGwociwgbikpIHsgaWYgKC0xICE9PSBlLmluZGV4T2YobikpIGNvbnRpbnVlOyB0W25dID0gcltuXTsgfSByZXR1cm4gdDsgfVxuZnVuY3Rpb24gbWVyZ2UoYSwgYikge1xuICBjb25zdCB7XG4gICAgcGxhY2Vob2xkZXJXaGl0ZWxpc3QgPSBhLnBsYWNlaG9sZGVyV2hpdGVsaXN0LFxuICAgIHBsYWNlaG9sZGVyUGF0dGVybiA9IGEucGxhY2Vob2xkZXJQYXR0ZXJuLFxuICAgIHByZXNlcnZlQ29tbWVudHMgPSBhLnByZXNlcnZlQ29tbWVudHMsXG4gICAgc3ludGFjdGljUGxhY2Vob2xkZXJzID0gYS5zeW50YWN0aWNQbGFjZWhvbGRlcnNcbiAgfSA9IGI7XG4gIHJldHVybiB7XG4gICAgcGFyc2VyOiBPYmplY3QuYXNzaWduKHt9LCBhLnBhcnNlciwgYi5wYXJzZXIpLFxuICAgIHBsYWNlaG9sZGVyV2hpdGVsaXN0LFxuICAgIHBsYWNlaG9sZGVyUGF0dGVybixcbiAgICBwcmVzZXJ2ZUNvbW1lbnRzLFxuICAgIHN5bnRhY3RpY1BsYWNlaG9sZGVyc1xuICB9O1xufVxuZnVuY3Rpb24gdmFsaWRhdGUob3B0cykge1xuICBpZiAob3B0cyAhPSBudWxsICYmIHR5cGVvZiBvcHRzICE9PSBcIm9iamVjdFwiKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiVW5rbm93biB0ZW1wbGF0ZSBvcHRpb25zLlwiKTtcbiAgfVxuICBjb25zdCBfcmVmID0gb3B0cyB8fCB7fSxcbiAgICB7XG4gICAgICBwbGFjZWhvbGRlcldoaXRlbGlzdCxcbiAgICAgIHBsYWNlaG9sZGVyUGF0dGVybixcbiAgICAgIHByZXNlcnZlQ29tbWVudHMsXG4gICAgICBzeW50YWN0aWNQbGFjZWhvbGRlcnNcbiAgICB9ID0gX3JlZixcbiAgICBwYXJzZXIgPSBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXNMb29zZShfcmVmLCBfZXhjbHVkZWQpO1xuICBpZiAocGxhY2Vob2xkZXJXaGl0ZWxpc3QgIT0gbnVsbCAmJiAhKHBsYWNlaG9sZGVyV2hpdGVsaXN0IGluc3RhbmNlb2YgU2V0KSkge1xuICAgIHRocm93IG5ldyBFcnJvcihcIicucGxhY2Vob2xkZXJXaGl0ZWxpc3QnIG11c3QgYmUgYSBTZXQsIG51bGwsIG9yIHVuZGVmaW5lZFwiKTtcbiAgfVxuICBpZiAocGxhY2Vob2xkZXJQYXR0ZXJuICE9IG51bGwgJiYgIShwbGFjZWhvbGRlclBhdHRlcm4gaW5zdGFuY2VvZiBSZWdFeHApICYmIHBsYWNlaG9sZGVyUGF0dGVybiAhPT0gZmFsc2UpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCInLnBsYWNlaG9sZGVyUGF0dGVybicgbXVzdCBiZSBhIFJlZ0V4cCwgZmFsc2UsIG51bGwsIG9yIHVuZGVmaW5lZFwiKTtcbiAgfVxuICBpZiAocHJlc2VydmVDb21tZW50cyAhPSBudWxsICYmIHR5cGVvZiBwcmVzZXJ2ZUNvbW1lbnRzICE9PSBcImJvb2xlYW5cIikge1xuICAgIHRocm93IG5ldyBFcnJvcihcIicucHJlc2VydmVDb21tZW50cycgbXVzdCBiZSBhIGJvb2xlYW4sIG51bGwsIG9yIHVuZGVmaW5lZFwiKTtcbiAgfVxuICBpZiAoc3ludGFjdGljUGxhY2Vob2xkZXJzICE9IG51bGwgJiYgdHlwZW9mIHN5bnRhY3RpY1BsYWNlaG9sZGVycyAhPT0gXCJib29sZWFuXCIpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCInLnN5bnRhY3RpY1BsYWNlaG9sZGVycycgbXVzdCBiZSBhIGJvb2xlYW4sIG51bGwsIG9yIHVuZGVmaW5lZFwiKTtcbiAgfVxuICBpZiAoc3ludGFjdGljUGxhY2Vob2xkZXJzID09PSB0cnVlICYmIChwbGFjZWhvbGRlcldoaXRlbGlzdCAhPSBudWxsIHx8IHBsYWNlaG9sZGVyUGF0dGVybiAhPSBudWxsKSkge1xuICAgIHRocm93IG5ldyBFcnJvcihcIicucGxhY2Vob2xkZXJXaGl0ZWxpc3QnIGFuZCAnLnBsYWNlaG9sZGVyUGF0dGVybicgYXJlbid0IGNvbXBhdGlibGVcIiArIFwiIHdpdGggJy5zeW50YWN0aWNQbGFjZWhvbGRlcnM6IHRydWUnXCIpO1xuICB9XG4gIHJldHVybiB7XG4gICAgcGFyc2VyLFxuICAgIHBsYWNlaG9sZGVyV2hpdGVsaXN0OiBwbGFjZWhvbGRlcldoaXRlbGlzdCB8fCB1bmRlZmluZWQsXG4gICAgcGxhY2Vob2xkZXJQYXR0ZXJuOiBwbGFjZWhvbGRlclBhdHRlcm4gPT0gbnVsbCA/IHVuZGVmaW5lZCA6IHBsYWNlaG9sZGVyUGF0dGVybixcbiAgICBwcmVzZXJ2ZUNvbW1lbnRzOiBwcmVzZXJ2ZUNvbW1lbnRzID09IG51bGwgPyB1bmRlZmluZWQgOiBwcmVzZXJ2ZUNvbW1lbnRzLFxuICAgIHN5bnRhY3RpY1BsYWNlaG9sZGVyczogc3ludGFjdGljUGxhY2Vob2xkZXJzID09IG51bGwgPyB1bmRlZmluZWQgOiBzeW50YWN0aWNQbGFjZWhvbGRlcnNcbiAgfTtcbn1cbmZ1bmN0aW9uIG5vcm1hbGl6ZVJlcGxhY2VtZW50cyhyZXBsYWNlbWVudHMpIHtcbiAgaWYgKEFycmF5LmlzQXJyYXkocmVwbGFjZW1lbnRzKSkge1xuICAgIHJldHVybiByZXBsYWNlbWVudHMucmVkdWNlKChhY2MsIHJlcGxhY2VtZW50LCBpKSA9PiB7XG4gICAgICBhY2NbXCIkXCIgKyBpXSA9IHJlcGxhY2VtZW50O1xuICAgICAgcmV0dXJuIGFjYztcbiAgICB9LCB7fSk7XG4gIH0gZWxzZSBpZiAodHlwZW9mIHJlcGxhY2VtZW50cyA9PT0gXCJvYmplY3RcIiB8fCByZXBsYWNlbWVudHMgPT0gbnVsbCkge1xuICAgIHJldHVybiByZXBsYWNlbWVudHMgfHwgdW5kZWZpbmVkO1xuICB9XG4gIHRocm93IG5ldyBFcnJvcihcIlRlbXBsYXRlIHJlcGxhY2VtZW50cyBtdXN0IGJlIGFuIGFycmF5LCBvYmplY3QsIG51bGwsIG9yIHVuZGVmaW5lZFwiKTtcbn1cblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9b3B0aW9ucy5qcy5tYXBcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@babel/template/lib/options.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@babel/template/lib/parse.js":
/*!***************************************************!*\
  !*** ./node_modules/@babel/template/lib/parse.js ***!
  \***************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports[\"default\"] = parseAndBuildMetadata;\nvar _t = __webpack_require__(/*! @babel/types */ \"(ssr)/./node_modules/@babel/types/lib/index.js\");\nvar _parser = __webpack_require__(/*! @babel/parser */ \"(ssr)/./node_modules/@babel/parser/lib/index.js\");\nvar _codeFrame = __webpack_require__(/*! @babel/code-frame */ \"(ssr)/./node_modules/@babel/code-frame/lib/index.js\");\nconst {\n  isCallExpression,\n  isExpressionStatement,\n  isFunction,\n  isIdentifier,\n  isJSXIdentifier,\n  isNewExpression,\n  isPlaceholder,\n  isStatement,\n  isStringLiteral,\n  removePropertiesDeep,\n  traverse\n} = _t;\nconst PATTERN = /^[_$A-Z0-9]+$/;\nfunction parseAndBuildMetadata(formatter, code, opts) {\n  const {\n    placeholderWhitelist,\n    placeholderPattern,\n    preserveComments,\n    syntacticPlaceholders\n  } = opts;\n  const ast = parseWithCodeFrame(code, opts.parser, syntacticPlaceholders);\n  removePropertiesDeep(ast, {\n    preserveComments\n  });\n  formatter.validate(ast);\n  const state = {\n    syntactic: {\n      placeholders: [],\n      placeholderNames: new Set()\n    },\n    legacy: {\n      placeholders: [],\n      placeholderNames: new Set()\n    },\n    placeholderWhitelist,\n    placeholderPattern,\n    syntacticPlaceholders\n  };\n  traverse(ast, placeholderVisitorHandler, state);\n  return Object.assign({\n    ast\n  }, state.syntactic.placeholders.length ? state.syntactic : state.legacy);\n}\nfunction placeholderVisitorHandler(node, ancestors, state) {\n  var _state$placeholderWhi;\n  let name;\n  let hasSyntacticPlaceholders = state.syntactic.placeholders.length > 0;\n  if (isPlaceholder(node)) {\n    if (state.syntacticPlaceholders === false) {\n      throw new Error(\"%%foo%%-style placeholders can't be used when \" + \"'.syntacticPlaceholders' is false.\");\n    }\n    name = node.name.name;\n    hasSyntacticPlaceholders = true;\n  } else if (hasSyntacticPlaceholders || state.syntacticPlaceholders) {\n    return;\n  } else if (isIdentifier(node) || isJSXIdentifier(node)) {\n    name = node.name;\n  } else if (isStringLiteral(node)) {\n    name = node.value;\n  } else {\n    return;\n  }\n  if (hasSyntacticPlaceholders && (state.placeholderPattern != null || state.placeholderWhitelist != null)) {\n    throw new Error(\"'.placeholderWhitelist' and '.placeholderPattern' aren't compatible\" + \" with '.syntacticPlaceholders: true'\");\n  }\n  if (!hasSyntacticPlaceholders && (state.placeholderPattern === false || !(state.placeholderPattern || PATTERN).test(name)) && !((_state$placeholderWhi = state.placeholderWhitelist) != null && _state$placeholderWhi.has(name))) {\n    return;\n  }\n  ancestors = ancestors.slice();\n  const {\n    node: parent,\n    key\n  } = ancestors[ancestors.length - 1];\n  let type;\n  if (isStringLiteral(node) || isPlaceholder(node, {\n    expectedNode: \"StringLiteral\"\n  })) {\n    type = \"string\";\n  } else if (isNewExpression(parent) && key === \"arguments\" || isCallExpression(parent) && key === \"arguments\" || isFunction(parent) && key === \"params\") {\n    type = \"param\";\n  } else if (isExpressionStatement(parent) && !isPlaceholder(node)) {\n    type = \"statement\";\n    ancestors = ancestors.slice(0, -1);\n  } else if (isStatement(node) && isPlaceholder(node)) {\n    type = \"statement\";\n  } else {\n    type = \"other\";\n  }\n  const {\n    placeholders,\n    placeholderNames\n  } = !hasSyntacticPlaceholders ? state.legacy : state.syntactic;\n  placeholders.push({\n    name,\n    type,\n    resolve: ast => resolveAncestors(ast, ancestors),\n    isDuplicate: placeholderNames.has(name)\n  });\n  placeholderNames.add(name);\n}\nfunction resolveAncestors(ast, ancestors) {\n  let parent = ast;\n  for (let i = 0; i < ancestors.length - 1; i++) {\n    const {\n      key,\n      index\n    } = ancestors[i];\n    if (index === undefined) {\n      parent = parent[key];\n    } else {\n      parent = parent[key][index];\n    }\n  }\n  const {\n    key,\n    index\n  } = ancestors[ancestors.length - 1];\n  return {\n    parent,\n    key,\n    index\n  };\n}\nfunction parseWithCodeFrame(code, parserOpts, syntacticPlaceholders) {\n  const plugins = (parserOpts.plugins || []).slice();\n  if (syntacticPlaceholders !== false) {\n    plugins.push(\"placeholders\");\n  }\n  parserOpts = Object.assign({\n    allowAwaitOutsideFunction: true,\n    allowReturnOutsideFunction: true,\n    allowNewTargetOutsideFunction: true,\n    allowSuperOutsideMethod: true,\n    allowYieldOutsideFunction: true,\n    sourceType: \"module\"\n  }, parserOpts, {\n    plugins\n  });\n  try {\n    return (0, _parser.parse)(code, parserOpts);\n  } catch (err) {\n    const loc = err.loc;\n    if (loc) {\n      err.message += \"\\n\" + (0, _codeFrame.codeFrameColumns)(code, {\n        start: loc\n      });\n      err.code = \"BABEL_TEMPLATE_PARSE_ERROR\";\n    }\n    throw err;\n  }\n}\n\n//# sourceMappingURL=parse.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGJhYmVsL3RlbXBsYXRlL2xpYi9wYXJzZS5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYiw4Q0FBNkM7QUFDN0M7QUFDQSxDQUFDLEVBQUM7QUFDRixrQkFBZTtBQUNmLFNBQVMsbUJBQU8sQ0FBQyxvRUFBYztBQUMvQixjQUFjLG1CQUFPLENBQUMsc0VBQWU7QUFDckMsaUJBQWlCLG1CQUFPLENBQUMsOEVBQW1CO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBLElBQUk7QUFDSjtBQUNBLElBQUk7QUFDSjtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLDBCQUEwQjtBQUM1QztBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSIsInNvdXJjZXMiOlsid2VicGFjazovL3JlcG8tdmlzdWFsaXplci8uL25vZGVfbW9kdWxlcy9AYmFiZWwvdGVtcGxhdGUvbGliL3BhcnNlLmpzPzkwOTkiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLmRlZmF1bHQgPSBwYXJzZUFuZEJ1aWxkTWV0YWRhdGE7XG52YXIgX3QgPSByZXF1aXJlKFwiQGJhYmVsL3R5cGVzXCIpO1xudmFyIF9wYXJzZXIgPSByZXF1aXJlKFwiQGJhYmVsL3BhcnNlclwiKTtcbnZhciBfY29kZUZyYW1lID0gcmVxdWlyZShcIkBiYWJlbC9jb2RlLWZyYW1lXCIpO1xuY29uc3Qge1xuICBpc0NhbGxFeHByZXNzaW9uLFxuICBpc0V4cHJlc3Npb25TdGF0ZW1lbnQsXG4gIGlzRnVuY3Rpb24sXG4gIGlzSWRlbnRpZmllcixcbiAgaXNKU1hJZGVudGlmaWVyLFxuICBpc05ld0V4cHJlc3Npb24sXG4gIGlzUGxhY2Vob2xkZXIsXG4gIGlzU3RhdGVtZW50LFxuICBpc1N0cmluZ0xpdGVyYWwsXG4gIHJlbW92ZVByb3BlcnRpZXNEZWVwLFxuICB0cmF2ZXJzZVxufSA9IF90O1xuY29uc3QgUEFUVEVSTiA9IC9eW18kQS1aMC05XSskLztcbmZ1bmN0aW9uIHBhcnNlQW5kQnVpbGRNZXRhZGF0YShmb3JtYXR0ZXIsIGNvZGUsIG9wdHMpIHtcbiAgY29uc3Qge1xuICAgIHBsYWNlaG9sZGVyV2hpdGVsaXN0LFxuICAgIHBsYWNlaG9sZGVyUGF0dGVybixcbiAgICBwcmVzZXJ2ZUNvbW1lbnRzLFxuICAgIHN5bnRhY3RpY1BsYWNlaG9sZGVyc1xuICB9ID0gb3B0cztcbiAgY29uc3QgYXN0ID0gcGFyc2VXaXRoQ29kZUZyYW1lKGNvZGUsIG9wdHMucGFyc2VyLCBzeW50YWN0aWNQbGFjZWhvbGRlcnMpO1xuICByZW1vdmVQcm9wZXJ0aWVzRGVlcChhc3QsIHtcbiAgICBwcmVzZXJ2ZUNvbW1lbnRzXG4gIH0pO1xuICBmb3JtYXR0ZXIudmFsaWRhdGUoYXN0KTtcbiAgY29uc3Qgc3RhdGUgPSB7XG4gICAgc3ludGFjdGljOiB7XG4gICAgICBwbGFjZWhvbGRlcnM6IFtdLFxuICAgICAgcGxhY2Vob2xkZXJOYW1lczogbmV3IFNldCgpXG4gICAgfSxcbiAgICBsZWdhY3k6IHtcbiAgICAgIHBsYWNlaG9sZGVyczogW10sXG4gICAgICBwbGFjZWhvbGRlck5hbWVzOiBuZXcgU2V0KClcbiAgICB9LFxuICAgIHBsYWNlaG9sZGVyV2hpdGVsaXN0LFxuICAgIHBsYWNlaG9sZGVyUGF0dGVybixcbiAgICBzeW50YWN0aWNQbGFjZWhvbGRlcnNcbiAgfTtcbiAgdHJhdmVyc2UoYXN0LCBwbGFjZWhvbGRlclZpc2l0b3JIYW5kbGVyLCBzdGF0ZSk7XG4gIHJldHVybiBPYmplY3QuYXNzaWduKHtcbiAgICBhc3RcbiAgfSwgc3RhdGUuc3ludGFjdGljLnBsYWNlaG9sZGVycy5sZW5ndGggPyBzdGF0ZS5zeW50YWN0aWMgOiBzdGF0ZS5sZWdhY3kpO1xufVxuZnVuY3Rpb24gcGxhY2Vob2xkZXJWaXNpdG9ySGFuZGxlcihub2RlLCBhbmNlc3RvcnMsIHN0YXRlKSB7XG4gIHZhciBfc3RhdGUkcGxhY2Vob2xkZXJXaGk7XG4gIGxldCBuYW1lO1xuICBsZXQgaGFzU3ludGFjdGljUGxhY2Vob2xkZXJzID0gc3RhdGUuc3ludGFjdGljLnBsYWNlaG9sZGVycy5sZW5ndGggPiAwO1xuICBpZiAoaXNQbGFjZWhvbGRlcihub2RlKSkge1xuICAgIGlmIChzdGF0ZS5zeW50YWN0aWNQbGFjZWhvbGRlcnMgPT09IGZhbHNlKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCIlJWZvbyUlLXN0eWxlIHBsYWNlaG9sZGVycyBjYW4ndCBiZSB1c2VkIHdoZW4gXCIgKyBcIicuc3ludGFjdGljUGxhY2Vob2xkZXJzJyBpcyBmYWxzZS5cIik7XG4gICAgfVxuICAgIG5hbWUgPSBub2RlLm5hbWUubmFtZTtcbiAgICBoYXNTeW50YWN0aWNQbGFjZWhvbGRlcnMgPSB0cnVlO1xuICB9IGVsc2UgaWYgKGhhc1N5bnRhY3RpY1BsYWNlaG9sZGVycyB8fCBzdGF0ZS5zeW50YWN0aWNQbGFjZWhvbGRlcnMpIHtcbiAgICByZXR1cm47XG4gIH0gZWxzZSBpZiAoaXNJZGVudGlmaWVyKG5vZGUpIHx8IGlzSlNYSWRlbnRpZmllcihub2RlKSkge1xuICAgIG5hbWUgPSBub2RlLm5hbWU7XG4gIH0gZWxzZSBpZiAoaXNTdHJpbmdMaXRlcmFsKG5vZGUpKSB7XG4gICAgbmFtZSA9IG5vZGUudmFsdWU7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGlmIChoYXNTeW50YWN0aWNQbGFjZWhvbGRlcnMgJiYgKHN0YXRlLnBsYWNlaG9sZGVyUGF0dGVybiAhPSBudWxsIHx8IHN0YXRlLnBsYWNlaG9sZGVyV2hpdGVsaXN0ICE9IG51bGwpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiJy5wbGFjZWhvbGRlcldoaXRlbGlzdCcgYW5kICcucGxhY2Vob2xkZXJQYXR0ZXJuJyBhcmVuJ3QgY29tcGF0aWJsZVwiICsgXCIgd2l0aCAnLnN5bnRhY3RpY1BsYWNlaG9sZGVyczogdHJ1ZSdcIik7XG4gIH1cbiAgaWYgKCFoYXNTeW50YWN0aWNQbGFjZWhvbGRlcnMgJiYgKHN0YXRlLnBsYWNlaG9sZGVyUGF0dGVybiA9PT0gZmFsc2UgfHwgIShzdGF0ZS5wbGFjZWhvbGRlclBhdHRlcm4gfHwgUEFUVEVSTikudGVzdChuYW1lKSkgJiYgISgoX3N0YXRlJHBsYWNlaG9sZGVyV2hpID0gc3RhdGUucGxhY2Vob2xkZXJXaGl0ZWxpc3QpICE9IG51bGwgJiYgX3N0YXRlJHBsYWNlaG9sZGVyV2hpLmhhcyhuYW1lKSkpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgYW5jZXN0b3JzID0gYW5jZXN0b3JzLnNsaWNlKCk7XG4gIGNvbnN0IHtcbiAgICBub2RlOiBwYXJlbnQsXG4gICAga2V5XG4gIH0gPSBhbmNlc3RvcnNbYW5jZXN0b3JzLmxlbmd0aCAtIDFdO1xuICBsZXQgdHlwZTtcbiAgaWYgKGlzU3RyaW5nTGl0ZXJhbChub2RlKSB8fCBpc1BsYWNlaG9sZGVyKG5vZGUsIHtcbiAgICBleHBlY3RlZE5vZGU6IFwiU3RyaW5nTGl0ZXJhbFwiXG4gIH0pKSB7XG4gICAgdHlwZSA9IFwic3RyaW5nXCI7XG4gIH0gZWxzZSBpZiAoaXNOZXdFeHByZXNzaW9uKHBhcmVudCkgJiYga2V5ID09PSBcImFyZ3VtZW50c1wiIHx8IGlzQ2FsbEV4cHJlc3Npb24ocGFyZW50KSAmJiBrZXkgPT09IFwiYXJndW1lbnRzXCIgfHwgaXNGdW5jdGlvbihwYXJlbnQpICYmIGtleSA9PT0gXCJwYXJhbXNcIikge1xuICAgIHR5cGUgPSBcInBhcmFtXCI7XG4gIH0gZWxzZSBpZiAoaXNFeHByZXNzaW9uU3RhdGVtZW50KHBhcmVudCkgJiYgIWlzUGxhY2Vob2xkZXIobm9kZSkpIHtcbiAgICB0eXBlID0gXCJzdGF0ZW1lbnRcIjtcbiAgICBhbmNlc3RvcnMgPSBhbmNlc3RvcnMuc2xpY2UoMCwgLTEpO1xuICB9IGVsc2UgaWYgKGlzU3RhdGVtZW50KG5vZGUpICYmIGlzUGxhY2Vob2xkZXIobm9kZSkpIHtcbiAgICB0eXBlID0gXCJzdGF0ZW1lbnRcIjtcbiAgfSBlbHNlIHtcbiAgICB0eXBlID0gXCJvdGhlclwiO1xuICB9XG4gIGNvbnN0IHtcbiAgICBwbGFjZWhvbGRlcnMsXG4gICAgcGxhY2Vob2xkZXJOYW1lc1xuICB9ID0gIWhhc1N5bnRhY3RpY1BsYWNlaG9sZGVycyA/IHN0YXRlLmxlZ2FjeSA6IHN0YXRlLnN5bnRhY3RpYztcbiAgcGxhY2Vob2xkZXJzLnB1c2goe1xuICAgIG5hbWUsXG4gICAgdHlwZSxcbiAgICByZXNvbHZlOiBhc3QgPT4gcmVzb2x2ZUFuY2VzdG9ycyhhc3QsIGFuY2VzdG9ycyksXG4gICAgaXNEdXBsaWNhdGU6IHBsYWNlaG9sZGVyTmFtZXMuaGFzKG5hbWUpXG4gIH0pO1xuICBwbGFjZWhvbGRlck5hbWVzLmFkZChuYW1lKTtcbn1cbmZ1bmN0aW9uIHJlc29sdmVBbmNlc3RvcnMoYXN0LCBhbmNlc3RvcnMpIHtcbiAgbGV0IHBhcmVudCA9IGFzdDtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBhbmNlc3RvcnMubGVuZ3RoIC0gMTsgaSsrKSB7XG4gICAgY29uc3Qge1xuICAgICAga2V5LFxuICAgICAgaW5kZXhcbiAgICB9ID0gYW5jZXN0b3JzW2ldO1xuICAgIGlmIChpbmRleCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBwYXJlbnQgPSBwYXJlbnRba2V5XTtcbiAgICB9IGVsc2Uge1xuICAgICAgcGFyZW50ID0gcGFyZW50W2tleV1baW5kZXhdO1xuICAgIH1cbiAgfVxuICBjb25zdCB7XG4gICAga2V5LFxuICAgIGluZGV4XG4gIH0gPSBhbmNlc3RvcnNbYW5jZXN0b3JzLmxlbmd0aCAtIDFdO1xuICByZXR1cm4ge1xuICAgIHBhcmVudCxcbiAgICBrZXksXG4gICAgaW5kZXhcbiAgfTtcbn1cbmZ1bmN0aW9uIHBhcnNlV2l0aENvZGVGcmFtZShjb2RlLCBwYXJzZXJPcHRzLCBzeW50YWN0aWNQbGFjZWhvbGRlcnMpIHtcbiAgY29uc3QgcGx1Z2lucyA9IChwYXJzZXJPcHRzLnBsdWdpbnMgfHwgW10pLnNsaWNlKCk7XG4gIGlmIChzeW50YWN0aWNQbGFjZWhvbGRlcnMgIT09IGZhbHNlKSB7XG4gICAgcGx1Z2lucy5wdXNoKFwicGxhY2Vob2xkZXJzXCIpO1xuICB9XG4gIHBhcnNlck9wdHMgPSBPYmplY3QuYXNzaWduKHtcbiAgICBhbGxvd0F3YWl0T3V0c2lkZUZ1bmN0aW9uOiB0cnVlLFxuICAgIGFsbG93UmV0dXJuT3V0c2lkZUZ1bmN0aW9uOiB0cnVlLFxuICAgIGFsbG93TmV3VGFyZ2V0T3V0c2lkZUZ1bmN0aW9uOiB0cnVlLFxuICAgIGFsbG93U3VwZXJPdXRzaWRlTWV0aG9kOiB0cnVlLFxuICAgIGFsbG93WWllbGRPdXRzaWRlRnVuY3Rpb246IHRydWUsXG4gICAgc291cmNlVHlwZTogXCJtb2R1bGVcIlxuICB9LCBwYXJzZXJPcHRzLCB7XG4gICAgcGx1Z2luc1xuICB9KTtcbiAgdHJ5IHtcbiAgICByZXR1cm4gKDAsIF9wYXJzZXIucGFyc2UpKGNvZGUsIHBhcnNlck9wdHMpO1xuICB9IGNhdGNoIChlcnIpIHtcbiAgICBjb25zdCBsb2MgPSBlcnIubG9jO1xuICAgIGlmIChsb2MpIHtcbiAgICAgIGVyci5tZXNzYWdlICs9IFwiXFxuXCIgKyAoMCwgX2NvZGVGcmFtZS5jb2RlRnJhbWVDb2x1bW5zKShjb2RlLCB7XG4gICAgICAgIHN0YXJ0OiBsb2NcbiAgICAgIH0pO1xuICAgICAgZXJyLmNvZGUgPSBcIkJBQkVMX1RFTVBMQVRFX1BBUlNFX0VSUk9SXCI7XG4gICAgfVxuICAgIHRocm93IGVycjtcbiAgfVxufVxuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1wYXJzZS5qcy5tYXBcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@babel/template/lib/parse.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@babel/template/lib/populate.js":
/*!******************************************************!*\
  !*** ./node_modules/@babel/template/lib/populate.js ***!
  \******************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports[\"default\"] = populatePlaceholders;\nvar _t = __webpack_require__(/*! @babel/types */ \"(ssr)/./node_modules/@babel/types/lib/index.js\");\nconst {\n  blockStatement,\n  cloneNode,\n  emptyStatement,\n  expressionStatement,\n  identifier,\n  isStatement,\n  isStringLiteral,\n  stringLiteral,\n  validate\n} = _t;\nfunction populatePlaceholders(metadata, replacements) {\n  const ast = cloneNode(metadata.ast);\n  if (replacements) {\n    metadata.placeholders.forEach(placeholder => {\n      if (!hasOwnProperty.call(replacements, placeholder.name)) {\n        const placeholderName = placeholder.name;\n        throw new Error(`Error: No substitution given for \"${placeholderName}\". If this is not meant to be a\n            placeholder you may want to consider passing one of the following options to @babel/template:\n            - { placeholderPattern: false, placeholderWhitelist: new Set(['${placeholderName}'])}\n            - { placeholderPattern: /^${placeholderName}$/ }`);\n      }\n    });\n    Object.keys(replacements).forEach(key => {\n      if (!metadata.placeholderNames.has(key)) {\n        throw new Error(`Unknown substitution \"${key}\" given`);\n      }\n    });\n  }\n  metadata.placeholders.slice().reverse().forEach(placeholder => {\n    try {\n      var _ref;\n      applyReplacement(placeholder, ast, (_ref = replacements && replacements[placeholder.name]) != null ? _ref : null);\n    } catch (e) {\n      e.message = `@babel/template placeholder \"${placeholder.name}\": ${e.message}`;\n      throw e;\n    }\n  });\n  return ast;\n}\nfunction applyReplacement(placeholder, ast, replacement) {\n  if (placeholder.isDuplicate) {\n    if (Array.isArray(replacement)) {\n      replacement = replacement.map(node => cloneNode(node));\n    } else if (typeof replacement === \"object\") {\n      replacement = cloneNode(replacement);\n    }\n  }\n  const {\n    parent,\n    key,\n    index\n  } = placeholder.resolve(ast);\n  if (placeholder.type === \"string\") {\n    if (typeof replacement === \"string\") {\n      replacement = stringLiteral(replacement);\n    }\n    if (!replacement || !isStringLiteral(replacement)) {\n      throw new Error(\"Expected string substitution\");\n    }\n  } else if (placeholder.type === \"statement\") {\n    if (index === undefined) {\n      if (!replacement) {\n        replacement = emptyStatement();\n      } else if (Array.isArray(replacement)) {\n        replacement = blockStatement(replacement);\n      } else if (typeof replacement === \"string\") {\n        replacement = expressionStatement(identifier(replacement));\n      } else if (!isStatement(replacement)) {\n        replacement = expressionStatement(replacement);\n      }\n    } else {\n      if (replacement && !Array.isArray(replacement)) {\n        if (typeof replacement === \"string\") {\n          replacement = identifier(replacement);\n        }\n        if (!isStatement(replacement)) {\n          replacement = expressionStatement(replacement);\n        }\n      }\n    }\n  } else if (placeholder.type === \"param\") {\n    if (typeof replacement === \"string\") {\n      replacement = identifier(replacement);\n    }\n    if (index === undefined) throw new Error(\"Assertion failure.\");\n  } else {\n    if (typeof replacement === \"string\") {\n      replacement = identifier(replacement);\n    }\n    if (Array.isArray(replacement)) {\n      throw new Error(\"Cannot replace single expression with an array.\");\n    }\n  }\n  function set(parent, key, value) {\n    const node = parent[key];\n    parent[key] = value;\n    if (node.type === \"Identifier\" || node.type === \"Placeholder\") {\n      if (node.typeAnnotation) {\n        value.typeAnnotation = node.typeAnnotation;\n      }\n      if (node.optional) {\n        value.optional = node.optional;\n      }\n      if (node.decorators) {\n        value.decorators = node.decorators;\n      }\n    }\n  }\n  if (index === undefined) {\n    validate(parent, key, replacement);\n    set(parent, key, replacement);\n  } else {\n    const items = parent[key].slice();\n    if (placeholder.type === \"statement\" || placeholder.type === \"param\") {\n      if (replacement == null) {\n        items.splice(index, 1);\n      } else if (Array.isArray(replacement)) {\n        items.splice(index, 1, ...replacement);\n      } else {\n        set(items, index, replacement);\n      }\n    } else {\n      set(items, index, replacement);\n    }\n    validate(parent, key, items);\n    parent[key] = items;\n  }\n}\n\n//# sourceMappingURL=populate.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGJhYmVsL3RlbXBsYXRlL2xpYi9wb3B1bGF0ZS5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYiw4Q0FBNkM7QUFDN0M7QUFDQSxDQUFDLEVBQUM7QUFDRixrQkFBZTtBQUNmLFNBQVMsbUJBQU8sQ0FBQyxvRUFBYztBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2REFBNkQsZ0JBQWdCO0FBQzdFO0FBQ0EsZ0JBQWdCLDZEQUE2RCxnQkFBZ0I7QUFDN0YsZ0JBQWdCLHdCQUF3QixnQkFBZ0IsSUFBSTtBQUM1RDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsaURBQWlELElBQUk7QUFDckQ7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTixrREFBa0QsaUJBQWlCLEtBQUssVUFBVTtBQUNsRjtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQSxRQUFRO0FBQ1I7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9yZXBvLXZpc3VhbGl6ZXIvLi9ub2RlX21vZHVsZXMvQGJhYmVsL3RlbXBsYXRlL2xpYi9wb3B1bGF0ZS5qcz8yZjBjIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5kZWZhdWx0ID0gcG9wdWxhdGVQbGFjZWhvbGRlcnM7XG52YXIgX3QgPSByZXF1aXJlKFwiQGJhYmVsL3R5cGVzXCIpO1xuY29uc3Qge1xuICBibG9ja1N0YXRlbWVudCxcbiAgY2xvbmVOb2RlLFxuICBlbXB0eVN0YXRlbWVudCxcbiAgZXhwcmVzc2lvblN0YXRlbWVudCxcbiAgaWRlbnRpZmllcixcbiAgaXNTdGF0ZW1lbnQsXG4gIGlzU3RyaW5nTGl0ZXJhbCxcbiAgc3RyaW5nTGl0ZXJhbCxcbiAgdmFsaWRhdGVcbn0gPSBfdDtcbmZ1bmN0aW9uIHBvcHVsYXRlUGxhY2Vob2xkZXJzKG1ldGFkYXRhLCByZXBsYWNlbWVudHMpIHtcbiAgY29uc3QgYXN0ID0gY2xvbmVOb2RlKG1ldGFkYXRhLmFzdCk7XG4gIGlmIChyZXBsYWNlbWVudHMpIHtcbiAgICBtZXRhZGF0YS5wbGFjZWhvbGRlcnMuZm9yRWFjaChwbGFjZWhvbGRlciA9PiB7XG4gICAgICBpZiAoIWhhc093blByb3BlcnR5LmNhbGwocmVwbGFjZW1lbnRzLCBwbGFjZWhvbGRlci5uYW1lKSkge1xuICAgICAgICBjb25zdCBwbGFjZWhvbGRlck5hbWUgPSBwbGFjZWhvbGRlci5uYW1lO1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEVycm9yOiBObyBzdWJzdGl0dXRpb24gZ2l2ZW4gZm9yIFwiJHtwbGFjZWhvbGRlck5hbWV9XCIuIElmIHRoaXMgaXMgbm90IG1lYW50IHRvIGJlIGFcbiAgICAgICAgICAgIHBsYWNlaG9sZGVyIHlvdSBtYXkgd2FudCB0byBjb25zaWRlciBwYXNzaW5nIG9uZSBvZiB0aGUgZm9sbG93aW5nIG9wdGlvbnMgdG8gQGJhYmVsL3RlbXBsYXRlOlxuICAgICAgICAgICAgLSB7IHBsYWNlaG9sZGVyUGF0dGVybjogZmFsc2UsIHBsYWNlaG9sZGVyV2hpdGVsaXN0OiBuZXcgU2V0KFsnJHtwbGFjZWhvbGRlck5hbWV9J10pfVxuICAgICAgICAgICAgLSB7IHBsYWNlaG9sZGVyUGF0dGVybjogL14ke3BsYWNlaG9sZGVyTmFtZX0kLyB9YCk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgT2JqZWN0LmtleXMocmVwbGFjZW1lbnRzKS5mb3JFYWNoKGtleSA9PiB7XG4gICAgICBpZiAoIW1ldGFkYXRhLnBsYWNlaG9sZGVyTmFtZXMuaGFzKGtleSkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBVbmtub3duIHN1YnN0aXR1dGlvbiBcIiR7a2V5fVwiIGdpdmVuYCk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbiAgbWV0YWRhdGEucGxhY2Vob2xkZXJzLnNsaWNlKCkucmV2ZXJzZSgpLmZvckVhY2gocGxhY2Vob2xkZXIgPT4ge1xuICAgIHRyeSB7XG4gICAgICB2YXIgX3JlZjtcbiAgICAgIGFwcGx5UmVwbGFjZW1lbnQocGxhY2Vob2xkZXIsIGFzdCwgKF9yZWYgPSByZXBsYWNlbWVudHMgJiYgcmVwbGFjZW1lbnRzW3BsYWNlaG9sZGVyLm5hbWVdKSAhPSBudWxsID8gX3JlZiA6IG51bGwpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIGUubWVzc2FnZSA9IGBAYmFiZWwvdGVtcGxhdGUgcGxhY2Vob2xkZXIgXCIke3BsYWNlaG9sZGVyLm5hbWV9XCI6ICR7ZS5tZXNzYWdlfWA7XG4gICAgICB0aHJvdyBlO1xuICAgIH1cbiAgfSk7XG4gIHJldHVybiBhc3Q7XG59XG5mdW5jdGlvbiBhcHBseVJlcGxhY2VtZW50KHBsYWNlaG9sZGVyLCBhc3QsIHJlcGxhY2VtZW50KSB7XG4gIGlmIChwbGFjZWhvbGRlci5pc0R1cGxpY2F0ZSkge1xuICAgIGlmIChBcnJheS5pc0FycmF5KHJlcGxhY2VtZW50KSkge1xuICAgICAgcmVwbGFjZW1lbnQgPSByZXBsYWNlbWVudC5tYXAobm9kZSA9PiBjbG9uZU5vZGUobm9kZSkpO1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIHJlcGxhY2VtZW50ID09PSBcIm9iamVjdFwiKSB7XG4gICAgICByZXBsYWNlbWVudCA9IGNsb25lTm9kZShyZXBsYWNlbWVudCk7XG4gICAgfVxuICB9XG4gIGNvbnN0IHtcbiAgICBwYXJlbnQsXG4gICAga2V5LFxuICAgIGluZGV4XG4gIH0gPSBwbGFjZWhvbGRlci5yZXNvbHZlKGFzdCk7XG4gIGlmIChwbGFjZWhvbGRlci50eXBlID09PSBcInN0cmluZ1wiKSB7XG4gICAgaWYgKHR5cGVvZiByZXBsYWNlbWVudCA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgcmVwbGFjZW1lbnQgPSBzdHJpbmdMaXRlcmFsKHJlcGxhY2VtZW50KTtcbiAgICB9XG4gICAgaWYgKCFyZXBsYWNlbWVudCB8fCAhaXNTdHJpbmdMaXRlcmFsKHJlcGxhY2VtZW50KSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRXhwZWN0ZWQgc3RyaW5nIHN1YnN0aXR1dGlvblwiKTtcbiAgICB9XG4gIH0gZWxzZSBpZiAocGxhY2Vob2xkZXIudHlwZSA9PT0gXCJzdGF0ZW1lbnRcIikge1xuICAgIGlmIChpbmRleCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBpZiAoIXJlcGxhY2VtZW50KSB7XG4gICAgICAgIHJlcGxhY2VtZW50ID0gZW1wdHlTdGF0ZW1lbnQoKTtcbiAgICAgIH0gZWxzZSBpZiAoQXJyYXkuaXNBcnJheShyZXBsYWNlbWVudCkpIHtcbiAgICAgICAgcmVwbGFjZW1lbnQgPSBibG9ja1N0YXRlbWVudChyZXBsYWNlbWVudCk7XG4gICAgICB9IGVsc2UgaWYgKHR5cGVvZiByZXBsYWNlbWVudCA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICByZXBsYWNlbWVudCA9IGV4cHJlc3Npb25TdGF0ZW1lbnQoaWRlbnRpZmllcihyZXBsYWNlbWVudCkpO1xuICAgICAgfSBlbHNlIGlmICghaXNTdGF0ZW1lbnQocmVwbGFjZW1lbnQpKSB7XG4gICAgICAgIHJlcGxhY2VtZW50ID0gZXhwcmVzc2lvblN0YXRlbWVudChyZXBsYWNlbWVudCk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChyZXBsYWNlbWVudCAmJiAhQXJyYXkuaXNBcnJheShyZXBsYWNlbWVudCkpIHtcbiAgICAgICAgaWYgKHR5cGVvZiByZXBsYWNlbWVudCA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgIHJlcGxhY2VtZW50ID0gaWRlbnRpZmllcihyZXBsYWNlbWVudCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFpc1N0YXRlbWVudChyZXBsYWNlbWVudCkpIHtcbiAgICAgICAgICByZXBsYWNlbWVudCA9IGV4cHJlc3Npb25TdGF0ZW1lbnQocmVwbGFjZW1lbnQpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9IGVsc2UgaWYgKHBsYWNlaG9sZGVyLnR5cGUgPT09IFwicGFyYW1cIikge1xuICAgIGlmICh0eXBlb2YgcmVwbGFjZW1lbnQgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgIHJlcGxhY2VtZW50ID0gaWRlbnRpZmllcihyZXBsYWNlbWVudCk7XG4gICAgfVxuICAgIGlmIChpbmRleCA9PT0gdW5kZWZpbmVkKSB0aHJvdyBuZXcgRXJyb3IoXCJBc3NlcnRpb24gZmFpbHVyZS5cIik7XG4gIH0gZWxzZSB7XG4gICAgaWYgKHR5cGVvZiByZXBsYWNlbWVudCA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgcmVwbGFjZW1lbnQgPSBpZGVudGlmaWVyKHJlcGxhY2VtZW50KTtcbiAgICB9XG4gICAgaWYgKEFycmF5LmlzQXJyYXkocmVwbGFjZW1lbnQpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3QgcmVwbGFjZSBzaW5nbGUgZXhwcmVzc2lvbiB3aXRoIGFuIGFycmF5LlwiKTtcbiAgICB9XG4gIH1cbiAgZnVuY3Rpb24gc2V0KHBhcmVudCwga2V5LCB2YWx1ZSkge1xuICAgIGNvbnN0IG5vZGUgPSBwYXJlbnRba2V5XTtcbiAgICBwYXJlbnRba2V5XSA9IHZhbHVlO1xuICAgIGlmIChub2RlLnR5cGUgPT09IFwiSWRlbnRpZmllclwiIHx8IG5vZGUudHlwZSA9PT0gXCJQbGFjZWhvbGRlclwiKSB7XG4gICAgICBpZiAobm9kZS50eXBlQW5ub3RhdGlvbikge1xuICAgICAgICB2YWx1ZS50eXBlQW5ub3RhdGlvbiA9IG5vZGUudHlwZUFubm90YXRpb247XG4gICAgICB9XG4gICAgICBpZiAobm9kZS5vcHRpb25hbCkge1xuICAgICAgICB2YWx1ZS5vcHRpb25hbCA9IG5vZGUub3B0aW9uYWw7XG4gICAgICB9XG4gICAgICBpZiAobm9kZS5kZWNvcmF0b3JzKSB7XG4gICAgICAgIHZhbHVlLmRlY29yYXRvcnMgPSBub2RlLmRlY29yYXRvcnM7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGlmIChpbmRleCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgdmFsaWRhdGUocGFyZW50LCBrZXksIHJlcGxhY2VtZW50KTtcbiAgICBzZXQocGFyZW50LCBrZXksIHJlcGxhY2VtZW50KTtcbiAgfSBlbHNlIHtcbiAgICBjb25zdCBpdGVtcyA9IHBhcmVudFtrZXldLnNsaWNlKCk7XG4gICAgaWYgKHBsYWNlaG9sZGVyLnR5cGUgPT09IFwic3RhdGVtZW50XCIgfHwgcGxhY2Vob2xkZXIudHlwZSA9PT0gXCJwYXJhbVwiKSB7XG4gICAgICBpZiAocmVwbGFjZW1lbnQgPT0gbnVsbCkge1xuICAgICAgICBpdGVtcy5zcGxpY2UoaW5kZXgsIDEpO1xuICAgICAgfSBlbHNlIGlmIChBcnJheS5pc0FycmF5KHJlcGxhY2VtZW50KSkge1xuICAgICAgICBpdGVtcy5zcGxpY2UoaW5kZXgsIDEsIC4uLnJlcGxhY2VtZW50KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHNldChpdGVtcywgaW5kZXgsIHJlcGxhY2VtZW50KTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgc2V0KGl0ZW1zLCBpbmRleCwgcmVwbGFjZW1lbnQpO1xuICAgIH1cbiAgICB2YWxpZGF0ZShwYXJlbnQsIGtleSwgaXRlbXMpO1xuICAgIHBhcmVudFtrZXldID0gaXRlbXM7XG4gIH1cbn1cblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cG9wdWxhdGUuanMubWFwXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@babel/template/lib/populate.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@babel/template/lib/string.js":
/*!****************************************************!*\
  !*** ./node_modules/@babel/template/lib/string.js ***!
  \****************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports[\"default\"] = stringTemplate;\nvar _options = __webpack_require__(/*! ./options.js */ \"(ssr)/./node_modules/@babel/template/lib/options.js\");\nvar _parse = __webpack_require__(/*! ./parse.js */ \"(ssr)/./node_modules/@babel/template/lib/parse.js\");\nvar _populate = __webpack_require__(/*! ./populate.js */ \"(ssr)/./node_modules/@babel/template/lib/populate.js\");\nfunction stringTemplate(formatter, code, opts) {\n  code = formatter.code(code);\n  let metadata;\n  return arg => {\n    const replacements = (0, _options.normalizeReplacements)(arg);\n    if (!metadata) metadata = (0, _parse.default)(formatter, code, opts);\n    return formatter.unwrap((0, _populate.default)(metadata, replacements));\n  };\n}\n\n//# sourceMappingURL=string.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGJhYmVsL3RlbXBsYXRlL2xpYi9zdHJpbmcuanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWIsOENBQTZDO0FBQzdDO0FBQ0EsQ0FBQyxFQUFDO0FBQ0Ysa0JBQWU7QUFDZixlQUFlLG1CQUFPLENBQUMseUVBQWM7QUFDckMsYUFBYSxtQkFBTyxDQUFDLHFFQUFZO0FBQ2pDLGdCQUFnQixtQkFBTyxDQUFDLDJFQUFlO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSIsInNvdXJjZXMiOlsid2VicGFjazovL3JlcG8tdmlzdWFsaXplci8uL25vZGVfbW9kdWxlcy9AYmFiZWwvdGVtcGxhdGUvbGliL3N0cmluZy5qcz9jNjk4Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5kZWZhdWx0ID0gc3RyaW5nVGVtcGxhdGU7XG52YXIgX29wdGlvbnMgPSByZXF1aXJlKFwiLi9vcHRpb25zLmpzXCIpO1xudmFyIF9wYXJzZSA9IHJlcXVpcmUoXCIuL3BhcnNlLmpzXCIpO1xudmFyIF9wb3B1bGF0ZSA9IHJlcXVpcmUoXCIuL3BvcHVsYXRlLmpzXCIpO1xuZnVuY3Rpb24gc3RyaW5nVGVtcGxhdGUoZm9ybWF0dGVyLCBjb2RlLCBvcHRzKSB7XG4gIGNvZGUgPSBmb3JtYXR0ZXIuY29kZShjb2RlKTtcbiAgbGV0IG1ldGFkYXRhO1xuICByZXR1cm4gYXJnID0+IHtcbiAgICBjb25zdCByZXBsYWNlbWVudHMgPSAoMCwgX29wdGlvbnMubm9ybWFsaXplUmVwbGFjZW1lbnRzKShhcmcpO1xuICAgIGlmICghbWV0YWRhdGEpIG1ldGFkYXRhID0gKDAsIF9wYXJzZS5kZWZhdWx0KShmb3JtYXR0ZXIsIGNvZGUsIG9wdHMpO1xuICAgIHJldHVybiBmb3JtYXR0ZXIudW53cmFwKCgwLCBfcG9wdWxhdGUuZGVmYXVsdCkobWV0YWRhdGEsIHJlcGxhY2VtZW50cykpO1xuICB9O1xufVxuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1zdHJpbmcuanMubWFwXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@babel/template/lib/string.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@babel/traverse/lib/cache.js":
/*!***************************************************!*\
  !*** ./node_modules/@babel/traverse/lib/cache.js ***!
  \***************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports.clear = clear;\nexports.clearPath = clearPath;\nexports.clearScope = clearScope;\nexports.getCachedPaths = getCachedPaths;\nexports.getOrCreateCachedPaths = getOrCreateCachedPaths;\nexports.scope = exports.path = void 0;\nlet pathsCache = exports.path = new WeakMap();\nlet scope = exports.scope = new WeakMap();\nfunction clear() {\n  clearPath();\n  clearScope();\n}\nfunction clearPath() {\n  exports.path = pathsCache = new WeakMap();\n}\nfunction clearScope() {\n  exports.scope = scope = new WeakMap();\n}\nfunction getCachedPaths(path) {\n  const {\n    parent,\n    parentPath\n  } = path;\n  return pathsCache.get(parent);\n}\nfunction getOrCreateCachedPaths(node, parentPath) {\n  let paths = pathsCache.get(node);\n  if (!paths) pathsCache.set(node, paths = new Map());\n  return paths;\n}\n\n//# sourceMappingURL=cache.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGJhYmVsL3RyYXZlcnNlL2xpYi9jYWNoZS5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYiw4Q0FBNkM7QUFDN0M7QUFDQSxDQUFDLEVBQUM7QUFDRixhQUFhO0FBQ2IsaUJBQWlCO0FBQ2pCLGtCQUFrQjtBQUNsQixzQkFBc0I7QUFDdEIsOEJBQThCO0FBQzlCLGFBQWEsR0FBRyxZQUFZO0FBQzVCLGlCQUFpQixZQUFZO0FBQzdCLFlBQVksYUFBYTtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRSxZQUFZO0FBQ2Q7QUFDQTtBQUNBLEVBQUUsYUFBYTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9yZXBvLXZpc3VhbGl6ZXIvLi9ub2RlX21vZHVsZXMvQGJhYmVsL3RyYXZlcnNlL2xpYi9jYWNoZS5qcz9mMmU1Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5jbGVhciA9IGNsZWFyO1xuZXhwb3J0cy5jbGVhclBhdGggPSBjbGVhclBhdGg7XG5leHBvcnRzLmNsZWFyU2NvcGUgPSBjbGVhclNjb3BlO1xuZXhwb3J0cy5nZXRDYWNoZWRQYXRocyA9IGdldENhY2hlZFBhdGhzO1xuZXhwb3J0cy5nZXRPckNyZWF0ZUNhY2hlZFBhdGhzID0gZ2V0T3JDcmVhdGVDYWNoZWRQYXRocztcbmV4cG9ydHMuc2NvcGUgPSBleHBvcnRzLnBhdGggPSB2b2lkIDA7XG5sZXQgcGF0aHNDYWNoZSA9IGV4cG9ydHMucGF0aCA9IG5ldyBXZWFrTWFwKCk7XG5sZXQgc2NvcGUgPSBleHBvcnRzLnNjb3BlID0gbmV3IFdlYWtNYXAoKTtcbmZ1bmN0aW9uIGNsZWFyKCkge1xuICBjbGVhclBhdGgoKTtcbiAgY2xlYXJTY29wZSgpO1xufVxuZnVuY3Rpb24gY2xlYXJQYXRoKCkge1xuICBleHBvcnRzLnBhdGggPSBwYXRoc0NhY2hlID0gbmV3IFdlYWtNYXAoKTtcbn1cbmZ1bmN0aW9uIGNsZWFyU2NvcGUoKSB7XG4gIGV4cG9ydHMuc2NvcGUgPSBzY29wZSA9IG5ldyBXZWFrTWFwKCk7XG59XG5mdW5jdGlvbiBnZXRDYWNoZWRQYXRocyhwYXRoKSB7XG4gIGNvbnN0IHtcbiAgICBwYXJlbnQsXG4gICAgcGFyZW50UGF0aFxuICB9ID0gcGF0aDtcbiAgcmV0dXJuIHBhdGhzQ2FjaGUuZ2V0KHBhcmVudCk7XG59XG5mdW5jdGlvbiBnZXRPckNyZWF0ZUNhY2hlZFBhdGhzKG5vZGUsIHBhcmVudFBhdGgpIHtcbiAgbGV0IHBhdGhzID0gcGF0aHNDYWNoZS5nZXQobm9kZSk7XG4gIGlmICghcGF0aHMpIHBhdGhzQ2FjaGUuc2V0KG5vZGUsIHBhdGhzID0gbmV3IE1hcCgpKTtcbiAgcmV0dXJuIHBhdGhzO1xufVxuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1jYWNoZS5qcy5tYXBcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@babel/traverse/lib/cache.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@babel/traverse/lib/context.js":
/*!*****************************************************!*\
  !*** ./node_modules/@babel/traverse/lib/context.js ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports[\"default\"] = void 0;\nvar _index = __webpack_require__(/*! ./path/index.js */ \"(ssr)/./node_modules/@babel/traverse/lib/path/index.js\");\nvar _t = __webpack_require__(/*! @babel/types */ \"(ssr)/./node_modules/@babel/types/lib/index.js\");\nvar _context = __webpack_require__(/*! ./path/context.js */ \"(ssr)/./node_modules/@babel/traverse/lib/path/context.js\");\nconst {\n  VISITOR_KEYS\n} = _t;\nclass TraversalContext {\n  constructor(scope, opts, state, parentPath) {\n    this.queue = null;\n    this.priorityQueue = null;\n    this.parentPath = parentPath;\n    this.scope = scope;\n    this.state = state;\n    this.opts = opts;\n  }\n  shouldVisit(node) {\n    const opts = this.opts;\n    if (opts.enter || opts.exit) return true;\n    if (opts[node.type]) return true;\n    const keys = VISITOR_KEYS[node.type];\n    if (!(keys != null && keys.length)) return false;\n    for (const key of keys) {\n      if (node[key]) {\n        return true;\n      }\n    }\n    return false;\n  }\n  create(node, container, key, listKey) {\n    return _index.default.get({\n      parentPath: this.parentPath,\n      parent: node,\n      container,\n      key: key,\n      listKey\n    });\n  }\n  maybeQueue(path, notPriority) {\n    if (this.queue) {\n      if (notPriority) {\n        this.queue.push(path);\n      } else {\n        this.priorityQueue.push(path);\n      }\n    }\n  }\n  visitMultiple(container, parent, listKey) {\n    if (container.length === 0) return false;\n    const queue = [];\n    for (let key = 0; key < container.length; key++) {\n      const node = container[key];\n      if (node && this.shouldVisit(node)) {\n        queue.push(this.create(parent, container, key, listKey));\n      }\n    }\n    return this.visitQueue(queue);\n  }\n  visitSingle(node, key) {\n    if (this.shouldVisit(node[key])) {\n      return this.visitQueue([this.create(node, node, key)]);\n    } else {\n      return false;\n    }\n  }\n  visitQueue(queue) {\n    this.queue = queue;\n    this.priorityQueue = [];\n    const visited = new WeakSet();\n    let stop = false;\n    let visitIndex = 0;\n    for (; visitIndex < queue.length;) {\n      const path = queue[visitIndex];\n      visitIndex++;\n      _context.resync.call(path);\n      if (path.contexts.length === 0 || path.contexts[path.contexts.length - 1] !== this) {\n        _context.pushContext.call(path, this);\n      }\n      if (path.key === null) continue;\n      const {\n        node\n      } = path;\n      if (visited.has(node)) continue;\n      if (node) visited.add(node);\n      if (path.visit()) {\n        stop = true;\n        break;\n      }\n      if (this.priorityQueue.length) {\n        stop = this.visitQueue(this.priorityQueue);\n        this.priorityQueue = [];\n        this.queue = queue;\n        if (stop) break;\n      }\n    }\n    for (let i = 0; i < visitIndex; i++) {\n      _context.popContext.call(queue[i]);\n    }\n    this.queue = null;\n    return stop;\n  }\n  visit(node, key) {\n    const nodes = node[key];\n    if (!nodes) return false;\n    if (Array.isArray(nodes)) {\n      return this.visitMultiple(nodes, node, key);\n    } else {\n      return this.visitSingle(node, key);\n    }\n  }\n}\nexports[\"default\"] = TraversalContext;\n\n//# sourceMappingURL=context.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGJhYmVsL3RyYXZlcnNlL2xpYi9jb250ZXh0LmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViLDhDQUE2QztBQUM3QztBQUNBLENBQUMsRUFBQztBQUNGLGtCQUFlO0FBQ2YsYUFBYSxtQkFBTyxDQUFDLCtFQUFpQjtBQUN0QyxTQUFTLG1CQUFPLENBQUMsb0VBQWM7QUFDL0IsZUFBZSxtQkFBTyxDQUFDLG1GQUFtQjtBQUMxQztBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQix3QkFBd0I7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVywwQkFBMEI7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGdCQUFnQjtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFlOztBQUVmIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcmVwby12aXN1YWxpemVyLy4vbm9kZV9tb2R1bGVzL0BiYWJlbC90cmF2ZXJzZS9saWIvY29udGV4dC5qcz8xYWNhIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5kZWZhdWx0ID0gdm9pZCAwO1xudmFyIF9pbmRleCA9IHJlcXVpcmUoXCIuL3BhdGgvaW5kZXguanNcIik7XG52YXIgX3QgPSByZXF1aXJlKFwiQGJhYmVsL3R5cGVzXCIpO1xudmFyIF9jb250ZXh0ID0gcmVxdWlyZShcIi4vcGF0aC9jb250ZXh0LmpzXCIpO1xuY29uc3Qge1xuICBWSVNJVE9SX0tFWVNcbn0gPSBfdDtcbmNsYXNzIFRyYXZlcnNhbENvbnRleHQge1xuICBjb25zdHJ1Y3RvcihzY29wZSwgb3B0cywgc3RhdGUsIHBhcmVudFBhdGgpIHtcbiAgICB0aGlzLnF1ZXVlID0gbnVsbDtcbiAgICB0aGlzLnByaW9yaXR5UXVldWUgPSBudWxsO1xuICAgIHRoaXMucGFyZW50UGF0aCA9IHBhcmVudFBhdGg7XG4gICAgdGhpcy5zY29wZSA9IHNjb3BlO1xuICAgIHRoaXMuc3RhdGUgPSBzdGF0ZTtcbiAgICB0aGlzLm9wdHMgPSBvcHRzO1xuICB9XG4gIHNob3VsZFZpc2l0KG5vZGUpIHtcbiAgICBjb25zdCBvcHRzID0gdGhpcy5vcHRzO1xuICAgIGlmIChvcHRzLmVudGVyIHx8IG9wdHMuZXhpdCkgcmV0dXJuIHRydWU7XG4gICAgaWYgKG9wdHNbbm9kZS50eXBlXSkgcmV0dXJuIHRydWU7XG4gICAgY29uc3Qga2V5cyA9IFZJU0lUT1JfS0VZU1tub2RlLnR5cGVdO1xuICAgIGlmICghKGtleXMgIT0gbnVsbCAmJiBrZXlzLmxlbmd0aCkpIHJldHVybiBmYWxzZTtcbiAgICBmb3IgKGNvbnN0IGtleSBvZiBrZXlzKSB7XG4gICAgICBpZiAobm9kZVtrZXldKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgY3JlYXRlKG5vZGUsIGNvbnRhaW5lciwga2V5LCBsaXN0S2V5KSB7XG4gICAgcmV0dXJuIF9pbmRleC5kZWZhdWx0LmdldCh7XG4gICAgICBwYXJlbnRQYXRoOiB0aGlzLnBhcmVudFBhdGgsXG4gICAgICBwYXJlbnQ6IG5vZGUsXG4gICAgICBjb250YWluZXIsXG4gICAgICBrZXk6IGtleSxcbiAgICAgIGxpc3RLZXlcbiAgICB9KTtcbiAgfVxuICBtYXliZVF1ZXVlKHBhdGgsIG5vdFByaW9yaXR5KSB7XG4gICAgaWYgKHRoaXMucXVldWUpIHtcbiAgICAgIGlmIChub3RQcmlvcml0eSkge1xuICAgICAgICB0aGlzLnF1ZXVlLnB1c2gocGF0aCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLnByaW9yaXR5UXVldWUucHVzaChwYXRoKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgdmlzaXRNdWx0aXBsZShjb250YWluZXIsIHBhcmVudCwgbGlzdEtleSkge1xuICAgIGlmIChjb250YWluZXIubGVuZ3RoID09PSAwKSByZXR1cm4gZmFsc2U7XG4gICAgY29uc3QgcXVldWUgPSBbXTtcbiAgICBmb3IgKGxldCBrZXkgPSAwOyBrZXkgPCBjb250YWluZXIubGVuZ3RoOyBrZXkrKykge1xuICAgICAgY29uc3Qgbm9kZSA9IGNvbnRhaW5lcltrZXldO1xuICAgICAgaWYgKG5vZGUgJiYgdGhpcy5zaG91bGRWaXNpdChub2RlKSkge1xuICAgICAgICBxdWV1ZS5wdXNoKHRoaXMuY3JlYXRlKHBhcmVudCwgY29udGFpbmVyLCBrZXksIGxpc3RLZXkpKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRoaXMudmlzaXRRdWV1ZShxdWV1ZSk7XG4gIH1cbiAgdmlzaXRTaW5nbGUobm9kZSwga2V5KSB7XG4gICAgaWYgKHRoaXMuc2hvdWxkVmlzaXQobm9kZVtrZXldKSkge1xuICAgICAgcmV0dXJuIHRoaXMudmlzaXRRdWV1ZShbdGhpcy5jcmVhdGUobm9kZSwgbm9kZSwga2V5KV0pO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG4gIHZpc2l0UXVldWUocXVldWUpIHtcbiAgICB0aGlzLnF1ZXVlID0gcXVldWU7XG4gICAgdGhpcy5wcmlvcml0eVF1ZXVlID0gW107XG4gICAgY29uc3QgdmlzaXRlZCA9IG5ldyBXZWFrU2V0KCk7XG4gICAgbGV0IHN0b3AgPSBmYWxzZTtcbiAgICBsZXQgdmlzaXRJbmRleCA9IDA7XG4gICAgZm9yICg7IHZpc2l0SW5kZXggPCBxdWV1ZS5sZW5ndGg7KSB7XG4gICAgICBjb25zdCBwYXRoID0gcXVldWVbdmlzaXRJbmRleF07XG4gICAgICB2aXNpdEluZGV4Kys7XG4gICAgICBfY29udGV4dC5yZXN5bmMuY2FsbChwYXRoKTtcbiAgICAgIGlmIChwYXRoLmNvbnRleHRzLmxlbmd0aCA9PT0gMCB8fCBwYXRoLmNvbnRleHRzW3BhdGguY29udGV4dHMubGVuZ3RoIC0gMV0gIT09IHRoaXMpIHtcbiAgICAgICAgX2NvbnRleHQucHVzaENvbnRleHQuY2FsbChwYXRoLCB0aGlzKTtcbiAgICAgIH1cbiAgICAgIGlmIChwYXRoLmtleSA9PT0gbnVsbCkgY29udGludWU7XG4gICAgICBjb25zdCB7XG4gICAgICAgIG5vZGVcbiAgICAgIH0gPSBwYXRoO1xuICAgICAgaWYgKHZpc2l0ZWQuaGFzKG5vZGUpKSBjb250aW51ZTtcbiAgICAgIGlmIChub2RlKSB2aXNpdGVkLmFkZChub2RlKTtcbiAgICAgIGlmIChwYXRoLnZpc2l0KCkpIHtcbiAgICAgICAgc3RvcCA9IHRydWU7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMucHJpb3JpdHlRdWV1ZS5sZW5ndGgpIHtcbiAgICAgICAgc3RvcCA9IHRoaXMudmlzaXRRdWV1ZSh0aGlzLnByaW9yaXR5UXVldWUpO1xuICAgICAgICB0aGlzLnByaW9yaXR5UXVldWUgPSBbXTtcbiAgICAgICAgdGhpcy5xdWV1ZSA9IHF1ZXVlO1xuICAgICAgICBpZiAoc3RvcCkgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdmlzaXRJbmRleDsgaSsrKSB7XG4gICAgICBfY29udGV4dC5wb3BDb250ZXh0LmNhbGwocXVldWVbaV0pO1xuICAgIH1cbiAgICB0aGlzLnF1ZXVlID0gbnVsbDtcbiAgICByZXR1cm4gc3RvcDtcbiAgfVxuICB2aXNpdChub2RlLCBrZXkpIHtcbiAgICBjb25zdCBub2RlcyA9IG5vZGVba2V5XTtcbiAgICBpZiAoIW5vZGVzKSByZXR1cm4gZmFsc2U7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkobm9kZXMpKSB7XG4gICAgICByZXR1cm4gdGhpcy52aXNpdE11bHRpcGxlKG5vZGVzLCBub2RlLCBrZXkpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gdGhpcy52aXNpdFNpbmdsZShub2RlLCBrZXkpO1xuICAgIH1cbiAgfVxufVxuZXhwb3J0cy5kZWZhdWx0ID0gVHJhdmVyc2FsQ29udGV4dDtcblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y29udGV4dC5qcy5tYXBcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@babel/traverse/lib/context.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@babel/traverse/lib/hub.js":
/*!*************************************************!*\
  !*** ./node_modules/@babel/traverse/lib/hub.js ***!
  \*************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports[\"default\"] = void 0;\nclass Hub {\n  getCode() {}\n  getScope() {}\n  addHelper() {\n    throw new Error(\"Helpers are not supported by the default hub.\");\n  }\n  buildError(node, msg, Error = TypeError) {\n    return new Error(msg);\n  }\n}\nexports[\"default\"] = Hub;\n\n//# sourceMappingURL=hub.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGJhYmVsL3RyYXZlcnNlL2xpYi9odWIuanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWIsOENBQTZDO0FBQzdDO0FBQ0EsQ0FBQyxFQUFDO0FBQ0Ysa0JBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFlOztBQUVmIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcmVwby12aXN1YWxpemVyLy4vbm9kZV9tb2R1bGVzL0BiYWJlbC90cmF2ZXJzZS9saWIvaHViLmpzPzBiMDEiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLmRlZmF1bHQgPSB2b2lkIDA7XG5jbGFzcyBIdWIge1xuICBnZXRDb2RlKCkge31cbiAgZ2V0U2NvcGUoKSB7fVxuICBhZGRIZWxwZXIoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiSGVscGVycyBhcmUgbm90IHN1cHBvcnRlZCBieSB0aGUgZGVmYXVsdCBodWIuXCIpO1xuICB9XG4gIGJ1aWxkRXJyb3Iobm9kZSwgbXNnLCBFcnJvciA9IFR5cGVFcnJvcikge1xuICAgIHJldHVybiBuZXcgRXJyb3IobXNnKTtcbiAgfVxufVxuZXhwb3J0cy5kZWZhdWx0ID0gSHViO1xuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1odWIuanMubWFwXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@babel/traverse/lib/hub.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@babel/traverse/lib/index.js":
/*!***************************************************!*\
  !*** ./node_modules/@babel/traverse/lib/index.js ***!
  \***************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nObject.defineProperty(exports, \"Hub\", ({\n  enumerable: true,\n  get: function () {\n    return _hub.default;\n  }\n}));\nObject.defineProperty(exports, \"NodePath\", ({\n  enumerable: true,\n  get: function () {\n    return _index.default;\n  }\n}));\nObject.defineProperty(exports, \"Scope\", ({\n  enumerable: true,\n  get: function () {\n    return _index2.default;\n  }\n}));\nexports.visitors = exports[\"default\"] = void 0;\n__webpack_require__(/*! ./path/context.js */ \"(ssr)/./node_modules/@babel/traverse/lib/path/context.js\");\nvar visitors = __webpack_require__(/*! ./visitors.js */ \"(ssr)/./node_modules/@babel/traverse/lib/visitors.js\");\nexports.visitors = visitors;\nvar _t = __webpack_require__(/*! @babel/types */ \"(ssr)/./node_modules/@babel/types/lib/index.js\");\nvar cache = __webpack_require__(/*! ./cache.js */ \"(ssr)/./node_modules/@babel/traverse/lib/cache.js\");\nvar _traverseNode = __webpack_require__(/*! ./traverse-node.js */ \"(ssr)/./node_modules/@babel/traverse/lib/traverse-node.js\");\nvar _index = __webpack_require__(/*! ./path/index.js */ \"(ssr)/./node_modules/@babel/traverse/lib/path/index.js\");\nvar _index2 = __webpack_require__(/*! ./scope/index.js */ \"(ssr)/./node_modules/@babel/traverse/lib/scope/index.js\");\nvar _hub = __webpack_require__(/*! ./hub.js */ \"(ssr)/./node_modules/@babel/traverse/lib/hub.js\");\nconst {\n  VISITOR_KEYS,\n  removeProperties,\n  traverseFast\n} = _t;\nfunction traverse(parent, opts = {}, scope, state, parentPath, visitSelf) {\n  if (!parent) return;\n  if (!opts.noScope && !scope) {\n    if (parent.type !== \"Program\" && parent.type !== \"File\") {\n      throw new Error(\"You must pass a scope and parentPath unless traversing a Program/File. \" + `Instead of that you tried to traverse a ${parent.type} node without ` + \"passing scope and parentPath.\");\n    }\n  }\n  if (!parentPath && visitSelf) {\n    throw new Error(\"visitSelf can only be used when providing a NodePath.\");\n  }\n  if (!VISITOR_KEYS[parent.type]) {\n    return;\n  }\n  visitors.explode(opts);\n  (0, _traverseNode.traverseNode)(parent, opts, scope, state, parentPath, undefined, visitSelf);\n}\nvar _default = exports[\"default\"] = traverse;\ntraverse.visitors = visitors;\ntraverse.verify = visitors.verify;\ntraverse.explode = visitors.explode;\ntraverse.cheap = function (node, enter) {\n  traverseFast(node, enter);\n  return;\n};\ntraverse.node = function (node, opts, scope, state, path, skipKeys) {\n  (0, _traverseNode.traverseNode)(node, opts, scope, state, path, skipKeys);\n};\ntraverse.clearNode = function (node, opts) {\n  removeProperties(node, opts);\n};\ntraverse.removeProperties = function (tree, opts) {\n  traverseFast(tree, traverse.clearNode, opts);\n  return tree;\n};\ntraverse.hasType = function (tree, type, denylistTypes) {\n  if (denylistTypes != null && denylistTypes.includes(tree.type)) return false;\n  if (tree.type === type) return true;\n  return traverseFast(tree, function (node) {\n    if (denylistTypes != null && denylistTypes.includes(node.type)) {\n      return traverseFast.skip;\n    }\n    if (node.type === type) {\n      return traverseFast.stop;\n    }\n  });\n};\ntraverse.cache = cache;\n\n//# sourceMappingURL=index.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGJhYmVsL3RyYXZlcnNlL2xpYi9pbmRleC5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYiw4Q0FBNkM7QUFDN0M7QUFDQSxDQUFDLEVBQUM7QUFDRix1Q0FBc0M7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLEVBQUM7QUFDRiw0Q0FBMkM7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLEVBQUM7QUFDRix5Q0FBd0M7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLEVBQUM7QUFDRixnQkFBZ0IsR0FBRyxrQkFBZTtBQUNsQyxtQkFBTyxDQUFDLG1GQUFtQjtBQUMzQixlQUFlLG1CQUFPLENBQUMsMkVBQWU7QUFDdEMsZ0JBQWdCO0FBQ2hCLFNBQVMsbUJBQU8sQ0FBQyxvRUFBYztBQUMvQixZQUFZLG1CQUFPLENBQUMscUVBQVk7QUFDaEMsb0JBQW9CLG1CQUFPLENBQUMscUZBQW9CO0FBQ2hELGFBQWEsbUJBQU8sQ0FBQywrRUFBaUI7QUFDdEMsY0FBYyxtQkFBTyxDQUFDLGlGQUFrQjtBQUN4QyxXQUFXLG1CQUFPLENBQUMsaUVBQVU7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0YsbUNBQW1DO0FBQ25DO0FBQ0E7QUFDQTtBQUNBLDZJQUE2SSxhQUFhO0FBQzFKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLGtCQUFlO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcmVwby12aXN1YWxpemVyLy4vbm9kZV9tb2R1bGVzL0BiYWJlbC90cmF2ZXJzZS9saWIvaW5kZXguanM/MThlMSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIkh1YlwiLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBfaHViLmRlZmF1bHQ7XG4gIH1cbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiTm9kZVBhdGhcIiwge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gX2luZGV4LmRlZmF1bHQ7XG4gIH1cbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiU2NvcGVcIiwge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gX2luZGV4Mi5kZWZhdWx0O1xuICB9XG59KTtcbmV4cG9ydHMudmlzaXRvcnMgPSBleHBvcnRzLmRlZmF1bHQgPSB2b2lkIDA7XG5yZXF1aXJlKFwiLi9wYXRoL2NvbnRleHQuanNcIik7XG52YXIgdmlzaXRvcnMgPSByZXF1aXJlKFwiLi92aXNpdG9ycy5qc1wiKTtcbmV4cG9ydHMudmlzaXRvcnMgPSB2aXNpdG9ycztcbnZhciBfdCA9IHJlcXVpcmUoXCJAYmFiZWwvdHlwZXNcIik7XG52YXIgY2FjaGUgPSByZXF1aXJlKFwiLi9jYWNoZS5qc1wiKTtcbnZhciBfdHJhdmVyc2VOb2RlID0gcmVxdWlyZShcIi4vdHJhdmVyc2Utbm9kZS5qc1wiKTtcbnZhciBfaW5kZXggPSByZXF1aXJlKFwiLi9wYXRoL2luZGV4LmpzXCIpO1xudmFyIF9pbmRleDIgPSByZXF1aXJlKFwiLi9zY29wZS9pbmRleC5qc1wiKTtcbnZhciBfaHViID0gcmVxdWlyZShcIi4vaHViLmpzXCIpO1xuY29uc3Qge1xuICBWSVNJVE9SX0tFWVMsXG4gIHJlbW92ZVByb3BlcnRpZXMsXG4gIHRyYXZlcnNlRmFzdFxufSA9IF90O1xuZnVuY3Rpb24gdHJhdmVyc2UocGFyZW50LCBvcHRzID0ge30sIHNjb3BlLCBzdGF0ZSwgcGFyZW50UGF0aCwgdmlzaXRTZWxmKSB7XG4gIGlmICghcGFyZW50KSByZXR1cm47XG4gIGlmICghb3B0cy5ub1Njb3BlICYmICFzY29wZSkge1xuICAgIGlmIChwYXJlbnQudHlwZSAhPT0gXCJQcm9ncmFtXCIgJiYgcGFyZW50LnR5cGUgIT09IFwiRmlsZVwiKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJZb3UgbXVzdCBwYXNzIGEgc2NvcGUgYW5kIHBhcmVudFBhdGggdW5sZXNzIHRyYXZlcnNpbmcgYSBQcm9ncmFtL0ZpbGUuIFwiICsgYEluc3RlYWQgb2YgdGhhdCB5b3UgdHJpZWQgdG8gdHJhdmVyc2UgYSAke3BhcmVudC50eXBlfSBub2RlIHdpdGhvdXQgYCArIFwicGFzc2luZyBzY29wZSBhbmQgcGFyZW50UGF0aC5cIik7XG4gICAgfVxuICB9XG4gIGlmICghcGFyZW50UGF0aCAmJiB2aXNpdFNlbGYpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJ2aXNpdFNlbGYgY2FuIG9ubHkgYmUgdXNlZCB3aGVuIHByb3ZpZGluZyBhIE5vZGVQYXRoLlwiKTtcbiAgfVxuICBpZiAoIVZJU0lUT1JfS0VZU1twYXJlbnQudHlwZV0pIHtcbiAgICByZXR1cm47XG4gIH1cbiAgdmlzaXRvcnMuZXhwbG9kZShvcHRzKTtcbiAgKDAsIF90cmF2ZXJzZU5vZGUudHJhdmVyc2VOb2RlKShwYXJlbnQsIG9wdHMsIHNjb3BlLCBzdGF0ZSwgcGFyZW50UGF0aCwgdW5kZWZpbmVkLCB2aXNpdFNlbGYpO1xufVxudmFyIF9kZWZhdWx0ID0gZXhwb3J0cy5kZWZhdWx0ID0gdHJhdmVyc2U7XG50cmF2ZXJzZS52aXNpdG9ycyA9IHZpc2l0b3JzO1xudHJhdmVyc2UudmVyaWZ5ID0gdmlzaXRvcnMudmVyaWZ5O1xudHJhdmVyc2UuZXhwbG9kZSA9IHZpc2l0b3JzLmV4cGxvZGU7XG50cmF2ZXJzZS5jaGVhcCA9IGZ1bmN0aW9uIChub2RlLCBlbnRlcikge1xuICB0cmF2ZXJzZUZhc3Qobm9kZSwgZW50ZXIpO1xuICByZXR1cm47XG59O1xudHJhdmVyc2Uubm9kZSA9IGZ1bmN0aW9uIChub2RlLCBvcHRzLCBzY29wZSwgc3RhdGUsIHBhdGgsIHNraXBLZXlzKSB7XG4gICgwLCBfdHJhdmVyc2VOb2RlLnRyYXZlcnNlTm9kZSkobm9kZSwgb3B0cywgc2NvcGUsIHN0YXRlLCBwYXRoLCBza2lwS2V5cyk7XG59O1xudHJhdmVyc2UuY2xlYXJOb2RlID0gZnVuY3Rpb24gKG5vZGUsIG9wdHMpIHtcbiAgcmVtb3ZlUHJvcGVydGllcyhub2RlLCBvcHRzKTtcbn07XG50cmF2ZXJzZS5yZW1vdmVQcm9wZXJ0aWVzID0gZnVuY3Rpb24gKHRyZWUsIG9wdHMpIHtcbiAgdHJhdmVyc2VGYXN0KHRyZWUsIHRyYXZlcnNlLmNsZWFyTm9kZSwgb3B0cyk7XG4gIHJldHVybiB0cmVlO1xufTtcbnRyYXZlcnNlLmhhc1R5cGUgPSBmdW5jdGlvbiAodHJlZSwgdHlwZSwgZGVueWxpc3RUeXBlcykge1xuICBpZiAoZGVueWxpc3RUeXBlcyAhPSBudWxsICYmIGRlbnlsaXN0VHlwZXMuaW5jbHVkZXModHJlZS50eXBlKSkgcmV0dXJuIGZhbHNlO1xuICBpZiAodHJlZS50eXBlID09PSB0eXBlKSByZXR1cm4gdHJ1ZTtcbiAgcmV0dXJuIHRyYXZlcnNlRmFzdCh0cmVlLCBmdW5jdGlvbiAobm9kZSkge1xuICAgIGlmIChkZW55bGlzdFR5cGVzICE9IG51bGwgJiYgZGVueWxpc3RUeXBlcy5pbmNsdWRlcyhub2RlLnR5cGUpKSB7XG4gICAgICByZXR1cm4gdHJhdmVyc2VGYXN0LnNraXA7XG4gICAgfVxuICAgIGlmIChub2RlLnR5cGUgPT09IHR5cGUpIHtcbiAgICAgIHJldHVybiB0cmF2ZXJzZUZhc3Quc3RvcDtcbiAgICB9XG4gIH0pO1xufTtcbnRyYXZlcnNlLmNhY2hlID0gY2FjaGU7XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcFxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@babel/traverse/lib/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@babel/traverse/lib/path/ancestry.js":
/*!***********************************************************!*\
  !*** ./node_modules/@babel/traverse/lib/path/ancestry.js ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports.find = find;\nexports.findParent = findParent;\nexports.getAncestry = getAncestry;\nexports.getDeepestCommonAncestorFrom = getDeepestCommonAncestorFrom;\nexports.getEarliestCommonAncestorFrom = getEarliestCommonAncestorFrom;\nexports.getFunctionParent = getFunctionParent;\nexports.getStatementParent = getStatementParent;\nexports.inType = inType;\nexports.isAncestor = isAncestor;\nexports.isDescendant = isDescendant;\nvar _t = __webpack_require__(/*! @babel/types */ \"(ssr)/./node_modules/@babel/types/lib/index.js\");\nconst {\n  VISITOR_KEYS\n} = _t;\nfunction findParent(callback) {\n  let path = this;\n  while (path = path.parentPath) {\n    if (callback(path)) return path;\n  }\n  return null;\n}\nfunction find(callback) {\n  let path = this;\n  do {\n    if (callback(path)) return path;\n  } while (path = path.parentPath);\n  return null;\n}\nfunction getFunctionParent() {\n  return this.findParent(p => p.isFunction());\n}\nfunction getStatementParent() {\n  let path = this;\n  do {\n    if (!path.parentPath || Array.isArray(path.container) && path.isStatement()) {\n      break;\n    } else {\n      path = path.parentPath;\n    }\n  } while (path);\n  if (path && (path.isProgram() || path.isFile())) {\n    throw new Error(\"File/Program node, we can't possibly find a statement parent to this\");\n  }\n  return path;\n}\nfunction getEarliestCommonAncestorFrom(paths) {\n  return this.getDeepestCommonAncestorFrom(paths, function (deepest, i, ancestries) {\n    let earliest;\n    const keys = VISITOR_KEYS[deepest.type];\n    for (const ancestry of ancestries) {\n      const path = ancestry[i + 1];\n      if (!earliest) {\n        earliest = path;\n        continue;\n      }\n      if (path.listKey && earliest.listKey === path.listKey) {\n        if (path.key < earliest.key) {\n          earliest = path;\n          continue;\n        }\n      }\n      const earliestKeyIndex = keys.indexOf(earliest.parentKey);\n      const currentKeyIndex = keys.indexOf(path.parentKey);\n      if (earliestKeyIndex > currentKeyIndex) {\n        earliest = path;\n      }\n    }\n    return earliest;\n  });\n}\nfunction getDeepestCommonAncestorFrom(paths, filter) {\n  if (!paths.length) {\n    return this;\n  }\n  if (paths.length === 1) {\n    return paths[0];\n  }\n  let minDepth = Infinity;\n  let lastCommonIndex, lastCommon;\n  const ancestries = paths.map(path => {\n    const ancestry = [];\n    do {\n      ancestry.unshift(path);\n    } while ((path = path.parentPath) && path !== this);\n    if (ancestry.length < minDepth) {\n      minDepth = ancestry.length;\n    }\n    return ancestry;\n  });\n  const first = ancestries[0];\n  depthLoop: for (let i = 0; i < minDepth; i++) {\n    const shouldMatch = first[i];\n    for (const ancestry of ancestries) {\n      if (ancestry[i] !== shouldMatch) {\n        break depthLoop;\n      }\n    }\n    lastCommonIndex = i;\n    lastCommon = shouldMatch;\n  }\n  if (lastCommon) {\n    if (filter) {\n      return filter(lastCommon, lastCommonIndex, ancestries);\n    } else {\n      return lastCommon;\n    }\n  } else {\n    throw new Error(\"Couldn't find intersection\");\n  }\n}\nfunction getAncestry() {\n  let path = this;\n  const paths = [];\n  do {\n    paths.push(path);\n  } while (path = path.parentPath);\n  return paths;\n}\nfunction isAncestor(maybeDescendant) {\n  return maybeDescendant.isDescendant(this);\n}\nfunction isDescendant(maybeAncestor) {\n  return !!this.findParent(parent => parent === maybeAncestor);\n}\nfunction inType(...candidateTypes) {\n  let path = this;\n  while (path) {\n    if (candidateTypes.includes(path.node.type)) return true;\n    path = path.parentPath;\n  }\n  return false;\n}\n\n//# sourceMappingURL=ancestry.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGJhYmVsL3RyYXZlcnNlL2xpYi9wYXRoL2FuY2VzdHJ5LmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViLDhDQUE2QztBQUM3QztBQUNBLENBQUMsRUFBQztBQUNGLFlBQVk7QUFDWixrQkFBa0I7QUFDbEIsbUJBQW1CO0FBQ25CLG9DQUFvQztBQUNwQyxxQ0FBcUM7QUFDckMseUJBQXlCO0FBQ3pCLDBCQUEwQjtBQUMxQixjQUFjO0FBQ2Qsa0JBQWtCO0FBQ2xCLG9CQUFvQjtBQUNwQixTQUFTLG1CQUFPLENBQUMsb0VBQWM7QUFDL0I7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLDZCQUE2QixjQUFjO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9yZXBvLXZpc3VhbGl6ZXIvLi9ub2RlX21vZHVsZXMvQGJhYmVsL3RyYXZlcnNlL2xpYi9wYXRoL2FuY2VzdHJ5LmpzPzQxMzYiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLmZpbmQgPSBmaW5kO1xuZXhwb3J0cy5maW5kUGFyZW50ID0gZmluZFBhcmVudDtcbmV4cG9ydHMuZ2V0QW5jZXN0cnkgPSBnZXRBbmNlc3RyeTtcbmV4cG9ydHMuZ2V0RGVlcGVzdENvbW1vbkFuY2VzdG9yRnJvbSA9IGdldERlZXBlc3RDb21tb25BbmNlc3RvckZyb207XG5leHBvcnRzLmdldEVhcmxpZXN0Q29tbW9uQW5jZXN0b3JGcm9tID0gZ2V0RWFybGllc3RDb21tb25BbmNlc3RvckZyb207XG5leHBvcnRzLmdldEZ1bmN0aW9uUGFyZW50ID0gZ2V0RnVuY3Rpb25QYXJlbnQ7XG5leHBvcnRzLmdldFN0YXRlbWVudFBhcmVudCA9IGdldFN0YXRlbWVudFBhcmVudDtcbmV4cG9ydHMuaW5UeXBlID0gaW5UeXBlO1xuZXhwb3J0cy5pc0FuY2VzdG9yID0gaXNBbmNlc3RvcjtcbmV4cG9ydHMuaXNEZXNjZW5kYW50ID0gaXNEZXNjZW5kYW50O1xudmFyIF90ID0gcmVxdWlyZShcIkBiYWJlbC90eXBlc1wiKTtcbmNvbnN0IHtcbiAgVklTSVRPUl9LRVlTXG59ID0gX3Q7XG5mdW5jdGlvbiBmaW5kUGFyZW50KGNhbGxiYWNrKSB7XG4gIGxldCBwYXRoID0gdGhpcztcbiAgd2hpbGUgKHBhdGggPSBwYXRoLnBhcmVudFBhdGgpIHtcbiAgICBpZiAoY2FsbGJhY2socGF0aCkpIHJldHVybiBwYXRoO1xuICB9XG4gIHJldHVybiBudWxsO1xufVxuZnVuY3Rpb24gZmluZChjYWxsYmFjaykge1xuICBsZXQgcGF0aCA9IHRoaXM7XG4gIGRvIHtcbiAgICBpZiAoY2FsbGJhY2socGF0aCkpIHJldHVybiBwYXRoO1xuICB9IHdoaWxlIChwYXRoID0gcGF0aC5wYXJlbnRQYXRoKTtcbiAgcmV0dXJuIG51bGw7XG59XG5mdW5jdGlvbiBnZXRGdW5jdGlvblBhcmVudCgpIHtcbiAgcmV0dXJuIHRoaXMuZmluZFBhcmVudChwID0+IHAuaXNGdW5jdGlvbigpKTtcbn1cbmZ1bmN0aW9uIGdldFN0YXRlbWVudFBhcmVudCgpIHtcbiAgbGV0IHBhdGggPSB0aGlzO1xuICBkbyB7XG4gICAgaWYgKCFwYXRoLnBhcmVudFBhdGggfHwgQXJyYXkuaXNBcnJheShwYXRoLmNvbnRhaW5lcikgJiYgcGF0aC5pc1N0YXRlbWVudCgpKSB7XG4gICAgICBicmVhaztcbiAgICB9IGVsc2Uge1xuICAgICAgcGF0aCA9IHBhdGgucGFyZW50UGF0aDtcbiAgICB9XG4gIH0gd2hpbGUgKHBhdGgpO1xuICBpZiAocGF0aCAmJiAocGF0aC5pc1Byb2dyYW0oKSB8fCBwYXRoLmlzRmlsZSgpKSkge1xuICAgIHRocm93IG5ldyBFcnJvcihcIkZpbGUvUHJvZ3JhbSBub2RlLCB3ZSBjYW4ndCBwb3NzaWJseSBmaW5kIGEgc3RhdGVtZW50IHBhcmVudCB0byB0aGlzXCIpO1xuICB9XG4gIHJldHVybiBwYXRoO1xufVxuZnVuY3Rpb24gZ2V0RWFybGllc3RDb21tb25BbmNlc3RvckZyb20ocGF0aHMpIHtcbiAgcmV0dXJuIHRoaXMuZ2V0RGVlcGVzdENvbW1vbkFuY2VzdG9yRnJvbShwYXRocywgZnVuY3Rpb24gKGRlZXBlc3QsIGksIGFuY2VzdHJpZXMpIHtcbiAgICBsZXQgZWFybGllc3Q7XG4gICAgY29uc3Qga2V5cyA9IFZJU0lUT1JfS0VZU1tkZWVwZXN0LnR5cGVdO1xuICAgIGZvciAoY29uc3QgYW5jZXN0cnkgb2YgYW5jZXN0cmllcykge1xuICAgICAgY29uc3QgcGF0aCA9IGFuY2VzdHJ5W2kgKyAxXTtcbiAgICAgIGlmICghZWFybGllc3QpIHtcbiAgICAgICAgZWFybGllc3QgPSBwYXRoO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIGlmIChwYXRoLmxpc3RLZXkgJiYgZWFybGllc3QubGlzdEtleSA9PT0gcGF0aC5saXN0S2V5KSB7XG4gICAgICAgIGlmIChwYXRoLmtleSA8IGVhcmxpZXN0LmtleSkge1xuICAgICAgICAgIGVhcmxpZXN0ID0gcGF0aDtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgY29uc3QgZWFybGllc3RLZXlJbmRleCA9IGtleXMuaW5kZXhPZihlYXJsaWVzdC5wYXJlbnRLZXkpO1xuICAgICAgY29uc3QgY3VycmVudEtleUluZGV4ID0ga2V5cy5pbmRleE9mKHBhdGgucGFyZW50S2V5KTtcbiAgICAgIGlmIChlYXJsaWVzdEtleUluZGV4ID4gY3VycmVudEtleUluZGV4KSB7XG4gICAgICAgIGVhcmxpZXN0ID0gcGF0aDtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGVhcmxpZXN0O1xuICB9KTtcbn1cbmZ1bmN0aW9uIGdldERlZXBlc3RDb21tb25BbmNlc3RvckZyb20ocGF0aHMsIGZpbHRlcikge1xuICBpZiAoIXBhdGhzLmxlbmd0aCkge1xuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIGlmIChwYXRocy5sZW5ndGggPT09IDEpIHtcbiAgICByZXR1cm4gcGF0aHNbMF07XG4gIH1cbiAgbGV0IG1pbkRlcHRoID0gSW5maW5pdHk7XG4gIGxldCBsYXN0Q29tbW9uSW5kZXgsIGxhc3RDb21tb247XG4gIGNvbnN0IGFuY2VzdHJpZXMgPSBwYXRocy5tYXAocGF0aCA9PiB7XG4gICAgY29uc3QgYW5jZXN0cnkgPSBbXTtcbiAgICBkbyB7XG4gICAgICBhbmNlc3RyeS51bnNoaWZ0KHBhdGgpO1xuICAgIH0gd2hpbGUgKChwYXRoID0gcGF0aC5wYXJlbnRQYXRoKSAmJiBwYXRoICE9PSB0aGlzKTtcbiAgICBpZiAoYW5jZXN0cnkubGVuZ3RoIDwgbWluRGVwdGgpIHtcbiAgICAgIG1pbkRlcHRoID0gYW5jZXN0cnkubGVuZ3RoO1xuICAgIH1cbiAgICByZXR1cm4gYW5jZXN0cnk7XG4gIH0pO1xuICBjb25zdCBmaXJzdCA9IGFuY2VzdHJpZXNbMF07XG4gIGRlcHRoTG9vcDogZm9yIChsZXQgaSA9IDA7IGkgPCBtaW5EZXB0aDsgaSsrKSB7XG4gICAgY29uc3Qgc2hvdWxkTWF0Y2ggPSBmaXJzdFtpXTtcbiAgICBmb3IgKGNvbnN0IGFuY2VzdHJ5IG9mIGFuY2VzdHJpZXMpIHtcbiAgICAgIGlmIChhbmNlc3RyeVtpXSAhPT0gc2hvdWxkTWF0Y2gpIHtcbiAgICAgICAgYnJlYWsgZGVwdGhMb29wO1xuICAgICAgfVxuICAgIH1cbiAgICBsYXN0Q29tbW9uSW5kZXggPSBpO1xuICAgIGxhc3RDb21tb24gPSBzaG91bGRNYXRjaDtcbiAgfVxuICBpZiAobGFzdENvbW1vbikge1xuICAgIGlmIChmaWx0ZXIpIHtcbiAgICAgIHJldHVybiBmaWx0ZXIobGFzdENvbW1vbiwgbGFzdENvbW1vbkluZGV4LCBhbmNlc3RyaWVzKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIGxhc3RDb21tb247XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHRocm93IG5ldyBFcnJvcihcIkNvdWxkbid0IGZpbmQgaW50ZXJzZWN0aW9uXCIpO1xuICB9XG59XG5mdW5jdGlvbiBnZXRBbmNlc3RyeSgpIHtcbiAgbGV0IHBhdGggPSB0aGlzO1xuICBjb25zdCBwYXRocyA9IFtdO1xuICBkbyB7XG4gICAgcGF0aHMucHVzaChwYXRoKTtcbiAgfSB3aGlsZSAocGF0aCA9IHBhdGgucGFyZW50UGF0aCk7XG4gIHJldHVybiBwYXRocztcbn1cbmZ1bmN0aW9uIGlzQW5jZXN0b3IobWF5YmVEZXNjZW5kYW50KSB7XG4gIHJldHVybiBtYXliZURlc2NlbmRhbnQuaXNEZXNjZW5kYW50KHRoaXMpO1xufVxuZnVuY3Rpb24gaXNEZXNjZW5kYW50KG1heWJlQW5jZXN0b3IpIHtcbiAgcmV0dXJuICEhdGhpcy5maW5kUGFyZW50KHBhcmVudCA9PiBwYXJlbnQgPT09IG1heWJlQW5jZXN0b3IpO1xufVxuZnVuY3Rpb24gaW5UeXBlKC4uLmNhbmRpZGF0ZVR5cGVzKSB7XG4gIGxldCBwYXRoID0gdGhpcztcbiAgd2hpbGUgKHBhdGgpIHtcbiAgICBpZiAoY2FuZGlkYXRlVHlwZXMuaW5jbHVkZXMocGF0aC5ub2RlLnR5cGUpKSByZXR1cm4gdHJ1ZTtcbiAgICBwYXRoID0gcGF0aC5wYXJlbnRQYXRoO1xuICB9XG4gIHJldHVybiBmYWxzZTtcbn1cblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YW5jZXN0cnkuanMubWFwXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@babel/traverse/lib/path/ancestry.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@babel/traverse/lib/path/comments.js":
/*!***********************************************************!*\
  !*** ./node_modules/@babel/traverse/lib/path/comments.js ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports.addComment = addComment;\nexports.addComments = addComments;\nexports.shareCommentsWithSiblings = shareCommentsWithSiblings;\nvar _t = __webpack_require__(/*! @babel/types */ \"(ssr)/./node_modules/@babel/types/lib/index.js\");\nconst {\n  addComment: _addComment,\n  addComments: _addComments\n} = _t;\nfunction shareCommentsWithSiblings() {\n  if (typeof this.key === \"string\") return;\n  const node = this.node;\n  if (!node) return;\n  const trailing = node.trailingComments;\n  const leading = node.leadingComments;\n  if (!trailing && !leading) return;\n  const prev = this.getSibling(this.key - 1);\n  const next = this.getSibling(this.key + 1);\n  const hasPrev = Boolean(prev.node);\n  const hasNext = Boolean(next.node);\n  if (hasPrev) {\n    if (leading) {\n      prev.addComments(\"trailing\", removeIfExisting(leading, prev.node.trailingComments));\n    }\n    if (trailing && !hasNext) prev.addComments(\"trailing\", trailing);\n  }\n  if (hasNext) {\n    if (trailing) {\n      next.addComments(\"leading\", removeIfExisting(trailing, next.node.leadingComments));\n    }\n    if (leading && !hasPrev) next.addComments(\"leading\", leading);\n  }\n}\nfunction removeIfExisting(list, toRemove) {\n  if (!(toRemove != null && toRemove.length)) return list;\n  const set = new Set(toRemove);\n  return list.filter(el => {\n    return !set.has(el);\n  });\n}\nfunction addComment(type, content, line) {\n  _addComment(this.node, type, content, line);\n}\nfunction addComments(type, comments) {\n  _addComments(this.node, type, comments);\n}\n\n//# sourceMappingURL=comments.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGJhYmVsL3RyYXZlcnNlL2xpYi9wYXRoL2NvbW1lbnRzLmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViLDhDQUE2QztBQUM3QztBQUNBLENBQUMsRUFBQztBQUNGLGtCQUFrQjtBQUNsQixtQkFBbUI7QUFDbkIsaUNBQWlDO0FBQ2pDLFNBQVMsbUJBQU8sQ0FBQyxvRUFBYztBQUMvQjtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSIsInNvdXJjZXMiOlsid2VicGFjazovL3JlcG8tdmlzdWFsaXplci8uL25vZGVfbW9kdWxlcy9AYmFiZWwvdHJhdmVyc2UvbGliL3BhdGgvY29tbWVudHMuanM/NDQ0MCJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuYWRkQ29tbWVudCA9IGFkZENvbW1lbnQ7XG5leHBvcnRzLmFkZENvbW1lbnRzID0gYWRkQ29tbWVudHM7XG5leHBvcnRzLnNoYXJlQ29tbWVudHNXaXRoU2libGluZ3MgPSBzaGFyZUNvbW1lbnRzV2l0aFNpYmxpbmdzO1xudmFyIF90ID0gcmVxdWlyZShcIkBiYWJlbC90eXBlc1wiKTtcbmNvbnN0IHtcbiAgYWRkQ29tbWVudDogX2FkZENvbW1lbnQsXG4gIGFkZENvbW1lbnRzOiBfYWRkQ29tbWVudHNcbn0gPSBfdDtcbmZ1bmN0aW9uIHNoYXJlQ29tbWVudHNXaXRoU2libGluZ3MoKSB7XG4gIGlmICh0eXBlb2YgdGhpcy5rZXkgPT09IFwic3RyaW5nXCIpIHJldHVybjtcbiAgY29uc3Qgbm9kZSA9IHRoaXMubm9kZTtcbiAgaWYgKCFub2RlKSByZXR1cm47XG4gIGNvbnN0IHRyYWlsaW5nID0gbm9kZS50cmFpbGluZ0NvbW1lbnRzO1xuICBjb25zdCBsZWFkaW5nID0gbm9kZS5sZWFkaW5nQ29tbWVudHM7XG4gIGlmICghdHJhaWxpbmcgJiYgIWxlYWRpbmcpIHJldHVybjtcbiAgY29uc3QgcHJldiA9IHRoaXMuZ2V0U2libGluZyh0aGlzLmtleSAtIDEpO1xuICBjb25zdCBuZXh0ID0gdGhpcy5nZXRTaWJsaW5nKHRoaXMua2V5ICsgMSk7XG4gIGNvbnN0IGhhc1ByZXYgPSBCb29sZWFuKHByZXYubm9kZSk7XG4gIGNvbnN0IGhhc05leHQgPSBCb29sZWFuKG5leHQubm9kZSk7XG4gIGlmIChoYXNQcmV2KSB7XG4gICAgaWYgKGxlYWRpbmcpIHtcbiAgICAgIHByZXYuYWRkQ29tbWVudHMoXCJ0cmFpbGluZ1wiLCByZW1vdmVJZkV4aXN0aW5nKGxlYWRpbmcsIHByZXYubm9kZS50cmFpbGluZ0NvbW1lbnRzKSk7XG4gICAgfVxuICAgIGlmICh0cmFpbGluZyAmJiAhaGFzTmV4dCkgcHJldi5hZGRDb21tZW50cyhcInRyYWlsaW5nXCIsIHRyYWlsaW5nKTtcbiAgfVxuICBpZiAoaGFzTmV4dCkge1xuICAgIGlmICh0cmFpbGluZykge1xuICAgICAgbmV4dC5hZGRDb21tZW50cyhcImxlYWRpbmdcIiwgcmVtb3ZlSWZFeGlzdGluZyh0cmFpbGluZywgbmV4dC5ub2RlLmxlYWRpbmdDb21tZW50cykpO1xuICAgIH1cbiAgICBpZiAobGVhZGluZyAmJiAhaGFzUHJldikgbmV4dC5hZGRDb21tZW50cyhcImxlYWRpbmdcIiwgbGVhZGluZyk7XG4gIH1cbn1cbmZ1bmN0aW9uIHJlbW92ZUlmRXhpc3RpbmcobGlzdCwgdG9SZW1vdmUpIHtcbiAgaWYgKCEodG9SZW1vdmUgIT0gbnVsbCAmJiB0b1JlbW92ZS5sZW5ndGgpKSByZXR1cm4gbGlzdDtcbiAgY29uc3Qgc2V0ID0gbmV3IFNldCh0b1JlbW92ZSk7XG4gIHJldHVybiBsaXN0LmZpbHRlcihlbCA9PiB7XG4gICAgcmV0dXJuICFzZXQuaGFzKGVsKTtcbiAgfSk7XG59XG5mdW5jdGlvbiBhZGRDb21tZW50KHR5cGUsIGNvbnRlbnQsIGxpbmUpIHtcbiAgX2FkZENvbW1lbnQodGhpcy5ub2RlLCB0eXBlLCBjb250ZW50LCBsaW5lKTtcbn1cbmZ1bmN0aW9uIGFkZENvbW1lbnRzKHR5cGUsIGNvbW1lbnRzKSB7XG4gIF9hZGRDb21tZW50cyh0aGlzLm5vZGUsIHR5cGUsIGNvbW1lbnRzKTtcbn1cblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y29tbWVudHMuanMubWFwXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@babel/traverse/lib/path/comments.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@babel/traverse/lib/path/context.js":
/*!**********************************************************!*\
  !*** ./node_modules/@babel/traverse/lib/path/context.js ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports._call = _call;\nexports._forceSetScope = _forceSetScope;\nexports._getQueueContexts = _getQueueContexts;\nexports._resyncKey = _resyncKey;\nexports._resyncList = _resyncList;\nexports._resyncParent = _resyncParent;\nexports._resyncRemoved = _resyncRemoved;\nexports.call = call;\nexports.isDenylisted = isDenylisted;\nexports.popContext = popContext;\nexports.pushContext = pushContext;\nexports.requeue = requeue;\nexports.requeueComputedKeyAndDecorators = requeueComputedKeyAndDecorators;\nexports.resync = resync;\nexports.setContext = setContext;\nexports.setKey = setKey;\nexports.setScope = setScope;\nexports.setup = setup;\nexports.skip = skip;\nexports.skipKey = skipKey;\nexports.stop = stop;\nexports.visit = visit;\nvar _traverseNode = __webpack_require__(/*! ../traverse-node.js */ \"(ssr)/./node_modules/@babel/traverse/lib/traverse-node.js\");\nvar _index = __webpack_require__(/*! ./index.js */ \"(ssr)/./node_modules/@babel/traverse/lib/path/index.js\");\nvar _removal = __webpack_require__(/*! ./removal.js */ \"(ssr)/./node_modules/@babel/traverse/lib/path/removal.js\");\nvar t = __webpack_require__(/*! @babel/types */ \"(ssr)/./node_modules/@babel/types/lib/index.js\");\nfunction call(key) {\n  const opts = this.opts;\n  this.debug(key);\n  if (this.node) {\n    if (_call.call(this, opts[key])) return true;\n  }\n  if (this.node) {\n    var _opts$this$node$type;\n    return _call.call(this, (_opts$this$node$type = opts[this.node.type]) == null ? void 0 : _opts$this$node$type[key]);\n  }\n  return false;\n}\nfunction _call(fns) {\n  if (!fns) return false;\n  for (const fn of fns) {\n    if (!fn) continue;\n    const node = this.node;\n    if (!node) return true;\n    const ret = fn.call(this.state, this, this.state);\n    if (ret && typeof ret === \"object\" && typeof ret.then === \"function\") {\n      throw new Error(`You appear to be using a plugin with an async traversal visitor, ` + `which your current version of Babel does not support. ` + `If you're using a published plugin, you may need to upgrade ` + `your @babel/core version.`);\n    }\n    if (ret) {\n      throw new Error(`Unexpected return value from visitor method ${fn}`);\n    }\n    if (this.node !== node) return true;\n    if (this._traverseFlags > 0) return true;\n  }\n  return false;\n}\nfunction isDenylisted() {\n  var _this$opts$denylist;\n  const denylist = (_this$opts$denylist = this.opts.denylist) != null ? _this$opts$denylist : this.opts.blacklist;\n  return denylist == null ? void 0 : denylist.includes(this.node.type);\n}\nexports.isBlacklisted = isDenylisted;\nfunction restoreContext(path, context) {\n  if (path.context !== context) {\n    path.context = context;\n    path.state = context.state;\n    path.opts = context.opts;\n  }\n}\nfunction visit() {\n  var _this$opts$shouldSkip, _this$opts;\n  if (!this.node) {\n    return false;\n  }\n  if (this.isDenylisted()) {\n    return false;\n  }\n  if ((_this$opts$shouldSkip = (_this$opts = this.opts).shouldSkip) != null && _this$opts$shouldSkip.call(_this$opts, this)) {\n    return false;\n  }\n  const currentContext = this.context;\n  if (this.shouldSkip || call.call(this, \"enter\")) {\n    this.debug(\"Skip...\");\n    return this.shouldStop;\n  }\n  restoreContext(this, currentContext);\n  this.debug(\"Recursing into...\");\n  this.shouldStop = (0, _traverseNode.traverseNode)(this.node, this.opts, this.scope, this.state, this, this.skipKeys);\n  restoreContext(this, currentContext);\n  call.call(this, \"exit\");\n  return this.shouldStop;\n}\nfunction skip() {\n  this.shouldSkip = true;\n}\nfunction skipKey(key) {\n  if (this.skipKeys == null) {\n    this.skipKeys = {};\n  }\n  this.skipKeys[key] = true;\n}\nfunction stop() {\n  this._traverseFlags |= _index.SHOULD_SKIP | _index.SHOULD_STOP;\n}\nfunction _forceSetScope() {\n  var _this$scope;\n  let path = this.parentPath;\n  if ((this.key === \"key\" || this.listKey === \"decorators\") && path.isMethod() || this.key === \"discriminant\" && path.isSwitchStatement()) {\n    path = path.parentPath;\n  }\n  let target;\n  while (path && !target) {\n    target = path.scope;\n    path = path.parentPath;\n  }\n  this.scope = this.getScope(target);\n  (_this$scope = this.scope) == null || _this$scope.init();\n}\nfunction setScope() {\n  var _this$opts2, _this$scope2;\n  if ((_this$opts2 = this.opts) != null && _this$opts2.noScope) return;\n  let path = this.parentPath;\n  if ((this.key === \"key\" || this.listKey === \"decorators\") && path.isMethod() || this.key === \"discriminant\" && path.isSwitchStatement()) {\n    path = path.parentPath;\n  }\n  let target;\n  while (path && !target) {\n    var _path$opts;\n    if ((_path$opts = path.opts) != null && _path$opts.noScope) return;\n    target = path.scope;\n    path = path.parentPath;\n  }\n  this.scope = this.getScope(target);\n  (_this$scope2 = this.scope) == null || _this$scope2.init();\n}\nfunction setContext(context) {\n  if (this.skipKeys != null) {\n    this.skipKeys = {};\n  }\n  this._traverseFlags = 0;\n  if (context) {\n    this.context = context;\n    this.state = context.state;\n    this.opts = context.opts;\n  }\n  setScope.call(this);\n  return this;\n}\nfunction resync() {\n  if (this.removed) return;\n  _resyncParent.call(this);\n  _resyncList.call(this);\n  _resyncKey.call(this);\n}\nfunction _resyncParent() {\n  if (this.parentPath) {\n    this.parent = this.parentPath.node;\n  }\n}\nfunction _resyncKey() {\n  if (!this.container) return;\n  if (this.node === this.container[this.key]) {\n    return;\n  }\n  if (Array.isArray(this.container)) {\n    for (let i = 0; i < this.container.length; i++) {\n      if (this.container[i] === this.node) {\n        setKey.call(this, i);\n        return;\n      }\n    }\n  } else {\n    for (const key of Object.keys(this.container)) {\n      if (this.container[key] === this.node) {\n        setKey.call(this, key);\n        return;\n      }\n    }\n  }\n  this.key = null;\n}\nfunction _resyncList() {\n  if (!this.parent || !this.inList) return;\n  const newContainer = this.parent[this.listKey];\n  if (this.container === newContainer) return;\n  this.container = newContainer || null;\n}\nfunction _resyncRemoved() {\n  if (this.key == null || !this.container || this.container[this.key] !== this.node) {\n    _removal._markRemoved.call(this);\n  }\n}\nfunction popContext() {\n  this.contexts.pop();\n  if (this.contexts.length > 0) {\n    this.setContext(this.contexts[this.contexts.length - 1]);\n  } else {\n    this.setContext(undefined);\n  }\n}\nfunction pushContext(context) {\n  this.contexts.push(context);\n  this.setContext(context);\n}\nfunction setup(parentPath, container, listKey, key) {\n  this.listKey = listKey;\n  this.container = container;\n  this.parentPath = parentPath || this.parentPath;\n  setKey.call(this, key);\n}\nfunction setKey(key) {\n  var _this$node;\n  this.key = key;\n  this.node = this.container[this.key];\n  this.type = (_this$node = this.node) == null ? void 0 : _this$node.type;\n}\nfunction requeue(pathToQueue = this) {\n  if (pathToQueue.removed) return;\n  const contexts = this.contexts;\n  for (const context of contexts) {\n    context.maybeQueue(pathToQueue);\n  }\n}\nfunction requeueComputedKeyAndDecorators() {\n  const {\n    context,\n    node\n  } = this;\n  if (!t.isPrivate(node) && node.computed) {\n    context.maybeQueue(this.get(\"key\"));\n  }\n  if (node.decorators) {\n    for (const decorator of this.get(\"decorators\")) {\n      context.maybeQueue(decorator);\n    }\n  }\n}\nfunction _getQueueContexts() {\n  let path = this;\n  let contexts = this.contexts;\n  while (!contexts.length) {\n    path = path.parentPath;\n    if (!path) break;\n    contexts = path.contexts;\n  }\n  return contexts;\n}\n\n//# sourceMappingURL=context.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGJhYmVsL3RyYXZlcnNlL2xpYi9wYXRoL2NvbnRleHQuanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWIsOENBQTZDO0FBQzdDO0FBQ0EsQ0FBQyxFQUFDO0FBQ0YsYUFBYTtBQUNiLHNCQUFzQjtBQUN0Qix5QkFBeUI7QUFDekIsa0JBQWtCO0FBQ2xCLG1CQUFtQjtBQUNuQixxQkFBcUI7QUFDckIsc0JBQXNCO0FBQ3RCLFlBQVk7QUFDWixvQkFBb0I7QUFDcEIsa0JBQWtCO0FBQ2xCLG1CQUFtQjtBQUNuQixlQUFlO0FBQ2YsdUNBQXVDO0FBQ3ZDLGNBQWM7QUFDZCxrQkFBa0I7QUFDbEIsY0FBYztBQUNkLGdCQUFnQjtBQUNoQixhQUFhO0FBQ2IsWUFBWTtBQUNaLGVBQWU7QUFDZixZQUFZO0FBQ1osYUFBYTtBQUNiLG9CQUFvQixtQkFBTyxDQUFDLHNGQUFxQjtBQUNqRCxhQUFhLG1CQUFPLENBQUMsMEVBQVk7QUFDakMsZUFBZSxtQkFBTyxDQUFDLDhFQUFjO0FBQ3JDLFFBQVEsbUJBQU8sQ0FBQyxvRUFBYztBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUVBQXFFLEdBQUc7QUFDeEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQiwyQkFBMkI7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcmVwby12aXN1YWxpemVyLy4vbm9kZV9tb2R1bGVzL0BiYWJlbC90cmF2ZXJzZS9saWIvcGF0aC9jb250ZXh0LmpzP2MyNzAiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLl9jYWxsID0gX2NhbGw7XG5leHBvcnRzLl9mb3JjZVNldFNjb3BlID0gX2ZvcmNlU2V0U2NvcGU7XG5leHBvcnRzLl9nZXRRdWV1ZUNvbnRleHRzID0gX2dldFF1ZXVlQ29udGV4dHM7XG5leHBvcnRzLl9yZXN5bmNLZXkgPSBfcmVzeW5jS2V5O1xuZXhwb3J0cy5fcmVzeW5jTGlzdCA9IF9yZXN5bmNMaXN0O1xuZXhwb3J0cy5fcmVzeW5jUGFyZW50ID0gX3Jlc3luY1BhcmVudDtcbmV4cG9ydHMuX3Jlc3luY1JlbW92ZWQgPSBfcmVzeW5jUmVtb3ZlZDtcbmV4cG9ydHMuY2FsbCA9IGNhbGw7XG5leHBvcnRzLmlzRGVueWxpc3RlZCA9IGlzRGVueWxpc3RlZDtcbmV4cG9ydHMucG9wQ29udGV4dCA9IHBvcENvbnRleHQ7XG5leHBvcnRzLnB1c2hDb250ZXh0ID0gcHVzaENvbnRleHQ7XG5leHBvcnRzLnJlcXVldWUgPSByZXF1ZXVlO1xuZXhwb3J0cy5yZXF1ZXVlQ29tcHV0ZWRLZXlBbmREZWNvcmF0b3JzID0gcmVxdWV1ZUNvbXB1dGVkS2V5QW5kRGVjb3JhdG9ycztcbmV4cG9ydHMucmVzeW5jID0gcmVzeW5jO1xuZXhwb3J0cy5zZXRDb250ZXh0ID0gc2V0Q29udGV4dDtcbmV4cG9ydHMuc2V0S2V5ID0gc2V0S2V5O1xuZXhwb3J0cy5zZXRTY29wZSA9IHNldFNjb3BlO1xuZXhwb3J0cy5zZXR1cCA9IHNldHVwO1xuZXhwb3J0cy5za2lwID0gc2tpcDtcbmV4cG9ydHMuc2tpcEtleSA9IHNraXBLZXk7XG5leHBvcnRzLnN0b3AgPSBzdG9wO1xuZXhwb3J0cy52aXNpdCA9IHZpc2l0O1xudmFyIF90cmF2ZXJzZU5vZGUgPSByZXF1aXJlKFwiLi4vdHJhdmVyc2Utbm9kZS5qc1wiKTtcbnZhciBfaW5kZXggPSByZXF1aXJlKFwiLi9pbmRleC5qc1wiKTtcbnZhciBfcmVtb3ZhbCA9IHJlcXVpcmUoXCIuL3JlbW92YWwuanNcIik7XG52YXIgdCA9IHJlcXVpcmUoXCJAYmFiZWwvdHlwZXNcIik7XG5mdW5jdGlvbiBjYWxsKGtleSkge1xuICBjb25zdCBvcHRzID0gdGhpcy5vcHRzO1xuICB0aGlzLmRlYnVnKGtleSk7XG4gIGlmICh0aGlzLm5vZGUpIHtcbiAgICBpZiAoX2NhbGwuY2FsbCh0aGlzLCBvcHRzW2tleV0pKSByZXR1cm4gdHJ1ZTtcbiAgfVxuICBpZiAodGhpcy5ub2RlKSB7XG4gICAgdmFyIF9vcHRzJHRoaXMkbm9kZSR0eXBlO1xuICAgIHJldHVybiBfY2FsbC5jYWxsKHRoaXMsIChfb3B0cyR0aGlzJG5vZGUkdHlwZSA9IG9wdHNbdGhpcy5ub2RlLnR5cGVdKSA9PSBudWxsID8gdm9pZCAwIDogX29wdHMkdGhpcyRub2RlJHR5cGVba2V5XSk7XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufVxuZnVuY3Rpb24gX2NhbGwoZm5zKSB7XG4gIGlmICghZm5zKSByZXR1cm4gZmFsc2U7XG4gIGZvciAoY29uc3QgZm4gb2YgZm5zKSB7XG4gICAgaWYgKCFmbikgY29udGludWU7XG4gICAgY29uc3Qgbm9kZSA9IHRoaXMubm9kZTtcbiAgICBpZiAoIW5vZGUpIHJldHVybiB0cnVlO1xuICAgIGNvbnN0IHJldCA9IGZuLmNhbGwodGhpcy5zdGF0ZSwgdGhpcywgdGhpcy5zdGF0ZSk7XG4gICAgaWYgKHJldCAmJiB0eXBlb2YgcmV0ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiByZXQudGhlbiA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYFlvdSBhcHBlYXIgdG8gYmUgdXNpbmcgYSBwbHVnaW4gd2l0aCBhbiBhc3luYyB0cmF2ZXJzYWwgdmlzaXRvciwgYCArIGB3aGljaCB5b3VyIGN1cnJlbnQgdmVyc2lvbiBvZiBCYWJlbCBkb2VzIG5vdCBzdXBwb3J0LiBgICsgYElmIHlvdSdyZSB1c2luZyBhIHB1Ymxpc2hlZCBwbHVnaW4sIHlvdSBtYXkgbmVlZCB0byB1cGdyYWRlIGAgKyBgeW91ciBAYmFiZWwvY29yZSB2ZXJzaW9uLmApO1xuICAgIH1cbiAgICBpZiAocmV0KSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYFVuZXhwZWN0ZWQgcmV0dXJuIHZhbHVlIGZyb20gdmlzaXRvciBtZXRob2QgJHtmbn1gKTtcbiAgICB9XG4gICAgaWYgKHRoaXMubm9kZSAhPT0gbm9kZSkgcmV0dXJuIHRydWU7XG4gICAgaWYgKHRoaXMuX3RyYXZlcnNlRmxhZ3MgPiAwKSByZXR1cm4gdHJ1ZTtcbiAgfVxuICByZXR1cm4gZmFsc2U7XG59XG5mdW5jdGlvbiBpc0RlbnlsaXN0ZWQoKSB7XG4gIHZhciBfdGhpcyRvcHRzJGRlbnlsaXN0O1xuICBjb25zdCBkZW55bGlzdCA9IChfdGhpcyRvcHRzJGRlbnlsaXN0ID0gdGhpcy5vcHRzLmRlbnlsaXN0KSAhPSBudWxsID8gX3RoaXMkb3B0cyRkZW55bGlzdCA6IHRoaXMub3B0cy5ibGFja2xpc3Q7XG4gIHJldHVybiBkZW55bGlzdCA9PSBudWxsID8gdm9pZCAwIDogZGVueWxpc3QuaW5jbHVkZXModGhpcy5ub2RlLnR5cGUpO1xufVxuZXhwb3J0cy5pc0JsYWNrbGlzdGVkID0gaXNEZW55bGlzdGVkO1xuZnVuY3Rpb24gcmVzdG9yZUNvbnRleHQocGF0aCwgY29udGV4dCkge1xuICBpZiAocGF0aC5jb250ZXh0ICE9PSBjb250ZXh0KSB7XG4gICAgcGF0aC5jb250ZXh0ID0gY29udGV4dDtcbiAgICBwYXRoLnN0YXRlID0gY29udGV4dC5zdGF0ZTtcbiAgICBwYXRoLm9wdHMgPSBjb250ZXh0Lm9wdHM7XG4gIH1cbn1cbmZ1bmN0aW9uIHZpc2l0KCkge1xuICB2YXIgX3RoaXMkb3B0cyRzaG91bGRTa2lwLCBfdGhpcyRvcHRzO1xuICBpZiAoIXRoaXMubm9kZSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBpZiAodGhpcy5pc0RlbnlsaXN0ZWQoKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBpZiAoKF90aGlzJG9wdHMkc2hvdWxkU2tpcCA9IChfdGhpcyRvcHRzID0gdGhpcy5vcHRzKS5zaG91bGRTa2lwKSAhPSBudWxsICYmIF90aGlzJG9wdHMkc2hvdWxkU2tpcC5jYWxsKF90aGlzJG9wdHMsIHRoaXMpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGNvbnN0IGN1cnJlbnRDb250ZXh0ID0gdGhpcy5jb250ZXh0O1xuICBpZiAodGhpcy5zaG91bGRTa2lwIHx8IGNhbGwuY2FsbCh0aGlzLCBcImVudGVyXCIpKSB7XG4gICAgdGhpcy5kZWJ1ZyhcIlNraXAuLi5cIik7XG4gICAgcmV0dXJuIHRoaXMuc2hvdWxkU3RvcDtcbiAgfVxuICByZXN0b3JlQ29udGV4dCh0aGlzLCBjdXJyZW50Q29udGV4dCk7XG4gIHRoaXMuZGVidWcoXCJSZWN1cnNpbmcgaW50by4uLlwiKTtcbiAgdGhpcy5zaG91bGRTdG9wID0gKDAsIF90cmF2ZXJzZU5vZGUudHJhdmVyc2VOb2RlKSh0aGlzLm5vZGUsIHRoaXMub3B0cywgdGhpcy5zY29wZSwgdGhpcy5zdGF0ZSwgdGhpcywgdGhpcy5za2lwS2V5cyk7XG4gIHJlc3RvcmVDb250ZXh0KHRoaXMsIGN1cnJlbnRDb250ZXh0KTtcbiAgY2FsbC5jYWxsKHRoaXMsIFwiZXhpdFwiKTtcbiAgcmV0dXJuIHRoaXMuc2hvdWxkU3RvcDtcbn1cbmZ1bmN0aW9uIHNraXAoKSB7XG4gIHRoaXMuc2hvdWxkU2tpcCA9IHRydWU7XG59XG5mdW5jdGlvbiBza2lwS2V5KGtleSkge1xuICBpZiAodGhpcy5za2lwS2V5cyA9PSBudWxsKSB7XG4gICAgdGhpcy5za2lwS2V5cyA9IHt9O1xuICB9XG4gIHRoaXMuc2tpcEtleXNba2V5XSA9IHRydWU7XG59XG5mdW5jdGlvbiBzdG9wKCkge1xuICB0aGlzLl90cmF2ZXJzZUZsYWdzIHw9IF9pbmRleC5TSE9VTERfU0tJUCB8IF9pbmRleC5TSE9VTERfU1RPUDtcbn1cbmZ1bmN0aW9uIF9mb3JjZVNldFNjb3BlKCkge1xuICB2YXIgX3RoaXMkc2NvcGU7XG4gIGxldCBwYXRoID0gdGhpcy5wYXJlbnRQYXRoO1xuICBpZiAoKHRoaXMua2V5ID09PSBcImtleVwiIHx8IHRoaXMubGlzdEtleSA9PT0gXCJkZWNvcmF0b3JzXCIpICYmIHBhdGguaXNNZXRob2QoKSB8fCB0aGlzLmtleSA9PT0gXCJkaXNjcmltaW5hbnRcIiAmJiBwYXRoLmlzU3dpdGNoU3RhdGVtZW50KCkpIHtcbiAgICBwYXRoID0gcGF0aC5wYXJlbnRQYXRoO1xuICB9XG4gIGxldCB0YXJnZXQ7XG4gIHdoaWxlIChwYXRoICYmICF0YXJnZXQpIHtcbiAgICB0YXJnZXQgPSBwYXRoLnNjb3BlO1xuICAgIHBhdGggPSBwYXRoLnBhcmVudFBhdGg7XG4gIH1cbiAgdGhpcy5zY29wZSA9IHRoaXMuZ2V0U2NvcGUodGFyZ2V0KTtcbiAgKF90aGlzJHNjb3BlID0gdGhpcy5zY29wZSkgPT0gbnVsbCB8fCBfdGhpcyRzY29wZS5pbml0KCk7XG59XG5mdW5jdGlvbiBzZXRTY29wZSgpIHtcbiAgdmFyIF90aGlzJG9wdHMyLCBfdGhpcyRzY29wZTI7XG4gIGlmICgoX3RoaXMkb3B0czIgPSB0aGlzLm9wdHMpICE9IG51bGwgJiYgX3RoaXMkb3B0czIubm9TY29wZSkgcmV0dXJuO1xuICBsZXQgcGF0aCA9IHRoaXMucGFyZW50UGF0aDtcbiAgaWYgKCh0aGlzLmtleSA9PT0gXCJrZXlcIiB8fCB0aGlzLmxpc3RLZXkgPT09IFwiZGVjb3JhdG9yc1wiKSAmJiBwYXRoLmlzTWV0aG9kKCkgfHwgdGhpcy5rZXkgPT09IFwiZGlzY3JpbWluYW50XCIgJiYgcGF0aC5pc1N3aXRjaFN0YXRlbWVudCgpKSB7XG4gICAgcGF0aCA9IHBhdGgucGFyZW50UGF0aDtcbiAgfVxuICBsZXQgdGFyZ2V0O1xuICB3aGlsZSAocGF0aCAmJiAhdGFyZ2V0KSB7XG4gICAgdmFyIF9wYXRoJG9wdHM7XG4gICAgaWYgKChfcGF0aCRvcHRzID0gcGF0aC5vcHRzKSAhPSBudWxsICYmIF9wYXRoJG9wdHMubm9TY29wZSkgcmV0dXJuO1xuICAgIHRhcmdldCA9IHBhdGguc2NvcGU7XG4gICAgcGF0aCA9IHBhdGgucGFyZW50UGF0aDtcbiAgfVxuICB0aGlzLnNjb3BlID0gdGhpcy5nZXRTY29wZSh0YXJnZXQpO1xuICAoX3RoaXMkc2NvcGUyID0gdGhpcy5zY29wZSkgPT0gbnVsbCB8fCBfdGhpcyRzY29wZTIuaW5pdCgpO1xufVxuZnVuY3Rpb24gc2V0Q29udGV4dChjb250ZXh0KSB7XG4gIGlmICh0aGlzLnNraXBLZXlzICE9IG51bGwpIHtcbiAgICB0aGlzLnNraXBLZXlzID0ge307XG4gIH1cbiAgdGhpcy5fdHJhdmVyc2VGbGFncyA9IDA7XG4gIGlmIChjb250ZXh0KSB7XG4gICAgdGhpcy5jb250ZXh0ID0gY29udGV4dDtcbiAgICB0aGlzLnN0YXRlID0gY29udGV4dC5zdGF0ZTtcbiAgICB0aGlzLm9wdHMgPSBjb250ZXh0Lm9wdHM7XG4gIH1cbiAgc2V0U2NvcGUuY2FsbCh0aGlzKTtcbiAgcmV0dXJuIHRoaXM7XG59XG5mdW5jdGlvbiByZXN5bmMoKSB7XG4gIGlmICh0aGlzLnJlbW92ZWQpIHJldHVybjtcbiAgX3Jlc3luY1BhcmVudC5jYWxsKHRoaXMpO1xuICBfcmVzeW5jTGlzdC5jYWxsKHRoaXMpO1xuICBfcmVzeW5jS2V5LmNhbGwodGhpcyk7XG59XG5mdW5jdGlvbiBfcmVzeW5jUGFyZW50KCkge1xuICBpZiAodGhpcy5wYXJlbnRQYXRoKSB7XG4gICAgdGhpcy5wYXJlbnQgPSB0aGlzLnBhcmVudFBhdGgubm9kZTtcbiAgfVxufVxuZnVuY3Rpb24gX3Jlc3luY0tleSgpIHtcbiAgaWYgKCF0aGlzLmNvbnRhaW5lcikgcmV0dXJuO1xuICBpZiAodGhpcy5ub2RlID09PSB0aGlzLmNvbnRhaW5lclt0aGlzLmtleV0pIHtcbiAgICByZXR1cm47XG4gIH1cbiAgaWYgKEFycmF5LmlzQXJyYXkodGhpcy5jb250YWluZXIpKSB7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLmNvbnRhaW5lci5sZW5ndGg7IGkrKykge1xuICAgICAgaWYgKHRoaXMuY29udGFpbmVyW2ldID09PSB0aGlzLm5vZGUpIHtcbiAgICAgICAgc2V0S2V5LmNhbGwodGhpcywgaSk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgZm9yIChjb25zdCBrZXkgb2YgT2JqZWN0LmtleXModGhpcy5jb250YWluZXIpKSB7XG4gICAgICBpZiAodGhpcy5jb250YWluZXJba2V5XSA9PT0gdGhpcy5ub2RlKSB7XG4gICAgICAgIHNldEtleS5jYWxsKHRoaXMsIGtleSk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgdGhpcy5rZXkgPSBudWxsO1xufVxuZnVuY3Rpb24gX3Jlc3luY0xpc3QoKSB7XG4gIGlmICghdGhpcy5wYXJlbnQgfHwgIXRoaXMuaW5MaXN0KSByZXR1cm47XG4gIGNvbnN0IG5ld0NvbnRhaW5lciA9IHRoaXMucGFyZW50W3RoaXMubGlzdEtleV07XG4gIGlmICh0aGlzLmNvbnRhaW5lciA9PT0gbmV3Q29udGFpbmVyKSByZXR1cm47XG4gIHRoaXMuY29udGFpbmVyID0gbmV3Q29udGFpbmVyIHx8IG51bGw7XG59XG5mdW5jdGlvbiBfcmVzeW5jUmVtb3ZlZCgpIHtcbiAgaWYgKHRoaXMua2V5ID09IG51bGwgfHwgIXRoaXMuY29udGFpbmVyIHx8IHRoaXMuY29udGFpbmVyW3RoaXMua2V5XSAhPT0gdGhpcy5ub2RlKSB7XG4gICAgX3JlbW92YWwuX21hcmtSZW1vdmVkLmNhbGwodGhpcyk7XG4gIH1cbn1cbmZ1bmN0aW9uIHBvcENvbnRleHQoKSB7XG4gIHRoaXMuY29udGV4dHMucG9wKCk7XG4gIGlmICh0aGlzLmNvbnRleHRzLmxlbmd0aCA+IDApIHtcbiAgICB0aGlzLnNldENvbnRleHQodGhpcy5jb250ZXh0c1t0aGlzLmNvbnRleHRzLmxlbmd0aCAtIDFdKTtcbiAgfSBlbHNlIHtcbiAgICB0aGlzLnNldENvbnRleHQodW5kZWZpbmVkKTtcbiAgfVxufVxuZnVuY3Rpb24gcHVzaENvbnRleHQoY29udGV4dCkge1xuICB0aGlzLmNvbnRleHRzLnB1c2goY29udGV4dCk7XG4gIHRoaXMuc2V0Q29udGV4dChjb250ZXh0KTtcbn1cbmZ1bmN0aW9uIHNldHVwKHBhcmVudFBhdGgsIGNvbnRhaW5lciwgbGlzdEtleSwga2V5KSB7XG4gIHRoaXMubGlzdEtleSA9IGxpc3RLZXk7XG4gIHRoaXMuY29udGFpbmVyID0gY29udGFpbmVyO1xuICB0aGlzLnBhcmVudFBhdGggPSBwYXJlbnRQYXRoIHx8IHRoaXMucGFyZW50UGF0aDtcbiAgc2V0S2V5LmNhbGwodGhpcywga2V5KTtcbn1cbmZ1bmN0aW9uIHNldEtleShrZXkpIHtcbiAgdmFyIF90aGlzJG5vZGU7XG4gIHRoaXMua2V5ID0ga2V5O1xuICB0aGlzLm5vZGUgPSB0aGlzLmNvbnRhaW5lclt0aGlzLmtleV07XG4gIHRoaXMudHlwZSA9IChfdGhpcyRub2RlID0gdGhpcy5ub2RlKSA9PSBudWxsID8gdm9pZCAwIDogX3RoaXMkbm9kZS50eXBlO1xufVxuZnVuY3Rpb24gcmVxdWV1ZShwYXRoVG9RdWV1ZSA9IHRoaXMpIHtcbiAgaWYgKHBhdGhUb1F1ZXVlLnJlbW92ZWQpIHJldHVybjtcbiAgY29uc3QgY29udGV4dHMgPSB0aGlzLmNvbnRleHRzO1xuICBmb3IgKGNvbnN0IGNvbnRleHQgb2YgY29udGV4dHMpIHtcbiAgICBjb250ZXh0Lm1heWJlUXVldWUocGF0aFRvUXVldWUpO1xuICB9XG59XG5mdW5jdGlvbiByZXF1ZXVlQ29tcHV0ZWRLZXlBbmREZWNvcmF0b3JzKCkge1xuICBjb25zdCB7XG4gICAgY29udGV4dCxcbiAgICBub2RlXG4gIH0gPSB0aGlzO1xuICBpZiAoIXQuaXNQcml2YXRlKG5vZGUpICYmIG5vZGUuY29tcHV0ZWQpIHtcbiAgICBjb250ZXh0Lm1heWJlUXVldWUodGhpcy5nZXQoXCJrZXlcIikpO1xuICB9XG4gIGlmIChub2RlLmRlY29yYXRvcnMpIHtcbiAgICBmb3IgKGNvbnN0IGRlY29yYXRvciBvZiB0aGlzLmdldChcImRlY29yYXRvcnNcIikpIHtcbiAgICAgIGNvbnRleHQubWF5YmVRdWV1ZShkZWNvcmF0b3IpO1xuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gX2dldFF1ZXVlQ29udGV4dHMoKSB7XG4gIGxldCBwYXRoID0gdGhpcztcbiAgbGV0IGNvbnRleHRzID0gdGhpcy5jb250ZXh0cztcbiAgd2hpbGUgKCFjb250ZXh0cy5sZW5ndGgpIHtcbiAgICBwYXRoID0gcGF0aC5wYXJlbnRQYXRoO1xuICAgIGlmICghcGF0aCkgYnJlYWs7XG4gICAgY29udGV4dHMgPSBwYXRoLmNvbnRleHRzO1xuICB9XG4gIHJldHVybiBjb250ZXh0cztcbn1cblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y29udGV4dC5qcy5tYXBcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@babel/traverse/lib/path/context.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@babel/traverse/lib/path/conversion.js":
/*!*************************************************************!*\
  !*** ./node_modules/@babel/traverse/lib/path/conversion.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports.arrowFunctionToExpression = arrowFunctionToExpression;\nexports.ensureBlock = ensureBlock;\nexports.ensureFunctionName = ensureFunctionName;\nexports.splitExportDeclaration = splitExportDeclaration;\nexports.toComputedKey = toComputedKey;\nexports.unwrapFunctionEnvironment = unwrapFunctionEnvironment;\nvar _t = __webpack_require__(/*! @babel/types */ \"(ssr)/./node_modules/@babel/types/lib/index.js\");\nvar _template = __webpack_require__(/*! @babel/template */ \"(ssr)/./node_modules/@babel/template/lib/index.js\");\nvar _visitors = __webpack_require__(/*! ../visitors.js */ \"(ssr)/./node_modules/@babel/traverse/lib/visitors.js\");\nvar _context = __webpack_require__(/*! ./context.js */ \"(ssr)/./node_modules/@babel/traverse/lib/path/context.js\");\nconst {\n  arrowFunctionExpression,\n  assignmentExpression,\n  binaryExpression,\n  blockStatement,\n  callExpression,\n  conditionalExpression,\n  expressionStatement,\n  identifier,\n  isIdentifier,\n  jsxIdentifier,\n  logicalExpression,\n  LOGICAL_OPERATORS,\n  memberExpression,\n  metaProperty,\n  numericLiteral,\n  objectExpression,\n  restElement,\n  returnStatement,\n  sequenceExpression,\n  spreadElement,\n  stringLiteral,\n  super: _super,\n  thisExpression,\n  toExpression,\n  unaryExpression,\n  toBindingIdentifierName,\n  isFunction,\n  isAssignmentPattern,\n  isRestElement,\n  getFunctionName,\n  cloneNode,\n  variableDeclaration,\n  variableDeclarator,\n  exportNamedDeclaration,\n  exportSpecifier,\n  inherits\n} = _t;\nfunction toComputedKey() {\n  let key;\n  if (this.isMemberExpression()) {\n    key = this.node.property;\n  } else if (this.isProperty() || this.isMethod()) {\n    key = this.node.key;\n  } else {\n    throw new ReferenceError(\"todo\");\n  }\n  if (!this.node.computed) {\n    if (isIdentifier(key)) key = stringLiteral(key.name);\n  }\n  return key;\n}\nfunction ensureBlock() {\n  const body = this.get(\"body\");\n  const bodyNode = body.node;\n  if (Array.isArray(body)) {\n    throw new Error(\"Can't convert array path to a block statement\");\n  }\n  if (!bodyNode) {\n    throw new Error(\"Can't convert node without a body\");\n  }\n  if (body.isBlockStatement()) {\n    return bodyNode;\n  }\n  const statements = [];\n  let stringPath = \"body\";\n  let key;\n  let listKey;\n  if (body.isStatement()) {\n    listKey = \"body\";\n    key = 0;\n    statements.push(body.node);\n  } else {\n    stringPath += \".body.0\";\n    if (this.isFunction()) {\n      key = \"argument\";\n      statements.push(returnStatement(body.node));\n    } else {\n      key = \"expression\";\n      statements.push(expressionStatement(body.node));\n    }\n  }\n  this.node.body = blockStatement(statements);\n  const parentPath = this.get(stringPath);\n  _context.setup.call(body, parentPath, listKey ? parentPath.node[listKey] : parentPath.node, listKey, key);\n  return this.node;\n}\nexports.arrowFunctionToShadowed = function () {\n  if (!this.isArrowFunctionExpression()) return;\n  this.arrowFunctionToExpression();\n};\nfunction unwrapFunctionEnvironment() {\n  if (!this.isArrowFunctionExpression() && !this.isFunctionExpression() && !this.isFunctionDeclaration()) {\n    throw this.buildCodeFrameError(\"Can only unwrap the environment of a function.\");\n  }\n  hoistFunctionEnvironment(this);\n}\nfunction setType(path, type) {\n  path.node.type = type;\n}\nfunction arrowFunctionToExpression({\n  allowInsertArrow = true,\n  allowInsertArrowWithRest = allowInsertArrow,\n  noNewArrows = !(_arguments$ => (_arguments$ = arguments[0]) == null ? void 0 : _arguments$.specCompliant)()\n} = {}) {\n  if (!this.isArrowFunctionExpression()) {\n    throw this.buildCodeFrameError(\"Cannot convert non-arrow function to a function expression.\");\n  }\n  let self = this;\n  if (!noNewArrows) {\n    var _self$ensureFunctionN;\n    self = (_self$ensureFunctionN = self.ensureFunctionName(false)) != null ? _self$ensureFunctionN : self;\n  }\n  const {\n    thisBinding,\n    fnPath: fn\n  } = hoistFunctionEnvironment(self, noNewArrows, allowInsertArrow, allowInsertArrowWithRest);\n  fn.ensureBlock();\n  setType(fn, \"FunctionExpression\");\n  if (!noNewArrows) {\n    const checkBinding = thisBinding ? null : fn.scope.generateUidIdentifier(\"arrowCheckId\");\n    if (checkBinding) {\n      fn.parentPath.scope.push({\n        id: checkBinding,\n        init: objectExpression([])\n      });\n    }\n    fn.get(\"body\").unshiftContainer(\"body\", expressionStatement(callExpression(this.hub.addHelper(\"newArrowCheck\"), [thisExpression(), checkBinding ? identifier(checkBinding.name) : identifier(thisBinding)])));\n    fn.replaceWith(callExpression(memberExpression(fn.node, identifier(\"bind\")), [checkBinding ? identifier(checkBinding.name) : thisExpression()]));\n    return fn.get(\"callee.object\");\n  }\n  return fn;\n}\nconst getSuperCallsVisitor = (0, _visitors.environmentVisitor)({\n  CallExpression(child, {\n    allSuperCalls\n  }) {\n    if (!child.get(\"callee\").isSuper()) return;\n    allSuperCalls.push(child);\n  }\n});\nfunction hoistFunctionEnvironment(fnPath, noNewArrows = true, allowInsertArrow = true, allowInsertArrowWithRest = true) {\n  let arrowParent;\n  let thisEnvFn = fnPath.findParent(p => {\n    if (p.isArrowFunctionExpression()) {\n      arrowParent != null ? arrowParent : arrowParent = p;\n      return false;\n    }\n    return p.isFunction() || p.isProgram() || p.isClassProperty({\n      static: false\n    }) || p.isClassPrivateProperty({\n      static: false\n    });\n  });\n  const inConstructor = thisEnvFn.isClassMethod({\n    kind: \"constructor\"\n  });\n  if (thisEnvFn.isClassProperty() || thisEnvFn.isClassPrivateProperty()) {\n    if (arrowParent) {\n      thisEnvFn = arrowParent;\n    } else if (allowInsertArrow) {\n      fnPath.replaceWith(callExpression(arrowFunctionExpression([], toExpression(fnPath.node)), []));\n      thisEnvFn = fnPath.get(\"callee\");\n      fnPath = thisEnvFn.get(\"body\");\n    } else {\n      throw fnPath.buildCodeFrameError(\"Unable to transform arrow inside class property\");\n    }\n  }\n  const {\n    thisPaths,\n    argumentsPaths,\n    newTargetPaths,\n    superProps,\n    superCalls\n  } = getScopeInformation(fnPath);\n  if (inConstructor && superCalls.length > 0) {\n    if (!allowInsertArrow) {\n      throw superCalls[0].buildCodeFrameError(\"When using '@babel/plugin-transform-arrow-functions', \" + \"it's not possible to compile `super()` in an arrow function without compiling classes.\\n\" + \"Please add '@babel/plugin-transform-classes' to your Babel configuration.\");\n    }\n    if (!allowInsertArrowWithRest) {\n      throw superCalls[0].buildCodeFrameError(\"When using '@babel/plugin-transform-parameters', \" + \"it's not possible to compile `super()` in an arrow function with default or rest parameters without compiling classes.\\n\" + \"Please add '@babel/plugin-transform-classes' to your Babel configuration.\");\n    }\n    const allSuperCalls = [];\n    thisEnvFn.traverse(getSuperCallsVisitor, {\n      allSuperCalls\n    });\n    const superBinding = getSuperBinding(thisEnvFn);\n    allSuperCalls.forEach(superCall => {\n      const callee = identifier(superBinding);\n      callee.loc = superCall.node.callee.loc;\n      superCall.get(\"callee\").replaceWith(callee);\n    });\n  }\n  if (argumentsPaths.length > 0) {\n    const argumentsBinding = getBinding(thisEnvFn, \"arguments\", () => {\n      const args = () => identifier(\"arguments\");\n      if (thisEnvFn.scope.path.isProgram()) {\n        return conditionalExpression(binaryExpression(\"===\", unaryExpression(\"typeof\", args()), stringLiteral(\"undefined\")), thisEnvFn.scope.buildUndefinedNode(), args());\n      } else {\n        return args();\n      }\n    });\n    argumentsPaths.forEach(argumentsChild => {\n      const argsRef = identifier(argumentsBinding);\n      argsRef.loc = argumentsChild.node.loc;\n      argumentsChild.replaceWith(argsRef);\n    });\n  }\n  if (newTargetPaths.length > 0) {\n    const newTargetBinding = getBinding(thisEnvFn, \"newtarget\", () => metaProperty(identifier(\"new\"), identifier(\"target\")));\n    newTargetPaths.forEach(targetChild => {\n      const targetRef = identifier(newTargetBinding);\n      targetRef.loc = targetChild.node.loc;\n      targetChild.replaceWith(targetRef);\n    });\n  }\n  if (superProps.length > 0) {\n    if (!allowInsertArrow) {\n      throw superProps[0].buildCodeFrameError(\"When using '@babel/plugin-transform-arrow-functions', \" + \"it's not possible to compile `super.prop` in an arrow function without compiling classes.\\n\" + \"Please add '@babel/plugin-transform-classes' to your Babel configuration.\");\n    }\n    const flatSuperProps = superProps.reduce((acc, superProp) => acc.concat(standardizeSuperProperty(superProp)), []);\n    flatSuperProps.forEach(superProp => {\n      const key = superProp.node.computed ? \"\" : superProp.get(\"property\").node.name;\n      const superParentPath = superProp.parentPath;\n      const isAssignment = superParentPath.isAssignmentExpression({\n        left: superProp.node\n      });\n      const isCall = superParentPath.isCallExpression({\n        callee: superProp.node\n      });\n      const isTaggedTemplate = superParentPath.isTaggedTemplateExpression({\n        tag: superProp.node\n      });\n      const superBinding = getSuperPropBinding(thisEnvFn, isAssignment, key);\n      const args = [];\n      if (superProp.node.computed) {\n        args.push(superProp.get(\"property\").node);\n      }\n      if (isAssignment) {\n        const value = superParentPath.node.right;\n        args.push(value);\n      }\n      const call = callExpression(identifier(superBinding), args);\n      if (isCall) {\n        superParentPath.unshiftContainer(\"arguments\", thisExpression());\n        superProp.replaceWith(memberExpression(call, identifier(\"call\")));\n        thisPaths.push(superParentPath.get(\"arguments.0\"));\n      } else if (isAssignment) {\n        superParentPath.replaceWith(call);\n      } else if (isTaggedTemplate) {\n        superProp.replaceWith(callExpression(memberExpression(call, identifier(\"bind\"), false), [thisExpression()]));\n        thisPaths.push(superProp.get(\"arguments.0\"));\n      } else {\n        superProp.replaceWith(call);\n      }\n    });\n  }\n  let thisBinding;\n  if (thisPaths.length > 0 || !noNewArrows) {\n    thisBinding = getThisBinding(thisEnvFn, inConstructor);\n    if (noNewArrows || inConstructor && hasSuperClass(thisEnvFn)) {\n      thisPaths.forEach(thisChild => {\n        const thisRef = thisChild.isJSX() ? jsxIdentifier(thisBinding) : identifier(thisBinding);\n        thisRef.loc = thisChild.node.loc;\n        thisChild.replaceWith(thisRef);\n      });\n      if (!noNewArrows) thisBinding = null;\n    }\n  }\n  return {\n    thisBinding: thisBinding,\n    fnPath\n  };\n}\nfunction isLogicalOp(op) {\n  return LOGICAL_OPERATORS.includes(op);\n}\nfunction standardizeSuperProperty(superProp) {\n  if (superProp.parentPath.isAssignmentExpression() && superProp.parentPath.node.operator !== \"=\") {\n    const assignmentPath = superProp.parentPath;\n    const op = assignmentPath.node.operator.slice(0, -1);\n    const value = assignmentPath.node.right;\n    const isLogicalAssignment = isLogicalOp(op);\n    if (superProp.node.computed) {\n      const tmp = superProp.scope.generateDeclaredUidIdentifier(\"tmp\");\n      const {\n        object,\n        property\n      } = superProp.node;\n      assignmentPath.get(\"left\").replaceWith(memberExpression(object, assignmentExpression(\"=\", tmp, property), true));\n      assignmentPath.get(\"right\").replaceWith(rightExpression(isLogicalAssignment ? \"=\" : op, memberExpression(object, identifier(tmp.name), true), value));\n    } else {\n      const object = superProp.node.object;\n      const property = superProp.node.property;\n      assignmentPath.get(\"left\").replaceWith(memberExpression(object, property));\n      assignmentPath.get(\"right\").replaceWith(rightExpression(isLogicalAssignment ? \"=\" : op, memberExpression(object, identifier(property.name)), value));\n    }\n    if (isLogicalAssignment) {\n      assignmentPath.replaceWith(logicalExpression(op, assignmentPath.node.left, assignmentPath.node.right));\n    } else {\n      assignmentPath.node.operator = \"=\";\n    }\n    return [assignmentPath.get(\"left\"), assignmentPath.get(\"right\").get(\"left\")];\n  } else if (superProp.parentPath.isUpdateExpression()) {\n    const updateExpr = superProp.parentPath;\n    const tmp = superProp.scope.generateDeclaredUidIdentifier(\"tmp\");\n    const computedKey = superProp.node.computed ? superProp.scope.generateDeclaredUidIdentifier(\"prop\") : null;\n    const parts = [assignmentExpression(\"=\", tmp, memberExpression(superProp.node.object, computedKey ? assignmentExpression(\"=\", computedKey, superProp.node.property) : superProp.node.property, superProp.node.computed)), assignmentExpression(\"=\", memberExpression(superProp.node.object, computedKey ? identifier(computedKey.name) : superProp.node.property, superProp.node.computed), binaryExpression(superProp.parentPath.node.operator[0], identifier(tmp.name), numericLiteral(1)))];\n    if (!superProp.parentPath.node.prefix) {\n      parts.push(identifier(tmp.name));\n    }\n    updateExpr.replaceWith(sequenceExpression(parts));\n    const left = updateExpr.get(\"expressions.0.right\");\n    const right = updateExpr.get(\"expressions.1.left\");\n    return [left, right];\n  }\n  return [superProp];\n  function rightExpression(op, left, right) {\n    if (op === \"=\") {\n      return assignmentExpression(\"=\", left, right);\n    } else {\n      return binaryExpression(op, left, right);\n    }\n  }\n}\nfunction hasSuperClass(thisEnvFn) {\n  return thisEnvFn.isClassMethod() && !!thisEnvFn.parentPath.parentPath.node.superClass;\n}\nconst assignSuperThisVisitor = (0, _visitors.environmentVisitor)({\n  CallExpression(child, {\n    supers,\n    thisBinding\n  }) {\n    if (!child.get(\"callee\").isSuper()) return;\n    if (supers.has(child.node)) return;\n    supers.add(child.node);\n    child.replaceWithMultiple([child.node, assignmentExpression(\"=\", identifier(thisBinding), identifier(\"this\"))]);\n  }\n});\nfunction getThisBinding(thisEnvFn, inConstructor) {\n  return getBinding(thisEnvFn, \"this\", thisBinding => {\n    if (!inConstructor || !hasSuperClass(thisEnvFn)) return thisExpression();\n    thisEnvFn.traverse(assignSuperThisVisitor, {\n      supers: new WeakSet(),\n      thisBinding\n    });\n  });\n}\nfunction getSuperBinding(thisEnvFn) {\n  return getBinding(thisEnvFn, \"supercall\", () => {\n    const argsBinding = thisEnvFn.scope.generateUidIdentifier(\"args\");\n    return arrowFunctionExpression([restElement(argsBinding)], callExpression(_super(), [spreadElement(identifier(argsBinding.name))]));\n  });\n}\nfunction getSuperPropBinding(thisEnvFn, isAssignment, propName) {\n  const op = isAssignment ? \"set\" : \"get\";\n  return getBinding(thisEnvFn, `superprop_${op}:${propName || \"\"}`, () => {\n    const argsList = [];\n    let fnBody;\n    if (propName) {\n      fnBody = memberExpression(_super(), identifier(propName));\n    } else {\n      const method = thisEnvFn.scope.generateUidIdentifier(\"prop\");\n      argsList.unshift(method);\n      fnBody = memberExpression(_super(), identifier(method.name), true);\n    }\n    if (isAssignment) {\n      const valueIdent = thisEnvFn.scope.generateUidIdentifier(\"value\");\n      argsList.push(valueIdent);\n      fnBody = assignmentExpression(\"=\", fnBody, identifier(valueIdent.name));\n    }\n    return arrowFunctionExpression(argsList, fnBody);\n  });\n}\nfunction getBinding(thisEnvFn, key, init) {\n  const cacheKey = \"binding:\" + key;\n  let data = thisEnvFn.getData(cacheKey);\n  if (!data) {\n    const id = thisEnvFn.scope.generateUidIdentifier(key);\n    data = id.name;\n    thisEnvFn.setData(cacheKey, data);\n    thisEnvFn.scope.push({\n      id: id,\n      init: init(data)\n    });\n  }\n  return data;\n}\nconst getScopeInformationVisitor = (0, _visitors.environmentVisitor)({\n  ThisExpression(child, {\n    thisPaths\n  }) {\n    thisPaths.push(child);\n  },\n  JSXIdentifier(child, {\n    thisPaths\n  }) {\n    if (child.node.name !== \"this\") return;\n    if (!child.parentPath.isJSXMemberExpression({\n      object: child.node\n    }) && !child.parentPath.isJSXOpeningElement({\n      name: child.node\n    })) {\n      return;\n    }\n    thisPaths.push(child);\n  },\n  CallExpression(child, {\n    superCalls\n  }) {\n    if (child.get(\"callee\").isSuper()) superCalls.push(child);\n  },\n  MemberExpression(child, {\n    superProps\n  }) {\n    if (child.get(\"object\").isSuper()) superProps.push(child);\n  },\n  Identifier(child, {\n    argumentsPaths\n  }) {\n    if (!child.isReferencedIdentifier({\n      name: \"arguments\"\n    })) return;\n    let curr = child.scope;\n    do {\n      if (curr.hasOwnBinding(\"arguments\")) {\n        curr.rename(\"arguments\");\n        return;\n      }\n      if (curr.path.isFunction() && !curr.path.isArrowFunctionExpression()) {\n        break;\n      }\n    } while (curr = curr.parent);\n    argumentsPaths.push(child);\n  },\n  MetaProperty(child, {\n    newTargetPaths\n  }) {\n    if (!child.get(\"meta\").isIdentifier({\n      name: \"new\"\n    })) return;\n    if (!child.get(\"property\").isIdentifier({\n      name: \"target\"\n    })) return;\n    newTargetPaths.push(child);\n  }\n});\nfunction getScopeInformation(fnPath) {\n  const thisPaths = [];\n  const argumentsPaths = [];\n  const newTargetPaths = [];\n  const superProps = [];\n  const superCalls = [];\n  fnPath.traverse(getScopeInformationVisitor, {\n    thisPaths,\n    argumentsPaths,\n    newTargetPaths,\n    superProps,\n    superCalls\n  });\n  return {\n    thisPaths,\n    argumentsPaths,\n    newTargetPaths,\n    superProps,\n    superCalls\n  };\n}\nfunction splitExportDeclaration() {\n  if (!this.isExportDeclaration() || this.isExportAllDeclaration()) {\n    throw new Error(\"Only default and named export declarations can be split.\");\n  }\n  if (this.isExportNamedDeclaration() && this.get(\"specifiers\").length > 0) {\n    throw new Error(\"It doesn't make sense to split exported specifiers.\");\n  }\n  const declaration = this.get(\"declaration\");\n  if (this.isExportDefaultDeclaration()) {\n    const standaloneDeclaration = declaration.isFunctionDeclaration() || declaration.isClassDeclaration();\n    const exportExpr = declaration.isFunctionExpression() || declaration.isClassExpression();\n    const scope = declaration.isScope() ? declaration.scope.parent : declaration.scope;\n    let id = declaration.node.id;\n    let needBindingRegistration = false;\n    if (!id) {\n      needBindingRegistration = true;\n      id = scope.generateUidIdentifier(\"default\");\n      if (standaloneDeclaration || exportExpr) {\n        declaration.node.id = cloneNode(id);\n      }\n    } else if (exportExpr && scope.hasBinding(id.name)) {\n      needBindingRegistration = true;\n      id = scope.generateUidIdentifier(id.name);\n    }\n    const updatedDeclaration = standaloneDeclaration ? declaration.node : variableDeclaration(\"var\", [variableDeclarator(cloneNode(id), declaration.node)]);\n    const updatedExportDeclaration = exportNamedDeclaration(null, [exportSpecifier(cloneNode(id), identifier(\"default\"))]);\n    this.insertAfter(updatedExportDeclaration);\n    this.replaceWith(updatedDeclaration);\n    if (needBindingRegistration) {\n      scope.registerDeclaration(this);\n    }\n    return this;\n  } else if (this.get(\"specifiers\").length > 0) {\n    throw new Error(\"It doesn't make sense to split exported specifiers.\");\n  }\n  const bindingIdentifiers = declaration.getOuterBindingIdentifiers();\n  const specifiers = Object.keys(bindingIdentifiers).map(name => {\n    return exportSpecifier(identifier(name), identifier(name));\n  });\n  const aliasDeclar = exportNamedDeclaration(null, specifiers);\n  this.insertAfter(aliasDeclar);\n  this.replaceWith(declaration.node);\n  return this;\n}\nconst refersOuterBindingVisitor = {\n  \"ReferencedIdentifier|BindingIdentifier\"(path, state) {\n    if (path.node.name !== state.name) return;\n    state.needsRename = true;\n    path.stop();\n  },\n  Scope(path, state) {\n    if (path.scope.hasOwnBinding(state.name)) {\n      path.skip();\n    }\n  }\n};\nfunction ensureFunctionName(supportUnicodeId) {\n  if (this.node.id) return this;\n  const res = getFunctionName(this.node, this.parent);\n  if (res == null) return this;\n  let {\n    name\n  } = res;\n  if (!supportUnicodeId && /[\\uD800-\\uDFFF]/.test(name)) {\n    return null;\n  }\n  if (name.startsWith(\"get \") || name.startsWith(\"set \")) {\n    return null;\n  }\n  name = toBindingIdentifierName(name.replace(/[/ ]/g, \"_\"));\n  const id = identifier(name);\n  inherits(id, res.originalNode);\n  const state = {\n    needsRename: false,\n    name\n  };\n  const {\n    scope\n  } = this;\n  const binding = scope.getOwnBinding(name);\n  if (binding) {\n    if (binding.kind === \"param\") {\n      state.needsRename = true;\n    } else {}\n  } else if (scope.parent.hasBinding(name) || scope.hasGlobal(name)) {\n    this.traverse(refersOuterBindingVisitor, state);\n  }\n  if (!state.needsRename) {\n    this.node.id = id;\n    scope.getProgramParent().references[id.name] = true;\n    return this;\n  }\n  if (scope.hasBinding(id.name) && !scope.hasGlobal(id.name)) {\n    scope.rename(id.name);\n    this.node.id = id;\n    scope.getProgramParent().references[id.name] = true;\n    return this;\n  }\n  if (!isFunction(this.node)) return null;\n  const key = scope.generateUidIdentifier(id.name);\n  const params = [];\n  for (let i = 0, len = getFunctionArity(this.node); i < len; i++) {\n    params.push(scope.generateUidIdentifier(\"x\"));\n  }\n  const call = _template.default.expression.ast`\n    (function (${key}) {\n      function ${id}(${params}) {\n        return ${cloneNode(key)}.apply(this, arguments);\n      }\n\n      ${cloneNode(id)}.toString = function () {\n        return ${cloneNode(key)}.toString();\n      }\n\n      return ${cloneNode(id)};\n    })(${toExpression(this.node)})\n  `;\n  return this.replaceWith(call)[0].get(\"arguments.0\");\n}\nfunction getFunctionArity(node) {\n  const count = node.params.findIndex(param => isAssignmentPattern(param) || isRestElement(param));\n  return count === -1 ? node.params.length : count;\n}\n\n//# sourceMappingURL=conversion.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGJhYmVsL3RyYXZlcnNlL2xpYi9wYXRoL2NvbnZlcnNpb24uanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWIsOENBQTZDO0FBQzdDO0FBQ0EsQ0FBQyxFQUFDO0FBQ0YsaUNBQWlDO0FBQ2pDLG1CQUFtQjtBQUNuQiwwQkFBMEI7QUFDMUIsOEJBQThCO0FBQzlCLHFCQUFxQjtBQUNyQixpQ0FBaUM7QUFDakMsU0FBUyxtQkFBTyxDQUFDLG9FQUFjO0FBQy9CLGdCQUFnQixtQkFBTyxDQUFDLDBFQUFpQjtBQUN6QyxnQkFBZ0IsbUJBQU8sQ0FBQyw0RUFBZ0I7QUFDeEMsZUFBZSxtQkFBTyxDQUFDLDhFQUFjO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0I7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFLElBQUk7QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLDRDQUE0QyxHQUFHLEdBQUcsZUFBZTtBQUNqRTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ04sSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscURBQXFELFNBQVM7QUFDOUQ7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLElBQUk7QUFDckIsaUJBQWlCLEdBQUcsR0FBRyxPQUFPO0FBQzlCLGlCQUFpQixlQUFlO0FBQ2hDOztBQUVBLFFBQVEsY0FBYztBQUN0QixpQkFBaUIsZUFBZTtBQUNoQzs7QUFFQSxlQUFlO0FBQ2YsS0FBSyxJQUFJLHdCQUF3QjtBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSIsInNvdXJjZXMiOlsid2VicGFjazovL3JlcG8tdmlzdWFsaXplci8uL25vZGVfbW9kdWxlcy9AYmFiZWwvdHJhdmVyc2UvbGliL3BhdGgvY29udmVyc2lvbi5qcz85ODY1Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5hcnJvd0Z1bmN0aW9uVG9FeHByZXNzaW9uID0gYXJyb3dGdW5jdGlvblRvRXhwcmVzc2lvbjtcbmV4cG9ydHMuZW5zdXJlQmxvY2sgPSBlbnN1cmVCbG9jaztcbmV4cG9ydHMuZW5zdXJlRnVuY3Rpb25OYW1lID0gZW5zdXJlRnVuY3Rpb25OYW1lO1xuZXhwb3J0cy5zcGxpdEV4cG9ydERlY2xhcmF0aW9uID0gc3BsaXRFeHBvcnREZWNsYXJhdGlvbjtcbmV4cG9ydHMudG9Db21wdXRlZEtleSA9IHRvQ29tcHV0ZWRLZXk7XG5leHBvcnRzLnVud3JhcEZ1bmN0aW9uRW52aXJvbm1lbnQgPSB1bndyYXBGdW5jdGlvbkVudmlyb25tZW50O1xudmFyIF90ID0gcmVxdWlyZShcIkBiYWJlbC90eXBlc1wiKTtcbnZhciBfdGVtcGxhdGUgPSByZXF1aXJlKFwiQGJhYmVsL3RlbXBsYXRlXCIpO1xudmFyIF92aXNpdG9ycyA9IHJlcXVpcmUoXCIuLi92aXNpdG9ycy5qc1wiKTtcbnZhciBfY29udGV4dCA9IHJlcXVpcmUoXCIuL2NvbnRleHQuanNcIik7XG5jb25zdCB7XG4gIGFycm93RnVuY3Rpb25FeHByZXNzaW9uLFxuICBhc3NpZ25tZW50RXhwcmVzc2lvbixcbiAgYmluYXJ5RXhwcmVzc2lvbixcbiAgYmxvY2tTdGF0ZW1lbnQsXG4gIGNhbGxFeHByZXNzaW9uLFxuICBjb25kaXRpb25hbEV4cHJlc3Npb24sXG4gIGV4cHJlc3Npb25TdGF0ZW1lbnQsXG4gIGlkZW50aWZpZXIsXG4gIGlzSWRlbnRpZmllcixcbiAganN4SWRlbnRpZmllcixcbiAgbG9naWNhbEV4cHJlc3Npb24sXG4gIExPR0lDQUxfT1BFUkFUT1JTLFxuICBtZW1iZXJFeHByZXNzaW9uLFxuICBtZXRhUHJvcGVydHksXG4gIG51bWVyaWNMaXRlcmFsLFxuICBvYmplY3RFeHByZXNzaW9uLFxuICByZXN0RWxlbWVudCxcbiAgcmV0dXJuU3RhdGVtZW50LFxuICBzZXF1ZW5jZUV4cHJlc3Npb24sXG4gIHNwcmVhZEVsZW1lbnQsXG4gIHN0cmluZ0xpdGVyYWwsXG4gIHN1cGVyOiBfc3VwZXIsXG4gIHRoaXNFeHByZXNzaW9uLFxuICB0b0V4cHJlc3Npb24sXG4gIHVuYXJ5RXhwcmVzc2lvbixcbiAgdG9CaW5kaW5nSWRlbnRpZmllck5hbWUsXG4gIGlzRnVuY3Rpb24sXG4gIGlzQXNzaWdubWVudFBhdHRlcm4sXG4gIGlzUmVzdEVsZW1lbnQsXG4gIGdldEZ1bmN0aW9uTmFtZSxcbiAgY2xvbmVOb2RlLFxuICB2YXJpYWJsZURlY2xhcmF0aW9uLFxuICB2YXJpYWJsZURlY2xhcmF0b3IsXG4gIGV4cG9ydE5hbWVkRGVjbGFyYXRpb24sXG4gIGV4cG9ydFNwZWNpZmllcixcbiAgaW5oZXJpdHNcbn0gPSBfdDtcbmZ1bmN0aW9uIHRvQ29tcHV0ZWRLZXkoKSB7XG4gIGxldCBrZXk7XG4gIGlmICh0aGlzLmlzTWVtYmVyRXhwcmVzc2lvbigpKSB7XG4gICAga2V5ID0gdGhpcy5ub2RlLnByb3BlcnR5O1xuICB9IGVsc2UgaWYgKHRoaXMuaXNQcm9wZXJ0eSgpIHx8IHRoaXMuaXNNZXRob2QoKSkge1xuICAgIGtleSA9IHRoaXMubm9kZS5rZXk7XG4gIH0gZWxzZSB7XG4gICAgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwidG9kb1wiKTtcbiAgfVxuICBpZiAoIXRoaXMubm9kZS5jb21wdXRlZCkge1xuICAgIGlmIChpc0lkZW50aWZpZXIoa2V5KSkga2V5ID0gc3RyaW5nTGl0ZXJhbChrZXkubmFtZSk7XG4gIH1cbiAgcmV0dXJuIGtleTtcbn1cbmZ1bmN0aW9uIGVuc3VyZUJsb2NrKCkge1xuICBjb25zdCBib2R5ID0gdGhpcy5nZXQoXCJib2R5XCIpO1xuICBjb25zdCBib2R5Tm9kZSA9IGJvZHkubm9kZTtcbiAgaWYgKEFycmF5LmlzQXJyYXkoYm9keSkpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW4ndCBjb252ZXJ0IGFycmF5IHBhdGggdG8gYSBibG9jayBzdGF0ZW1lbnRcIik7XG4gIH1cbiAgaWYgKCFib2R5Tm9kZSkge1xuICAgIHRocm93IG5ldyBFcnJvcihcIkNhbid0IGNvbnZlcnQgbm9kZSB3aXRob3V0IGEgYm9keVwiKTtcbiAgfVxuICBpZiAoYm9keS5pc0Jsb2NrU3RhdGVtZW50KCkpIHtcbiAgICByZXR1cm4gYm9keU5vZGU7XG4gIH1cbiAgY29uc3Qgc3RhdGVtZW50cyA9IFtdO1xuICBsZXQgc3RyaW5nUGF0aCA9IFwiYm9keVwiO1xuICBsZXQga2V5O1xuICBsZXQgbGlzdEtleTtcbiAgaWYgKGJvZHkuaXNTdGF0ZW1lbnQoKSkge1xuICAgIGxpc3RLZXkgPSBcImJvZHlcIjtcbiAgICBrZXkgPSAwO1xuICAgIHN0YXRlbWVudHMucHVzaChib2R5Lm5vZGUpO1xuICB9IGVsc2Uge1xuICAgIHN0cmluZ1BhdGggKz0gXCIuYm9keS4wXCI7XG4gICAgaWYgKHRoaXMuaXNGdW5jdGlvbigpKSB7XG4gICAgICBrZXkgPSBcImFyZ3VtZW50XCI7XG4gICAgICBzdGF0ZW1lbnRzLnB1c2gocmV0dXJuU3RhdGVtZW50KGJvZHkubm9kZSkpO1xuICAgIH0gZWxzZSB7XG4gICAgICBrZXkgPSBcImV4cHJlc3Npb25cIjtcbiAgICAgIHN0YXRlbWVudHMucHVzaChleHByZXNzaW9uU3RhdGVtZW50KGJvZHkubm9kZSkpO1xuICAgIH1cbiAgfVxuICB0aGlzLm5vZGUuYm9keSA9IGJsb2NrU3RhdGVtZW50KHN0YXRlbWVudHMpO1xuICBjb25zdCBwYXJlbnRQYXRoID0gdGhpcy5nZXQoc3RyaW5nUGF0aCk7XG4gIF9jb250ZXh0LnNldHVwLmNhbGwoYm9keSwgcGFyZW50UGF0aCwgbGlzdEtleSA/IHBhcmVudFBhdGgubm9kZVtsaXN0S2V5XSA6IHBhcmVudFBhdGgubm9kZSwgbGlzdEtleSwga2V5KTtcbiAgcmV0dXJuIHRoaXMubm9kZTtcbn1cbmV4cG9ydHMuYXJyb3dGdW5jdGlvblRvU2hhZG93ZWQgPSBmdW5jdGlvbiAoKSB7XG4gIGlmICghdGhpcy5pc0Fycm93RnVuY3Rpb25FeHByZXNzaW9uKCkpIHJldHVybjtcbiAgdGhpcy5hcnJvd0Z1bmN0aW9uVG9FeHByZXNzaW9uKCk7XG59O1xuZnVuY3Rpb24gdW53cmFwRnVuY3Rpb25FbnZpcm9ubWVudCgpIHtcbiAgaWYgKCF0aGlzLmlzQXJyb3dGdW5jdGlvbkV4cHJlc3Npb24oKSAmJiAhdGhpcy5pc0Z1bmN0aW9uRXhwcmVzc2lvbigpICYmICF0aGlzLmlzRnVuY3Rpb25EZWNsYXJhdGlvbigpKSB7XG4gICAgdGhyb3cgdGhpcy5idWlsZENvZGVGcmFtZUVycm9yKFwiQ2FuIG9ubHkgdW53cmFwIHRoZSBlbnZpcm9ubWVudCBvZiBhIGZ1bmN0aW9uLlwiKTtcbiAgfVxuICBob2lzdEZ1bmN0aW9uRW52aXJvbm1lbnQodGhpcyk7XG59XG5mdW5jdGlvbiBzZXRUeXBlKHBhdGgsIHR5cGUpIHtcbiAgcGF0aC5ub2RlLnR5cGUgPSB0eXBlO1xufVxuZnVuY3Rpb24gYXJyb3dGdW5jdGlvblRvRXhwcmVzc2lvbih7XG4gIGFsbG93SW5zZXJ0QXJyb3cgPSB0cnVlLFxuICBhbGxvd0luc2VydEFycm93V2l0aFJlc3QgPSBhbGxvd0luc2VydEFycm93LFxuICBub05ld0Fycm93cyA9ICEoX2FyZ3VtZW50cyQgPT4gKF9hcmd1bWVudHMkID0gYXJndW1lbnRzWzBdKSA9PSBudWxsID8gdm9pZCAwIDogX2FyZ3VtZW50cyQuc3BlY0NvbXBsaWFudCkoKVxufSA9IHt9KSB7XG4gIGlmICghdGhpcy5pc0Fycm93RnVuY3Rpb25FeHByZXNzaW9uKCkpIHtcbiAgICB0aHJvdyB0aGlzLmJ1aWxkQ29kZUZyYW1lRXJyb3IoXCJDYW5ub3QgY29udmVydCBub24tYXJyb3cgZnVuY3Rpb24gdG8gYSBmdW5jdGlvbiBleHByZXNzaW9uLlwiKTtcbiAgfVxuICBsZXQgc2VsZiA9IHRoaXM7XG4gIGlmICghbm9OZXdBcnJvd3MpIHtcbiAgICB2YXIgX3NlbGYkZW5zdXJlRnVuY3Rpb25OO1xuICAgIHNlbGYgPSAoX3NlbGYkZW5zdXJlRnVuY3Rpb25OID0gc2VsZi5lbnN1cmVGdW5jdGlvbk5hbWUoZmFsc2UpKSAhPSBudWxsID8gX3NlbGYkZW5zdXJlRnVuY3Rpb25OIDogc2VsZjtcbiAgfVxuICBjb25zdCB7XG4gICAgdGhpc0JpbmRpbmcsXG4gICAgZm5QYXRoOiBmblxuICB9ID0gaG9pc3RGdW5jdGlvbkVudmlyb25tZW50KHNlbGYsIG5vTmV3QXJyb3dzLCBhbGxvd0luc2VydEFycm93LCBhbGxvd0luc2VydEFycm93V2l0aFJlc3QpO1xuICBmbi5lbnN1cmVCbG9jaygpO1xuICBzZXRUeXBlKGZuLCBcIkZ1bmN0aW9uRXhwcmVzc2lvblwiKTtcbiAgaWYgKCFub05ld0Fycm93cykge1xuICAgIGNvbnN0IGNoZWNrQmluZGluZyA9IHRoaXNCaW5kaW5nID8gbnVsbCA6IGZuLnNjb3BlLmdlbmVyYXRlVWlkSWRlbnRpZmllcihcImFycm93Q2hlY2tJZFwiKTtcbiAgICBpZiAoY2hlY2tCaW5kaW5nKSB7XG4gICAgICBmbi5wYXJlbnRQYXRoLnNjb3BlLnB1c2goe1xuICAgICAgICBpZDogY2hlY2tCaW5kaW5nLFxuICAgICAgICBpbml0OiBvYmplY3RFeHByZXNzaW9uKFtdKVxuICAgICAgfSk7XG4gICAgfVxuICAgIGZuLmdldChcImJvZHlcIikudW5zaGlmdENvbnRhaW5lcihcImJvZHlcIiwgZXhwcmVzc2lvblN0YXRlbWVudChjYWxsRXhwcmVzc2lvbih0aGlzLmh1Yi5hZGRIZWxwZXIoXCJuZXdBcnJvd0NoZWNrXCIpLCBbdGhpc0V4cHJlc3Npb24oKSwgY2hlY2tCaW5kaW5nID8gaWRlbnRpZmllcihjaGVja0JpbmRpbmcubmFtZSkgOiBpZGVudGlmaWVyKHRoaXNCaW5kaW5nKV0pKSk7XG4gICAgZm4ucmVwbGFjZVdpdGgoY2FsbEV4cHJlc3Npb24obWVtYmVyRXhwcmVzc2lvbihmbi5ub2RlLCBpZGVudGlmaWVyKFwiYmluZFwiKSksIFtjaGVja0JpbmRpbmcgPyBpZGVudGlmaWVyKGNoZWNrQmluZGluZy5uYW1lKSA6IHRoaXNFeHByZXNzaW9uKCldKSk7XG4gICAgcmV0dXJuIGZuLmdldChcImNhbGxlZS5vYmplY3RcIik7XG4gIH1cbiAgcmV0dXJuIGZuO1xufVxuY29uc3QgZ2V0U3VwZXJDYWxsc1Zpc2l0b3IgPSAoMCwgX3Zpc2l0b3JzLmVudmlyb25tZW50VmlzaXRvcikoe1xuICBDYWxsRXhwcmVzc2lvbihjaGlsZCwge1xuICAgIGFsbFN1cGVyQ2FsbHNcbiAgfSkge1xuICAgIGlmICghY2hpbGQuZ2V0KFwiY2FsbGVlXCIpLmlzU3VwZXIoKSkgcmV0dXJuO1xuICAgIGFsbFN1cGVyQ2FsbHMucHVzaChjaGlsZCk7XG4gIH1cbn0pO1xuZnVuY3Rpb24gaG9pc3RGdW5jdGlvbkVudmlyb25tZW50KGZuUGF0aCwgbm9OZXdBcnJvd3MgPSB0cnVlLCBhbGxvd0luc2VydEFycm93ID0gdHJ1ZSwgYWxsb3dJbnNlcnRBcnJvd1dpdGhSZXN0ID0gdHJ1ZSkge1xuICBsZXQgYXJyb3dQYXJlbnQ7XG4gIGxldCB0aGlzRW52Rm4gPSBmblBhdGguZmluZFBhcmVudChwID0+IHtcbiAgICBpZiAocC5pc0Fycm93RnVuY3Rpb25FeHByZXNzaW9uKCkpIHtcbiAgICAgIGFycm93UGFyZW50ICE9IG51bGwgPyBhcnJvd1BhcmVudCA6IGFycm93UGFyZW50ID0gcDtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuIHAuaXNGdW5jdGlvbigpIHx8IHAuaXNQcm9ncmFtKCkgfHwgcC5pc0NsYXNzUHJvcGVydHkoe1xuICAgICAgc3RhdGljOiBmYWxzZVxuICAgIH0pIHx8IHAuaXNDbGFzc1ByaXZhdGVQcm9wZXJ0eSh7XG4gICAgICBzdGF0aWM6IGZhbHNlXG4gICAgfSk7XG4gIH0pO1xuICBjb25zdCBpbkNvbnN0cnVjdG9yID0gdGhpc0VudkZuLmlzQ2xhc3NNZXRob2Qoe1xuICAgIGtpbmQ6IFwiY29uc3RydWN0b3JcIlxuICB9KTtcbiAgaWYgKHRoaXNFbnZGbi5pc0NsYXNzUHJvcGVydHkoKSB8fCB0aGlzRW52Rm4uaXNDbGFzc1ByaXZhdGVQcm9wZXJ0eSgpKSB7XG4gICAgaWYgKGFycm93UGFyZW50KSB7XG4gICAgICB0aGlzRW52Rm4gPSBhcnJvd1BhcmVudDtcbiAgICB9IGVsc2UgaWYgKGFsbG93SW5zZXJ0QXJyb3cpIHtcbiAgICAgIGZuUGF0aC5yZXBsYWNlV2l0aChjYWxsRXhwcmVzc2lvbihhcnJvd0Z1bmN0aW9uRXhwcmVzc2lvbihbXSwgdG9FeHByZXNzaW9uKGZuUGF0aC5ub2RlKSksIFtdKSk7XG4gICAgICB0aGlzRW52Rm4gPSBmblBhdGguZ2V0KFwiY2FsbGVlXCIpO1xuICAgICAgZm5QYXRoID0gdGhpc0VudkZuLmdldChcImJvZHlcIik7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IGZuUGF0aC5idWlsZENvZGVGcmFtZUVycm9yKFwiVW5hYmxlIHRvIHRyYW5zZm9ybSBhcnJvdyBpbnNpZGUgY2xhc3MgcHJvcGVydHlcIik7XG4gICAgfVxuICB9XG4gIGNvbnN0IHtcbiAgICB0aGlzUGF0aHMsXG4gICAgYXJndW1lbnRzUGF0aHMsXG4gICAgbmV3VGFyZ2V0UGF0aHMsXG4gICAgc3VwZXJQcm9wcyxcbiAgICBzdXBlckNhbGxzXG4gIH0gPSBnZXRTY29wZUluZm9ybWF0aW9uKGZuUGF0aCk7XG4gIGlmIChpbkNvbnN0cnVjdG9yICYmIHN1cGVyQ2FsbHMubGVuZ3RoID4gMCkge1xuICAgIGlmICghYWxsb3dJbnNlcnRBcnJvdykge1xuICAgICAgdGhyb3cgc3VwZXJDYWxsc1swXS5idWlsZENvZGVGcmFtZUVycm9yKFwiV2hlbiB1c2luZyAnQGJhYmVsL3BsdWdpbi10cmFuc2Zvcm0tYXJyb3ctZnVuY3Rpb25zJywgXCIgKyBcIml0J3Mgbm90IHBvc3NpYmxlIHRvIGNvbXBpbGUgYHN1cGVyKClgIGluIGFuIGFycm93IGZ1bmN0aW9uIHdpdGhvdXQgY29tcGlsaW5nIGNsYXNzZXMuXFxuXCIgKyBcIlBsZWFzZSBhZGQgJ0BiYWJlbC9wbHVnaW4tdHJhbnNmb3JtLWNsYXNzZXMnIHRvIHlvdXIgQmFiZWwgY29uZmlndXJhdGlvbi5cIik7XG4gICAgfVxuICAgIGlmICghYWxsb3dJbnNlcnRBcnJvd1dpdGhSZXN0KSB7XG4gICAgICB0aHJvdyBzdXBlckNhbGxzWzBdLmJ1aWxkQ29kZUZyYW1lRXJyb3IoXCJXaGVuIHVzaW5nICdAYmFiZWwvcGx1Z2luLXRyYW5zZm9ybS1wYXJhbWV0ZXJzJywgXCIgKyBcIml0J3Mgbm90IHBvc3NpYmxlIHRvIGNvbXBpbGUgYHN1cGVyKClgIGluIGFuIGFycm93IGZ1bmN0aW9uIHdpdGggZGVmYXVsdCBvciByZXN0IHBhcmFtZXRlcnMgd2l0aG91dCBjb21waWxpbmcgY2xhc3Nlcy5cXG5cIiArIFwiUGxlYXNlIGFkZCAnQGJhYmVsL3BsdWdpbi10cmFuc2Zvcm0tY2xhc3NlcycgdG8geW91ciBCYWJlbCBjb25maWd1cmF0aW9uLlwiKTtcbiAgICB9XG4gICAgY29uc3QgYWxsU3VwZXJDYWxscyA9IFtdO1xuICAgIHRoaXNFbnZGbi50cmF2ZXJzZShnZXRTdXBlckNhbGxzVmlzaXRvciwge1xuICAgICAgYWxsU3VwZXJDYWxsc1xuICAgIH0pO1xuICAgIGNvbnN0IHN1cGVyQmluZGluZyA9IGdldFN1cGVyQmluZGluZyh0aGlzRW52Rm4pO1xuICAgIGFsbFN1cGVyQ2FsbHMuZm9yRWFjaChzdXBlckNhbGwgPT4ge1xuICAgICAgY29uc3QgY2FsbGVlID0gaWRlbnRpZmllcihzdXBlckJpbmRpbmcpO1xuICAgICAgY2FsbGVlLmxvYyA9IHN1cGVyQ2FsbC5ub2RlLmNhbGxlZS5sb2M7XG4gICAgICBzdXBlckNhbGwuZ2V0KFwiY2FsbGVlXCIpLnJlcGxhY2VXaXRoKGNhbGxlZSk7XG4gICAgfSk7XG4gIH1cbiAgaWYgKGFyZ3VtZW50c1BhdGhzLmxlbmd0aCA+IDApIHtcbiAgICBjb25zdCBhcmd1bWVudHNCaW5kaW5nID0gZ2V0QmluZGluZyh0aGlzRW52Rm4sIFwiYXJndW1lbnRzXCIsICgpID0+IHtcbiAgICAgIGNvbnN0IGFyZ3MgPSAoKSA9PiBpZGVudGlmaWVyKFwiYXJndW1lbnRzXCIpO1xuICAgICAgaWYgKHRoaXNFbnZGbi5zY29wZS5wYXRoLmlzUHJvZ3JhbSgpKSB7XG4gICAgICAgIHJldHVybiBjb25kaXRpb25hbEV4cHJlc3Npb24oYmluYXJ5RXhwcmVzc2lvbihcIj09PVwiLCB1bmFyeUV4cHJlc3Npb24oXCJ0eXBlb2ZcIiwgYXJncygpKSwgc3RyaW5nTGl0ZXJhbChcInVuZGVmaW5lZFwiKSksIHRoaXNFbnZGbi5zY29wZS5idWlsZFVuZGVmaW5lZE5vZGUoKSwgYXJncygpKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBhcmdzKCk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgYXJndW1lbnRzUGF0aHMuZm9yRWFjaChhcmd1bWVudHNDaGlsZCA9PiB7XG4gICAgICBjb25zdCBhcmdzUmVmID0gaWRlbnRpZmllcihhcmd1bWVudHNCaW5kaW5nKTtcbiAgICAgIGFyZ3NSZWYubG9jID0gYXJndW1lbnRzQ2hpbGQubm9kZS5sb2M7XG4gICAgICBhcmd1bWVudHNDaGlsZC5yZXBsYWNlV2l0aChhcmdzUmVmKTtcbiAgICB9KTtcbiAgfVxuICBpZiAobmV3VGFyZ2V0UGF0aHMubGVuZ3RoID4gMCkge1xuICAgIGNvbnN0IG5ld1RhcmdldEJpbmRpbmcgPSBnZXRCaW5kaW5nKHRoaXNFbnZGbiwgXCJuZXd0YXJnZXRcIiwgKCkgPT4gbWV0YVByb3BlcnR5KGlkZW50aWZpZXIoXCJuZXdcIiksIGlkZW50aWZpZXIoXCJ0YXJnZXRcIikpKTtcbiAgICBuZXdUYXJnZXRQYXRocy5mb3JFYWNoKHRhcmdldENoaWxkID0+IHtcbiAgICAgIGNvbnN0IHRhcmdldFJlZiA9IGlkZW50aWZpZXIobmV3VGFyZ2V0QmluZGluZyk7XG4gICAgICB0YXJnZXRSZWYubG9jID0gdGFyZ2V0Q2hpbGQubm9kZS5sb2M7XG4gICAgICB0YXJnZXRDaGlsZC5yZXBsYWNlV2l0aCh0YXJnZXRSZWYpO1xuICAgIH0pO1xuICB9XG4gIGlmIChzdXBlclByb3BzLmxlbmd0aCA+IDApIHtcbiAgICBpZiAoIWFsbG93SW5zZXJ0QXJyb3cpIHtcbiAgICAgIHRocm93IHN1cGVyUHJvcHNbMF0uYnVpbGRDb2RlRnJhbWVFcnJvcihcIldoZW4gdXNpbmcgJ0BiYWJlbC9wbHVnaW4tdHJhbnNmb3JtLWFycm93LWZ1bmN0aW9ucycsIFwiICsgXCJpdCdzIG5vdCBwb3NzaWJsZSB0byBjb21waWxlIGBzdXBlci5wcm9wYCBpbiBhbiBhcnJvdyBmdW5jdGlvbiB3aXRob3V0IGNvbXBpbGluZyBjbGFzc2VzLlxcblwiICsgXCJQbGVhc2UgYWRkICdAYmFiZWwvcGx1Z2luLXRyYW5zZm9ybS1jbGFzc2VzJyB0byB5b3VyIEJhYmVsIGNvbmZpZ3VyYXRpb24uXCIpO1xuICAgIH1cbiAgICBjb25zdCBmbGF0U3VwZXJQcm9wcyA9IHN1cGVyUHJvcHMucmVkdWNlKChhY2MsIHN1cGVyUHJvcCkgPT4gYWNjLmNvbmNhdChzdGFuZGFyZGl6ZVN1cGVyUHJvcGVydHkoc3VwZXJQcm9wKSksIFtdKTtcbiAgICBmbGF0U3VwZXJQcm9wcy5mb3JFYWNoKHN1cGVyUHJvcCA9PiB7XG4gICAgICBjb25zdCBrZXkgPSBzdXBlclByb3Aubm9kZS5jb21wdXRlZCA/IFwiXCIgOiBzdXBlclByb3AuZ2V0KFwicHJvcGVydHlcIikubm9kZS5uYW1lO1xuICAgICAgY29uc3Qgc3VwZXJQYXJlbnRQYXRoID0gc3VwZXJQcm9wLnBhcmVudFBhdGg7XG4gICAgICBjb25zdCBpc0Fzc2lnbm1lbnQgPSBzdXBlclBhcmVudFBhdGguaXNBc3NpZ25tZW50RXhwcmVzc2lvbih7XG4gICAgICAgIGxlZnQ6IHN1cGVyUHJvcC5ub2RlXG4gICAgICB9KTtcbiAgICAgIGNvbnN0IGlzQ2FsbCA9IHN1cGVyUGFyZW50UGF0aC5pc0NhbGxFeHByZXNzaW9uKHtcbiAgICAgICAgY2FsbGVlOiBzdXBlclByb3Aubm9kZVxuICAgICAgfSk7XG4gICAgICBjb25zdCBpc1RhZ2dlZFRlbXBsYXRlID0gc3VwZXJQYXJlbnRQYXRoLmlzVGFnZ2VkVGVtcGxhdGVFeHByZXNzaW9uKHtcbiAgICAgICAgdGFnOiBzdXBlclByb3Aubm9kZVxuICAgICAgfSk7XG4gICAgICBjb25zdCBzdXBlckJpbmRpbmcgPSBnZXRTdXBlclByb3BCaW5kaW5nKHRoaXNFbnZGbiwgaXNBc3NpZ25tZW50LCBrZXkpO1xuICAgICAgY29uc3QgYXJncyA9IFtdO1xuICAgICAgaWYgKHN1cGVyUHJvcC5ub2RlLmNvbXB1dGVkKSB7XG4gICAgICAgIGFyZ3MucHVzaChzdXBlclByb3AuZ2V0KFwicHJvcGVydHlcIikubm9kZSk7XG4gICAgICB9XG4gICAgICBpZiAoaXNBc3NpZ25tZW50KSB7XG4gICAgICAgIGNvbnN0IHZhbHVlID0gc3VwZXJQYXJlbnRQYXRoLm5vZGUucmlnaHQ7XG4gICAgICAgIGFyZ3MucHVzaCh2YWx1ZSk7XG4gICAgICB9XG4gICAgICBjb25zdCBjYWxsID0gY2FsbEV4cHJlc3Npb24oaWRlbnRpZmllcihzdXBlckJpbmRpbmcpLCBhcmdzKTtcbiAgICAgIGlmIChpc0NhbGwpIHtcbiAgICAgICAgc3VwZXJQYXJlbnRQYXRoLnVuc2hpZnRDb250YWluZXIoXCJhcmd1bWVudHNcIiwgdGhpc0V4cHJlc3Npb24oKSk7XG4gICAgICAgIHN1cGVyUHJvcC5yZXBsYWNlV2l0aChtZW1iZXJFeHByZXNzaW9uKGNhbGwsIGlkZW50aWZpZXIoXCJjYWxsXCIpKSk7XG4gICAgICAgIHRoaXNQYXRocy5wdXNoKHN1cGVyUGFyZW50UGF0aC5nZXQoXCJhcmd1bWVudHMuMFwiKSk7XG4gICAgICB9IGVsc2UgaWYgKGlzQXNzaWdubWVudCkge1xuICAgICAgICBzdXBlclBhcmVudFBhdGgucmVwbGFjZVdpdGgoY2FsbCk7XG4gICAgICB9IGVsc2UgaWYgKGlzVGFnZ2VkVGVtcGxhdGUpIHtcbiAgICAgICAgc3VwZXJQcm9wLnJlcGxhY2VXaXRoKGNhbGxFeHByZXNzaW9uKG1lbWJlckV4cHJlc3Npb24oY2FsbCwgaWRlbnRpZmllcihcImJpbmRcIiksIGZhbHNlKSwgW3RoaXNFeHByZXNzaW9uKCldKSk7XG4gICAgICAgIHRoaXNQYXRocy5wdXNoKHN1cGVyUHJvcC5nZXQoXCJhcmd1bWVudHMuMFwiKSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzdXBlclByb3AucmVwbGFjZVdpdGgoY2FsbCk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbiAgbGV0IHRoaXNCaW5kaW5nO1xuICBpZiAodGhpc1BhdGhzLmxlbmd0aCA+IDAgfHwgIW5vTmV3QXJyb3dzKSB7XG4gICAgdGhpc0JpbmRpbmcgPSBnZXRUaGlzQmluZGluZyh0aGlzRW52Rm4sIGluQ29uc3RydWN0b3IpO1xuICAgIGlmIChub05ld0Fycm93cyB8fCBpbkNvbnN0cnVjdG9yICYmIGhhc1N1cGVyQ2xhc3ModGhpc0VudkZuKSkge1xuICAgICAgdGhpc1BhdGhzLmZvckVhY2godGhpc0NoaWxkID0+IHtcbiAgICAgICAgY29uc3QgdGhpc1JlZiA9IHRoaXNDaGlsZC5pc0pTWCgpID8ganN4SWRlbnRpZmllcih0aGlzQmluZGluZykgOiBpZGVudGlmaWVyKHRoaXNCaW5kaW5nKTtcbiAgICAgICAgdGhpc1JlZi5sb2MgPSB0aGlzQ2hpbGQubm9kZS5sb2M7XG4gICAgICAgIHRoaXNDaGlsZC5yZXBsYWNlV2l0aCh0aGlzUmVmKTtcbiAgICAgIH0pO1xuICAgICAgaWYgKCFub05ld0Fycm93cykgdGhpc0JpbmRpbmcgPSBudWxsO1xuICAgIH1cbiAgfVxuICByZXR1cm4ge1xuICAgIHRoaXNCaW5kaW5nOiB0aGlzQmluZGluZyxcbiAgICBmblBhdGhcbiAgfTtcbn1cbmZ1bmN0aW9uIGlzTG9naWNhbE9wKG9wKSB7XG4gIHJldHVybiBMT0dJQ0FMX09QRVJBVE9SUy5pbmNsdWRlcyhvcCk7XG59XG5mdW5jdGlvbiBzdGFuZGFyZGl6ZVN1cGVyUHJvcGVydHkoc3VwZXJQcm9wKSB7XG4gIGlmIChzdXBlclByb3AucGFyZW50UGF0aC5pc0Fzc2lnbm1lbnRFeHByZXNzaW9uKCkgJiYgc3VwZXJQcm9wLnBhcmVudFBhdGgubm9kZS5vcGVyYXRvciAhPT0gXCI9XCIpIHtcbiAgICBjb25zdCBhc3NpZ25tZW50UGF0aCA9IHN1cGVyUHJvcC5wYXJlbnRQYXRoO1xuICAgIGNvbnN0IG9wID0gYXNzaWdubWVudFBhdGgubm9kZS5vcGVyYXRvci5zbGljZSgwLCAtMSk7XG4gICAgY29uc3QgdmFsdWUgPSBhc3NpZ25tZW50UGF0aC5ub2RlLnJpZ2h0O1xuICAgIGNvbnN0IGlzTG9naWNhbEFzc2lnbm1lbnQgPSBpc0xvZ2ljYWxPcChvcCk7XG4gICAgaWYgKHN1cGVyUHJvcC5ub2RlLmNvbXB1dGVkKSB7XG4gICAgICBjb25zdCB0bXAgPSBzdXBlclByb3Auc2NvcGUuZ2VuZXJhdGVEZWNsYXJlZFVpZElkZW50aWZpZXIoXCJ0bXBcIik7XG4gICAgICBjb25zdCB7XG4gICAgICAgIG9iamVjdCxcbiAgICAgICAgcHJvcGVydHlcbiAgICAgIH0gPSBzdXBlclByb3Aubm9kZTtcbiAgICAgIGFzc2lnbm1lbnRQYXRoLmdldChcImxlZnRcIikucmVwbGFjZVdpdGgobWVtYmVyRXhwcmVzc2lvbihvYmplY3QsIGFzc2lnbm1lbnRFeHByZXNzaW9uKFwiPVwiLCB0bXAsIHByb3BlcnR5KSwgdHJ1ZSkpO1xuICAgICAgYXNzaWdubWVudFBhdGguZ2V0KFwicmlnaHRcIikucmVwbGFjZVdpdGgocmlnaHRFeHByZXNzaW9uKGlzTG9naWNhbEFzc2lnbm1lbnQgPyBcIj1cIiA6IG9wLCBtZW1iZXJFeHByZXNzaW9uKG9iamVjdCwgaWRlbnRpZmllcih0bXAubmFtZSksIHRydWUpLCB2YWx1ZSkpO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBvYmplY3QgPSBzdXBlclByb3Aubm9kZS5vYmplY3Q7XG4gICAgICBjb25zdCBwcm9wZXJ0eSA9IHN1cGVyUHJvcC5ub2RlLnByb3BlcnR5O1xuICAgICAgYXNzaWdubWVudFBhdGguZ2V0KFwibGVmdFwiKS5yZXBsYWNlV2l0aChtZW1iZXJFeHByZXNzaW9uKG9iamVjdCwgcHJvcGVydHkpKTtcbiAgICAgIGFzc2lnbm1lbnRQYXRoLmdldChcInJpZ2h0XCIpLnJlcGxhY2VXaXRoKHJpZ2h0RXhwcmVzc2lvbihpc0xvZ2ljYWxBc3NpZ25tZW50ID8gXCI9XCIgOiBvcCwgbWVtYmVyRXhwcmVzc2lvbihvYmplY3QsIGlkZW50aWZpZXIocHJvcGVydHkubmFtZSkpLCB2YWx1ZSkpO1xuICAgIH1cbiAgICBpZiAoaXNMb2dpY2FsQXNzaWdubWVudCkge1xuICAgICAgYXNzaWdubWVudFBhdGgucmVwbGFjZVdpdGgobG9naWNhbEV4cHJlc3Npb24ob3AsIGFzc2lnbm1lbnRQYXRoLm5vZGUubGVmdCwgYXNzaWdubWVudFBhdGgubm9kZS5yaWdodCkpO1xuICAgIH0gZWxzZSB7XG4gICAgICBhc3NpZ25tZW50UGF0aC5ub2RlLm9wZXJhdG9yID0gXCI9XCI7XG4gICAgfVxuICAgIHJldHVybiBbYXNzaWdubWVudFBhdGguZ2V0KFwibGVmdFwiKSwgYXNzaWdubWVudFBhdGguZ2V0KFwicmlnaHRcIikuZ2V0KFwibGVmdFwiKV07XG4gIH0gZWxzZSBpZiAoc3VwZXJQcm9wLnBhcmVudFBhdGguaXNVcGRhdGVFeHByZXNzaW9uKCkpIHtcbiAgICBjb25zdCB1cGRhdGVFeHByID0gc3VwZXJQcm9wLnBhcmVudFBhdGg7XG4gICAgY29uc3QgdG1wID0gc3VwZXJQcm9wLnNjb3BlLmdlbmVyYXRlRGVjbGFyZWRVaWRJZGVudGlmaWVyKFwidG1wXCIpO1xuICAgIGNvbnN0IGNvbXB1dGVkS2V5ID0gc3VwZXJQcm9wLm5vZGUuY29tcHV0ZWQgPyBzdXBlclByb3Auc2NvcGUuZ2VuZXJhdGVEZWNsYXJlZFVpZElkZW50aWZpZXIoXCJwcm9wXCIpIDogbnVsbDtcbiAgICBjb25zdCBwYXJ0cyA9IFthc3NpZ25tZW50RXhwcmVzc2lvbihcIj1cIiwgdG1wLCBtZW1iZXJFeHByZXNzaW9uKHN1cGVyUHJvcC5ub2RlLm9iamVjdCwgY29tcHV0ZWRLZXkgPyBhc3NpZ25tZW50RXhwcmVzc2lvbihcIj1cIiwgY29tcHV0ZWRLZXksIHN1cGVyUHJvcC5ub2RlLnByb3BlcnR5KSA6IHN1cGVyUHJvcC5ub2RlLnByb3BlcnR5LCBzdXBlclByb3Aubm9kZS5jb21wdXRlZCkpLCBhc3NpZ25tZW50RXhwcmVzc2lvbihcIj1cIiwgbWVtYmVyRXhwcmVzc2lvbihzdXBlclByb3Aubm9kZS5vYmplY3QsIGNvbXB1dGVkS2V5ID8gaWRlbnRpZmllcihjb21wdXRlZEtleS5uYW1lKSA6IHN1cGVyUHJvcC5ub2RlLnByb3BlcnR5LCBzdXBlclByb3Aubm9kZS5jb21wdXRlZCksIGJpbmFyeUV4cHJlc3Npb24oc3VwZXJQcm9wLnBhcmVudFBhdGgubm9kZS5vcGVyYXRvclswXSwgaWRlbnRpZmllcih0bXAubmFtZSksIG51bWVyaWNMaXRlcmFsKDEpKSldO1xuICAgIGlmICghc3VwZXJQcm9wLnBhcmVudFBhdGgubm9kZS5wcmVmaXgpIHtcbiAgICAgIHBhcnRzLnB1c2goaWRlbnRpZmllcih0bXAubmFtZSkpO1xuICAgIH1cbiAgICB1cGRhdGVFeHByLnJlcGxhY2VXaXRoKHNlcXVlbmNlRXhwcmVzc2lvbihwYXJ0cykpO1xuICAgIGNvbnN0IGxlZnQgPSB1cGRhdGVFeHByLmdldChcImV4cHJlc3Npb25zLjAucmlnaHRcIik7XG4gICAgY29uc3QgcmlnaHQgPSB1cGRhdGVFeHByLmdldChcImV4cHJlc3Npb25zLjEubGVmdFwiKTtcbiAgICByZXR1cm4gW2xlZnQsIHJpZ2h0XTtcbiAgfVxuICByZXR1cm4gW3N1cGVyUHJvcF07XG4gIGZ1bmN0aW9uIHJpZ2h0RXhwcmVzc2lvbihvcCwgbGVmdCwgcmlnaHQpIHtcbiAgICBpZiAob3AgPT09IFwiPVwiKSB7XG4gICAgICByZXR1cm4gYXNzaWdubWVudEV4cHJlc3Npb24oXCI9XCIsIGxlZnQsIHJpZ2h0KTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIGJpbmFyeUV4cHJlc3Npb24ob3AsIGxlZnQsIHJpZ2h0KTtcbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIGhhc1N1cGVyQ2xhc3ModGhpc0VudkZuKSB7XG4gIHJldHVybiB0aGlzRW52Rm4uaXNDbGFzc01ldGhvZCgpICYmICEhdGhpc0VudkZuLnBhcmVudFBhdGgucGFyZW50UGF0aC5ub2RlLnN1cGVyQ2xhc3M7XG59XG5jb25zdCBhc3NpZ25TdXBlclRoaXNWaXNpdG9yID0gKDAsIF92aXNpdG9ycy5lbnZpcm9ubWVudFZpc2l0b3IpKHtcbiAgQ2FsbEV4cHJlc3Npb24oY2hpbGQsIHtcbiAgICBzdXBlcnMsXG4gICAgdGhpc0JpbmRpbmdcbiAgfSkge1xuICAgIGlmICghY2hpbGQuZ2V0KFwiY2FsbGVlXCIpLmlzU3VwZXIoKSkgcmV0dXJuO1xuICAgIGlmIChzdXBlcnMuaGFzKGNoaWxkLm5vZGUpKSByZXR1cm47XG4gICAgc3VwZXJzLmFkZChjaGlsZC5ub2RlKTtcbiAgICBjaGlsZC5yZXBsYWNlV2l0aE11bHRpcGxlKFtjaGlsZC5ub2RlLCBhc3NpZ25tZW50RXhwcmVzc2lvbihcIj1cIiwgaWRlbnRpZmllcih0aGlzQmluZGluZyksIGlkZW50aWZpZXIoXCJ0aGlzXCIpKV0pO1xuICB9XG59KTtcbmZ1bmN0aW9uIGdldFRoaXNCaW5kaW5nKHRoaXNFbnZGbiwgaW5Db25zdHJ1Y3Rvcikge1xuICByZXR1cm4gZ2V0QmluZGluZyh0aGlzRW52Rm4sIFwidGhpc1wiLCB0aGlzQmluZGluZyA9PiB7XG4gICAgaWYgKCFpbkNvbnN0cnVjdG9yIHx8ICFoYXNTdXBlckNsYXNzKHRoaXNFbnZGbikpIHJldHVybiB0aGlzRXhwcmVzc2lvbigpO1xuICAgIHRoaXNFbnZGbi50cmF2ZXJzZShhc3NpZ25TdXBlclRoaXNWaXNpdG9yLCB7XG4gICAgICBzdXBlcnM6IG5ldyBXZWFrU2V0KCksXG4gICAgICB0aGlzQmluZGluZ1xuICAgIH0pO1xuICB9KTtcbn1cbmZ1bmN0aW9uIGdldFN1cGVyQmluZGluZyh0aGlzRW52Rm4pIHtcbiAgcmV0dXJuIGdldEJpbmRpbmcodGhpc0VudkZuLCBcInN1cGVyY2FsbFwiLCAoKSA9PiB7XG4gICAgY29uc3QgYXJnc0JpbmRpbmcgPSB0aGlzRW52Rm4uc2NvcGUuZ2VuZXJhdGVVaWRJZGVudGlmaWVyKFwiYXJnc1wiKTtcbiAgICByZXR1cm4gYXJyb3dGdW5jdGlvbkV4cHJlc3Npb24oW3Jlc3RFbGVtZW50KGFyZ3NCaW5kaW5nKV0sIGNhbGxFeHByZXNzaW9uKF9zdXBlcigpLCBbc3ByZWFkRWxlbWVudChpZGVudGlmaWVyKGFyZ3NCaW5kaW5nLm5hbWUpKV0pKTtcbiAgfSk7XG59XG5mdW5jdGlvbiBnZXRTdXBlclByb3BCaW5kaW5nKHRoaXNFbnZGbiwgaXNBc3NpZ25tZW50LCBwcm9wTmFtZSkge1xuICBjb25zdCBvcCA9IGlzQXNzaWdubWVudCA/IFwic2V0XCIgOiBcImdldFwiO1xuICByZXR1cm4gZ2V0QmluZGluZyh0aGlzRW52Rm4sIGBzdXBlcnByb3BfJHtvcH06JHtwcm9wTmFtZSB8fCBcIlwifWAsICgpID0+IHtcbiAgICBjb25zdCBhcmdzTGlzdCA9IFtdO1xuICAgIGxldCBmbkJvZHk7XG4gICAgaWYgKHByb3BOYW1lKSB7XG4gICAgICBmbkJvZHkgPSBtZW1iZXJFeHByZXNzaW9uKF9zdXBlcigpLCBpZGVudGlmaWVyKHByb3BOYW1lKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IG1ldGhvZCA9IHRoaXNFbnZGbi5zY29wZS5nZW5lcmF0ZVVpZElkZW50aWZpZXIoXCJwcm9wXCIpO1xuICAgICAgYXJnc0xpc3QudW5zaGlmdChtZXRob2QpO1xuICAgICAgZm5Cb2R5ID0gbWVtYmVyRXhwcmVzc2lvbihfc3VwZXIoKSwgaWRlbnRpZmllcihtZXRob2QubmFtZSksIHRydWUpO1xuICAgIH1cbiAgICBpZiAoaXNBc3NpZ25tZW50KSB7XG4gICAgICBjb25zdCB2YWx1ZUlkZW50ID0gdGhpc0VudkZuLnNjb3BlLmdlbmVyYXRlVWlkSWRlbnRpZmllcihcInZhbHVlXCIpO1xuICAgICAgYXJnc0xpc3QucHVzaCh2YWx1ZUlkZW50KTtcbiAgICAgIGZuQm9keSA9IGFzc2lnbm1lbnRFeHByZXNzaW9uKFwiPVwiLCBmbkJvZHksIGlkZW50aWZpZXIodmFsdWVJZGVudC5uYW1lKSk7XG4gICAgfVxuICAgIHJldHVybiBhcnJvd0Z1bmN0aW9uRXhwcmVzc2lvbihhcmdzTGlzdCwgZm5Cb2R5KTtcbiAgfSk7XG59XG5mdW5jdGlvbiBnZXRCaW5kaW5nKHRoaXNFbnZGbiwga2V5LCBpbml0KSB7XG4gIGNvbnN0IGNhY2hlS2V5ID0gXCJiaW5kaW5nOlwiICsga2V5O1xuICBsZXQgZGF0YSA9IHRoaXNFbnZGbi5nZXREYXRhKGNhY2hlS2V5KTtcbiAgaWYgKCFkYXRhKSB7XG4gICAgY29uc3QgaWQgPSB0aGlzRW52Rm4uc2NvcGUuZ2VuZXJhdGVVaWRJZGVudGlmaWVyKGtleSk7XG4gICAgZGF0YSA9IGlkLm5hbWU7XG4gICAgdGhpc0VudkZuLnNldERhdGEoY2FjaGVLZXksIGRhdGEpO1xuICAgIHRoaXNFbnZGbi5zY29wZS5wdXNoKHtcbiAgICAgIGlkOiBpZCxcbiAgICAgIGluaXQ6IGluaXQoZGF0YSlcbiAgICB9KTtcbiAgfVxuICByZXR1cm4gZGF0YTtcbn1cbmNvbnN0IGdldFNjb3BlSW5mb3JtYXRpb25WaXNpdG9yID0gKDAsIF92aXNpdG9ycy5lbnZpcm9ubWVudFZpc2l0b3IpKHtcbiAgVGhpc0V4cHJlc3Npb24oY2hpbGQsIHtcbiAgICB0aGlzUGF0aHNcbiAgfSkge1xuICAgIHRoaXNQYXRocy5wdXNoKGNoaWxkKTtcbiAgfSxcbiAgSlNYSWRlbnRpZmllcihjaGlsZCwge1xuICAgIHRoaXNQYXRoc1xuICB9KSB7XG4gICAgaWYgKGNoaWxkLm5vZGUubmFtZSAhPT0gXCJ0aGlzXCIpIHJldHVybjtcbiAgICBpZiAoIWNoaWxkLnBhcmVudFBhdGguaXNKU1hNZW1iZXJFeHByZXNzaW9uKHtcbiAgICAgIG9iamVjdDogY2hpbGQubm9kZVxuICAgIH0pICYmICFjaGlsZC5wYXJlbnRQYXRoLmlzSlNYT3BlbmluZ0VsZW1lbnQoe1xuICAgICAgbmFtZTogY2hpbGQubm9kZVxuICAgIH0pKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXNQYXRocy5wdXNoKGNoaWxkKTtcbiAgfSxcbiAgQ2FsbEV4cHJlc3Npb24oY2hpbGQsIHtcbiAgICBzdXBlckNhbGxzXG4gIH0pIHtcbiAgICBpZiAoY2hpbGQuZ2V0KFwiY2FsbGVlXCIpLmlzU3VwZXIoKSkgc3VwZXJDYWxscy5wdXNoKGNoaWxkKTtcbiAgfSxcbiAgTWVtYmVyRXhwcmVzc2lvbihjaGlsZCwge1xuICAgIHN1cGVyUHJvcHNcbiAgfSkge1xuICAgIGlmIChjaGlsZC5nZXQoXCJvYmplY3RcIikuaXNTdXBlcigpKSBzdXBlclByb3BzLnB1c2goY2hpbGQpO1xuICB9LFxuICBJZGVudGlmaWVyKGNoaWxkLCB7XG4gICAgYXJndW1lbnRzUGF0aHNcbiAgfSkge1xuICAgIGlmICghY2hpbGQuaXNSZWZlcmVuY2VkSWRlbnRpZmllcih7XG4gICAgICBuYW1lOiBcImFyZ3VtZW50c1wiXG4gICAgfSkpIHJldHVybjtcbiAgICBsZXQgY3VyciA9IGNoaWxkLnNjb3BlO1xuICAgIGRvIHtcbiAgICAgIGlmIChjdXJyLmhhc093bkJpbmRpbmcoXCJhcmd1bWVudHNcIikpIHtcbiAgICAgICAgY3Vyci5yZW5hbWUoXCJhcmd1bWVudHNcIik7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGlmIChjdXJyLnBhdGguaXNGdW5jdGlvbigpICYmICFjdXJyLnBhdGguaXNBcnJvd0Z1bmN0aW9uRXhwcmVzc2lvbigpKSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH0gd2hpbGUgKGN1cnIgPSBjdXJyLnBhcmVudCk7XG4gICAgYXJndW1lbnRzUGF0aHMucHVzaChjaGlsZCk7XG4gIH0sXG4gIE1ldGFQcm9wZXJ0eShjaGlsZCwge1xuICAgIG5ld1RhcmdldFBhdGhzXG4gIH0pIHtcbiAgICBpZiAoIWNoaWxkLmdldChcIm1ldGFcIikuaXNJZGVudGlmaWVyKHtcbiAgICAgIG5hbWU6IFwibmV3XCJcbiAgICB9KSkgcmV0dXJuO1xuICAgIGlmICghY2hpbGQuZ2V0KFwicHJvcGVydHlcIikuaXNJZGVudGlmaWVyKHtcbiAgICAgIG5hbWU6IFwidGFyZ2V0XCJcbiAgICB9KSkgcmV0dXJuO1xuICAgIG5ld1RhcmdldFBhdGhzLnB1c2goY2hpbGQpO1xuICB9XG59KTtcbmZ1bmN0aW9uIGdldFNjb3BlSW5mb3JtYXRpb24oZm5QYXRoKSB7XG4gIGNvbnN0IHRoaXNQYXRocyA9IFtdO1xuICBjb25zdCBhcmd1bWVudHNQYXRocyA9IFtdO1xuICBjb25zdCBuZXdUYXJnZXRQYXRocyA9IFtdO1xuICBjb25zdCBzdXBlclByb3BzID0gW107XG4gIGNvbnN0IHN1cGVyQ2FsbHMgPSBbXTtcbiAgZm5QYXRoLnRyYXZlcnNlKGdldFNjb3BlSW5mb3JtYXRpb25WaXNpdG9yLCB7XG4gICAgdGhpc1BhdGhzLFxuICAgIGFyZ3VtZW50c1BhdGhzLFxuICAgIG5ld1RhcmdldFBhdGhzLFxuICAgIHN1cGVyUHJvcHMsXG4gICAgc3VwZXJDYWxsc1xuICB9KTtcbiAgcmV0dXJuIHtcbiAgICB0aGlzUGF0aHMsXG4gICAgYXJndW1lbnRzUGF0aHMsXG4gICAgbmV3VGFyZ2V0UGF0aHMsXG4gICAgc3VwZXJQcm9wcyxcbiAgICBzdXBlckNhbGxzXG4gIH07XG59XG5mdW5jdGlvbiBzcGxpdEV4cG9ydERlY2xhcmF0aW9uKCkge1xuICBpZiAoIXRoaXMuaXNFeHBvcnREZWNsYXJhdGlvbigpIHx8IHRoaXMuaXNFeHBvcnRBbGxEZWNsYXJhdGlvbigpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiT25seSBkZWZhdWx0IGFuZCBuYW1lZCBleHBvcnQgZGVjbGFyYXRpb25zIGNhbiBiZSBzcGxpdC5cIik7XG4gIH1cbiAgaWYgKHRoaXMuaXNFeHBvcnROYW1lZERlY2xhcmF0aW9uKCkgJiYgdGhpcy5nZXQoXCJzcGVjaWZpZXJzXCIpLmxlbmd0aCA+IDApIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJJdCBkb2Vzbid0IG1ha2Ugc2Vuc2UgdG8gc3BsaXQgZXhwb3J0ZWQgc3BlY2lmaWVycy5cIik7XG4gIH1cbiAgY29uc3QgZGVjbGFyYXRpb24gPSB0aGlzLmdldChcImRlY2xhcmF0aW9uXCIpO1xuICBpZiAodGhpcy5pc0V4cG9ydERlZmF1bHREZWNsYXJhdGlvbigpKSB7XG4gICAgY29uc3Qgc3RhbmRhbG9uZURlY2xhcmF0aW9uID0gZGVjbGFyYXRpb24uaXNGdW5jdGlvbkRlY2xhcmF0aW9uKCkgfHwgZGVjbGFyYXRpb24uaXNDbGFzc0RlY2xhcmF0aW9uKCk7XG4gICAgY29uc3QgZXhwb3J0RXhwciA9IGRlY2xhcmF0aW9uLmlzRnVuY3Rpb25FeHByZXNzaW9uKCkgfHwgZGVjbGFyYXRpb24uaXNDbGFzc0V4cHJlc3Npb24oKTtcbiAgICBjb25zdCBzY29wZSA9IGRlY2xhcmF0aW9uLmlzU2NvcGUoKSA/IGRlY2xhcmF0aW9uLnNjb3BlLnBhcmVudCA6IGRlY2xhcmF0aW9uLnNjb3BlO1xuICAgIGxldCBpZCA9IGRlY2xhcmF0aW9uLm5vZGUuaWQ7XG4gICAgbGV0IG5lZWRCaW5kaW5nUmVnaXN0cmF0aW9uID0gZmFsc2U7XG4gICAgaWYgKCFpZCkge1xuICAgICAgbmVlZEJpbmRpbmdSZWdpc3RyYXRpb24gPSB0cnVlO1xuICAgICAgaWQgPSBzY29wZS5nZW5lcmF0ZVVpZElkZW50aWZpZXIoXCJkZWZhdWx0XCIpO1xuICAgICAgaWYgKHN0YW5kYWxvbmVEZWNsYXJhdGlvbiB8fCBleHBvcnRFeHByKSB7XG4gICAgICAgIGRlY2xhcmF0aW9uLm5vZGUuaWQgPSBjbG9uZU5vZGUoaWQpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoZXhwb3J0RXhwciAmJiBzY29wZS5oYXNCaW5kaW5nKGlkLm5hbWUpKSB7XG4gICAgICBuZWVkQmluZGluZ1JlZ2lzdHJhdGlvbiA9IHRydWU7XG4gICAgICBpZCA9IHNjb3BlLmdlbmVyYXRlVWlkSWRlbnRpZmllcihpZC5uYW1lKTtcbiAgICB9XG4gICAgY29uc3QgdXBkYXRlZERlY2xhcmF0aW9uID0gc3RhbmRhbG9uZURlY2xhcmF0aW9uID8gZGVjbGFyYXRpb24ubm9kZSA6IHZhcmlhYmxlRGVjbGFyYXRpb24oXCJ2YXJcIiwgW3ZhcmlhYmxlRGVjbGFyYXRvcihjbG9uZU5vZGUoaWQpLCBkZWNsYXJhdGlvbi5ub2RlKV0pO1xuICAgIGNvbnN0IHVwZGF0ZWRFeHBvcnREZWNsYXJhdGlvbiA9IGV4cG9ydE5hbWVkRGVjbGFyYXRpb24obnVsbCwgW2V4cG9ydFNwZWNpZmllcihjbG9uZU5vZGUoaWQpLCBpZGVudGlmaWVyKFwiZGVmYXVsdFwiKSldKTtcbiAgICB0aGlzLmluc2VydEFmdGVyKHVwZGF0ZWRFeHBvcnREZWNsYXJhdGlvbik7XG4gICAgdGhpcy5yZXBsYWNlV2l0aCh1cGRhdGVkRGVjbGFyYXRpb24pO1xuICAgIGlmIChuZWVkQmluZGluZ1JlZ2lzdHJhdGlvbikge1xuICAgICAgc2NvcGUucmVnaXN0ZXJEZWNsYXJhdGlvbih0aGlzKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG4gIH0gZWxzZSBpZiAodGhpcy5nZXQoXCJzcGVjaWZpZXJzXCIpLmxlbmd0aCA+IDApIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJJdCBkb2Vzbid0IG1ha2Ugc2Vuc2UgdG8gc3BsaXQgZXhwb3J0ZWQgc3BlY2lmaWVycy5cIik7XG4gIH1cbiAgY29uc3QgYmluZGluZ0lkZW50aWZpZXJzID0gZGVjbGFyYXRpb24uZ2V0T3V0ZXJCaW5kaW5nSWRlbnRpZmllcnMoKTtcbiAgY29uc3Qgc3BlY2lmaWVycyA9IE9iamVjdC5rZXlzKGJpbmRpbmdJZGVudGlmaWVycykubWFwKG5hbWUgPT4ge1xuICAgIHJldHVybiBleHBvcnRTcGVjaWZpZXIoaWRlbnRpZmllcihuYW1lKSwgaWRlbnRpZmllcihuYW1lKSk7XG4gIH0pO1xuICBjb25zdCBhbGlhc0RlY2xhciA9IGV4cG9ydE5hbWVkRGVjbGFyYXRpb24obnVsbCwgc3BlY2lmaWVycyk7XG4gIHRoaXMuaW5zZXJ0QWZ0ZXIoYWxpYXNEZWNsYXIpO1xuICB0aGlzLnJlcGxhY2VXaXRoKGRlY2xhcmF0aW9uLm5vZGUpO1xuICByZXR1cm4gdGhpcztcbn1cbmNvbnN0IHJlZmVyc091dGVyQmluZGluZ1Zpc2l0b3IgPSB7XG4gIFwiUmVmZXJlbmNlZElkZW50aWZpZXJ8QmluZGluZ0lkZW50aWZpZXJcIihwYXRoLCBzdGF0ZSkge1xuICAgIGlmIChwYXRoLm5vZGUubmFtZSAhPT0gc3RhdGUubmFtZSkgcmV0dXJuO1xuICAgIHN0YXRlLm5lZWRzUmVuYW1lID0gdHJ1ZTtcbiAgICBwYXRoLnN0b3AoKTtcbiAgfSxcbiAgU2NvcGUocGF0aCwgc3RhdGUpIHtcbiAgICBpZiAocGF0aC5zY29wZS5oYXNPd25CaW5kaW5nKHN0YXRlLm5hbWUpKSB7XG4gICAgICBwYXRoLnNraXAoKTtcbiAgICB9XG4gIH1cbn07XG5mdW5jdGlvbiBlbnN1cmVGdW5jdGlvbk5hbWUoc3VwcG9ydFVuaWNvZGVJZCkge1xuICBpZiAodGhpcy5ub2RlLmlkKSByZXR1cm4gdGhpcztcbiAgY29uc3QgcmVzID0gZ2V0RnVuY3Rpb25OYW1lKHRoaXMubm9kZSwgdGhpcy5wYXJlbnQpO1xuICBpZiAocmVzID09IG51bGwpIHJldHVybiB0aGlzO1xuICBsZXQge1xuICAgIG5hbWVcbiAgfSA9IHJlcztcbiAgaWYgKCFzdXBwb3J0VW5pY29kZUlkICYmIC9bXFx1RDgwMC1cXHVERkZGXS8udGVzdChuYW1lKSkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIGlmIChuYW1lLnN0YXJ0c1dpdGgoXCJnZXQgXCIpIHx8IG5hbWUuc3RhcnRzV2l0aChcInNldCBcIikpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICBuYW1lID0gdG9CaW5kaW5nSWRlbnRpZmllck5hbWUobmFtZS5yZXBsYWNlKC9bLyBdL2csIFwiX1wiKSk7XG4gIGNvbnN0IGlkID0gaWRlbnRpZmllcihuYW1lKTtcbiAgaW5oZXJpdHMoaWQsIHJlcy5vcmlnaW5hbE5vZGUpO1xuICBjb25zdCBzdGF0ZSA9IHtcbiAgICBuZWVkc1JlbmFtZTogZmFsc2UsXG4gICAgbmFtZVxuICB9O1xuICBjb25zdCB7XG4gICAgc2NvcGVcbiAgfSA9IHRoaXM7XG4gIGNvbnN0IGJpbmRpbmcgPSBzY29wZS5nZXRPd25CaW5kaW5nKG5hbWUpO1xuICBpZiAoYmluZGluZykge1xuICAgIGlmIChiaW5kaW5nLmtpbmQgPT09IFwicGFyYW1cIikge1xuICAgICAgc3RhdGUubmVlZHNSZW5hbWUgPSB0cnVlO1xuICAgIH0gZWxzZSB7fVxuICB9IGVsc2UgaWYgKHNjb3BlLnBhcmVudC5oYXNCaW5kaW5nKG5hbWUpIHx8IHNjb3BlLmhhc0dsb2JhbChuYW1lKSkge1xuICAgIHRoaXMudHJhdmVyc2UocmVmZXJzT3V0ZXJCaW5kaW5nVmlzaXRvciwgc3RhdGUpO1xuICB9XG4gIGlmICghc3RhdGUubmVlZHNSZW5hbWUpIHtcbiAgICB0aGlzLm5vZGUuaWQgPSBpZDtcbiAgICBzY29wZS5nZXRQcm9ncmFtUGFyZW50KCkucmVmZXJlbmNlc1tpZC5uYW1lXSA9IHRydWU7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgaWYgKHNjb3BlLmhhc0JpbmRpbmcoaWQubmFtZSkgJiYgIXNjb3BlLmhhc0dsb2JhbChpZC5uYW1lKSkge1xuICAgIHNjb3BlLnJlbmFtZShpZC5uYW1lKTtcbiAgICB0aGlzLm5vZGUuaWQgPSBpZDtcbiAgICBzY29wZS5nZXRQcm9ncmFtUGFyZW50KCkucmVmZXJlbmNlc1tpZC5uYW1lXSA9IHRydWU7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgaWYgKCFpc0Z1bmN0aW9uKHRoaXMubm9kZSkpIHJldHVybiBudWxsO1xuICBjb25zdCBrZXkgPSBzY29wZS5nZW5lcmF0ZVVpZElkZW50aWZpZXIoaWQubmFtZSk7XG4gIGNvbnN0IHBhcmFtcyA9IFtdO1xuICBmb3IgKGxldCBpID0gMCwgbGVuID0gZ2V0RnVuY3Rpb25Bcml0eSh0aGlzLm5vZGUpOyBpIDwgbGVuOyBpKyspIHtcbiAgICBwYXJhbXMucHVzaChzY29wZS5nZW5lcmF0ZVVpZElkZW50aWZpZXIoXCJ4XCIpKTtcbiAgfVxuICBjb25zdCBjYWxsID0gX3RlbXBsYXRlLmRlZmF1bHQuZXhwcmVzc2lvbi5hc3RgXG4gICAgKGZ1bmN0aW9uICgke2tleX0pIHtcbiAgICAgIGZ1bmN0aW9uICR7aWR9KCR7cGFyYW1zfSkge1xuICAgICAgICByZXR1cm4gJHtjbG9uZU5vZGUoa2V5KX0uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgIH1cblxuICAgICAgJHtjbG9uZU5vZGUoaWQpfS50b1N0cmluZyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuICR7Y2xvbmVOb2RlKGtleSl9LnRvU3RyaW5nKCk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiAke2Nsb25lTm9kZShpZCl9O1xuICAgIH0pKCR7dG9FeHByZXNzaW9uKHRoaXMubm9kZSl9KVxuICBgO1xuICByZXR1cm4gdGhpcy5yZXBsYWNlV2l0aChjYWxsKVswXS5nZXQoXCJhcmd1bWVudHMuMFwiKTtcbn1cbmZ1bmN0aW9uIGdldEZ1bmN0aW9uQXJpdHkobm9kZSkge1xuICBjb25zdCBjb3VudCA9IG5vZGUucGFyYW1zLmZpbmRJbmRleChwYXJhbSA9PiBpc0Fzc2lnbm1lbnRQYXR0ZXJuKHBhcmFtKSB8fCBpc1Jlc3RFbGVtZW50KHBhcmFtKSk7XG4gIHJldHVybiBjb3VudCA9PT0gLTEgPyBub2RlLnBhcmFtcy5sZW5ndGggOiBjb3VudDtcbn1cblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y29udmVyc2lvbi5qcy5tYXBcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@babel/traverse/lib/path/conversion.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@babel/traverse/lib/path/evaluation.js":
/*!*************************************************************!*\
  !*** ./node_modules/@babel/traverse/lib/path/evaluation.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports.evaluate = evaluate;\nexports.evaluateTruthy = evaluateTruthy;\nconst VALID_OBJECT_CALLEES = [\"Number\", \"String\", \"Math\"];\nconst VALID_IDENTIFIER_CALLEES = [\"isFinite\", \"isNaN\", \"parseFloat\", \"parseInt\", \"decodeURI\", \"decodeURIComponent\", \"encodeURI\", \"encodeURIComponent\", null, null];\nconst INVALID_METHODS = [\"random\"];\nfunction isValidObjectCallee(val) {\n  return VALID_OBJECT_CALLEES.includes(val);\n}\nfunction isValidIdentifierCallee(val) {\n  return VALID_IDENTIFIER_CALLEES.includes(val);\n}\nfunction isInvalidMethod(val) {\n  return INVALID_METHODS.includes(val);\n}\nfunction evaluateTruthy() {\n  const res = this.evaluate();\n  if (res.confident) return !!res.value;\n}\nfunction deopt(path, state) {\n  if (!state.confident) return;\n  state.deoptPath = path;\n  state.confident = false;\n}\nconst Globals = new Map([[\"undefined\", undefined], [\"Infinity\", Infinity], [\"NaN\", NaN]]);\nfunction evaluateCached(path, state) {\n  const {\n    node\n  } = path;\n  const {\n    seen\n  } = state;\n  if (seen.has(node)) {\n    const existing = seen.get(node);\n    if (existing.resolved) {\n      return existing.value;\n    } else {\n      deopt(path, state);\n      return;\n    }\n  } else {\n    const item = {\n      resolved: false\n    };\n    seen.set(node, item);\n    const val = _evaluate(path, state);\n    if (state.confident) {\n      item.resolved = true;\n      item.value = val;\n    }\n    return val;\n  }\n}\nfunction _evaluate(path, state) {\n  if (!state.confident) return;\n  if (path.isSequenceExpression()) {\n    const exprs = path.get(\"expressions\");\n    return evaluateCached(exprs[exprs.length - 1], state);\n  }\n  if (path.isStringLiteral() || path.isNumericLiteral() || path.isBooleanLiteral()) {\n    return path.node.value;\n  }\n  if (path.isNullLiteral()) {\n    return null;\n  }\n  if (path.isTemplateLiteral()) {\n    return evaluateQuasis(path, path.node.quasis, state);\n  }\n  if (path.isTaggedTemplateExpression() && path.get(\"tag\").isMemberExpression()) {\n    const object = path.get(\"tag.object\");\n    const {\n      node: {\n        name\n      }\n    } = object;\n    const property = path.get(\"tag.property\");\n    if (object.isIdentifier() && name === \"String\" && !path.scope.getBinding(name) && property.isIdentifier() && property.node.name === \"raw\") {\n      return evaluateQuasis(path, path.node.quasi.quasis, state, true);\n    }\n  }\n  if (path.isConditionalExpression()) {\n    const testResult = evaluateCached(path.get(\"test\"), state);\n    if (!state.confident) return;\n    if (testResult) {\n      return evaluateCached(path.get(\"consequent\"), state);\n    } else {\n      return evaluateCached(path.get(\"alternate\"), state);\n    }\n  }\n  if (path.isExpressionWrapper()) {\n    return evaluateCached(path.get(\"expression\"), state);\n  }\n  if (path.isMemberExpression() && !path.parentPath.isCallExpression({\n    callee: path.node\n  })) {\n    const property = path.get(\"property\");\n    const object = path.get(\"object\");\n    if (object.isLiteral()) {\n      const value = object.node.value;\n      const type = typeof value;\n      let key = null;\n      if (path.node.computed) {\n        key = evaluateCached(property, state);\n        if (!state.confident) return;\n      } else if (property.isIdentifier()) {\n        key = property.node.name;\n      }\n      if ((type === \"number\" || type === \"string\") && key != null && (typeof key === \"number\" || typeof key === \"string\")) {\n        return value[key];\n      }\n    }\n  }\n  if (path.isReferencedIdentifier()) {\n    const binding = path.scope.getBinding(path.node.name);\n    if (binding) {\n      if (binding.constantViolations.length > 0 || path.node.start < binding.path.node.end) {\n        deopt(binding.path, state);\n        return;\n      }\n      const bindingPathScope = binding.path.scope;\n      if (binding.kind === \"var\" && bindingPathScope !== binding.scope) {\n        let hasUnsafeBlock = !bindingPathScope.path.parentPath.isBlockStatement();\n        for (let scope = bindingPathScope.parent; scope; scope = scope.parent) {\n          var _scope$path$parentPat;\n          if (scope === path.scope) {\n            if (hasUnsafeBlock) {\n              deopt(binding.path, state);\n              return;\n            }\n            break;\n          }\n          if ((_scope$path$parentPat = scope.path.parentPath) != null && _scope$path$parentPat.isBlockStatement()) {\n            hasUnsafeBlock = true;\n          }\n        }\n      }\n      if (binding.hasValue) {\n        return binding.value;\n      }\n    }\n    const name = path.node.name;\n    if (Globals.has(name)) {\n      if (!binding) {\n        return Globals.get(name);\n      }\n      deopt(binding.path, state);\n      return;\n    }\n    if (!binding) {\n      deopt(path, state);\n      return;\n    }\n    const bindingPath = binding.path;\n    if (!bindingPath.isVariableDeclarator()) {\n      deopt(bindingPath, state);\n      return;\n    }\n    const initPath = bindingPath.get(\"init\");\n    const value = evaluateCached(initPath, state);\n    if (typeof value === \"object\" && value !== null && binding.references > 1) {\n      deopt(initPath, state);\n      return;\n    }\n    return value;\n  }\n  if (path.isUnaryExpression({\n    prefix: true\n  })) {\n    if (path.node.operator === \"void\") {\n      return undefined;\n    }\n    const argument = path.get(\"argument\");\n    if (path.node.operator === \"typeof\" && (argument.isFunction() || argument.isClass())) {\n      return \"function\";\n    }\n    const arg = evaluateCached(argument, state);\n    if (!state.confident) return;\n    switch (path.node.operator) {\n      case \"!\":\n        return !arg;\n      case \"+\":\n        return +arg;\n      case \"-\":\n        return -arg;\n      case \"~\":\n        return ~arg;\n      case \"typeof\":\n        return typeof arg;\n    }\n  }\n  if (path.isArrayExpression()) {\n    const arr = [];\n    const elems = path.get(\"elements\");\n    for (const elem of elems) {\n      const elemValue = elem.evaluate();\n      if (elemValue.confident) {\n        arr.push(elemValue.value);\n      } else {\n        deopt(elemValue.deopt, state);\n        return;\n      }\n    }\n    return arr;\n  }\n  if (path.isObjectExpression()) {\n    const obj = {};\n    const props = path.get(\"properties\");\n    for (const prop of props) {\n      if (prop.isObjectMethod() || prop.isSpreadElement()) {\n        deopt(prop, state);\n        return;\n      }\n      const keyPath = prop.get(\"key\");\n      let key;\n      if (prop.node.computed) {\n        key = keyPath.evaluate();\n        if (!key.confident) {\n          deopt(key.deopt, state);\n          return;\n        }\n        key = key.value;\n      } else if (keyPath.isIdentifier()) {\n        key = keyPath.node.name;\n      } else {\n        key = keyPath.node.value;\n      }\n      const valuePath = prop.get(\"value\");\n      let value = valuePath.evaluate();\n      if (!value.confident) {\n        deopt(value.deopt, state);\n        return;\n      }\n      value = value.value;\n      obj[key] = value;\n    }\n    return obj;\n  }\n  if (path.isLogicalExpression()) {\n    const wasConfident = state.confident;\n    const left = evaluateCached(path.get(\"left\"), state);\n    const leftConfident = state.confident;\n    state.confident = wasConfident;\n    const right = evaluateCached(path.get(\"right\"), state);\n    const rightConfident = state.confident;\n    switch (path.node.operator) {\n      case \"||\":\n        state.confident = leftConfident && (!!left || rightConfident);\n        if (!state.confident) return;\n        return left || right;\n      case \"&&\":\n        state.confident = leftConfident && (!left || rightConfident);\n        if (!state.confident) return;\n        return left && right;\n      case \"??\":\n        state.confident = leftConfident && (left != null || rightConfident);\n        if (!state.confident) return;\n        return left != null ? left : right;\n    }\n  }\n  if (path.isBinaryExpression()) {\n    const left = evaluateCached(path.get(\"left\"), state);\n    if (!state.confident) return;\n    const right = evaluateCached(path.get(\"right\"), state);\n    if (!state.confident) return;\n    switch (path.node.operator) {\n      case \"-\":\n        return left - right;\n      case \"+\":\n        return left + right;\n      case \"/\":\n        return left / right;\n      case \"*\":\n        return left * right;\n      case \"%\":\n        return left % right;\n      case \"**\":\n        return Math.pow(left, right);\n      case \"<\":\n        return left < right;\n      case \">\":\n        return left > right;\n      case \"<=\":\n        return left <= right;\n      case \">=\":\n        return left >= right;\n      case \"==\":\n        return left == right;\n      case \"!=\":\n        return left != right;\n      case \"===\":\n        return left === right;\n      case \"!==\":\n        return left !== right;\n      case \"|\":\n        return left | right;\n      case \"&\":\n        return left & right;\n      case \"^\":\n        return left ^ right;\n      case \"<<\":\n        return left << right;\n      case \">>\":\n        return left >> right;\n      case \">>>\":\n        return left >>> right;\n    }\n  }\n  if (path.isCallExpression()) {\n    const callee = path.get(\"callee\");\n    let context;\n    let func;\n    if (callee.isIdentifier() && !path.scope.getBinding(callee.node.name) && (isValidObjectCallee(callee.node.name) || isValidIdentifierCallee(callee.node.name))) {\n      func = global[callee.node.name];\n    }\n    if (callee.isMemberExpression()) {\n      const object = callee.get(\"object\");\n      const property = callee.get(\"property\");\n      if (object.isIdentifier() && property.isIdentifier() && isValidObjectCallee(object.node.name) && !isInvalidMethod(property.node.name)) {\n        context = global[object.node.name];\n        const key = property.node.name;\n        if (hasOwnProperty.call(context, key)) {\n          func = context[key];\n        }\n      }\n      if (object.isLiteral() && property.isIdentifier()) {\n        const type = typeof object.node.value;\n        if (type === \"string\" || type === \"number\") {\n          context = object.node.value;\n          func = context[property.node.name];\n        }\n      }\n    }\n    if (func) {\n      const args = path.get(\"arguments\").map(arg => evaluateCached(arg, state));\n      if (!state.confident) return;\n      return func.apply(context, args);\n    }\n  }\n  deopt(path, state);\n}\nfunction evaluateQuasis(path, quasis, state, raw = false) {\n  let str = \"\";\n  let i = 0;\n  const exprs = path.isTemplateLiteral() ? path.get(\"expressions\") : path.get(\"quasi.expressions\");\n  for (const elem of quasis) {\n    if (!state.confident) break;\n    str += raw ? elem.value.raw : elem.value.cooked;\n    const expr = exprs[i++];\n    if (expr) str += String(evaluateCached(expr, state));\n  }\n  if (!state.confident) return;\n  return str;\n}\nfunction evaluate() {\n  const state = {\n    confident: true,\n    deoptPath: null,\n    seen: new Map()\n  };\n  let value = evaluateCached(this, state);\n  if (!state.confident) value = undefined;\n  return {\n    confident: state.confident,\n    deopt: state.deoptPath,\n    value: value\n  };\n}\n\n//# sourceMappingURL=evaluation.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGJhYmVsL3RyYXZlcnNlL2xpYi9wYXRoL2V2YWx1YXRpb24uanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWIsOENBQTZDO0FBQzdDO0FBQ0EsQ0FBQyxFQUFDO0FBQ0YsZ0JBQWdCO0FBQ2hCLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtEQUFrRCxPQUFPO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9yZXBvLXZpc3VhbGl6ZXIvLi9ub2RlX21vZHVsZXMvQGJhYmVsL3RyYXZlcnNlL2xpYi9wYXRoL2V2YWx1YXRpb24uanM/ZDQ3ZSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuZXZhbHVhdGUgPSBldmFsdWF0ZTtcbmV4cG9ydHMuZXZhbHVhdGVUcnV0aHkgPSBldmFsdWF0ZVRydXRoeTtcbmNvbnN0IFZBTElEX09CSkVDVF9DQUxMRUVTID0gW1wiTnVtYmVyXCIsIFwiU3RyaW5nXCIsIFwiTWF0aFwiXTtcbmNvbnN0IFZBTElEX0lERU5USUZJRVJfQ0FMTEVFUyA9IFtcImlzRmluaXRlXCIsIFwiaXNOYU5cIiwgXCJwYXJzZUZsb2F0XCIsIFwicGFyc2VJbnRcIiwgXCJkZWNvZGVVUklcIiwgXCJkZWNvZGVVUklDb21wb25lbnRcIiwgXCJlbmNvZGVVUklcIiwgXCJlbmNvZGVVUklDb21wb25lbnRcIiwgbnVsbCwgbnVsbF07XG5jb25zdCBJTlZBTElEX01FVEhPRFMgPSBbXCJyYW5kb21cIl07XG5mdW5jdGlvbiBpc1ZhbGlkT2JqZWN0Q2FsbGVlKHZhbCkge1xuICByZXR1cm4gVkFMSURfT0JKRUNUX0NBTExFRVMuaW5jbHVkZXModmFsKTtcbn1cbmZ1bmN0aW9uIGlzVmFsaWRJZGVudGlmaWVyQ2FsbGVlKHZhbCkge1xuICByZXR1cm4gVkFMSURfSURFTlRJRklFUl9DQUxMRUVTLmluY2x1ZGVzKHZhbCk7XG59XG5mdW5jdGlvbiBpc0ludmFsaWRNZXRob2QodmFsKSB7XG4gIHJldHVybiBJTlZBTElEX01FVEhPRFMuaW5jbHVkZXModmFsKTtcbn1cbmZ1bmN0aW9uIGV2YWx1YXRlVHJ1dGh5KCkge1xuICBjb25zdCByZXMgPSB0aGlzLmV2YWx1YXRlKCk7XG4gIGlmIChyZXMuY29uZmlkZW50KSByZXR1cm4gISFyZXMudmFsdWU7XG59XG5mdW5jdGlvbiBkZW9wdChwYXRoLCBzdGF0ZSkge1xuICBpZiAoIXN0YXRlLmNvbmZpZGVudCkgcmV0dXJuO1xuICBzdGF0ZS5kZW9wdFBhdGggPSBwYXRoO1xuICBzdGF0ZS5jb25maWRlbnQgPSBmYWxzZTtcbn1cbmNvbnN0IEdsb2JhbHMgPSBuZXcgTWFwKFtbXCJ1bmRlZmluZWRcIiwgdW5kZWZpbmVkXSwgW1wiSW5maW5pdHlcIiwgSW5maW5pdHldLCBbXCJOYU5cIiwgTmFOXV0pO1xuZnVuY3Rpb24gZXZhbHVhdGVDYWNoZWQocGF0aCwgc3RhdGUpIHtcbiAgY29uc3Qge1xuICAgIG5vZGVcbiAgfSA9IHBhdGg7XG4gIGNvbnN0IHtcbiAgICBzZWVuXG4gIH0gPSBzdGF0ZTtcbiAgaWYgKHNlZW4uaGFzKG5vZGUpKSB7XG4gICAgY29uc3QgZXhpc3RpbmcgPSBzZWVuLmdldChub2RlKTtcbiAgICBpZiAoZXhpc3RpbmcucmVzb2x2ZWQpIHtcbiAgICAgIHJldHVybiBleGlzdGluZy52YWx1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgZGVvcHQocGF0aCwgc3RhdGUpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBjb25zdCBpdGVtID0ge1xuICAgICAgcmVzb2x2ZWQ6IGZhbHNlXG4gICAgfTtcbiAgICBzZWVuLnNldChub2RlLCBpdGVtKTtcbiAgICBjb25zdCB2YWwgPSBfZXZhbHVhdGUocGF0aCwgc3RhdGUpO1xuICAgIGlmIChzdGF0ZS5jb25maWRlbnQpIHtcbiAgICAgIGl0ZW0ucmVzb2x2ZWQgPSB0cnVlO1xuICAgICAgaXRlbS52YWx1ZSA9IHZhbDtcbiAgICB9XG4gICAgcmV0dXJuIHZhbDtcbiAgfVxufVxuZnVuY3Rpb24gX2V2YWx1YXRlKHBhdGgsIHN0YXRlKSB7XG4gIGlmICghc3RhdGUuY29uZmlkZW50KSByZXR1cm47XG4gIGlmIChwYXRoLmlzU2VxdWVuY2VFeHByZXNzaW9uKCkpIHtcbiAgICBjb25zdCBleHBycyA9IHBhdGguZ2V0KFwiZXhwcmVzc2lvbnNcIik7XG4gICAgcmV0dXJuIGV2YWx1YXRlQ2FjaGVkKGV4cHJzW2V4cHJzLmxlbmd0aCAtIDFdLCBzdGF0ZSk7XG4gIH1cbiAgaWYgKHBhdGguaXNTdHJpbmdMaXRlcmFsKCkgfHwgcGF0aC5pc051bWVyaWNMaXRlcmFsKCkgfHwgcGF0aC5pc0Jvb2xlYW5MaXRlcmFsKCkpIHtcbiAgICByZXR1cm4gcGF0aC5ub2RlLnZhbHVlO1xuICB9XG4gIGlmIChwYXRoLmlzTnVsbExpdGVyYWwoKSkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIGlmIChwYXRoLmlzVGVtcGxhdGVMaXRlcmFsKCkpIHtcbiAgICByZXR1cm4gZXZhbHVhdGVRdWFzaXMocGF0aCwgcGF0aC5ub2RlLnF1YXNpcywgc3RhdGUpO1xuICB9XG4gIGlmIChwYXRoLmlzVGFnZ2VkVGVtcGxhdGVFeHByZXNzaW9uKCkgJiYgcGF0aC5nZXQoXCJ0YWdcIikuaXNNZW1iZXJFeHByZXNzaW9uKCkpIHtcbiAgICBjb25zdCBvYmplY3QgPSBwYXRoLmdldChcInRhZy5vYmplY3RcIik7XG4gICAgY29uc3Qge1xuICAgICAgbm9kZToge1xuICAgICAgICBuYW1lXG4gICAgICB9XG4gICAgfSA9IG9iamVjdDtcbiAgICBjb25zdCBwcm9wZXJ0eSA9IHBhdGguZ2V0KFwidGFnLnByb3BlcnR5XCIpO1xuICAgIGlmIChvYmplY3QuaXNJZGVudGlmaWVyKCkgJiYgbmFtZSA9PT0gXCJTdHJpbmdcIiAmJiAhcGF0aC5zY29wZS5nZXRCaW5kaW5nKG5hbWUpICYmIHByb3BlcnR5LmlzSWRlbnRpZmllcigpICYmIHByb3BlcnR5Lm5vZGUubmFtZSA9PT0gXCJyYXdcIikge1xuICAgICAgcmV0dXJuIGV2YWx1YXRlUXVhc2lzKHBhdGgsIHBhdGgubm9kZS5xdWFzaS5xdWFzaXMsIHN0YXRlLCB0cnVlKTtcbiAgICB9XG4gIH1cbiAgaWYgKHBhdGguaXNDb25kaXRpb25hbEV4cHJlc3Npb24oKSkge1xuICAgIGNvbnN0IHRlc3RSZXN1bHQgPSBldmFsdWF0ZUNhY2hlZChwYXRoLmdldChcInRlc3RcIiksIHN0YXRlKTtcbiAgICBpZiAoIXN0YXRlLmNvbmZpZGVudCkgcmV0dXJuO1xuICAgIGlmICh0ZXN0UmVzdWx0KSB7XG4gICAgICByZXR1cm4gZXZhbHVhdGVDYWNoZWQocGF0aC5nZXQoXCJjb25zZXF1ZW50XCIpLCBzdGF0ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBldmFsdWF0ZUNhY2hlZChwYXRoLmdldChcImFsdGVybmF0ZVwiKSwgc3RhdGUpO1xuICAgIH1cbiAgfVxuICBpZiAocGF0aC5pc0V4cHJlc3Npb25XcmFwcGVyKCkpIHtcbiAgICByZXR1cm4gZXZhbHVhdGVDYWNoZWQocGF0aC5nZXQoXCJleHByZXNzaW9uXCIpLCBzdGF0ZSk7XG4gIH1cbiAgaWYgKHBhdGguaXNNZW1iZXJFeHByZXNzaW9uKCkgJiYgIXBhdGgucGFyZW50UGF0aC5pc0NhbGxFeHByZXNzaW9uKHtcbiAgICBjYWxsZWU6IHBhdGgubm9kZVxuICB9KSkge1xuICAgIGNvbnN0IHByb3BlcnR5ID0gcGF0aC5nZXQoXCJwcm9wZXJ0eVwiKTtcbiAgICBjb25zdCBvYmplY3QgPSBwYXRoLmdldChcIm9iamVjdFwiKTtcbiAgICBpZiAob2JqZWN0LmlzTGl0ZXJhbCgpKSB7XG4gICAgICBjb25zdCB2YWx1ZSA9IG9iamVjdC5ub2RlLnZhbHVlO1xuICAgICAgY29uc3QgdHlwZSA9IHR5cGVvZiB2YWx1ZTtcbiAgICAgIGxldCBrZXkgPSBudWxsO1xuICAgICAgaWYgKHBhdGgubm9kZS5jb21wdXRlZCkge1xuICAgICAgICBrZXkgPSBldmFsdWF0ZUNhY2hlZChwcm9wZXJ0eSwgc3RhdGUpO1xuICAgICAgICBpZiAoIXN0YXRlLmNvbmZpZGVudCkgcmV0dXJuO1xuICAgICAgfSBlbHNlIGlmIChwcm9wZXJ0eS5pc0lkZW50aWZpZXIoKSkge1xuICAgICAgICBrZXkgPSBwcm9wZXJ0eS5ub2RlLm5hbWU7XG4gICAgICB9XG4gICAgICBpZiAoKHR5cGUgPT09IFwibnVtYmVyXCIgfHwgdHlwZSA9PT0gXCJzdHJpbmdcIikgJiYga2V5ICE9IG51bGwgJiYgKHR5cGVvZiBrZXkgPT09IFwibnVtYmVyXCIgfHwgdHlwZW9mIGtleSA9PT0gXCJzdHJpbmdcIikpIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlW2tleV07XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGlmIChwYXRoLmlzUmVmZXJlbmNlZElkZW50aWZpZXIoKSkge1xuICAgIGNvbnN0IGJpbmRpbmcgPSBwYXRoLnNjb3BlLmdldEJpbmRpbmcocGF0aC5ub2RlLm5hbWUpO1xuICAgIGlmIChiaW5kaW5nKSB7XG4gICAgICBpZiAoYmluZGluZy5jb25zdGFudFZpb2xhdGlvbnMubGVuZ3RoID4gMCB8fCBwYXRoLm5vZGUuc3RhcnQgPCBiaW5kaW5nLnBhdGgubm9kZS5lbmQpIHtcbiAgICAgICAgZGVvcHQoYmluZGluZy5wYXRoLCBzdGF0ZSk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGJpbmRpbmdQYXRoU2NvcGUgPSBiaW5kaW5nLnBhdGguc2NvcGU7XG4gICAgICBpZiAoYmluZGluZy5raW5kID09PSBcInZhclwiICYmIGJpbmRpbmdQYXRoU2NvcGUgIT09IGJpbmRpbmcuc2NvcGUpIHtcbiAgICAgICAgbGV0IGhhc1Vuc2FmZUJsb2NrID0gIWJpbmRpbmdQYXRoU2NvcGUucGF0aC5wYXJlbnRQYXRoLmlzQmxvY2tTdGF0ZW1lbnQoKTtcbiAgICAgICAgZm9yIChsZXQgc2NvcGUgPSBiaW5kaW5nUGF0aFNjb3BlLnBhcmVudDsgc2NvcGU7IHNjb3BlID0gc2NvcGUucGFyZW50KSB7XG4gICAgICAgICAgdmFyIF9zY29wZSRwYXRoJHBhcmVudFBhdDtcbiAgICAgICAgICBpZiAoc2NvcGUgPT09IHBhdGguc2NvcGUpIHtcbiAgICAgICAgICAgIGlmIChoYXNVbnNhZmVCbG9jaykge1xuICAgICAgICAgICAgICBkZW9wdChiaW5kaW5nLnBhdGgsIHN0YXRlKTtcbiAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICgoX3Njb3BlJHBhdGgkcGFyZW50UGF0ID0gc2NvcGUucGF0aC5wYXJlbnRQYXRoKSAhPSBudWxsICYmIF9zY29wZSRwYXRoJHBhcmVudFBhdC5pc0Jsb2NrU3RhdGVtZW50KCkpIHtcbiAgICAgICAgICAgIGhhc1Vuc2FmZUJsb2NrID0gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChiaW5kaW5nLmhhc1ZhbHVlKSB7XG4gICAgICAgIHJldHVybiBiaW5kaW5nLnZhbHVlO1xuICAgICAgfVxuICAgIH1cbiAgICBjb25zdCBuYW1lID0gcGF0aC5ub2RlLm5hbWU7XG4gICAgaWYgKEdsb2JhbHMuaGFzKG5hbWUpKSB7XG4gICAgICBpZiAoIWJpbmRpbmcpIHtcbiAgICAgICAgcmV0dXJuIEdsb2JhbHMuZ2V0KG5hbWUpO1xuICAgICAgfVxuICAgICAgZGVvcHQoYmluZGluZy5wYXRoLCBzdGF0ZSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICghYmluZGluZykge1xuICAgICAgZGVvcHQocGF0aCwgc3RhdGUpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBiaW5kaW5nUGF0aCA9IGJpbmRpbmcucGF0aDtcbiAgICBpZiAoIWJpbmRpbmdQYXRoLmlzVmFyaWFibGVEZWNsYXJhdG9yKCkpIHtcbiAgICAgIGRlb3B0KGJpbmRpbmdQYXRoLCBzdGF0ZSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IGluaXRQYXRoID0gYmluZGluZ1BhdGguZ2V0KFwiaW5pdFwiKTtcbiAgICBjb25zdCB2YWx1ZSA9IGV2YWx1YXRlQ2FjaGVkKGluaXRQYXRoLCBzdGF0ZSk7XG4gICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gXCJvYmplY3RcIiAmJiB2YWx1ZSAhPT0gbnVsbCAmJiBiaW5kaW5nLnJlZmVyZW5jZXMgPiAxKSB7XG4gICAgICBkZW9wdChpbml0UGF0aCwgc3RhdGUpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICByZXR1cm4gdmFsdWU7XG4gIH1cbiAgaWYgKHBhdGguaXNVbmFyeUV4cHJlc3Npb24oe1xuICAgIHByZWZpeDogdHJ1ZVxuICB9KSkge1xuICAgIGlmIChwYXRoLm5vZGUub3BlcmF0b3IgPT09IFwidm9pZFwiKSB7XG4gICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cbiAgICBjb25zdCBhcmd1bWVudCA9IHBhdGguZ2V0KFwiYXJndW1lbnRcIik7XG4gICAgaWYgKHBhdGgubm9kZS5vcGVyYXRvciA9PT0gXCJ0eXBlb2ZcIiAmJiAoYXJndW1lbnQuaXNGdW5jdGlvbigpIHx8IGFyZ3VtZW50LmlzQ2xhc3MoKSkpIHtcbiAgICAgIHJldHVybiBcImZ1bmN0aW9uXCI7XG4gICAgfVxuICAgIGNvbnN0IGFyZyA9IGV2YWx1YXRlQ2FjaGVkKGFyZ3VtZW50LCBzdGF0ZSk7XG4gICAgaWYgKCFzdGF0ZS5jb25maWRlbnQpIHJldHVybjtcbiAgICBzd2l0Y2ggKHBhdGgubm9kZS5vcGVyYXRvcikge1xuICAgICAgY2FzZSBcIiFcIjpcbiAgICAgICAgcmV0dXJuICFhcmc7XG4gICAgICBjYXNlIFwiK1wiOlxuICAgICAgICByZXR1cm4gK2FyZztcbiAgICAgIGNhc2UgXCItXCI6XG4gICAgICAgIHJldHVybiAtYXJnO1xuICAgICAgY2FzZSBcIn5cIjpcbiAgICAgICAgcmV0dXJuIH5hcmc7XG4gICAgICBjYXNlIFwidHlwZW9mXCI6XG4gICAgICAgIHJldHVybiB0eXBlb2YgYXJnO1xuICAgIH1cbiAgfVxuICBpZiAocGF0aC5pc0FycmF5RXhwcmVzc2lvbigpKSB7XG4gICAgY29uc3QgYXJyID0gW107XG4gICAgY29uc3QgZWxlbXMgPSBwYXRoLmdldChcImVsZW1lbnRzXCIpO1xuICAgIGZvciAoY29uc3QgZWxlbSBvZiBlbGVtcykge1xuICAgICAgY29uc3QgZWxlbVZhbHVlID0gZWxlbS5ldmFsdWF0ZSgpO1xuICAgICAgaWYgKGVsZW1WYWx1ZS5jb25maWRlbnQpIHtcbiAgICAgICAgYXJyLnB1c2goZWxlbVZhbHVlLnZhbHVlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGRlb3B0KGVsZW1WYWx1ZS5kZW9wdCwgc3RhdGUpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBhcnI7XG4gIH1cbiAgaWYgKHBhdGguaXNPYmplY3RFeHByZXNzaW9uKCkpIHtcbiAgICBjb25zdCBvYmogPSB7fTtcbiAgICBjb25zdCBwcm9wcyA9IHBhdGguZ2V0KFwicHJvcGVydGllc1wiKTtcbiAgICBmb3IgKGNvbnN0IHByb3Agb2YgcHJvcHMpIHtcbiAgICAgIGlmIChwcm9wLmlzT2JqZWN0TWV0aG9kKCkgfHwgcHJvcC5pc1NwcmVhZEVsZW1lbnQoKSkge1xuICAgICAgICBkZW9wdChwcm9wLCBzdGF0ZSk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGtleVBhdGggPSBwcm9wLmdldChcImtleVwiKTtcbiAgICAgIGxldCBrZXk7XG4gICAgICBpZiAocHJvcC5ub2RlLmNvbXB1dGVkKSB7XG4gICAgICAgIGtleSA9IGtleVBhdGguZXZhbHVhdGUoKTtcbiAgICAgICAgaWYgKCFrZXkuY29uZmlkZW50KSB7XG4gICAgICAgICAgZGVvcHQoa2V5LmRlb3B0LCBzdGF0ZSk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGtleSA9IGtleS52YWx1ZTtcbiAgICAgIH0gZWxzZSBpZiAoa2V5UGF0aC5pc0lkZW50aWZpZXIoKSkge1xuICAgICAgICBrZXkgPSBrZXlQYXRoLm5vZGUubmFtZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGtleSA9IGtleVBhdGgubm9kZS52YWx1ZTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHZhbHVlUGF0aCA9IHByb3AuZ2V0KFwidmFsdWVcIik7XG4gICAgICBsZXQgdmFsdWUgPSB2YWx1ZVBhdGguZXZhbHVhdGUoKTtcbiAgICAgIGlmICghdmFsdWUuY29uZmlkZW50KSB7XG4gICAgICAgIGRlb3B0KHZhbHVlLmRlb3B0LCBzdGF0ZSk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHZhbHVlID0gdmFsdWUudmFsdWU7XG4gICAgICBvYmpba2V5XSA9IHZhbHVlO1xuICAgIH1cbiAgICByZXR1cm4gb2JqO1xuICB9XG4gIGlmIChwYXRoLmlzTG9naWNhbEV4cHJlc3Npb24oKSkge1xuICAgIGNvbnN0IHdhc0NvbmZpZGVudCA9IHN0YXRlLmNvbmZpZGVudDtcbiAgICBjb25zdCBsZWZ0ID0gZXZhbHVhdGVDYWNoZWQocGF0aC5nZXQoXCJsZWZ0XCIpLCBzdGF0ZSk7XG4gICAgY29uc3QgbGVmdENvbmZpZGVudCA9IHN0YXRlLmNvbmZpZGVudDtcbiAgICBzdGF0ZS5jb25maWRlbnQgPSB3YXNDb25maWRlbnQ7XG4gICAgY29uc3QgcmlnaHQgPSBldmFsdWF0ZUNhY2hlZChwYXRoLmdldChcInJpZ2h0XCIpLCBzdGF0ZSk7XG4gICAgY29uc3QgcmlnaHRDb25maWRlbnQgPSBzdGF0ZS5jb25maWRlbnQ7XG4gICAgc3dpdGNoIChwYXRoLm5vZGUub3BlcmF0b3IpIHtcbiAgICAgIGNhc2UgXCJ8fFwiOlxuICAgICAgICBzdGF0ZS5jb25maWRlbnQgPSBsZWZ0Q29uZmlkZW50ICYmICghIWxlZnQgfHwgcmlnaHRDb25maWRlbnQpO1xuICAgICAgICBpZiAoIXN0YXRlLmNvbmZpZGVudCkgcmV0dXJuO1xuICAgICAgICByZXR1cm4gbGVmdCB8fCByaWdodDtcbiAgICAgIGNhc2UgXCImJlwiOlxuICAgICAgICBzdGF0ZS5jb25maWRlbnQgPSBsZWZ0Q29uZmlkZW50ICYmICghbGVmdCB8fCByaWdodENvbmZpZGVudCk7XG4gICAgICAgIGlmICghc3RhdGUuY29uZmlkZW50KSByZXR1cm47XG4gICAgICAgIHJldHVybiBsZWZ0ICYmIHJpZ2h0O1xuICAgICAgY2FzZSBcIj8/XCI6XG4gICAgICAgIHN0YXRlLmNvbmZpZGVudCA9IGxlZnRDb25maWRlbnQgJiYgKGxlZnQgIT0gbnVsbCB8fCByaWdodENvbmZpZGVudCk7XG4gICAgICAgIGlmICghc3RhdGUuY29uZmlkZW50KSByZXR1cm47XG4gICAgICAgIHJldHVybiBsZWZ0ICE9IG51bGwgPyBsZWZ0IDogcmlnaHQ7XG4gICAgfVxuICB9XG4gIGlmIChwYXRoLmlzQmluYXJ5RXhwcmVzc2lvbigpKSB7XG4gICAgY29uc3QgbGVmdCA9IGV2YWx1YXRlQ2FjaGVkKHBhdGguZ2V0KFwibGVmdFwiKSwgc3RhdGUpO1xuICAgIGlmICghc3RhdGUuY29uZmlkZW50KSByZXR1cm47XG4gICAgY29uc3QgcmlnaHQgPSBldmFsdWF0ZUNhY2hlZChwYXRoLmdldChcInJpZ2h0XCIpLCBzdGF0ZSk7XG4gICAgaWYgKCFzdGF0ZS5jb25maWRlbnQpIHJldHVybjtcbiAgICBzd2l0Y2ggKHBhdGgubm9kZS5vcGVyYXRvcikge1xuICAgICAgY2FzZSBcIi1cIjpcbiAgICAgICAgcmV0dXJuIGxlZnQgLSByaWdodDtcbiAgICAgIGNhc2UgXCIrXCI6XG4gICAgICAgIHJldHVybiBsZWZ0ICsgcmlnaHQ7XG4gICAgICBjYXNlIFwiL1wiOlxuICAgICAgICByZXR1cm4gbGVmdCAvIHJpZ2h0O1xuICAgICAgY2FzZSBcIipcIjpcbiAgICAgICAgcmV0dXJuIGxlZnQgKiByaWdodDtcbiAgICAgIGNhc2UgXCIlXCI6XG4gICAgICAgIHJldHVybiBsZWZ0ICUgcmlnaHQ7XG4gICAgICBjYXNlIFwiKipcIjpcbiAgICAgICAgcmV0dXJuIE1hdGgucG93KGxlZnQsIHJpZ2h0KTtcbiAgICAgIGNhc2UgXCI8XCI6XG4gICAgICAgIHJldHVybiBsZWZ0IDwgcmlnaHQ7XG4gICAgICBjYXNlIFwiPlwiOlxuICAgICAgICByZXR1cm4gbGVmdCA+IHJpZ2h0O1xuICAgICAgY2FzZSBcIjw9XCI6XG4gICAgICAgIHJldHVybiBsZWZ0IDw9IHJpZ2h0O1xuICAgICAgY2FzZSBcIj49XCI6XG4gICAgICAgIHJldHVybiBsZWZ0ID49IHJpZ2h0O1xuICAgICAgY2FzZSBcIj09XCI6XG4gICAgICAgIHJldHVybiBsZWZ0ID09IHJpZ2h0O1xuICAgICAgY2FzZSBcIiE9XCI6XG4gICAgICAgIHJldHVybiBsZWZ0ICE9IHJpZ2h0O1xuICAgICAgY2FzZSBcIj09PVwiOlxuICAgICAgICByZXR1cm4gbGVmdCA9PT0gcmlnaHQ7XG4gICAgICBjYXNlIFwiIT09XCI6XG4gICAgICAgIHJldHVybiBsZWZ0ICE9PSByaWdodDtcbiAgICAgIGNhc2UgXCJ8XCI6XG4gICAgICAgIHJldHVybiBsZWZ0IHwgcmlnaHQ7XG4gICAgICBjYXNlIFwiJlwiOlxuICAgICAgICByZXR1cm4gbGVmdCAmIHJpZ2h0O1xuICAgICAgY2FzZSBcIl5cIjpcbiAgICAgICAgcmV0dXJuIGxlZnQgXiByaWdodDtcbiAgICAgIGNhc2UgXCI8PFwiOlxuICAgICAgICByZXR1cm4gbGVmdCA8PCByaWdodDtcbiAgICAgIGNhc2UgXCI+PlwiOlxuICAgICAgICByZXR1cm4gbGVmdCA+PiByaWdodDtcbiAgICAgIGNhc2UgXCI+Pj5cIjpcbiAgICAgICAgcmV0dXJuIGxlZnQgPj4+IHJpZ2h0O1xuICAgIH1cbiAgfVxuICBpZiAocGF0aC5pc0NhbGxFeHByZXNzaW9uKCkpIHtcbiAgICBjb25zdCBjYWxsZWUgPSBwYXRoLmdldChcImNhbGxlZVwiKTtcbiAgICBsZXQgY29udGV4dDtcbiAgICBsZXQgZnVuYztcbiAgICBpZiAoY2FsbGVlLmlzSWRlbnRpZmllcigpICYmICFwYXRoLnNjb3BlLmdldEJpbmRpbmcoY2FsbGVlLm5vZGUubmFtZSkgJiYgKGlzVmFsaWRPYmplY3RDYWxsZWUoY2FsbGVlLm5vZGUubmFtZSkgfHwgaXNWYWxpZElkZW50aWZpZXJDYWxsZWUoY2FsbGVlLm5vZGUubmFtZSkpKSB7XG4gICAgICBmdW5jID0gZ2xvYmFsW2NhbGxlZS5ub2RlLm5hbWVdO1xuICAgIH1cbiAgICBpZiAoY2FsbGVlLmlzTWVtYmVyRXhwcmVzc2lvbigpKSB7XG4gICAgICBjb25zdCBvYmplY3QgPSBjYWxsZWUuZ2V0KFwib2JqZWN0XCIpO1xuICAgICAgY29uc3QgcHJvcGVydHkgPSBjYWxsZWUuZ2V0KFwicHJvcGVydHlcIik7XG4gICAgICBpZiAob2JqZWN0LmlzSWRlbnRpZmllcigpICYmIHByb3BlcnR5LmlzSWRlbnRpZmllcigpICYmIGlzVmFsaWRPYmplY3RDYWxsZWUob2JqZWN0Lm5vZGUubmFtZSkgJiYgIWlzSW52YWxpZE1ldGhvZChwcm9wZXJ0eS5ub2RlLm5hbWUpKSB7XG4gICAgICAgIGNvbnRleHQgPSBnbG9iYWxbb2JqZWN0Lm5vZGUubmFtZV07XG4gICAgICAgIGNvbnN0IGtleSA9IHByb3BlcnR5Lm5vZGUubmFtZTtcbiAgICAgICAgaWYgKGhhc093blByb3BlcnR5LmNhbGwoY29udGV4dCwga2V5KSkge1xuICAgICAgICAgIGZ1bmMgPSBjb250ZXh0W2tleV07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChvYmplY3QuaXNMaXRlcmFsKCkgJiYgcHJvcGVydHkuaXNJZGVudGlmaWVyKCkpIHtcbiAgICAgICAgY29uc3QgdHlwZSA9IHR5cGVvZiBvYmplY3Qubm9kZS52YWx1ZTtcbiAgICAgICAgaWYgKHR5cGUgPT09IFwic3RyaW5nXCIgfHwgdHlwZSA9PT0gXCJudW1iZXJcIikge1xuICAgICAgICAgIGNvbnRleHQgPSBvYmplY3Qubm9kZS52YWx1ZTtcbiAgICAgICAgICBmdW5jID0gY29udGV4dFtwcm9wZXJ0eS5ub2RlLm5hbWVdO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChmdW5jKSB7XG4gICAgICBjb25zdCBhcmdzID0gcGF0aC5nZXQoXCJhcmd1bWVudHNcIikubWFwKGFyZyA9PiBldmFsdWF0ZUNhY2hlZChhcmcsIHN0YXRlKSk7XG4gICAgICBpZiAoIXN0YXRlLmNvbmZpZGVudCkgcmV0dXJuO1xuICAgICAgcmV0dXJuIGZ1bmMuYXBwbHkoY29udGV4dCwgYXJncyk7XG4gICAgfVxuICB9XG4gIGRlb3B0KHBhdGgsIHN0YXRlKTtcbn1cbmZ1bmN0aW9uIGV2YWx1YXRlUXVhc2lzKHBhdGgsIHF1YXNpcywgc3RhdGUsIHJhdyA9IGZhbHNlKSB7XG4gIGxldCBzdHIgPSBcIlwiO1xuICBsZXQgaSA9IDA7XG4gIGNvbnN0IGV4cHJzID0gcGF0aC5pc1RlbXBsYXRlTGl0ZXJhbCgpID8gcGF0aC5nZXQoXCJleHByZXNzaW9uc1wiKSA6IHBhdGguZ2V0KFwicXVhc2kuZXhwcmVzc2lvbnNcIik7XG4gIGZvciAoY29uc3QgZWxlbSBvZiBxdWFzaXMpIHtcbiAgICBpZiAoIXN0YXRlLmNvbmZpZGVudCkgYnJlYWs7XG4gICAgc3RyICs9IHJhdyA/IGVsZW0udmFsdWUucmF3IDogZWxlbS52YWx1ZS5jb29rZWQ7XG4gICAgY29uc3QgZXhwciA9IGV4cHJzW2krK107XG4gICAgaWYgKGV4cHIpIHN0ciArPSBTdHJpbmcoZXZhbHVhdGVDYWNoZWQoZXhwciwgc3RhdGUpKTtcbiAgfVxuICBpZiAoIXN0YXRlLmNvbmZpZGVudCkgcmV0dXJuO1xuICByZXR1cm4gc3RyO1xufVxuZnVuY3Rpb24gZXZhbHVhdGUoKSB7XG4gIGNvbnN0IHN0YXRlID0ge1xuICAgIGNvbmZpZGVudDogdHJ1ZSxcbiAgICBkZW9wdFBhdGg6IG51bGwsXG4gICAgc2VlbjogbmV3IE1hcCgpXG4gIH07XG4gIGxldCB2YWx1ZSA9IGV2YWx1YXRlQ2FjaGVkKHRoaXMsIHN0YXRlKTtcbiAgaWYgKCFzdGF0ZS5jb25maWRlbnQpIHZhbHVlID0gdW5kZWZpbmVkO1xuICByZXR1cm4ge1xuICAgIGNvbmZpZGVudDogc3RhdGUuY29uZmlkZW50LFxuICAgIGRlb3B0OiBzdGF0ZS5kZW9wdFBhdGgsXG4gICAgdmFsdWU6IHZhbHVlXG4gIH07XG59XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWV2YWx1YXRpb24uanMubWFwXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@babel/traverse/lib/path/evaluation.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@babel/traverse/lib/path/family.js":
/*!*********************************************************!*\
  !*** ./node_modules/@babel/traverse/lib/path/family.js ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports._getKey = _getKey;\nexports._getPattern = _getPattern;\nexports.get = get;\nexports.getAllNextSiblings = getAllNextSiblings;\nexports.getAllPrevSiblings = getAllPrevSiblings;\nexports.getAssignmentIdentifiers = getAssignmentIdentifiers;\nexports.getBindingIdentifierPaths = getBindingIdentifierPaths;\nexports.getBindingIdentifiers = getBindingIdentifiers;\nexports.getCompletionRecords = getCompletionRecords;\nexports.getNextSibling = getNextSibling;\nexports.getOpposite = getOpposite;\nexports.getOuterBindingIdentifierPaths = getOuterBindingIdentifierPaths;\nexports.getOuterBindingIdentifiers = getOuterBindingIdentifiers;\nexports.getPrevSibling = getPrevSibling;\nexports.getSibling = getSibling;\nvar _index = __webpack_require__(/*! ./index.js */ \"(ssr)/./node_modules/@babel/traverse/lib/path/index.js\");\nvar _t = __webpack_require__(/*! @babel/types */ \"(ssr)/./node_modules/@babel/types/lib/index.js\");\nconst {\n  getAssignmentIdentifiers: _getAssignmentIdentifiers,\n  getBindingIdentifiers: _getBindingIdentifiers,\n  getOuterBindingIdentifiers: _getOuterBindingIdentifiers,\n  numericLiteral,\n  unaryExpression\n} = _t;\nconst NORMAL_COMPLETION = 0;\nconst BREAK_COMPLETION = 1;\nfunction NormalCompletion(path) {\n  return {\n    type: NORMAL_COMPLETION,\n    path\n  };\n}\nfunction BreakCompletion(path) {\n  return {\n    type: BREAK_COMPLETION,\n    path\n  };\n}\nfunction getOpposite() {\n  if (this.key === \"left\") {\n    return this.getSibling(\"right\");\n  } else if (this.key === \"right\") {\n    return this.getSibling(\"left\");\n  }\n  return null;\n}\nfunction addCompletionRecords(path, records, context) {\n  if (path) {\n    records.push(..._getCompletionRecords(path, context));\n  }\n  return records;\n}\nfunction completionRecordForSwitch(cases, records, context) {\n  let lastNormalCompletions = [];\n  for (let i = 0; i < cases.length; i++) {\n    const casePath = cases[i];\n    const caseCompletions = _getCompletionRecords(casePath, context);\n    const normalCompletions = [];\n    const breakCompletions = [];\n    for (const c of caseCompletions) {\n      if (c.type === NORMAL_COMPLETION) {\n        normalCompletions.push(c);\n      }\n      if (c.type === BREAK_COMPLETION) {\n        breakCompletions.push(c);\n      }\n    }\n    if (normalCompletions.length) {\n      lastNormalCompletions = normalCompletions;\n    }\n    records.push(...breakCompletions);\n  }\n  records.push(...lastNormalCompletions);\n  return records;\n}\nfunction normalCompletionToBreak(completions) {\n  completions.forEach(c => {\n    c.type = BREAK_COMPLETION;\n  });\n}\nfunction replaceBreakStatementInBreakCompletion(completions, reachable) {\n  completions.forEach(c => {\n    if (c.path.isBreakStatement({\n      label: null\n    })) {\n      if (reachable) {\n        c.path.replaceWith(unaryExpression(\"void\", numericLiteral(0)));\n      } else {\n        c.path.remove();\n      }\n    }\n  });\n}\nfunction getStatementListCompletion(paths, context) {\n  const completions = [];\n  if (context.canHaveBreak) {\n    let lastNormalCompletions = [];\n    for (let i = 0; i < paths.length; i++) {\n      const path = paths[i];\n      const newContext = Object.assign({}, context, {\n        inCaseClause: false\n      });\n      if (path.isBlockStatement() && (context.inCaseClause || context.shouldPopulateBreak)) {\n        newContext.shouldPopulateBreak = true;\n      } else {\n        newContext.shouldPopulateBreak = false;\n      }\n      const statementCompletions = _getCompletionRecords(path, newContext);\n      if (statementCompletions.length > 0 && statementCompletions.every(c => c.type === BREAK_COMPLETION)) {\n        if (lastNormalCompletions.length > 0 && statementCompletions.every(c => c.path.isBreakStatement({\n          label: null\n        }))) {\n          normalCompletionToBreak(lastNormalCompletions);\n          completions.push(...lastNormalCompletions);\n          if (lastNormalCompletions.some(c => c.path.isDeclaration())) {\n            completions.push(...statementCompletions);\n            if (!context.shouldPreserveBreak) {\n              replaceBreakStatementInBreakCompletion(statementCompletions, true);\n            }\n          }\n          if (!context.shouldPreserveBreak) {\n            replaceBreakStatementInBreakCompletion(statementCompletions, false);\n          }\n        } else {\n          completions.push(...statementCompletions);\n          if (!context.shouldPopulateBreak && !context.shouldPreserveBreak) {\n            replaceBreakStatementInBreakCompletion(statementCompletions, true);\n          }\n        }\n        break;\n      }\n      if (i === paths.length - 1) {\n        completions.push(...statementCompletions);\n      } else {\n        lastNormalCompletions = [];\n        for (let i = 0; i < statementCompletions.length; i++) {\n          const c = statementCompletions[i];\n          if (c.type === BREAK_COMPLETION) {\n            completions.push(c);\n          }\n          if (c.type === NORMAL_COMPLETION) {\n            lastNormalCompletions.push(c);\n          }\n        }\n      }\n    }\n  } else if (paths.length) {\n    for (let i = paths.length - 1; i >= 0; i--) {\n      const pathCompletions = _getCompletionRecords(paths[i], context);\n      if (pathCompletions.length > 1 || pathCompletions.length === 1 && !pathCompletions[0].path.isVariableDeclaration() && !pathCompletions[0].path.isEmptyStatement()) {\n        completions.push(...pathCompletions);\n        break;\n      }\n    }\n  }\n  return completions;\n}\nfunction _getCompletionRecords(path, context) {\n  let records = [];\n  if (path.isIfStatement()) {\n    records = addCompletionRecords(path.get(\"consequent\"), records, context);\n    records = addCompletionRecords(path.get(\"alternate\"), records, context);\n  } else if (path.isDoExpression() || path.isFor() || path.isWhile() || path.isLabeledStatement()) {\n    return addCompletionRecords(path.get(\"body\"), records, context);\n  } else if (path.isProgram() || path.isBlockStatement()) {\n    return getStatementListCompletion(path.get(\"body\"), context);\n  } else if (path.isFunction()) {\n    return _getCompletionRecords(path.get(\"body\"), context);\n  } else if (path.isTryStatement()) {\n    records = addCompletionRecords(path.get(\"block\"), records, context);\n    records = addCompletionRecords(path.get(\"handler\"), records, context);\n  } else if (path.isCatchClause()) {\n    return addCompletionRecords(path.get(\"body\"), records, context);\n  } else if (path.isSwitchStatement()) {\n    return completionRecordForSwitch(path.get(\"cases\"), records, context);\n  } else if (path.isSwitchCase()) {\n    return getStatementListCompletion(path.get(\"consequent\"), {\n      canHaveBreak: true,\n      shouldPopulateBreak: false,\n      inCaseClause: true,\n      shouldPreserveBreak: context.shouldPreserveBreak\n    });\n  } else if (path.isBreakStatement()) {\n    records.push(BreakCompletion(path));\n  } else {\n    records.push(NormalCompletion(path));\n  }\n  return records;\n}\nfunction getCompletionRecords(shouldPreserveBreak = false) {\n  const records = _getCompletionRecords(this, {\n    canHaveBreak: false,\n    shouldPopulateBreak: false,\n    inCaseClause: false,\n    shouldPreserveBreak\n  });\n  return records.map(r => r.path);\n}\nfunction getSibling(key) {\n  return _index.default.get({\n    parentPath: this.parentPath,\n    parent: this.parent,\n    container: this.container,\n    listKey: this.listKey,\n    key: key\n  }).setContext(this.context);\n}\nfunction getPrevSibling() {\n  return this.getSibling(this.key - 1);\n}\nfunction getNextSibling() {\n  return this.getSibling(this.key + 1);\n}\nfunction getAllNextSiblings() {\n  let _key = this.key;\n  let sibling = this.getSibling(++_key);\n  const siblings = [];\n  while (sibling.node) {\n    siblings.push(sibling);\n    sibling = this.getSibling(++_key);\n  }\n  return siblings;\n}\nfunction getAllPrevSiblings() {\n  let _key = this.key;\n  let sibling = this.getSibling(--_key);\n  const siblings = [];\n  while (sibling.node) {\n    siblings.push(sibling);\n    sibling = this.getSibling(--_key);\n  }\n  return siblings;\n}\nfunction get(key, context = true) {\n  if (context === true) context = this.context;\n  const parts = key.split(\".\");\n  if (parts.length === 1) {\n    return _getKey.call(this, key, context);\n  } else {\n    return _getPattern.call(this, parts, context);\n  }\n}\nfunction _getKey(key, context) {\n  const node = this.node;\n  const container = node[key];\n  if (Array.isArray(container)) {\n    return container.map((_, i) => {\n      return _index.default.get({\n        listKey: key,\n        parentPath: this,\n        parent: node,\n        container: container,\n        key: i\n      }).setContext(context);\n    });\n  } else {\n    return _index.default.get({\n      parentPath: this,\n      parent: node,\n      container: node,\n      key: key\n    }).setContext(context);\n  }\n}\nfunction _getPattern(parts, context) {\n  let path = this;\n  for (const part of parts) {\n    if (part === \".\") {\n      path = path.parentPath;\n    } else {\n      if (Array.isArray(path)) {\n        path = path[part];\n      } else {\n        path = path.get(part, context);\n      }\n    }\n  }\n  return path;\n}\nfunction getAssignmentIdentifiers() {\n  return _getAssignmentIdentifiers(this.node);\n}\nfunction getBindingIdentifiers(duplicates) {\n  return _getBindingIdentifiers(this.node, duplicates);\n}\nfunction getOuterBindingIdentifiers(duplicates) {\n  return _getOuterBindingIdentifiers(this.node, duplicates);\n}\nfunction getBindingIdentifierPaths(duplicates = false, outerOnly = false) {\n  const path = this;\n  const search = [path];\n  const ids = Object.create(null);\n  while (search.length) {\n    const id = search.shift();\n    if (!id) continue;\n    if (!id.node) continue;\n    const keys = _getBindingIdentifiers.keys[id.node.type];\n    if (id.isIdentifier()) {\n      if (duplicates) {\n        const _ids = ids[id.node.name] = ids[id.node.name] || [];\n        _ids.push(id);\n      } else {\n        ids[id.node.name] = id;\n      }\n      continue;\n    }\n    if (id.isExportDeclaration()) {\n      const declaration = id.get(\"declaration\");\n      if (declaration.isDeclaration()) {\n        search.push(declaration);\n      }\n      continue;\n    }\n    if (outerOnly) {\n      if (id.isFunctionDeclaration()) {\n        search.push(id.get(\"id\"));\n        continue;\n      }\n      if (id.isFunctionExpression()) {\n        continue;\n      }\n    }\n    if (keys) {\n      for (let i = 0; i < keys.length; i++) {\n        const key = keys[i];\n        const child = id.get(key);\n        if (Array.isArray(child)) {\n          search.push(...child);\n        } else if (child.node) {\n          search.push(child);\n        }\n      }\n    }\n  }\n  return ids;\n}\nfunction getOuterBindingIdentifierPaths(duplicates = false) {\n  return this.getBindingIdentifierPaths(duplicates, true);\n}\n\n//# sourceMappingURL=family.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGJhYmVsL3RyYXZlcnNlL2xpYi9wYXRoL2ZhbWlseS5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYiw4Q0FBNkM7QUFDN0M7QUFDQSxDQUFDLEVBQUM7QUFDRixlQUFlO0FBQ2YsbUJBQW1CO0FBQ25CLFdBQVc7QUFDWCwwQkFBMEI7QUFDMUIsMEJBQTBCO0FBQzFCLGdDQUFnQztBQUNoQyxpQ0FBaUM7QUFDakMsNkJBQTZCO0FBQzdCLDRCQUE0QjtBQUM1QixzQkFBc0I7QUFDdEIsbUJBQW1CO0FBQ25CLHNDQUFzQztBQUN0QyxrQ0FBa0M7QUFDbEMsc0JBQXNCO0FBQ3RCLGtCQUFrQjtBQUNsQixhQUFhLG1CQUFPLENBQUMsMEVBQVk7QUFDakMsU0FBUyxtQkFBTyxDQUFDLG9FQUFjO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixrQkFBa0I7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0Isa0JBQWtCO0FBQ3RDO0FBQ0EseUNBQXlDO0FBQ3pDO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0Esd0JBQXdCLGlDQUFpQztBQUN6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSixtQ0FBbUMsUUFBUTtBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQSxJQUFJO0FBQ0o7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxJQUFJO0FBQ0o7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0wsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsaUJBQWlCO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcmVwby12aXN1YWxpemVyLy4vbm9kZV9tb2R1bGVzL0BiYWJlbC90cmF2ZXJzZS9saWIvcGF0aC9mYW1pbHkuanM/MDVmNCJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuX2dldEtleSA9IF9nZXRLZXk7XG5leHBvcnRzLl9nZXRQYXR0ZXJuID0gX2dldFBhdHRlcm47XG5leHBvcnRzLmdldCA9IGdldDtcbmV4cG9ydHMuZ2V0QWxsTmV4dFNpYmxpbmdzID0gZ2V0QWxsTmV4dFNpYmxpbmdzO1xuZXhwb3J0cy5nZXRBbGxQcmV2U2libGluZ3MgPSBnZXRBbGxQcmV2U2libGluZ3M7XG5leHBvcnRzLmdldEFzc2lnbm1lbnRJZGVudGlmaWVycyA9IGdldEFzc2lnbm1lbnRJZGVudGlmaWVycztcbmV4cG9ydHMuZ2V0QmluZGluZ0lkZW50aWZpZXJQYXRocyA9IGdldEJpbmRpbmdJZGVudGlmaWVyUGF0aHM7XG5leHBvcnRzLmdldEJpbmRpbmdJZGVudGlmaWVycyA9IGdldEJpbmRpbmdJZGVudGlmaWVycztcbmV4cG9ydHMuZ2V0Q29tcGxldGlvblJlY29yZHMgPSBnZXRDb21wbGV0aW9uUmVjb3JkcztcbmV4cG9ydHMuZ2V0TmV4dFNpYmxpbmcgPSBnZXROZXh0U2libGluZztcbmV4cG9ydHMuZ2V0T3Bwb3NpdGUgPSBnZXRPcHBvc2l0ZTtcbmV4cG9ydHMuZ2V0T3V0ZXJCaW5kaW5nSWRlbnRpZmllclBhdGhzID0gZ2V0T3V0ZXJCaW5kaW5nSWRlbnRpZmllclBhdGhzO1xuZXhwb3J0cy5nZXRPdXRlckJpbmRpbmdJZGVudGlmaWVycyA9IGdldE91dGVyQmluZGluZ0lkZW50aWZpZXJzO1xuZXhwb3J0cy5nZXRQcmV2U2libGluZyA9IGdldFByZXZTaWJsaW5nO1xuZXhwb3J0cy5nZXRTaWJsaW5nID0gZ2V0U2libGluZztcbnZhciBfaW5kZXggPSByZXF1aXJlKFwiLi9pbmRleC5qc1wiKTtcbnZhciBfdCA9IHJlcXVpcmUoXCJAYmFiZWwvdHlwZXNcIik7XG5jb25zdCB7XG4gIGdldEFzc2lnbm1lbnRJZGVudGlmaWVyczogX2dldEFzc2lnbm1lbnRJZGVudGlmaWVycyxcbiAgZ2V0QmluZGluZ0lkZW50aWZpZXJzOiBfZ2V0QmluZGluZ0lkZW50aWZpZXJzLFxuICBnZXRPdXRlckJpbmRpbmdJZGVudGlmaWVyczogX2dldE91dGVyQmluZGluZ0lkZW50aWZpZXJzLFxuICBudW1lcmljTGl0ZXJhbCxcbiAgdW5hcnlFeHByZXNzaW9uXG59ID0gX3Q7XG5jb25zdCBOT1JNQUxfQ09NUExFVElPTiA9IDA7XG5jb25zdCBCUkVBS19DT01QTEVUSU9OID0gMTtcbmZ1bmN0aW9uIE5vcm1hbENvbXBsZXRpb24ocGF0aCkge1xuICByZXR1cm4ge1xuICAgIHR5cGU6IE5PUk1BTF9DT01QTEVUSU9OLFxuICAgIHBhdGhcbiAgfTtcbn1cbmZ1bmN0aW9uIEJyZWFrQ29tcGxldGlvbihwYXRoKSB7XG4gIHJldHVybiB7XG4gICAgdHlwZTogQlJFQUtfQ09NUExFVElPTixcbiAgICBwYXRoXG4gIH07XG59XG5mdW5jdGlvbiBnZXRPcHBvc2l0ZSgpIHtcbiAgaWYgKHRoaXMua2V5ID09PSBcImxlZnRcIikge1xuICAgIHJldHVybiB0aGlzLmdldFNpYmxpbmcoXCJyaWdodFwiKTtcbiAgfSBlbHNlIGlmICh0aGlzLmtleSA9PT0gXCJyaWdodFwiKSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0U2libGluZyhcImxlZnRcIik7XG4gIH1cbiAgcmV0dXJuIG51bGw7XG59XG5mdW5jdGlvbiBhZGRDb21wbGV0aW9uUmVjb3JkcyhwYXRoLCByZWNvcmRzLCBjb250ZXh0KSB7XG4gIGlmIChwYXRoKSB7XG4gICAgcmVjb3Jkcy5wdXNoKC4uLl9nZXRDb21wbGV0aW9uUmVjb3JkcyhwYXRoLCBjb250ZXh0KSk7XG4gIH1cbiAgcmV0dXJuIHJlY29yZHM7XG59XG5mdW5jdGlvbiBjb21wbGV0aW9uUmVjb3JkRm9yU3dpdGNoKGNhc2VzLCByZWNvcmRzLCBjb250ZXh0KSB7XG4gIGxldCBsYXN0Tm9ybWFsQ29tcGxldGlvbnMgPSBbXTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBjYXNlcy5sZW5ndGg7IGkrKykge1xuICAgIGNvbnN0IGNhc2VQYXRoID0gY2FzZXNbaV07XG4gICAgY29uc3QgY2FzZUNvbXBsZXRpb25zID0gX2dldENvbXBsZXRpb25SZWNvcmRzKGNhc2VQYXRoLCBjb250ZXh0KTtcbiAgICBjb25zdCBub3JtYWxDb21wbGV0aW9ucyA9IFtdO1xuICAgIGNvbnN0IGJyZWFrQ29tcGxldGlvbnMgPSBbXTtcbiAgICBmb3IgKGNvbnN0IGMgb2YgY2FzZUNvbXBsZXRpb25zKSB7XG4gICAgICBpZiAoYy50eXBlID09PSBOT1JNQUxfQ09NUExFVElPTikge1xuICAgICAgICBub3JtYWxDb21wbGV0aW9ucy5wdXNoKGMpO1xuICAgICAgfVxuICAgICAgaWYgKGMudHlwZSA9PT0gQlJFQUtfQ09NUExFVElPTikge1xuICAgICAgICBicmVha0NvbXBsZXRpb25zLnB1c2goYyk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChub3JtYWxDb21wbGV0aW9ucy5sZW5ndGgpIHtcbiAgICAgIGxhc3ROb3JtYWxDb21wbGV0aW9ucyA9IG5vcm1hbENvbXBsZXRpb25zO1xuICAgIH1cbiAgICByZWNvcmRzLnB1c2goLi4uYnJlYWtDb21wbGV0aW9ucyk7XG4gIH1cbiAgcmVjb3Jkcy5wdXNoKC4uLmxhc3ROb3JtYWxDb21wbGV0aW9ucyk7XG4gIHJldHVybiByZWNvcmRzO1xufVxuZnVuY3Rpb24gbm9ybWFsQ29tcGxldGlvblRvQnJlYWsoY29tcGxldGlvbnMpIHtcbiAgY29tcGxldGlvbnMuZm9yRWFjaChjID0+IHtcbiAgICBjLnR5cGUgPSBCUkVBS19DT01QTEVUSU9OO1xuICB9KTtcbn1cbmZ1bmN0aW9uIHJlcGxhY2VCcmVha1N0YXRlbWVudEluQnJlYWtDb21wbGV0aW9uKGNvbXBsZXRpb25zLCByZWFjaGFibGUpIHtcbiAgY29tcGxldGlvbnMuZm9yRWFjaChjID0+IHtcbiAgICBpZiAoYy5wYXRoLmlzQnJlYWtTdGF0ZW1lbnQoe1xuICAgICAgbGFiZWw6IG51bGxcbiAgICB9KSkge1xuICAgICAgaWYgKHJlYWNoYWJsZSkge1xuICAgICAgICBjLnBhdGgucmVwbGFjZVdpdGgodW5hcnlFeHByZXNzaW9uKFwidm9pZFwiLCBudW1lcmljTGl0ZXJhbCgwKSkpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYy5wYXRoLnJlbW92ZSgpO1xuICAgICAgfVxuICAgIH1cbiAgfSk7XG59XG5mdW5jdGlvbiBnZXRTdGF0ZW1lbnRMaXN0Q29tcGxldGlvbihwYXRocywgY29udGV4dCkge1xuICBjb25zdCBjb21wbGV0aW9ucyA9IFtdO1xuICBpZiAoY29udGV4dC5jYW5IYXZlQnJlYWspIHtcbiAgICBsZXQgbGFzdE5vcm1hbENvbXBsZXRpb25zID0gW107XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwYXRocy5sZW5ndGg7IGkrKykge1xuICAgICAgY29uc3QgcGF0aCA9IHBhdGhzW2ldO1xuICAgICAgY29uc3QgbmV3Q29udGV4dCA9IE9iamVjdC5hc3NpZ24oe30sIGNvbnRleHQsIHtcbiAgICAgICAgaW5DYXNlQ2xhdXNlOiBmYWxzZVxuICAgICAgfSk7XG4gICAgICBpZiAocGF0aC5pc0Jsb2NrU3RhdGVtZW50KCkgJiYgKGNvbnRleHQuaW5DYXNlQ2xhdXNlIHx8IGNvbnRleHQuc2hvdWxkUG9wdWxhdGVCcmVhaykpIHtcbiAgICAgICAgbmV3Q29udGV4dC5zaG91bGRQb3B1bGF0ZUJyZWFrID0gdHJ1ZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG5ld0NvbnRleHQuc2hvdWxkUG9wdWxhdGVCcmVhayA9IGZhbHNlO1xuICAgICAgfVxuICAgICAgY29uc3Qgc3RhdGVtZW50Q29tcGxldGlvbnMgPSBfZ2V0Q29tcGxldGlvblJlY29yZHMocGF0aCwgbmV3Q29udGV4dCk7XG4gICAgICBpZiAoc3RhdGVtZW50Q29tcGxldGlvbnMubGVuZ3RoID4gMCAmJiBzdGF0ZW1lbnRDb21wbGV0aW9ucy5ldmVyeShjID0+IGMudHlwZSA9PT0gQlJFQUtfQ09NUExFVElPTikpIHtcbiAgICAgICAgaWYgKGxhc3ROb3JtYWxDb21wbGV0aW9ucy5sZW5ndGggPiAwICYmIHN0YXRlbWVudENvbXBsZXRpb25zLmV2ZXJ5KGMgPT4gYy5wYXRoLmlzQnJlYWtTdGF0ZW1lbnQoe1xuICAgICAgICAgIGxhYmVsOiBudWxsXG4gICAgICAgIH0pKSkge1xuICAgICAgICAgIG5vcm1hbENvbXBsZXRpb25Ub0JyZWFrKGxhc3ROb3JtYWxDb21wbGV0aW9ucyk7XG4gICAgICAgICAgY29tcGxldGlvbnMucHVzaCguLi5sYXN0Tm9ybWFsQ29tcGxldGlvbnMpO1xuICAgICAgICAgIGlmIChsYXN0Tm9ybWFsQ29tcGxldGlvbnMuc29tZShjID0+IGMucGF0aC5pc0RlY2xhcmF0aW9uKCkpKSB7XG4gICAgICAgICAgICBjb21wbGV0aW9ucy5wdXNoKC4uLnN0YXRlbWVudENvbXBsZXRpb25zKTtcbiAgICAgICAgICAgIGlmICghY29udGV4dC5zaG91bGRQcmVzZXJ2ZUJyZWFrKSB7XG4gICAgICAgICAgICAgIHJlcGxhY2VCcmVha1N0YXRlbWVudEluQnJlYWtDb21wbGV0aW9uKHN0YXRlbWVudENvbXBsZXRpb25zLCB0cnVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKCFjb250ZXh0LnNob3VsZFByZXNlcnZlQnJlYWspIHtcbiAgICAgICAgICAgIHJlcGxhY2VCcmVha1N0YXRlbWVudEluQnJlYWtDb21wbGV0aW9uKHN0YXRlbWVudENvbXBsZXRpb25zLCBmYWxzZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNvbXBsZXRpb25zLnB1c2goLi4uc3RhdGVtZW50Q29tcGxldGlvbnMpO1xuICAgICAgICAgIGlmICghY29udGV4dC5zaG91bGRQb3B1bGF0ZUJyZWFrICYmICFjb250ZXh0LnNob3VsZFByZXNlcnZlQnJlYWspIHtcbiAgICAgICAgICAgIHJlcGxhY2VCcmVha1N0YXRlbWVudEluQnJlYWtDb21wbGV0aW9uKHN0YXRlbWVudENvbXBsZXRpb25zLCB0cnVlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBpZiAoaSA9PT0gcGF0aHMubGVuZ3RoIC0gMSkge1xuICAgICAgICBjb21wbGV0aW9ucy5wdXNoKC4uLnN0YXRlbWVudENvbXBsZXRpb25zKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGxhc3ROb3JtYWxDb21wbGV0aW9ucyA9IFtdO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHN0YXRlbWVudENvbXBsZXRpb25zLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgY29uc3QgYyA9IHN0YXRlbWVudENvbXBsZXRpb25zW2ldO1xuICAgICAgICAgIGlmIChjLnR5cGUgPT09IEJSRUFLX0NPTVBMRVRJT04pIHtcbiAgICAgICAgICAgIGNvbXBsZXRpb25zLnB1c2goYyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChjLnR5cGUgPT09IE5PUk1BTF9DT01QTEVUSU9OKSB7XG4gICAgICAgICAgICBsYXN0Tm9ybWFsQ29tcGxldGlvbnMucHVzaChjKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH0gZWxzZSBpZiAocGF0aHMubGVuZ3RoKSB7XG4gICAgZm9yIChsZXQgaSA9IHBhdGhzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICBjb25zdCBwYXRoQ29tcGxldGlvbnMgPSBfZ2V0Q29tcGxldGlvblJlY29yZHMocGF0aHNbaV0sIGNvbnRleHQpO1xuICAgICAgaWYgKHBhdGhDb21wbGV0aW9ucy5sZW5ndGggPiAxIHx8IHBhdGhDb21wbGV0aW9ucy5sZW5ndGggPT09IDEgJiYgIXBhdGhDb21wbGV0aW9uc1swXS5wYXRoLmlzVmFyaWFibGVEZWNsYXJhdGlvbigpICYmICFwYXRoQ29tcGxldGlvbnNbMF0ucGF0aC5pc0VtcHR5U3RhdGVtZW50KCkpIHtcbiAgICAgICAgY29tcGxldGlvbnMucHVzaCguLi5wYXRoQ29tcGxldGlvbnMpO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIGNvbXBsZXRpb25zO1xufVxuZnVuY3Rpb24gX2dldENvbXBsZXRpb25SZWNvcmRzKHBhdGgsIGNvbnRleHQpIHtcbiAgbGV0IHJlY29yZHMgPSBbXTtcbiAgaWYgKHBhdGguaXNJZlN0YXRlbWVudCgpKSB7XG4gICAgcmVjb3JkcyA9IGFkZENvbXBsZXRpb25SZWNvcmRzKHBhdGguZ2V0KFwiY29uc2VxdWVudFwiKSwgcmVjb3JkcywgY29udGV4dCk7XG4gICAgcmVjb3JkcyA9IGFkZENvbXBsZXRpb25SZWNvcmRzKHBhdGguZ2V0KFwiYWx0ZXJuYXRlXCIpLCByZWNvcmRzLCBjb250ZXh0KTtcbiAgfSBlbHNlIGlmIChwYXRoLmlzRG9FeHByZXNzaW9uKCkgfHwgcGF0aC5pc0ZvcigpIHx8IHBhdGguaXNXaGlsZSgpIHx8IHBhdGguaXNMYWJlbGVkU3RhdGVtZW50KCkpIHtcbiAgICByZXR1cm4gYWRkQ29tcGxldGlvblJlY29yZHMocGF0aC5nZXQoXCJib2R5XCIpLCByZWNvcmRzLCBjb250ZXh0KTtcbiAgfSBlbHNlIGlmIChwYXRoLmlzUHJvZ3JhbSgpIHx8IHBhdGguaXNCbG9ja1N0YXRlbWVudCgpKSB7XG4gICAgcmV0dXJuIGdldFN0YXRlbWVudExpc3RDb21wbGV0aW9uKHBhdGguZ2V0KFwiYm9keVwiKSwgY29udGV4dCk7XG4gIH0gZWxzZSBpZiAocGF0aC5pc0Z1bmN0aW9uKCkpIHtcbiAgICByZXR1cm4gX2dldENvbXBsZXRpb25SZWNvcmRzKHBhdGguZ2V0KFwiYm9keVwiKSwgY29udGV4dCk7XG4gIH0gZWxzZSBpZiAocGF0aC5pc1RyeVN0YXRlbWVudCgpKSB7XG4gICAgcmVjb3JkcyA9IGFkZENvbXBsZXRpb25SZWNvcmRzKHBhdGguZ2V0KFwiYmxvY2tcIiksIHJlY29yZHMsIGNvbnRleHQpO1xuICAgIHJlY29yZHMgPSBhZGRDb21wbGV0aW9uUmVjb3JkcyhwYXRoLmdldChcImhhbmRsZXJcIiksIHJlY29yZHMsIGNvbnRleHQpO1xuICB9IGVsc2UgaWYgKHBhdGguaXNDYXRjaENsYXVzZSgpKSB7XG4gICAgcmV0dXJuIGFkZENvbXBsZXRpb25SZWNvcmRzKHBhdGguZ2V0KFwiYm9keVwiKSwgcmVjb3JkcywgY29udGV4dCk7XG4gIH0gZWxzZSBpZiAocGF0aC5pc1N3aXRjaFN0YXRlbWVudCgpKSB7XG4gICAgcmV0dXJuIGNvbXBsZXRpb25SZWNvcmRGb3JTd2l0Y2gocGF0aC5nZXQoXCJjYXNlc1wiKSwgcmVjb3JkcywgY29udGV4dCk7XG4gIH0gZWxzZSBpZiAocGF0aC5pc1N3aXRjaENhc2UoKSkge1xuICAgIHJldHVybiBnZXRTdGF0ZW1lbnRMaXN0Q29tcGxldGlvbihwYXRoLmdldChcImNvbnNlcXVlbnRcIiksIHtcbiAgICAgIGNhbkhhdmVCcmVhazogdHJ1ZSxcbiAgICAgIHNob3VsZFBvcHVsYXRlQnJlYWs6IGZhbHNlLFxuICAgICAgaW5DYXNlQ2xhdXNlOiB0cnVlLFxuICAgICAgc2hvdWxkUHJlc2VydmVCcmVhazogY29udGV4dC5zaG91bGRQcmVzZXJ2ZUJyZWFrXG4gICAgfSk7XG4gIH0gZWxzZSBpZiAocGF0aC5pc0JyZWFrU3RhdGVtZW50KCkpIHtcbiAgICByZWNvcmRzLnB1c2goQnJlYWtDb21wbGV0aW9uKHBhdGgpKTtcbiAgfSBlbHNlIHtcbiAgICByZWNvcmRzLnB1c2goTm9ybWFsQ29tcGxldGlvbihwYXRoKSk7XG4gIH1cbiAgcmV0dXJuIHJlY29yZHM7XG59XG5mdW5jdGlvbiBnZXRDb21wbGV0aW9uUmVjb3JkcyhzaG91bGRQcmVzZXJ2ZUJyZWFrID0gZmFsc2UpIHtcbiAgY29uc3QgcmVjb3JkcyA9IF9nZXRDb21wbGV0aW9uUmVjb3Jkcyh0aGlzLCB7XG4gICAgY2FuSGF2ZUJyZWFrOiBmYWxzZSxcbiAgICBzaG91bGRQb3B1bGF0ZUJyZWFrOiBmYWxzZSxcbiAgICBpbkNhc2VDbGF1c2U6IGZhbHNlLFxuICAgIHNob3VsZFByZXNlcnZlQnJlYWtcbiAgfSk7XG4gIHJldHVybiByZWNvcmRzLm1hcChyID0+IHIucGF0aCk7XG59XG5mdW5jdGlvbiBnZXRTaWJsaW5nKGtleSkge1xuICByZXR1cm4gX2luZGV4LmRlZmF1bHQuZ2V0KHtcbiAgICBwYXJlbnRQYXRoOiB0aGlzLnBhcmVudFBhdGgsXG4gICAgcGFyZW50OiB0aGlzLnBhcmVudCxcbiAgICBjb250YWluZXI6IHRoaXMuY29udGFpbmVyLFxuICAgIGxpc3RLZXk6IHRoaXMubGlzdEtleSxcbiAgICBrZXk6IGtleVxuICB9KS5zZXRDb250ZXh0KHRoaXMuY29udGV4dCk7XG59XG5mdW5jdGlvbiBnZXRQcmV2U2libGluZygpIHtcbiAgcmV0dXJuIHRoaXMuZ2V0U2libGluZyh0aGlzLmtleSAtIDEpO1xufVxuZnVuY3Rpb24gZ2V0TmV4dFNpYmxpbmcoKSB7XG4gIHJldHVybiB0aGlzLmdldFNpYmxpbmcodGhpcy5rZXkgKyAxKTtcbn1cbmZ1bmN0aW9uIGdldEFsbE5leHRTaWJsaW5ncygpIHtcbiAgbGV0IF9rZXkgPSB0aGlzLmtleTtcbiAgbGV0IHNpYmxpbmcgPSB0aGlzLmdldFNpYmxpbmcoKytfa2V5KTtcbiAgY29uc3Qgc2libGluZ3MgPSBbXTtcbiAgd2hpbGUgKHNpYmxpbmcubm9kZSkge1xuICAgIHNpYmxpbmdzLnB1c2goc2libGluZyk7XG4gICAgc2libGluZyA9IHRoaXMuZ2V0U2libGluZygrK19rZXkpO1xuICB9XG4gIHJldHVybiBzaWJsaW5ncztcbn1cbmZ1bmN0aW9uIGdldEFsbFByZXZTaWJsaW5ncygpIHtcbiAgbGV0IF9rZXkgPSB0aGlzLmtleTtcbiAgbGV0IHNpYmxpbmcgPSB0aGlzLmdldFNpYmxpbmcoLS1fa2V5KTtcbiAgY29uc3Qgc2libGluZ3MgPSBbXTtcbiAgd2hpbGUgKHNpYmxpbmcubm9kZSkge1xuICAgIHNpYmxpbmdzLnB1c2goc2libGluZyk7XG4gICAgc2libGluZyA9IHRoaXMuZ2V0U2libGluZygtLV9rZXkpO1xuICB9XG4gIHJldHVybiBzaWJsaW5ncztcbn1cbmZ1bmN0aW9uIGdldChrZXksIGNvbnRleHQgPSB0cnVlKSB7XG4gIGlmIChjb250ZXh0ID09PSB0cnVlKSBjb250ZXh0ID0gdGhpcy5jb250ZXh0O1xuICBjb25zdCBwYXJ0cyA9IGtleS5zcGxpdChcIi5cIik7XG4gIGlmIChwYXJ0cy5sZW5ndGggPT09IDEpIHtcbiAgICByZXR1cm4gX2dldEtleS5jYWxsKHRoaXMsIGtleSwgY29udGV4dCk7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIF9nZXRQYXR0ZXJuLmNhbGwodGhpcywgcGFydHMsIGNvbnRleHQpO1xuICB9XG59XG5mdW5jdGlvbiBfZ2V0S2V5KGtleSwgY29udGV4dCkge1xuICBjb25zdCBub2RlID0gdGhpcy5ub2RlO1xuICBjb25zdCBjb250YWluZXIgPSBub2RlW2tleV07XG4gIGlmIChBcnJheS5pc0FycmF5KGNvbnRhaW5lcikpIHtcbiAgICByZXR1cm4gY29udGFpbmVyLm1hcCgoXywgaSkgPT4ge1xuICAgICAgcmV0dXJuIF9pbmRleC5kZWZhdWx0LmdldCh7XG4gICAgICAgIGxpc3RLZXk6IGtleSxcbiAgICAgICAgcGFyZW50UGF0aDogdGhpcyxcbiAgICAgICAgcGFyZW50OiBub2RlLFxuICAgICAgICBjb250YWluZXI6IGNvbnRhaW5lcixcbiAgICAgICAga2V5OiBpXG4gICAgICB9KS5zZXRDb250ZXh0KGNvbnRleHQpO1xuICAgIH0pO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBfaW5kZXguZGVmYXVsdC5nZXQoe1xuICAgICAgcGFyZW50UGF0aDogdGhpcyxcbiAgICAgIHBhcmVudDogbm9kZSxcbiAgICAgIGNvbnRhaW5lcjogbm9kZSxcbiAgICAgIGtleToga2V5XG4gICAgfSkuc2V0Q29udGV4dChjb250ZXh0KTtcbiAgfVxufVxuZnVuY3Rpb24gX2dldFBhdHRlcm4ocGFydHMsIGNvbnRleHQpIHtcbiAgbGV0IHBhdGggPSB0aGlzO1xuICBmb3IgKGNvbnN0IHBhcnQgb2YgcGFydHMpIHtcbiAgICBpZiAocGFydCA9PT0gXCIuXCIpIHtcbiAgICAgIHBhdGggPSBwYXRoLnBhcmVudFBhdGg7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChBcnJheS5pc0FycmF5KHBhdGgpKSB7XG4gICAgICAgIHBhdGggPSBwYXRoW3BhcnRdO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcGF0aCA9IHBhdGguZ2V0KHBhcnQsIGNvbnRleHQpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gcGF0aDtcbn1cbmZ1bmN0aW9uIGdldEFzc2lnbm1lbnRJZGVudGlmaWVycygpIHtcbiAgcmV0dXJuIF9nZXRBc3NpZ25tZW50SWRlbnRpZmllcnModGhpcy5ub2RlKTtcbn1cbmZ1bmN0aW9uIGdldEJpbmRpbmdJZGVudGlmaWVycyhkdXBsaWNhdGVzKSB7XG4gIHJldHVybiBfZ2V0QmluZGluZ0lkZW50aWZpZXJzKHRoaXMubm9kZSwgZHVwbGljYXRlcyk7XG59XG5mdW5jdGlvbiBnZXRPdXRlckJpbmRpbmdJZGVudGlmaWVycyhkdXBsaWNhdGVzKSB7XG4gIHJldHVybiBfZ2V0T3V0ZXJCaW5kaW5nSWRlbnRpZmllcnModGhpcy5ub2RlLCBkdXBsaWNhdGVzKTtcbn1cbmZ1bmN0aW9uIGdldEJpbmRpbmdJZGVudGlmaWVyUGF0aHMoZHVwbGljYXRlcyA9IGZhbHNlLCBvdXRlck9ubHkgPSBmYWxzZSkge1xuICBjb25zdCBwYXRoID0gdGhpcztcbiAgY29uc3Qgc2VhcmNoID0gW3BhdGhdO1xuICBjb25zdCBpZHMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICB3aGlsZSAoc2VhcmNoLmxlbmd0aCkge1xuICAgIGNvbnN0IGlkID0gc2VhcmNoLnNoaWZ0KCk7XG4gICAgaWYgKCFpZCkgY29udGludWU7XG4gICAgaWYgKCFpZC5ub2RlKSBjb250aW51ZTtcbiAgICBjb25zdCBrZXlzID0gX2dldEJpbmRpbmdJZGVudGlmaWVycy5rZXlzW2lkLm5vZGUudHlwZV07XG4gICAgaWYgKGlkLmlzSWRlbnRpZmllcigpKSB7XG4gICAgICBpZiAoZHVwbGljYXRlcykge1xuICAgICAgICBjb25zdCBfaWRzID0gaWRzW2lkLm5vZGUubmFtZV0gPSBpZHNbaWQubm9kZS5uYW1lXSB8fCBbXTtcbiAgICAgICAgX2lkcy5wdXNoKGlkKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlkc1tpZC5ub2RlLm5hbWVdID0gaWQ7XG4gICAgICB9XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgaWYgKGlkLmlzRXhwb3J0RGVjbGFyYXRpb24oKSkge1xuICAgICAgY29uc3QgZGVjbGFyYXRpb24gPSBpZC5nZXQoXCJkZWNsYXJhdGlvblwiKTtcbiAgICAgIGlmIChkZWNsYXJhdGlvbi5pc0RlY2xhcmF0aW9uKCkpIHtcbiAgICAgICAgc2VhcmNoLnB1c2goZGVjbGFyYXRpb24pO1xuICAgICAgfVxuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIGlmIChvdXRlck9ubHkpIHtcbiAgICAgIGlmIChpZC5pc0Z1bmN0aW9uRGVjbGFyYXRpb24oKSkge1xuICAgICAgICBzZWFyY2gucHVzaChpZC5nZXQoXCJpZFwiKSk7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgaWYgKGlkLmlzRnVuY3Rpb25FeHByZXNzaW9uKCkpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChrZXlzKSB7XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY29uc3Qga2V5ID0ga2V5c1tpXTtcbiAgICAgICAgY29uc3QgY2hpbGQgPSBpZC5nZXQoa2V5KTtcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoY2hpbGQpKSB7XG4gICAgICAgICAgc2VhcmNoLnB1c2goLi4uY2hpbGQpO1xuICAgICAgICB9IGVsc2UgaWYgKGNoaWxkLm5vZGUpIHtcbiAgICAgICAgICBzZWFyY2gucHVzaChjaGlsZCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIGlkcztcbn1cbmZ1bmN0aW9uIGdldE91dGVyQmluZGluZ0lkZW50aWZpZXJQYXRocyhkdXBsaWNhdGVzID0gZmFsc2UpIHtcbiAgcmV0dXJuIHRoaXMuZ2V0QmluZGluZ0lkZW50aWZpZXJQYXRocyhkdXBsaWNhdGVzLCB0cnVlKTtcbn1cblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZmFtaWx5LmpzLm1hcFxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@babel/traverse/lib/path/family.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@babel/traverse/lib/path/index.js":
/*!********************************************************!*\
  !*** ./node_modules/@babel/traverse/lib/path/index.js ***!
  \********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports[\"default\"] = exports.SHOULD_STOP = exports.SHOULD_SKIP = exports.REMOVED = void 0;\nvar virtualTypes = __webpack_require__(/*! ./lib/virtual-types.js */ \"(ssr)/./node_modules/@babel/traverse/lib/path/lib/virtual-types.js\");\nvar _debug = __webpack_require__(/*! debug */ \"(ssr)/./node_modules/debug/src/index.js\");\nvar _index = __webpack_require__(/*! ../index.js */ \"(ssr)/./node_modules/@babel/traverse/lib/index.js\");\nvar _index2 = __webpack_require__(/*! ../scope/index.js */ \"(ssr)/./node_modules/@babel/traverse/lib/scope/index.js\");\nvar _t = __webpack_require__(/*! @babel/types */ \"(ssr)/./node_modules/@babel/types/lib/index.js\");\nvar t = _t;\nvar cache = __webpack_require__(/*! ../cache.js */ \"(ssr)/./node_modules/@babel/traverse/lib/cache.js\");\nvar _generator = __webpack_require__(/*! @babel/generator */ \"(ssr)/./node_modules/@babel/generator/lib/index.js\");\nvar NodePath_ancestry = __webpack_require__(/*! ./ancestry.js */ \"(ssr)/./node_modules/@babel/traverse/lib/path/ancestry.js\");\nvar NodePath_inference = __webpack_require__(/*! ./inference/index.js */ \"(ssr)/./node_modules/@babel/traverse/lib/path/inference/index.js\");\nvar NodePath_replacement = __webpack_require__(/*! ./replacement.js */ \"(ssr)/./node_modules/@babel/traverse/lib/path/replacement.js\");\nvar NodePath_evaluation = __webpack_require__(/*! ./evaluation.js */ \"(ssr)/./node_modules/@babel/traverse/lib/path/evaluation.js\");\nvar NodePath_conversion = __webpack_require__(/*! ./conversion.js */ \"(ssr)/./node_modules/@babel/traverse/lib/path/conversion.js\");\nvar NodePath_introspection = __webpack_require__(/*! ./introspection.js */ \"(ssr)/./node_modules/@babel/traverse/lib/path/introspection.js\");\nvar _context = __webpack_require__(/*! ./context.js */ \"(ssr)/./node_modules/@babel/traverse/lib/path/context.js\");\nvar NodePath_context = _context;\nvar NodePath_removal = __webpack_require__(/*! ./removal.js */ \"(ssr)/./node_modules/@babel/traverse/lib/path/removal.js\");\nvar NodePath_modification = __webpack_require__(/*! ./modification.js */ \"(ssr)/./node_modules/@babel/traverse/lib/path/modification.js\");\nvar NodePath_family = __webpack_require__(/*! ./family.js */ \"(ssr)/./node_modules/@babel/traverse/lib/path/family.js\");\nvar NodePath_comments = __webpack_require__(/*! ./comments.js */ \"(ssr)/./node_modules/@babel/traverse/lib/path/comments.js\");\nvar NodePath_virtual_types_validator = __webpack_require__(/*! ./lib/virtual-types-validator.js */ \"(ssr)/./node_modules/@babel/traverse/lib/path/lib/virtual-types-validator.js\");\nconst {\n  validate\n} = _t;\nconst debug = _debug(\"babel\");\nconst REMOVED = exports.REMOVED = 1 << 0;\nconst SHOULD_STOP = exports.SHOULD_STOP = 1 << 1;\nconst SHOULD_SKIP = exports.SHOULD_SKIP = 1 << 2;\nconst NodePath_Final = exports[\"default\"] = class NodePath {\n  constructor(hub, parent) {\n    this.contexts = [];\n    this.state = null;\n    this._traverseFlags = 0;\n    this.skipKeys = null;\n    this.parentPath = null;\n    this.container = null;\n    this.listKey = null;\n    this.key = null;\n    this.node = null;\n    this.type = null;\n    this._store = null;\n    this.parent = parent;\n    this.hub = hub;\n    this.data = null;\n    this.context = null;\n    this.scope = null;\n  }\n  get removed() {\n    return (this._traverseFlags & 1) > 0;\n  }\n  set removed(v) {\n    if (v) this._traverseFlags |= 1;else this._traverseFlags &= -2;\n  }\n  get shouldStop() {\n    return (this._traverseFlags & 2) > 0;\n  }\n  set shouldStop(v) {\n    if (v) this._traverseFlags |= 2;else this._traverseFlags &= -3;\n  }\n  get shouldSkip() {\n    return (this._traverseFlags & 4) > 0;\n  }\n  set shouldSkip(v) {\n    if (v) this._traverseFlags |= 4;else this._traverseFlags &= -5;\n  }\n  static get({\n    hub,\n    parentPath,\n    parent,\n    container,\n    listKey,\n    key\n  }) {\n    if (!hub && parentPath) {\n      hub = parentPath.hub;\n    }\n    if (!parent) {\n      throw new Error(\"To get a node path the parent needs to exist\");\n    }\n    const targetNode = container[key];\n    const paths = cache.getOrCreateCachedPaths(parent, parentPath);\n    let path = paths.get(targetNode);\n    if (!path) {\n      path = new NodePath(hub, parent);\n      if (targetNode) paths.set(targetNode, path);\n    }\n    _context.setup.call(path, parentPath, container, listKey, key);\n    return path;\n  }\n  getScope(scope) {\n    return this.isScope() ? new _index2.default(this) : scope;\n  }\n  setData(key, val) {\n    if (this.data == null) {\n      this.data = Object.create(null);\n    }\n    return this.data[key] = val;\n  }\n  getData(key, def) {\n    if (this.data == null) {\n      this.data = Object.create(null);\n    }\n    let val = this.data[key];\n    if (val === undefined && def !== undefined) val = this.data[key] = def;\n    return val;\n  }\n  hasNode() {\n    return this.node != null;\n  }\n  buildCodeFrameError(msg, Error = SyntaxError) {\n    return this.hub.buildError(this.node, msg, Error);\n  }\n  traverse(visitor, state) {\n    (0, _index.default)(this.node, visitor, this.scope, state, this);\n  }\n  set(key, node) {\n    validate(this.node, key, node);\n    this.node[key] = node;\n  }\n  getPathLocation() {\n    const parts = [];\n    let path = this;\n    do {\n      let key = path.key;\n      if (path.inList) key = `${path.listKey}[${key}]`;\n      parts.unshift(key);\n    } while (path = path.parentPath);\n    return parts.join(\".\");\n  }\n  debug(message) {\n    if (!debug.enabled) return;\n    debug(`${this.getPathLocation()} ${this.type}: ${message}`);\n  }\n  toString() {\n    return (0, _generator.default)(this.node).code;\n  }\n  get inList() {\n    return !!this.listKey;\n  }\n  set inList(inList) {\n    if (!inList) {\n      this.listKey = null;\n    }\n  }\n  get parentKey() {\n    return this.listKey || this.key;\n  }\n};\nconst methods = {\n  findParent: NodePath_ancestry.findParent,\n  find: NodePath_ancestry.find,\n  getFunctionParent: NodePath_ancestry.getFunctionParent,\n  getStatementParent: NodePath_ancestry.getStatementParent,\n  getEarliestCommonAncestorFrom: NodePath_ancestry.getEarliestCommonAncestorFrom,\n  getDeepestCommonAncestorFrom: NodePath_ancestry.getDeepestCommonAncestorFrom,\n  getAncestry: NodePath_ancestry.getAncestry,\n  isAncestor: NodePath_ancestry.isAncestor,\n  isDescendant: NodePath_ancestry.isDescendant,\n  inType: NodePath_ancestry.inType,\n  getTypeAnnotation: NodePath_inference.getTypeAnnotation,\n  isBaseType: NodePath_inference.isBaseType,\n  couldBeBaseType: NodePath_inference.couldBeBaseType,\n  baseTypeStrictlyMatches: NodePath_inference.baseTypeStrictlyMatches,\n  isGenericType: NodePath_inference.isGenericType,\n  replaceWithMultiple: NodePath_replacement.replaceWithMultiple,\n  replaceWithSourceString: NodePath_replacement.replaceWithSourceString,\n  replaceWith: NodePath_replacement.replaceWith,\n  replaceExpressionWithStatements: NodePath_replacement.replaceExpressionWithStatements,\n  replaceInline: NodePath_replacement.replaceInline,\n  evaluateTruthy: NodePath_evaluation.evaluateTruthy,\n  evaluate: NodePath_evaluation.evaluate,\n  toComputedKey: NodePath_conversion.toComputedKey,\n  ensureBlock: NodePath_conversion.ensureBlock,\n  unwrapFunctionEnvironment: NodePath_conversion.unwrapFunctionEnvironment,\n  arrowFunctionToExpression: NodePath_conversion.arrowFunctionToExpression,\n  splitExportDeclaration: NodePath_conversion.splitExportDeclaration,\n  ensureFunctionName: NodePath_conversion.ensureFunctionName,\n  matchesPattern: NodePath_introspection.matchesPattern,\n  isStatic: NodePath_introspection.isStatic,\n  isNodeType: NodePath_introspection.isNodeType,\n  canHaveVariableDeclarationOrExpression: NodePath_introspection.canHaveVariableDeclarationOrExpression,\n  canSwapBetweenExpressionAndStatement: NodePath_introspection.canSwapBetweenExpressionAndStatement,\n  isCompletionRecord: NodePath_introspection.isCompletionRecord,\n  isStatementOrBlock: NodePath_introspection.isStatementOrBlock,\n  referencesImport: NodePath_introspection.referencesImport,\n  getSource: NodePath_introspection.getSource,\n  willIMaybeExecuteBefore: NodePath_introspection.willIMaybeExecuteBefore,\n  _guessExecutionStatusRelativeTo: NodePath_introspection._guessExecutionStatusRelativeTo,\n  resolve: NodePath_introspection.resolve,\n  isConstantExpression: NodePath_introspection.isConstantExpression,\n  isInStrictMode: NodePath_introspection.isInStrictMode,\n  isDenylisted: NodePath_context.isDenylisted,\n  visit: NodePath_context.visit,\n  skip: NodePath_context.skip,\n  skipKey: NodePath_context.skipKey,\n  stop: NodePath_context.stop,\n  setContext: NodePath_context.setContext,\n  requeue: NodePath_context.requeue,\n  requeueComputedKeyAndDecorators: NodePath_context.requeueComputedKeyAndDecorators,\n  remove: NodePath_removal.remove,\n  insertBefore: NodePath_modification.insertBefore,\n  insertAfter: NodePath_modification.insertAfter,\n  unshiftContainer: NodePath_modification.unshiftContainer,\n  pushContainer: NodePath_modification.pushContainer,\n  getOpposite: NodePath_family.getOpposite,\n  getCompletionRecords: NodePath_family.getCompletionRecords,\n  getSibling: NodePath_family.getSibling,\n  getPrevSibling: NodePath_family.getPrevSibling,\n  getNextSibling: NodePath_family.getNextSibling,\n  getAllNextSiblings: NodePath_family.getAllNextSiblings,\n  getAllPrevSiblings: NodePath_family.getAllPrevSiblings,\n  get: NodePath_family.get,\n  getAssignmentIdentifiers: NodePath_family.getAssignmentIdentifiers,\n  getBindingIdentifiers: NodePath_family.getBindingIdentifiers,\n  getOuterBindingIdentifiers: NodePath_family.getOuterBindingIdentifiers,\n  getBindingIdentifierPaths: NodePath_family.getBindingIdentifierPaths,\n  getOuterBindingIdentifierPaths: NodePath_family.getOuterBindingIdentifierPaths,\n  shareCommentsWithSiblings: NodePath_comments.shareCommentsWithSiblings,\n  addComment: NodePath_comments.addComment,\n  addComments: NodePath_comments.addComments\n};\nObject.assign(NodePath_Final.prototype, methods);\nNodePath_Final.prototype.arrowFunctionToShadowed = NodePath_conversion[String(\"arrowFunctionToShadowed\")];\nObject.assign(NodePath_Final.prototype, {\n  has: NodePath_introspection[String(\"has\")],\n  is: NodePath_introspection[String(\"is\")],\n  isnt: NodePath_introspection[String(\"isnt\")],\n  equals: NodePath_introspection[String(\"equals\")],\n  hoist: NodePath_modification[String(\"hoist\")],\n  updateSiblingKeys: NodePath_modification.updateSiblingKeys,\n  call: NodePath_context.call,\n  isBlacklisted: NodePath_context[String(\"isBlacklisted\")],\n  setScope: NodePath_context.setScope,\n  resync: NodePath_context.resync,\n  popContext: NodePath_context.popContext,\n  pushContext: NodePath_context.pushContext,\n  setup: NodePath_context.setup,\n  setKey: NodePath_context.setKey\n});\nNodePath_Final.prototype._guessExecutionStatusRelativeToDifferentFunctions = NodePath_introspection._guessExecutionStatusRelativeTo;\nNodePath_Final.prototype._guessExecutionStatusRelativeToDifferentFunctions = NodePath_introspection._guessExecutionStatusRelativeTo;\nObject.assign(NodePath_Final.prototype, {\n  _getTypeAnnotation: NodePath_inference._getTypeAnnotation,\n  _replaceWith: NodePath_replacement._replaceWith,\n  _resolve: NodePath_introspection._resolve,\n  _call: NodePath_context._call,\n  _resyncParent: NodePath_context._resyncParent,\n  _resyncKey: NodePath_context._resyncKey,\n  _resyncList: NodePath_context._resyncList,\n  _resyncRemoved: NodePath_context._resyncRemoved,\n  _getQueueContexts: NodePath_context._getQueueContexts,\n  _removeFromScope: NodePath_removal._removeFromScope,\n  _callRemovalHooks: NodePath_removal._callRemovalHooks,\n  _remove: NodePath_removal._remove,\n  _markRemoved: NodePath_removal._markRemoved,\n  _assertUnremoved: NodePath_removal._assertUnremoved,\n  _containerInsert: NodePath_modification._containerInsert,\n  _containerInsertBefore: NodePath_modification._containerInsertBefore,\n  _containerInsertAfter: NodePath_modification._containerInsertAfter,\n  _verifyNodeList: NodePath_modification._verifyNodeList,\n  _getKey: NodePath_family._getKey,\n  _getPattern: NodePath_family._getPattern\n});\nfor (const type of t.TYPES) {\n  const typeKey = `is${type}`;\n  const fn = t[typeKey];\n  NodePath_Final.prototype[typeKey] = function (opts) {\n    return fn(this.node, opts);\n  };\n  NodePath_Final.prototype[`assert${type}`] = function (opts) {\n    if (!fn(this.node, opts)) {\n      throw new TypeError(`Expected node path of type ${type}`);\n    }\n  };\n}\nObject.assign(NodePath_Final.prototype, NodePath_virtual_types_validator);\nfor (const type of Object.keys(virtualTypes)) {\n  if (type.startsWith(\"_\")) continue;\n  if (!t.TYPES.includes(type)) t.TYPES.push(type);\n}\n\n//# sourceMappingURL=index.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGJhYmVsL3RyYXZlcnNlL2xpYi9wYXRoL2luZGV4LmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViLDhDQUE2QztBQUM3QztBQUNBLENBQUMsRUFBQztBQUNGLGtCQUFlLEdBQUcsbUJBQW1CLEdBQUcsbUJBQW1CLEdBQUcsZUFBZTtBQUM3RSxtQkFBbUIsbUJBQU8sQ0FBQyxrR0FBd0I7QUFDbkQsYUFBYSxtQkFBTyxDQUFDLHNEQUFPO0FBQzVCLGFBQWEsbUJBQU8sQ0FBQyxzRUFBYTtBQUNsQyxjQUFjLG1CQUFPLENBQUMsa0ZBQW1CO0FBQ3pDLFNBQVMsbUJBQU8sQ0FBQyxvRUFBYztBQUMvQjtBQUNBLFlBQVksbUJBQU8sQ0FBQyxzRUFBYTtBQUNqQyxpQkFBaUIsbUJBQU8sQ0FBQyw0RUFBa0I7QUFDM0Msd0JBQXdCLG1CQUFPLENBQUMsZ0ZBQWU7QUFDL0MseUJBQXlCLG1CQUFPLENBQUMsOEZBQXNCO0FBQ3ZELDJCQUEyQixtQkFBTyxDQUFDLHNGQUFrQjtBQUNyRCwwQkFBMEIsbUJBQU8sQ0FBQyxvRkFBaUI7QUFDbkQsMEJBQTBCLG1CQUFPLENBQUMsb0ZBQWlCO0FBQ25ELDZCQUE2QixtQkFBTyxDQUFDLDBGQUFvQjtBQUN6RCxlQUFlLG1CQUFPLENBQUMsOEVBQWM7QUFDckM7QUFDQSx1QkFBdUIsbUJBQU8sQ0FBQyw4RUFBYztBQUM3Qyw0QkFBNEIsbUJBQU8sQ0FBQyx3RkFBbUI7QUFDdkQsc0JBQXNCLG1CQUFPLENBQUMsNEVBQWE7QUFDM0Msd0JBQXdCLG1CQUFPLENBQUMsZ0ZBQWU7QUFDL0MsdUNBQXVDLG1CQUFPLENBQUMsc0hBQWtDO0FBQ2pGO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQSxnQkFBZ0IsZUFBZTtBQUMvQixvQkFBb0IsbUJBQW1CO0FBQ3ZDLG9CQUFvQixtQkFBbUI7QUFDdkMsdUJBQXVCLGtCQUFlO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0M7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQztBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQyxhQUFhLEdBQUcsSUFBSTtBQUNwRDtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsd0JBQXdCLEVBQUUsVUFBVSxJQUFJLFFBQVE7QUFDN0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBLHVCQUF1QixLQUFLO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DLEtBQUs7QUFDekM7QUFDQSx3REFBd0QsS0FBSztBQUM3RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcmVwby12aXN1YWxpemVyLy4vbm9kZV9tb2R1bGVzL0BiYWJlbC90cmF2ZXJzZS9saWIvcGF0aC9pbmRleC5qcz81MGVkIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5kZWZhdWx0ID0gZXhwb3J0cy5TSE9VTERfU1RPUCA9IGV4cG9ydHMuU0hPVUxEX1NLSVAgPSBleHBvcnRzLlJFTU9WRUQgPSB2b2lkIDA7XG52YXIgdmlydHVhbFR5cGVzID0gcmVxdWlyZShcIi4vbGliL3ZpcnR1YWwtdHlwZXMuanNcIik7XG52YXIgX2RlYnVnID0gcmVxdWlyZShcImRlYnVnXCIpO1xudmFyIF9pbmRleCA9IHJlcXVpcmUoXCIuLi9pbmRleC5qc1wiKTtcbnZhciBfaW5kZXgyID0gcmVxdWlyZShcIi4uL3Njb3BlL2luZGV4LmpzXCIpO1xudmFyIF90ID0gcmVxdWlyZShcIkBiYWJlbC90eXBlc1wiKTtcbnZhciB0ID0gX3Q7XG52YXIgY2FjaGUgPSByZXF1aXJlKFwiLi4vY2FjaGUuanNcIik7XG52YXIgX2dlbmVyYXRvciA9IHJlcXVpcmUoXCJAYmFiZWwvZ2VuZXJhdG9yXCIpO1xudmFyIE5vZGVQYXRoX2FuY2VzdHJ5ID0gcmVxdWlyZShcIi4vYW5jZXN0cnkuanNcIik7XG52YXIgTm9kZVBhdGhfaW5mZXJlbmNlID0gcmVxdWlyZShcIi4vaW5mZXJlbmNlL2luZGV4LmpzXCIpO1xudmFyIE5vZGVQYXRoX3JlcGxhY2VtZW50ID0gcmVxdWlyZShcIi4vcmVwbGFjZW1lbnQuanNcIik7XG52YXIgTm9kZVBhdGhfZXZhbHVhdGlvbiA9IHJlcXVpcmUoXCIuL2V2YWx1YXRpb24uanNcIik7XG52YXIgTm9kZVBhdGhfY29udmVyc2lvbiA9IHJlcXVpcmUoXCIuL2NvbnZlcnNpb24uanNcIik7XG52YXIgTm9kZVBhdGhfaW50cm9zcGVjdGlvbiA9IHJlcXVpcmUoXCIuL2ludHJvc3BlY3Rpb24uanNcIik7XG52YXIgX2NvbnRleHQgPSByZXF1aXJlKFwiLi9jb250ZXh0LmpzXCIpO1xudmFyIE5vZGVQYXRoX2NvbnRleHQgPSBfY29udGV4dDtcbnZhciBOb2RlUGF0aF9yZW1vdmFsID0gcmVxdWlyZShcIi4vcmVtb3ZhbC5qc1wiKTtcbnZhciBOb2RlUGF0aF9tb2RpZmljYXRpb24gPSByZXF1aXJlKFwiLi9tb2RpZmljYXRpb24uanNcIik7XG52YXIgTm9kZVBhdGhfZmFtaWx5ID0gcmVxdWlyZShcIi4vZmFtaWx5LmpzXCIpO1xudmFyIE5vZGVQYXRoX2NvbW1lbnRzID0gcmVxdWlyZShcIi4vY29tbWVudHMuanNcIik7XG52YXIgTm9kZVBhdGhfdmlydHVhbF90eXBlc192YWxpZGF0b3IgPSByZXF1aXJlKFwiLi9saWIvdmlydHVhbC10eXBlcy12YWxpZGF0b3IuanNcIik7XG5jb25zdCB7XG4gIHZhbGlkYXRlXG59ID0gX3Q7XG5jb25zdCBkZWJ1ZyA9IF9kZWJ1ZyhcImJhYmVsXCIpO1xuY29uc3QgUkVNT1ZFRCA9IGV4cG9ydHMuUkVNT1ZFRCA9IDEgPDwgMDtcbmNvbnN0IFNIT1VMRF9TVE9QID0gZXhwb3J0cy5TSE9VTERfU1RPUCA9IDEgPDwgMTtcbmNvbnN0IFNIT1VMRF9TS0lQID0gZXhwb3J0cy5TSE9VTERfU0tJUCA9IDEgPDwgMjtcbmNvbnN0IE5vZGVQYXRoX0ZpbmFsID0gZXhwb3J0cy5kZWZhdWx0ID0gY2xhc3MgTm9kZVBhdGgge1xuICBjb25zdHJ1Y3RvcihodWIsIHBhcmVudCkge1xuICAgIHRoaXMuY29udGV4dHMgPSBbXTtcbiAgICB0aGlzLnN0YXRlID0gbnVsbDtcbiAgICB0aGlzLl90cmF2ZXJzZUZsYWdzID0gMDtcbiAgICB0aGlzLnNraXBLZXlzID0gbnVsbDtcbiAgICB0aGlzLnBhcmVudFBhdGggPSBudWxsO1xuICAgIHRoaXMuY29udGFpbmVyID0gbnVsbDtcbiAgICB0aGlzLmxpc3RLZXkgPSBudWxsO1xuICAgIHRoaXMua2V5ID0gbnVsbDtcbiAgICB0aGlzLm5vZGUgPSBudWxsO1xuICAgIHRoaXMudHlwZSA9IG51bGw7XG4gICAgdGhpcy5fc3RvcmUgPSBudWxsO1xuICAgIHRoaXMucGFyZW50ID0gcGFyZW50O1xuICAgIHRoaXMuaHViID0gaHViO1xuICAgIHRoaXMuZGF0YSA9IG51bGw7XG4gICAgdGhpcy5jb250ZXh0ID0gbnVsbDtcbiAgICB0aGlzLnNjb3BlID0gbnVsbDtcbiAgfVxuICBnZXQgcmVtb3ZlZCgpIHtcbiAgICByZXR1cm4gKHRoaXMuX3RyYXZlcnNlRmxhZ3MgJiAxKSA+IDA7XG4gIH1cbiAgc2V0IHJlbW92ZWQodikge1xuICAgIGlmICh2KSB0aGlzLl90cmF2ZXJzZUZsYWdzIHw9IDE7ZWxzZSB0aGlzLl90cmF2ZXJzZUZsYWdzICY9IC0yO1xuICB9XG4gIGdldCBzaG91bGRTdG9wKCkge1xuICAgIHJldHVybiAodGhpcy5fdHJhdmVyc2VGbGFncyAmIDIpID4gMDtcbiAgfVxuICBzZXQgc2hvdWxkU3RvcCh2KSB7XG4gICAgaWYgKHYpIHRoaXMuX3RyYXZlcnNlRmxhZ3MgfD0gMjtlbHNlIHRoaXMuX3RyYXZlcnNlRmxhZ3MgJj0gLTM7XG4gIH1cbiAgZ2V0IHNob3VsZFNraXAoKSB7XG4gICAgcmV0dXJuICh0aGlzLl90cmF2ZXJzZUZsYWdzICYgNCkgPiAwO1xuICB9XG4gIHNldCBzaG91bGRTa2lwKHYpIHtcbiAgICBpZiAodikgdGhpcy5fdHJhdmVyc2VGbGFncyB8PSA0O2Vsc2UgdGhpcy5fdHJhdmVyc2VGbGFncyAmPSAtNTtcbiAgfVxuICBzdGF0aWMgZ2V0KHtcbiAgICBodWIsXG4gICAgcGFyZW50UGF0aCxcbiAgICBwYXJlbnQsXG4gICAgY29udGFpbmVyLFxuICAgIGxpc3RLZXksXG4gICAga2V5XG4gIH0pIHtcbiAgICBpZiAoIWh1YiAmJiBwYXJlbnRQYXRoKSB7XG4gICAgICBodWIgPSBwYXJlbnRQYXRoLmh1YjtcbiAgICB9XG4gICAgaWYgKCFwYXJlbnQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIlRvIGdldCBhIG5vZGUgcGF0aCB0aGUgcGFyZW50IG5lZWRzIHRvIGV4aXN0XCIpO1xuICAgIH1cbiAgICBjb25zdCB0YXJnZXROb2RlID0gY29udGFpbmVyW2tleV07XG4gICAgY29uc3QgcGF0aHMgPSBjYWNoZS5nZXRPckNyZWF0ZUNhY2hlZFBhdGhzKHBhcmVudCwgcGFyZW50UGF0aCk7XG4gICAgbGV0IHBhdGggPSBwYXRocy5nZXQodGFyZ2V0Tm9kZSk7XG4gICAgaWYgKCFwYXRoKSB7XG4gICAgICBwYXRoID0gbmV3IE5vZGVQYXRoKGh1YiwgcGFyZW50KTtcbiAgICAgIGlmICh0YXJnZXROb2RlKSBwYXRocy5zZXQodGFyZ2V0Tm9kZSwgcGF0aCk7XG4gICAgfVxuICAgIF9jb250ZXh0LnNldHVwLmNhbGwocGF0aCwgcGFyZW50UGF0aCwgY29udGFpbmVyLCBsaXN0S2V5LCBrZXkpO1xuICAgIHJldHVybiBwYXRoO1xuICB9XG4gIGdldFNjb3BlKHNjb3BlKSB7XG4gICAgcmV0dXJuIHRoaXMuaXNTY29wZSgpID8gbmV3IF9pbmRleDIuZGVmYXVsdCh0aGlzKSA6IHNjb3BlO1xuICB9XG4gIHNldERhdGEoa2V5LCB2YWwpIHtcbiAgICBpZiAodGhpcy5kYXRhID09IG51bGwpIHtcbiAgICAgIHRoaXMuZGF0YSA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLmRhdGFba2V5XSA9IHZhbDtcbiAgfVxuICBnZXREYXRhKGtleSwgZGVmKSB7XG4gICAgaWYgKHRoaXMuZGF0YSA9PSBudWxsKSB7XG4gICAgICB0aGlzLmRhdGEgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgIH1cbiAgICBsZXQgdmFsID0gdGhpcy5kYXRhW2tleV07XG4gICAgaWYgKHZhbCA9PT0gdW5kZWZpbmVkICYmIGRlZiAhPT0gdW5kZWZpbmVkKSB2YWwgPSB0aGlzLmRhdGFba2V5XSA9IGRlZjtcbiAgICByZXR1cm4gdmFsO1xuICB9XG4gIGhhc05vZGUoKSB7XG4gICAgcmV0dXJuIHRoaXMubm9kZSAhPSBudWxsO1xuICB9XG4gIGJ1aWxkQ29kZUZyYW1lRXJyb3IobXNnLCBFcnJvciA9IFN5bnRheEVycm9yKSB7XG4gICAgcmV0dXJuIHRoaXMuaHViLmJ1aWxkRXJyb3IodGhpcy5ub2RlLCBtc2csIEVycm9yKTtcbiAgfVxuICB0cmF2ZXJzZSh2aXNpdG9yLCBzdGF0ZSkge1xuICAgICgwLCBfaW5kZXguZGVmYXVsdCkodGhpcy5ub2RlLCB2aXNpdG9yLCB0aGlzLnNjb3BlLCBzdGF0ZSwgdGhpcyk7XG4gIH1cbiAgc2V0KGtleSwgbm9kZSkge1xuICAgIHZhbGlkYXRlKHRoaXMubm9kZSwga2V5LCBub2RlKTtcbiAgICB0aGlzLm5vZGVba2V5XSA9IG5vZGU7XG4gIH1cbiAgZ2V0UGF0aExvY2F0aW9uKCkge1xuICAgIGNvbnN0IHBhcnRzID0gW107XG4gICAgbGV0IHBhdGggPSB0aGlzO1xuICAgIGRvIHtcbiAgICAgIGxldCBrZXkgPSBwYXRoLmtleTtcbiAgICAgIGlmIChwYXRoLmluTGlzdCkga2V5ID0gYCR7cGF0aC5saXN0S2V5fVske2tleX1dYDtcbiAgICAgIHBhcnRzLnVuc2hpZnQoa2V5KTtcbiAgICB9IHdoaWxlIChwYXRoID0gcGF0aC5wYXJlbnRQYXRoKTtcbiAgICByZXR1cm4gcGFydHMuam9pbihcIi5cIik7XG4gIH1cbiAgZGVidWcobWVzc2FnZSkge1xuICAgIGlmICghZGVidWcuZW5hYmxlZCkgcmV0dXJuO1xuICAgIGRlYnVnKGAke3RoaXMuZ2V0UGF0aExvY2F0aW9uKCl9ICR7dGhpcy50eXBlfTogJHttZXNzYWdlfWApO1xuICB9XG4gIHRvU3RyaW5nKCkge1xuICAgIHJldHVybiAoMCwgX2dlbmVyYXRvci5kZWZhdWx0KSh0aGlzLm5vZGUpLmNvZGU7XG4gIH1cbiAgZ2V0IGluTGlzdCgpIHtcbiAgICByZXR1cm4gISF0aGlzLmxpc3RLZXk7XG4gIH1cbiAgc2V0IGluTGlzdChpbkxpc3QpIHtcbiAgICBpZiAoIWluTGlzdCkge1xuICAgICAgdGhpcy5saXN0S2V5ID0gbnVsbDtcbiAgICB9XG4gIH1cbiAgZ2V0IHBhcmVudEtleSgpIHtcbiAgICByZXR1cm4gdGhpcy5saXN0S2V5IHx8IHRoaXMua2V5O1xuICB9XG59O1xuY29uc3QgbWV0aG9kcyA9IHtcbiAgZmluZFBhcmVudDogTm9kZVBhdGhfYW5jZXN0cnkuZmluZFBhcmVudCxcbiAgZmluZDogTm9kZVBhdGhfYW5jZXN0cnkuZmluZCxcbiAgZ2V0RnVuY3Rpb25QYXJlbnQ6IE5vZGVQYXRoX2FuY2VzdHJ5LmdldEZ1bmN0aW9uUGFyZW50LFxuICBnZXRTdGF0ZW1lbnRQYXJlbnQ6IE5vZGVQYXRoX2FuY2VzdHJ5LmdldFN0YXRlbWVudFBhcmVudCxcbiAgZ2V0RWFybGllc3RDb21tb25BbmNlc3RvckZyb206IE5vZGVQYXRoX2FuY2VzdHJ5LmdldEVhcmxpZXN0Q29tbW9uQW5jZXN0b3JGcm9tLFxuICBnZXREZWVwZXN0Q29tbW9uQW5jZXN0b3JGcm9tOiBOb2RlUGF0aF9hbmNlc3RyeS5nZXREZWVwZXN0Q29tbW9uQW5jZXN0b3JGcm9tLFxuICBnZXRBbmNlc3RyeTogTm9kZVBhdGhfYW5jZXN0cnkuZ2V0QW5jZXN0cnksXG4gIGlzQW5jZXN0b3I6IE5vZGVQYXRoX2FuY2VzdHJ5LmlzQW5jZXN0b3IsXG4gIGlzRGVzY2VuZGFudDogTm9kZVBhdGhfYW5jZXN0cnkuaXNEZXNjZW5kYW50LFxuICBpblR5cGU6IE5vZGVQYXRoX2FuY2VzdHJ5LmluVHlwZSxcbiAgZ2V0VHlwZUFubm90YXRpb246IE5vZGVQYXRoX2luZmVyZW5jZS5nZXRUeXBlQW5ub3RhdGlvbixcbiAgaXNCYXNlVHlwZTogTm9kZVBhdGhfaW5mZXJlbmNlLmlzQmFzZVR5cGUsXG4gIGNvdWxkQmVCYXNlVHlwZTogTm9kZVBhdGhfaW5mZXJlbmNlLmNvdWxkQmVCYXNlVHlwZSxcbiAgYmFzZVR5cGVTdHJpY3RseU1hdGNoZXM6IE5vZGVQYXRoX2luZmVyZW5jZS5iYXNlVHlwZVN0cmljdGx5TWF0Y2hlcyxcbiAgaXNHZW5lcmljVHlwZTogTm9kZVBhdGhfaW5mZXJlbmNlLmlzR2VuZXJpY1R5cGUsXG4gIHJlcGxhY2VXaXRoTXVsdGlwbGU6IE5vZGVQYXRoX3JlcGxhY2VtZW50LnJlcGxhY2VXaXRoTXVsdGlwbGUsXG4gIHJlcGxhY2VXaXRoU291cmNlU3RyaW5nOiBOb2RlUGF0aF9yZXBsYWNlbWVudC5yZXBsYWNlV2l0aFNvdXJjZVN0cmluZyxcbiAgcmVwbGFjZVdpdGg6IE5vZGVQYXRoX3JlcGxhY2VtZW50LnJlcGxhY2VXaXRoLFxuICByZXBsYWNlRXhwcmVzc2lvbldpdGhTdGF0ZW1lbnRzOiBOb2RlUGF0aF9yZXBsYWNlbWVudC5yZXBsYWNlRXhwcmVzc2lvbldpdGhTdGF0ZW1lbnRzLFxuICByZXBsYWNlSW5saW5lOiBOb2RlUGF0aF9yZXBsYWNlbWVudC5yZXBsYWNlSW5saW5lLFxuICBldmFsdWF0ZVRydXRoeTogTm9kZVBhdGhfZXZhbHVhdGlvbi5ldmFsdWF0ZVRydXRoeSxcbiAgZXZhbHVhdGU6IE5vZGVQYXRoX2V2YWx1YXRpb24uZXZhbHVhdGUsXG4gIHRvQ29tcHV0ZWRLZXk6IE5vZGVQYXRoX2NvbnZlcnNpb24udG9Db21wdXRlZEtleSxcbiAgZW5zdXJlQmxvY2s6IE5vZGVQYXRoX2NvbnZlcnNpb24uZW5zdXJlQmxvY2ssXG4gIHVud3JhcEZ1bmN0aW9uRW52aXJvbm1lbnQ6IE5vZGVQYXRoX2NvbnZlcnNpb24udW53cmFwRnVuY3Rpb25FbnZpcm9ubWVudCxcbiAgYXJyb3dGdW5jdGlvblRvRXhwcmVzc2lvbjogTm9kZVBhdGhfY29udmVyc2lvbi5hcnJvd0Z1bmN0aW9uVG9FeHByZXNzaW9uLFxuICBzcGxpdEV4cG9ydERlY2xhcmF0aW9uOiBOb2RlUGF0aF9jb252ZXJzaW9uLnNwbGl0RXhwb3J0RGVjbGFyYXRpb24sXG4gIGVuc3VyZUZ1bmN0aW9uTmFtZTogTm9kZVBhdGhfY29udmVyc2lvbi5lbnN1cmVGdW5jdGlvbk5hbWUsXG4gIG1hdGNoZXNQYXR0ZXJuOiBOb2RlUGF0aF9pbnRyb3NwZWN0aW9uLm1hdGNoZXNQYXR0ZXJuLFxuICBpc1N0YXRpYzogTm9kZVBhdGhfaW50cm9zcGVjdGlvbi5pc1N0YXRpYyxcbiAgaXNOb2RlVHlwZTogTm9kZVBhdGhfaW50cm9zcGVjdGlvbi5pc05vZGVUeXBlLFxuICBjYW5IYXZlVmFyaWFibGVEZWNsYXJhdGlvbk9yRXhwcmVzc2lvbjogTm9kZVBhdGhfaW50cm9zcGVjdGlvbi5jYW5IYXZlVmFyaWFibGVEZWNsYXJhdGlvbk9yRXhwcmVzc2lvbixcbiAgY2FuU3dhcEJldHdlZW5FeHByZXNzaW9uQW5kU3RhdGVtZW50OiBOb2RlUGF0aF9pbnRyb3NwZWN0aW9uLmNhblN3YXBCZXR3ZWVuRXhwcmVzc2lvbkFuZFN0YXRlbWVudCxcbiAgaXNDb21wbGV0aW9uUmVjb3JkOiBOb2RlUGF0aF9pbnRyb3NwZWN0aW9uLmlzQ29tcGxldGlvblJlY29yZCxcbiAgaXNTdGF0ZW1lbnRPckJsb2NrOiBOb2RlUGF0aF9pbnRyb3NwZWN0aW9uLmlzU3RhdGVtZW50T3JCbG9jayxcbiAgcmVmZXJlbmNlc0ltcG9ydDogTm9kZVBhdGhfaW50cm9zcGVjdGlvbi5yZWZlcmVuY2VzSW1wb3J0LFxuICBnZXRTb3VyY2U6IE5vZGVQYXRoX2ludHJvc3BlY3Rpb24uZ2V0U291cmNlLFxuICB3aWxsSU1heWJlRXhlY3V0ZUJlZm9yZTogTm9kZVBhdGhfaW50cm9zcGVjdGlvbi53aWxsSU1heWJlRXhlY3V0ZUJlZm9yZSxcbiAgX2d1ZXNzRXhlY3V0aW9uU3RhdHVzUmVsYXRpdmVUbzogTm9kZVBhdGhfaW50cm9zcGVjdGlvbi5fZ3Vlc3NFeGVjdXRpb25TdGF0dXNSZWxhdGl2ZVRvLFxuICByZXNvbHZlOiBOb2RlUGF0aF9pbnRyb3NwZWN0aW9uLnJlc29sdmUsXG4gIGlzQ29uc3RhbnRFeHByZXNzaW9uOiBOb2RlUGF0aF9pbnRyb3NwZWN0aW9uLmlzQ29uc3RhbnRFeHByZXNzaW9uLFxuICBpc0luU3RyaWN0TW9kZTogTm9kZVBhdGhfaW50cm9zcGVjdGlvbi5pc0luU3RyaWN0TW9kZSxcbiAgaXNEZW55bGlzdGVkOiBOb2RlUGF0aF9jb250ZXh0LmlzRGVueWxpc3RlZCxcbiAgdmlzaXQ6IE5vZGVQYXRoX2NvbnRleHQudmlzaXQsXG4gIHNraXA6IE5vZGVQYXRoX2NvbnRleHQuc2tpcCxcbiAgc2tpcEtleTogTm9kZVBhdGhfY29udGV4dC5za2lwS2V5LFxuICBzdG9wOiBOb2RlUGF0aF9jb250ZXh0LnN0b3AsXG4gIHNldENvbnRleHQ6IE5vZGVQYXRoX2NvbnRleHQuc2V0Q29udGV4dCxcbiAgcmVxdWV1ZTogTm9kZVBhdGhfY29udGV4dC5yZXF1ZXVlLFxuICByZXF1ZXVlQ29tcHV0ZWRLZXlBbmREZWNvcmF0b3JzOiBOb2RlUGF0aF9jb250ZXh0LnJlcXVldWVDb21wdXRlZEtleUFuZERlY29yYXRvcnMsXG4gIHJlbW92ZTogTm9kZVBhdGhfcmVtb3ZhbC5yZW1vdmUsXG4gIGluc2VydEJlZm9yZTogTm9kZVBhdGhfbW9kaWZpY2F0aW9uLmluc2VydEJlZm9yZSxcbiAgaW5zZXJ0QWZ0ZXI6IE5vZGVQYXRoX21vZGlmaWNhdGlvbi5pbnNlcnRBZnRlcixcbiAgdW5zaGlmdENvbnRhaW5lcjogTm9kZVBhdGhfbW9kaWZpY2F0aW9uLnVuc2hpZnRDb250YWluZXIsXG4gIHB1c2hDb250YWluZXI6IE5vZGVQYXRoX21vZGlmaWNhdGlvbi5wdXNoQ29udGFpbmVyLFxuICBnZXRPcHBvc2l0ZTogTm9kZVBhdGhfZmFtaWx5LmdldE9wcG9zaXRlLFxuICBnZXRDb21wbGV0aW9uUmVjb3JkczogTm9kZVBhdGhfZmFtaWx5LmdldENvbXBsZXRpb25SZWNvcmRzLFxuICBnZXRTaWJsaW5nOiBOb2RlUGF0aF9mYW1pbHkuZ2V0U2libGluZyxcbiAgZ2V0UHJldlNpYmxpbmc6IE5vZGVQYXRoX2ZhbWlseS5nZXRQcmV2U2libGluZyxcbiAgZ2V0TmV4dFNpYmxpbmc6IE5vZGVQYXRoX2ZhbWlseS5nZXROZXh0U2libGluZyxcbiAgZ2V0QWxsTmV4dFNpYmxpbmdzOiBOb2RlUGF0aF9mYW1pbHkuZ2V0QWxsTmV4dFNpYmxpbmdzLFxuICBnZXRBbGxQcmV2U2libGluZ3M6IE5vZGVQYXRoX2ZhbWlseS5nZXRBbGxQcmV2U2libGluZ3MsXG4gIGdldDogTm9kZVBhdGhfZmFtaWx5LmdldCxcbiAgZ2V0QXNzaWdubWVudElkZW50aWZpZXJzOiBOb2RlUGF0aF9mYW1pbHkuZ2V0QXNzaWdubWVudElkZW50aWZpZXJzLFxuICBnZXRCaW5kaW5nSWRlbnRpZmllcnM6IE5vZGVQYXRoX2ZhbWlseS5nZXRCaW5kaW5nSWRlbnRpZmllcnMsXG4gIGdldE91dGVyQmluZGluZ0lkZW50aWZpZXJzOiBOb2RlUGF0aF9mYW1pbHkuZ2V0T3V0ZXJCaW5kaW5nSWRlbnRpZmllcnMsXG4gIGdldEJpbmRpbmdJZGVudGlmaWVyUGF0aHM6IE5vZGVQYXRoX2ZhbWlseS5nZXRCaW5kaW5nSWRlbnRpZmllclBhdGhzLFxuICBnZXRPdXRlckJpbmRpbmdJZGVudGlmaWVyUGF0aHM6IE5vZGVQYXRoX2ZhbWlseS5nZXRPdXRlckJpbmRpbmdJZGVudGlmaWVyUGF0aHMsXG4gIHNoYXJlQ29tbWVudHNXaXRoU2libGluZ3M6IE5vZGVQYXRoX2NvbW1lbnRzLnNoYXJlQ29tbWVudHNXaXRoU2libGluZ3MsXG4gIGFkZENvbW1lbnQ6IE5vZGVQYXRoX2NvbW1lbnRzLmFkZENvbW1lbnQsXG4gIGFkZENvbW1lbnRzOiBOb2RlUGF0aF9jb21tZW50cy5hZGRDb21tZW50c1xufTtcbk9iamVjdC5hc3NpZ24oTm9kZVBhdGhfRmluYWwucHJvdG90eXBlLCBtZXRob2RzKTtcbk5vZGVQYXRoX0ZpbmFsLnByb3RvdHlwZS5hcnJvd0Z1bmN0aW9uVG9TaGFkb3dlZCA9IE5vZGVQYXRoX2NvbnZlcnNpb25bU3RyaW5nKFwiYXJyb3dGdW5jdGlvblRvU2hhZG93ZWRcIildO1xuT2JqZWN0LmFzc2lnbihOb2RlUGF0aF9GaW5hbC5wcm90b3R5cGUsIHtcbiAgaGFzOiBOb2RlUGF0aF9pbnRyb3NwZWN0aW9uW1N0cmluZyhcImhhc1wiKV0sXG4gIGlzOiBOb2RlUGF0aF9pbnRyb3NwZWN0aW9uW1N0cmluZyhcImlzXCIpXSxcbiAgaXNudDogTm9kZVBhdGhfaW50cm9zcGVjdGlvbltTdHJpbmcoXCJpc250XCIpXSxcbiAgZXF1YWxzOiBOb2RlUGF0aF9pbnRyb3NwZWN0aW9uW1N0cmluZyhcImVxdWFsc1wiKV0sXG4gIGhvaXN0OiBOb2RlUGF0aF9tb2RpZmljYXRpb25bU3RyaW5nKFwiaG9pc3RcIildLFxuICB1cGRhdGVTaWJsaW5nS2V5czogTm9kZVBhdGhfbW9kaWZpY2F0aW9uLnVwZGF0ZVNpYmxpbmdLZXlzLFxuICBjYWxsOiBOb2RlUGF0aF9jb250ZXh0LmNhbGwsXG4gIGlzQmxhY2tsaXN0ZWQ6IE5vZGVQYXRoX2NvbnRleHRbU3RyaW5nKFwiaXNCbGFja2xpc3RlZFwiKV0sXG4gIHNldFNjb3BlOiBOb2RlUGF0aF9jb250ZXh0LnNldFNjb3BlLFxuICByZXN5bmM6IE5vZGVQYXRoX2NvbnRleHQucmVzeW5jLFxuICBwb3BDb250ZXh0OiBOb2RlUGF0aF9jb250ZXh0LnBvcENvbnRleHQsXG4gIHB1c2hDb250ZXh0OiBOb2RlUGF0aF9jb250ZXh0LnB1c2hDb250ZXh0LFxuICBzZXR1cDogTm9kZVBhdGhfY29udGV4dC5zZXR1cCxcbiAgc2V0S2V5OiBOb2RlUGF0aF9jb250ZXh0LnNldEtleVxufSk7XG5Ob2RlUGF0aF9GaW5hbC5wcm90b3R5cGUuX2d1ZXNzRXhlY3V0aW9uU3RhdHVzUmVsYXRpdmVUb0RpZmZlcmVudEZ1bmN0aW9ucyA9IE5vZGVQYXRoX2ludHJvc3BlY3Rpb24uX2d1ZXNzRXhlY3V0aW9uU3RhdHVzUmVsYXRpdmVUbztcbk5vZGVQYXRoX0ZpbmFsLnByb3RvdHlwZS5fZ3Vlc3NFeGVjdXRpb25TdGF0dXNSZWxhdGl2ZVRvRGlmZmVyZW50RnVuY3Rpb25zID0gTm9kZVBhdGhfaW50cm9zcGVjdGlvbi5fZ3Vlc3NFeGVjdXRpb25TdGF0dXNSZWxhdGl2ZVRvO1xuT2JqZWN0LmFzc2lnbihOb2RlUGF0aF9GaW5hbC5wcm90b3R5cGUsIHtcbiAgX2dldFR5cGVBbm5vdGF0aW9uOiBOb2RlUGF0aF9pbmZlcmVuY2UuX2dldFR5cGVBbm5vdGF0aW9uLFxuICBfcmVwbGFjZVdpdGg6IE5vZGVQYXRoX3JlcGxhY2VtZW50Ll9yZXBsYWNlV2l0aCxcbiAgX3Jlc29sdmU6IE5vZGVQYXRoX2ludHJvc3BlY3Rpb24uX3Jlc29sdmUsXG4gIF9jYWxsOiBOb2RlUGF0aF9jb250ZXh0Ll9jYWxsLFxuICBfcmVzeW5jUGFyZW50OiBOb2RlUGF0aF9jb250ZXh0Ll9yZXN5bmNQYXJlbnQsXG4gIF9yZXN5bmNLZXk6IE5vZGVQYXRoX2NvbnRleHQuX3Jlc3luY0tleSxcbiAgX3Jlc3luY0xpc3Q6IE5vZGVQYXRoX2NvbnRleHQuX3Jlc3luY0xpc3QsXG4gIF9yZXN5bmNSZW1vdmVkOiBOb2RlUGF0aF9jb250ZXh0Ll9yZXN5bmNSZW1vdmVkLFxuICBfZ2V0UXVldWVDb250ZXh0czogTm9kZVBhdGhfY29udGV4dC5fZ2V0UXVldWVDb250ZXh0cyxcbiAgX3JlbW92ZUZyb21TY29wZTogTm9kZVBhdGhfcmVtb3ZhbC5fcmVtb3ZlRnJvbVNjb3BlLFxuICBfY2FsbFJlbW92YWxIb29rczogTm9kZVBhdGhfcmVtb3ZhbC5fY2FsbFJlbW92YWxIb29rcyxcbiAgX3JlbW92ZTogTm9kZVBhdGhfcmVtb3ZhbC5fcmVtb3ZlLFxuICBfbWFya1JlbW92ZWQ6IE5vZGVQYXRoX3JlbW92YWwuX21hcmtSZW1vdmVkLFxuICBfYXNzZXJ0VW5yZW1vdmVkOiBOb2RlUGF0aF9yZW1vdmFsLl9hc3NlcnRVbnJlbW92ZWQsXG4gIF9jb250YWluZXJJbnNlcnQ6IE5vZGVQYXRoX21vZGlmaWNhdGlvbi5fY29udGFpbmVySW5zZXJ0LFxuICBfY29udGFpbmVySW5zZXJ0QmVmb3JlOiBOb2RlUGF0aF9tb2RpZmljYXRpb24uX2NvbnRhaW5lckluc2VydEJlZm9yZSxcbiAgX2NvbnRhaW5lckluc2VydEFmdGVyOiBOb2RlUGF0aF9tb2RpZmljYXRpb24uX2NvbnRhaW5lckluc2VydEFmdGVyLFxuICBfdmVyaWZ5Tm9kZUxpc3Q6IE5vZGVQYXRoX21vZGlmaWNhdGlvbi5fdmVyaWZ5Tm9kZUxpc3QsXG4gIF9nZXRLZXk6IE5vZGVQYXRoX2ZhbWlseS5fZ2V0S2V5LFxuICBfZ2V0UGF0dGVybjogTm9kZVBhdGhfZmFtaWx5Ll9nZXRQYXR0ZXJuXG59KTtcbmZvciAoY29uc3QgdHlwZSBvZiB0LlRZUEVTKSB7XG4gIGNvbnN0IHR5cGVLZXkgPSBgaXMke3R5cGV9YDtcbiAgY29uc3QgZm4gPSB0W3R5cGVLZXldO1xuICBOb2RlUGF0aF9GaW5hbC5wcm90b3R5cGVbdHlwZUtleV0gPSBmdW5jdGlvbiAob3B0cykge1xuICAgIHJldHVybiBmbih0aGlzLm5vZGUsIG9wdHMpO1xuICB9O1xuICBOb2RlUGF0aF9GaW5hbC5wcm90b3R5cGVbYGFzc2VydCR7dHlwZX1gXSA9IGZ1bmN0aW9uIChvcHRzKSB7XG4gICAgaWYgKCFmbih0aGlzLm5vZGUsIG9wdHMpKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBFeHBlY3RlZCBub2RlIHBhdGggb2YgdHlwZSAke3R5cGV9YCk7XG4gICAgfVxuICB9O1xufVxuT2JqZWN0LmFzc2lnbihOb2RlUGF0aF9GaW5hbC5wcm90b3R5cGUsIE5vZGVQYXRoX3ZpcnR1YWxfdHlwZXNfdmFsaWRhdG9yKTtcbmZvciAoY29uc3QgdHlwZSBvZiBPYmplY3Qua2V5cyh2aXJ0dWFsVHlwZXMpKSB7XG4gIGlmICh0eXBlLnN0YXJ0c1dpdGgoXCJfXCIpKSBjb250aW51ZTtcbiAgaWYgKCF0LlRZUEVTLmluY2x1ZGVzKHR5cGUpKSB0LlRZUEVTLnB1c2godHlwZSk7XG59XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcFxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@babel/traverse/lib/path/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@babel/traverse/lib/path/inference/index.js":
/*!******************************************************************!*\
  !*** ./node_modules/@babel/traverse/lib/path/inference/index.js ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports._getTypeAnnotation = _getTypeAnnotation;\nexports.baseTypeStrictlyMatches = baseTypeStrictlyMatches;\nexports.couldBeBaseType = couldBeBaseType;\nexports.getTypeAnnotation = getTypeAnnotation;\nexports.isBaseType = isBaseType;\nexports.isGenericType = isGenericType;\nvar inferers = __webpack_require__(/*! ./inferers.js */ \"(ssr)/./node_modules/@babel/traverse/lib/path/inference/inferers.js\");\nvar _t = __webpack_require__(/*! @babel/types */ \"(ssr)/./node_modules/@babel/types/lib/index.js\");\nconst {\n  anyTypeAnnotation,\n  isAnyTypeAnnotation,\n  isArrayTypeAnnotation,\n  isBooleanTypeAnnotation,\n  isEmptyTypeAnnotation,\n  isFlowBaseAnnotation,\n  isGenericTypeAnnotation,\n  isIdentifier,\n  isMixedTypeAnnotation,\n  isNumberTypeAnnotation,\n  isStringTypeAnnotation,\n  isTSArrayType,\n  isTSTypeAnnotation,\n  isTSTypeReference,\n  isTupleTypeAnnotation,\n  isTypeAnnotation,\n  isUnionTypeAnnotation,\n  isVoidTypeAnnotation,\n  stringTypeAnnotation,\n  voidTypeAnnotation\n} = _t;\nfunction getTypeAnnotation() {\n  let type = this.getData(\"typeAnnotation\");\n  if (type != null) {\n    return type;\n  }\n  type = _getTypeAnnotation.call(this) || anyTypeAnnotation();\n  if (isTypeAnnotation(type) || isTSTypeAnnotation(type)) {\n    type = type.typeAnnotation;\n  }\n  this.setData(\"typeAnnotation\", type);\n  return type;\n}\nconst typeAnnotationInferringNodes = new WeakSet();\nfunction _getTypeAnnotation() {\n  const node = this.node;\n  if (!node) {\n    if (this.key === \"init\" && this.parentPath.isVariableDeclarator()) {\n      const declar = this.parentPath.parentPath;\n      const declarParent = declar.parentPath;\n      if (declar.key === \"left\" && declarParent.isForInStatement()) {\n        return stringTypeAnnotation();\n      }\n      if (declar.key === \"left\" && declarParent.isForOfStatement()) {\n        return anyTypeAnnotation();\n      }\n      return voidTypeAnnotation();\n    } else {\n      return;\n    }\n  }\n  if (node.typeAnnotation) {\n    return node.typeAnnotation;\n  }\n  if (typeAnnotationInferringNodes.has(node)) {\n    return;\n  }\n  typeAnnotationInferringNodes.add(node);\n  try {\n    var _inferer;\n    let inferer = inferers[node.type];\n    if (inferer) {\n      return inferer.call(this, node);\n    }\n    inferer = inferers[this.parentPath.type];\n    if ((_inferer = inferer) != null && _inferer.validParent) {\n      return this.parentPath.getTypeAnnotation();\n    }\n  } finally {\n    typeAnnotationInferringNodes.delete(node);\n  }\n}\nfunction isBaseType(baseName, soft) {\n  return _isBaseType(baseName, this.getTypeAnnotation(), soft);\n}\nfunction _isBaseType(baseName, type, soft) {\n  if (baseName === \"string\") {\n    return isStringTypeAnnotation(type);\n  } else if (baseName === \"number\") {\n    return isNumberTypeAnnotation(type);\n  } else if (baseName === \"boolean\") {\n    return isBooleanTypeAnnotation(type);\n  } else if (baseName === \"any\") {\n    return isAnyTypeAnnotation(type);\n  } else if (baseName === \"mixed\") {\n    return isMixedTypeAnnotation(type);\n  } else if (baseName === \"empty\") {\n    return isEmptyTypeAnnotation(type);\n  } else if (baseName === \"void\") {\n    return isVoidTypeAnnotation(type);\n  } else {\n    if (soft) {\n      return false;\n    } else {\n      throw new Error(`Unknown base type ${baseName}`);\n    }\n  }\n}\nfunction couldBeBaseType(name) {\n  const type = this.getTypeAnnotation();\n  if (isAnyTypeAnnotation(type)) return true;\n  if (isUnionTypeAnnotation(type)) {\n    for (const type2 of type.types) {\n      if (isAnyTypeAnnotation(type2) || _isBaseType(name, type2, true)) {\n        return true;\n      }\n    }\n    return false;\n  } else {\n    return _isBaseType(name, type, true);\n  }\n}\nfunction baseTypeStrictlyMatches(rightArg) {\n  const left = this.getTypeAnnotation();\n  const right = rightArg.getTypeAnnotation();\n  if (!isAnyTypeAnnotation(left) && isFlowBaseAnnotation(left)) {\n    return right.type === left.type;\n  }\n  return false;\n}\nfunction isGenericType(genericName) {\n  const type = this.getTypeAnnotation();\n  if (genericName === \"Array\") {\n    if (isTSArrayType(type) || isArrayTypeAnnotation(type) || isTupleTypeAnnotation(type)) {\n      return true;\n    }\n  }\n  return isGenericTypeAnnotation(type) && isIdentifier(type.id, {\n    name: genericName\n  }) || isTSTypeReference(type) && isIdentifier(type.typeName, {\n    name: genericName\n  });\n}\n\n//# sourceMappingURL=index.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGJhYmVsL3RyYXZlcnNlL2xpYi9wYXRoL2luZmVyZW5jZS9pbmRleC5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYiw4Q0FBNkM7QUFDN0M7QUFDQSxDQUFDLEVBQUM7QUFDRiwwQkFBMEI7QUFDMUIsK0JBQStCO0FBQy9CLHVCQUF1QjtBQUN2Qix5QkFBeUI7QUFDekIsa0JBQWtCO0FBQ2xCLHFCQUFxQjtBQUNyQixlQUFlLG1CQUFPLENBQUMsMEZBQWU7QUFDdEMsU0FBUyxtQkFBTyxDQUFDLG9FQUFjO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQSxNQUFNO0FBQ04sMkNBQTJDLFNBQVM7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDs7QUFFQSIsInNvdXJjZXMiOlsid2VicGFjazovL3JlcG8tdmlzdWFsaXplci8uL25vZGVfbW9kdWxlcy9AYmFiZWwvdHJhdmVyc2UvbGliL3BhdGgvaW5mZXJlbmNlL2luZGV4LmpzPzhmZTMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLl9nZXRUeXBlQW5ub3RhdGlvbiA9IF9nZXRUeXBlQW5ub3RhdGlvbjtcbmV4cG9ydHMuYmFzZVR5cGVTdHJpY3RseU1hdGNoZXMgPSBiYXNlVHlwZVN0cmljdGx5TWF0Y2hlcztcbmV4cG9ydHMuY291bGRCZUJhc2VUeXBlID0gY291bGRCZUJhc2VUeXBlO1xuZXhwb3J0cy5nZXRUeXBlQW5ub3RhdGlvbiA9IGdldFR5cGVBbm5vdGF0aW9uO1xuZXhwb3J0cy5pc0Jhc2VUeXBlID0gaXNCYXNlVHlwZTtcbmV4cG9ydHMuaXNHZW5lcmljVHlwZSA9IGlzR2VuZXJpY1R5cGU7XG52YXIgaW5mZXJlcnMgPSByZXF1aXJlKFwiLi9pbmZlcmVycy5qc1wiKTtcbnZhciBfdCA9IHJlcXVpcmUoXCJAYmFiZWwvdHlwZXNcIik7XG5jb25zdCB7XG4gIGFueVR5cGVBbm5vdGF0aW9uLFxuICBpc0FueVR5cGVBbm5vdGF0aW9uLFxuICBpc0FycmF5VHlwZUFubm90YXRpb24sXG4gIGlzQm9vbGVhblR5cGVBbm5vdGF0aW9uLFxuICBpc0VtcHR5VHlwZUFubm90YXRpb24sXG4gIGlzRmxvd0Jhc2VBbm5vdGF0aW9uLFxuICBpc0dlbmVyaWNUeXBlQW5ub3RhdGlvbixcbiAgaXNJZGVudGlmaWVyLFxuICBpc01peGVkVHlwZUFubm90YXRpb24sXG4gIGlzTnVtYmVyVHlwZUFubm90YXRpb24sXG4gIGlzU3RyaW5nVHlwZUFubm90YXRpb24sXG4gIGlzVFNBcnJheVR5cGUsXG4gIGlzVFNUeXBlQW5ub3RhdGlvbixcbiAgaXNUU1R5cGVSZWZlcmVuY2UsXG4gIGlzVHVwbGVUeXBlQW5ub3RhdGlvbixcbiAgaXNUeXBlQW5ub3RhdGlvbixcbiAgaXNVbmlvblR5cGVBbm5vdGF0aW9uLFxuICBpc1ZvaWRUeXBlQW5ub3RhdGlvbixcbiAgc3RyaW5nVHlwZUFubm90YXRpb24sXG4gIHZvaWRUeXBlQW5ub3RhdGlvblxufSA9IF90O1xuZnVuY3Rpb24gZ2V0VHlwZUFubm90YXRpb24oKSB7XG4gIGxldCB0eXBlID0gdGhpcy5nZXREYXRhKFwidHlwZUFubm90YXRpb25cIik7XG4gIGlmICh0eXBlICE9IG51bGwpIHtcbiAgICByZXR1cm4gdHlwZTtcbiAgfVxuICB0eXBlID0gX2dldFR5cGVBbm5vdGF0aW9uLmNhbGwodGhpcykgfHwgYW55VHlwZUFubm90YXRpb24oKTtcbiAgaWYgKGlzVHlwZUFubm90YXRpb24odHlwZSkgfHwgaXNUU1R5cGVBbm5vdGF0aW9uKHR5cGUpKSB7XG4gICAgdHlwZSA9IHR5cGUudHlwZUFubm90YXRpb247XG4gIH1cbiAgdGhpcy5zZXREYXRhKFwidHlwZUFubm90YXRpb25cIiwgdHlwZSk7XG4gIHJldHVybiB0eXBlO1xufVxuY29uc3QgdHlwZUFubm90YXRpb25JbmZlcnJpbmdOb2RlcyA9IG5ldyBXZWFrU2V0KCk7XG5mdW5jdGlvbiBfZ2V0VHlwZUFubm90YXRpb24oKSB7XG4gIGNvbnN0IG5vZGUgPSB0aGlzLm5vZGU7XG4gIGlmICghbm9kZSkge1xuICAgIGlmICh0aGlzLmtleSA9PT0gXCJpbml0XCIgJiYgdGhpcy5wYXJlbnRQYXRoLmlzVmFyaWFibGVEZWNsYXJhdG9yKCkpIHtcbiAgICAgIGNvbnN0IGRlY2xhciA9IHRoaXMucGFyZW50UGF0aC5wYXJlbnRQYXRoO1xuICAgICAgY29uc3QgZGVjbGFyUGFyZW50ID0gZGVjbGFyLnBhcmVudFBhdGg7XG4gICAgICBpZiAoZGVjbGFyLmtleSA9PT0gXCJsZWZ0XCIgJiYgZGVjbGFyUGFyZW50LmlzRm9ySW5TdGF0ZW1lbnQoKSkge1xuICAgICAgICByZXR1cm4gc3RyaW5nVHlwZUFubm90YXRpb24oKTtcbiAgICAgIH1cbiAgICAgIGlmIChkZWNsYXIua2V5ID09PSBcImxlZnRcIiAmJiBkZWNsYXJQYXJlbnQuaXNGb3JPZlN0YXRlbWVudCgpKSB7XG4gICAgICAgIHJldHVybiBhbnlUeXBlQW5ub3RhdGlvbigpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHZvaWRUeXBlQW5ub3RhdGlvbigpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICB9XG4gIGlmIChub2RlLnR5cGVBbm5vdGF0aW9uKSB7XG4gICAgcmV0dXJuIG5vZGUudHlwZUFubm90YXRpb247XG4gIH1cbiAgaWYgKHR5cGVBbm5vdGF0aW9uSW5mZXJyaW5nTm9kZXMuaGFzKG5vZGUpKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIHR5cGVBbm5vdGF0aW9uSW5mZXJyaW5nTm9kZXMuYWRkKG5vZGUpO1xuICB0cnkge1xuICAgIHZhciBfaW5mZXJlcjtcbiAgICBsZXQgaW5mZXJlciA9IGluZmVyZXJzW25vZGUudHlwZV07XG4gICAgaWYgKGluZmVyZXIpIHtcbiAgICAgIHJldHVybiBpbmZlcmVyLmNhbGwodGhpcywgbm9kZSk7XG4gICAgfVxuICAgIGluZmVyZXIgPSBpbmZlcmVyc1t0aGlzLnBhcmVudFBhdGgudHlwZV07XG4gICAgaWYgKChfaW5mZXJlciA9IGluZmVyZXIpICE9IG51bGwgJiYgX2luZmVyZXIudmFsaWRQYXJlbnQpIHtcbiAgICAgIHJldHVybiB0aGlzLnBhcmVudFBhdGguZ2V0VHlwZUFubm90YXRpb24oKTtcbiAgICB9XG4gIH0gZmluYWxseSB7XG4gICAgdHlwZUFubm90YXRpb25JbmZlcnJpbmdOb2Rlcy5kZWxldGUobm9kZSk7XG4gIH1cbn1cbmZ1bmN0aW9uIGlzQmFzZVR5cGUoYmFzZU5hbWUsIHNvZnQpIHtcbiAgcmV0dXJuIF9pc0Jhc2VUeXBlKGJhc2VOYW1lLCB0aGlzLmdldFR5cGVBbm5vdGF0aW9uKCksIHNvZnQpO1xufVxuZnVuY3Rpb24gX2lzQmFzZVR5cGUoYmFzZU5hbWUsIHR5cGUsIHNvZnQpIHtcbiAgaWYgKGJhc2VOYW1lID09PSBcInN0cmluZ1wiKSB7XG4gICAgcmV0dXJuIGlzU3RyaW5nVHlwZUFubm90YXRpb24odHlwZSk7XG4gIH0gZWxzZSBpZiAoYmFzZU5hbWUgPT09IFwibnVtYmVyXCIpIHtcbiAgICByZXR1cm4gaXNOdW1iZXJUeXBlQW5ub3RhdGlvbih0eXBlKTtcbiAgfSBlbHNlIGlmIChiYXNlTmFtZSA9PT0gXCJib29sZWFuXCIpIHtcbiAgICByZXR1cm4gaXNCb29sZWFuVHlwZUFubm90YXRpb24odHlwZSk7XG4gIH0gZWxzZSBpZiAoYmFzZU5hbWUgPT09IFwiYW55XCIpIHtcbiAgICByZXR1cm4gaXNBbnlUeXBlQW5ub3RhdGlvbih0eXBlKTtcbiAgfSBlbHNlIGlmIChiYXNlTmFtZSA9PT0gXCJtaXhlZFwiKSB7XG4gICAgcmV0dXJuIGlzTWl4ZWRUeXBlQW5ub3RhdGlvbih0eXBlKTtcbiAgfSBlbHNlIGlmIChiYXNlTmFtZSA9PT0gXCJlbXB0eVwiKSB7XG4gICAgcmV0dXJuIGlzRW1wdHlUeXBlQW5ub3RhdGlvbih0eXBlKTtcbiAgfSBlbHNlIGlmIChiYXNlTmFtZSA9PT0gXCJ2b2lkXCIpIHtcbiAgICByZXR1cm4gaXNWb2lkVHlwZUFubm90YXRpb24odHlwZSk7XG4gIH0gZWxzZSB7XG4gICAgaWYgKHNvZnQpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBVbmtub3duIGJhc2UgdHlwZSAke2Jhc2VOYW1lfWApO1xuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gY291bGRCZUJhc2VUeXBlKG5hbWUpIHtcbiAgY29uc3QgdHlwZSA9IHRoaXMuZ2V0VHlwZUFubm90YXRpb24oKTtcbiAgaWYgKGlzQW55VHlwZUFubm90YXRpb24odHlwZSkpIHJldHVybiB0cnVlO1xuICBpZiAoaXNVbmlvblR5cGVBbm5vdGF0aW9uKHR5cGUpKSB7XG4gICAgZm9yIChjb25zdCB0eXBlMiBvZiB0eXBlLnR5cGVzKSB7XG4gICAgICBpZiAoaXNBbnlUeXBlQW5ub3RhdGlvbih0eXBlMikgfHwgX2lzQmFzZVR5cGUobmFtZSwgdHlwZTIsIHRydWUpKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIF9pc0Jhc2VUeXBlKG5hbWUsIHR5cGUsIHRydWUpO1xuICB9XG59XG5mdW5jdGlvbiBiYXNlVHlwZVN0cmljdGx5TWF0Y2hlcyhyaWdodEFyZykge1xuICBjb25zdCBsZWZ0ID0gdGhpcy5nZXRUeXBlQW5ub3RhdGlvbigpO1xuICBjb25zdCByaWdodCA9IHJpZ2h0QXJnLmdldFR5cGVBbm5vdGF0aW9uKCk7XG4gIGlmICghaXNBbnlUeXBlQW5ub3RhdGlvbihsZWZ0KSAmJiBpc0Zsb3dCYXNlQW5ub3RhdGlvbihsZWZ0KSkge1xuICAgIHJldHVybiByaWdodC50eXBlID09PSBsZWZ0LnR5cGU7XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufVxuZnVuY3Rpb24gaXNHZW5lcmljVHlwZShnZW5lcmljTmFtZSkge1xuICBjb25zdCB0eXBlID0gdGhpcy5nZXRUeXBlQW5ub3RhdGlvbigpO1xuICBpZiAoZ2VuZXJpY05hbWUgPT09IFwiQXJyYXlcIikge1xuICAgIGlmIChpc1RTQXJyYXlUeXBlKHR5cGUpIHx8IGlzQXJyYXlUeXBlQW5ub3RhdGlvbih0eXBlKSB8fCBpc1R1cGxlVHlwZUFubm90YXRpb24odHlwZSkpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gaXNHZW5lcmljVHlwZUFubm90YXRpb24odHlwZSkgJiYgaXNJZGVudGlmaWVyKHR5cGUuaWQsIHtcbiAgICBuYW1lOiBnZW5lcmljTmFtZVxuICB9KSB8fCBpc1RTVHlwZVJlZmVyZW5jZSh0eXBlKSAmJiBpc0lkZW50aWZpZXIodHlwZS50eXBlTmFtZSwge1xuICAgIG5hbWU6IGdlbmVyaWNOYW1lXG4gIH0pO1xufVxuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXBcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@babel/traverse/lib/path/inference/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@babel/traverse/lib/path/inference/inferer-reference.js":
/*!******************************************************************************!*\
  !*** ./node_modules/@babel/traverse/lib/path/inference/inferer-reference.js ***!
  \******************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports[\"default\"] = _default;\nvar _t = __webpack_require__(/*! @babel/types */ \"(ssr)/./node_modules/@babel/types/lib/index.js\");\nvar _util = __webpack_require__(/*! ./util.js */ \"(ssr)/./node_modules/@babel/traverse/lib/path/inference/util.js\");\nconst {\n  BOOLEAN_NUMBER_BINARY_OPERATORS,\n  createTypeAnnotationBasedOnTypeof,\n  numberTypeAnnotation,\n  voidTypeAnnotation\n} = _t;\nfunction _default(node) {\n  if (!this.isReferenced()) return;\n  const binding = this.scope.getBinding(node.name);\n  if (binding) {\n    if (binding.identifier.typeAnnotation) {\n      return binding.identifier.typeAnnotation;\n    } else {\n      return getTypeAnnotationBindingConstantViolations(binding, this, node.name);\n    }\n  }\n  if (node.name === \"undefined\") {\n    return voidTypeAnnotation();\n  } else if (node.name === \"NaN\" || node.name === \"Infinity\") {\n    return numberTypeAnnotation();\n  } else if (node.name === \"arguments\") {}\n}\nfunction getTypeAnnotationBindingConstantViolations(binding, path, name) {\n  const types = [];\n  const functionConstantViolations = [];\n  let constantViolations = getConstantViolationsBefore(binding, path, functionConstantViolations);\n  const testType = getConditionalAnnotation(binding, path, name);\n  if (testType) {\n    const testConstantViolations = getConstantViolationsBefore(binding, testType.ifStatement);\n    constantViolations = constantViolations.filter(path => !testConstantViolations.includes(path));\n    types.push(testType.typeAnnotation);\n  }\n  if (constantViolations.length) {\n    constantViolations.push(...functionConstantViolations);\n    for (const violation of constantViolations) {\n      types.push(violation.getTypeAnnotation());\n    }\n  }\n  if (!types.length) {\n    return;\n  }\n  return (0, _util.createUnionType)(types);\n}\nfunction getConstantViolationsBefore(binding, path, functions) {\n  const violations = binding.constantViolations.slice();\n  violations.unshift(binding.path);\n  return violations.filter(violation => {\n    violation = violation.resolve();\n    const status = violation._guessExecutionStatusRelativeTo(path);\n    if (functions && status === \"unknown\") functions.push(violation);\n    return status === \"before\";\n  });\n}\nfunction inferAnnotationFromBinaryExpression(name, path) {\n  const operator = path.node.operator;\n  const right = path.get(\"right\").resolve();\n  const left = path.get(\"left\").resolve();\n  let target;\n  if (left.isIdentifier({\n    name\n  })) {\n    target = right;\n  } else if (right.isIdentifier({\n    name\n  })) {\n    target = left;\n  }\n  if (target) {\n    if (operator === \"===\") {\n      return target.getTypeAnnotation();\n    }\n    if (BOOLEAN_NUMBER_BINARY_OPERATORS.includes(operator)) {\n      return numberTypeAnnotation();\n    }\n    return;\n  }\n  if (operator !== \"===\" && operator !== \"==\") return;\n  let typeofPath;\n  let typePath;\n  if (left.isUnaryExpression({\n    operator: \"typeof\"\n  })) {\n    typeofPath = left;\n    typePath = right;\n  } else if (right.isUnaryExpression({\n    operator: \"typeof\"\n  })) {\n    typeofPath = right;\n    typePath = left;\n  }\n  if (!typeofPath) return;\n  if (!typeofPath.get(\"argument\").isIdentifier({\n    name\n  })) return;\n  typePath = typePath.resolve();\n  if (!typePath.isLiteral()) return;\n  const typeValue = typePath.node.value;\n  if (typeof typeValue !== \"string\") return;\n  return createTypeAnnotationBasedOnTypeof(typeValue);\n}\nfunction getParentConditionalPath(binding, path, name) {\n  let parentPath;\n  while (parentPath = path.parentPath) {\n    if (parentPath.isIfStatement() || parentPath.isConditionalExpression()) {\n      if (path.key === \"test\") {\n        return;\n      }\n      return parentPath;\n    }\n    if (parentPath.isFunction()) {\n      if (name == null || parentPath.parentPath.scope.getBinding(name) !== binding) return;\n    }\n    path = parentPath;\n  }\n}\nfunction getConditionalAnnotation(binding, path, name) {\n  const ifStatement = getParentConditionalPath(binding, path, name);\n  if (!ifStatement) return;\n  const test = ifStatement.get(\"test\");\n  const paths = [test];\n  const types = [];\n  for (let i = 0; i < paths.length; i++) {\n    const path = paths[i];\n    if (path.isLogicalExpression()) {\n      if (path.node.operator === \"&&\") {\n        paths.push(path.get(\"left\"));\n        paths.push(path.get(\"right\"));\n      }\n    } else if (path.isBinaryExpression()) {\n      const type = inferAnnotationFromBinaryExpression(name, path);\n      if (type) types.push(type);\n    }\n  }\n  if (types.length) {\n    return {\n      typeAnnotation: (0, _util.createUnionType)(types),\n      ifStatement\n    };\n  }\n  return getConditionalAnnotation(binding, ifStatement, name);\n}\n\n//# sourceMappingURL=inferer-reference.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGJhYmVsL3RyYXZlcnNlL2xpYi9wYXRoL2luZmVyZW5jZS9pbmZlcmVyLXJlZmVyZW5jZS5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYiw4Q0FBNkM7QUFDN0M7QUFDQSxDQUFDLEVBQUM7QUFDRixrQkFBZTtBQUNmLFNBQVMsbUJBQU8sQ0FBQyxvRUFBYztBQUMvQixZQUFZLG1CQUFPLENBQUMsa0ZBQVc7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLElBQUk7QUFDSjtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0Isa0JBQWtCO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9yZXBvLXZpc3VhbGl6ZXIvLi9ub2RlX21vZHVsZXMvQGJhYmVsL3RyYXZlcnNlL2xpYi9wYXRoL2luZmVyZW5jZS9pbmZlcmVyLXJlZmVyZW5jZS5qcz84YjM1Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5kZWZhdWx0ID0gX2RlZmF1bHQ7XG52YXIgX3QgPSByZXF1aXJlKFwiQGJhYmVsL3R5cGVzXCIpO1xudmFyIF91dGlsID0gcmVxdWlyZShcIi4vdXRpbC5qc1wiKTtcbmNvbnN0IHtcbiAgQk9PTEVBTl9OVU1CRVJfQklOQVJZX09QRVJBVE9SUyxcbiAgY3JlYXRlVHlwZUFubm90YXRpb25CYXNlZE9uVHlwZW9mLFxuICBudW1iZXJUeXBlQW5ub3RhdGlvbixcbiAgdm9pZFR5cGVBbm5vdGF0aW9uXG59ID0gX3Q7XG5mdW5jdGlvbiBfZGVmYXVsdChub2RlKSB7XG4gIGlmICghdGhpcy5pc1JlZmVyZW5jZWQoKSkgcmV0dXJuO1xuICBjb25zdCBiaW5kaW5nID0gdGhpcy5zY29wZS5nZXRCaW5kaW5nKG5vZGUubmFtZSk7XG4gIGlmIChiaW5kaW5nKSB7XG4gICAgaWYgKGJpbmRpbmcuaWRlbnRpZmllci50eXBlQW5ub3RhdGlvbikge1xuICAgICAgcmV0dXJuIGJpbmRpbmcuaWRlbnRpZmllci50eXBlQW5ub3RhdGlvbjtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIGdldFR5cGVBbm5vdGF0aW9uQmluZGluZ0NvbnN0YW50VmlvbGF0aW9ucyhiaW5kaW5nLCB0aGlzLCBub2RlLm5hbWUpO1xuICAgIH1cbiAgfVxuICBpZiAobm9kZS5uYW1lID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgcmV0dXJuIHZvaWRUeXBlQW5ub3RhdGlvbigpO1xuICB9IGVsc2UgaWYgKG5vZGUubmFtZSA9PT0gXCJOYU5cIiB8fCBub2RlLm5hbWUgPT09IFwiSW5maW5pdHlcIikge1xuICAgIHJldHVybiBudW1iZXJUeXBlQW5ub3RhdGlvbigpO1xuICB9IGVsc2UgaWYgKG5vZGUubmFtZSA9PT0gXCJhcmd1bWVudHNcIikge31cbn1cbmZ1bmN0aW9uIGdldFR5cGVBbm5vdGF0aW9uQmluZGluZ0NvbnN0YW50VmlvbGF0aW9ucyhiaW5kaW5nLCBwYXRoLCBuYW1lKSB7XG4gIGNvbnN0IHR5cGVzID0gW107XG4gIGNvbnN0IGZ1bmN0aW9uQ29uc3RhbnRWaW9sYXRpb25zID0gW107XG4gIGxldCBjb25zdGFudFZpb2xhdGlvbnMgPSBnZXRDb25zdGFudFZpb2xhdGlvbnNCZWZvcmUoYmluZGluZywgcGF0aCwgZnVuY3Rpb25Db25zdGFudFZpb2xhdGlvbnMpO1xuICBjb25zdCB0ZXN0VHlwZSA9IGdldENvbmRpdGlvbmFsQW5ub3RhdGlvbihiaW5kaW5nLCBwYXRoLCBuYW1lKTtcbiAgaWYgKHRlc3RUeXBlKSB7XG4gICAgY29uc3QgdGVzdENvbnN0YW50VmlvbGF0aW9ucyA9IGdldENvbnN0YW50VmlvbGF0aW9uc0JlZm9yZShiaW5kaW5nLCB0ZXN0VHlwZS5pZlN0YXRlbWVudCk7XG4gICAgY29uc3RhbnRWaW9sYXRpb25zID0gY29uc3RhbnRWaW9sYXRpb25zLmZpbHRlcihwYXRoID0+ICF0ZXN0Q29uc3RhbnRWaW9sYXRpb25zLmluY2x1ZGVzKHBhdGgpKTtcbiAgICB0eXBlcy5wdXNoKHRlc3RUeXBlLnR5cGVBbm5vdGF0aW9uKTtcbiAgfVxuICBpZiAoY29uc3RhbnRWaW9sYXRpb25zLmxlbmd0aCkge1xuICAgIGNvbnN0YW50VmlvbGF0aW9ucy5wdXNoKC4uLmZ1bmN0aW9uQ29uc3RhbnRWaW9sYXRpb25zKTtcbiAgICBmb3IgKGNvbnN0IHZpb2xhdGlvbiBvZiBjb25zdGFudFZpb2xhdGlvbnMpIHtcbiAgICAgIHR5cGVzLnB1c2godmlvbGF0aW9uLmdldFR5cGVBbm5vdGF0aW9uKCkpO1xuICAgIH1cbiAgfVxuICBpZiAoIXR5cGVzLmxlbmd0aCkge1xuICAgIHJldHVybjtcbiAgfVxuICByZXR1cm4gKDAsIF91dGlsLmNyZWF0ZVVuaW9uVHlwZSkodHlwZXMpO1xufVxuZnVuY3Rpb24gZ2V0Q29uc3RhbnRWaW9sYXRpb25zQmVmb3JlKGJpbmRpbmcsIHBhdGgsIGZ1bmN0aW9ucykge1xuICBjb25zdCB2aW9sYXRpb25zID0gYmluZGluZy5jb25zdGFudFZpb2xhdGlvbnMuc2xpY2UoKTtcbiAgdmlvbGF0aW9ucy51bnNoaWZ0KGJpbmRpbmcucGF0aCk7XG4gIHJldHVybiB2aW9sYXRpb25zLmZpbHRlcih2aW9sYXRpb24gPT4ge1xuICAgIHZpb2xhdGlvbiA9IHZpb2xhdGlvbi5yZXNvbHZlKCk7XG4gICAgY29uc3Qgc3RhdHVzID0gdmlvbGF0aW9uLl9ndWVzc0V4ZWN1dGlvblN0YXR1c1JlbGF0aXZlVG8ocGF0aCk7XG4gICAgaWYgKGZ1bmN0aW9ucyAmJiBzdGF0dXMgPT09IFwidW5rbm93blwiKSBmdW5jdGlvbnMucHVzaCh2aW9sYXRpb24pO1xuICAgIHJldHVybiBzdGF0dXMgPT09IFwiYmVmb3JlXCI7XG4gIH0pO1xufVxuZnVuY3Rpb24gaW5mZXJBbm5vdGF0aW9uRnJvbUJpbmFyeUV4cHJlc3Npb24obmFtZSwgcGF0aCkge1xuICBjb25zdCBvcGVyYXRvciA9IHBhdGgubm9kZS5vcGVyYXRvcjtcbiAgY29uc3QgcmlnaHQgPSBwYXRoLmdldChcInJpZ2h0XCIpLnJlc29sdmUoKTtcbiAgY29uc3QgbGVmdCA9IHBhdGguZ2V0KFwibGVmdFwiKS5yZXNvbHZlKCk7XG4gIGxldCB0YXJnZXQ7XG4gIGlmIChsZWZ0LmlzSWRlbnRpZmllcih7XG4gICAgbmFtZVxuICB9KSkge1xuICAgIHRhcmdldCA9IHJpZ2h0O1xuICB9IGVsc2UgaWYgKHJpZ2h0LmlzSWRlbnRpZmllcih7XG4gICAgbmFtZVxuICB9KSkge1xuICAgIHRhcmdldCA9IGxlZnQ7XG4gIH1cbiAgaWYgKHRhcmdldCkge1xuICAgIGlmIChvcGVyYXRvciA9PT0gXCI9PT1cIikge1xuICAgICAgcmV0dXJuIHRhcmdldC5nZXRUeXBlQW5ub3RhdGlvbigpO1xuICAgIH1cbiAgICBpZiAoQk9PTEVBTl9OVU1CRVJfQklOQVJZX09QRVJBVE9SUy5pbmNsdWRlcyhvcGVyYXRvcikpIHtcbiAgICAgIHJldHVybiBudW1iZXJUeXBlQW5ub3RhdGlvbigpO1xuICAgIH1cbiAgICByZXR1cm47XG4gIH1cbiAgaWYgKG9wZXJhdG9yICE9PSBcIj09PVwiICYmIG9wZXJhdG9yICE9PSBcIj09XCIpIHJldHVybjtcbiAgbGV0IHR5cGVvZlBhdGg7XG4gIGxldCB0eXBlUGF0aDtcbiAgaWYgKGxlZnQuaXNVbmFyeUV4cHJlc3Npb24oe1xuICAgIG9wZXJhdG9yOiBcInR5cGVvZlwiXG4gIH0pKSB7XG4gICAgdHlwZW9mUGF0aCA9IGxlZnQ7XG4gICAgdHlwZVBhdGggPSByaWdodDtcbiAgfSBlbHNlIGlmIChyaWdodC5pc1VuYXJ5RXhwcmVzc2lvbih7XG4gICAgb3BlcmF0b3I6IFwidHlwZW9mXCJcbiAgfSkpIHtcbiAgICB0eXBlb2ZQYXRoID0gcmlnaHQ7XG4gICAgdHlwZVBhdGggPSBsZWZ0O1xuICB9XG4gIGlmICghdHlwZW9mUGF0aCkgcmV0dXJuO1xuICBpZiAoIXR5cGVvZlBhdGguZ2V0KFwiYXJndW1lbnRcIikuaXNJZGVudGlmaWVyKHtcbiAgICBuYW1lXG4gIH0pKSByZXR1cm47XG4gIHR5cGVQYXRoID0gdHlwZVBhdGgucmVzb2x2ZSgpO1xuICBpZiAoIXR5cGVQYXRoLmlzTGl0ZXJhbCgpKSByZXR1cm47XG4gIGNvbnN0IHR5cGVWYWx1ZSA9IHR5cGVQYXRoLm5vZGUudmFsdWU7XG4gIGlmICh0eXBlb2YgdHlwZVZhbHVlICE9PSBcInN0cmluZ1wiKSByZXR1cm47XG4gIHJldHVybiBjcmVhdGVUeXBlQW5ub3RhdGlvbkJhc2VkT25UeXBlb2YodHlwZVZhbHVlKTtcbn1cbmZ1bmN0aW9uIGdldFBhcmVudENvbmRpdGlvbmFsUGF0aChiaW5kaW5nLCBwYXRoLCBuYW1lKSB7XG4gIGxldCBwYXJlbnRQYXRoO1xuICB3aGlsZSAocGFyZW50UGF0aCA9IHBhdGgucGFyZW50UGF0aCkge1xuICAgIGlmIChwYXJlbnRQYXRoLmlzSWZTdGF0ZW1lbnQoKSB8fCBwYXJlbnRQYXRoLmlzQ29uZGl0aW9uYWxFeHByZXNzaW9uKCkpIHtcbiAgICAgIGlmIChwYXRoLmtleSA9PT0gXCJ0ZXN0XCIpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHBhcmVudFBhdGg7XG4gICAgfVxuICAgIGlmIChwYXJlbnRQYXRoLmlzRnVuY3Rpb24oKSkge1xuICAgICAgaWYgKG5hbWUgPT0gbnVsbCB8fCBwYXJlbnRQYXRoLnBhcmVudFBhdGguc2NvcGUuZ2V0QmluZGluZyhuYW1lKSAhPT0gYmluZGluZykgcmV0dXJuO1xuICAgIH1cbiAgICBwYXRoID0gcGFyZW50UGF0aDtcbiAgfVxufVxuZnVuY3Rpb24gZ2V0Q29uZGl0aW9uYWxBbm5vdGF0aW9uKGJpbmRpbmcsIHBhdGgsIG5hbWUpIHtcbiAgY29uc3QgaWZTdGF0ZW1lbnQgPSBnZXRQYXJlbnRDb25kaXRpb25hbFBhdGgoYmluZGluZywgcGF0aCwgbmFtZSk7XG4gIGlmICghaWZTdGF0ZW1lbnQpIHJldHVybjtcbiAgY29uc3QgdGVzdCA9IGlmU3RhdGVtZW50LmdldChcInRlc3RcIik7XG4gIGNvbnN0IHBhdGhzID0gW3Rlc3RdO1xuICBjb25zdCB0eXBlcyA9IFtdO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IHBhdGhzLmxlbmd0aDsgaSsrKSB7XG4gICAgY29uc3QgcGF0aCA9IHBhdGhzW2ldO1xuICAgIGlmIChwYXRoLmlzTG9naWNhbEV4cHJlc3Npb24oKSkge1xuICAgICAgaWYgKHBhdGgubm9kZS5vcGVyYXRvciA9PT0gXCImJlwiKSB7XG4gICAgICAgIHBhdGhzLnB1c2gocGF0aC5nZXQoXCJsZWZ0XCIpKTtcbiAgICAgICAgcGF0aHMucHVzaChwYXRoLmdldChcInJpZ2h0XCIpKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHBhdGguaXNCaW5hcnlFeHByZXNzaW9uKCkpIHtcbiAgICAgIGNvbnN0IHR5cGUgPSBpbmZlckFubm90YXRpb25Gcm9tQmluYXJ5RXhwcmVzc2lvbihuYW1lLCBwYXRoKTtcbiAgICAgIGlmICh0eXBlKSB0eXBlcy5wdXNoKHR5cGUpO1xuICAgIH1cbiAgfVxuICBpZiAodHlwZXMubGVuZ3RoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGVBbm5vdGF0aW9uOiAoMCwgX3V0aWwuY3JlYXRlVW5pb25UeXBlKSh0eXBlcyksXG4gICAgICBpZlN0YXRlbWVudFxuICAgIH07XG4gIH1cbiAgcmV0dXJuIGdldENvbmRpdGlvbmFsQW5ub3RhdGlvbihiaW5kaW5nLCBpZlN0YXRlbWVudCwgbmFtZSk7XG59XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZmVyZXItcmVmZXJlbmNlLmpzLm1hcFxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@babel/traverse/lib/path/inference/inferer-reference.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@babel/traverse/lib/path/inference/inferers.js":
/*!*********************************************************************!*\
  !*** ./node_modules/@babel/traverse/lib/path/inference/inferers.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports.ArrayExpression = ArrayExpression;\nexports.AssignmentExpression = AssignmentExpression;\nexports.BinaryExpression = BinaryExpression;\nexports.BooleanLiteral = BooleanLiteral;\nexports.CallExpression = CallExpression;\nexports.ConditionalExpression = ConditionalExpression;\nexports.ClassDeclaration = exports.ClassExpression = exports.FunctionDeclaration = exports.ArrowFunctionExpression = exports.FunctionExpression = Func;\nObject.defineProperty(exports, \"Identifier\", ({\n  enumerable: true,\n  get: function () {\n    return _infererReference.default;\n  }\n}));\nexports.LogicalExpression = LogicalExpression;\nexports.NewExpression = NewExpression;\nexports.NullLiteral = NullLiteral;\nexports.NumericLiteral = NumericLiteral;\nexports.ObjectExpression = ObjectExpression;\nexports.ParenthesizedExpression = ParenthesizedExpression;\nexports.RegExpLiteral = RegExpLiteral;\nexports.RestElement = RestElement;\nexports.SequenceExpression = SequenceExpression;\nexports.StringLiteral = StringLiteral;\nexports.TSAsExpression = TSAsExpression;\nexports.TSNonNullExpression = TSNonNullExpression;\nexports.TaggedTemplateExpression = TaggedTemplateExpression;\nexports.TemplateLiteral = TemplateLiteral;\nexports.TypeCastExpression = TypeCastExpression;\nexports.UnaryExpression = UnaryExpression;\nexports.UpdateExpression = UpdateExpression;\nexports.VariableDeclarator = VariableDeclarator;\nvar _t = __webpack_require__(/*! @babel/types */ \"(ssr)/./node_modules/@babel/types/lib/index.js\");\nvar _infererReference = __webpack_require__(/*! ./inferer-reference.js */ \"(ssr)/./node_modules/@babel/traverse/lib/path/inference/inferer-reference.js\");\nvar _util = __webpack_require__(/*! ./util.js */ \"(ssr)/./node_modules/@babel/traverse/lib/path/inference/util.js\");\nconst {\n  BOOLEAN_BINARY_OPERATORS,\n  BOOLEAN_UNARY_OPERATORS,\n  NUMBER_BINARY_OPERATORS,\n  NUMBER_UNARY_OPERATORS,\n  STRING_UNARY_OPERATORS,\n  anyTypeAnnotation,\n  arrayTypeAnnotation,\n  booleanTypeAnnotation,\n  buildMatchMemberExpression,\n  genericTypeAnnotation,\n  identifier,\n  nullLiteralTypeAnnotation,\n  numberTypeAnnotation,\n  stringTypeAnnotation,\n  tupleTypeAnnotation,\n  unionTypeAnnotation,\n  voidTypeAnnotation,\n  isIdentifier\n} = _t;\nfunction VariableDeclarator() {\n  if (!this.get(\"id\").isIdentifier()) return;\n  return this.get(\"init\").getTypeAnnotation();\n}\nfunction TypeCastExpression(node) {\n  return node.typeAnnotation;\n}\nTypeCastExpression.validParent = true;\nfunction TSAsExpression(node) {\n  return node.typeAnnotation;\n}\nTSAsExpression.validParent = true;\nfunction TSNonNullExpression() {\n  return this.get(\"expression\").getTypeAnnotation();\n}\nfunction NewExpression(node) {\n  if (node.callee.type === \"Identifier\") {\n    return genericTypeAnnotation(node.callee);\n  }\n}\nfunction TemplateLiteral() {\n  return stringTypeAnnotation();\n}\nfunction UnaryExpression(node) {\n  const operator = node.operator;\n  if (operator === \"void\") {\n    return voidTypeAnnotation();\n  } else if (NUMBER_UNARY_OPERATORS.includes(operator)) {\n    return numberTypeAnnotation();\n  } else if (STRING_UNARY_OPERATORS.includes(operator)) {\n    return stringTypeAnnotation();\n  } else if (BOOLEAN_UNARY_OPERATORS.includes(operator)) {\n    return booleanTypeAnnotation();\n  }\n}\nfunction BinaryExpression(node) {\n  const operator = node.operator;\n  if (NUMBER_BINARY_OPERATORS.includes(operator)) {\n    return numberTypeAnnotation();\n  } else if (BOOLEAN_BINARY_OPERATORS.includes(operator)) {\n    return booleanTypeAnnotation();\n  } else if (operator === \"+\") {\n    const right = this.get(\"right\");\n    const left = this.get(\"left\");\n    if (left.isBaseType(\"number\") && right.isBaseType(\"number\")) {\n      return numberTypeAnnotation();\n    } else if (left.isBaseType(\"string\") || right.isBaseType(\"string\")) {\n      return stringTypeAnnotation();\n    }\n    return unionTypeAnnotation([stringTypeAnnotation(), numberTypeAnnotation()]);\n  }\n}\nfunction LogicalExpression() {\n  const argumentTypes = [this.get(\"left\").getTypeAnnotation(), this.get(\"right\").getTypeAnnotation()];\n  return (0, _util.createUnionType)(argumentTypes);\n}\nfunction ConditionalExpression() {\n  const argumentTypes = [this.get(\"consequent\").getTypeAnnotation(), this.get(\"alternate\").getTypeAnnotation()];\n  return (0, _util.createUnionType)(argumentTypes);\n}\nfunction SequenceExpression() {\n  return this.get(\"expressions\").pop().getTypeAnnotation();\n}\nfunction ParenthesizedExpression() {\n  return this.get(\"expression\").getTypeAnnotation();\n}\nfunction AssignmentExpression() {\n  return this.get(\"right\").getTypeAnnotation();\n}\nfunction UpdateExpression(node) {\n  const operator = node.operator;\n  if (operator === \"++\" || operator === \"--\") {\n    return numberTypeAnnotation();\n  }\n}\nfunction StringLiteral() {\n  return stringTypeAnnotation();\n}\nfunction NumericLiteral() {\n  return numberTypeAnnotation();\n}\nfunction BooleanLiteral() {\n  return booleanTypeAnnotation();\n}\nfunction NullLiteral() {\n  return nullLiteralTypeAnnotation();\n}\nfunction RegExpLiteral() {\n  return genericTypeAnnotation(identifier(\"RegExp\"));\n}\nfunction ObjectExpression() {\n  return genericTypeAnnotation(identifier(\"Object\"));\n}\nfunction ArrayExpression() {\n  return genericTypeAnnotation(identifier(\"Array\"));\n}\nfunction RestElement() {\n  return ArrayExpression();\n}\nRestElement.validParent = true;\nfunction Func() {\n  return genericTypeAnnotation(identifier(\"Function\"));\n}\nconst isArrayFrom = buildMatchMemberExpression(\"Array.from\");\nconst isObjectKeys = buildMatchMemberExpression(\"Object.keys\");\nconst isObjectValues = buildMatchMemberExpression(\"Object.values\");\nconst isObjectEntries = buildMatchMemberExpression(\"Object.entries\");\nfunction CallExpression() {\n  const {\n    callee\n  } = this.node;\n  if (isObjectKeys(callee)) {\n    return arrayTypeAnnotation(stringTypeAnnotation());\n  } else if (isArrayFrom(callee) || isObjectValues(callee) || isIdentifier(callee, {\n    name: \"Array\"\n  })) {\n    return arrayTypeAnnotation(anyTypeAnnotation());\n  } else if (isObjectEntries(callee)) {\n    return arrayTypeAnnotation(tupleTypeAnnotation([stringTypeAnnotation(), anyTypeAnnotation()]));\n  }\n  return resolveCall(this.get(\"callee\"));\n}\nfunction TaggedTemplateExpression() {\n  return resolveCall(this.get(\"tag\"));\n}\nfunction resolveCall(callee) {\n  callee = callee.resolve();\n  if (callee.isFunction()) {\n    const {\n      node\n    } = callee;\n    if (node.async) {\n      if (node.generator) {\n        return genericTypeAnnotation(identifier(\"AsyncIterator\"));\n      } else {\n        return genericTypeAnnotation(identifier(\"Promise\"));\n      }\n    } else {\n      if (node.generator) {\n        return genericTypeAnnotation(identifier(\"Iterator\"));\n      } else if (callee.node.returnType) {\n        return callee.node.returnType;\n      } else {}\n    }\n  }\n}\n\n//# sourceMappingURL=inferers.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGJhYmVsL3RyYXZlcnNlL2xpYi9wYXRoL2luZmVyZW5jZS9pbmZlcmVycy5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYiw4Q0FBNkM7QUFDN0M7QUFDQSxDQUFDLEVBQUM7QUFDRix1QkFBdUI7QUFDdkIsNEJBQTRCO0FBQzVCLHdCQUF3QjtBQUN4QixzQkFBc0I7QUFDdEIsc0JBQXNCO0FBQ3RCLDZCQUE2QjtBQUM3Qix3QkFBd0IsR0FBRyx1QkFBdUIsR0FBRywyQkFBMkIsR0FBRywrQkFBK0IsR0FBRywwQkFBMEI7QUFDL0ksOENBQTZDO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxFQUFDO0FBQ0YseUJBQXlCO0FBQ3pCLHFCQUFxQjtBQUNyQixtQkFBbUI7QUFDbkIsc0JBQXNCO0FBQ3RCLHdCQUF3QjtBQUN4QiwrQkFBK0I7QUFDL0IscUJBQXFCO0FBQ3JCLG1CQUFtQjtBQUNuQiwwQkFBMEI7QUFDMUIscUJBQXFCO0FBQ3JCLHNCQUFzQjtBQUN0QiwyQkFBMkI7QUFDM0IsZ0NBQWdDO0FBQ2hDLHVCQUF1QjtBQUN2QiwwQkFBMEI7QUFDMUIsdUJBQXVCO0FBQ3ZCLHdCQUF3QjtBQUN4QiwwQkFBMEI7QUFDMUIsU0FBUyxtQkFBTyxDQUFDLG9FQUFjO0FBQy9CLHdCQUF3QixtQkFBTyxDQUFDLDRHQUF3QjtBQUN4RCxZQUFZLG1CQUFPLENBQUMsa0ZBQVc7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsR0FBRztBQUNIO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTs7QUFFQSIsInNvdXJjZXMiOlsid2VicGFjazovL3JlcG8tdmlzdWFsaXplci8uL25vZGVfbW9kdWxlcy9AYmFiZWwvdHJhdmVyc2UvbGliL3BhdGgvaW5mZXJlbmNlL2luZmVyZXJzLmpzPzI5YzQiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLkFycmF5RXhwcmVzc2lvbiA9IEFycmF5RXhwcmVzc2lvbjtcbmV4cG9ydHMuQXNzaWdubWVudEV4cHJlc3Npb24gPSBBc3NpZ25tZW50RXhwcmVzc2lvbjtcbmV4cG9ydHMuQmluYXJ5RXhwcmVzc2lvbiA9IEJpbmFyeUV4cHJlc3Npb247XG5leHBvcnRzLkJvb2xlYW5MaXRlcmFsID0gQm9vbGVhbkxpdGVyYWw7XG5leHBvcnRzLkNhbGxFeHByZXNzaW9uID0gQ2FsbEV4cHJlc3Npb247XG5leHBvcnRzLkNvbmRpdGlvbmFsRXhwcmVzc2lvbiA9IENvbmRpdGlvbmFsRXhwcmVzc2lvbjtcbmV4cG9ydHMuQ2xhc3NEZWNsYXJhdGlvbiA9IGV4cG9ydHMuQ2xhc3NFeHByZXNzaW9uID0gZXhwb3J0cy5GdW5jdGlvbkRlY2xhcmF0aW9uID0gZXhwb3J0cy5BcnJvd0Z1bmN0aW9uRXhwcmVzc2lvbiA9IGV4cG9ydHMuRnVuY3Rpb25FeHByZXNzaW9uID0gRnVuYztcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIklkZW50aWZpZXJcIiwge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gX2luZmVyZXJSZWZlcmVuY2UuZGVmYXVsdDtcbiAgfVxufSk7XG5leHBvcnRzLkxvZ2ljYWxFeHByZXNzaW9uID0gTG9naWNhbEV4cHJlc3Npb247XG5leHBvcnRzLk5ld0V4cHJlc3Npb24gPSBOZXdFeHByZXNzaW9uO1xuZXhwb3J0cy5OdWxsTGl0ZXJhbCA9IE51bGxMaXRlcmFsO1xuZXhwb3J0cy5OdW1lcmljTGl0ZXJhbCA9IE51bWVyaWNMaXRlcmFsO1xuZXhwb3J0cy5PYmplY3RFeHByZXNzaW9uID0gT2JqZWN0RXhwcmVzc2lvbjtcbmV4cG9ydHMuUGFyZW50aGVzaXplZEV4cHJlc3Npb24gPSBQYXJlbnRoZXNpemVkRXhwcmVzc2lvbjtcbmV4cG9ydHMuUmVnRXhwTGl0ZXJhbCA9IFJlZ0V4cExpdGVyYWw7XG5leHBvcnRzLlJlc3RFbGVtZW50ID0gUmVzdEVsZW1lbnQ7XG5leHBvcnRzLlNlcXVlbmNlRXhwcmVzc2lvbiA9IFNlcXVlbmNlRXhwcmVzc2lvbjtcbmV4cG9ydHMuU3RyaW5nTGl0ZXJhbCA9IFN0cmluZ0xpdGVyYWw7XG5leHBvcnRzLlRTQXNFeHByZXNzaW9uID0gVFNBc0V4cHJlc3Npb247XG5leHBvcnRzLlRTTm9uTnVsbEV4cHJlc3Npb24gPSBUU05vbk51bGxFeHByZXNzaW9uO1xuZXhwb3J0cy5UYWdnZWRUZW1wbGF0ZUV4cHJlc3Npb24gPSBUYWdnZWRUZW1wbGF0ZUV4cHJlc3Npb247XG5leHBvcnRzLlRlbXBsYXRlTGl0ZXJhbCA9IFRlbXBsYXRlTGl0ZXJhbDtcbmV4cG9ydHMuVHlwZUNhc3RFeHByZXNzaW9uID0gVHlwZUNhc3RFeHByZXNzaW9uO1xuZXhwb3J0cy5VbmFyeUV4cHJlc3Npb24gPSBVbmFyeUV4cHJlc3Npb247XG5leHBvcnRzLlVwZGF0ZUV4cHJlc3Npb24gPSBVcGRhdGVFeHByZXNzaW9uO1xuZXhwb3J0cy5WYXJpYWJsZURlY2xhcmF0b3IgPSBWYXJpYWJsZURlY2xhcmF0b3I7XG52YXIgX3QgPSByZXF1aXJlKFwiQGJhYmVsL3R5cGVzXCIpO1xudmFyIF9pbmZlcmVyUmVmZXJlbmNlID0gcmVxdWlyZShcIi4vaW5mZXJlci1yZWZlcmVuY2UuanNcIik7XG52YXIgX3V0aWwgPSByZXF1aXJlKFwiLi91dGlsLmpzXCIpO1xuY29uc3Qge1xuICBCT09MRUFOX0JJTkFSWV9PUEVSQVRPUlMsXG4gIEJPT0xFQU5fVU5BUllfT1BFUkFUT1JTLFxuICBOVU1CRVJfQklOQVJZX09QRVJBVE9SUyxcbiAgTlVNQkVSX1VOQVJZX09QRVJBVE9SUyxcbiAgU1RSSU5HX1VOQVJZX09QRVJBVE9SUyxcbiAgYW55VHlwZUFubm90YXRpb24sXG4gIGFycmF5VHlwZUFubm90YXRpb24sXG4gIGJvb2xlYW5UeXBlQW5ub3RhdGlvbixcbiAgYnVpbGRNYXRjaE1lbWJlckV4cHJlc3Npb24sXG4gIGdlbmVyaWNUeXBlQW5ub3RhdGlvbixcbiAgaWRlbnRpZmllcixcbiAgbnVsbExpdGVyYWxUeXBlQW5ub3RhdGlvbixcbiAgbnVtYmVyVHlwZUFubm90YXRpb24sXG4gIHN0cmluZ1R5cGVBbm5vdGF0aW9uLFxuICB0dXBsZVR5cGVBbm5vdGF0aW9uLFxuICB1bmlvblR5cGVBbm5vdGF0aW9uLFxuICB2b2lkVHlwZUFubm90YXRpb24sXG4gIGlzSWRlbnRpZmllclxufSA9IF90O1xuZnVuY3Rpb24gVmFyaWFibGVEZWNsYXJhdG9yKCkge1xuICBpZiAoIXRoaXMuZ2V0KFwiaWRcIikuaXNJZGVudGlmaWVyKCkpIHJldHVybjtcbiAgcmV0dXJuIHRoaXMuZ2V0KFwiaW5pdFwiKS5nZXRUeXBlQW5ub3RhdGlvbigpO1xufVxuZnVuY3Rpb24gVHlwZUNhc3RFeHByZXNzaW9uKG5vZGUpIHtcbiAgcmV0dXJuIG5vZGUudHlwZUFubm90YXRpb247XG59XG5UeXBlQ2FzdEV4cHJlc3Npb24udmFsaWRQYXJlbnQgPSB0cnVlO1xuZnVuY3Rpb24gVFNBc0V4cHJlc3Npb24obm9kZSkge1xuICByZXR1cm4gbm9kZS50eXBlQW5ub3RhdGlvbjtcbn1cblRTQXNFeHByZXNzaW9uLnZhbGlkUGFyZW50ID0gdHJ1ZTtcbmZ1bmN0aW9uIFRTTm9uTnVsbEV4cHJlc3Npb24oKSB7XG4gIHJldHVybiB0aGlzLmdldChcImV4cHJlc3Npb25cIikuZ2V0VHlwZUFubm90YXRpb24oKTtcbn1cbmZ1bmN0aW9uIE5ld0V4cHJlc3Npb24obm9kZSkge1xuICBpZiAobm9kZS5jYWxsZWUudHlwZSA9PT0gXCJJZGVudGlmaWVyXCIpIHtcbiAgICByZXR1cm4gZ2VuZXJpY1R5cGVBbm5vdGF0aW9uKG5vZGUuY2FsbGVlKTtcbiAgfVxufVxuZnVuY3Rpb24gVGVtcGxhdGVMaXRlcmFsKCkge1xuICByZXR1cm4gc3RyaW5nVHlwZUFubm90YXRpb24oKTtcbn1cbmZ1bmN0aW9uIFVuYXJ5RXhwcmVzc2lvbihub2RlKSB7XG4gIGNvbnN0IG9wZXJhdG9yID0gbm9kZS5vcGVyYXRvcjtcbiAgaWYgKG9wZXJhdG9yID09PSBcInZvaWRcIikge1xuICAgIHJldHVybiB2b2lkVHlwZUFubm90YXRpb24oKTtcbiAgfSBlbHNlIGlmIChOVU1CRVJfVU5BUllfT1BFUkFUT1JTLmluY2x1ZGVzKG9wZXJhdG9yKSkge1xuICAgIHJldHVybiBudW1iZXJUeXBlQW5ub3RhdGlvbigpO1xuICB9IGVsc2UgaWYgKFNUUklOR19VTkFSWV9PUEVSQVRPUlMuaW5jbHVkZXMob3BlcmF0b3IpKSB7XG4gICAgcmV0dXJuIHN0cmluZ1R5cGVBbm5vdGF0aW9uKCk7XG4gIH0gZWxzZSBpZiAoQk9PTEVBTl9VTkFSWV9PUEVSQVRPUlMuaW5jbHVkZXMob3BlcmF0b3IpKSB7XG4gICAgcmV0dXJuIGJvb2xlYW5UeXBlQW5ub3RhdGlvbigpO1xuICB9XG59XG5mdW5jdGlvbiBCaW5hcnlFeHByZXNzaW9uKG5vZGUpIHtcbiAgY29uc3Qgb3BlcmF0b3IgPSBub2RlLm9wZXJhdG9yO1xuICBpZiAoTlVNQkVSX0JJTkFSWV9PUEVSQVRPUlMuaW5jbHVkZXMob3BlcmF0b3IpKSB7XG4gICAgcmV0dXJuIG51bWJlclR5cGVBbm5vdGF0aW9uKCk7XG4gIH0gZWxzZSBpZiAoQk9PTEVBTl9CSU5BUllfT1BFUkFUT1JTLmluY2x1ZGVzKG9wZXJhdG9yKSkge1xuICAgIHJldHVybiBib29sZWFuVHlwZUFubm90YXRpb24oKTtcbiAgfSBlbHNlIGlmIChvcGVyYXRvciA9PT0gXCIrXCIpIHtcbiAgICBjb25zdCByaWdodCA9IHRoaXMuZ2V0KFwicmlnaHRcIik7XG4gICAgY29uc3QgbGVmdCA9IHRoaXMuZ2V0KFwibGVmdFwiKTtcbiAgICBpZiAobGVmdC5pc0Jhc2VUeXBlKFwibnVtYmVyXCIpICYmIHJpZ2h0LmlzQmFzZVR5cGUoXCJudW1iZXJcIikpIHtcbiAgICAgIHJldHVybiBudW1iZXJUeXBlQW5ub3RhdGlvbigpO1xuICAgIH0gZWxzZSBpZiAobGVmdC5pc0Jhc2VUeXBlKFwic3RyaW5nXCIpIHx8IHJpZ2h0LmlzQmFzZVR5cGUoXCJzdHJpbmdcIikpIHtcbiAgICAgIHJldHVybiBzdHJpbmdUeXBlQW5ub3RhdGlvbigpO1xuICAgIH1cbiAgICByZXR1cm4gdW5pb25UeXBlQW5ub3RhdGlvbihbc3RyaW5nVHlwZUFubm90YXRpb24oKSwgbnVtYmVyVHlwZUFubm90YXRpb24oKV0pO1xuICB9XG59XG5mdW5jdGlvbiBMb2dpY2FsRXhwcmVzc2lvbigpIHtcbiAgY29uc3QgYXJndW1lbnRUeXBlcyA9IFt0aGlzLmdldChcImxlZnRcIikuZ2V0VHlwZUFubm90YXRpb24oKSwgdGhpcy5nZXQoXCJyaWdodFwiKS5nZXRUeXBlQW5ub3RhdGlvbigpXTtcbiAgcmV0dXJuICgwLCBfdXRpbC5jcmVhdGVVbmlvblR5cGUpKGFyZ3VtZW50VHlwZXMpO1xufVxuZnVuY3Rpb24gQ29uZGl0aW9uYWxFeHByZXNzaW9uKCkge1xuICBjb25zdCBhcmd1bWVudFR5cGVzID0gW3RoaXMuZ2V0KFwiY29uc2VxdWVudFwiKS5nZXRUeXBlQW5ub3RhdGlvbigpLCB0aGlzLmdldChcImFsdGVybmF0ZVwiKS5nZXRUeXBlQW5ub3RhdGlvbigpXTtcbiAgcmV0dXJuICgwLCBfdXRpbC5jcmVhdGVVbmlvblR5cGUpKGFyZ3VtZW50VHlwZXMpO1xufVxuZnVuY3Rpb24gU2VxdWVuY2VFeHByZXNzaW9uKCkge1xuICByZXR1cm4gdGhpcy5nZXQoXCJleHByZXNzaW9uc1wiKS5wb3AoKS5nZXRUeXBlQW5ub3RhdGlvbigpO1xufVxuZnVuY3Rpb24gUGFyZW50aGVzaXplZEV4cHJlc3Npb24oKSB7XG4gIHJldHVybiB0aGlzLmdldChcImV4cHJlc3Npb25cIikuZ2V0VHlwZUFubm90YXRpb24oKTtcbn1cbmZ1bmN0aW9uIEFzc2lnbm1lbnRFeHByZXNzaW9uKCkge1xuICByZXR1cm4gdGhpcy5nZXQoXCJyaWdodFwiKS5nZXRUeXBlQW5ub3RhdGlvbigpO1xufVxuZnVuY3Rpb24gVXBkYXRlRXhwcmVzc2lvbihub2RlKSB7XG4gIGNvbnN0IG9wZXJhdG9yID0gbm9kZS5vcGVyYXRvcjtcbiAgaWYgKG9wZXJhdG9yID09PSBcIisrXCIgfHwgb3BlcmF0b3IgPT09IFwiLS1cIikge1xuICAgIHJldHVybiBudW1iZXJUeXBlQW5ub3RhdGlvbigpO1xuICB9XG59XG5mdW5jdGlvbiBTdHJpbmdMaXRlcmFsKCkge1xuICByZXR1cm4gc3RyaW5nVHlwZUFubm90YXRpb24oKTtcbn1cbmZ1bmN0aW9uIE51bWVyaWNMaXRlcmFsKCkge1xuICByZXR1cm4gbnVtYmVyVHlwZUFubm90YXRpb24oKTtcbn1cbmZ1bmN0aW9uIEJvb2xlYW5MaXRlcmFsKCkge1xuICByZXR1cm4gYm9vbGVhblR5cGVBbm5vdGF0aW9uKCk7XG59XG5mdW5jdGlvbiBOdWxsTGl0ZXJhbCgpIHtcbiAgcmV0dXJuIG51bGxMaXRlcmFsVHlwZUFubm90YXRpb24oKTtcbn1cbmZ1bmN0aW9uIFJlZ0V4cExpdGVyYWwoKSB7XG4gIHJldHVybiBnZW5lcmljVHlwZUFubm90YXRpb24oaWRlbnRpZmllcihcIlJlZ0V4cFwiKSk7XG59XG5mdW5jdGlvbiBPYmplY3RFeHByZXNzaW9uKCkge1xuICByZXR1cm4gZ2VuZXJpY1R5cGVBbm5vdGF0aW9uKGlkZW50aWZpZXIoXCJPYmplY3RcIikpO1xufVxuZnVuY3Rpb24gQXJyYXlFeHByZXNzaW9uKCkge1xuICByZXR1cm4gZ2VuZXJpY1R5cGVBbm5vdGF0aW9uKGlkZW50aWZpZXIoXCJBcnJheVwiKSk7XG59XG5mdW5jdGlvbiBSZXN0RWxlbWVudCgpIHtcbiAgcmV0dXJuIEFycmF5RXhwcmVzc2lvbigpO1xufVxuUmVzdEVsZW1lbnQudmFsaWRQYXJlbnQgPSB0cnVlO1xuZnVuY3Rpb24gRnVuYygpIHtcbiAgcmV0dXJuIGdlbmVyaWNUeXBlQW5ub3RhdGlvbihpZGVudGlmaWVyKFwiRnVuY3Rpb25cIikpO1xufVxuY29uc3QgaXNBcnJheUZyb20gPSBidWlsZE1hdGNoTWVtYmVyRXhwcmVzc2lvbihcIkFycmF5LmZyb21cIik7XG5jb25zdCBpc09iamVjdEtleXMgPSBidWlsZE1hdGNoTWVtYmVyRXhwcmVzc2lvbihcIk9iamVjdC5rZXlzXCIpO1xuY29uc3QgaXNPYmplY3RWYWx1ZXMgPSBidWlsZE1hdGNoTWVtYmVyRXhwcmVzc2lvbihcIk9iamVjdC52YWx1ZXNcIik7XG5jb25zdCBpc09iamVjdEVudHJpZXMgPSBidWlsZE1hdGNoTWVtYmVyRXhwcmVzc2lvbihcIk9iamVjdC5lbnRyaWVzXCIpO1xuZnVuY3Rpb24gQ2FsbEV4cHJlc3Npb24oKSB7XG4gIGNvbnN0IHtcbiAgICBjYWxsZWVcbiAgfSA9IHRoaXMubm9kZTtcbiAgaWYgKGlzT2JqZWN0S2V5cyhjYWxsZWUpKSB7XG4gICAgcmV0dXJuIGFycmF5VHlwZUFubm90YXRpb24oc3RyaW5nVHlwZUFubm90YXRpb24oKSk7XG4gIH0gZWxzZSBpZiAoaXNBcnJheUZyb20oY2FsbGVlKSB8fCBpc09iamVjdFZhbHVlcyhjYWxsZWUpIHx8IGlzSWRlbnRpZmllcihjYWxsZWUsIHtcbiAgICBuYW1lOiBcIkFycmF5XCJcbiAgfSkpIHtcbiAgICByZXR1cm4gYXJyYXlUeXBlQW5ub3RhdGlvbihhbnlUeXBlQW5ub3RhdGlvbigpKTtcbiAgfSBlbHNlIGlmIChpc09iamVjdEVudHJpZXMoY2FsbGVlKSkge1xuICAgIHJldHVybiBhcnJheVR5cGVBbm5vdGF0aW9uKHR1cGxlVHlwZUFubm90YXRpb24oW3N0cmluZ1R5cGVBbm5vdGF0aW9uKCksIGFueVR5cGVBbm5vdGF0aW9uKCldKSk7XG4gIH1cbiAgcmV0dXJuIHJlc29sdmVDYWxsKHRoaXMuZ2V0KFwiY2FsbGVlXCIpKTtcbn1cbmZ1bmN0aW9uIFRhZ2dlZFRlbXBsYXRlRXhwcmVzc2lvbigpIHtcbiAgcmV0dXJuIHJlc29sdmVDYWxsKHRoaXMuZ2V0KFwidGFnXCIpKTtcbn1cbmZ1bmN0aW9uIHJlc29sdmVDYWxsKGNhbGxlZSkge1xuICBjYWxsZWUgPSBjYWxsZWUucmVzb2x2ZSgpO1xuICBpZiAoY2FsbGVlLmlzRnVuY3Rpb24oKSkge1xuICAgIGNvbnN0IHtcbiAgICAgIG5vZGVcbiAgICB9ID0gY2FsbGVlO1xuICAgIGlmIChub2RlLmFzeW5jKSB7XG4gICAgICBpZiAobm9kZS5nZW5lcmF0b3IpIHtcbiAgICAgICAgcmV0dXJuIGdlbmVyaWNUeXBlQW5ub3RhdGlvbihpZGVudGlmaWVyKFwiQXN5bmNJdGVyYXRvclwiKSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gZ2VuZXJpY1R5cGVBbm5vdGF0aW9uKGlkZW50aWZpZXIoXCJQcm9taXNlXCIpKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKG5vZGUuZ2VuZXJhdG9yKSB7XG4gICAgICAgIHJldHVybiBnZW5lcmljVHlwZUFubm90YXRpb24oaWRlbnRpZmllcihcIkl0ZXJhdG9yXCIpKTtcbiAgICAgIH0gZWxzZSBpZiAoY2FsbGVlLm5vZGUucmV0dXJuVHlwZSkge1xuICAgICAgICByZXR1cm4gY2FsbGVlLm5vZGUucmV0dXJuVHlwZTtcbiAgICAgIH0gZWxzZSB7fVxuICAgIH1cbiAgfVxufVxuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmZlcmVycy5qcy5tYXBcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@babel/traverse/lib/path/inference/inferers.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@babel/traverse/lib/path/inference/util.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@babel/traverse/lib/path/inference/util.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports.createUnionType = createUnionType;\nvar _t = __webpack_require__(/*! @babel/types */ \"(ssr)/./node_modules/@babel/types/lib/index.js\");\nconst {\n  createFlowUnionType,\n  createTSUnionType,\n  createUnionTypeAnnotation,\n  isFlowType,\n  isTSType\n} = _t;\nfunction createUnionType(types) {\n  if (types.every(v => isFlowType(v))) {\n    if (createFlowUnionType) {\n      return createFlowUnionType(types);\n    }\n    return createUnionTypeAnnotation(types);\n  } else if (types.every(v => isTSType(v))) {\n    if (createTSUnionType) {\n      return createTSUnionType(types);\n    }\n  }\n}\n\n//# sourceMappingURL=util.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGJhYmVsL3RyYXZlcnNlL2xpYi9wYXRoL2luZmVyZW5jZS91dGlsLmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViLDhDQUE2QztBQUM3QztBQUNBLENBQUMsRUFBQztBQUNGLHVCQUF1QjtBQUN2QixTQUFTLG1CQUFPLENBQUMsb0VBQWM7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcmVwby12aXN1YWxpemVyLy4vbm9kZV9tb2R1bGVzL0BiYWJlbC90cmF2ZXJzZS9saWIvcGF0aC9pbmZlcmVuY2UvdXRpbC5qcz81OGU2Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5jcmVhdGVVbmlvblR5cGUgPSBjcmVhdGVVbmlvblR5cGU7XG52YXIgX3QgPSByZXF1aXJlKFwiQGJhYmVsL3R5cGVzXCIpO1xuY29uc3Qge1xuICBjcmVhdGVGbG93VW5pb25UeXBlLFxuICBjcmVhdGVUU1VuaW9uVHlwZSxcbiAgY3JlYXRlVW5pb25UeXBlQW5ub3RhdGlvbixcbiAgaXNGbG93VHlwZSxcbiAgaXNUU1R5cGVcbn0gPSBfdDtcbmZ1bmN0aW9uIGNyZWF0ZVVuaW9uVHlwZSh0eXBlcykge1xuICBpZiAodHlwZXMuZXZlcnkodiA9PiBpc0Zsb3dUeXBlKHYpKSkge1xuICAgIGlmIChjcmVhdGVGbG93VW5pb25UeXBlKSB7XG4gICAgICByZXR1cm4gY3JlYXRlRmxvd1VuaW9uVHlwZSh0eXBlcyk7XG4gICAgfVxuICAgIHJldHVybiBjcmVhdGVVbmlvblR5cGVBbm5vdGF0aW9uKHR5cGVzKTtcbiAgfSBlbHNlIGlmICh0eXBlcy5ldmVyeSh2ID0+IGlzVFNUeXBlKHYpKSkge1xuICAgIGlmIChjcmVhdGVUU1VuaW9uVHlwZSkge1xuICAgICAgcmV0dXJuIGNyZWF0ZVRTVW5pb25UeXBlKHR5cGVzKTtcbiAgICB9XG4gIH1cbn1cblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dXRpbC5qcy5tYXBcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@babel/traverse/lib/path/inference/util.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@babel/traverse/lib/path/introspection.js":
/*!****************************************************************!*\
  !*** ./node_modules/@babel/traverse/lib/path/introspection.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports._guessExecutionStatusRelativeTo = _guessExecutionStatusRelativeTo;\nexports._resolve = _resolve;\nexports.canHaveVariableDeclarationOrExpression = canHaveVariableDeclarationOrExpression;\nexports.canSwapBetweenExpressionAndStatement = canSwapBetweenExpressionAndStatement;\nexports.getSource = getSource;\nexports.isCompletionRecord = isCompletionRecord;\nexports.isConstantExpression = isConstantExpression;\nexports.isInStrictMode = isInStrictMode;\nexports.isNodeType = isNodeType;\nexports.isStatementOrBlock = isStatementOrBlock;\nexports.isStatic = isStatic;\nexports.matchesPattern = matchesPattern;\nexports.referencesImport = referencesImport;\nexports.resolve = resolve;\nexports.willIMaybeExecuteBefore = willIMaybeExecuteBefore;\nvar _t = __webpack_require__(/*! @babel/types */ \"(ssr)/./node_modules/@babel/types/lib/index.js\");\nconst {\n  STATEMENT_OR_BLOCK_KEYS,\n  VISITOR_KEYS,\n  isBlockStatement,\n  isExpression,\n  isIdentifier,\n  isLiteral,\n  isStringLiteral,\n  isType,\n  matchesPattern: _matchesPattern\n} = _t;\nfunction matchesPattern(pattern, allowPartial) {\n  return _matchesPattern(this.node, pattern, allowPartial);\n}\nexports.has = function has(key) {\n  var _this$node;\n  const val = (_this$node = this.node) == null ? void 0 : _this$node[key];\n  if (val && Array.isArray(val)) {\n    return !!val.length;\n  } else {\n    return !!val;\n  }\n};\nfunction isStatic() {\n  return this.scope.isStatic(this.node);\n}\nexports.is = exports.has;\nexports.isnt = function isnt(key) {\n  return !this.has(key);\n};\nexports.equals = function equals(key, value) {\n  return this.node[key] === value;\n};\nfunction isNodeType(type) {\n  return isType(this.type, type);\n}\nfunction canHaveVariableDeclarationOrExpression() {\n  return (this.key === \"init\" || this.key === \"left\") && this.parentPath.isFor();\n}\nfunction canSwapBetweenExpressionAndStatement(replacement) {\n  if (this.key !== \"body\" || !this.parentPath.isArrowFunctionExpression()) {\n    return false;\n  }\n  if (this.isExpression()) {\n    return isBlockStatement(replacement);\n  } else if (this.isBlockStatement()) {\n    return isExpression(replacement);\n  }\n  return false;\n}\nfunction isCompletionRecord(allowInsideFunction) {\n  let path = this;\n  let first = true;\n  do {\n    const {\n      type,\n      container\n    } = path;\n    if (!first && (path.isFunction() || type === \"StaticBlock\")) {\n      return !!allowInsideFunction;\n    }\n    first = false;\n    if (Array.isArray(container) && path.key !== container.length - 1) {\n      return false;\n    }\n  } while ((path = path.parentPath) && !path.isProgram() && !path.isDoExpression());\n  return true;\n}\nfunction isStatementOrBlock() {\n  if (this.parentPath.isLabeledStatement() || isBlockStatement(this.container)) {\n    return false;\n  } else {\n    return STATEMENT_OR_BLOCK_KEYS.includes(this.key);\n  }\n}\nfunction referencesImport(moduleSource, importName) {\n  if (!this.isReferencedIdentifier()) {\n    if (this.isJSXMemberExpression() && this.node.property.name === importName || (this.isMemberExpression() || this.isOptionalMemberExpression()) && (this.node.computed ? isStringLiteral(this.node.property, {\n      value: importName\n    }) : this.node.property.name === importName)) {\n      const object = this.get(\"object\");\n      return object.isReferencedIdentifier() && object.referencesImport(moduleSource, \"*\");\n    }\n    return false;\n  }\n  const binding = this.scope.getBinding(this.node.name);\n  if ((binding == null ? void 0 : binding.kind) !== \"module\") return false;\n  const path = binding.path;\n  const parent = path.parentPath;\n  if (!parent.isImportDeclaration()) return false;\n  if (parent.node.source.value === moduleSource) {\n    if (!importName) return true;\n  } else {\n    return false;\n  }\n  if (path.isImportDefaultSpecifier() && importName === \"default\") {\n    return true;\n  }\n  if (path.isImportNamespaceSpecifier() && importName === \"*\") {\n    return true;\n  }\n  if (path.isImportSpecifier() && isIdentifier(path.node.imported, {\n    name: importName\n  })) {\n    return true;\n  }\n  return false;\n}\nfunction getSource() {\n  const node = this.node;\n  if (node.end) {\n    const code = this.hub.getCode();\n    if (code) return code.slice(node.start, node.end);\n  }\n  return \"\";\n}\nfunction willIMaybeExecuteBefore(target) {\n  return this._guessExecutionStatusRelativeTo(target) !== \"after\";\n}\nfunction getOuterFunction(path) {\n  return path.isProgram() ? path : (path.parentPath.scope.getFunctionParent() || path.parentPath.scope.getProgramParent()).path;\n}\nfunction isExecutionUncertain(type, key) {\n  switch (type) {\n    case \"LogicalExpression\":\n      return key === \"right\";\n    case \"ConditionalExpression\":\n    case \"IfStatement\":\n      return key === \"consequent\" || key === \"alternate\";\n    case \"WhileStatement\":\n    case \"DoWhileStatement\":\n    case \"ForInStatement\":\n    case \"ForOfStatement\":\n      return key === \"body\";\n    case \"ForStatement\":\n      return key === \"body\" || key === \"update\";\n    case \"SwitchStatement\":\n      return key === \"cases\";\n    case \"TryStatement\":\n      return key === \"handler\";\n    case \"AssignmentPattern\":\n      return key === \"right\";\n    case \"OptionalMemberExpression\":\n      return key === \"property\";\n    case \"OptionalCallExpression\":\n      return key === \"arguments\";\n    default:\n      return false;\n  }\n}\nfunction isExecutionUncertainInList(paths, maxIndex) {\n  for (let i = 0; i < maxIndex; i++) {\n    const path = paths[i];\n    if (isExecutionUncertain(path.parent.type, path.parentKey)) {\n      return true;\n    }\n  }\n  return false;\n}\nconst SYMBOL_CHECKING = Symbol();\nfunction _guessExecutionStatusRelativeTo(target) {\n  return _guessExecutionStatusRelativeToCached(this, target, new Map());\n}\nfunction _guessExecutionStatusRelativeToCached(base, target, cache) {\n  const funcParent = {\n    this: getOuterFunction(base),\n    target: getOuterFunction(target)\n  };\n  if (funcParent.target.node !== funcParent.this.node) {\n    return _guessExecutionStatusRelativeToDifferentFunctionsCached(base, funcParent.target, cache);\n  }\n  const paths = {\n    target: target.getAncestry(),\n    this: base.getAncestry()\n  };\n  if (paths.target.includes(base)) return \"after\";\n  if (paths.this.includes(target)) return \"before\";\n  let commonPath;\n  const commonIndex = {\n    target: 0,\n    this: 0\n  };\n  while (!commonPath && commonIndex.this < paths.this.length) {\n    const path = paths.this[commonIndex.this];\n    commonIndex.target = paths.target.indexOf(path);\n    if (commonIndex.target >= 0) {\n      commonPath = path;\n    } else {\n      commonIndex.this++;\n    }\n  }\n  if (!commonPath) {\n    throw new Error(\"Internal Babel error - The two compared nodes\" + \" don't appear to belong to the same program.\");\n  }\n  if (isExecutionUncertainInList(paths.this, commonIndex.this - 1) || isExecutionUncertainInList(paths.target, commonIndex.target - 1)) {\n    return \"unknown\";\n  }\n  const divergence = {\n    this: paths.this[commonIndex.this - 1],\n    target: paths.target[commonIndex.target - 1]\n  };\n  if (divergence.target.listKey && divergence.this.listKey && divergence.target.container === divergence.this.container) {\n    return divergence.target.key > divergence.this.key ? \"before\" : \"after\";\n  }\n  const keys = VISITOR_KEYS[commonPath.type];\n  const keyPosition = {\n    this: keys.indexOf(divergence.this.parentKey),\n    target: keys.indexOf(divergence.target.parentKey)\n  };\n  return keyPosition.target > keyPosition.this ? \"before\" : \"after\";\n}\nfunction _guessExecutionStatusRelativeToDifferentFunctionsInternal(base, target, cache) {\n  if (!target.isFunctionDeclaration()) {\n    if (_guessExecutionStatusRelativeToCached(base, target, cache) === \"before\") {\n      return \"before\";\n    }\n    return \"unknown\";\n  } else if (target.parentPath.isExportDeclaration()) {\n    return \"unknown\";\n  }\n  const binding = target.scope.getBinding(target.node.id.name);\n  if (!binding.references) return \"before\";\n  const referencePaths = binding.referencePaths;\n  let allStatus;\n  for (const path of referencePaths) {\n    const childOfFunction = !!path.find(path => path.node === target.node);\n    if (childOfFunction) continue;\n    if (path.key !== \"callee\" || !path.parentPath.isCallExpression()) {\n      return \"unknown\";\n    }\n    const status = _guessExecutionStatusRelativeToCached(base, path, cache);\n    if (allStatus && allStatus !== status) {\n      return \"unknown\";\n    } else {\n      allStatus = status;\n    }\n  }\n  return allStatus;\n}\nfunction _guessExecutionStatusRelativeToDifferentFunctionsCached(base, target, cache) {\n  let nodeMap = cache.get(base.node);\n  let cached;\n  if (!nodeMap) {\n    cache.set(base.node, nodeMap = new Map());\n  } else if (cached = nodeMap.get(target.node)) {\n    if (cached === SYMBOL_CHECKING) {\n      return \"unknown\";\n    }\n    return cached;\n  }\n  nodeMap.set(target.node, SYMBOL_CHECKING);\n  const result = _guessExecutionStatusRelativeToDifferentFunctionsInternal(base, target, cache);\n  nodeMap.set(target.node, result);\n  return result;\n}\nfunction resolve(dangerous, resolved) {\n  return _resolve.call(this, dangerous, resolved) || this;\n}\nfunction _resolve(dangerous, resolved) {\n  var _resolved;\n  if ((_resolved = resolved) != null && _resolved.includes(this)) return;\n  resolved = resolved || [];\n  resolved.push(this);\n  if (this.isVariableDeclarator()) {\n    if (this.get(\"id\").isIdentifier()) {\n      return this.get(\"init\").resolve(dangerous, resolved);\n    } else {}\n  } else if (this.isReferencedIdentifier()) {\n    const binding = this.scope.getBinding(this.node.name);\n    if (!binding) return;\n    if (!binding.constant) return;\n    if (binding.kind === \"module\") return;\n    if (binding.path !== this) {\n      const ret = binding.path.resolve(dangerous, resolved);\n      if (this.find(parent => parent.node === ret.node)) return;\n      return ret;\n    }\n  } else if (this.isTypeCastExpression()) {\n    return this.get(\"expression\").resolve(dangerous, resolved);\n  } else if (dangerous && this.isMemberExpression()) {\n    const targetKey = this.toComputedKey();\n    if (!isLiteral(targetKey)) return;\n    const targetName = targetKey.value;\n    const target = this.get(\"object\").resolve(dangerous, resolved);\n    if (target.isObjectExpression()) {\n      const props = target.get(\"properties\");\n      for (const prop of props) {\n        if (!prop.isProperty()) continue;\n        const key = prop.get(\"key\");\n        let match = prop.isnt(\"computed\") && key.isIdentifier({\n          name: targetName\n        });\n        match = match || key.isLiteral({\n          value: targetName\n        });\n        if (match) return prop.get(\"value\").resolve(dangerous, resolved);\n      }\n    } else if (target.isArrayExpression() && !isNaN(+targetName)) {\n      const elems = target.get(\"elements\");\n      const elem = elems[targetName];\n      if (elem) return elem.resolve(dangerous, resolved);\n    }\n  }\n}\nfunction isConstantExpression() {\n  if (this.isIdentifier()) {\n    const binding = this.scope.getBinding(this.node.name);\n    if (!binding) return false;\n    return binding.constant;\n  }\n  if (this.isLiteral()) {\n    if (this.isRegExpLiteral()) {\n      return false;\n    }\n    if (this.isTemplateLiteral()) {\n      return this.get(\"expressions\").every(expression => expression.isConstantExpression());\n    }\n    return true;\n  }\n  if (this.isUnaryExpression()) {\n    if (this.node.operator !== \"void\") {\n      return false;\n    }\n    return this.get(\"argument\").isConstantExpression();\n  }\n  if (this.isBinaryExpression()) {\n    const {\n      operator\n    } = this.node;\n    return operator !== \"in\" && operator !== \"instanceof\" && this.get(\"left\").isConstantExpression() && this.get(\"right\").isConstantExpression();\n  }\n  if (this.isMemberExpression()) {\n    return !this.node.computed && this.get(\"object\").isIdentifier({\n      name: \"Symbol\"\n    }) && !this.scope.hasBinding(\"Symbol\", {\n      noGlobals: true\n    });\n  }\n  if (this.isCallExpression()) {\n    return this.node.arguments.length === 1 && this.get(\"callee\").matchesPattern(\"Symbol.for\") && !this.scope.hasBinding(\"Symbol\", {\n      noGlobals: true\n    }) && this.get(\"arguments\")[0].isStringLiteral();\n  }\n  return false;\n}\nfunction isInStrictMode() {\n  const start = this.isProgram() ? this : this.parentPath;\n  const strictParent = start.find(path => {\n    if (path.isProgram({\n      sourceType: \"module\"\n    })) return true;\n    if (path.isClass()) return true;\n    if (path.isArrowFunctionExpression() && !path.get(\"body\").isBlockStatement()) {\n      return false;\n    }\n    let body;\n    if (path.isFunction()) {\n      body = path.node.body;\n    } else if (path.isProgram()) {\n      body = path.node;\n    } else {\n      return false;\n    }\n    for (const directive of body.directives) {\n      if (directive.value.value === \"use strict\") {\n        return true;\n      }\n    }\n    return false;\n  });\n  return !!strictParent;\n}\n\n//# sourceMappingURL=introspection.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGJhYmVsL3RyYXZlcnNlL2xpYi9wYXRoL2ludHJvc3BlY3Rpb24uanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWIsOENBQTZDO0FBQzdDO0FBQ0EsQ0FBQyxFQUFDO0FBQ0YsdUNBQXVDO0FBQ3ZDLGdCQUFnQjtBQUNoQiw4Q0FBOEM7QUFDOUMsNENBQTRDO0FBQzVDLGlCQUFpQjtBQUNqQiwwQkFBMEI7QUFDMUIsNEJBQTRCO0FBQzVCLHNCQUFzQjtBQUN0QixrQkFBa0I7QUFDbEIsMEJBQTBCO0FBQzFCLGdCQUFnQjtBQUNoQixzQkFBc0I7QUFDdEIsd0JBQXdCO0FBQ3hCLGVBQWU7QUFDZiwrQkFBK0I7QUFDL0IsU0FBUyxtQkFBTyxDQUFDLG9FQUFjO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1YsWUFBWTtBQUNaO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsY0FBYztBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTixJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcmVwby12aXN1YWxpemVyLy4vbm9kZV9tb2R1bGVzL0BiYWJlbC90cmF2ZXJzZS9saWIvcGF0aC9pbnRyb3NwZWN0aW9uLmpzP2MxNzAiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLl9ndWVzc0V4ZWN1dGlvblN0YXR1c1JlbGF0aXZlVG8gPSBfZ3Vlc3NFeGVjdXRpb25TdGF0dXNSZWxhdGl2ZVRvO1xuZXhwb3J0cy5fcmVzb2x2ZSA9IF9yZXNvbHZlO1xuZXhwb3J0cy5jYW5IYXZlVmFyaWFibGVEZWNsYXJhdGlvbk9yRXhwcmVzc2lvbiA9IGNhbkhhdmVWYXJpYWJsZURlY2xhcmF0aW9uT3JFeHByZXNzaW9uO1xuZXhwb3J0cy5jYW5Td2FwQmV0d2VlbkV4cHJlc3Npb25BbmRTdGF0ZW1lbnQgPSBjYW5Td2FwQmV0d2VlbkV4cHJlc3Npb25BbmRTdGF0ZW1lbnQ7XG5leHBvcnRzLmdldFNvdXJjZSA9IGdldFNvdXJjZTtcbmV4cG9ydHMuaXNDb21wbGV0aW9uUmVjb3JkID0gaXNDb21wbGV0aW9uUmVjb3JkO1xuZXhwb3J0cy5pc0NvbnN0YW50RXhwcmVzc2lvbiA9IGlzQ29uc3RhbnRFeHByZXNzaW9uO1xuZXhwb3J0cy5pc0luU3RyaWN0TW9kZSA9IGlzSW5TdHJpY3RNb2RlO1xuZXhwb3J0cy5pc05vZGVUeXBlID0gaXNOb2RlVHlwZTtcbmV4cG9ydHMuaXNTdGF0ZW1lbnRPckJsb2NrID0gaXNTdGF0ZW1lbnRPckJsb2NrO1xuZXhwb3J0cy5pc1N0YXRpYyA9IGlzU3RhdGljO1xuZXhwb3J0cy5tYXRjaGVzUGF0dGVybiA9IG1hdGNoZXNQYXR0ZXJuO1xuZXhwb3J0cy5yZWZlcmVuY2VzSW1wb3J0ID0gcmVmZXJlbmNlc0ltcG9ydDtcbmV4cG9ydHMucmVzb2x2ZSA9IHJlc29sdmU7XG5leHBvcnRzLndpbGxJTWF5YmVFeGVjdXRlQmVmb3JlID0gd2lsbElNYXliZUV4ZWN1dGVCZWZvcmU7XG52YXIgX3QgPSByZXF1aXJlKFwiQGJhYmVsL3R5cGVzXCIpO1xuY29uc3Qge1xuICBTVEFURU1FTlRfT1JfQkxPQ0tfS0VZUyxcbiAgVklTSVRPUl9LRVlTLFxuICBpc0Jsb2NrU3RhdGVtZW50LFxuICBpc0V4cHJlc3Npb24sXG4gIGlzSWRlbnRpZmllcixcbiAgaXNMaXRlcmFsLFxuICBpc1N0cmluZ0xpdGVyYWwsXG4gIGlzVHlwZSxcbiAgbWF0Y2hlc1BhdHRlcm46IF9tYXRjaGVzUGF0dGVyblxufSA9IF90O1xuZnVuY3Rpb24gbWF0Y2hlc1BhdHRlcm4ocGF0dGVybiwgYWxsb3dQYXJ0aWFsKSB7XG4gIHJldHVybiBfbWF0Y2hlc1BhdHRlcm4odGhpcy5ub2RlLCBwYXR0ZXJuLCBhbGxvd1BhcnRpYWwpO1xufVxuZXhwb3J0cy5oYXMgPSBmdW5jdGlvbiBoYXMoa2V5KSB7XG4gIHZhciBfdGhpcyRub2RlO1xuICBjb25zdCB2YWwgPSAoX3RoaXMkbm9kZSA9IHRoaXMubm9kZSkgPT0gbnVsbCA/IHZvaWQgMCA6IF90aGlzJG5vZGVba2V5XTtcbiAgaWYgKHZhbCAmJiBBcnJheS5pc0FycmF5KHZhbCkpIHtcbiAgICByZXR1cm4gISF2YWwubGVuZ3RoO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiAhIXZhbDtcbiAgfVxufTtcbmZ1bmN0aW9uIGlzU3RhdGljKCkge1xuICByZXR1cm4gdGhpcy5zY29wZS5pc1N0YXRpYyh0aGlzLm5vZGUpO1xufVxuZXhwb3J0cy5pcyA9IGV4cG9ydHMuaGFzO1xuZXhwb3J0cy5pc250ID0gZnVuY3Rpb24gaXNudChrZXkpIHtcbiAgcmV0dXJuICF0aGlzLmhhcyhrZXkpO1xufTtcbmV4cG9ydHMuZXF1YWxzID0gZnVuY3Rpb24gZXF1YWxzKGtleSwgdmFsdWUpIHtcbiAgcmV0dXJuIHRoaXMubm9kZVtrZXldID09PSB2YWx1ZTtcbn07XG5mdW5jdGlvbiBpc05vZGVUeXBlKHR5cGUpIHtcbiAgcmV0dXJuIGlzVHlwZSh0aGlzLnR5cGUsIHR5cGUpO1xufVxuZnVuY3Rpb24gY2FuSGF2ZVZhcmlhYmxlRGVjbGFyYXRpb25PckV4cHJlc3Npb24oKSB7XG4gIHJldHVybiAodGhpcy5rZXkgPT09IFwiaW5pdFwiIHx8IHRoaXMua2V5ID09PSBcImxlZnRcIikgJiYgdGhpcy5wYXJlbnRQYXRoLmlzRm9yKCk7XG59XG5mdW5jdGlvbiBjYW5Td2FwQmV0d2VlbkV4cHJlc3Npb25BbmRTdGF0ZW1lbnQocmVwbGFjZW1lbnQpIHtcbiAgaWYgKHRoaXMua2V5ICE9PSBcImJvZHlcIiB8fCAhdGhpcy5wYXJlbnRQYXRoLmlzQXJyb3dGdW5jdGlvbkV4cHJlc3Npb24oKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBpZiAodGhpcy5pc0V4cHJlc3Npb24oKSkge1xuICAgIHJldHVybiBpc0Jsb2NrU3RhdGVtZW50KHJlcGxhY2VtZW50KTtcbiAgfSBlbHNlIGlmICh0aGlzLmlzQmxvY2tTdGF0ZW1lbnQoKSkge1xuICAgIHJldHVybiBpc0V4cHJlc3Npb24ocmVwbGFjZW1lbnQpO1xuICB9XG4gIHJldHVybiBmYWxzZTtcbn1cbmZ1bmN0aW9uIGlzQ29tcGxldGlvblJlY29yZChhbGxvd0luc2lkZUZ1bmN0aW9uKSB7XG4gIGxldCBwYXRoID0gdGhpcztcbiAgbGV0IGZpcnN0ID0gdHJ1ZTtcbiAgZG8ge1xuICAgIGNvbnN0IHtcbiAgICAgIHR5cGUsXG4gICAgICBjb250YWluZXJcbiAgICB9ID0gcGF0aDtcbiAgICBpZiAoIWZpcnN0ICYmIChwYXRoLmlzRnVuY3Rpb24oKSB8fCB0eXBlID09PSBcIlN0YXRpY0Jsb2NrXCIpKSB7XG4gICAgICByZXR1cm4gISFhbGxvd0luc2lkZUZ1bmN0aW9uO1xuICAgIH1cbiAgICBmaXJzdCA9IGZhbHNlO1xuICAgIGlmIChBcnJheS5pc0FycmF5KGNvbnRhaW5lcikgJiYgcGF0aC5rZXkgIT09IGNvbnRhaW5lci5sZW5ndGggLSAxKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9IHdoaWxlICgocGF0aCA9IHBhdGgucGFyZW50UGF0aCkgJiYgIXBhdGguaXNQcm9ncmFtKCkgJiYgIXBhdGguaXNEb0V4cHJlc3Npb24oKSk7XG4gIHJldHVybiB0cnVlO1xufVxuZnVuY3Rpb24gaXNTdGF0ZW1lbnRPckJsb2NrKCkge1xuICBpZiAodGhpcy5wYXJlbnRQYXRoLmlzTGFiZWxlZFN0YXRlbWVudCgpIHx8IGlzQmxvY2tTdGF0ZW1lbnQodGhpcy5jb250YWluZXIpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBTVEFURU1FTlRfT1JfQkxPQ0tfS0VZUy5pbmNsdWRlcyh0aGlzLmtleSk7XG4gIH1cbn1cbmZ1bmN0aW9uIHJlZmVyZW5jZXNJbXBvcnQobW9kdWxlU291cmNlLCBpbXBvcnROYW1lKSB7XG4gIGlmICghdGhpcy5pc1JlZmVyZW5jZWRJZGVudGlmaWVyKCkpIHtcbiAgICBpZiAodGhpcy5pc0pTWE1lbWJlckV4cHJlc3Npb24oKSAmJiB0aGlzLm5vZGUucHJvcGVydHkubmFtZSA9PT0gaW1wb3J0TmFtZSB8fCAodGhpcy5pc01lbWJlckV4cHJlc3Npb24oKSB8fCB0aGlzLmlzT3B0aW9uYWxNZW1iZXJFeHByZXNzaW9uKCkpICYmICh0aGlzLm5vZGUuY29tcHV0ZWQgPyBpc1N0cmluZ0xpdGVyYWwodGhpcy5ub2RlLnByb3BlcnR5LCB7XG4gICAgICB2YWx1ZTogaW1wb3J0TmFtZVxuICAgIH0pIDogdGhpcy5ub2RlLnByb3BlcnR5Lm5hbWUgPT09IGltcG9ydE5hbWUpKSB7XG4gICAgICBjb25zdCBvYmplY3QgPSB0aGlzLmdldChcIm9iamVjdFwiKTtcbiAgICAgIHJldHVybiBvYmplY3QuaXNSZWZlcmVuY2VkSWRlbnRpZmllcigpICYmIG9iamVjdC5yZWZlcmVuY2VzSW1wb3J0KG1vZHVsZVNvdXJjZSwgXCIqXCIpO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgY29uc3QgYmluZGluZyA9IHRoaXMuc2NvcGUuZ2V0QmluZGluZyh0aGlzLm5vZGUubmFtZSk7XG4gIGlmICgoYmluZGluZyA9PSBudWxsID8gdm9pZCAwIDogYmluZGluZy5raW5kKSAhPT0gXCJtb2R1bGVcIikgcmV0dXJuIGZhbHNlO1xuICBjb25zdCBwYXRoID0gYmluZGluZy5wYXRoO1xuICBjb25zdCBwYXJlbnQgPSBwYXRoLnBhcmVudFBhdGg7XG4gIGlmICghcGFyZW50LmlzSW1wb3J0RGVjbGFyYXRpb24oKSkgcmV0dXJuIGZhbHNlO1xuICBpZiAocGFyZW50Lm5vZGUuc291cmNlLnZhbHVlID09PSBtb2R1bGVTb3VyY2UpIHtcbiAgICBpZiAoIWltcG9ydE5hbWUpIHJldHVybiB0cnVlO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBpZiAocGF0aC5pc0ltcG9ydERlZmF1bHRTcGVjaWZpZXIoKSAmJiBpbXBvcnROYW1lID09PSBcImRlZmF1bHRcIikge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIGlmIChwYXRoLmlzSW1wb3J0TmFtZXNwYWNlU3BlY2lmaWVyKCkgJiYgaW1wb3J0TmFtZSA9PT0gXCIqXCIpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICBpZiAocGF0aC5pc0ltcG9ydFNwZWNpZmllcigpICYmIGlzSWRlbnRpZmllcihwYXRoLm5vZGUuaW1wb3J0ZWQsIHtcbiAgICBuYW1lOiBpbXBvcnROYW1lXG4gIH0pKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufVxuZnVuY3Rpb24gZ2V0U291cmNlKCkge1xuICBjb25zdCBub2RlID0gdGhpcy5ub2RlO1xuICBpZiAobm9kZS5lbmQpIHtcbiAgICBjb25zdCBjb2RlID0gdGhpcy5odWIuZ2V0Q29kZSgpO1xuICAgIGlmIChjb2RlKSByZXR1cm4gY29kZS5zbGljZShub2RlLnN0YXJ0LCBub2RlLmVuZCk7XG4gIH1cbiAgcmV0dXJuIFwiXCI7XG59XG5mdW5jdGlvbiB3aWxsSU1heWJlRXhlY3V0ZUJlZm9yZSh0YXJnZXQpIHtcbiAgcmV0dXJuIHRoaXMuX2d1ZXNzRXhlY3V0aW9uU3RhdHVzUmVsYXRpdmVUbyh0YXJnZXQpICE9PSBcImFmdGVyXCI7XG59XG5mdW5jdGlvbiBnZXRPdXRlckZ1bmN0aW9uKHBhdGgpIHtcbiAgcmV0dXJuIHBhdGguaXNQcm9ncmFtKCkgPyBwYXRoIDogKHBhdGgucGFyZW50UGF0aC5zY29wZS5nZXRGdW5jdGlvblBhcmVudCgpIHx8IHBhdGgucGFyZW50UGF0aC5zY29wZS5nZXRQcm9ncmFtUGFyZW50KCkpLnBhdGg7XG59XG5mdW5jdGlvbiBpc0V4ZWN1dGlvblVuY2VydGFpbih0eXBlLCBrZXkpIHtcbiAgc3dpdGNoICh0eXBlKSB7XG4gICAgY2FzZSBcIkxvZ2ljYWxFeHByZXNzaW9uXCI6XG4gICAgICByZXR1cm4ga2V5ID09PSBcInJpZ2h0XCI7XG4gICAgY2FzZSBcIkNvbmRpdGlvbmFsRXhwcmVzc2lvblwiOlxuICAgIGNhc2UgXCJJZlN0YXRlbWVudFwiOlxuICAgICAgcmV0dXJuIGtleSA9PT0gXCJjb25zZXF1ZW50XCIgfHwga2V5ID09PSBcImFsdGVybmF0ZVwiO1xuICAgIGNhc2UgXCJXaGlsZVN0YXRlbWVudFwiOlxuICAgIGNhc2UgXCJEb1doaWxlU3RhdGVtZW50XCI6XG4gICAgY2FzZSBcIkZvckluU3RhdGVtZW50XCI6XG4gICAgY2FzZSBcIkZvck9mU3RhdGVtZW50XCI6XG4gICAgICByZXR1cm4ga2V5ID09PSBcImJvZHlcIjtcbiAgICBjYXNlIFwiRm9yU3RhdGVtZW50XCI6XG4gICAgICByZXR1cm4ga2V5ID09PSBcImJvZHlcIiB8fCBrZXkgPT09IFwidXBkYXRlXCI7XG4gICAgY2FzZSBcIlN3aXRjaFN0YXRlbWVudFwiOlxuICAgICAgcmV0dXJuIGtleSA9PT0gXCJjYXNlc1wiO1xuICAgIGNhc2UgXCJUcnlTdGF0ZW1lbnRcIjpcbiAgICAgIHJldHVybiBrZXkgPT09IFwiaGFuZGxlclwiO1xuICAgIGNhc2UgXCJBc3NpZ25tZW50UGF0dGVyblwiOlxuICAgICAgcmV0dXJuIGtleSA9PT0gXCJyaWdodFwiO1xuICAgIGNhc2UgXCJPcHRpb25hbE1lbWJlckV4cHJlc3Npb25cIjpcbiAgICAgIHJldHVybiBrZXkgPT09IFwicHJvcGVydHlcIjtcbiAgICBjYXNlIFwiT3B0aW9uYWxDYWxsRXhwcmVzc2lvblwiOlxuICAgICAgcmV0dXJuIGtleSA9PT0gXCJhcmd1bWVudHNcIjtcbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIGZhbHNlO1xuICB9XG59XG5mdW5jdGlvbiBpc0V4ZWN1dGlvblVuY2VydGFpbkluTGlzdChwYXRocywgbWF4SW5kZXgpIHtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBtYXhJbmRleDsgaSsrKSB7XG4gICAgY29uc3QgcGF0aCA9IHBhdGhzW2ldO1xuICAgIGlmIChpc0V4ZWN1dGlvblVuY2VydGFpbihwYXRoLnBhcmVudC50eXBlLCBwYXRoLnBhcmVudEtleSkpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gZmFsc2U7XG59XG5jb25zdCBTWU1CT0xfQ0hFQ0tJTkcgPSBTeW1ib2woKTtcbmZ1bmN0aW9uIF9ndWVzc0V4ZWN1dGlvblN0YXR1c1JlbGF0aXZlVG8odGFyZ2V0KSB7XG4gIHJldHVybiBfZ3Vlc3NFeGVjdXRpb25TdGF0dXNSZWxhdGl2ZVRvQ2FjaGVkKHRoaXMsIHRhcmdldCwgbmV3IE1hcCgpKTtcbn1cbmZ1bmN0aW9uIF9ndWVzc0V4ZWN1dGlvblN0YXR1c1JlbGF0aXZlVG9DYWNoZWQoYmFzZSwgdGFyZ2V0LCBjYWNoZSkge1xuICBjb25zdCBmdW5jUGFyZW50ID0ge1xuICAgIHRoaXM6IGdldE91dGVyRnVuY3Rpb24oYmFzZSksXG4gICAgdGFyZ2V0OiBnZXRPdXRlckZ1bmN0aW9uKHRhcmdldClcbiAgfTtcbiAgaWYgKGZ1bmNQYXJlbnQudGFyZ2V0Lm5vZGUgIT09IGZ1bmNQYXJlbnQudGhpcy5ub2RlKSB7XG4gICAgcmV0dXJuIF9ndWVzc0V4ZWN1dGlvblN0YXR1c1JlbGF0aXZlVG9EaWZmZXJlbnRGdW5jdGlvbnNDYWNoZWQoYmFzZSwgZnVuY1BhcmVudC50YXJnZXQsIGNhY2hlKTtcbiAgfVxuICBjb25zdCBwYXRocyA9IHtcbiAgICB0YXJnZXQ6IHRhcmdldC5nZXRBbmNlc3RyeSgpLFxuICAgIHRoaXM6IGJhc2UuZ2V0QW5jZXN0cnkoKVxuICB9O1xuICBpZiAocGF0aHMudGFyZ2V0LmluY2x1ZGVzKGJhc2UpKSByZXR1cm4gXCJhZnRlclwiO1xuICBpZiAocGF0aHMudGhpcy5pbmNsdWRlcyh0YXJnZXQpKSByZXR1cm4gXCJiZWZvcmVcIjtcbiAgbGV0IGNvbW1vblBhdGg7XG4gIGNvbnN0IGNvbW1vbkluZGV4ID0ge1xuICAgIHRhcmdldDogMCxcbiAgICB0aGlzOiAwXG4gIH07XG4gIHdoaWxlICghY29tbW9uUGF0aCAmJiBjb21tb25JbmRleC50aGlzIDwgcGF0aHMudGhpcy5sZW5ndGgpIHtcbiAgICBjb25zdCBwYXRoID0gcGF0aHMudGhpc1tjb21tb25JbmRleC50aGlzXTtcbiAgICBjb21tb25JbmRleC50YXJnZXQgPSBwYXRocy50YXJnZXQuaW5kZXhPZihwYXRoKTtcbiAgICBpZiAoY29tbW9uSW5kZXgudGFyZ2V0ID49IDApIHtcbiAgICAgIGNvbW1vblBhdGggPSBwYXRoO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb21tb25JbmRleC50aGlzKys7XG4gICAgfVxuICB9XG4gIGlmICghY29tbW9uUGF0aCkge1xuICAgIHRocm93IG5ldyBFcnJvcihcIkludGVybmFsIEJhYmVsIGVycm9yIC0gVGhlIHR3byBjb21wYXJlZCBub2Rlc1wiICsgXCIgZG9uJ3QgYXBwZWFyIHRvIGJlbG9uZyB0byB0aGUgc2FtZSBwcm9ncmFtLlwiKTtcbiAgfVxuICBpZiAoaXNFeGVjdXRpb25VbmNlcnRhaW5Jbkxpc3QocGF0aHMudGhpcywgY29tbW9uSW5kZXgudGhpcyAtIDEpIHx8IGlzRXhlY3V0aW9uVW5jZXJ0YWluSW5MaXN0KHBhdGhzLnRhcmdldCwgY29tbW9uSW5kZXgudGFyZ2V0IC0gMSkpIHtcbiAgICByZXR1cm4gXCJ1bmtub3duXCI7XG4gIH1cbiAgY29uc3QgZGl2ZXJnZW5jZSA9IHtcbiAgICB0aGlzOiBwYXRocy50aGlzW2NvbW1vbkluZGV4LnRoaXMgLSAxXSxcbiAgICB0YXJnZXQ6IHBhdGhzLnRhcmdldFtjb21tb25JbmRleC50YXJnZXQgLSAxXVxuICB9O1xuICBpZiAoZGl2ZXJnZW5jZS50YXJnZXQubGlzdEtleSAmJiBkaXZlcmdlbmNlLnRoaXMubGlzdEtleSAmJiBkaXZlcmdlbmNlLnRhcmdldC5jb250YWluZXIgPT09IGRpdmVyZ2VuY2UudGhpcy5jb250YWluZXIpIHtcbiAgICByZXR1cm4gZGl2ZXJnZW5jZS50YXJnZXQua2V5ID4gZGl2ZXJnZW5jZS50aGlzLmtleSA/IFwiYmVmb3JlXCIgOiBcImFmdGVyXCI7XG4gIH1cbiAgY29uc3Qga2V5cyA9IFZJU0lUT1JfS0VZU1tjb21tb25QYXRoLnR5cGVdO1xuICBjb25zdCBrZXlQb3NpdGlvbiA9IHtcbiAgICB0aGlzOiBrZXlzLmluZGV4T2YoZGl2ZXJnZW5jZS50aGlzLnBhcmVudEtleSksXG4gICAgdGFyZ2V0OiBrZXlzLmluZGV4T2YoZGl2ZXJnZW5jZS50YXJnZXQucGFyZW50S2V5KVxuICB9O1xuICByZXR1cm4ga2V5UG9zaXRpb24udGFyZ2V0ID4ga2V5UG9zaXRpb24udGhpcyA/IFwiYmVmb3JlXCIgOiBcImFmdGVyXCI7XG59XG5mdW5jdGlvbiBfZ3Vlc3NFeGVjdXRpb25TdGF0dXNSZWxhdGl2ZVRvRGlmZmVyZW50RnVuY3Rpb25zSW50ZXJuYWwoYmFzZSwgdGFyZ2V0LCBjYWNoZSkge1xuICBpZiAoIXRhcmdldC5pc0Z1bmN0aW9uRGVjbGFyYXRpb24oKSkge1xuICAgIGlmIChfZ3Vlc3NFeGVjdXRpb25TdGF0dXNSZWxhdGl2ZVRvQ2FjaGVkKGJhc2UsIHRhcmdldCwgY2FjaGUpID09PSBcImJlZm9yZVwiKSB7XG4gICAgICByZXR1cm4gXCJiZWZvcmVcIjtcbiAgICB9XG4gICAgcmV0dXJuIFwidW5rbm93blwiO1xuICB9IGVsc2UgaWYgKHRhcmdldC5wYXJlbnRQYXRoLmlzRXhwb3J0RGVjbGFyYXRpb24oKSkge1xuICAgIHJldHVybiBcInVua25vd25cIjtcbiAgfVxuICBjb25zdCBiaW5kaW5nID0gdGFyZ2V0LnNjb3BlLmdldEJpbmRpbmcodGFyZ2V0Lm5vZGUuaWQubmFtZSk7XG4gIGlmICghYmluZGluZy5yZWZlcmVuY2VzKSByZXR1cm4gXCJiZWZvcmVcIjtcbiAgY29uc3QgcmVmZXJlbmNlUGF0aHMgPSBiaW5kaW5nLnJlZmVyZW5jZVBhdGhzO1xuICBsZXQgYWxsU3RhdHVzO1xuICBmb3IgKGNvbnN0IHBhdGggb2YgcmVmZXJlbmNlUGF0aHMpIHtcbiAgICBjb25zdCBjaGlsZE9mRnVuY3Rpb24gPSAhIXBhdGguZmluZChwYXRoID0+IHBhdGgubm9kZSA9PT0gdGFyZ2V0Lm5vZGUpO1xuICAgIGlmIChjaGlsZE9mRnVuY3Rpb24pIGNvbnRpbnVlO1xuICAgIGlmIChwYXRoLmtleSAhPT0gXCJjYWxsZWVcIiB8fCAhcGF0aC5wYXJlbnRQYXRoLmlzQ2FsbEV4cHJlc3Npb24oKSkge1xuICAgICAgcmV0dXJuIFwidW5rbm93blwiO1xuICAgIH1cbiAgICBjb25zdCBzdGF0dXMgPSBfZ3Vlc3NFeGVjdXRpb25TdGF0dXNSZWxhdGl2ZVRvQ2FjaGVkKGJhc2UsIHBhdGgsIGNhY2hlKTtcbiAgICBpZiAoYWxsU3RhdHVzICYmIGFsbFN0YXR1cyAhPT0gc3RhdHVzKSB7XG4gICAgICByZXR1cm4gXCJ1bmtub3duXCI7XG4gICAgfSBlbHNlIHtcbiAgICAgIGFsbFN0YXR1cyA9IHN0YXR1cztcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGFsbFN0YXR1cztcbn1cbmZ1bmN0aW9uIF9ndWVzc0V4ZWN1dGlvblN0YXR1c1JlbGF0aXZlVG9EaWZmZXJlbnRGdW5jdGlvbnNDYWNoZWQoYmFzZSwgdGFyZ2V0LCBjYWNoZSkge1xuICBsZXQgbm9kZU1hcCA9IGNhY2hlLmdldChiYXNlLm5vZGUpO1xuICBsZXQgY2FjaGVkO1xuICBpZiAoIW5vZGVNYXApIHtcbiAgICBjYWNoZS5zZXQoYmFzZS5ub2RlLCBub2RlTWFwID0gbmV3IE1hcCgpKTtcbiAgfSBlbHNlIGlmIChjYWNoZWQgPSBub2RlTWFwLmdldCh0YXJnZXQubm9kZSkpIHtcbiAgICBpZiAoY2FjaGVkID09PSBTWU1CT0xfQ0hFQ0tJTkcpIHtcbiAgICAgIHJldHVybiBcInVua25vd25cIjtcbiAgICB9XG4gICAgcmV0dXJuIGNhY2hlZDtcbiAgfVxuICBub2RlTWFwLnNldCh0YXJnZXQubm9kZSwgU1lNQk9MX0NIRUNLSU5HKTtcbiAgY29uc3QgcmVzdWx0ID0gX2d1ZXNzRXhlY3V0aW9uU3RhdHVzUmVsYXRpdmVUb0RpZmZlcmVudEZ1bmN0aW9uc0ludGVybmFsKGJhc2UsIHRhcmdldCwgY2FjaGUpO1xuICBub2RlTWFwLnNldCh0YXJnZXQubm9kZSwgcmVzdWx0KTtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cbmZ1bmN0aW9uIHJlc29sdmUoZGFuZ2Vyb3VzLCByZXNvbHZlZCkge1xuICByZXR1cm4gX3Jlc29sdmUuY2FsbCh0aGlzLCBkYW5nZXJvdXMsIHJlc29sdmVkKSB8fCB0aGlzO1xufVxuZnVuY3Rpb24gX3Jlc29sdmUoZGFuZ2Vyb3VzLCByZXNvbHZlZCkge1xuICB2YXIgX3Jlc29sdmVkO1xuICBpZiAoKF9yZXNvbHZlZCA9IHJlc29sdmVkKSAhPSBudWxsICYmIF9yZXNvbHZlZC5pbmNsdWRlcyh0aGlzKSkgcmV0dXJuO1xuICByZXNvbHZlZCA9IHJlc29sdmVkIHx8IFtdO1xuICByZXNvbHZlZC5wdXNoKHRoaXMpO1xuICBpZiAodGhpcy5pc1ZhcmlhYmxlRGVjbGFyYXRvcigpKSB7XG4gICAgaWYgKHRoaXMuZ2V0KFwiaWRcIikuaXNJZGVudGlmaWVyKCkpIHtcbiAgICAgIHJldHVybiB0aGlzLmdldChcImluaXRcIikucmVzb2x2ZShkYW5nZXJvdXMsIHJlc29sdmVkKTtcbiAgICB9IGVsc2Uge31cbiAgfSBlbHNlIGlmICh0aGlzLmlzUmVmZXJlbmNlZElkZW50aWZpZXIoKSkge1xuICAgIGNvbnN0IGJpbmRpbmcgPSB0aGlzLnNjb3BlLmdldEJpbmRpbmcodGhpcy5ub2RlLm5hbWUpO1xuICAgIGlmICghYmluZGluZykgcmV0dXJuO1xuICAgIGlmICghYmluZGluZy5jb25zdGFudCkgcmV0dXJuO1xuICAgIGlmIChiaW5kaW5nLmtpbmQgPT09IFwibW9kdWxlXCIpIHJldHVybjtcbiAgICBpZiAoYmluZGluZy5wYXRoICE9PSB0aGlzKSB7XG4gICAgICBjb25zdCByZXQgPSBiaW5kaW5nLnBhdGgucmVzb2x2ZShkYW5nZXJvdXMsIHJlc29sdmVkKTtcbiAgICAgIGlmICh0aGlzLmZpbmQocGFyZW50ID0+IHBhcmVudC5ub2RlID09PSByZXQubm9kZSkpIHJldHVybjtcbiAgICAgIHJldHVybiByZXQ7XG4gICAgfVxuICB9IGVsc2UgaWYgKHRoaXMuaXNUeXBlQ2FzdEV4cHJlc3Npb24oKSkge1xuICAgIHJldHVybiB0aGlzLmdldChcImV4cHJlc3Npb25cIikucmVzb2x2ZShkYW5nZXJvdXMsIHJlc29sdmVkKTtcbiAgfSBlbHNlIGlmIChkYW5nZXJvdXMgJiYgdGhpcy5pc01lbWJlckV4cHJlc3Npb24oKSkge1xuICAgIGNvbnN0IHRhcmdldEtleSA9IHRoaXMudG9Db21wdXRlZEtleSgpO1xuICAgIGlmICghaXNMaXRlcmFsKHRhcmdldEtleSkpIHJldHVybjtcbiAgICBjb25zdCB0YXJnZXROYW1lID0gdGFyZ2V0S2V5LnZhbHVlO1xuICAgIGNvbnN0IHRhcmdldCA9IHRoaXMuZ2V0KFwib2JqZWN0XCIpLnJlc29sdmUoZGFuZ2Vyb3VzLCByZXNvbHZlZCk7XG4gICAgaWYgKHRhcmdldC5pc09iamVjdEV4cHJlc3Npb24oKSkge1xuICAgICAgY29uc3QgcHJvcHMgPSB0YXJnZXQuZ2V0KFwicHJvcGVydGllc1wiKTtcbiAgICAgIGZvciAoY29uc3QgcHJvcCBvZiBwcm9wcykge1xuICAgICAgICBpZiAoIXByb3AuaXNQcm9wZXJ0eSgpKSBjb250aW51ZTtcbiAgICAgICAgY29uc3Qga2V5ID0gcHJvcC5nZXQoXCJrZXlcIik7XG4gICAgICAgIGxldCBtYXRjaCA9IHByb3AuaXNudChcImNvbXB1dGVkXCIpICYmIGtleS5pc0lkZW50aWZpZXIoe1xuICAgICAgICAgIG5hbWU6IHRhcmdldE5hbWVcbiAgICAgICAgfSk7XG4gICAgICAgIG1hdGNoID0gbWF0Y2ggfHwga2V5LmlzTGl0ZXJhbCh7XG4gICAgICAgICAgdmFsdWU6IHRhcmdldE5hbWVcbiAgICAgICAgfSk7XG4gICAgICAgIGlmIChtYXRjaCkgcmV0dXJuIHByb3AuZ2V0KFwidmFsdWVcIikucmVzb2x2ZShkYW5nZXJvdXMsIHJlc29sdmVkKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHRhcmdldC5pc0FycmF5RXhwcmVzc2lvbigpICYmICFpc05hTigrdGFyZ2V0TmFtZSkpIHtcbiAgICAgIGNvbnN0IGVsZW1zID0gdGFyZ2V0LmdldChcImVsZW1lbnRzXCIpO1xuICAgICAgY29uc3QgZWxlbSA9IGVsZW1zW3RhcmdldE5hbWVdO1xuICAgICAgaWYgKGVsZW0pIHJldHVybiBlbGVtLnJlc29sdmUoZGFuZ2Vyb3VzLCByZXNvbHZlZCk7XG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiBpc0NvbnN0YW50RXhwcmVzc2lvbigpIHtcbiAgaWYgKHRoaXMuaXNJZGVudGlmaWVyKCkpIHtcbiAgICBjb25zdCBiaW5kaW5nID0gdGhpcy5zY29wZS5nZXRCaW5kaW5nKHRoaXMubm9kZS5uYW1lKTtcbiAgICBpZiAoIWJpbmRpbmcpIHJldHVybiBmYWxzZTtcbiAgICByZXR1cm4gYmluZGluZy5jb25zdGFudDtcbiAgfVxuICBpZiAodGhpcy5pc0xpdGVyYWwoKSkge1xuICAgIGlmICh0aGlzLmlzUmVnRXhwTGl0ZXJhbCgpKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGlmICh0aGlzLmlzVGVtcGxhdGVMaXRlcmFsKCkpIHtcbiAgICAgIHJldHVybiB0aGlzLmdldChcImV4cHJlc3Npb25zXCIpLmV2ZXJ5KGV4cHJlc3Npb24gPT4gZXhwcmVzc2lvbi5pc0NvbnN0YW50RXhwcmVzc2lvbigpKTtcbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgaWYgKHRoaXMuaXNVbmFyeUV4cHJlc3Npb24oKSkge1xuICAgIGlmICh0aGlzLm5vZGUub3BlcmF0b3IgIT09IFwidm9pZFwiKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLmdldChcImFyZ3VtZW50XCIpLmlzQ29uc3RhbnRFeHByZXNzaW9uKCk7XG4gIH1cbiAgaWYgKHRoaXMuaXNCaW5hcnlFeHByZXNzaW9uKCkpIHtcbiAgICBjb25zdCB7XG4gICAgICBvcGVyYXRvclxuICAgIH0gPSB0aGlzLm5vZGU7XG4gICAgcmV0dXJuIG9wZXJhdG9yICE9PSBcImluXCIgJiYgb3BlcmF0b3IgIT09IFwiaW5zdGFuY2VvZlwiICYmIHRoaXMuZ2V0KFwibGVmdFwiKS5pc0NvbnN0YW50RXhwcmVzc2lvbigpICYmIHRoaXMuZ2V0KFwicmlnaHRcIikuaXNDb25zdGFudEV4cHJlc3Npb24oKTtcbiAgfVxuICBpZiAodGhpcy5pc01lbWJlckV4cHJlc3Npb24oKSkge1xuICAgIHJldHVybiAhdGhpcy5ub2RlLmNvbXB1dGVkICYmIHRoaXMuZ2V0KFwib2JqZWN0XCIpLmlzSWRlbnRpZmllcih7XG4gICAgICBuYW1lOiBcIlN5bWJvbFwiXG4gICAgfSkgJiYgIXRoaXMuc2NvcGUuaGFzQmluZGluZyhcIlN5bWJvbFwiLCB7XG4gICAgICBub0dsb2JhbHM6IHRydWVcbiAgICB9KTtcbiAgfVxuICBpZiAodGhpcy5pc0NhbGxFeHByZXNzaW9uKCkpIHtcbiAgICByZXR1cm4gdGhpcy5ub2RlLmFyZ3VtZW50cy5sZW5ndGggPT09IDEgJiYgdGhpcy5nZXQoXCJjYWxsZWVcIikubWF0Y2hlc1BhdHRlcm4oXCJTeW1ib2wuZm9yXCIpICYmICF0aGlzLnNjb3BlLmhhc0JpbmRpbmcoXCJTeW1ib2xcIiwge1xuICAgICAgbm9HbG9iYWxzOiB0cnVlXG4gICAgfSkgJiYgdGhpcy5nZXQoXCJhcmd1bWVudHNcIilbMF0uaXNTdHJpbmdMaXRlcmFsKCk7XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufVxuZnVuY3Rpb24gaXNJblN0cmljdE1vZGUoKSB7XG4gIGNvbnN0IHN0YXJ0ID0gdGhpcy5pc1Byb2dyYW0oKSA/IHRoaXMgOiB0aGlzLnBhcmVudFBhdGg7XG4gIGNvbnN0IHN0cmljdFBhcmVudCA9IHN0YXJ0LmZpbmQocGF0aCA9PiB7XG4gICAgaWYgKHBhdGguaXNQcm9ncmFtKHtcbiAgICAgIHNvdXJjZVR5cGU6IFwibW9kdWxlXCJcbiAgICB9KSkgcmV0dXJuIHRydWU7XG4gICAgaWYgKHBhdGguaXNDbGFzcygpKSByZXR1cm4gdHJ1ZTtcbiAgICBpZiAocGF0aC5pc0Fycm93RnVuY3Rpb25FeHByZXNzaW9uKCkgJiYgIXBhdGguZ2V0KFwiYm9keVwiKS5pc0Jsb2NrU3RhdGVtZW50KCkpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgbGV0IGJvZHk7XG4gICAgaWYgKHBhdGguaXNGdW5jdGlvbigpKSB7XG4gICAgICBib2R5ID0gcGF0aC5ub2RlLmJvZHk7XG4gICAgfSBlbHNlIGlmIChwYXRoLmlzUHJvZ3JhbSgpKSB7XG4gICAgICBib2R5ID0gcGF0aC5ub2RlO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGZvciAoY29uc3QgZGlyZWN0aXZlIG9mIGJvZHkuZGlyZWN0aXZlcykge1xuICAgICAgaWYgKGRpcmVjdGl2ZS52YWx1ZS52YWx1ZSA9PT0gXCJ1c2Ugc3RyaWN0XCIpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfSk7XG4gIHJldHVybiAhIXN0cmljdFBhcmVudDtcbn1cblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW50cm9zcGVjdGlvbi5qcy5tYXBcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@babel/traverse/lib/path/introspection.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@babel/traverse/lib/path/lib/hoister.js":
/*!**************************************************************!*\
  !*** ./node_modules/@babel/traverse/lib/path/lib/hoister.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports[\"default\"] = void 0;\nvar _t = __webpack_require__(/*! @babel/types */ \"(ssr)/./node_modules/@babel/types/lib/index.js\");\nvar _t2 = _t;\nconst {\n  react\n} = _t;\nconst {\n  cloneNode,\n  jsxExpressionContainer,\n  variableDeclaration,\n  variableDeclarator\n} = _t2;\nconst referenceVisitor = {\n  ReferencedIdentifier(path, state) {\n    if (path.isJSXIdentifier() && react.isCompatTag(path.node.name) && !path.parentPath.isJSXMemberExpression()) {\n      return;\n    }\n    if (path.node.name === \"this\") {\n      let scope = path.scope;\n      do {\n        if (scope.path.isFunction() && !scope.path.isArrowFunctionExpression()) {\n          break;\n        }\n      } while (scope = scope.parent);\n      if (scope) state.breakOnScopePaths.push(scope.path);\n    }\n    const binding = path.scope.getBinding(path.node.name);\n    if (!binding) return;\n    for (const violation of binding.constantViolations) {\n      if (violation.scope !== binding.path.scope) {\n        state.mutableBinding = true;\n        path.stop();\n        return;\n      }\n    }\n    if (binding !== state.scope.getBinding(path.node.name)) return;\n    state.bindings[path.node.name] = binding;\n  }\n};\nclass PathHoister {\n  constructor(path, scope) {\n    this.breakOnScopePaths = void 0;\n    this.bindings = void 0;\n    this.mutableBinding = void 0;\n    this.scopes = void 0;\n    this.scope = void 0;\n    this.path = void 0;\n    this.attachAfter = void 0;\n    this.breakOnScopePaths = [];\n    this.bindings = {};\n    this.mutableBinding = false;\n    this.scopes = [];\n    this.scope = scope;\n    this.path = path;\n    this.attachAfter = false;\n  }\n  isCompatibleScope(scope) {\n    for (const key of Object.keys(this.bindings)) {\n      const binding = this.bindings[key];\n      if (!scope.bindingIdentifierEquals(key, binding.identifier)) {\n        return false;\n      }\n    }\n    return true;\n  }\n  getCompatibleScopes() {\n    let scope = this.path.scope;\n    do {\n      if (this.isCompatibleScope(scope)) {\n        this.scopes.push(scope);\n      } else {\n        break;\n      }\n      if (this.breakOnScopePaths.includes(scope.path)) {\n        break;\n      }\n    } while (scope = scope.parent);\n  }\n  getAttachmentPath() {\n    let path = this._getAttachmentPath();\n    if (!path) return;\n    let targetScope = path.scope;\n    if (targetScope.path === path) {\n      targetScope = path.scope.parent;\n    }\n    if (targetScope.path.isProgram() || targetScope.path.isFunction()) {\n      for (const name of Object.keys(this.bindings)) {\n        if (!targetScope.hasOwnBinding(name)) continue;\n        const binding = this.bindings[name];\n        if (binding.kind === \"param\" || binding.path.parentKey === \"params\") {\n          continue;\n        }\n        const bindingParentPath = this.getAttachmentParentForPath(binding.path);\n        if (bindingParentPath.key >= path.key) {\n          this.attachAfter = true;\n          path = binding.path;\n          for (const violationPath of binding.constantViolations) {\n            if (this.getAttachmentParentForPath(violationPath).key > path.key) {\n              path = violationPath;\n            }\n          }\n        }\n      }\n    }\n    return path;\n  }\n  _getAttachmentPath() {\n    const scopes = this.scopes;\n    const scope = scopes.pop();\n    if (!scope) return;\n    if (scope.path.isFunction()) {\n      if (this.hasOwnParamBindings(scope)) {\n        if (this.scope === scope) return;\n        const bodies = scope.path.get(\"body\").get(\"body\");\n        for (let i = 0; i < bodies.length; i++) {\n          if (bodies[i].node._blockHoist) continue;\n          return bodies[i];\n        }\n      } else {\n        return this.getNextScopeAttachmentParent();\n      }\n    } else if (scope.path.isProgram()) {\n      return this.getNextScopeAttachmentParent();\n    }\n  }\n  getNextScopeAttachmentParent() {\n    const scope = this.scopes.pop();\n    if (scope) return this.getAttachmentParentForPath(scope.path);\n  }\n  getAttachmentParentForPath(path) {\n    do {\n      if (!path.parentPath || Array.isArray(path.container) && path.isStatement()) {\n        return path;\n      }\n    } while (path = path.parentPath);\n    return path;\n  }\n  hasOwnParamBindings(scope) {\n    for (const name of Object.keys(this.bindings)) {\n      if (!scope.hasOwnBinding(name)) continue;\n      const binding = this.bindings[name];\n      if (binding.kind === \"param\" && binding.constant) return true;\n    }\n    return false;\n  }\n  run() {\n    this.path.traverse(referenceVisitor, this);\n    if (this.mutableBinding) return;\n    this.getCompatibleScopes();\n    const attachTo = this.getAttachmentPath();\n    if (!attachTo) return;\n    if (attachTo.getFunctionParent() === this.path.getFunctionParent()) return;\n    let uid = attachTo.scope.generateUidIdentifier(\"ref\");\n    const declarator = variableDeclarator(uid, this.path.node);\n    const insertFn = this.attachAfter ? \"insertAfter\" : \"insertBefore\";\n    const [attached] = attachTo[insertFn]([attachTo.isVariableDeclarator() ? declarator : variableDeclaration(\"var\", [declarator])]);\n    const parent = this.path.parentPath;\n    if (parent.isJSXElement() && this.path.container === parent.node.children) {\n      uid = jsxExpressionContainer(uid);\n    }\n    this.path.replaceWith(cloneNode(uid));\n    return attached.isVariableDeclarator() ? attached.get(\"init\") : attached.get(\"declarations.0.init\");\n  }\n}\nexports[\"default\"] = PathHoister;\n\n//# sourceMappingURL=hoister.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGJhYmVsL3RyYXZlcnNlL2xpYi9wYXRoL2xpYi9ob2lzdGVyLmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViLDhDQUE2QztBQUM3QztBQUNBLENBQUMsRUFBQztBQUNGLGtCQUFlO0FBQ2YsU0FBUyxtQkFBTyxDQUFDLG9FQUFjO0FBQy9CO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixtQkFBbUI7QUFDM0M7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBZTs7QUFFZiIsInNvdXJjZXMiOlsid2VicGFjazovL3JlcG8tdmlzdWFsaXplci8uL25vZGVfbW9kdWxlcy9AYmFiZWwvdHJhdmVyc2UvbGliL3BhdGgvbGliL2hvaXN0ZXIuanM/NmFjYyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuZGVmYXVsdCA9IHZvaWQgMDtcbnZhciBfdCA9IHJlcXVpcmUoXCJAYmFiZWwvdHlwZXNcIik7XG52YXIgX3QyID0gX3Q7XG5jb25zdCB7XG4gIHJlYWN0XG59ID0gX3Q7XG5jb25zdCB7XG4gIGNsb25lTm9kZSxcbiAganN4RXhwcmVzc2lvbkNvbnRhaW5lcixcbiAgdmFyaWFibGVEZWNsYXJhdGlvbixcbiAgdmFyaWFibGVEZWNsYXJhdG9yXG59ID0gX3QyO1xuY29uc3QgcmVmZXJlbmNlVmlzaXRvciA9IHtcbiAgUmVmZXJlbmNlZElkZW50aWZpZXIocGF0aCwgc3RhdGUpIHtcbiAgICBpZiAocGF0aC5pc0pTWElkZW50aWZpZXIoKSAmJiByZWFjdC5pc0NvbXBhdFRhZyhwYXRoLm5vZGUubmFtZSkgJiYgIXBhdGgucGFyZW50UGF0aC5pc0pTWE1lbWJlckV4cHJlc3Npb24oKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAocGF0aC5ub2RlLm5hbWUgPT09IFwidGhpc1wiKSB7XG4gICAgICBsZXQgc2NvcGUgPSBwYXRoLnNjb3BlO1xuICAgICAgZG8ge1xuICAgICAgICBpZiAoc2NvcGUucGF0aC5pc0Z1bmN0aW9uKCkgJiYgIXNjb3BlLnBhdGguaXNBcnJvd0Z1bmN0aW9uRXhwcmVzc2lvbigpKSB7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH0gd2hpbGUgKHNjb3BlID0gc2NvcGUucGFyZW50KTtcbiAgICAgIGlmIChzY29wZSkgc3RhdGUuYnJlYWtPblNjb3BlUGF0aHMucHVzaChzY29wZS5wYXRoKTtcbiAgICB9XG4gICAgY29uc3QgYmluZGluZyA9IHBhdGguc2NvcGUuZ2V0QmluZGluZyhwYXRoLm5vZGUubmFtZSk7XG4gICAgaWYgKCFiaW5kaW5nKSByZXR1cm47XG4gICAgZm9yIChjb25zdCB2aW9sYXRpb24gb2YgYmluZGluZy5jb25zdGFudFZpb2xhdGlvbnMpIHtcbiAgICAgIGlmICh2aW9sYXRpb24uc2NvcGUgIT09IGJpbmRpbmcucGF0aC5zY29wZSkge1xuICAgICAgICBzdGF0ZS5tdXRhYmxlQmluZGluZyA9IHRydWU7XG4gICAgICAgIHBhdGguc3RvcCgpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChiaW5kaW5nICE9PSBzdGF0ZS5zY29wZS5nZXRCaW5kaW5nKHBhdGgubm9kZS5uYW1lKSkgcmV0dXJuO1xuICAgIHN0YXRlLmJpbmRpbmdzW3BhdGgubm9kZS5uYW1lXSA9IGJpbmRpbmc7XG4gIH1cbn07XG5jbGFzcyBQYXRoSG9pc3RlciB7XG4gIGNvbnN0cnVjdG9yKHBhdGgsIHNjb3BlKSB7XG4gICAgdGhpcy5icmVha09uU2NvcGVQYXRocyA9IHZvaWQgMDtcbiAgICB0aGlzLmJpbmRpbmdzID0gdm9pZCAwO1xuICAgIHRoaXMubXV0YWJsZUJpbmRpbmcgPSB2b2lkIDA7XG4gICAgdGhpcy5zY29wZXMgPSB2b2lkIDA7XG4gICAgdGhpcy5zY29wZSA9IHZvaWQgMDtcbiAgICB0aGlzLnBhdGggPSB2b2lkIDA7XG4gICAgdGhpcy5hdHRhY2hBZnRlciA9IHZvaWQgMDtcbiAgICB0aGlzLmJyZWFrT25TY29wZVBhdGhzID0gW107XG4gICAgdGhpcy5iaW5kaW5ncyA9IHt9O1xuICAgIHRoaXMubXV0YWJsZUJpbmRpbmcgPSBmYWxzZTtcbiAgICB0aGlzLnNjb3BlcyA9IFtdO1xuICAgIHRoaXMuc2NvcGUgPSBzY29wZTtcbiAgICB0aGlzLnBhdGggPSBwYXRoO1xuICAgIHRoaXMuYXR0YWNoQWZ0ZXIgPSBmYWxzZTtcbiAgfVxuICBpc0NvbXBhdGlibGVTY29wZShzY29wZSkge1xuICAgIGZvciAoY29uc3Qga2V5IG9mIE9iamVjdC5rZXlzKHRoaXMuYmluZGluZ3MpKSB7XG4gICAgICBjb25zdCBiaW5kaW5nID0gdGhpcy5iaW5kaW5nc1trZXldO1xuICAgICAgaWYgKCFzY29wZS5iaW5kaW5nSWRlbnRpZmllckVxdWFscyhrZXksIGJpbmRpbmcuaWRlbnRpZmllcikpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICBnZXRDb21wYXRpYmxlU2NvcGVzKCkge1xuICAgIGxldCBzY29wZSA9IHRoaXMucGF0aC5zY29wZTtcbiAgICBkbyB7XG4gICAgICBpZiAodGhpcy5pc0NvbXBhdGlibGVTY29wZShzY29wZSkpIHtcbiAgICAgICAgdGhpcy5zY29wZXMucHVzaChzY29wZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLmJyZWFrT25TY29wZVBhdGhzLmluY2x1ZGVzKHNjb3BlLnBhdGgpKSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH0gd2hpbGUgKHNjb3BlID0gc2NvcGUucGFyZW50KTtcbiAgfVxuICBnZXRBdHRhY2htZW50UGF0aCgpIHtcbiAgICBsZXQgcGF0aCA9IHRoaXMuX2dldEF0dGFjaG1lbnRQYXRoKCk7XG4gICAgaWYgKCFwYXRoKSByZXR1cm47XG4gICAgbGV0IHRhcmdldFNjb3BlID0gcGF0aC5zY29wZTtcbiAgICBpZiAodGFyZ2V0U2NvcGUucGF0aCA9PT0gcGF0aCkge1xuICAgICAgdGFyZ2V0U2NvcGUgPSBwYXRoLnNjb3BlLnBhcmVudDtcbiAgICB9XG4gICAgaWYgKHRhcmdldFNjb3BlLnBhdGguaXNQcm9ncmFtKCkgfHwgdGFyZ2V0U2NvcGUucGF0aC5pc0Z1bmN0aW9uKCkpIHtcbiAgICAgIGZvciAoY29uc3QgbmFtZSBvZiBPYmplY3Qua2V5cyh0aGlzLmJpbmRpbmdzKSkge1xuICAgICAgICBpZiAoIXRhcmdldFNjb3BlLmhhc093bkJpbmRpbmcobmFtZSkpIGNvbnRpbnVlO1xuICAgICAgICBjb25zdCBiaW5kaW5nID0gdGhpcy5iaW5kaW5nc1tuYW1lXTtcbiAgICAgICAgaWYgKGJpbmRpbmcua2luZCA9PT0gXCJwYXJhbVwiIHx8IGJpbmRpbmcucGF0aC5wYXJlbnRLZXkgPT09IFwicGFyYW1zXCIpIHtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBiaW5kaW5nUGFyZW50UGF0aCA9IHRoaXMuZ2V0QXR0YWNobWVudFBhcmVudEZvclBhdGgoYmluZGluZy5wYXRoKTtcbiAgICAgICAgaWYgKGJpbmRpbmdQYXJlbnRQYXRoLmtleSA+PSBwYXRoLmtleSkge1xuICAgICAgICAgIHRoaXMuYXR0YWNoQWZ0ZXIgPSB0cnVlO1xuICAgICAgICAgIHBhdGggPSBiaW5kaW5nLnBhdGg7XG4gICAgICAgICAgZm9yIChjb25zdCB2aW9sYXRpb25QYXRoIG9mIGJpbmRpbmcuY29uc3RhbnRWaW9sYXRpb25zKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5nZXRBdHRhY2htZW50UGFyZW50Rm9yUGF0aCh2aW9sYXRpb25QYXRoKS5rZXkgPiBwYXRoLmtleSkge1xuICAgICAgICAgICAgICBwYXRoID0gdmlvbGF0aW9uUGF0aDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHBhdGg7XG4gIH1cbiAgX2dldEF0dGFjaG1lbnRQYXRoKCkge1xuICAgIGNvbnN0IHNjb3BlcyA9IHRoaXMuc2NvcGVzO1xuICAgIGNvbnN0IHNjb3BlID0gc2NvcGVzLnBvcCgpO1xuICAgIGlmICghc2NvcGUpIHJldHVybjtcbiAgICBpZiAoc2NvcGUucGF0aC5pc0Z1bmN0aW9uKCkpIHtcbiAgICAgIGlmICh0aGlzLmhhc093blBhcmFtQmluZGluZ3Moc2NvcGUpKSB7XG4gICAgICAgIGlmICh0aGlzLnNjb3BlID09PSBzY29wZSkgcmV0dXJuO1xuICAgICAgICBjb25zdCBib2RpZXMgPSBzY29wZS5wYXRoLmdldChcImJvZHlcIikuZ2V0KFwiYm9keVwiKTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBib2RpZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBpZiAoYm9kaWVzW2ldLm5vZGUuX2Jsb2NrSG9pc3QpIGNvbnRpbnVlO1xuICAgICAgICAgIHJldHVybiBib2RpZXNbaV07XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdldE5leHRTY29wZUF0dGFjaG1lbnRQYXJlbnQoKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHNjb3BlLnBhdGguaXNQcm9ncmFtKCkpIHtcbiAgICAgIHJldHVybiB0aGlzLmdldE5leHRTY29wZUF0dGFjaG1lbnRQYXJlbnQoKTtcbiAgICB9XG4gIH1cbiAgZ2V0TmV4dFNjb3BlQXR0YWNobWVudFBhcmVudCgpIHtcbiAgICBjb25zdCBzY29wZSA9IHRoaXMuc2NvcGVzLnBvcCgpO1xuICAgIGlmIChzY29wZSkgcmV0dXJuIHRoaXMuZ2V0QXR0YWNobWVudFBhcmVudEZvclBhdGgoc2NvcGUucGF0aCk7XG4gIH1cbiAgZ2V0QXR0YWNobWVudFBhcmVudEZvclBhdGgocGF0aCkge1xuICAgIGRvIHtcbiAgICAgIGlmICghcGF0aC5wYXJlbnRQYXRoIHx8IEFycmF5LmlzQXJyYXkocGF0aC5jb250YWluZXIpICYmIHBhdGguaXNTdGF0ZW1lbnQoKSkge1xuICAgICAgICByZXR1cm4gcGF0aDtcbiAgICAgIH1cbiAgICB9IHdoaWxlIChwYXRoID0gcGF0aC5wYXJlbnRQYXRoKTtcbiAgICByZXR1cm4gcGF0aDtcbiAgfVxuICBoYXNPd25QYXJhbUJpbmRpbmdzKHNjb3BlKSB7XG4gICAgZm9yIChjb25zdCBuYW1lIG9mIE9iamVjdC5rZXlzKHRoaXMuYmluZGluZ3MpKSB7XG4gICAgICBpZiAoIXNjb3BlLmhhc093bkJpbmRpbmcobmFtZSkpIGNvbnRpbnVlO1xuICAgICAgY29uc3QgYmluZGluZyA9IHRoaXMuYmluZGluZ3NbbmFtZV07XG4gICAgICBpZiAoYmluZGluZy5raW5kID09PSBcInBhcmFtXCIgJiYgYmluZGluZy5jb25zdGFudCkgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBydW4oKSB7XG4gICAgdGhpcy5wYXRoLnRyYXZlcnNlKHJlZmVyZW5jZVZpc2l0b3IsIHRoaXMpO1xuICAgIGlmICh0aGlzLm11dGFibGVCaW5kaW5nKSByZXR1cm47XG4gICAgdGhpcy5nZXRDb21wYXRpYmxlU2NvcGVzKCk7XG4gICAgY29uc3QgYXR0YWNoVG8gPSB0aGlzLmdldEF0dGFjaG1lbnRQYXRoKCk7XG4gICAgaWYgKCFhdHRhY2hUbykgcmV0dXJuO1xuICAgIGlmIChhdHRhY2hUby5nZXRGdW5jdGlvblBhcmVudCgpID09PSB0aGlzLnBhdGguZ2V0RnVuY3Rpb25QYXJlbnQoKSkgcmV0dXJuO1xuICAgIGxldCB1aWQgPSBhdHRhY2hUby5zY29wZS5nZW5lcmF0ZVVpZElkZW50aWZpZXIoXCJyZWZcIik7XG4gICAgY29uc3QgZGVjbGFyYXRvciA9IHZhcmlhYmxlRGVjbGFyYXRvcih1aWQsIHRoaXMucGF0aC5ub2RlKTtcbiAgICBjb25zdCBpbnNlcnRGbiA9IHRoaXMuYXR0YWNoQWZ0ZXIgPyBcImluc2VydEFmdGVyXCIgOiBcImluc2VydEJlZm9yZVwiO1xuICAgIGNvbnN0IFthdHRhY2hlZF0gPSBhdHRhY2hUb1tpbnNlcnRGbl0oW2F0dGFjaFRvLmlzVmFyaWFibGVEZWNsYXJhdG9yKCkgPyBkZWNsYXJhdG9yIDogdmFyaWFibGVEZWNsYXJhdGlvbihcInZhclwiLCBbZGVjbGFyYXRvcl0pXSk7XG4gICAgY29uc3QgcGFyZW50ID0gdGhpcy5wYXRoLnBhcmVudFBhdGg7XG4gICAgaWYgKHBhcmVudC5pc0pTWEVsZW1lbnQoKSAmJiB0aGlzLnBhdGguY29udGFpbmVyID09PSBwYXJlbnQubm9kZS5jaGlsZHJlbikge1xuICAgICAgdWlkID0ganN4RXhwcmVzc2lvbkNvbnRhaW5lcih1aWQpO1xuICAgIH1cbiAgICB0aGlzLnBhdGgucmVwbGFjZVdpdGgoY2xvbmVOb2RlKHVpZCkpO1xuICAgIHJldHVybiBhdHRhY2hlZC5pc1ZhcmlhYmxlRGVjbGFyYXRvcigpID8gYXR0YWNoZWQuZ2V0KFwiaW5pdFwiKSA6IGF0dGFjaGVkLmdldChcImRlY2xhcmF0aW9ucy4wLmluaXRcIik7XG4gIH1cbn1cbmV4cG9ydHMuZGVmYXVsdCA9IFBhdGhIb2lzdGVyO1xuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1ob2lzdGVyLmpzLm1hcFxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@babel/traverse/lib/path/lib/hoister.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@babel/traverse/lib/path/lib/removal-hooks.js":
/*!********************************************************************!*\
  !*** ./node_modules/@babel/traverse/lib/path/lib/removal-hooks.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports.hooks = void 0;\nconst hooks = exports.hooks = [function (self, parent) {\n  const removeParent = self.key === \"test\" && (parent.isWhile() || parent.isSwitchCase()) || self.key === \"declaration\" && parent.isExportDeclaration() || self.key === \"body\" && parent.isLabeledStatement() || self.listKey === \"declarations\" && parent.isVariableDeclaration() && parent.node.declarations.length === 1 || self.key === \"expression\" && parent.isExpressionStatement();\n  if (removeParent) {\n    parent.remove();\n    return true;\n  }\n}, function (self, parent) {\n  if (parent.isSequenceExpression() && parent.node.expressions.length === 1) {\n    parent.replaceWith(parent.node.expressions[0]);\n    return true;\n  }\n}, function (self, parent) {\n  if (parent.isBinary()) {\n    if (self.key === \"left\") {\n      parent.replaceWith(parent.node.right);\n    } else {\n      parent.replaceWith(parent.node.left);\n    }\n    return true;\n  }\n}, function (self, parent) {\n  if (parent.isIfStatement() && self.key === \"consequent\" || self.key === \"body\" && (parent.isLoop() || parent.isArrowFunctionExpression())) {\n    self.replaceWith({\n      type: \"BlockStatement\",\n      directives: [],\n      body: []\n    });\n    return true;\n  }\n}];\n\n//# sourceMappingURL=removal-hooks.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGJhYmVsL3RyYXZlcnNlL2xpYi9wYXRoL2xpYi9yZW1vdmFsLWhvb2tzLmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViLDhDQUE2QztBQUM3QztBQUNBLENBQUMsRUFBQztBQUNGLGFBQWE7QUFDYixjQUFjLGFBQWE7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsQ0FBQzs7QUFFRCIsInNvdXJjZXMiOlsid2VicGFjazovL3JlcG8tdmlzdWFsaXplci8uL25vZGVfbW9kdWxlcy9AYmFiZWwvdHJhdmVyc2UvbGliL3BhdGgvbGliL3JlbW92YWwtaG9va3MuanM/ZmI1NSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuaG9va3MgPSB2b2lkIDA7XG5jb25zdCBob29rcyA9IGV4cG9ydHMuaG9va3MgPSBbZnVuY3Rpb24gKHNlbGYsIHBhcmVudCkge1xuICBjb25zdCByZW1vdmVQYXJlbnQgPSBzZWxmLmtleSA9PT0gXCJ0ZXN0XCIgJiYgKHBhcmVudC5pc1doaWxlKCkgfHwgcGFyZW50LmlzU3dpdGNoQ2FzZSgpKSB8fCBzZWxmLmtleSA9PT0gXCJkZWNsYXJhdGlvblwiICYmIHBhcmVudC5pc0V4cG9ydERlY2xhcmF0aW9uKCkgfHwgc2VsZi5rZXkgPT09IFwiYm9keVwiICYmIHBhcmVudC5pc0xhYmVsZWRTdGF0ZW1lbnQoKSB8fCBzZWxmLmxpc3RLZXkgPT09IFwiZGVjbGFyYXRpb25zXCIgJiYgcGFyZW50LmlzVmFyaWFibGVEZWNsYXJhdGlvbigpICYmIHBhcmVudC5ub2RlLmRlY2xhcmF0aW9ucy5sZW5ndGggPT09IDEgfHwgc2VsZi5rZXkgPT09IFwiZXhwcmVzc2lvblwiICYmIHBhcmVudC5pc0V4cHJlc3Npb25TdGF0ZW1lbnQoKTtcbiAgaWYgKHJlbW92ZVBhcmVudCkge1xuICAgIHBhcmVudC5yZW1vdmUoKTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxufSwgZnVuY3Rpb24gKHNlbGYsIHBhcmVudCkge1xuICBpZiAocGFyZW50LmlzU2VxdWVuY2VFeHByZXNzaW9uKCkgJiYgcGFyZW50Lm5vZGUuZXhwcmVzc2lvbnMubGVuZ3RoID09PSAxKSB7XG4gICAgcGFyZW50LnJlcGxhY2VXaXRoKHBhcmVudC5ub2RlLmV4cHJlc3Npb25zWzBdKTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxufSwgZnVuY3Rpb24gKHNlbGYsIHBhcmVudCkge1xuICBpZiAocGFyZW50LmlzQmluYXJ5KCkpIHtcbiAgICBpZiAoc2VsZi5rZXkgPT09IFwibGVmdFwiKSB7XG4gICAgICBwYXJlbnQucmVwbGFjZVdpdGgocGFyZW50Lm5vZGUucmlnaHQpO1xuICAgIH0gZWxzZSB7XG4gICAgICBwYXJlbnQucmVwbGFjZVdpdGgocGFyZW50Lm5vZGUubGVmdCk7XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xuICB9XG59LCBmdW5jdGlvbiAoc2VsZiwgcGFyZW50KSB7XG4gIGlmIChwYXJlbnQuaXNJZlN0YXRlbWVudCgpICYmIHNlbGYua2V5ID09PSBcImNvbnNlcXVlbnRcIiB8fCBzZWxmLmtleSA9PT0gXCJib2R5XCIgJiYgKHBhcmVudC5pc0xvb3AoKSB8fCBwYXJlbnQuaXNBcnJvd0Z1bmN0aW9uRXhwcmVzc2lvbigpKSkge1xuICAgIHNlbGYucmVwbGFjZVdpdGgoe1xuICAgICAgdHlwZTogXCJCbG9ja1N0YXRlbWVudFwiLFxuICAgICAgZGlyZWN0aXZlczogW10sXG4gICAgICBib2R5OiBbXVxuICAgIH0pO1xuICAgIHJldHVybiB0cnVlO1xuICB9XG59XTtcblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cmVtb3ZhbC1ob29rcy5qcy5tYXBcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@babel/traverse/lib/path/lib/removal-hooks.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@babel/traverse/lib/path/lib/virtual-types-validator.js":
/*!******************************************************************************!*\
  !*** ./node_modules/@babel/traverse/lib/path/lib/virtual-types-validator.js ***!
  \******************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports.isBindingIdentifier = isBindingIdentifier;\nexports.isBlockScoped = isBlockScoped;\nexports.isExpression = isExpression;\nexports.isFlow = isFlow;\nexports.isForAwaitStatement = isForAwaitStatement;\nexports.isGenerated = isGenerated;\nexports.isPure = isPure;\nexports.isReferenced = isReferenced;\nexports.isReferencedIdentifier = isReferencedIdentifier;\nexports.isReferencedMemberExpression = isReferencedMemberExpression;\nexports.isRestProperty = isRestProperty;\nexports.isScope = isScope;\nexports.isSpreadProperty = isSpreadProperty;\nexports.isStatement = isStatement;\nexports.isUser = isUser;\nexports.isVar = isVar;\nvar _t = __webpack_require__(/*! @babel/types */ \"(ssr)/./node_modules/@babel/types/lib/index.js\");\nconst {\n  isBinding,\n  isBlockScoped: nodeIsBlockScoped,\n  isExportDeclaration,\n  isExpression: nodeIsExpression,\n  isFlow: nodeIsFlow,\n  isForStatement,\n  isForXStatement,\n  isIdentifier,\n  isImportDeclaration,\n  isImportSpecifier,\n  isJSXIdentifier,\n  isJSXMemberExpression,\n  isMemberExpression,\n  isRestElement: nodeIsRestElement,\n  isReferenced: nodeIsReferenced,\n  isScope: nodeIsScope,\n  isStatement: nodeIsStatement,\n  isVar: nodeIsVar,\n  isVariableDeclaration,\n  react,\n  isForOfStatement\n} = _t;\nconst {\n  isCompatTag\n} = react;\nfunction isReferencedIdentifier(opts) {\n  const {\n    node,\n    parent\n  } = this;\n  if (isIdentifier(node, opts)) {\n    return nodeIsReferenced(node, parent, this.parentPath.parent);\n  } else if (isJSXIdentifier(node, opts)) {\n    if (!isJSXMemberExpression(parent) && isCompatTag(node.name)) return false;\n    return nodeIsReferenced(node, parent, this.parentPath.parent);\n  } else {\n    return false;\n  }\n}\nfunction isReferencedMemberExpression() {\n  const {\n    node,\n    parent\n  } = this;\n  return isMemberExpression(node) && nodeIsReferenced(node, parent);\n}\nfunction isBindingIdentifier() {\n  const {\n    node,\n    parent\n  } = this;\n  const grandparent = this.parentPath.parent;\n  return isIdentifier(node) && isBinding(node, parent, grandparent);\n}\nfunction isStatement() {\n  const {\n    node,\n    parent\n  } = this;\n  if (nodeIsStatement(node)) {\n    if (isVariableDeclaration(node)) {\n      if (isForXStatement(parent, {\n        left: node\n      })) return false;\n      if (isForStatement(parent, {\n        init: node\n      })) return false;\n    }\n    return true;\n  } else {\n    return false;\n  }\n}\nfunction isExpression() {\n  if (this.isIdentifier()) {\n    return this.isReferencedIdentifier();\n  } else {\n    return nodeIsExpression(this.node);\n  }\n}\nfunction isScope() {\n  return nodeIsScope(this.node, this.parent);\n}\nfunction isReferenced() {\n  return nodeIsReferenced(this.node, this.parent);\n}\nfunction isBlockScoped() {\n  return nodeIsBlockScoped(this.node);\n}\nfunction isVar() {\n  return nodeIsVar(this.node);\n}\nfunction isUser() {\n  var _this$node;\n  return !!((_this$node = this.node) != null && _this$node.loc);\n}\nfunction isGenerated() {\n  return !this.isUser();\n}\nfunction isPure(constantsOnly) {\n  return this.scope.isPure(this.node, constantsOnly);\n}\nfunction isFlow() {\n  const {\n    node\n  } = this;\n  if (nodeIsFlow(node)) {\n    return true;\n  } else if (isImportDeclaration(node)) {\n    return node.importKind === \"type\" || node.importKind === \"typeof\";\n  } else if (isExportDeclaration(node)) {\n    return node.exportKind === \"type\";\n  } else if (isImportSpecifier(node)) {\n    return node.importKind === \"type\" || node.importKind === \"typeof\";\n  } else {\n    return false;\n  }\n}\nfunction isRestProperty() {\n  var _this$parentPath;\n  return nodeIsRestElement(this.node) && ((_this$parentPath = this.parentPath) == null ? void 0 : _this$parentPath.isObjectPattern());\n}\nfunction isSpreadProperty() {\n  var _this$parentPath2;\n  return nodeIsRestElement(this.node) && ((_this$parentPath2 = this.parentPath) == null ? void 0 : _this$parentPath2.isObjectExpression());\n}\nfunction isForAwaitStatement() {\n  return isForOfStatement(this.node, {\n    await: true\n  });\n}\nexports.isExistentialTypeParam = function isExistentialTypeParam() {\n  throw new Error(\"`path.isExistentialTypeParam` has been renamed to `path.isExistsTypeAnnotation()` in Babel 7.\");\n};\nexports.isNumericLiteralTypeAnnotation = function isNumericLiteralTypeAnnotation() {\n  throw new Error(\"`path.isNumericLiteralTypeAnnotation()` has been renamed to `path.isNumberLiteralTypeAnnotation()` in Babel 7.\");\n};\n\n//# sourceMappingURL=virtual-types-validator.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGJhYmVsL3RyYXZlcnNlL2xpYi9wYXRoL2xpYi92aXJ0dWFsLXR5cGVzLXZhbGlkYXRvci5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYiw4Q0FBNkM7QUFDN0M7QUFDQSxDQUFDLEVBQUM7QUFDRiwyQkFBMkI7QUFDM0IscUJBQXFCO0FBQ3JCLG9CQUFvQjtBQUNwQixjQUFjO0FBQ2QsMkJBQTJCO0FBQzNCLG1CQUFtQjtBQUNuQixjQUFjO0FBQ2Qsb0JBQW9CO0FBQ3BCLDhCQUE4QjtBQUM5QixvQ0FBb0M7QUFDcEMsc0JBQXNCO0FBQ3RCLGVBQWU7QUFDZix3QkFBd0I7QUFDeEIsbUJBQW1CO0FBQ25CLGNBQWM7QUFDZCxhQUFhO0FBQ2IsU0FBUyxtQkFBTyxDQUFDLG9FQUFjO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQSxJQUFJO0FBQ0o7QUFDQSxJQUFJO0FBQ0o7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLDhCQUE4QjtBQUM5QjtBQUNBO0FBQ0Esc0NBQXNDO0FBQ3RDO0FBQ0E7O0FBRUEiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9yZXBvLXZpc3VhbGl6ZXIvLi9ub2RlX21vZHVsZXMvQGJhYmVsL3RyYXZlcnNlL2xpYi9wYXRoL2xpYi92aXJ0dWFsLXR5cGVzLXZhbGlkYXRvci5qcz9iMWFiIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5pc0JpbmRpbmdJZGVudGlmaWVyID0gaXNCaW5kaW5nSWRlbnRpZmllcjtcbmV4cG9ydHMuaXNCbG9ja1Njb3BlZCA9IGlzQmxvY2tTY29wZWQ7XG5leHBvcnRzLmlzRXhwcmVzc2lvbiA9IGlzRXhwcmVzc2lvbjtcbmV4cG9ydHMuaXNGbG93ID0gaXNGbG93O1xuZXhwb3J0cy5pc0ZvckF3YWl0U3RhdGVtZW50ID0gaXNGb3JBd2FpdFN0YXRlbWVudDtcbmV4cG9ydHMuaXNHZW5lcmF0ZWQgPSBpc0dlbmVyYXRlZDtcbmV4cG9ydHMuaXNQdXJlID0gaXNQdXJlO1xuZXhwb3J0cy5pc1JlZmVyZW5jZWQgPSBpc1JlZmVyZW5jZWQ7XG5leHBvcnRzLmlzUmVmZXJlbmNlZElkZW50aWZpZXIgPSBpc1JlZmVyZW5jZWRJZGVudGlmaWVyO1xuZXhwb3J0cy5pc1JlZmVyZW5jZWRNZW1iZXJFeHByZXNzaW9uID0gaXNSZWZlcmVuY2VkTWVtYmVyRXhwcmVzc2lvbjtcbmV4cG9ydHMuaXNSZXN0UHJvcGVydHkgPSBpc1Jlc3RQcm9wZXJ0eTtcbmV4cG9ydHMuaXNTY29wZSA9IGlzU2NvcGU7XG5leHBvcnRzLmlzU3ByZWFkUHJvcGVydHkgPSBpc1NwcmVhZFByb3BlcnR5O1xuZXhwb3J0cy5pc1N0YXRlbWVudCA9IGlzU3RhdGVtZW50O1xuZXhwb3J0cy5pc1VzZXIgPSBpc1VzZXI7XG5leHBvcnRzLmlzVmFyID0gaXNWYXI7XG52YXIgX3QgPSByZXF1aXJlKFwiQGJhYmVsL3R5cGVzXCIpO1xuY29uc3Qge1xuICBpc0JpbmRpbmcsXG4gIGlzQmxvY2tTY29wZWQ6IG5vZGVJc0Jsb2NrU2NvcGVkLFxuICBpc0V4cG9ydERlY2xhcmF0aW9uLFxuICBpc0V4cHJlc3Npb246IG5vZGVJc0V4cHJlc3Npb24sXG4gIGlzRmxvdzogbm9kZUlzRmxvdyxcbiAgaXNGb3JTdGF0ZW1lbnQsXG4gIGlzRm9yWFN0YXRlbWVudCxcbiAgaXNJZGVudGlmaWVyLFxuICBpc0ltcG9ydERlY2xhcmF0aW9uLFxuICBpc0ltcG9ydFNwZWNpZmllcixcbiAgaXNKU1hJZGVudGlmaWVyLFxuICBpc0pTWE1lbWJlckV4cHJlc3Npb24sXG4gIGlzTWVtYmVyRXhwcmVzc2lvbixcbiAgaXNSZXN0RWxlbWVudDogbm9kZUlzUmVzdEVsZW1lbnQsXG4gIGlzUmVmZXJlbmNlZDogbm9kZUlzUmVmZXJlbmNlZCxcbiAgaXNTY29wZTogbm9kZUlzU2NvcGUsXG4gIGlzU3RhdGVtZW50OiBub2RlSXNTdGF0ZW1lbnQsXG4gIGlzVmFyOiBub2RlSXNWYXIsXG4gIGlzVmFyaWFibGVEZWNsYXJhdGlvbixcbiAgcmVhY3QsXG4gIGlzRm9yT2ZTdGF0ZW1lbnRcbn0gPSBfdDtcbmNvbnN0IHtcbiAgaXNDb21wYXRUYWdcbn0gPSByZWFjdDtcbmZ1bmN0aW9uIGlzUmVmZXJlbmNlZElkZW50aWZpZXIob3B0cykge1xuICBjb25zdCB7XG4gICAgbm9kZSxcbiAgICBwYXJlbnRcbiAgfSA9IHRoaXM7XG4gIGlmIChpc0lkZW50aWZpZXIobm9kZSwgb3B0cykpIHtcbiAgICByZXR1cm4gbm9kZUlzUmVmZXJlbmNlZChub2RlLCBwYXJlbnQsIHRoaXMucGFyZW50UGF0aC5wYXJlbnQpO1xuICB9IGVsc2UgaWYgKGlzSlNYSWRlbnRpZmllcihub2RlLCBvcHRzKSkge1xuICAgIGlmICghaXNKU1hNZW1iZXJFeHByZXNzaW9uKHBhcmVudCkgJiYgaXNDb21wYXRUYWcobm9kZS5uYW1lKSkgcmV0dXJuIGZhbHNlO1xuICAgIHJldHVybiBub2RlSXNSZWZlcmVuY2VkKG5vZGUsIHBhcmVudCwgdGhpcy5wYXJlbnRQYXRoLnBhcmVudCk7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG59XG5mdW5jdGlvbiBpc1JlZmVyZW5jZWRNZW1iZXJFeHByZXNzaW9uKCkge1xuICBjb25zdCB7XG4gICAgbm9kZSxcbiAgICBwYXJlbnRcbiAgfSA9IHRoaXM7XG4gIHJldHVybiBpc01lbWJlckV4cHJlc3Npb24obm9kZSkgJiYgbm9kZUlzUmVmZXJlbmNlZChub2RlLCBwYXJlbnQpO1xufVxuZnVuY3Rpb24gaXNCaW5kaW5nSWRlbnRpZmllcigpIHtcbiAgY29uc3Qge1xuICAgIG5vZGUsXG4gICAgcGFyZW50XG4gIH0gPSB0aGlzO1xuICBjb25zdCBncmFuZHBhcmVudCA9IHRoaXMucGFyZW50UGF0aC5wYXJlbnQ7XG4gIHJldHVybiBpc0lkZW50aWZpZXIobm9kZSkgJiYgaXNCaW5kaW5nKG5vZGUsIHBhcmVudCwgZ3JhbmRwYXJlbnQpO1xufVxuZnVuY3Rpb24gaXNTdGF0ZW1lbnQoKSB7XG4gIGNvbnN0IHtcbiAgICBub2RlLFxuICAgIHBhcmVudFxuICB9ID0gdGhpcztcbiAgaWYgKG5vZGVJc1N0YXRlbWVudChub2RlKSkge1xuICAgIGlmIChpc1ZhcmlhYmxlRGVjbGFyYXRpb24obm9kZSkpIHtcbiAgICAgIGlmIChpc0ZvclhTdGF0ZW1lbnQocGFyZW50LCB7XG4gICAgICAgIGxlZnQ6IG5vZGVcbiAgICAgIH0pKSByZXR1cm4gZmFsc2U7XG4gICAgICBpZiAoaXNGb3JTdGF0ZW1lbnQocGFyZW50LCB7XG4gICAgICAgIGluaXQ6IG5vZGVcbiAgICAgIH0pKSByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxufVxuZnVuY3Rpb24gaXNFeHByZXNzaW9uKCkge1xuICBpZiAodGhpcy5pc0lkZW50aWZpZXIoKSkge1xuICAgIHJldHVybiB0aGlzLmlzUmVmZXJlbmNlZElkZW50aWZpZXIoKTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gbm9kZUlzRXhwcmVzc2lvbih0aGlzLm5vZGUpO1xuICB9XG59XG5mdW5jdGlvbiBpc1Njb3BlKCkge1xuICByZXR1cm4gbm9kZUlzU2NvcGUodGhpcy5ub2RlLCB0aGlzLnBhcmVudCk7XG59XG5mdW5jdGlvbiBpc1JlZmVyZW5jZWQoKSB7XG4gIHJldHVybiBub2RlSXNSZWZlcmVuY2VkKHRoaXMubm9kZSwgdGhpcy5wYXJlbnQpO1xufVxuZnVuY3Rpb24gaXNCbG9ja1Njb3BlZCgpIHtcbiAgcmV0dXJuIG5vZGVJc0Jsb2NrU2NvcGVkKHRoaXMubm9kZSk7XG59XG5mdW5jdGlvbiBpc1ZhcigpIHtcbiAgcmV0dXJuIG5vZGVJc1Zhcih0aGlzLm5vZGUpO1xufVxuZnVuY3Rpb24gaXNVc2VyKCkge1xuICB2YXIgX3RoaXMkbm9kZTtcbiAgcmV0dXJuICEhKChfdGhpcyRub2RlID0gdGhpcy5ub2RlKSAhPSBudWxsICYmIF90aGlzJG5vZGUubG9jKTtcbn1cbmZ1bmN0aW9uIGlzR2VuZXJhdGVkKCkge1xuICByZXR1cm4gIXRoaXMuaXNVc2VyKCk7XG59XG5mdW5jdGlvbiBpc1B1cmUoY29uc3RhbnRzT25seSkge1xuICByZXR1cm4gdGhpcy5zY29wZS5pc1B1cmUodGhpcy5ub2RlLCBjb25zdGFudHNPbmx5KTtcbn1cbmZ1bmN0aW9uIGlzRmxvdygpIHtcbiAgY29uc3Qge1xuICAgIG5vZGVcbiAgfSA9IHRoaXM7XG4gIGlmIChub2RlSXNGbG93KG5vZGUpKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH0gZWxzZSBpZiAoaXNJbXBvcnREZWNsYXJhdGlvbihub2RlKSkge1xuICAgIHJldHVybiBub2RlLmltcG9ydEtpbmQgPT09IFwidHlwZVwiIHx8IG5vZGUuaW1wb3J0S2luZCA9PT0gXCJ0eXBlb2ZcIjtcbiAgfSBlbHNlIGlmIChpc0V4cG9ydERlY2xhcmF0aW9uKG5vZGUpKSB7XG4gICAgcmV0dXJuIG5vZGUuZXhwb3J0S2luZCA9PT0gXCJ0eXBlXCI7XG4gIH0gZWxzZSBpZiAoaXNJbXBvcnRTcGVjaWZpZXIobm9kZSkpIHtcbiAgICByZXR1cm4gbm9kZS5pbXBvcnRLaW5kID09PSBcInR5cGVcIiB8fCBub2RlLmltcG9ydEtpbmQgPT09IFwidHlwZW9mXCI7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG59XG5mdW5jdGlvbiBpc1Jlc3RQcm9wZXJ0eSgpIHtcbiAgdmFyIF90aGlzJHBhcmVudFBhdGg7XG4gIHJldHVybiBub2RlSXNSZXN0RWxlbWVudCh0aGlzLm5vZGUpICYmICgoX3RoaXMkcGFyZW50UGF0aCA9IHRoaXMucGFyZW50UGF0aCkgPT0gbnVsbCA/IHZvaWQgMCA6IF90aGlzJHBhcmVudFBhdGguaXNPYmplY3RQYXR0ZXJuKCkpO1xufVxuZnVuY3Rpb24gaXNTcHJlYWRQcm9wZXJ0eSgpIHtcbiAgdmFyIF90aGlzJHBhcmVudFBhdGgyO1xuICByZXR1cm4gbm9kZUlzUmVzdEVsZW1lbnQodGhpcy5ub2RlKSAmJiAoKF90aGlzJHBhcmVudFBhdGgyID0gdGhpcy5wYXJlbnRQYXRoKSA9PSBudWxsID8gdm9pZCAwIDogX3RoaXMkcGFyZW50UGF0aDIuaXNPYmplY3RFeHByZXNzaW9uKCkpO1xufVxuZnVuY3Rpb24gaXNGb3JBd2FpdFN0YXRlbWVudCgpIHtcbiAgcmV0dXJuIGlzRm9yT2ZTdGF0ZW1lbnQodGhpcy5ub2RlLCB7XG4gICAgYXdhaXQ6IHRydWVcbiAgfSk7XG59XG5leHBvcnRzLmlzRXhpc3RlbnRpYWxUeXBlUGFyYW0gPSBmdW5jdGlvbiBpc0V4aXN0ZW50aWFsVHlwZVBhcmFtKCkge1xuICB0aHJvdyBuZXcgRXJyb3IoXCJgcGF0aC5pc0V4aXN0ZW50aWFsVHlwZVBhcmFtYCBoYXMgYmVlbiByZW5hbWVkIHRvIGBwYXRoLmlzRXhpc3RzVHlwZUFubm90YXRpb24oKWAgaW4gQmFiZWwgNy5cIik7XG59O1xuZXhwb3J0cy5pc051bWVyaWNMaXRlcmFsVHlwZUFubm90YXRpb24gPSBmdW5jdGlvbiBpc051bWVyaWNMaXRlcmFsVHlwZUFubm90YXRpb24oKSB7XG4gIHRocm93IG5ldyBFcnJvcihcImBwYXRoLmlzTnVtZXJpY0xpdGVyYWxUeXBlQW5ub3RhdGlvbigpYCBoYXMgYmVlbiByZW5hbWVkIHRvIGBwYXRoLmlzTnVtYmVyTGl0ZXJhbFR5cGVBbm5vdGF0aW9uKClgIGluIEJhYmVsIDcuXCIpO1xufTtcblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dmlydHVhbC10eXBlcy12YWxpZGF0b3IuanMubWFwXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@babel/traverse/lib/path/lib/virtual-types-validator.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@babel/traverse/lib/path/lib/virtual-types.js":
/*!********************************************************************!*\
  !*** ./node_modules/@babel/traverse/lib/path/lib/virtual-types.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports.Var = exports.User = exports.Statement = exports.SpreadProperty = exports.Scope = exports.RestProperty = exports.ReferencedMemberExpression = exports.ReferencedIdentifier = exports.Referenced = exports.Pure = exports.NumericLiteralTypeAnnotation = exports.Generated = exports.ForAwaitStatement = exports.Flow = exports.Expression = exports.ExistentialTypeParam = exports.BlockScoped = exports.BindingIdentifier = void 0;\nconst ReferencedIdentifier = exports.ReferencedIdentifier = [\"Identifier\", \"JSXIdentifier\"];\nconst ReferencedMemberExpression = exports.ReferencedMemberExpression = [\"MemberExpression\"];\nconst BindingIdentifier = exports.BindingIdentifier = [\"Identifier\"];\nconst Statement = exports.Statement = [\"Statement\"];\nconst Expression = exports.Expression = [\"Expression\"];\nconst Scope = exports.Scope = [\"Scopable\", \"Pattern\"];\nconst Referenced = exports.Referenced = null;\nconst BlockScoped = exports.BlockScoped = [\"FunctionDeclaration\", \"ClassDeclaration\", \"VariableDeclaration\"];\nconst Var = exports.Var = [\"VariableDeclaration\"];\nconst User = exports.User = null;\nconst Generated = exports.Generated = null;\nconst Pure = exports.Pure = null;\nconst Flow = exports.Flow = [\"Flow\", \"ImportDeclaration\", \"ExportDeclaration\", \"ImportSpecifier\"];\nconst RestProperty = exports.RestProperty = [\"RestElement\"];\nconst SpreadProperty = exports.SpreadProperty = [\"RestElement\"];\nconst ExistentialTypeParam = exports.ExistentialTypeParam = [\"ExistsTypeAnnotation\"];\nconst NumericLiteralTypeAnnotation = exports.NumericLiteralTypeAnnotation = [\"NumberLiteralTypeAnnotation\"];\nconst ForAwaitStatement = exports.ForAwaitStatement = [\"ForOfStatement\"];\n\n//# sourceMappingURL=virtual-types.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGJhYmVsL3RyYXZlcnNlL2xpYi9wYXRoL2xpYi92aXJ0dWFsLXR5cGVzLmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViLDhDQUE2QztBQUM3QztBQUNBLENBQUMsRUFBQztBQUNGLFdBQVcsR0FBRyxZQUFZLEdBQUcsaUJBQWlCLEdBQUcsc0JBQXNCLEdBQUcsYUFBYSxHQUFHLG9CQUFvQixHQUFHLGtDQUFrQyxHQUFHLDRCQUE0QixHQUFHLGtCQUFrQixHQUFHLFlBQVksR0FBRyxvQ0FBb0MsR0FBRyxpQkFBaUIsR0FBRyx5QkFBeUIsR0FBRyxZQUFZLEdBQUcsa0JBQWtCLEdBQUcsNEJBQTRCLEdBQUcsbUJBQW1CLEdBQUcseUJBQXlCO0FBQ2xhLDZCQUE2Qiw0QkFBNEI7QUFDekQsbUNBQW1DLGtDQUFrQztBQUNyRSwwQkFBMEIseUJBQXlCO0FBQ25ELGtCQUFrQixpQkFBaUI7QUFDbkMsbUJBQW1CLGtCQUFrQjtBQUNyQyxjQUFjLGFBQWE7QUFDM0IsbUJBQW1CLGtCQUFrQjtBQUNyQyxvQkFBb0IsbUJBQW1CO0FBQ3ZDLFlBQVksV0FBVztBQUN2QixhQUFhLFlBQVk7QUFDekIsa0JBQWtCLGlCQUFpQjtBQUNuQyxhQUFhLFlBQVk7QUFDekIsYUFBYSxZQUFZO0FBQ3pCLHFCQUFxQixvQkFBb0I7QUFDekMsdUJBQXVCLHNCQUFzQjtBQUM3Qyw2QkFBNkIsNEJBQTRCO0FBQ3pELHFDQUFxQyxvQ0FBb0M7QUFDekUsMEJBQTBCLHlCQUF5Qjs7QUFFbkQiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9yZXBvLXZpc3VhbGl6ZXIvLi9ub2RlX21vZHVsZXMvQGJhYmVsL3RyYXZlcnNlL2xpYi9wYXRoL2xpYi92aXJ0dWFsLXR5cGVzLmpzPzIxMzAiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLlZhciA9IGV4cG9ydHMuVXNlciA9IGV4cG9ydHMuU3RhdGVtZW50ID0gZXhwb3J0cy5TcHJlYWRQcm9wZXJ0eSA9IGV4cG9ydHMuU2NvcGUgPSBleHBvcnRzLlJlc3RQcm9wZXJ0eSA9IGV4cG9ydHMuUmVmZXJlbmNlZE1lbWJlckV4cHJlc3Npb24gPSBleHBvcnRzLlJlZmVyZW5jZWRJZGVudGlmaWVyID0gZXhwb3J0cy5SZWZlcmVuY2VkID0gZXhwb3J0cy5QdXJlID0gZXhwb3J0cy5OdW1lcmljTGl0ZXJhbFR5cGVBbm5vdGF0aW9uID0gZXhwb3J0cy5HZW5lcmF0ZWQgPSBleHBvcnRzLkZvckF3YWl0U3RhdGVtZW50ID0gZXhwb3J0cy5GbG93ID0gZXhwb3J0cy5FeHByZXNzaW9uID0gZXhwb3J0cy5FeGlzdGVudGlhbFR5cGVQYXJhbSA9IGV4cG9ydHMuQmxvY2tTY29wZWQgPSBleHBvcnRzLkJpbmRpbmdJZGVudGlmaWVyID0gdm9pZCAwO1xuY29uc3QgUmVmZXJlbmNlZElkZW50aWZpZXIgPSBleHBvcnRzLlJlZmVyZW5jZWRJZGVudGlmaWVyID0gW1wiSWRlbnRpZmllclwiLCBcIkpTWElkZW50aWZpZXJcIl07XG5jb25zdCBSZWZlcmVuY2VkTWVtYmVyRXhwcmVzc2lvbiA9IGV4cG9ydHMuUmVmZXJlbmNlZE1lbWJlckV4cHJlc3Npb24gPSBbXCJNZW1iZXJFeHByZXNzaW9uXCJdO1xuY29uc3QgQmluZGluZ0lkZW50aWZpZXIgPSBleHBvcnRzLkJpbmRpbmdJZGVudGlmaWVyID0gW1wiSWRlbnRpZmllclwiXTtcbmNvbnN0IFN0YXRlbWVudCA9IGV4cG9ydHMuU3RhdGVtZW50ID0gW1wiU3RhdGVtZW50XCJdO1xuY29uc3QgRXhwcmVzc2lvbiA9IGV4cG9ydHMuRXhwcmVzc2lvbiA9IFtcIkV4cHJlc3Npb25cIl07XG5jb25zdCBTY29wZSA9IGV4cG9ydHMuU2NvcGUgPSBbXCJTY29wYWJsZVwiLCBcIlBhdHRlcm5cIl07XG5jb25zdCBSZWZlcmVuY2VkID0gZXhwb3J0cy5SZWZlcmVuY2VkID0gbnVsbDtcbmNvbnN0IEJsb2NrU2NvcGVkID0gZXhwb3J0cy5CbG9ja1Njb3BlZCA9IFtcIkZ1bmN0aW9uRGVjbGFyYXRpb25cIiwgXCJDbGFzc0RlY2xhcmF0aW9uXCIsIFwiVmFyaWFibGVEZWNsYXJhdGlvblwiXTtcbmNvbnN0IFZhciA9IGV4cG9ydHMuVmFyID0gW1wiVmFyaWFibGVEZWNsYXJhdGlvblwiXTtcbmNvbnN0IFVzZXIgPSBleHBvcnRzLlVzZXIgPSBudWxsO1xuY29uc3QgR2VuZXJhdGVkID0gZXhwb3J0cy5HZW5lcmF0ZWQgPSBudWxsO1xuY29uc3QgUHVyZSA9IGV4cG9ydHMuUHVyZSA9IG51bGw7XG5jb25zdCBGbG93ID0gZXhwb3J0cy5GbG93ID0gW1wiRmxvd1wiLCBcIkltcG9ydERlY2xhcmF0aW9uXCIsIFwiRXhwb3J0RGVjbGFyYXRpb25cIiwgXCJJbXBvcnRTcGVjaWZpZXJcIl07XG5jb25zdCBSZXN0UHJvcGVydHkgPSBleHBvcnRzLlJlc3RQcm9wZXJ0eSA9IFtcIlJlc3RFbGVtZW50XCJdO1xuY29uc3QgU3ByZWFkUHJvcGVydHkgPSBleHBvcnRzLlNwcmVhZFByb3BlcnR5ID0gW1wiUmVzdEVsZW1lbnRcIl07XG5jb25zdCBFeGlzdGVudGlhbFR5cGVQYXJhbSA9IGV4cG9ydHMuRXhpc3RlbnRpYWxUeXBlUGFyYW0gPSBbXCJFeGlzdHNUeXBlQW5ub3RhdGlvblwiXTtcbmNvbnN0IE51bWVyaWNMaXRlcmFsVHlwZUFubm90YXRpb24gPSBleHBvcnRzLk51bWVyaWNMaXRlcmFsVHlwZUFubm90YXRpb24gPSBbXCJOdW1iZXJMaXRlcmFsVHlwZUFubm90YXRpb25cIl07XG5jb25zdCBGb3JBd2FpdFN0YXRlbWVudCA9IGV4cG9ydHMuRm9yQXdhaXRTdGF0ZW1lbnQgPSBbXCJGb3JPZlN0YXRlbWVudFwiXTtcblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dmlydHVhbC10eXBlcy5qcy5tYXBcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@babel/traverse/lib/path/lib/virtual-types.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@babel/traverse/lib/path/modification.js":
/*!***************************************************************!*\
  !*** ./node_modules/@babel/traverse/lib/path/modification.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports._containerInsert = _containerInsert;\nexports._containerInsertAfter = _containerInsertAfter;\nexports._containerInsertBefore = _containerInsertBefore;\nexports._verifyNodeList = _verifyNodeList;\nexports.insertAfter = insertAfter;\nexports.insertBefore = insertBefore;\nexports.pushContainer = pushContainer;\nexports.unshiftContainer = unshiftContainer;\nexports.updateSiblingKeys = updateSiblingKeys;\nvar _cache = __webpack_require__(/*! ../cache.js */ \"(ssr)/./node_modules/@babel/traverse/lib/cache.js\");\nvar _index = __webpack_require__(/*! ./index.js */ \"(ssr)/./node_modules/@babel/traverse/lib/path/index.js\");\nvar _context = __webpack_require__(/*! ./context.js */ \"(ssr)/./node_modules/@babel/traverse/lib/path/context.js\");\nvar _removal = __webpack_require__(/*! ./removal.js */ \"(ssr)/./node_modules/@babel/traverse/lib/path/removal.js\");\nvar _t = __webpack_require__(/*! @babel/types */ \"(ssr)/./node_modules/@babel/types/lib/index.js\");\nvar _hoister = __webpack_require__(/*! ./lib/hoister.js */ \"(ssr)/./node_modules/@babel/traverse/lib/path/lib/hoister.js\");\nconst {\n  arrowFunctionExpression,\n  assertExpression,\n  assignmentExpression,\n  blockStatement,\n  callExpression,\n  cloneNode,\n  expressionStatement,\n  isAssignmentExpression,\n  isCallExpression,\n  isExportNamedDeclaration,\n  isExpression,\n  isIdentifier,\n  isSequenceExpression,\n  isSuper,\n  thisExpression\n} = _t;\nfunction insertBefore(nodes_) {\n  _removal._assertUnremoved.call(this);\n  const nodes = _verifyNodeList.call(this, nodes_);\n  const {\n    parentPath,\n    parent\n  } = this;\n  if (parentPath.isExpressionStatement() || parentPath.isLabeledStatement() || isExportNamedDeclaration(parent) || parentPath.isExportDefaultDeclaration() && this.isDeclaration()) {\n    return parentPath.insertBefore(nodes);\n  } else if (this.isNodeType(\"Expression\") && !this.isJSXElement() || parentPath.isForStatement() && this.key === \"init\") {\n    if (this.node) nodes.push(this.node);\n    return this.replaceExpressionWithStatements(nodes);\n  } else if (Array.isArray(this.container)) {\n    return _containerInsertBefore.call(this, nodes);\n  } else if (this.isStatementOrBlock()) {\n    const node = this.node;\n    const shouldInsertCurrentNode = node && (!this.isExpressionStatement() || node.expression != null);\n    const [blockPath] = this.replaceWith(blockStatement(shouldInsertCurrentNode ? [node] : []));\n    return blockPath.unshiftContainer(\"body\", nodes);\n  } else {\n    throw new Error(\"We don't know what to do with this node type. \" + \"We were previously a Statement but we can't fit in here?\");\n  }\n}\nfunction _containerInsert(from, nodes) {\n  updateSiblingKeys.call(this, from, nodes.length);\n  const paths = [];\n  this.container.splice(from, 0, ...nodes);\n  for (let i = 0; i < nodes.length; i++) {\n    var _this$context;\n    const to = from + i;\n    const path = this.getSibling(to);\n    paths.push(path);\n    if ((_this$context = this.context) != null && _this$context.queue) {\n      _context.pushContext.call(path, this.context);\n    }\n  }\n  const contexts = _context._getQueueContexts.call(this);\n  for (const path of paths) {\n    _context.setScope.call(path);\n    path.debug(\"Inserted.\");\n    for (const context of contexts) {\n      context.maybeQueue(path, true);\n    }\n  }\n  return paths;\n}\nfunction _containerInsertBefore(nodes) {\n  return _containerInsert.call(this, this.key, nodes);\n}\nfunction _containerInsertAfter(nodes) {\n  return _containerInsert.call(this, this.key + 1, nodes);\n}\nconst last = arr => arr[arr.length - 1];\nfunction isHiddenInSequenceExpression(path) {\n  return isSequenceExpression(path.parent) && (last(path.parent.expressions) !== path.node || isHiddenInSequenceExpression(path.parentPath));\n}\nfunction isAlmostConstantAssignment(node, scope) {\n  if (!isAssignmentExpression(node) || !isIdentifier(node.left)) {\n    return false;\n  }\n  const blockScope = scope.getBlockParent();\n  return blockScope.hasOwnBinding(node.left.name) && blockScope.getOwnBinding(node.left.name).constantViolations.length <= 1;\n}\nfunction insertAfter(nodes_) {\n  _removal._assertUnremoved.call(this);\n  if (this.isSequenceExpression()) {\n    return last(this.get(\"expressions\")).insertAfter(nodes_);\n  }\n  const nodes = _verifyNodeList.call(this, nodes_);\n  const {\n    parentPath,\n    parent\n  } = this;\n  if (parentPath.isExpressionStatement() || parentPath.isLabeledStatement() || isExportNamedDeclaration(parent) || parentPath.isExportDefaultDeclaration() && this.isDeclaration()) {\n    return parentPath.insertAfter(nodes.map(node => {\n      return isExpression(node) ? expressionStatement(node) : node;\n    }));\n  } else if (this.isNodeType(\"Expression\") && !this.isJSXElement() && !parentPath.isJSXElement() || parentPath.isForStatement() && this.key === \"init\") {\n    const self = this;\n    if (self.node) {\n      const node = self.node;\n      let {\n        scope\n      } = this;\n      if (scope.path.isPattern()) {\n        assertExpression(node);\n        self.replaceWith(callExpression(arrowFunctionExpression([], node), []));\n        self.get(\"callee.body\").insertAfter(nodes);\n        return [self];\n      }\n      if (isHiddenInSequenceExpression(self)) {\n        nodes.unshift(node);\n      } else if (isCallExpression(node) && isSuper(node.callee)) {\n        nodes.unshift(node);\n        nodes.push(thisExpression());\n      } else if (isAlmostConstantAssignment(node, scope)) {\n        nodes.unshift(node);\n        nodes.push(cloneNode(node.left));\n      } else if (scope.isPure(node, true)) {\n        nodes.push(node);\n      } else {\n        if (parentPath.isMethod({\n          computed: true,\n          key: node\n        })) {\n          scope = scope.parent;\n        }\n        const temp = scope.generateDeclaredUidIdentifier();\n        nodes.unshift(expressionStatement(assignmentExpression(\"=\", cloneNode(temp), node)));\n        nodes.push(expressionStatement(cloneNode(temp)));\n      }\n    }\n    return this.replaceExpressionWithStatements(nodes);\n  } else if (Array.isArray(this.container)) {\n    return _containerInsertAfter.call(this, nodes);\n  } else if (this.isStatementOrBlock()) {\n    const node = this.node;\n    const shouldInsertCurrentNode = node && (!this.isExpressionStatement() || node.expression != null);\n    const [blockPath] = this.replaceWith(blockStatement(shouldInsertCurrentNode ? [node] : []));\n    return blockPath.pushContainer(\"body\", nodes);\n  } else {\n    throw new Error(\"We don't know what to do with this node type. \" + \"We were previously a Statement but we can't fit in here?\");\n  }\n}\nfunction updateSiblingKeys(fromIndex, incrementBy) {\n  if (!this.parent) return;\n  const paths = (0, _cache.getCachedPaths)(this);\n  if (!paths) return;\n  for (const [, path] of paths) {\n    if (typeof path.key === \"number\" && path.container === this.container && path.key >= fromIndex) {\n      path.key += incrementBy;\n    }\n  }\n}\nfunction _verifyNodeList(nodes) {\n  if (!nodes) {\n    return [];\n  }\n  if (!Array.isArray(nodes)) {\n    nodes = [nodes];\n  }\n  for (let i = 0; i < nodes.length; i++) {\n    const node = nodes[i];\n    let msg;\n    if (!node) {\n      msg = \"has falsy node\";\n    } else if (typeof node !== \"object\") {\n      msg = \"contains a non-object node\";\n    } else if (!node.type) {\n      msg = \"without a type\";\n    } else if (node instanceof _index.default) {\n      msg = \"has a NodePath when it expected a raw object\";\n    }\n    if (msg) {\n      const type = Array.isArray(node) ? \"array\" : typeof node;\n      throw new Error(`Node list ${msg} with the index of ${i} and type of ${type}`);\n    }\n  }\n  return nodes;\n}\nfunction unshiftContainer(listKey, nodes) {\n  _removal._assertUnremoved.call(this);\n  const verifiedNodes = _verifyNodeList.call(this, nodes);\n  const container = this.node[listKey];\n  const path = _index.default.get({\n    parentPath: this,\n    parent: this.node,\n    container,\n    listKey,\n    key: 0\n  }).setContext(this.context);\n  return _containerInsertBefore.call(path, verifiedNodes);\n}\nfunction pushContainer(listKey, nodes) {\n  _removal._assertUnremoved.call(this);\n  const verifiedNodes = _verifyNodeList.call(this, nodes);\n  const container = this.node[listKey];\n  const path = _index.default.get({\n    parentPath: this,\n    parent: this.node,\n    container,\n    listKey,\n    key: container.length\n  }).setContext(this.context);\n  return path.replaceWithMultiple(verifiedNodes);\n}\nexports.hoist = function hoist(scope = this.scope) {\n  const hoister = new _hoister.default(this, scope);\n  return hoister.run();\n};\n\n//# sourceMappingURL=modification.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGJhYmVsL3RyYXZlcnNlL2xpYi9wYXRoL21vZGlmaWNhdGlvbi5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYiw4Q0FBNkM7QUFDN0M7QUFDQSxDQUFDLEVBQUM7QUFDRix3QkFBd0I7QUFDeEIsNkJBQTZCO0FBQzdCLDhCQUE4QjtBQUM5Qix1QkFBdUI7QUFDdkIsbUJBQW1CO0FBQ25CLG9CQUFvQjtBQUNwQixxQkFBcUI7QUFDckIsd0JBQXdCO0FBQ3hCLHlCQUF5QjtBQUN6QixhQUFhLG1CQUFPLENBQUMsc0VBQWE7QUFDbEMsYUFBYSxtQkFBTyxDQUFDLDBFQUFZO0FBQ2pDLGVBQWUsbUJBQU8sQ0FBQyw4RUFBYztBQUNyQyxlQUFlLG1CQUFPLENBQUMsOEVBQWM7QUFDckMsU0FBUyxtQkFBTyxDQUFDLG9FQUFjO0FBQy9CLGVBQWUsbUJBQU8sQ0FBQyxzRkFBa0I7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixrQkFBa0I7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixrQkFBa0I7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUMsS0FBSyxvQkFBb0IsR0FBRyxjQUFjLEtBQUs7QUFDbEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7O0FBRUEiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9yZXBvLXZpc3VhbGl6ZXIvLi9ub2RlX21vZHVsZXMvQGJhYmVsL3RyYXZlcnNlL2xpYi9wYXRoL21vZGlmaWNhdGlvbi5qcz9mYmE3Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5fY29udGFpbmVySW5zZXJ0ID0gX2NvbnRhaW5lckluc2VydDtcbmV4cG9ydHMuX2NvbnRhaW5lckluc2VydEFmdGVyID0gX2NvbnRhaW5lckluc2VydEFmdGVyO1xuZXhwb3J0cy5fY29udGFpbmVySW5zZXJ0QmVmb3JlID0gX2NvbnRhaW5lckluc2VydEJlZm9yZTtcbmV4cG9ydHMuX3ZlcmlmeU5vZGVMaXN0ID0gX3ZlcmlmeU5vZGVMaXN0O1xuZXhwb3J0cy5pbnNlcnRBZnRlciA9IGluc2VydEFmdGVyO1xuZXhwb3J0cy5pbnNlcnRCZWZvcmUgPSBpbnNlcnRCZWZvcmU7XG5leHBvcnRzLnB1c2hDb250YWluZXIgPSBwdXNoQ29udGFpbmVyO1xuZXhwb3J0cy51bnNoaWZ0Q29udGFpbmVyID0gdW5zaGlmdENvbnRhaW5lcjtcbmV4cG9ydHMudXBkYXRlU2libGluZ0tleXMgPSB1cGRhdGVTaWJsaW5nS2V5cztcbnZhciBfY2FjaGUgPSByZXF1aXJlKFwiLi4vY2FjaGUuanNcIik7XG52YXIgX2luZGV4ID0gcmVxdWlyZShcIi4vaW5kZXguanNcIik7XG52YXIgX2NvbnRleHQgPSByZXF1aXJlKFwiLi9jb250ZXh0LmpzXCIpO1xudmFyIF9yZW1vdmFsID0gcmVxdWlyZShcIi4vcmVtb3ZhbC5qc1wiKTtcbnZhciBfdCA9IHJlcXVpcmUoXCJAYmFiZWwvdHlwZXNcIik7XG52YXIgX2hvaXN0ZXIgPSByZXF1aXJlKFwiLi9saWIvaG9pc3Rlci5qc1wiKTtcbmNvbnN0IHtcbiAgYXJyb3dGdW5jdGlvbkV4cHJlc3Npb24sXG4gIGFzc2VydEV4cHJlc3Npb24sXG4gIGFzc2lnbm1lbnRFeHByZXNzaW9uLFxuICBibG9ja1N0YXRlbWVudCxcbiAgY2FsbEV4cHJlc3Npb24sXG4gIGNsb25lTm9kZSxcbiAgZXhwcmVzc2lvblN0YXRlbWVudCxcbiAgaXNBc3NpZ25tZW50RXhwcmVzc2lvbixcbiAgaXNDYWxsRXhwcmVzc2lvbixcbiAgaXNFeHBvcnROYW1lZERlY2xhcmF0aW9uLFxuICBpc0V4cHJlc3Npb24sXG4gIGlzSWRlbnRpZmllcixcbiAgaXNTZXF1ZW5jZUV4cHJlc3Npb24sXG4gIGlzU3VwZXIsXG4gIHRoaXNFeHByZXNzaW9uXG59ID0gX3Q7XG5mdW5jdGlvbiBpbnNlcnRCZWZvcmUobm9kZXNfKSB7XG4gIF9yZW1vdmFsLl9hc3NlcnRVbnJlbW92ZWQuY2FsbCh0aGlzKTtcbiAgY29uc3Qgbm9kZXMgPSBfdmVyaWZ5Tm9kZUxpc3QuY2FsbCh0aGlzLCBub2Rlc18pO1xuICBjb25zdCB7XG4gICAgcGFyZW50UGF0aCxcbiAgICBwYXJlbnRcbiAgfSA9IHRoaXM7XG4gIGlmIChwYXJlbnRQYXRoLmlzRXhwcmVzc2lvblN0YXRlbWVudCgpIHx8IHBhcmVudFBhdGguaXNMYWJlbGVkU3RhdGVtZW50KCkgfHwgaXNFeHBvcnROYW1lZERlY2xhcmF0aW9uKHBhcmVudCkgfHwgcGFyZW50UGF0aC5pc0V4cG9ydERlZmF1bHREZWNsYXJhdGlvbigpICYmIHRoaXMuaXNEZWNsYXJhdGlvbigpKSB7XG4gICAgcmV0dXJuIHBhcmVudFBhdGguaW5zZXJ0QmVmb3JlKG5vZGVzKTtcbiAgfSBlbHNlIGlmICh0aGlzLmlzTm9kZVR5cGUoXCJFeHByZXNzaW9uXCIpICYmICF0aGlzLmlzSlNYRWxlbWVudCgpIHx8IHBhcmVudFBhdGguaXNGb3JTdGF0ZW1lbnQoKSAmJiB0aGlzLmtleSA9PT0gXCJpbml0XCIpIHtcbiAgICBpZiAodGhpcy5ub2RlKSBub2Rlcy5wdXNoKHRoaXMubm9kZSk7XG4gICAgcmV0dXJuIHRoaXMucmVwbGFjZUV4cHJlc3Npb25XaXRoU3RhdGVtZW50cyhub2Rlcyk7XG4gIH0gZWxzZSBpZiAoQXJyYXkuaXNBcnJheSh0aGlzLmNvbnRhaW5lcikpIHtcbiAgICByZXR1cm4gX2NvbnRhaW5lckluc2VydEJlZm9yZS5jYWxsKHRoaXMsIG5vZGVzKTtcbiAgfSBlbHNlIGlmICh0aGlzLmlzU3RhdGVtZW50T3JCbG9jaygpKSB7XG4gICAgY29uc3Qgbm9kZSA9IHRoaXMubm9kZTtcbiAgICBjb25zdCBzaG91bGRJbnNlcnRDdXJyZW50Tm9kZSA9IG5vZGUgJiYgKCF0aGlzLmlzRXhwcmVzc2lvblN0YXRlbWVudCgpIHx8IG5vZGUuZXhwcmVzc2lvbiAhPSBudWxsKTtcbiAgICBjb25zdCBbYmxvY2tQYXRoXSA9IHRoaXMucmVwbGFjZVdpdGgoYmxvY2tTdGF0ZW1lbnQoc2hvdWxkSW5zZXJ0Q3VycmVudE5vZGUgPyBbbm9kZV0gOiBbXSkpO1xuICAgIHJldHVybiBibG9ja1BhdGgudW5zaGlmdENvbnRhaW5lcihcImJvZHlcIiwgbm9kZXMpO1xuICB9IGVsc2Uge1xuICAgIHRocm93IG5ldyBFcnJvcihcIldlIGRvbid0IGtub3cgd2hhdCB0byBkbyB3aXRoIHRoaXMgbm9kZSB0eXBlLiBcIiArIFwiV2Ugd2VyZSBwcmV2aW91c2x5IGEgU3RhdGVtZW50IGJ1dCB3ZSBjYW4ndCBmaXQgaW4gaGVyZT9cIik7XG4gIH1cbn1cbmZ1bmN0aW9uIF9jb250YWluZXJJbnNlcnQoZnJvbSwgbm9kZXMpIHtcbiAgdXBkYXRlU2libGluZ0tleXMuY2FsbCh0aGlzLCBmcm9tLCBub2Rlcy5sZW5ndGgpO1xuICBjb25zdCBwYXRocyA9IFtdO1xuICB0aGlzLmNvbnRhaW5lci5zcGxpY2UoZnJvbSwgMCwgLi4ubm9kZXMpO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IG5vZGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIF90aGlzJGNvbnRleHQ7XG4gICAgY29uc3QgdG8gPSBmcm9tICsgaTtcbiAgICBjb25zdCBwYXRoID0gdGhpcy5nZXRTaWJsaW5nKHRvKTtcbiAgICBwYXRocy5wdXNoKHBhdGgpO1xuICAgIGlmICgoX3RoaXMkY29udGV4dCA9IHRoaXMuY29udGV4dCkgIT0gbnVsbCAmJiBfdGhpcyRjb250ZXh0LnF1ZXVlKSB7XG4gICAgICBfY29udGV4dC5wdXNoQ29udGV4dC5jYWxsKHBhdGgsIHRoaXMuY29udGV4dCk7XG4gICAgfVxuICB9XG4gIGNvbnN0IGNvbnRleHRzID0gX2NvbnRleHQuX2dldFF1ZXVlQ29udGV4dHMuY2FsbCh0aGlzKTtcbiAgZm9yIChjb25zdCBwYXRoIG9mIHBhdGhzKSB7XG4gICAgX2NvbnRleHQuc2V0U2NvcGUuY2FsbChwYXRoKTtcbiAgICBwYXRoLmRlYnVnKFwiSW5zZXJ0ZWQuXCIpO1xuICAgIGZvciAoY29uc3QgY29udGV4dCBvZiBjb250ZXh0cykge1xuICAgICAgY29udGV4dC5tYXliZVF1ZXVlKHBhdGgsIHRydWUpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcGF0aHM7XG59XG5mdW5jdGlvbiBfY29udGFpbmVySW5zZXJ0QmVmb3JlKG5vZGVzKSB7XG4gIHJldHVybiBfY29udGFpbmVySW5zZXJ0LmNhbGwodGhpcywgdGhpcy5rZXksIG5vZGVzKTtcbn1cbmZ1bmN0aW9uIF9jb250YWluZXJJbnNlcnRBZnRlcihub2Rlcykge1xuICByZXR1cm4gX2NvbnRhaW5lckluc2VydC5jYWxsKHRoaXMsIHRoaXMua2V5ICsgMSwgbm9kZXMpO1xufVxuY29uc3QgbGFzdCA9IGFyciA9PiBhcnJbYXJyLmxlbmd0aCAtIDFdO1xuZnVuY3Rpb24gaXNIaWRkZW5JblNlcXVlbmNlRXhwcmVzc2lvbihwYXRoKSB7XG4gIHJldHVybiBpc1NlcXVlbmNlRXhwcmVzc2lvbihwYXRoLnBhcmVudCkgJiYgKGxhc3QocGF0aC5wYXJlbnQuZXhwcmVzc2lvbnMpICE9PSBwYXRoLm5vZGUgfHwgaXNIaWRkZW5JblNlcXVlbmNlRXhwcmVzc2lvbihwYXRoLnBhcmVudFBhdGgpKTtcbn1cbmZ1bmN0aW9uIGlzQWxtb3N0Q29uc3RhbnRBc3NpZ25tZW50KG5vZGUsIHNjb3BlKSB7XG4gIGlmICghaXNBc3NpZ25tZW50RXhwcmVzc2lvbihub2RlKSB8fCAhaXNJZGVudGlmaWVyKG5vZGUubGVmdCkpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgY29uc3QgYmxvY2tTY29wZSA9IHNjb3BlLmdldEJsb2NrUGFyZW50KCk7XG4gIHJldHVybiBibG9ja1Njb3BlLmhhc093bkJpbmRpbmcobm9kZS5sZWZ0Lm5hbWUpICYmIGJsb2NrU2NvcGUuZ2V0T3duQmluZGluZyhub2RlLmxlZnQubmFtZSkuY29uc3RhbnRWaW9sYXRpb25zLmxlbmd0aCA8PSAxO1xufVxuZnVuY3Rpb24gaW5zZXJ0QWZ0ZXIobm9kZXNfKSB7XG4gIF9yZW1vdmFsLl9hc3NlcnRVbnJlbW92ZWQuY2FsbCh0aGlzKTtcbiAgaWYgKHRoaXMuaXNTZXF1ZW5jZUV4cHJlc3Npb24oKSkge1xuICAgIHJldHVybiBsYXN0KHRoaXMuZ2V0KFwiZXhwcmVzc2lvbnNcIikpLmluc2VydEFmdGVyKG5vZGVzXyk7XG4gIH1cbiAgY29uc3Qgbm9kZXMgPSBfdmVyaWZ5Tm9kZUxpc3QuY2FsbCh0aGlzLCBub2Rlc18pO1xuICBjb25zdCB7XG4gICAgcGFyZW50UGF0aCxcbiAgICBwYXJlbnRcbiAgfSA9IHRoaXM7XG4gIGlmIChwYXJlbnRQYXRoLmlzRXhwcmVzc2lvblN0YXRlbWVudCgpIHx8IHBhcmVudFBhdGguaXNMYWJlbGVkU3RhdGVtZW50KCkgfHwgaXNFeHBvcnROYW1lZERlY2xhcmF0aW9uKHBhcmVudCkgfHwgcGFyZW50UGF0aC5pc0V4cG9ydERlZmF1bHREZWNsYXJhdGlvbigpICYmIHRoaXMuaXNEZWNsYXJhdGlvbigpKSB7XG4gICAgcmV0dXJuIHBhcmVudFBhdGguaW5zZXJ0QWZ0ZXIobm9kZXMubWFwKG5vZGUgPT4ge1xuICAgICAgcmV0dXJuIGlzRXhwcmVzc2lvbihub2RlKSA/IGV4cHJlc3Npb25TdGF0ZW1lbnQobm9kZSkgOiBub2RlO1xuICAgIH0pKTtcbiAgfSBlbHNlIGlmICh0aGlzLmlzTm9kZVR5cGUoXCJFeHByZXNzaW9uXCIpICYmICF0aGlzLmlzSlNYRWxlbWVudCgpICYmICFwYXJlbnRQYXRoLmlzSlNYRWxlbWVudCgpIHx8IHBhcmVudFBhdGguaXNGb3JTdGF0ZW1lbnQoKSAmJiB0aGlzLmtleSA9PT0gXCJpbml0XCIpIHtcbiAgICBjb25zdCBzZWxmID0gdGhpcztcbiAgICBpZiAoc2VsZi5ub2RlKSB7XG4gICAgICBjb25zdCBub2RlID0gc2VsZi5ub2RlO1xuICAgICAgbGV0IHtcbiAgICAgICAgc2NvcGVcbiAgICAgIH0gPSB0aGlzO1xuICAgICAgaWYgKHNjb3BlLnBhdGguaXNQYXR0ZXJuKCkpIHtcbiAgICAgICAgYXNzZXJ0RXhwcmVzc2lvbihub2RlKTtcbiAgICAgICAgc2VsZi5yZXBsYWNlV2l0aChjYWxsRXhwcmVzc2lvbihhcnJvd0Z1bmN0aW9uRXhwcmVzc2lvbihbXSwgbm9kZSksIFtdKSk7XG4gICAgICAgIHNlbGYuZ2V0KFwiY2FsbGVlLmJvZHlcIikuaW5zZXJ0QWZ0ZXIobm9kZXMpO1xuICAgICAgICByZXR1cm4gW3NlbGZdO1xuICAgICAgfVxuICAgICAgaWYgKGlzSGlkZGVuSW5TZXF1ZW5jZUV4cHJlc3Npb24oc2VsZikpIHtcbiAgICAgICAgbm9kZXMudW5zaGlmdChub2RlKTtcbiAgICAgIH0gZWxzZSBpZiAoaXNDYWxsRXhwcmVzc2lvbihub2RlKSAmJiBpc1N1cGVyKG5vZGUuY2FsbGVlKSkge1xuICAgICAgICBub2Rlcy51bnNoaWZ0KG5vZGUpO1xuICAgICAgICBub2Rlcy5wdXNoKHRoaXNFeHByZXNzaW9uKCkpO1xuICAgICAgfSBlbHNlIGlmIChpc0FsbW9zdENvbnN0YW50QXNzaWdubWVudChub2RlLCBzY29wZSkpIHtcbiAgICAgICAgbm9kZXMudW5zaGlmdChub2RlKTtcbiAgICAgICAgbm9kZXMucHVzaChjbG9uZU5vZGUobm9kZS5sZWZ0KSk7XG4gICAgICB9IGVsc2UgaWYgKHNjb3BlLmlzUHVyZShub2RlLCB0cnVlKSkge1xuICAgICAgICBub2Rlcy5wdXNoKG5vZGUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKHBhcmVudFBhdGguaXNNZXRob2Qoe1xuICAgICAgICAgIGNvbXB1dGVkOiB0cnVlLFxuICAgICAgICAgIGtleTogbm9kZVxuICAgICAgICB9KSkge1xuICAgICAgICAgIHNjb3BlID0gc2NvcGUucGFyZW50O1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHRlbXAgPSBzY29wZS5nZW5lcmF0ZURlY2xhcmVkVWlkSWRlbnRpZmllcigpO1xuICAgICAgICBub2Rlcy51bnNoaWZ0KGV4cHJlc3Npb25TdGF0ZW1lbnQoYXNzaWdubWVudEV4cHJlc3Npb24oXCI9XCIsIGNsb25lTm9kZSh0ZW1wKSwgbm9kZSkpKTtcbiAgICAgICAgbm9kZXMucHVzaChleHByZXNzaW9uU3RhdGVtZW50KGNsb25lTm9kZSh0ZW1wKSkpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdGhpcy5yZXBsYWNlRXhwcmVzc2lvbldpdGhTdGF0ZW1lbnRzKG5vZGVzKTtcbiAgfSBlbHNlIGlmIChBcnJheS5pc0FycmF5KHRoaXMuY29udGFpbmVyKSkge1xuICAgIHJldHVybiBfY29udGFpbmVySW5zZXJ0QWZ0ZXIuY2FsbCh0aGlzLCBub2Rlcyk7XG4gIH0gZWxzZSBpZiAodGhpcy5pc1N0YXRlbWVudE9yQmxvY2soKSkge1xuICAgIGNvbnN0IG5vZGUgPSB0aGlzLm5vZGU7XG4gICAgY29uc3Qgc2hvdWxkSW5zZXJ0Q3VycmVudE5vZGUgPSBub2RlICYmICghdGhpcy5pc0V4cHJlc3Npb25TdGF0ZW1lbnQoKSB8fCBub2RlLmV4cHJlc3Npb24gIT0gbnVsbCk7XG4gICAgY29uc3QgW2Jsb2NrUGF0aF0gPSB0aGlzLnJlcGxhY2VXaXRoKGJsb2NrU3RhdGVtZW50KHNob3VsZEluc2VydEN1cnJlbnROb2RlID8gW25vZGVdIDogW10pKTtcbiAgICByZXR1cm4gYmxvY2tQYXRoLnB1c2hDb250YWluZXIoXCJib2R5XCIsIG5vZGVzKTtcbiAgfSBlbHNlIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJXZSBkb24ndCBrbm93IHdoYXQgdG8gZG8gd2l0aCB0aGlzIG5vZGUgdHlwZS4gXCIgKyBcIldlIHdlcmUgcHJldmlvdXNseSBhIFN0YXRlbWVudCBidXQgd2UgY2FuJ3QgZml0IGluIGhlcmU/XCIpO1xuICB9XG59XG5mdW5jdGlvbiB1cGRhdGVTaWJsaW5nS2V5cyhmcm9tSW5kZXgsIGluY3JlbWVudEJ5KSB7XG4gIGlmICghdGhpcy5wYXJlbnQpIHJldHVybjtcbiAgY29uc3QgcGF0aHMgPSAoMCwgX2NhY2hlLmdldENhY2hlZFBhdGhzKSh0aGlzKTtcbiAgaWYgKCFwYXRocykgcmV0dXJuO1xuICBmb3IgKGNvbnN0IFssIHBhdGhdIG9mIHBhdGhzKSB7XG4gICAgaWYgKHR5cGVvZiBwYXRoLmtleSA9PT0gXCJudW1iZXJcIiAmJiBwYXRoLmNvbnRhaW5lciA9PT0gdGhpcy5jb250YWluZXIgJiYgcGF0aC5rZXkgPj0gZnJvbUluZGV4KSB7XG4gICAgICBwYXRoLmtleSArPSBpbmNyZW1lbnRCeTtcbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIF92ZXJpZnlOb2RlTGlzdChub2Rlcykge1xuICBpZiAoIW5vZGVzKSB7XG4gICAgcmV0dXJuIFtdO1xuICB9XG4gIGlmICghQXJyYXkuaXNBcnJheShub2RlcykpIHtcbiAgICBub2RlcyA9IFtub2Rlc107XG4gIH1cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBub2Rlcy5sZW5ndGg7IGkrKykge1xuICAgIGNvbnN0IG5vZGUgPSBub2Rlc1tpXTtcbiAgICBsZXQgbXNnO1xuICAgIGlmICghbm9kZSkge1xuICAgICAgbXNnID0gXCJoYXMgZmFsc3kgbm9kZVwiO1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIG5vZGUgIT09IFwib2JqZWN0XCIpIHtcbiAgICAgIG1zZyA9IFwiY29udGFpbnMgYSBub24tb2JqZWN0IG5vZGVcIjtcbiAgICB9IGVsc2UgaWYgKCFub2RlLnR5cGUpIHtcbiAgICAgIG1zZyA9IFwid2l0aG91dCBhIHR5cGVcIjtcbiAgICB9IGVsc2UgaWYgKG5vZGUgaW5zdGFuY2VvZiBfaW5kZXguZGVmYXVsdCkge1xuICAgICAgbXNnID0gXCJoYXMgYSBOb2RlUGF0aCB3aGVuIGl0IGV4cGVjdGVkIGEgcmF3IG9iamVjdFwiO1xuICAgIH1cbiAgICBpZiAobXNnKSB7XG4gICAgICBjb25zdCB0eXBlID0gQXJyYXkuaXNBcnJheShub2RlKSA/IFwiYXJyYXlcIiA6IHR5cGVvZiBub2RlO1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBOb2RlIGxpc3QgJHttc2d9IHdpdGggdGhlIGluZGV4IG9mICR7aX0gYW5kIHR5cGUgb2YgJHt0eXBlfWApO1xuICAgIH1cbiAgfVxuICByZXR1cm4gbm9kZXM7XG59XG5mdW5jdGlvbiB1bnNoaWZ0Q29udGFpbmVyKGxpc3RLZXksIG5vZGVzKSB7XG4gIF9yZW1vdmFsLl9hc3NlcnRVbnJlbW92ZWQuY2FsbCh0aGlzKTtcbiAgY29uc3QgdmVyaWZpZWROb2RlcyA9IF92ZXJpZnlOb2RlTGlzdC5jYWxsKHRoaXMsIG5vZGVzKTtcbiAgY29uc3QgY29udGFpbmVyID0gdGhpcy5ub2RlW2xpc3RLZXldO1xuICBjb25zdCBwYXRoID0gX2luZGV4LmRlZmF1bHQuZ2V0KHtcbiAgICBwYXJlbnRQYXRoOiB0aGlzLFxuICAgIHBhcmVudDogdGhpcy5ub2RlLFxuICAgIGNvbnRhaW5lcixcbiAgICBsaXN0S2V5LFxuICAgIGtleTogMFxuICB9KS5zZXRDb250ZXh0KHRoaXMuY29udGV4dCk7XG4gIHJldHVybiBfY29udGFpbmVySW5zZXJ0QmVmb3JlLmNhbGwocGF0aCwgdmVyaWZpZWROb2Rlcyk7XG59XG5mdW5jdGlvbiBwdXNoQ29udGFpbmVyKGxpc3RLZXksIG5vZGVzKSB7XG4gIF9yZW1vdmFsLl9hc3NlcnRVbnJlbW92ZWQuY2FsbCh0aGlzKTtcbiAgY29uc3QgdmVyaWZpZWROb2RlcyA9IF92ZXJpZnlOb2RlTGlzdC5jYWxsKHRoaXMsIG5vZGVzKTtcbiAgY29uc3QgY29udGFpbmVyID0gdGhpcy5ub2RlW2xpc3RLZXldO1xuICBjb25zdCBwYXRoID0gX2luZGV4LmRlZmF1bHQuZ2V0KHtcbiAgICBwYXJlbnRQYXRoOiB0aGlzLFxuICAgIHBhcmVudDogdGhpcy5ub2RlLFxuICAgIGNvbnRhaW5lcixcbiAgICBsaXN0S2V5LFxuICAgIGtleTogY29udGFpbmVyLmxlbmd0aFxuICB9KS5zZXRDb250ZXh0KHRoaXMuY29udGV4dCk7XG4gIHJldHVybiBwYXRoLnJlcGxhY2VXaXRoTXVsdGlwbGUodmVyaWZpZWROb2Rlcyk7XG59XG5leHBvcnRzLmhvaXN0ID0gZnVuY3Rpb24gaG9pc3Qoc2NvcGUgPSB0aGlzLnNjb3BlKSB7XG4gIGNvbnN0IGhvaXN0ZXIgPSBuZXcgX2hvaXN0ZXIuZGVmYXVsdCh0aGlzLCBzY29wZSk7XG4gIHJldHVybiBob2lzdGVyLnJ1bigpO1xufTtcblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bW9kaWZpY2F0aW9uLmpzLm1hcFxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@babel/traverse/lib/path/modification.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@babel/traverse/lib/path/removal.js":
/*!**********************************************************!*\
  !*** ./node_modules/@babel/traverse/lib/path/removal.js ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports._assertUnremoved = _assertUnremoved;\nexports._callRemovalHooks = _callRemovalHooks;\nexports._markRemoved = _markRemoved;\nexports._remove = _remove;\nexports._removeFromScope = _removeFromScope;\nexports.remove = remove;\nvar _removalHooks = __webpack_require__(/*! ./lib/removal-hooks.js */ \"(ssr)/./node_modules/@babel/traverse/lib/path/lib/removal-hooks.js\");\nvar _cache = __webpack_require__(/*! ../cache.js */ \"(ssr)/./node_modules/@babel/traverse/lib/cache.js\");\nvar _replacement = __webpack_require__(/*! ./replacement.js */ \"(ssr)/./node_modules/@babel/traverse/lib/path/replacement.js\");\nvar _index = __webpack_require__(/*! ./index.js */ \"(ssr)/./node_modules/@babel/traverse/lib/path/index.js\");\nvar t = __webpack_require__(/*! @babel/types */ \"(ssr)/./node_modules/@babel/types/lib/index.js\");\nvar _modification = __webpack_require__(/*! ./modification.js */ \"(ssr)/./node_modules/@babel/traverse/lib/path/modification.js\");\nvar _context = __webpack_require__(/*! ./context.js */ \"(ssr)/./node_modules/@babel/traverse/lib/path/context.js\");\nfunction remove() {\n  var _this$opts;\n  _assertUnremoved.call(this);\n  _context.resync.call(this);\n  if (_callRemovalHooks.call(this)) {\n    _markRemoved.call(this);\n    return;\n  }\n  if (!((_this$opts = this.opts) != null && _this$opts.noScope)) {\n    _removeFromScope.call(this);\n  }\n  this.shareCommentsWithSiblings();\n  _remove.call(this);\n  _markRemoved.call(this);\n}\nfunction _removeFromScope() {\n  const bindings = t.getBindingIdentifiers(this.node, false, false, true);\n  Object.keys(bindings).forEach(name => this.scope.removeBinding(name));\n}\nfunction _callRemovalHooks() {\n  if (this.parentPath) {\n    for (const fn of _removalHooks.hooks) {\n      if (fn(this, this.parentPath)) return true;\n    }\n  }\n}\nfunction _remove() {\n  if (Array.isArray(this.container)) {\n    this.container.splice(this.key, 1);\n    _modification.updateSiblingKeys.call(this, this.key, -1);\n  } else {\n    _replacement._replaceWith.call(this, null);\n  }\n}\nfunction _markRemoved() {\n  this._traverseFlags |= _index.SHOULD_SKIP | _index.REMOVED;\n  if (this.parent) {\n    var _getCachedPaths;\n    (_getCachedPaths = (0, _cache.getCachedPaths)(this)) == null || _getCachedPaths.delete(this.node);\n  }\n  this.node = null;\n}\nfunction _assertUnremoved() {\n  if (this.removed) {\n    throw this.buildCodeFrameError(\"NodePath has been removed so is read-only.\");\n  }\n}\n\n//# sourceMappingURL=removal.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGJhYmVsL3RyYXZlcnNlL2xpYi9wYXRoL3JlbW92YWwuanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWIsOENBQTZDO0FBQzdDO0FBQ0EsQ0FBQyxFQUFDO0FBQ0Ysd0JBQXdCO0FBQ3hCLHlCQUF5QjtBQUN6QixvQkFBb0I7QUFDcEIsZUFBZTtBQUNmLHdCQUF3QjtBQUN4QixjQUFjO0FBQ2Qsb0JBQW9CLG1CQUFPLENBQUMsa0dBQXdCO0FBQ3BELGFBQWEsbUJBQU8sQ0FBQyxzRUFBYTtBQUNsQyxtQkFBbUIsbUJBQU8sQ0FBQyxzRkFBa0I7QUFDN0MsYUFBYSxtQkFBTyxDQUFDLDBFQUFZO0FBQ2pDLFFBQVEsbUJBQU8sQ0FBQyxvRUFBYztBQUM5QixvQkFBb0IsbUJBQU8sQ0FBQyx3RkFBbUI7QUFDL0MsZUFBZSxtQkFBTyxDQUFDLDhFQUFjO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSIsInNvdXJjZXMiOlsid2VicGFjazovL3JlcG8tdmlzdWFsaXplci8uL25vZGVfbW9kdWxlcy9AYmFiZWwvdHJhdmVyc2UvbGliL3BhdGgvcmVtb3ZhbC5qcz8zZWE0Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5fYXNzZXJ0VW5yZW1vdmVkID0gX2Fzc2VydFVucmVtb3ZlZDtcbmV4cG9ydHMuX2NhbGxSZW1vdmFsSG9va3MgPSBfY2FsbFJlbW92YWxIb29rcztcbmV4cG9ydHMuX21hcmtSZW1vdmVkID0gX21hcmtSZW1vdmVkO1xuZXhwb3J0cy5fcmVtb3ZlID0gX3JlbW92ZTtcbmV4cG9ydHMuX3JlbW92ZUZyb21TY29wZSA9IF9yZW1vdmVGcm9tU2NvcGU7XG5leHBvcnRzLnJlbW92ZSA9IHJlbW92ZTtcbnZhciBfcmVtb3ZhbEhvb2tzID0gcmVxdWlyZShcIi4vbGliL3JlbW92YWwtaG9va3MuanNcIik7XG52YXIgX2NhY2hlID0gcmVxdWlyZShcIi4uL2NhY2hlLmpzXCIpO1xudmFyIF9yZXBsYWNlbWVudCA9IHJlcXVpcmUoXCIuL3JlcGxhY2VtZW50LmpzXCIpO1xudmFyIF9pbmRleCA9IHJlcXVpcmUoXCIuL2luZGV4LmpzXCIpO1xudmFyIHQgPSByZXF1aXJlKFwiQGJhYmVsL3R5cGVzXCIpO1xudmFyIF9tb2RpZmljYXRpb24gPSByZXF1aXJlKFwiLi9tb2RpZmljYXRpb24uanNcIik7XG52YXIgX2NvbnRleHQgPSByZXF1aXJlKFwiLi9jb250ZXh0LmpzXCIpO1xuZnVuY3Rpb24gcmVtb3ZlKCkge1xuICB2YXIgX3RoaXMkb3B0cztcbiAgX2Fzc2VydFVucmVtb3ZlZC5jYWxsKHRoaXMpO1xuICBfY29udGV4dC5yZXN5bmMuY2FsbCh0aGlzKTtcbiAgaWYgKF9jYWxsUmVtb3ZhbEhvb2tzLmNhbGwodGhpcykpIHtcbiAgICBfbWFya1JlbW92ZWQuY2FsbCh0aGlzKTtcbiAgICByZXR1cm47XG4gIH1cbiAgaWYgKCEoKF90aGlzJG9wdHMgPSB0aGlzLm9wdHMpICE9IG51bGwgJiYgX3RoaXMkb3B0cy5ub1Njb3BlKSkge1xuICAgIF9yZW1vdmVGcm9tU2NvcGUuY2FsbCh0aGlzKTtcbiAgfVxuICB0aGlzLnNoYXJlQ29tbWVudHNXaXRoU2libGluZ3MoKTtcbiAgX3JlbW92ZS5jYWxsKHRoaXMpO1xuICBfbWFya1JlbW92ZWQuY2FsbCh0aGlzKTtcbn1cbmZ1bmN0aW9uIF9yZW1vdmVGcm9tU2NvcGUoKSB7XG4gIGNvbnN0IGJpbmRpbmdzID0gdC5nZXRCaW5kaW5nSWRlbnRpZmllcnModGhpcy5ub2RlLCBmYWxzZSwgZmFsc2UsIHRydWUpO1xuICBPYmplY3Qua2V5cyhiaW5kaW5ncykuZm9yRWFjaChuYW1lID0+IHRoaXMuc2NvcGUucmVtb3ZlQmluZGluZyhuYW1lKSk7XG59XG5mdW5jdGlvbiBfY2FsbFJlbW92YWxIb29rcygpIHtcbiAgaWYgKHRoaXMucGFyZW50UGF0aCkge1xuICAgIGZvciAoY29uc3QgZm4gb2YgX3JlbW92YWxIb29rcy5ob29rcykge1xuICAgICAgaWYgKGZuKHRoaXMsIHRoaXMucGFyZW50UGF0aCkpIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gX3JlbW92ZSgpIHtcbiAgaWYgKEFycmF5LmlzQXJyYXkodGhpcy5jb250YWluZXIpKSB7XG4gICAgdGhpcy5jb250YWluZXIuc3BsaWNlKHRoaXMua2V5LCAxKTtcbiAgICBfbW9kaWZpY2F0aW9uLnVwZGF0ZVNpYmxpbmdLZXlzLmNhbGwodGhpcywgdGhpcy5rZXksIC0xKTtcbiAgfSBlbHNlIHtcbiAgICBfcmVwbGFjZW1lbnQuX3JlcGxhY2VXaXRoLmNhbGwodGhpcywgbnVsbCk7XG4gIH1cbn1cbmZ1bmN0aW9uIF9tYXJrUmVtb3ZlZCgpIHtcbiAgdGhpcy5fdHJhdmVyc2VGbGFncyB8PSBfaW5kZXguU0hPVUxEX1NLSVAgfCBfaW5kZXguUkVNT1ZFRDtcbiAgaWYgKHRoaXMucGFyZW50KSB7XG4gICAgdmFyIF9nZXRDYWNoZWRQYXRocztcbiAgICAoX2dldENhY2hlZFBhdGhzID0gKDAsIF9jYWNoZS5nZXRDYWNoZWRQYXRocykodGhpcykpID09IG51bGwgfHwgX2dldENhY2hlZFBhdGhzLmRlbGV0ZSh0aGlzLm5vZGUpO1xuICB9XG4gIHRoaXMubm9kZSA9IG51bGw7XG59XG5mdW5jdGlvbiBfYXNzZXJ0VW5yZW1vdmVkKCkge1xuICBpZiAodGhpcy5yZW1vdmVkKSB7XG4gICAgdGhyb3cgdGhpcy5idWlsZENvZGVGcmFtZUVycm9yKFwiTm9kZVBhdGggaGFzIGJlZW4gcmVtb3ZlZCBzbyBpcyByZWFkLW9ubHkuXCIpO1xuICB9XG59XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXJlbW92YWwuanMubWFwXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@babel/traverse/lib/path/removal.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@babel/traverse/lib/path/replacement.js":
/*!**************************************************************!*\
  !*** ./node_modules/@babel/traverse/lib/path/replacement.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports._replaceWith = _replaceWith;\nexports.replaceExpressionWithStatements = replaceExpressionWithStatements;\nexports.replaceInline = replaceInline;\nexports.replaceWith = replaceWith;\nexports.replaceWithMultiple = replaceWithMultiple;\nexports.replaceWithSourceString = replaceWithSourceString;\nvar _codeFrame = __webpack_require__(/*! @babel/code-frame */ \"(ssr)/./node_modules/@babel/code-frame/lib/index.js\");\nvar _index = __webpack_require__(/*! ../index.js */ \"(ssr)/./node_modules/@babel/traverse/lib/index.js\");\nvar _index2 = __webpack_require__(/*! ./index.js */ \"(ssr)/./node_modules/@babel/traverse/lib/path/index.js\");\nvar _cache = __webpack_require__(/*! ../cache.js */ \"(ssr)/./node_modules/@babel/traverse/lib/cache.js\");\nvar _modification = __webpack_require__(/*! ./modification.js */ \"(ssr)/./node_modules/@babel/traverse/lib/path/modification.js\");\nvar _parser = __webpack_require__(/*! @babel/parser */ \"(ssr)/./node_modules/@babel/parser/lib/index.js\");\nvar _t = __webpack_require__(/*! @babel/types */ \"(ssr)/./node_modules/@babel/types/lib/index.js\");\nvar _context = __webpack_require__(/*! ./context.js */ \"(ssr)/./node_modules/@babel/traverse/lib/path/context.js\");\nconst {\n  FUNCTION_TYPES,\n  arrowFunctionExpression,\n  assignmentExpression,\n  awaitExpression,\n  blockStatement,\n  buildUndefinedNode,\n  callExpression,\n  cloneNode,\n  conditionalExpression,\n  expressionStatement,\n  getBindingIdentifiers,\n  identifier,\n  inheritLeadingComments,\n  inheritTrailingComments,\n  inheritsComments,\n  isBlockStatement,\n  isEmptyStatement,\n  isExpression,\n  isExpressionStatement,\n  isIfStatement,\n  isProgram,\n  isStatement,\n  isVariableDeclaration,\n  removeComments,\n  returnStatement,\n  sequenceExpression,\n  validate,\n  yieldExpression\n} = _t;\nfunction replaceWithMultiple(nodes) {\n  var _getCachedPaths;\n  _context.resync.call(this);\n  const verifiedNodes = _modification._verifyNodeList.call(this, nodes);\n  inheritLeadingComments(verifiedNodes[0], this.node);\n  inheritTrailingComments(verifiedNodes[verifiedNodes.length - 1], this.node);\n  (_getCachedPaths = (0, _cache.getCachedPaths)(this)) == null || _getCachedPaths.delete(this.node);\n  this.node = this.container[this.key] = null;\n  const paths = this.insertAfter(nodes);\n  if (this.node) {\n    this.requeue();\n  } else {\n    this.remove();\n  }\n  return paths;\n}\nfunction replaceWithSourceString(replacement) {\n  _context.resync.call(this);\n  let ast;\n  try {\n    replacement = `(${replacement})`;\n    ast = (0, _parser.parse)(replacement);\n  } catch (err) {\n    const loc = err.loc;\n    if (loc) {\n      err.message += \" - make sure this is an expression.\\n\" + (0, _codeFrame.codeFrameColumns)(replacement, {\n        start: {\n          line: loc.line,\n          column: loc.column + 1\n        }\n      });\n      err.code = \"BABEL_REPLACE_SOURCE_ERROR\";\n    }\n    throw err;\n  }\n  const expressionAST = ast.program.body[0].expression;\n  _index.default.removeProperties(expressionAST);\n  return this.replaceWith(expressionAST);\n}\nfunction replaceWith(replacementPath) {\n  _context.resync.call(this);\n  if (this.removed) {\n    throw new Error(\"You can't replace this node, we've already removed it\");\n  }\n  let replacement = replacementPath instanceof _index2.default ? replacementPath.node : replacementPath;\n  if (!replacement) {\n    throw new Error(\"You passed `path.replaceWith()` a falsy node, use `path.remove()` instead\");\n  }\n  if (this.node === replacement) {\n    return [this];\n  }\n  if (this.isProgram() && !isProgram(replacement)) {\n    throw new Error(\"You can only replace a Program root node with another Program node\");\n  }\n  if (Array.isArray(replacement)) {\n    throw new Error(\"Don't use `path.replaceWith()` with an array of nodes, use `path.replaceWithMultiple()`\");\n  }\n  if (typeof replacement === \"string\") {\n    throw new Error(\"Don't use `path.replaceWith()` with a source string, use `path.replaceWithSourceString()`\");\n  }\n  let nodePath = \"\";\n  if (this.isNodeType(\"Statement\") && isExpression(replacement)) {\n    if (!this.canHaveVariableDeclarationOrExpression() && !this.canSwapBetweenExpressionAndStatement(replacement) && !this.parentPath.isExportDefaultDeclaration()) {\n      replacement = expressionStatement(replacement);\n      nodePath = \"expression\";\n    }\n  }\n  if (this.isNodeType(\"Expression\") && isStatement(replacement)) {\n    if (!this.canHaveVariableDeclarationOrExpression() && !this.canSwapBetweenExpressionAndStatement(replacement)) {\n      return this.replaceExpressionWithStatements([replacement]);\n    }\n  }\n  const oldNode = this.node;\n  if (oldNode) {\n    inheritsComments(replacement, oldNode);\n    removeComments(oldNode);\n  }\n  _replaceWith.call(this, replacement);\n  this.type = replacement.type;\n  _context.setScope.call(this);\n  this.requeue();\n  return [nodePath ? this.get(nodePath) : this];\n}\nfunction _replaceWith(node) {\n  var _getCachedPaths2;\n  if (!this.container) {\n    throw new ReferenceError(\"Container is falsy\");\n  }\n  if (this.inList) {\n    validate(this.parent, this.key, [node]);\n  } else {\n    validate(this.parent, this.key, node);\n  }\n  this.debug(`Replace with ${node == null ? void 0 : node.type}`);\n  (_getCachedPaths2 = (0, _cache.getCachedPaths)(this)) == null || _getCachedPaths2.set(node, this).delete(this.node);\n  this.node = node;\n  this.container[this.key] = node;\n}\nfunction replaceExpressionWithStatements(nodes) {\n  _context.resync.call(this);\n  const declars = [];\n  const nodesAsSingleExpression = gatherSequenceExpressions(nodes, declars);\n  if (nodesAsSingleExpression) {\n    for (const id of declars) this.scope.push({\n      id\n    });\n    return this.replaceWith(nodesAsSingleExpression)[0].get(\"expressions\");\n  }\n  const functionParent = this.getFunctionParent();\n  const isParentAsync = functionParent == null ? void 0 : functionParent.node.async;\n  const isParentGenerator = functionParent == null ? void 0 : functionParent.node.generator;\n  const container = arrowFunctionExpression([], blockStatement(nodes));\n  this.replaceWith(callExpression(container, []));\n  const callee = this.get(\"callee\");\n  callee.get(\"body\").scope.hoistVariables(id => this.scope.push({\n    id\n  }));\n  const completionRecords = callee.getCompletionRecords();\n  for (const path of completionRecords) {\n    if (!path.isExpressionStatement()) continue;\n    const loop = path.findParent(path => path.isLoop());\n    if (loop) {\n      let uid = loop.getData(\"expressionReplacementReturnUid\");\n      if (!uid) {\n        uid = callee.scope.generateDeclaredUidIdentifier(\"ret\");\n        callee.get(\"body\").pushContainer(\"body\", returnStatement(cloneNode(uid)));\n        loop.setData(\"expressionReplacementReturnUid\", uid);\n      } else {\n        uid = identifier(uid.name);\n      }\n      path.get(\"expression\").replaceWith(assignmentExpression(\"=\", cloneNode(uid), path.node.expression));\n    } else {\n      path.replaceWith(returnStatement(path.node.expression));\n    }\n  }\n  callee.arrowFunctionToExpression();\n  const newCallee = callee;\n  const needToAwaitFunction = isParentAsync && _index.default.hasType(newCallee.node.body, \"AwaitExpression\", FUNCTION_TYPES);\n  const needToYieldFunction = isParentGenerator && _index.default.hasType(newCallee.node.body, \"YieldExpression\", FUNCTION_TYPES);\n  if (needToAwaitFunction) {\n    newCallee.set(\"async\", true);\n    if (!needToYieldFunction) {\n      this.replaceWith(awaitExpression(this.node));\n    }\n  }\n  if (needToYieldFunction) {\n    newCallee.set(\"generator\", true);\n    this.replaceWith(yieldExpression(this.node, true));\n  }\n  return newCallee.get(\"body.body\");\n}\nfunction gatherSequenceExpressions(nodes, declars) {\n  const exprs = [];\n  let ensureLastUndefined = true;\n  for (const node of nodes) {\n    if (!isEmptyStatement(node)) {\n      ensureLastUndefined = false;\n    }\n    if (isExpression(node)) {\n      exprs.push(node);\n    } else if (isExpressionStatement(node)) {\n      exprs.push(node.expression);\n    } else if (isVariableDeclaration(node)) {\n      if (node.kind !== \"var\") return;\n      for (const declar of node.declarations) {\n        const bindings = getBindingIdentifiers(declar);\n        for (const key of Object.keys(bindings)) {\n          declars.push(cloneNode(bindings[key]));\n        }\n        if (declar.init) {\n          exprs.push(assignmentExpression(\"=\", declar.id, declar.init));\n        }\n      }\n      ensureLastUndefined = true;\n    } else if (isIfStatement(node)) {\n      const consequent = node.consequent ? gatherSequenceExpressions([node.consequent], declars) : buildUndefinedNode();\n      const alternate = node.alternate ? gatherSequenceExpressions([node.alternate], declars) : buildUndefinedNode();\n      if (!consequent || !alternate) return;\n      exprs.push(conditionalExpression(node.test, consequent, alternate));\n    } else if (isBlockStatement(node)) {\n      const body = gatherSequenceExpressions(node.body, declars);\n      if (!body) return;\n      exprs.push(body);\n    } else if (isEmptyStatement(node)) {\n      if (nodes.indexOf(node) === 0) {\n        ensureLastUndefined = true;\n      }\n    } else {\n      return;\n    }\n  }\n  if (ensureLastUndefined) exprs.push(buildUndefinedNode());\n  if (exprs.length === 1) {\n    return exprs[0];\n  } else {\n    return sequenceExpression(exprs);\n  }\n}\nfunction replaceInline(nodes) {\n  _context.resync.call(this);\n  if (Array.isArray(nodes)) {\n    if (Array.isArray(this.container)) {\n      nodes = _modification._verifyNodeList.call(this, nodes);\n      const paths = _modification._containerInsertAfter.call(this, nodes);\n      this.remove();\n      return paths;\n    } else {\n      return this.replaceWithMultiple(nodes);\n    }\n  } else {\n    return this.replaceWith(nodes);\n  }\n}\n\n//# sourceMappingURL=replacement.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGJhYmVsL3RyYXZlcnNlL2xpYi9wYXRoL3JlcGxhY2VtZW50LmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViLDhDQUE2QztBQUM3QztBQUNBLENBQUMsRUFBQztBQUNGLG9CQUFvQjtBQUNwQix1Q0FBdUM7QUFDdkMscUJBQXFCO0FBQ3JCLG1CQUFtQjtBQUNuQiwyQkFBMkI7QUFDM0IsK0JBQStCO0FBQy9CLGlCQUFpQixtQkFBTyxDQUFDLDhFQUFtQjtBQUM1QyxhQUFhLG1CQUFPLENBQUMsc0VBQWE7QUFDbEMsY0FBYyxtQkFBTyxDQUFDLDBFQUFZO0FBQ2xDLGFBQWEsbUJBQU8sQ0FBQyxzRUFBYTtBQUNsQyxvQkFBb0IsbUJBQU8sQ0FBQyx3RkFBbUI7QUFDL0MsY0FBYyxtQkFBTyxDQUFDLHNFQUFlO0FBQ3JDLFNBQVMsbUJBQU8sQ0FBQyxvRUFBYztBQUMvQixlQUFlLG1CQUFPLENBQUMsOEVBQWM7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsWUFBWTtBQUNsQztBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQSw2QkFBNkIsa0NBQWtDO0FBQy9EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTs7QUFFQSIsInNvdXJjZXMiOlsid2VicGFjazovL3JlcG8tdmlzdWFsaXplci8uL25vZGVfbW9kdWxlcy9AYmFiZWwvdHJhdmVyc2UvbGliL3BhdGgvcmVwbGFjZW1lbnQuanM/N2U3MSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuX3JlcGxhY2VXaXRoID0gX3JlcGxhY2VXaXRoO1xuZXhwb3J0cy5yZXBsYWNlRXhwcmVzc2lvbldpdGhTdGF0ZW1lbnRzID0gcmVwbGFjZUV4cHJlc3Npb25XaXRoU3RhdGVtZW50cztcbmV4cG9ydHMucmVwbGFjZUlubGluZSA9IHJlcGxhY2VJbmxpbmU7XG5leHBvcnRzLnJlcGxhY2VXaXRoID0gcmVwbGFjZVdpdGg7XG5leHBvcnRzLnJlcGxhY2VXaXRoTXVsdGlwbGUgPSByZXBsYWNlV2l0aE11bHRpcGxlO1xuZXhwb3J0cy5yZXBsYWNlV2l0aFNvdXJjZVN0cmluZyA9IHJlcGxhY2VXaXRoU291cmNlU3RyaW5nO1xudmFyIF9jb2RlRnJhbWUgPSByZXF1aXJlKFwiQGJhYmVsL2NvZGUtZnJhbWVcIik7XG52YXIgX2luZGV4ID0gcmVxdWlyZShcIi4uL2luZGV4LmpzXCIpO1xudmFyIF9pbmRleDIgPSByZXF1aXJlKFwiLi9pbmRleC5qc1wiKTtcbnZhciBfY2FjaGUgPSByZXF1aXJlKFwiLi4vY2FjaGUuanNcIik7XG52YXIgX21vZGlmaWNhdGlvbiA9IHJlcXVpcmUoXCIuL21vZGlmaWNhdGlvbi5qc1wiKTtcbnZhciBfcGFyc2VyID0gcmVxdWlyZShcIkBiYWJlbC9wYXJzZXJcIik7XG52YXIgX3QgPSByZXF1aXJlKFwiQGJhYmVsL3R5cGVzXCIpO1xudmFyIF9jb250ZXh0ID0gcmVxdWlyZShcIi4vY29udGV4dC5qc1wiKTtcbmNvbnN0IHtcbiAgRlVOQ1RJT05fVFlQRVMsXG4gIGFycm93RnVuY3Rpb25FeHByZXNzaW9uLFxuICBhc3NpZ25tZW50RXhwcmVzc2lvbixcbiAgYXdhaXRFeHByZXNzaW9uLFxuICBibG9ja1N0YXRlbWVudCxcbiAgYnVpbGRVbmRlZmluZWROb2RlLFxuICBjYWxsRXhwcmVzc2lvbixcbiAgY2xvbmVOb2RlLFxuICBjb25kaXRpb25hbEV4cHJlc3Npb24sXG4gIGV4cHJlc3Npb25TdGF0ZW1lbnQsXG4gIGdldEJpbmRpbmdJZGVudGlmaWVycyxcbiAgaWRlbnRpZmllcixcbiAgaW5oZXJpdExlYWRpbmdDb21tZW50cyxcbiAgaW5oZXJpdFRyYWlsaW5nQ29tbWVudHMsXG4gIGluaGVyaXRzQ29tbWVudHMsXG4gIGlzQmxvY2tTdGF0ZW1lbnQsXG4gIGlzRW1wdHlTdGF0ZW1lbnQsXG4gIGlzRXhwcmVzc2lvbixcbiAgaXNFeHByZXNzaW9uU3RhdGVtZW50LFxuICBpc0lmU3RhdGVtZW50LFxuICBpc1Byb2dyYW0sXG4gIGlzU3RhdGVtZW50LFxuICBpc1ZhcmlhYmxlRGVjbGFyYXRpb24sXG4gIHJlbW92ZUNvbW1lbnRzLFxuICByZXR1cm5TdGF0ZW1lbnQsXG4gIHNlcXVlbmNlRXhwcmVzc2lvbixcbiAgdmFsaWRhdGUsXG4gIHlpZWxkRXhwcmVzc2lvblxufSA9IF90O1xuZnVuY3Rpb24gcmVwbGFjZVdpdGhNdWx0aXBsZShub2Rlcykge1xuICB2YXIgX2dldENhY2hlZFBhdGhzO1xuICBfY29udGV4dC5yZXN5bmMuY2FsbCh0aGlzKTtcbiAgY29uc3QgdmVyaWZpZWROb2RlcyA9IF9tb2RpZmljYXRpb24uX3ZlcmlmeU5vZGVMaXN0LmNhbGwodGhpcywgbm9kZXMpO1xuICBpbmhlcml0TGVhZGluZ0NvbW1lbnRzKHZlcmlmaWVkTm9kZXNbMF0sIHRoaXMubm9kZSk7XG4gIGluaGVyaXRUcmFpbGluZ0NvbW1lbnRzKHZlcmlmaWVkTm9kZXNbdmVyaWZpZWROb2Rlcy5sZW5ndGggLSAxXSwgdGhpcy5ub2RlKTtcbiAgKF9nZXRDYWNoZWRQYXRocyA9ICgwLCBfY2FjaGUuZ2V0Q2FjaGVkUGF0aHMpKHRoaXMpKSA9PSBudWxsIHx8IF9nZXRDYWNoZWRQYXRocy5kZWxldGUodGhpcy5ub2RlKTtcbiAgdGhpcy5ub2RlID0gdGhpcy5jb250YWluZXJbdGhpcy5rZXldID0gbnVsbDtcbiAgY29uc3QgcGF0aHMgPSB0aGlzLmluc2VydEFmdGVyKG5vZGVzKTtcbiAgaWYgKHRoaXMubm9kZSkge1xuICAgIHRoaXMucmVxdWV1ZSgpO1xuICB9IGVsc2Uge1xuICAgIHRoaXMucmVtb3ZlKCk7XG4gIH1cbiAgcmV0dXJuIHBhdGhzO1xufVxuZnVuY3Rpb24gcmVwbGFjZVdpdGhTb3VyY2VTdHJpbmcocmVwbGFjZW1lbnQpIHtcbiAgX2NvbnRleHQucmVzeW5jLmNhbGwodGhpcyk7XG4gIGxldCBhc3Q7XG4gIHRyeSB7XG4gICAgcmVwbGFjZW1lbnQgPSBgKCR7cmVwbGFjZW1lbnR9KWA7XG4gICAgYXN0ID0gKDAsIF9wYXJzZXIucGFyc2UpKHJlcGxhY2VtZW50KTtcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgY29uc3QgbG9jID0gZXJyLmxvYztcbiAgICBpZiAobG9jKSB7XG4gICAgICBlcnIubWVzc2FnZSArPSBcIiAtIG1ha2Ugc3VyZSB0aGlzIGlzIGFuIGV4cHJlc3Npb24uXFxuXCIgKyAoMCwgX2NvZGVGcmFtZS5jb2RlRnJhbWVDb2x1bW5zKShyZXBsYWNlbWVudCwge1xuICAgICAgICBzdGFydDoge1xuICAgICAgICAgIGxpbmU6IGxvYy5saW5lLFxuICAgICAgICAgIGNvbHVtbjogbG9jLmNvbHVtbiArIDFcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICBlcnIuY29kZSA9IFwiQkFCRUxfUkVQTEFDRV9TT1VSQ0VfRVJST1JcIjtcbiAgICB9XG4gICAgdGhyb3cgZXJyO1xuICB9XG4gIGNvbnN0IGV4cHJlc3Npb25BU1QgPSBhc3QucHJvZ3JhbS5ib2R5WzBdLmV4cHJlc3Npb247XG4gIF9pbmRleC5kZWZhdWx0LnJlbW92ZVByb3BlcnRpZXMoZXhwcmVzc2lvbkFTVCk7XG4gIHJldHVybiB0aGlzLnJlcGxhY2VXaXRoKGV4cHJlc3Npb25BU1QpO1xufVxuZnVuY3Rpb24gcmVwbGFjZVdpdGgocmVwbGFjZW1lbnRQYXRoKSB7XG4gIF9jb250ZXh0LnJlc3luYy5jYWxsKHRoaXMpO1xuICBpZiAodGhpcy5yZW1vdmVkKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiWW91IGNhbid0IHJlcGxhY2UgdGhpcyBub2RlLCB3ZSd2ZSBhbHJlYWR5IHJlbW92ZWQgaXRcIik7XG4gIH1cbiAgbGV0IHJlcGxhY2VtZW50ID0gcmVwbGFjZW1lbnRQYXRoIGluc3RhbmNlb2YgX2luZGV4Mi5kZWZhdWx0ID8gcmVwbGFjZW1lbnRQYXRoLm5vZGUgOiByZXBsYWNlbWVudFBhdGg7XG4gIGlmICghcmVwbGFjZW1lbnQpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJZb3UgcGFzc2VkIGBwYXRoLnJlcGxhY2VXaXRoKClgIGEgZmFsc3kgbm9kZSwgdXNlIGBwYXRoLnJlbW92ZSgpYCBpbnN0ZWFkXCIpO1xuICB9XG4gIGlmICh0aGlzLm5vZGUgPT09IHJlcGxhY2VtZW50KSB7XG4gICAgcmV0dXJuIFt0aGlzXTtcbiAgfVxuICBpZiAodGhpcy5pc1Byb2dyYW0oKSAmJiAhaXNQcm9ncmFtKHJlcGxhY2VtZW50KSkge1xuICAgIHRocm93IG5ldyBFcnJvcihcIllvdSBjYW4gb25seSByZXBsYWNlIGEgUHJvZ3JhbSByb290IG5vZGUgd2l0aCBhbm90aGVyIFByb2dyYW0gbm9kZVwiKTtcbiAgfVxuICBpZiAoQXJyYXkuaXNBcnJheShyZXBsYWNlbWVudCkpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJEb24ndCB1c2UgYHBhdGgucmVwbGFjZVdpdGgoKWAgd2l0aCBhbiBhcnJheSBvZiBub2RlcywgdXNlIGBwYXRoLnJlcGxhY2VXaXRoTXVsdGlwbGUoKWBcIik7XG4gIH1cbiAgaWYgKHR5cGVvZiByZXBsYWNlbWVudCA9PT0gXCJzdHJpbmdcIikge1xuICAgIHRocm93IG5ldyBFcnJvcihcIkRvbid0IHVzZSBgcGF0aC5yZXBsYWNlV2l0aCgpYCB3aXRoIGEgc291cmNlIHN0cmluZywgdXNlIGBwYXRoLnJlcGxhY2VXaXRoU291cmNlU3RyaW5nKClgXCIpO1xuICB9XG4gIGxldCBub2RlUGF0aCA9IFwiXCI7XG4gIGlmICh0aGlzLmlzTm9kZVR5cGUoXCJTdGF0ZW1lbnRcIikgJiYgaXNFeHByZXNzaW9uKHJlcGxhY2VtZW50KSkge1xuICAgIGlmICghdGhpcy5jYW5IYXZlVmFyaWFibGVEZWNsYXJhdGlvbk9yRXhwcmVzc2lvbigpICYmICF0aGlzLmNhblN3YXBCZXR3ZWVuRXhwcmVzc2lvbkFuZFN0YXRlbWVudChyZXBsYWNlbWVudCkgJiYgIXRoaXMucGFyZW50UGF0aC5pc0V4cG9ydERlZmF1bHREZWNsYXJhdGlvbigpKSB7XG4gICAgICByZXBsYWNlbWVudCA9IGV4cHJlc3Npb25TdGF0ZW1lbnQocmVwbGFjZW1lbnQpO1xuICAgICAgbm9kZVBhdGggPSBcImV4cHJlc3Npb25cIjtcbiAgICB9XG4gIH1cbiAgaWYgKHRoaXMuaXNOb2RlVHlwZShcIkV4cHJlc3Npb25cIikgJiYgaXNTdGF0ZW1lbnQocmVwbGFjZW1lbnQpKSB7XG4gICAgaWYgKCF0aGlzLmNhbkhhdmVWYXJpYWJsZURlY2xhcmF0aW9uT3JFeHByZXNzaW9uKCkgJiYgIXRoaXMuY2FuU3dhcEJldHdlZW5FeHByZXNzaW9uQW5kU3RhdGVtZW50KHJlcGxhY2VtZW50KSkge1xuICAgICAgcmV0dXJuIHRoaXMucmVwbGFjZUV4cHJlc3Npb25XaXRoU3RhdGVtZW50cyhbcmVwbGFjZW1lbnRdKTtcbiAgICB9XG4gIH1cbiAgY29uc3Qgb2xkTm9kZSA9IHRoaXMubm9kZTtcbiAgaWYgKG9sZE5vZGUpIHtcbiAgICBpbmhlcml0c0NvbW1lbnRzKHJlcGxhY2VtZW50LCBvbGROb2RlKTtcbiAgICByZW1vdmVDb21tZW50cyhvbGROb2RlKTtcbiAgfVxuICBfcmVwbGFjZVdpdGguY2FsbCh0aGlzLCByZXBsYWNlbWVudCk7XG4gIHRoaXMudHlwZSA9IHJlcGxhY2VtZW50LnR5cGU7XG4gIF9jb250ZXh0LnNldFNjb3BlLmNhbGwodGhpcyk7XG4gIHRoaXMucmVxdWV1ZSgpO1xuICByZXR1cm4gW25vZGVQYXRoID8gdGhpcy5nZXQobm9kZVBhdGgpIDogdGhpc107XG59XG5mdW5jdGlvbiBfcmVwbGFjZVdpdGgobm9kZSkge1xuICB2YXIgX2dldENhY2hlZFBhdGhzMjtcbiAgaWYgKCF0aGlzLmNvbnRhaW5lcikge1xuICAgIHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcIkNvbnRhaW5lciBpcyBmYWxzeVwiKTtcbiAgfVxuICBpZiAodGhpcy5pbkxpc3QpIHtcbiAgICB2YWxpZGF0ZSh0aGlzLnBhcmVudCwgdGhpcy5rZXksIFtub2RlXSk7XG4gIH0gZWxzZSB7XG4gICAgdmFsaWRhdGUodGhpcy5wYXJlbnQsIHRoaXMua2V5LCBub2RlKTtcbiAgfVxuICB0aGlzLmRlYnVnKGBSZXBsYWNlIHdpdGggJHtub2RlID09IG51bGwgPyB2b2lkIDAgOiBub2RlLnR5cGV9YCk7XG4gIChfZ2V0Q2FjaGVkUGF0aHMyID0gKDAsIF9jYWNoZS5nZXRDYWNoZWRQYXRocykodGhpcykpID09IG51bGwgfHwgX2dldENhY2hlZFBhdGhzMi5zZXQobm9kZSwgdGhpcykuZGVsZXRlKHRoaXMubm9kZSk7XG4gIHRoaXMubm9kZSA9IG5vZGU7XG4gIHRoaXMuY29udGFpbmVyW3RoaXMua2V5XSA9IG5vZGU7XG59XG5mdW5jdGlvbiByZXBsYWNlRXhwcmVzc2lvbldpdGhTdGF0ZW1lbnRzKG5vZGVzKSB7XG4gIF9jb250ZXh0LnJlc3luYy5jYWxsKHRoaXMpO1xuICBjb25zdCBkZWNsYXJzID0gW107XG4gIGNvbnN0IG5vZGVzQXNTaW5nbGVFeHByZXNzaW9uID0gZ2F0aGVyU2VxdWVuY2VFeHByZXNzaW9ucyhub2RlcywgZGVjbGFycyk7XG4gIGlmIChub2Rlc0FzU2luZ2xlRXhwcmVzc2lvbikge1xuICAgIGZvciAoY29uc3QgaWQgb2YgZGVjbGFycykgdGhpcy5zY29wZS5wdXNoKHtcbiAgICAgIGlkXG4gICAgfSk7XG4gICAgcmV0dXJuIHRoaXMucmVwbGFjZVdpdGgobm9kZXNBc1NpbmdsZUV4cHJlc3Npb24pWzBdLmdldChcImV4cHJlc3Npb25zXCIpO1xuICB9XG4gIGNvbnN0IGZ1bmN0aW9uUGFyZW50ID0gdGhpcy5nZXRGdW5jdGlvblBhcmVudCgpO1xuICBjb25zdCBpc1BhcmVudEFzeW5jID0gZnVuY3Rpb25QYXJlbnQgPT0gbnVsbCA/IHZvaWQgMCA6IGZ1bmN0aW9uUGFyZW50Lm5vZGUuYXN5bmM7XG4gIGNvbnN0IGlzUGFyZW50R2VuZXJhdG9yID0gZnVuY3Rpb25QYXJlbnQgPT0gbnVsbCA/IHZvaWQgMCA6IGZ1bmN0aW9uUGFyZW50Lm5vZGUuZ2VuZXJhdG9yO1xuICBjb25zdCBjb250YWluZXIgPSBhcnJvd0Z1bmN0aW9uRXhwcmVzc2lvbihbXSwgYmxvY2tTdGF0ZW1lbnQobm9kZXMpKTtcbiAgdGhpcy5yZXBsYWNlV2l0aChjYWxsRXhwcmVzc2lvbihjb250YWluZXIsIFtdKSk7XG4gIGNvbnN0IGNhbGxlZSA9IHRoaXMuZ2V0KFwiY2FsbGVlXCIpO1xuICBjYWxsZWUuZ2V0KFwiYm9keVwiKS5zY29wZS5ob2lzdFZhcmlhYmxlcyhpZCA9PiB0aGlzLnNjb3BlLnB1c2goe1xuICAgIGlkXG4gIH0pKTtcbiAgY29uc3QgY29tcGxldGlvblJlY29yZHMgPSBjYWxsZWUuZ2V0Q29tcGxldGlvblJlY29yZHMoKTtcbiAgZm9yIChjb25zdCBwYXRoIG9mIGNvbXBsZXRpb25SZWNvcmRzKSB7XG4gICAgaWYgKCFwYXRoLmlzRXhwcmVzc2lvblN0YXRlbWVudCgpKSBjb250aW51ZTtcbiAgICBjb25zdCBsb29wID0gcGF0aC5maW5kUGFyZW50KHBhdGggPT4gcGF0aC5pc0xvb3AoKSk7XG4gICAgaWYgKGxvb3ApIHtcbiAgICAgIGxldCB1aWQgPSBsb29wLmdldERhdGEoXCJleHByZXNzaW9uUmVwbGFjZW1lbnRSZXR1cm5VaWRcIik7XG4gICAgICBpZiAoIXVpZCkge1xuICAgICAgICB1aWQgPSBjYWxsZWUuc2NvcGUuZ2VuZXJhdGVEZWNsYXJlZFVpZElkZW50aWZpZXIoXCJyZXRcIik7XG4gICAgICAgIGNhbGxlZS5nZXQoXCJib2R5XCIpLnB1c2hDb250YWluZXIoXCJib2R5XCIsIHJldHVyblN0YXRlbWVudChjbG9uZU5vZGUodWlkKSkpO1xuICAgICAgICBsb29wLnNldERhdGEoXCJleHByZXNzaW9uUmVwbGFjZW1lbnRSZXR1cm5VaWRcIiwgdWlkKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHVpZCA9IGlkZW50aWZpZXIodWlkLm5hbWUpO1xuICAgICAgfVxuICAgICAgcGF0aC5nZXQoXCJleHByZXNzaW9uXCIpLnJlcGxhY2VXaXRoKGFzc2lnbm1lbnRFeHByZXNzaW9uKFwiPVwiLCBjbG9uZU5vZGUodWlkKSwgcGF0aC5ub2RlLmV4cHJlc3Npb24pKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcGF0aC5yZXBsYWNlV2l0aChyZXR1cm5TdGF0ZW1lbnQocGF0aC5ub2RlLmV4cHJlc3Npb24pKTtcbiAgICB9XG4gIH1cbiAgY2FsbGVlLmFycm93RnVuY3Rpb25Ub0V4cHJlc3Npb24oKTtcbiAgY29uc3QgbmV3Q2FsbGVlID0gY2FsbGVlO1xuICBjb25zdCBuZWVkVG9Bd2FpdEZ1bmN0aW9uID0gaXNQYXJlbnRBc3luYyAmJiBfaW5kZXguZGVmYXVsdC5oYXNUeXBlKG5ld0NhbGxlZS5ub2RlLmJvZHksIFwiQXdhaXRFeHByZXNzaW9uXCIsIEZVTkNUSU9OX1RZUEVTKTtcbiAgY29uc3QgbmVlZFRvWWllbGRGdW5jdGlvbiA9IGlzUGFyZW50R2VuZXJhdG9yICYmIF9pbmRleC5kZWZhdWx0Lmhhc1R5cGUobmV3Q2FsbGVlLm5vZGUuYm9keSwgXCJZaWVsZEV4cHJlc3Npb25cIiwgRlVOQ1RJT05fVFlQRVMpO1xuICBpZiAobmVlZFRvQXdhaXRGdW5jdGlvbikge1xuICAgIG5ld0NhbGxlZS5zZXQoXCJhc3luY1wiLCB0cnVlKTtcbiAgICBpZiAoIW5lZWRUb1lpZWxkRnVuY3Rpb24pIHtcbiAgICAgIHRoaXMucmVwbGFjZVdpdGgoYXdhaXRFeHByZXNzaW9uKHRoaXMubm9kZSkpO1xuICAgIH1cbiAgfVxuICBpZiAobmVlZFRvWWllbGRGdW5jdGlvbikge1xuICAgIG5ld0NhbGxlZS5zZXQoXCJnZW5lcmF0b3JcIiwgdHJ1ZSk7XG4gICAgdGhpcy5yZXBsYWNlV2l0aCh5aWVsZEV4cHJlc3Npb24odGhpcy5ub2RlLCB0cnVlKSk7XG4gIH1cbiAgcmV0dXJuIG5ld0NhbGxlZS5nZXQoXCJib2R5LmJvZHlcIik7XG59XG5mdW5jdGlvbiBnYXRoZXJTZXF1ZW5jZUV4cHJlc3Npb25zKG5vZGVzLCBkZWNsYXJzKSB7XG4gIGNvbnN0IGV4cHJzID0gW107XG4gIGxldCBlbnN1cmVMYXN0VW5kZWZpbmVkID0gdHJ1ZTtcbiAgZm9yIChjb25zdCBub2RlIG9mIG5vZGVzKSB7XG4gICAgaWYgKCFpc0VtcHR5U3RhdGVtZW50KG5vZGUpKSB7XG4gICAgICBlbnN1cmVMYXN0VW5kZWZpbmVkID0gZmFsc2U7XG4gICAgfVxuICAgIGlmIChpc0V4cHJlc3Npb24obm9kZSkpIHtcbiAgICAgIGV4cHJzLnB1c2gobm9kZSk7XG4gICAgfSBlbHNlIGlmIChpc0V4cHJlc3Npb25TdGF0ZW1lbnQobm9kZSkpIHtcbiAgICAgIGV4cHJzLnB1c2gobm9kZS5leHByZXNzaW9uKTtcbiAgICB9IGVsc2UgaWYgKGlzVmFyaWFibGVEZWNsYXJhdGlvbihub2RlKSkge1xuICAgICAgaWYgKG5vZGUua2luZCAhPT0gXCJ2YXJcIikgcmV0dXJuO1xuICAgICAgZm9yIChjb25zdCBkZWNsYXIgb2Ygbm9kZS5kZWNsYXJhdGlvbnMpIHtcbiAgICAgICAgY29uc3QgYmluZGluZ3MgPSBnZXRCaW5kaW5nSWRlbnRpZmllcnMoZGVjbGFyKTtcbiAgICAgICAgZm9yIChjb25zdCBrZXkgb2YgT2JqZWN0LmtleXMoYmluZGluZ3MpKSB7XG4gICAgICAgICAgZGVjbGFycy5wdXNoKGNsb25lTm9kZShiaW5kaW5nc1trZXldKSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGRlY2xhci5pbml0KSB7XG4gICAgICAgICAgZXhwcnMucHVzaChhc3NpZ25tZW50RXhwcmVzc2lvbihcIj1cIiwgZGVjbGFyLmlkLCBkZWNsYXIuaW5pdCkpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBlbnN1cmVMYXN0VW5kZWZpbmVkID0gdHJ1ZTtcbiAgICB9IGVsc2UgaWYgKGlzSWZTdGF0ZW1lbnQobm9kZSkpIHtcbiAgICAgIGNvbnN0IGNvbnNlcXVlbnQgPSBub2RlLmNvbnNlcXVlbnQgPyBnYXRoZXJTZXF1ZW5jZUV4cHJlc3Npb25zKFtub2RlLmNvbnNlcXVlbnRdLCBkZWNsYXJzKSA6IGJ1aWxkVW5kZWZpbmVkTm9kZSgpO1xuICAgICAgY29uc3QgYWx0ZXJuYXRlID0gbm9kZS5hbHRlcm5hdGUgPyBnYXRoZXJTZXF1ZW5jZUV4cHJlc3Npb25zKFtub2RlLmFsdGVybmF0ZV0sIGRlY2xhcnMpIDogYnVpbGRVbmRlZmluZWROb2RlKCk7XG4gICAgICBpZiAoIWNvbnNlcXVlbnQgfHwgIWFsdGVybmF0ZSkgcmV0dXJuO1xuICAgICAgZXhwcnMucHVzaChjb25kaXRpb25hbEV4cHJlc3Npb24obm9kZS50ZXN0LCBjb25zZXF1ZW50LCBhbHRlcm5hdGUpKTtcbiAgICB9IGVsc2UgaWYgKGlzQmxvY2tTdGF0ZW1lbnQobm9kZSkpIHtcbiAgICAgIGNvbnN0IGJvZHkgPSBnYXRoZXJTZXF1ZW5jZUV4cHJlc3Npb25zKG5vZGUuYm9keSwgZGVjbGFycyk7XG4gICAgICBpZiAoIWJvZHkpIHJldHVybjtcbiAgICAgIGV4cHJzLnB1c2goYm9keSk7XG4gICAgfSBlbHNlIGlmIChpc0VtcHR5U3RhdGVtZW50KG5vZGUpKSB7XG4gICAgICBpZiAobm9kZXMuaW5kZXhPZihub2RlKSA9PT0gMCkge1xuICAgICAgICBlbnN1cmVMYXN0VW5kZWZpbmVkID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgfVxuICBpZiAoZW5zdXJlTGFzdFVuZGVmaW5lZCkgZXhwcnMucHVzaChidWlsZFVuZGVmaW5lZE5vZGUoKSk7XG4gIGlmIChleHBycy5sZW5ndGggPT09IDEpIHtcbiAgICByZXR1cm4gZXhwcnNbMF07XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIHNlcXVlbmNlRXhwcmVzc2lvbihleHBycyk7XG4gIH1cbn1cbmZ1bmN0aW9uIHJlcGxhY2VJbmxpbmUobm9kZXMpIHtcbiAgX2NvbnRleHQucmVzeW5jLmNhbGwodGhpcyk7XG4gIGlmIChBcnJheS5pc0FycmF5KG5vZGVzKSkge1xuICAgIGlmIChBcnJheS5pc0FycmF5KHRoaXMuY29udGFpbmVyKSkge1xuICAgICAgbm9kZXMgPSBfbW9kaWZpY2F0aW9uLl92ZXJpZnlOb2RlTGlzdC5jYWxsKHRoaXMsIG5vZGVzKTtcbiAgICAgIGNvbnN0IHBhdGhzID0gX21vZGlmaWNhdGlvbi5fY29udGFpbmVySW5zZXJ0QWZ0ZXIuY2FsbCh0aGlzLCBub2Rlcyk7XG4gICAgICB0aGlzLnJlbW92ZSgpO1xuICAgICAgcmV0dXJuIHBhdGhzO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gdGhpcy5yZXBsYWNlV2l0aE11bHRpcGxlKG5vZGVzKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIHRoaXMucmVwbGFjZVdpdGgobm9kZXMpO1xuICB9XG59XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXJlcGxhY2VtZW50LmpzLm1hcFxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@babel/traverse/lib/path/replacement.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@babel/traverse/lib/scope/binding.js":
/*!***********************************************************!*\
  !*** ./node_modules/@babel/traverse/lib/scope/binding.js ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports[\"default\"] = void 0;\nclass Binding {\n  constructor({\n    identifier,\n    scope,\n    path,\n    kind\n  }) {\n    this.identifier = void 0;\n    this.scope = void 0;\n    this.path = void 0;\n    this.kind = void 0;\n    this.constantViolations = [];\n    this.constant = true;\n    this.referencePaths = [];\n    this.referenced = false;\n    this.references = 0;\n    this.identifier = identifier;\n    this.scope = scope;\n    this.path = path;\n    this.kind = kind;\n    if ((kind === \"var\" || kind === \"hoisted\") && isInitInLoop(path)) {\n      this.reassign(path);\n    }\n    this.clearValue();\n  }\n  deoptValue() {\n    this.clearValue();\n    this.hasDeoptedValue = true;\n  }\n  setValue(value) {\n    if (this.hasDeoptedValue) return;\n    this.hasValue = true;\n    this.value = value;\n  }\n  clearValue() {\n    this.hasDeoptedValue = false;\n    this.hasValue = false;\n    this.value = null;\n  }\n  reassign(path) {\n    this.constant = false;\n    if (this.constantViolations.includes(path)) {\n      return;\n    }\n    this.constantViolations.push(path);\n  }\n  reference(path) {\n    if (this.referencePaths.includes(path)) {\n      return;\n    }\n    this.referenced = true;\n    this.references++;\n    this.referencePaths.push(path);\n  }\n  dereference() {\n    this.references--;\n    this.referenced = !!this.references;\n  }\n}\nexports[\"default\"] = Binding;\nfunction isInitInLoop(path) {\n  const isFunctionDeclarationOrHasInit = !path.isVariableDeclarator() || path.node.init;\n  for (let {\n    parentPath,\n    key\n  } = path; parentPath; {\n    parentPath,\n    key\n  } = parentPath) {\n    if (parentPath.isFunctionParent()) return false;\n    if (key === \"left\" && parentPath.isForXStatement() || isFunctionDeclarationOrHasInit && key === \"body\" && parentPath.isLoop()) {\n      return true;\n    }\n  }\n  return false;\n}\n\n//# sourceMappingURL=binding.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGJhYmVsL3RyYXZlcnNlL2xpYi9zY29wZS9iaW5kaW5nLmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViLDhDQUE2QztBQUM3QztBQUNBLENBQUMsRUFBQztBQUNGLGtCQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSSxRQUFRO0FBQ1o7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSIsInNvdXJjZXMiOlsid2VicGFjazovL3JlcG8tdmlzdWFsaXplci8uL25vZGVfbW9kdWxlcy9AYmFiZWwvdHJhdmVyc2UvbGliL3Njb3BlL2JpbmRpbmcuanM/NjFhOSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuZGVmYXVsdCA9IHZvaWQgMDtcbmNsYXNzIEJpbmRpbmcge1xuICBjb25zdHJ1Y3Rvcih7XG4gICAgaWRlbnRpZmllcixcbiAgICBzY29wZSxcbiAgICBwYXRoLFxuICAgIGtpbmRcbiAgfSkge1xuICAgIHRoaXMuaWRlbnRpZmllciA9IHZvaWQgMDtcbiAgICB0aGlzLnNjb3BlID0gdm9pZCAwO1xuICAgIHRoaXMucGF0aCA9IHZvaWQgMDtcbiAgICB0aGlzLmtpbmQgPSB2b2lkIDA7XG4gICAgdGhpcy5jb25zdGFudFZpb2xhdGlvbnMgPSBbXTtcbiAgICB0aGlzLmNvbnN0YW50ID0gdHJ1ZTtcbiAgICB0aGlzLnJlZmVyZW5jZVBhdGhzID0gW107XG4gICAgdGhpcy5yZWZlcmVuY2VkID0gZmFsc2U7XG4gICAgdGhpcy5yZWZlcmVuY2VzID0gMDtcbiAgICB0aGlzLmlkZW50aWZpZXIgPSBpZGVudGlmaWVyO1xuICAgIHRoaXMuc2NvcGUgPSBzY29wZTtcbiAgICB0aGlzLnBhdGggPSBwYXRoO1xuICAgIHRoaXMua2luZCA9IGtpbmQ7XG4gICAgaWYgKChraW5kID09PSBcInZhclwiIHx8IGtpbmQgPT09IFwiaG9pc3RlZFwiKSAmJiBpc0luaXRJbkxvb3AocGF0aCkpIHtcbiAgICAgIHRoaXMucmVhc3NpZ24ocGF0aCk7XG4gICAgfVxuICAgIHRoaXMuY2xlYXJWYWx1ZSgpO1xuICB9XG4gIGRlb3B0VmFsdWUoKSB7XG4gICAgdGhpcy5jbGVhclZhbHVlKCk7XG4gICAgdGhpcy5oYXNEZW9wdGVkVmFsdWUgPSB0cnVlO1xuICB9XG4gIHNldFZhbHVlKHZhbHVlKSB7XG4gICAgaWYgKHRoaXMuaGFzRGVvcHRlZFZhbHVlKSByZXR1cm47XG4gICAgdGhpcy5oYXNWYWx1ZSA9IHRydWU7XG4gICAgdGhpcy52YWx1ZSA9IHZhbHVlO1xuICB9XG4gIGNsZWFyVmFsdWUoKSB7XG4gICAgdGhpcy5oYXNEZW9wdGVkVmFsdWUgPSBmYWxzZTtcbiAgICB0aGlzLmhhc1ZhbHVlID0gZmFsc2U7XG4gICAgdGhpcy52YWx1ZSA9IG51bGw7XG4gIH1cbiAgcmVhc3NpZ24ocGF0aCkge1xuICAgIHRoaXMuY29uc3RhbnQgPSBmYWxzZTtcbiAgICBpZiAodGhpcy5jb25zdGFudFZpb2xhdGlvbnMuaW5jbHVkZXMocGF0aCkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5jb25zdGFudFZpb2xhdGlvbnMucHVzaChwYXRoKTtcbiAgfVxuICByZWZlcmVuY2UocGF0aCkge1xuICAgIGlmICh0aGlzLnJlZmVyZW5jZVBhdGhzLmluY2x1ZGVzKHBhdGgpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMucmVmZXJlbmNlZCA9IHRydWU7XG4gICAgdGhpcy5yZWZlcmVuY2VzKys7XG4gICAgdGhpcy5yZWZlcmVuY2VQYXRocy5wdXNoKHBhdGgpO1xuICB9XG4gIGRlcmVmZXJlbmNlKCkge1xuICAgIHRoaXMucmVmZXJlbmNlcy0tO1xuICAgIHRoaXMucmVmZXJlbmNlZCA9ICEhdGhpcy5yZWZlcmVuY2VzO1xuICB9XG59XG5leHBvcnRzLmRlZmF1bHQgPSBCaW5kaW5nO1xuZnVuY3Rpb24gaXNJbml0SW5Mb29wKHBhdGgpIHtcbiAgY29uc3QgaXNGdW5jdGlvbkRlY2xhcmF0aW9uT3JIYXNJbml0ID0gIXBhdGguaXNWYXJpYWJsZURlY2xhcmF0b3IoKSB8fCBwYXRoLm5vZGUuaW5pdDtcbiAgZm9yIChsZXQge1xuICAgIHBhcmVudFBhdGgsXG4gICAga2V5XG4gIH0gPSBwYXRoOyBwYXJlbnRQYXRoOyB7XG4gICAgcGFyZW50UGF0aCxcbiAgICBrZXlcbiAgfSA9IHBhcmVudFBhdGgpIHtcbiAgICBpZiAocGFyZW50UGF0aC5pc0Z1bmN0aW9uUGFyZW50KCkpIHJldHVybiBmYWxzZTtcbiAgICBpZiAoa2V5ID09PSBcImxlZnRcIiAmJiBwYXJlbnRQYXRoLmlzRm9yWFN0YXRlbWVudCgpIHx8IGlzRnVuY3Rpb25EZWNsYXJhdGlvbk9ySGFzSW5pdCAmJiBrZXkgPT09IFwiYm9keVwiICYmIHBhcmVudFBhdGguaXNMb29wKCkpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gZmFsc2U7XG59XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWJpbmRpbmcuanMubWFwXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@babel/traverse/lib/scope/binding.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@babel/traverse/lib/scope/index.js":
/*!*********************************************************!*\
  !*** ./node_modules/@babel/traverse/lib/scope/index.js ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports[\"default\"] = void 0;\nvar _renamer = __webpack_require__(/*! ./lib/renamer.js */ \"(ssr)/./node_modules/@babel/traverse/lib/scope/lib/renamer.js\");\nvar _index = __webpack_require__(/*! ../index.js */ \"(ssr)/./node_modules/@babel/traverse/lib/index.js\");\nvar _traverseForScope = __webpack_require__(/*! ./traverseForScope.js */ \"(ssr)/./node_modules/@babel/traverse/lib/scope/traverseForScope.js\");\nvar _binding = __webpack_require__(/*! ./binding.js */ \"(ssr)/./node_modules/@babel/traverse/lib/scope/binding.js\");\nvar _t = __webpack_require__(/*! @babel/types */ \"(ssr)/./node_modules/@babel/types/lib/index.js\");\nvar t = _t;\nvar _cache = __webpack_require__(/*! ../cache.js */ \"(ssr)/./node_modules/@babel/traverse/lib/cache.js\");\nconst globalsBuiltinLower = __webpack_require__(/*! @babel/helper-globals/data/builtin-lower.json */ \"(ssr)/./node_modules/@babel/helper-globals/data/builtin-lower.json\"),\n  globalsBuiltinUpper = __webpack_require__(/*! @babel/helper-globals/data/builtin-upper.json */ \"(ssr)/./node_modules/@babel/helper-globals/data/builtin-upper.json\");\nconst {\n  assignmentExpression,\n  callExpression,\n  cloneNode,\n  getBindingIdentifiers,\n  identifier,\n  isArrayExpression,\n  isBinary,\n  isCallExpression,\n  isClass,\n  isClassBody,\n  isClassDeclaration,\n  isExportAllDeclaration,\n  isExportDefaultDeclaration,\n  isExportNamedDeclaration,\n  isFunctionDeclaration,\n  isIdentifier,\n  isImportDeclaration,\n  isLiteral,\n  isMemberExpression,\n  isMethod,\n  isModuleSpecifier,\n  isNullLiteral,\n  isObjectExpression,\n  isProperty,\n  isPureish,\n  isRegExpLiteral,\n  isSuper,\n  isTaggedTemplateExpression,\n  isTemplateLiteral,\n  isThisExpression,\n  isUnaryExpression,\n  isVariableDeclaration,\n  expressionStatement,\n  matchesPattern,\n  memberExpression,\n  numericLiteral,\n  toIdentifier,\n  variableDeclaration,\n  variableDeclarator,\n  isObjectProperty,\n  isTopicReference,\n  isMetaProperty,\n  isPrivateName,\n  isExportDeclaration,\n  buildUndefinedNode,\n  sequenceExpression\n} = _t;\nfunction gatherNodeParts(node, parts) {\n  switch (node == null ? void 0 : node.type) {\n    default:\n      if (isImportDeclaration(node) || isExportDeclaration(node)) {\n        var _node$specifiers;\n        if ((isExportAllDeclaration(node) || isExportNamedDeclaration(node) || isImportDeclaration(node)) && node.source) {\n          gatherNodeParts(node.source, parts);\n        } else if ((isExportNamedDeclaration(node) || isImportDeclaration(node)) && (_node$specifiers = node.specifiers) != null && _node$specifiers.length) {\n          for (const e of node.specifiers) gatherNodeParts(e, parts);\n        } else if ((isExportDefaultDeclaration(node) || isExportNamedDeclaration(node)) && node.declaration) {\n          gatherNodeParts(node.declaration, parts);\n        }\n      } else if (isModuleSpecifier(node)) {\n        gatherNodeParts(node.local, parts);\n      } else if (isLiteral(node) && !isNullLiteral(node) && !isRegExpLiteral(node) && !isTemplateLiteral(node)) {\n        parts.push(node.value);\n      }\n      break;\n    case \"MemberExpression\":\n    case \"OptionalMemberExpression\":\n    case \"JSXMemberExpression\":\n      gatherNodeParts(node.object, parts);\n      gatherNodeParts(node.property, parts);\n      break;\n    case \"Identifier\":\n    case \"JSXIdentifier\":\n      parts.push(node.name);\n      break;\n    case \"CallExpression\":\n    case \"OptionalCallExpression\":\n    case \"NewExpression\":\n      gatherNodeParts(node.callee, parts);\n      break;\n    case \"ObjectExpression\":\n    case \"ObjectPattern\":\n      for (const e of node.properties) {\n        gatherNodeParts(e, parts);\n      }\n      break;\n    case \"SpreadElement\":\n    case \"RestElement\":\n      gatherNodeParts(node.argument, parts);\n      break;\n    case \"ObjectProperty\":\n    case \"ObjectMethod\":\n    case \"ClassProperty\":\n    case \"ClassMethod\":\n    case \"ClassPrivateProperty\":\n    case \"ClassPrivateMethod\":\n      gatherNodeParts(node.key, parts);\n      break;\n    case \"ThisExpression\":\n      parts.push(\"this\");\n      break;\n    case \"Super\":\n      parts.push(\"super\");\n      break;\n    case \"Import\":\n    case \"ImportExpression\":\n      parts.push(\"import\");\n      break;\n    case \"DoExpression\":\n      parts.push(\"do\");\n      break;\n    case \"YieldExpression\":\n      parts.push(\"yield\");\n      gatherNodeParts(node.argument, parts);\n      break;\n    case \"AwaitExpression\":\n      parts.push(\"await\");\n      gatherNodeParts(node.argument, parts);\n      break;\n    case \"AssignmentExpression\":\n      gatherNodeParts(node.left, parts);\n      break;\n    case \"VariableDeclarator\":\n      gatherNodeParts(node.id, parts);\n      break;\n    case \"FunctionExpression\":\n    case \"FunctionDeclaration\":\n    case \"ClassExpression\":\n    case \"ClassDeclaration\":\n      gatherNodeParts(node.id, parts);\n      break;\n    case \"PrivateName\":\n      gatherNodeParts(node.id, parts);\n      break;\n    case \"ParenthesizedExpression\":\n      gatherNodeParts(node.expression, parts);\n      break;\n    case \"UnaryExpression\":\n    case \"UpdateExpression\":\n      gatherNodeParts(node.argument, parts);\n      break;\n    case \"MetaProperty\":\n      gatherNodeParts(node.meta, parts);\n      gatherNodeParts(node.property, parts);\n      break;\n    case \"JSXElement\":\n      gatherNodeParts(node.openingElement, parts);\n      break;\n    case \"JSXOpeningElement\":\n      gatherNodeParts(node.name, parts);\n      break;\n    case \"JSXFragment\":\n      gatherNodeParts(node.openingFragment, parts);\n      break;\n    case \"JSXOpeningFragment\":\n      parts.push(\"Fragment\");\n      break;\n    case \"JSXNamespacedName\":\n      gatherNodeParts(node.namespace, parts);\n      gatherNodeParts(node.name, parts);\n      break;\n  }\n}\nfunction resetScope(scope) {\n  scope.references = Object.create(null);\n  scope.uids = Object.create(null);\n  scope.bindings = Object.create(null);\n  scope.globals = Object.create(null);\n}\nfunction isAnonymousFunctionExpression(path) {\n  return path.isFunctionExpression() && !path.node.id || path.isArrowFunctionExpression();\n}\nvar NOT_LOCAL_BINDING = Symbol.for(\"should not be considered a local binding\");\nconst collectorVisitor = {\n  ForStatement(path) {\n    const declar = path.get(\"init\");\n    if (declar.isVar()) {\n      const {\n        scope\n      } = path;\n      const parentScope = scope.getFunctionParent() || scope.getProgramParent();\n      parentScope.registerBinding(\"var\", declar);\n    }\n  },\n  Declaration(path) {\n    if (path.isBlockScoped()) return;\n    if (path.isImportDeclaration()) return;\n    if (path.isExportDeclaration()) return;\n    const parent = path.scope.getFunctionParent() || path.scope.getProgramParent();\n    parent.registerDeclaration(path);\n  },\n  ImportDeclaration(path) {\n    const parent = path.scope.getBlockParent();\n    parent.registerDeclaration(path);\n  },\n  TSImportEqualsDeclaration(path) {\n    const parent = path.scope.getBlockParent();\n    parent.registerDeclaration(path);\n  },\n  ReferencedIdentifier(path, state) {\n    if (t.isTSQualifiedName(path.parent) && path.parent.right === path.node) {\n      return;\n    }\n    if (path.parentPath.isTSImportEqualsDeclaration()) return;\n    state.references.push(path);\n  },\n  ForXStatement(path, state) {\n    const left = path.get(\"left\");\n    if (left.isPattern() || left.isIdentifier()) {\n      state.constantViolations.push(path);\n    } else if (left.isVar()) {\n      const {\n        scope\n      } = path;\n      const parentScope = scope.getFunctionParent() || scope.getProgramParent();\n      parentScope.registerBinding(\"var\", left);\n    }\n  },\n  ExportDeclaration: {\n    exit(path) {\n      const {\n        node,\n        scope\n      } = path;\n      if (isExportAllDeclaration(node)) return;\n      const declar = node.declaration;\n      if (isClassDeclaration(declar) || isFunctionDeclaration(declar)) {\n        const id = declar.id;\n        if (!id) return;\n        const binding = scope.getBinding(id.name);\n        binding == null || binding.reference(path);\n      } else if (isVariableDeclaration(declar)) {\n        for (const decl of declar.declarations) {\n          for (const name of Object.keys(getBindingIdentifiers(decl))) {\n            const binding = scope.getBinding(name);\n            binding == null || binding.reference(path);\n          }\n        }\n      }\n    }\n  },\n  LabeledStatement(path) {\n    path.scope.getBlockParent().registerDeclaration(path);\n  },\n  AssignmentExpression(path, state) {\n    state.assignments.push(path);\n  },\n  UpdateExpression(path, state) {\n    state.constantViolations.push(path);\n  },\n  UnaryExpression(path, state) {\n    if (path.node.operator === \"delete\") {\n      state.constantViolations.push(path);\n    }\n  },\n  BlockScoped(path) {\n    let scope = path.scope;\n    if (scope.path === path) scope = scope.parent;\n    const parent = scope.getBlockParent();\n    parent.registerDeclaration(path);\n    if (path.isClassDeclaration() && path.node.id) {\n      const id = path.node.id;\n      const name = id.name;\n      path.scope.bindings[name] = path.scope.parent.getBinding(name);\n    }\n  },\n  CatchClause(path) {\n    path.scope.registerBinding(\"let\", path);\n  },\n  Function(path) {\n    const params = path.get(\"params\");\n    for (const param of params) {\n      path.scope.registerBinding(\"param\", param);\n    }\n    if (path.isFunctionExpression() && path.node.id && !path.node.id[NOT_LOCAL_BINDING]) {\n      path.scope.registerBinding(\"local\", path.get(\"id\"), path);\n    }\n  },\n  ClassExpression(path) {\n    if (path.node.id && !path.node.id[NOT_LOCAL_BINDING]) {\n      path.scope.registerBinding(\"local\", path.get(\"id\"), path);\n    }\n  },\n  TSTypeAnnotation(path) {\n    path.skip();\n  }\n};\nlet scopeVisitor;\nlet uid = 0;\nclass Scope {\n  constructor(path) {\n    this.uid = void 0;\n    this.path = void 0;\n    this.block = void 0;\n    this.inited = void 0;\n    this.labels = void 0;\n    this.bindings = void 0;\n    this.referencesSet = void 0;\n    this.globals = void 0;\n    this.uidsSet = void 0;\n    this.data = void 0;\n    this.crawling = void 0;\n    const {\n      node\n    } = path;\n    const cached = _cache.scope.get(node);\n    if ((cached == null ? void 0 : cached.path) === path) {\n      return cached;\n    }\n    _cache.scope.set(node, this);\n    this.uid = uid++;\n    this.block = node;\n    this.path = path;\n    this.labels = new Map();\n    this.inited = false;\n    Object.defineProperties(this, {\n      references: {\n        enumerable: true,\n        configurable: true,\n        writable: true,\n        value: Object.create(null)\n      },\n      uids: {\n        enumerable: true,\n        configurable: true,\n        writable: true,\n        value: Object.create(null)\n      }\n    });\n  }\n  get parent() {\n    var _parent;\n    let parent,\n      path = this.path;\n    do {\n      var _path;\n      const shouldSkip = path.key === \"key\" || path.listKey === \"decorators\";\n      path = path.parentPath;\n      if (shouldSkip && path.isMethod()) path = path.parentPath;\n      if ((_path = path) != null && _path.isScope()) parent = path;\n    } while (path && !parent);\n    return (_parent = parent) == null ? void 0 : _parent.scope;\n  }\n  get references() {\n    throw new Error(\"Scope#references is not available in Babel 8. Use Scope#referencesSet instead.\");\n  }\n  get uids() {\n    throw new Error(\"Scope#uids is not available in Babel 8. Use Scope#uidsSet instead.\");\n  }\n  generateDeclaredUidIdentifier(name) {\n    const id = this.generateUidIdentifier(name);\n    this.push({\n      id\n    });\n    return cloneNode(id);\n  }\n  generateUidIdentifier(name) {\n    return identifier(this.generateUid(name));\n  }\n  generateUid(name = \"temp\") {\n    name = toIdentifier(name).replace(/^_+/, \"\").replace(/\\d+$/g, \"\");\n    let uid;\n    let i = 0;\n    do {\n      uid = `_${name}`;\n      if (i >= 11) uid += i - 1;else if (i >= 9) uid += i - 9;else if (i >= 1) uid += i + 1;\n      i++;\n    } while (this.hasLabel(uid) || this.hasBinding(uid) || this.hasGlobal(uid) || this.hasReference(uid));\n    const program = this.getProgramParent();\n    program.references[uid] = true;\n    program.uids[uid] = true;\n    return uid;\n  }\n  generateUidBasedOnNode(node, defaultName) {\n    const parts = [];\n    gatherNodeParts(node, parts);\n    let id = parts.join(\"$\");\n    id = id.replace(/^_/, \"\") || defaultName || \"ref\";\n    return this.generateUid(id.slice(0, 20));\n  }\n  generateUidIdentifierBasedOnNode(node, defaultName) {\n    return identifier(this.generateUidBasedOnNode(node, defaultName));\n  }\n  isStatic(node) {\n    if (isThisExpression(node) || isSuper(node) || isTopicReference(node)) {\n      return true;\n    }\n    if (isIdentifier(node)) {\n      const binding = this.getBinding(node.name);\n      if (binding) {\n        return binding.constant;\n      } else {\n        return this.hasBinding(node.name);\n      }\n    }\n    return false;\n  }\n  maybeGenerateMemoised(node, dontPush) {\n    if (this.isStatic(node)) {\n      return null;\n    } else {\n      const id = this.generateUidIdentifierBasedOnNode(node);\n      if (!dontPush) {\n        this.push({\n          id\n        });\n        return cloneNode(id);\n      }\n      return id;\n    }\n  }\n  checkBlockScopedCollisions(local, kind, name, id) {\n    if (kind === \"param\") return;\n    if (local.kind === \"local\") return;\n    const duplicate = kind === \"let\" || local.kind === \"let\" || local.kind === \"const\" || local.kind === \"module\" || local.kind === \"param\" && kind === \"const\";\n    if (duplicate) {\n      throw this.path.hub.buildError(id, `Duplicate declaration \"${name}\"`, TypeError);\n    }\n  }\n  rename(oldName, newName) {\n    const binding = this.getBinding(oldName);\n    if (binding) {\n      newName || (newName = this.generateUidIdentifier(oldName).name);\n      const renamer = new _renamer.default(binding, oldName, newName);\n      renamer.rename(arguments[2]);\n    }\n  }\n  dump() {\n    const sep = \"-\".repeat(60);\n    console.log(sep);\n    let scope = this;\n    do {\n      console.log(\"#\", scope.block.type);\n      for (const name of Object.keys(scope.bindings)) {\n        const binding = scope.bindings[name];\n        console.log(\" -\", name, {\n          constant: binding.constant,\n          references: binding.references,\n          violations: binding.constantViolations.length,\n          kind: binding.kind\n        });\n      }\n    } while (scope = scope.parent);\n    console.log(sep);\n  }\n  hasLabel(name) {\n    return !!this.getLabel(name);\n  }\n  getLabel(name) {\n    return this.labels.get(name);\n  }\n  registerLabel(path) {\n    this.labels.set(path.node.label.name, path);\n  }\n  registerDeclaration(path) {\n    if (path.isLabeledStatement()) {\n      this.registerLabel(path);\n    } else if (path.isFunctionDeclaration()) {\n      this.registerBinding(\"hoisted\", path.get(\"id\"), path);\n    } else if (path.isVariableDeclaration()) {\n      const declarations = path.get(\"declarations\");\n      const {\n        kind\n      } = path.node;\n      for (const declar of declarations) {\n        this.registerBinding(kind === \"using\" || kind === \"await using\" ? \"const\" : kind, declar);\n      }\n    } else if (path.isClassDeclaration()) {\n      if (path.node.declare) return;\n      this.registerBinding(\"let\", path);\n    } else if (path.isImportDeclaration()) {\n      const isTypeDeclaration = path.node.importKind === \"type\" || path.node.importKind === \"typeof\";\n      const specifiers = path.get(\"specifiers\");\n      for (const specifier of specifiers) {\n        const isTypeSpecifier = isTypeDeclaration || specifier.isImportSpecifier() && (specifier.node.importKind === \"type\" || specifier.node.importKind === \"typeof\");\n        this.registerBinding(isTypeSpecifier ? \"unknown\" : \"module\", specifier);\n      }\n    } else if (path.isExportDeclaration()) {\n      const declar = path.get(\"declaration\");\n      if (declar.isClassDeclaration() || declar.isFunctionDeclaration() || declar.isVariableDeclaration()) {\n        this.registerDeclaration(declar);\n      }\n    } else {\n      this.registerBinding(\"unknown\", path);\n    }\n  }\n  buildUndefinedNode() {\n    return buildUndefinedNode();\n  }\n  registerConstantViolation(path) {\n    const ids = path.getAssignmentIdentifiers();\n    for (const name of Object.keys(ids)) {\n      var _this$getBinding;\n      (_this$getBinding = this.getBinding(name)) == null || _this$getBinding.reassign(path);\n    }\n  }\n  registerBinding(kind, path, bindingPath = path) {\n    if (!kind) throw new ReferenceError(\"no `kind`\");\n    if (path.isVariableDeclaration()) {\n      const declarators = path.get(\"declarations\");\n      for (const declar of declarators) {\n        this.registerBinding(kind, declar);\n      }\n      return;\n    }\n    const parent = this.getProgramParent();\n    const ids = path.getOuterBindingIdentifiers(true);\n    for (const name of Object.keys(ids)) {\n      parent.references[name] = true;\n      for (const id of ids[name]) {\n        const local = this.getOwnBinding(name);\n        if (local) {\n          if (local.identifier === id) continue;\n          this.checkBlockScopedCollisions(local, kind, name, id);\n        }\n        if (local) {\n          local.reassign(bindingPath);\n        } else {\n          this.bindings[name] = new _binding.default({\n            identifier: id,\n            scope: this,\n            path: bindingPath,\n            kind: kind\n          });\n        }\n      }\n    }\n  }\n  addGlobal(node) {\n    this.globals[node.name] = node;\n  }\n  hasUid(name) {\n    let scope = this;\n    do {\n      if (scope.uids[name]) return true;\n    } while (scope = scope.parent);\n    return false;\n  }\n  hasGlobal(name) {\n    let scope = this;\n    do {\n      if (scope.globals[name]) return true;\n    } while (scope = scope.parent);\n    return false;\n  }\n  hasReference(name) {\n    return !!this.getProgramParent().references[name];\n  }\n  isPure(node, constantsOnly) {\n    if (isIdentifier(node)) {\n      const binding = this.getBinding(node.name);\n      if (!binding) return false;\n      if (constantsOnly) return binding.constant;\n      return true;\n    } else if (isThisExpression(node) || isMetaProperty(node) || isTopicReference(node) || isPrivateName(node)) {\n      return true;\n    } else if (isClass(node)) {\n      var _node$decorators;\n      if (node.superClass && !this.isPure(node.superClass, constantsOnly)) {\n        return false;\n      }\n      if (((_node$decorators = node.decorators) == null ? void 0 : _node$decorators.length) > 0) {\n        return false;\n      }\n      return this.isPure(node.body, constantsOnly);\n    } else if (isClassBody(node)) {\n      for (const method of node.body) {\n        if (!this.isPure(method, constantsOnly)) return false;\n      }\n      return true;\n    } else if (isBinary(node)) {\n      return this.isPure(node.left, constantsOnly) && this.isPure(node.right, constantsOnly);\n    } else if (isArrayExpression(node) || (node == null ? void 0 : node.type) === \"TupleExpression\") {\n      for (const elem of node.elements) {\n        if (elem !== null && !this.isPure(elem, constantsOnly)) return false;\n      }\n      return true;\n    } else if (isObjectExpression(node) || (node == null ? void 0 : node.type) === \"RecordExpression\") {\n      for (const prop of node.properties) {\n        if (!this.isPure(prop, constantsOnly)) return false;\n      }\n      return true;\n    } else if (isMethod(node)) {\n      var _node$decorators2;\n      if (node.computed && !this.isPure(node.key, constantsOnly)) return false;\n      if (((_node$decorators2 = node.decorators) == null ? void 0 : _node$decorators2.length) > 0) {\n        return false;\n      }\n      return true;\n    } else if (isProperty(node)) {\n      var _node$decorators3;\n      if (node.computed && !this.isPure(node.key, constantsOnly)) return false;\n      if (((_node$decorators3 = node.decorators) == null ? void 0 : _node$decorators3.length) > 0) {\n        return false;\n      }\n      if (isObjectProperty(node) || node.static) {\n        if (node.value !== null && !this.isPure(node.value, constantsOnly)) {\n          return false;\n        }\n      }\n      return true;\n    } else if (isUnaryExpression(node)) {\n      return this.isPure(node.argument, constantsOnly);\n    } else if (isTemplateLiteral(node)) {\n      for (const expression of node.expressions) {\n        if (!this.isPure(expression, constantsOnly)) return false;\n      }\n      return true;\n    } else if (isTaggedTemplateExpression(node)) {\n      return matchesPattern(node.tag, \"String.raw\") && !this.hasBinding(\"String\", {\n        noGlobals: true\n      }) && this.isPure(node.quasi, constantsOnly);\n    } else if (isMemberExpression(node)) {\n      return !node.computed && isIdentifier(node.object) && node.object.name === \"Symbol\" && isIdentifier(node.property) && node.property.name !== \"for\" && !this.hasBinding(\"Symbol\", {\n        noGlobals: true\n      });\n    } else if (isCallExpression(node)) {\n      return matchesPattern(node.callee, \"Symbol.for\") && !this.hasBinding(\"Symbol\", {\n        noGlobals: true\n      }) && node.arguments.length === 1 && t.isStringLiteral(node.arguments[0]);\n    } else {\n      return isPureish(node);\n    }\n  }\n  setData(key, val) {\n    return this.data[key] = val;\n  }\n  getData(key) {\n    let scope = this;\n    do {\n      const data = scope.data[key];\n      if (data != null) return data;\n    } while (scope = scope.parent);\n  }\n  removeData(key) {\n    let scope = this;\n    do {\n      const data = scope.data[key];\n      if (data != null) scope.data[key] = null;\n    } while (scope = scope.parent);\n  }\n  init() {\n    if (!this.inited) {\n      this.inited = true;\n      this.crawl();\n    }\n  }\n  crawl() {\n    const path = this.path;\n    resetScope(this);\n    this.data = Object.create(null);\n    let scope = this;\n    do {\n      if (scope.crawling) return;\n      if (scope.path.isProgram()) {\n        break;\n      }\n    } while (scope = scope.parent);\n    const programParent = scope;\n    const state = {\n      references: [],\n      constantViolations: [],\n      assignments: []\n    };\n    this.crawling = true;\n    scopeVisitor || (scopeVisitor = _index.default.visitors.merge([{\n      Scope(path) {\n        resetScope(path.scope);\n      }\n    }, collectorVisitor]));\n    if (path.type !== \"Program\") {\n      const typeVisitors = scopeVisitor[path.type];\n      if (typeVisitors) {\n        for (const visit of typeVisitors.enter) {\n          visit.call(state, path, state);\n        }\n      }\n    }\n    path.traverse(scopeVisitor, state);\n    this.crawling = false;\n    for (const path of state.assignments) {\n      const ids = path.getAssignmentIdentifiers();\n      for (const name of Object.keys(ids)) {\n        if (path.scope.getBinding(name)) continue;\n        programParent.addGlobal(ids[name]);\n      }\n      path.scope.registerConstantViolation(path);\n    }\n    for (const ref of state.references) {\n      const binding = ref.scope.getBinding(ref.node.name);\n      if (binding) {\n        binding.reference(ref);\n      } else {\n        programParent.addGlobal(ref.node);\n      }\n    }\n    for (const path of state.constantViolations) {\n      path.scope.registerConstantViolation(path);\n    }\n  }\n  push(opts) {\n    let path = this.path;\n    if (path.isPattern()) {\n      path = this.getPatternParent().path;\n    } else if (!path.isBlockStatement() && !path.isProgram()) {\n      path = this.getBlockParent().path;\n    }\n    if (path.isSwitchStatement()) {\n      path = (this.getFunctionParent() || this.getProgramParent()).path;\n    }\n    const {\n      init,\n      unique,\n      kind = \"var\",\n      id\n    } = opts;\n    if (!init && !unique && (kind === \"var\" || kind === \"let\") && isAnonymousFunctionExpression(path) && isCallExpression(path.parent, {\n      callee: path.node\n    }) && path.parent.arguments.length <= path.node.params.length && isIdentifier(id)) {\n      path.pushContainer(\"params\", id);\n      path.scope.registerBinding(\"param\", path.get(\"params\")[path.node.params.length - 1]);\n      return;\n    }\n    if (path.isLoop() || path.isCatchClause() || path.isFunction()) {\n      path.ensureBlock();\n      path = path.get(\"body\");\n    }\n    const blockHoist = opts._blockHoist == null ? 2 : opts._blockHoist;\n    const dataKey = `declaration:${kind}:${blockHoist}`;\n    let declarPath = !unique && path.getData(dataKey);\n    if (!declarPath) {\n      const declar = variableDeclaration(kind, []);\n      declar._blockHoist = blockHoist;\n      [declarPath] = path.unshiftContainer(\"body\", [declar]);\n      if (!unique) path.setData(dataKey, declarPath);\n    }\n    const declarator = variableDeclarator(id, init);\n    const len = declarPath.node.declarations.push(declarator);\n    path.scope.registerBinding(kind, declarPath.get(\"declarations\")[len - 1]);\n  }\n  getProgramParent() {\n    let scope = this;\n    do {\n      if (scope.path.isProgram()) {\n        return scope;\n      }\n    } while (scope = scope.parent);\n    throw new Error(\"Couldn't find a Program\");\n  }\n  getFunctionParent() {\n    let scope = this;\n    do {\n      if (scope.path.isFunctionParent()) {\n        return scope;\n      }\n    } while (scope = scope.parent);\n    return null;\n  }\n  getBlockParent() {\n    let scope = this;\n    do {\n      if (scope.path.isBlockParent()) {\n        return scope;\n      }\n    } while (scope = scope.parent);\n    throw new Error(\"We couldn't find a BlockStatement, For, Switch, Function, Loop or Program...\");\n  }\n  getPatternParent() {\n    let scope = this;\n    do {\n      if (!scope.path.isPattern()) {\n        return scope.getBlockParent();\n      }\n    } while (scope = scope.parent.parent);\n    throw new Error(\"We couldn't find a BlockStatement, For, Switch, Function, Loop or Program...\");\n  }\n  getAllBindings() {\n    const ids = Object.create(null);\n    let scope = this;\n    do {\n      for (const key of Object.keys(scope.bindings)) {\n        if (key in ids === false) {\n          ids[key] = scope.bindings[key];\n        }\n      }\n      scope = scope.parent;\n    } while (scope);\n    return ids;\n  }\n  bindingIdentifierEquals(name, node) {\n    return this.getBindingIdentifier(name) === node;\n  }\n  getBinding(name) {\n    let scope = this;\n    let previousPath;\n    do {\n      const binding = scope.getOwnBinding(name);\n      if (binding) {\n        var _previousPath;\n        if ((_previousPath = previousPath) != null && _previousPath.isPattern() && binding.kind !== \"param\" && binding.kind !== \"local\") {} else {\n          return binding;\n        }\n      } else if (!binding && name === \"arguments\" && scope.path.isFunction() && !scope.path.isArrowFunctionExpression()) {\n        break;\n      }\n      previousPath = scope.path;\n    } while (scope = scope.parent);\n  }\n  getOwnBinding(name) {\n    return this.bindings[name];\n  }\n  getBindingIdentifier(name) {\n    var _this$getBinding2;\n    return (_this$getBinding2 = this.getBinding(name)) == null ? void 0 : _this$getBinding2.identifier;\n  }\n  getOwnBindingIdentifier(name) {\n    const binding = this.bindings[name];\n    return binding == null ? void 0 : binding.identifier;\n  }\n  hasOwnBinding(name) {\n    return !!this.getOwnBinding(name);\n  }\n  hasBinding(name, opts) {\n    if (!name) return false;\n    let noGlobals;\n    let noUids;\n    let upToScope;\n    if (typeof opts === \"object\") {\n      noGlobals = opts.noGlobals;\n      noUids = opts.noUids;\n      upToScope = opts.upToScope;\n    } else if (typeof opts === \"boolean\") {\n      noGlobals = opts;\n    }\n    let scope = this;\n    do {\n      if (upToScope === scope) {\n        break;\n      }\n      if (scope.hasOwnBinding(name)) {\n        return true;\n      }\n    } while (scope = scope.parent);\n    if (!noUids && this.hasUid(name)) return true;\n    if (!noGlobals && Scope.globals.includes(name)) return true;\n    if (!noGlobals && Scope.contextVariables.includes(name)) return true;\n    return false;\n  }\n  parentHasBinding(name, opts) {\n    var _this$parent;\n    return (_this$parent = this.parent) == null ? void 0 : _this$parent.hasBinding(name, opts);\n  }\n  moveBindingTo(name, scope) {\n    const info = this.getBinding(name);\n    if (info) {\n      info.scope.removeOwnBinding(name);\n      info.scope = scope;\n      scope.bindings[name] = info;\n    }\n  }\n  removeOwnBinding(name) {\n    delete this.bindings[name];\n  }\n  removeBinding(name) {\n    var _this$getBinding3;\n    (_this$getBinding3 = this.getBinding(name)) == null || _this$getBinding3.scope.removeOwnBinding(name);\n    let scope = this;\n    do {\n      if (scope.uids[name]) {\n        scope.uids[name] = false;\n      }\n    } while (scope = scope.parent);\n  }\n  hoistVariables(emit = id => this.push({\n    id\n  })) {\n    this.crawl();\n    const seen = new Set();\n    for (const name of Object.keys(this.bindings)) {\n      const binding = this.bindings[name];\n      if (!binding) continue;\n      const {\n        path\n      } = binding;\n      if (!path.isVariableDeclarator()) continue;\n      const {\n        parent,\n        parentPath\n      } = path;\n      if (parent.kind !== \"var\" || seen.has(parent)) continue;\n      seen.add(path.parent);\n      let firstId;\n      const init = [];\n      for (const decl of parent.declarations) {\n        firstId != null ? firstId : firstId = decl.id;\n        if (decl.init) {\n          init.push(assignmentExpression(\"=\", decl.id, decl.init));\n        }\n        const ids = Object.keys(getBindingIdentifiers(decl, false, true, true));\n        for (const name of ids) {\n          emit(identifier(name), decl.init != null);\n        }\n      }\n      if (parentPath.parentPath.isForXStatement({\n        left: parent\n      })) {\n        parentPath.replaceWith(firstId);\n      } else if (init.length === 0) {\n        parentPath.remove();\n      } else {\n        const expr = init.length === 1 ? init[0] : sequenceExpression(init);\n        if (parentPath.parentPath.isForStatement({\n          init: parent\n        })) {\n          parentPath.replaceWith(expr);\n        } else {\n          parentPath.replaceWith(expressionStatement(expr));\n        }\n      }\n    }\n  }\n}\nexports[\"default\"] = Scope;\nScope.globals = [...globalsBuiltinLower, ...globalsBuiltinUpper];\nScope.contextVariables = [\"arguments\", \"undefined\", \"Infinity\", \"NaN\"];\nScope.prototype._renameFromMap = function _renameFromMap(map, oldName, newName, value) {\n  if (map[oldName]) {\n    map[newName] = value;\n    map[oldName] = null;\n  }\n};\nScope.prototype.traverse = function (node, opts, state) {\n  (0, _index.default)(node, opts, this, state, this.path);\n};\nScope.prototype._generateUid = function _generateUid(name, i) {\n  let id = name;\n  if (i > 1) id += i;\n  return `_${id}`;\n};\nScope.prototype.toArray = function toArray(node, i, arrayLikeIsIterable) {\n  if (isIdentifier(node)) {\n    const binding = this.getBinding(node.name);\n    if (binding != null && binding.constant && binding.path.isGenericType(\"Array\")) {\n      return node;\n    }\n  }\n  if (isArrayExpression(node)) {\n    return node;\n  }\n  if (isIdentifier(node, {\n    name: \"arguments\"\n  })) {\n    return callExpression(memberExpression(memberExpression(memberExpression(identifier(\"Array\"), identifier(\"prototype\")), identifier(\"slice\")), identifier(\"call\")), [node]);\n  }\n  let helperName;\n  const args = [node];\n  if (i === true) {\n    helperName = \"toConsumableArray\";\n  } else if (typeof i === \"number\") {\n    args.push(numericLiteral(i));\n    helperName = \"slicedToArray\";\n  } else {\n    helperName = \"toArray\";\n  }\n  if (arrayLikeIsIterable) {\n    args.unshift(this.path.hub.addHelper(helperName));\n    helperName = \"maybeArrayLike\";\n  }\n  return callExpression(this.path.hub.addHelper(helperName), args);\n};\nScope.prototype.getAllBindingsOfKind = function getAllBindingsOfKind(...kinds) {\n  const ids = Object.create(null);\n  for (const kind of kinds) {\n    let scope = this;\n    do {\n      for (const name of Object.keys(scope.bindings)) {\n        const binding = scope.bindings[name];\n        if (binding.kind === kind) ids[name] = binding;\n      }\n      scope = scope.parent;\n    } while (scope);\n  }\n  return ids;\n};\nObject.defineProperties(Scope.prototype, {\n  parentBlock: {\n    configurable: true,\n    enumerable: true,\n    get() {\n      return this.path.parent;\n    }\n  },\n  hub: {\n    configurable: true,\n    enumerable: true,\n    get() {\n      return this.path.hub;\n    }\n  }\n});\n\n//# sourceMappingURL=index.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGJhYmVsL3RyYXZlcnNlL2xpYi9zY29wZS9pbmRleC5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYiw4Q0FBNkM7QUFDN0M7QUFDQSxDQUFDLEVBQUM7QUFDRixrQkFBZTtBQUNmLGVBQWUsbUJBQU8sQ0FBQyx1RkFBa0I7QUFDekMsYUFBYSxtQkFBTyxDQUFDLHNFQUFhO0FBQ2xDLHdCQUF3QixtQkFBTyxDQUFDLGlHQUF1QjtBQUN2RCxlQUFlLG1CQUFPLENBQUMsK0VBQWM7QUFDckMsU0FBUyxtQkFBTyxDQUFDLG9FQUFjO0FBQy9CO0FBQ0EsYUFBYSxtQkFBTyxDQUFDLHNFQUFhO0FBQ2xDLDRCQUE0QixtQkFBTyxDQUFDLHlIQUErQztBQUNuRix3QkFBd0IsbUJBQU8sQ0FBQyx5SEFBK0M7QUFDL0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixLQUFLO0FBQ3JCLGdDQUFnQyw4QkFBOEI7QUFDOUQ7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUVBQW1FLEtBQUs7QUFDeEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLE9BQU87QUFDUCxNQUFNO0FBQ047QUFDQTtBQUNBLE9BQU87QUFDUCxNQUFNO0FBQ047QUFDQTtBQUNBLE9BQU87QUFDUCxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUMsS0FBSyxHQUFHLFdBQVc7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNElBQTRJO0FBQzVJO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxRQUFRO0FBQ1I7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsR0FBRztBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcmVwby12aXN1YWxpemVyLy4vbm9kZV9tb2R1bGVzL0BiYWJlbC90cmF2ZXJzZS9saWIvc2NvcGUvaW5kZXguanM/Y2ZhOCJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuZGVmYXVsdCA9IHZvaWQgMDtcbnZhciBfcmVuYW1lciA9IHJlcXVpcmUoXCIuL2xpYi9yZW5hbWVyLmpzXCIpO1xudmFyIF9pbmRleCA9IHJlcXVpcmUoXCIuLi9pbmRleC5qc1wiKTtcbnZhciBfdHJhdmVyc2VGb3JTY29wZSA9IHJlcXVpcmUoXCIuL3RyYXZlcnNlRm9yU2NvcGUuanNcIik7XG52YXIgX2JpbmRpbmcgPSByZXF1aXJlKFwiLi9iaW5kaW5nLmpzXCIpO1xudmFyIF90ID0gcmVxdWlyZShcIkBiYWJlbC90eXBlc1wiKTtcbnZhciB0ID0gX3Q7XG52YXIgX2NhY2hlID0gcmVxdWlyZShcIi4uL2NhY2hlLmpzXCIpO1xuY29uc3QgZ2xvYmFsc0J1aWx0aW5Mb3dlciA9IHJlcXVpcmUoXCJAYmFiZWwvaGVscGVyLWdsb2JhbHMvZGF0YS9idWlsdGluLWxvd2VyLmpzb25cIiksXG4gIGdsb2JhbHNCdWlsdGluVXBwZXIgPSByZXF1aXJlKFwiQGJhYmVsL2hlbHBlci1nbG9iYWxzL2RhdGEvYnVpbHRpbi11cHBlci5qc29uXCIpO1xuY29uc3Qge1xuICBhc3NpZ25tZW50RXhwcmVzc2lvbixcbiAgY2FsbEV4cHJlc3Npb24sXG4gIGNsb25lTm9kZSxcbiAgZ2V0QmluZGluZ0lkZW50aWZpZXJzLFxuICBpZGVudGlmaWVyLFxuICBpc0FycmF5RXhwcmVzc2lvbixcbiAgaXNCaW5hcnksXG4gIGlzQ2FsbEV4cHJlc3Npb24sXG4gIGlzQ2xhc3MsXG4gIGlzQ2xhc3NCb2R5LFxuICBpc0NsYXNzRGVjbGFyYXRpb24sXG4gIGlzRXhwb3J0QWxsRGVjbGFyYXRpb24sXG4gIGlzRXhwb3J0RGVmYXVsdERlY2xhcmF0aW9uLFxuICBpc0V4cG9ydE5hbWVkRGVjbGFyYXRpb24sXG4gIGlzRnVuY3Rpb25EZWNsYXJhdGlvbixcbiAgaXNJZGVudGlmaWVyLFxuICBpc0ltcG9ydERlY2xhcmF0aW9uLFxuICBpc0xpdGVyYWwsXG4gIGlzTWVtYmVyRXhwcmVzc2lvbixcbiAgaXNNZXRob2QsXG4gIGlzTW9kdWxlU3BlY2lmaWVyLFxuICBpc051bGxMaXRlcmFsLFxuICBpc09iamVjdEV4cHJlc3Npb24sXG4gIGlzUHJvcGVydHksXG4gIGlzUHVyZWlzaCxcbiAgaXNSZWdFeHBMaXRlcmFsLFxuICBpc1N1cGVyLFxuICBpc1RhZ2dlZFRlbXBsYXRlRXhwcmVzc2lvbixcbiAgaXNUZW1wbGF0ZUxpdGVyYWwsXG4gIGlzVGhpc0V4cHJlc3Npb24sXG4gIGlzVW5hcnlFeHByZXNzaW9uLFxuICBpc1ZhcmlhYmxlRGVjbGFyYXRpb24sXG4gIGV4cHJlc3Npb25TdGF0ZW1lbnQsXG4gIG1hdGNoZXNQYXR0ZXJuLFxuICBtZW1iZXJFeHByZXNzaW9uLFxuICBudW1lcmljTGl0ZXJhbCxcbiAgdG9JZGVudGlmaWVyLFxuICB2YXJpYWJsZURlY2xhcmF0aW9uLFxuICB2YXJpYWJsZURlY2xhcmF0b3IsXG4gIGlzT2JqZWN0UHJvcGVydHksXG4gIGlzVG9waWNSZWZlcmVuY2UsXG4gIGlzTWV0YVByb3BlcnR5LFxuICBpc1ByaXZhdGVOYW1lLFxuICBpc0V4cG9ydERlY2xhcmF0aW9uLFxuICBidWlsZFVuZGVmaW5lZE5vZGUsXG4gIHNlcXVlbmNlRXhwcmVzc2lvblxufSA9IF90O1xuZnVuY3Rpb24gZ2F0aGVyTm9kZVBhcnRzKG5vZGUsIHBhcnRzKSB7XG4gIHN3aXRjaCAobm9kZSA9PSBudWxsID8gdm9pZCAwIDogbm9kZS50eXBlKSB7XG4gICAgZGVmYXVsdDpcbiAgICAgIGlmIChpc0ltcG9ydERlY2xhcmF0aW9uKG5vZGUpIHx8IGlzRXhwb3J0RGVjbGFyYXRpb24obm9kZSkpIHtcbiAgICAgICAgdmFyIF9ub2RlJHNwZWNpZmllcnM7XG4gICAgICAgIGlmICgoaXNFeHBvcnRBbGxEZWNsYXJhdGlvbihub2RlKSB8fCBpc0V4cG9ydE5hbWVkRGVjbGFyYXRpb24obm9kZSkgfHwgaXNJbXBvcnREZWNsYXJhdGlvbihub2RlKSkgJiYgbm9kZS5zb3VyY2UpIHtcbiAgICAgICAgICBnYXRoZXJOb2RlUGFydHMobm9kZS5zb3VyY2UsIHBhcnRzKTtcbiAgICAgICAgfSBlbHNlIGlmICgoaXNFeHBvcnROYW1lZERlY2xhcmF0aW9uKG5vZGUpIHx8IGlzSW1wb3J0RGVjbGFyYXRpb24obm9kZSkpICYmIChfbm9kZSRzcGVjaWZpZXJzID0gbm9kZS5zcGVjaWZpZXJzKSAhPSBudWxsICYmIF9ub2RlJHNwZWNpZmllcnMubGVuZ3RoKSB7XG4gICAgICAgICAgZm9yIChjb25zdCBlIG9mIG5vZGUuc3BlY2lmaWVycykgZ2F0aGVyTm9kZVBhcnRzKGUsIHBhcnRzKTtcbiAgICAgICAgfSBlbHNlIGlmICgoaXNFeHBvcnREZWZhdWx0RGVjbGFyYXRpb24obm9kZSkgfHwgaXNFeHBvcnROYW1lZERlY2xhcmF0aW9uKG5vZGUpKSAmJiBub2RlLmRlY2xhcmF0aW9uKSB7XG4gICAgICAgICAgZ2F0aGVyTm9kZVBhcnRzKG5vZGUuZGVjbGFyYXRpb24sIHBhcnRzKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChpc01vZHVsZVNwZWNpZmllcihub2RlKSkge1xuICAgICAgICBnYXRoZXJOb2RlUGFydHMobm9kZS5sb2NhbCwgcGFydHMpO1xuICAgICAgfSBlbHNlIGlmIChpc0xpdGVyYWwobm9kZSkgJiYgIWlzTnVsbExpdGVyYWwobm9kZSkgJiYgIWlzUmVnRXhwTGl0ZXJhbChub2RlKSAmJiAhaXNUZW1wbGF0ZUxpdGVyYWwobm9kZSkpIHtcbiAgICAgICAgcGFydHMucHVzaChub2RlLnZhbHVlKTtcbiAgICAgIH1cbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgXCJNZW1iZXJFeHByZXNzaW9uXCI6XG4gICAgY2FzZSBcIk9wdGlvbmFsTWVtYmVyRXhwcmVzc2lvblwiOlxuICAgIGNhc2UgXCJKU1hNZW1iZXJFeHByZXNzaW9uXCI6XG4gICAgICBnYXRoZXJOb2RlUGFydHMobm9kZS5vYmplY3QsIHBhcnRzKTtcbiAgICAgIGdhdGhlck5vZGVQYXJ0cyhub2RlLnByb3BlcnR5LCBwYXJ0cyk7XG4gICAgICBicmVhaztcbiAgICBjYXNlIFwiSWRlbnRpZmllclwiOlxuICAgIGNhc2UgXCJKU1hJZGVudGlmaWVyXCI6XG4gICAgICBwYXJ0cy5wdXNoKG5vZGUubmFtZSk7XG4gICAgICBicmVhaztcbiAgICBjYXNlIFwiQ2FsbEV4cHJlc3Npb25cIjpcbiAgICBjYXNlIFwiT3B0aW9uYWxDYWxsRXhwcmVzc2lvblwiOlxuICAgIGNhc2UgXCJOZXdFeHByZXNzaW9uXCI6XG4gICAgICBnYXRoZXJOb2RlUGFydHMobm9kZS5jYWxsZWUsIHBhcnRzKTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgXCJPYmplY3RFeHByZXNzaW9uXCI6XG4gICAgY2FzZSBcIk9iamVjdFBhdHRlcm5cIjpcbiAgICAgIGZvciAoY29uc3QgZSBvZiBub2RlLnByb3BlcnRpZXMpIHtcbiAgICAgICAgZ2F0aGVyTm9kZVBhcnRzKGUsIHBhcnRzKTtcbiAgICAgIH1cbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgXCJTcHJlYWRFbGVtZW50XCI6XG4gICAgY2FzZSBcIlJlc3RFbGVtZW50XCI6XG4gICAgICBnYXRoZXJOb2RlUGFydHMobm9kZS5hcmd1bWVudCwgcGFydHMpO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBcIk9iamVjdFByb3BlcnR5XCI6XG4gICAgY2FzZSBcIk9iamVjdE1ldGhvZFwiOlxuICAgIGNhc2UgXCJDbGFzc1Byb3BlcnR5XCI6XG4gICAgY2FzZSBcIkNsYXNzTWV0aG9kXCI6XG4gICAgY2FzZSBcIkNsYXNzUHJpdmF0ZVByb3BlcnR5XCI6XG4gICAgY2FzZSBcIkNsYXNzUHJpdmF0ZU1ldGhvZFwiOlxuICAgICAgZ2F0aGVyTm9kZVBhcnRzKG5vZGUua2V5LCBwYXJ0cyk7XG4gICAgICBicmVhaztcbiAgICBjYXNlIFwiVGhpc0V4cHJlc3Npb25cIjpcbiAgICAgIHBhcnRzLnB1c2goXCJ0aGlzXCIpO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBcIlN1cGVyXCI6XG4gICAgICBwYXJ0cy5wdXNoKFwic3VwZXJcIik7XG4gICAgICBicmVhaztcbiAgICBjYXNlIFwiSW1wb3J0XCI6XG4gICAgY2FzZSBcIkltcG9ydEV4cHJlc3Npb25cIjpcbiAgICAgIHBhcnRzLnB1c2goXCJpbXBvcnRcIik7XG4gICAgICBicmVhaztcbiAgICBjYXNlIFwiRG9FeHByZXNzaW9uXCI6XG4gICAgICBwYXJ0cy5wdXNoKFwiZG9cIik7XG4gICAgICBicmVhaztcbiAgICBjYXNlIFwiWWllbGRFeHByZXNzaW9uXCI6XG4gICAgICBwYXJ0cy5wdXNoKFwieWllbGRcIik7XG4gICAgICBnYXRoZXJOb2RlUGFydHMobm9kZS5hcmd1bWVudCwgcGFydHMpO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBcIkF3YWl0RXhwcmVzc2lvblwiOlxuICAgICAgcGFydHMucHVzaChcImF3YWl0XCIpO1xuICAgICAgZ2F0aGVyTm9kZVBhcnRzKG5vZGUuYXJndW1lbnQsIHBhcnRzKTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgXCJBc3NpZ25tZW50RXhwcmVzc2lvblwiOlxuICAgICAgZ2F0aGVyTm9kZVBhcnRzKG5vZGUubGVmdCwgcGFydHMpO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBcIlZhcmlhYmxlRGVjbGFyYXRvclwiOlxuICAgICAgZ2F0aGVyTm9kZVBhcnRzKG5vZGUuaWQsIHBhcnRzKTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgXCJGdW5jdGlvbkV4cHJlc3Npb25cIjpcbiAgICBjYXNlIFwiRnVuY3Rpb25EZWNsYXJhdGlvblwiOlxuICAgIGNhc2UgXCJDbGFzc0V4cHJlc3Npb25cIjpcbiAgICBjYXNlIFwiQ2xhc3NEZWNsYXJhdGlvblwiOlxuICAgICAgZ2F0aGVyTm9kZVBhcnRzKG5vZGUuaWQsIHBhcnRzKTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgXCJQcml2YXRlTmFtZVwiOlxuICAgICAgZ2F0aGVyTm9kZVBhcnRzKG5vZGUuaWQsIHBhcnRzKTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgXCJQYXJlbnRoZXNpemVkRXhwcmVzc2lvblwiOlxuICAgICAgZ2F0aGVyTm9kZVBhcnRzKG5vZGUuZXhwcmVzc2lvbiwgcGFydHMpO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBcIlVuYXJ5RXhwcmVzc2lvblwiOlxuICAgIGNhc2UgXCJVcGRhdGVFeHByZXNzaW9uXCI6XG4gICAgICBnYXRoZXJOb2RlUGFydHMobm9kZS5hcmd1bWVudCwgcGFydHMpO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBcIk1ldGFQcm9wZXJ0eVwiOlxuICAgICAgZ2F0aGVyTm9kZVBhcnRzKG5vZGUubWV0YSwgcGFydHMpO1xuICAgICAgZ2F0aGVyTm9kZVBhcnRzKG5vZGUucHJvcGVydHksIHBhcnRzKTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgXCJKU1hFbGVtZW50XCI6XG4gICAgICBnYXRoZXJOb2RlUGFydHMobm9kZS5vcGVuaW5nRWxlbWVudCwgcGFydHMpO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBcIkpTWE9wZW5pbmdFbGVtZW50XCI6XG4gICAgICBnYXRoZXJOb2RlUGFydHMobm9kZS5uYW1lLCBwYXJ0cyk7XG4gICAgICBicmVhaztcbiAgICBjYXNlIFwiSlNYRnJhZ21lbnRcIjpcbiAgICAgIGdhdGhlck5vZGVQYXJ0cyhub2RlLm9wZW5pbmdGcmFnbWVudCwgcGFydHMpO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBcIkpTWE9wZW5pbmdGcmFnbWVudFwiOlxuICAgICAgcGFydHMucHVzaChcIkZyYWdtZW50XCIpO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBcIkpTWE5hbWVzcGFjZWROYW1lXCI6XG4gICAgICBnYXRoZXJOb2RlUGFydHMobm9kZS5uYW1lc3BhY2UsIHBhcnRzKTtcbiAgICAgIGdhdGhlck5vZGVQYXJ0cyhub2RlLm5hbWUsIHBhcnRzKTtcbiAgICAgIGJyZWFrO1xuICB9XG59XG5mdW5jdGlvbiByZXNldFNjb3BlKHNjb3BlKSB7XG4gIHNjb3BlLnJlZmVyZW5jZXMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICBzY29wZS51aWRzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgc2NvcGUuYmluZGluZ3MgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICBzY29wZS5nbG9iYWxzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbn1cbmZ1bmN0aW9uIGlzQW5vbnltb3VzRnVuY3Rpb25FeHByZXNzaW9uKHBhdGgpIHtcbiAgcmV0dXJuIHBhdGguaXNGdW5jdGlvbkV4cHJlc3Npb24oKSAmJiAhcGF0aC5ub2RlLmlkIHx8IHBhdGguaXNBcnJvd0Z1bmN0aW9uRXhwcmVzc2lvbigpO1xufVxudmFyIE5PVF9MT0NBTF9CSU5ESU5HID0gU3ltYm9sLmZvcihcInNob3VsZCBub3QgYmUgY29uc2lkZXJlZCBhIGxvY2FsIGJpbmRpbmdcIik7XG5jb25zdCBjb2xsZWN0b3JWaXNpdG9yID0ge1xuICBGb3JTdGF0ZW1lbnQocGF0aCkge1xuICAgIGNvbnN0IGRlY2xhciA9IHBhdGguZ2V0KFwiaW5pdFwiKTtcbiAgICBpZiAoZGVjbGFyLmlzVmFyKCkpIHtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgc2NvcGVcbiAgICAgIH0gPSBwYXRoO1xuICAgICAgY29uc3QgcGFyZW50U2NvcGUgPSBzY29wZS5nZXRGdW5jdGlvblBhcmVudCgpIHx8IHNjb3BlLmdldFByb2dyYW1QYXJlbnQoKTtcbiAgICAgIHBhcmVudFNjb3BlLnJlZ2lzdGVyQmluZGluZyhcInZhclwiLCBkZWNsYXIpO1xuICAgIH1cbiAgfSxcbiAgRGVjbGFyYXRpb24ocGF0aCkge1xuICAgIGlmIChwYXRoLmlzQmxvY2tTY29wZWQoKSkgcmV0dXJuO1xuICAgIGlmIChwYXRoLmlzSW1wb3J0RGVjbGFyYXRpb24oKSkgcmV0dXJuO1xuICAgIGlmIChwYXRoLmlzRXhwb3J0RGVjbGFyYXRpb24oKSkgcmV0dXJuO1xuICAgIGNvbnN0IHBhcmVudCA9IHBhdGguc2NvcGUuZ2V0RnVuY3Rpb25QYXJlbnQoKSB8fCBwYXRoLnNjb3BlLmdldFByb2dyYW1QYXJlbnQoKTtcbiAgICBwYXJlbnQucmVnaXN0ZXJEZWNsYXJhdGlvbihwYXRoKTtcbiAgfSxcbiAgSW1wb3J0RGVjbGFyYXRpb24ocGF0aCkge1xuICAgIGNvbnN0IHBhcmVudCA9IHBhdGguc2NvcGUuZ2V0QmxvY2tQYXJlbnQoKTtcbiAgICBwYXJlbnQucmVnaXN0ZXJEZWNsYXJhdGlvbihwYXRoKTtcbiAgfSxcbiAgVFNJbXBvcnRFcXVhbHNEZWNsYXJhdGlvbihwYXRoKSB7XG4gICAgY29uc3QgcGFyZW50ID0gcGF0aC5zY29wZS5nZXRCbG9ja1BhcmVudCgpO1xuICAgIHBhcmVudC5yZWdpc3RlckRlY2xhcmF0aW9uKHBhdGgpO1xuICB9LFxuICBSZWZlcmVuY2VkSWRlbnRpZmllcihwYXRoLCBzdGF0ZSkge1xuICAgIGlmICh0LmlzVFNRdWFsaWZpZWROYW1lKHBhdGgucGFyZW50KSAmJiBwYXRoLnBhcmVudC5yaWdodCA9PT0gcGF0aC5ub2RlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmIChwYXRoLnBhcmVudFBhdGguaXNUU0ltcG9ydEVxdWFsc0RlY2xhcmF0aW9uKCkpIHJldHVybjtcbiAgICBzdGF0ZS5yZWZlcmVuY2VzLnB1c2gocGF0aCk7XG4gIH0sXG4gIEZvclhTdGF0ZW1lbnQocGF0aCwgc3RhdGUpIHtcbiAgICBjb25zdCBsZWZ0ID0gcGF0aC5nZXQoXCJsZWZ0XCIpO1xuICAgIGlmIChsZWZ0LmlzUGF0dGVybigpIHx8IGxlZnQuaXNJZGVudGlmaWVyKCkpIHtcbiAgICAgIHN0YXRlLmNvbnN0YW50VmlvbGF0aW9ucy5wdXNoKHBhdGgpO1xuICAgIH0gZWxzZSBpZiAobGVmdC5pc1ZhcigpKSB7XG4gICAgICBjb25zdCB7XG4gICAgICAgIHNjb3BlXG4gICAgICB9ID0gcGF0aDtcbiAgICAgIGNvbnN0IHBhcmVudFNjb3BlID0gc2NvcGUuZ2V0RnVuY3Rpb25QYXJlbnQoKSB8fCBzY29wZS5nZXRQcm9ncmFtUGFyZW50KCk7XG4gICAgICBwYXJlbnRTY29wZS5yZWdpc3RlckJpbmRpbmcoXCJ2YXJcIiwgbGVmdCk7XG4gICAgfVxuICB9LFxuICBFeHBvcnREZWNsYXJhdGlvbjoge1xuICAgIGV4aXQocGF0aCkge1xuICAgICAgY29uc3Qge1xuICAgICAgICBub2RlLFxuICAgICAgICBzY29wZVxuICAgICAgfSA9IHBhdGg7XG4gICAgICBpZiAoaXNFeHBvcnRBbGxEZWNsYXJhdGlvbihub2RlKSkgcmV0dXJuO1xuICAgICAgY29uc3QgZGVjbGFyID0gbm9kZS5kZWNsYXJhdGlvbjtcbiAgICAgIGlmIChpc0NsYXNzRGVjbGFyYXRpb24oZGVjbGFyKSB8fCBpc0Z1bmN0aW9uRGVjbGFyYXRpb24oZGVjbGFyKSkge1xuICAgICAgICBjb25zdCBpZCA9IGRlY2xhci5pZDtcbiAgICAgICAgaWYgKCFpZCkgcmV0dXJuO1xuICAgICAgICBjb25zdCBiaW5kaW5nID0gc2NvcGUuZ2V0QmluZGluZyhpZC5uYW1lKTtcbiAgICAgICAgYmluZGluZyA9PSBudWxsIHx8IGJpbmRpbmcucmVmZXJlbmNlKHBhdGgpO1xuICAgICAgfSBlbHNlIGlmIChpc1ZhcmlhYmxlRGVjbGFyYXRpb24oZGVjbGFyKSkge1xuICAgICAgICBmb3IgKGNvbnN0IGRlY2wgb2YgZGVjbGFyLmRlY2xhcmF0aW9ucykge1xuICAgICAgICAgIGZvciAoY29uc3QgbmFtZSBvZiBPYmplY3Qua2V5cyhnZXRCaW5kaW5nSWRlbnRpZmllcnMoZGVjbCkpKSB7XG4gICAgICAgICAgICBjb25zdCBiaW5kaW5nID0gc2NvcGUuZ2V0QmluZGluZyhuYW1lKTtcbiAgICAgICAgICAgIGJpbmRpbmcgPT0gbnVsbCB8fCBiaW5kaW5nLnJlZmVyZW5jZShwYXRoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH0sXG4gIExhYmVsZWRTdGF0ZW1lbnQocGF0aCkge1xuICAgIHBhdGguc2NvcGUuZ2V0QmxvY2tQYXJlbnQoKS5yZWdpc3RlckRlY2xhcmF0aW9uKHBhdGgpO1xuICB9LFxuICBBc3NpZ25tZW50RXhwcmVzc2lvbihwYXRoLCBzdGF0ZSkge1xuICAgIHN0YXRlLmFzc2lnbm1lbnRzLnB1c2gocGF0aCk7XG4gIH0sXG4gIFVwZGF0ZUV4cHJlc3Npb24ocGF0aCwgc3RhdGUpIHtcbiAgICBzdGF0ZS5jb25zdGFudFZpb2xhdGlvbnMucHVzaChwYXRoKTtcbiAgfSxcbiAgVW5hcnlFeHByZXNzaW9uKHBhdGgsIHN0YXRlKSB7XG4gICAgaWYgKHBhdGgubm9kZS5vcGVyYXRvciA9PT0gXCJkZWxldGVcIikge1xuICAgICAgc3RhdGUuY29uc3RhbnRWaW9sYXRpb25zLnB1c2gocGF0aCk7XG4gICAgfVxuICB9LFxuICBCbG9ja1Njb3BlZChwYXRoKSB7XG4gICAgbGV0IHNjb3BlID0gcGF0aC5zY29wZTtcbiAgICBpZiAoc2NvcGUucGF0aCA9PT0gcGF0aCkgc2NvcGUgPSBzY29wZS5wYXJlbnQ7XG4gICAgY29uc3QgcGFyZW50ID0gc2NvcGUuZ2V0QmxvY2tQYXJlbnQoKTtcbiAgICBwYXJlbnQucmVnaXN0ZXJEZWNsYXJhdGlvbihwYXRoKTtcbiAgICBpZiAocGF0aC5pc0NsYXNzRGVjbGFyYXRpb24oKSAmJiBwYXRoLm5vZGUuaWQpIHtcbiAgICAgIGNvbnN0IGlkID0gcGF0aC5ub2RlLmlkO1xuICAgICAgY29uc3QgbmFtZSA9IGlkLm5hbWU7XG4gICAgICBwYXRoLnNjb3BlLmJpbmRpbmdzW25hbWVdID0gcGF0aC5zY29wZS5wYXJlbnQuZ2V0QmluZGluZyhuYW1lKTtcbiAgICB9XG4gIH0sXG4gIENhdGNoQ2xhdXNlKHBhdGgpIHtcbiAgICBwYXRoLnNjb3BlLnJlZ2lzdGVyQmluZGluZyhcImxldFwiLCBwYXRoKTtcbiAgfSxcbiAgRnVuY3Rpb24ocGF0aCkge1xuICAgIGNvbnN0IHBhcmFtcyA9IHBhdGguZ2V0KFwicGFyYW1zXCIpO1xuICAgIGZvciAoY29uc3QgcGFyYW0gb2YgcGFyYW1zKSB7XG4gICAgICBwYXRoLnNjb3BlLnJlZ2lzdGVyQmluZGluZyhcInBhcmFtXCIsIHBhcmFtKTtcbiAgICB9XG4gICAgaWYgKHBhdGguaXNGdW5jdGlvbkV4cHJlc3Npb24oKSAmJiBwYXRoLm5vZGUuaWQgJiYgIXBhdGgubm9kZS5pZFtOT1RfTE9DQUxfQklORElOR10pIHtcbiAgICAgIHBhdGguc2NvcGUucmVnaXN0ZXJCaW5kaW5nKFwibG9jYWxcIiwgcGF0aC5nZXQoXCJpZFwiKSwgcGF0aCk7XG4gICAgfVxuICB9LFxuICBDbGFzc0V4cHJlc3Npb24ocGF0aCkge1xuICAgIGlmIChwYXRoLm5vZGUuaWQgJiYgIXBhdGgubm9kZS5pZFtOT1RfTE9DQUxfQklORElOR10pIHtcbiAgICAgIHBhdGguc2NvcGUucmVnaXN0ZXJCaW5kaW5nKFwibG9jYWxcIiwgcGF0aC5nZXQoXCJpZFwiKSwgcGF0aCk7XG4gICAgfVxuICB9LFxuICBUU1R5cGVBbm5vdGF0aW9uKHBhdGgpIHtcbiAgICBwYXRoLnNraXAoKTtcbiAgfVxufTtcbmxldCBzY29wZVZpc2l0b3I7XG5sZXQgdWlkID0gMDtcbmNsYXNzIFNjb3BlIHtcbiAgY29uc3RydWN0b3IocGF0aCkge1xuICAgIHRoaXMudWlkID0gdm9pZCAwO1xuICAgIHRoaXMucGF0aCA9IHZvaWQgMDtcbiAgICB0aGlzLmJsb2NrID0gdm9pZCAwO1xuICAgIHRoaXMuaW5pdGVkID0gdm9pZCAwO1xuICAgIHRoaXMubGFiZWxzID0gdm9pZCAwO1xuICAgIHRoaXMuYmluZGluZ3MgPSB2b2lkIDA7XG4gICAgdGhpcy5yZWZlcmVuY2VzU2V0ID0gdm9pZCAwO1xuICAgIHRoaXMuZ2xvYmFscyA9IHZvaWQgMDtcbiAgICB0aGlzLnVpZHNTZXQgPSB2b2lkIDA7XG4gICAgdGhpcy5kYXRhID0gdm9pZCAwO1xuICAgIHRoaXMuY3Jhd2xpbmcgPSB2b2lkIDA7XG4gICAgY29uc3Qge1xuICAgICAgbm9kZVxuICAgIH0gPSBwYXRoO1xuICAgIGNvbnN0IGNhY2hlZCA9IF9jYWNoZS5zY29wZS5nZXQobm9kZSk7XG4gICAgaWYgKChjYWNoZWQgPT0gbnVsbCA/IHZvaWQgMCA6IGNhY2hlZC5wYXRoKSA9PT0gcGF0aCkge1xuICAgICAgcmV0dXJuIGNhY2hlZDtcbiAgICB9XG4gICAgX2NhY2hlLnNjb3BlLnNldChub2RlLCB0aGlzKTtcbiAgICB0aGlzLnVpZCA9IHVpZCsrO1xuICAgIHRoaXMuYmxvY2sgPSBub2RlO1xuICAgIHRoaXMucGF0aCA9IHBhdGg7XG4gICAgdGhpcy5sYWJlbHMgPSBuZXcgTWFwKCk7XG4gICAgdGhpcy5pbml0ZWQgPSBmYWxzZTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydGllcyh0aGlzLCB7XG4gICAgICByZWZlcmVuY2VzOiB7XG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgIHZhbHVlOiBPYmplY3QuY3JlYXRlKG51bGwpXG4gICAgICB9LFxuICAgICAgdWlkczoge1xuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICB2YWx1ZTogT2JqZWN0LmNyZWF0ZShudWxsKVxuICAgICAgfVxuICAgIH0pO1xuICB9XG4gIGdldCBwYXJlbnQoKSB7XG4gICAgdmFyIF9wYXJlbnQ7XG4gICAgbGV0IHBhcmVudCxcbiAgICAgIHBhdGggPSB0aGlzLnBhdGg7XG4gICAgZG8ge1xuICAgICAgdmFyIF9wYXRoO1xuICAgICAgY29uc3Qgc2hvdWxkU2tpcCA9IHBhdGgua2V5ID09PSBcImtleVwiIHx8IHBhdGgubGlzdEtleSA9PT0gXCJkZWNvcmF0b3JzXCI7XG4gICAgICBwYXRoID0gcGF0aC5wYXJlbnRQYXRoO1xuICAgICAgaWYgKHNob3VsZFNraXAgJiYgcGF0aC5pc01ldGhvZCgpKSBwYXRoID0gcGF0aC5wYXJlbnRQYXRoO1xuICAgICAgaWYgKChfcGF0aCA9IHBhdGgpICE9IG51bGwgJiYgX3BhdGguaXNTY29wZSgpKSBwYXJlbnQgPSBwYXRoO1xuICAgIH0gd2hpbGUgKHBhdGggJiYgIXBhcmVudCk7XG4gICAgcmV0dXJuIChfcGFyZW50ID0gcGFyZW50KSA9PSBudWxsID8gdm9pZCAwIDogX3BhcmVudC5zY29wZTtcbiAgfVxuICBnZXQgcmVmZXJlbmNlcygpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJTY29wZSNyZWZlcmVuY2VzIGlzIG5vdCBhdmFpbGFibGUgaW4gQmFiZWwgOC4gVXNlIFNjb3BlI3JlZmVyZW5jZXNTZXQgaW5zdGVhZC5cIik7XG4gIH1cbiAgZ2V0IHVpZHMoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiU2NvcGUjdWlkcyBpcyBub3QgYXZhaWxhYmxlIGluIEJhYmVsIDguIFVzZSBTY29wZSN1aWRzU2V0IGluc3RlYWQuXCIpO1xuICB9XG4gIGdlbmVyYXRlRGVjbGFyZWRVaWRJZGVudGlmaWVyKG5hbWUpIHtcbiAgICBjb25zdCBpZCA9IHRoaXMuZ2VuZXJhdGVVaWRJZGVudGlmaWVyKG5hbWUpO1xuICAgIHRoaXMucHVzaCh7XG4gICAgICBpZFxuICAgIH0pO1xuICAgIHJldHVybiBjbG9uZU5vZGUoaWQpO1xuICB9XG4gIGdlbmVyYXRlVWlkSWRlbnRpZmllcihuYW1lKSB7XG4gICAgcmV0dXJuIGlkZW50aWZpZXIodGhpcy5nZW5lcmF0ZVVpZChuYW1lKSk7XG4gIH1cbiAgZ2VuZXJhdGVVaWQobmFtZSA9IFwidGVtcFwiKSB7XG4gICAgbmFtZSA9IHRvSWRlbnRpZmllcihuYW1lKS5yZXBsYWNlKC9eXysvLCBcIlwiKS5yZXBsYWNlKC9cXGQrJC9nLCBcIlwiKTtcbiAgICBsZXQgdWlkO1xuICAgIGxldCBpID0gMDtcbiAgICBkbyB7XG4gICAgICB1aWQgPSBgXyR7bmFtZX1gO1xuICAgICAgaWYgKGkgPj0gMTEpIHVpZCArPSBpIC0gMTtlbHNlIGlmIChpID49IDkpIHVpZCArPSBpIC0gOTtlbHNlIGlmIChpID49IDEpIHVpZCArPSBpICsgMTtcbiAgICAgIGkrKztcbiAgICB9IHdoaWxlICh0aGlzLmhhc0xhYmVsKHVpZCkgfHwgdGhpcy5oYXNCaW5kaW5nKHVpZCkgfHwgdGhpcy5oYXNHbG9iYWwodWlkKSB8fCB0aGlzLmhhc1JlZmVyZW5jZSh1aWQpKTtcbiAgICBjb25zdCBwcm9ncmFtID0gdGhpcy5nZXRQcm9ncmFtUGFyZW50KCk7XG4gICAgcHJvZ3JhbS5yZWZlcmVuY2VzW3VpZF0gPSB0cnVlO1xuICAgIHByb2dyYW0udWlkc1t1aWRdID0gdHJ1ZTtcbiAgICByZXR1cm4gdWlkO1xuICB9XG4gIGdlbmVyYXRlVWlkQmFzZWRPbk5vZGUobm9kZSwgZGVmYXVsdE5hbWUpIHtcbiAgICBjb25zdCBwYXJ0cyA9IFtdO1xuICAgIGdhdGhlck5vZGVQYXJ0cyhub2RlLCBwYXJ0cyk7XG4gICAgbGV0IGlkID0gcGFydHMuam9pbihcIiRcIik7XG4gICAgaWQgPSBpZC5yZXBsYWNlKC9eXy8sIFwiXCIpIHx8IGRlZmF1bHROYW1lIHx8IFwicmVmXCI7XG4gICAgcmV0dXJuIHRoaXMuZ2VuZXJhdGVVaWQoaWQuc2xpY2UoMCwgMjApKTtcbiAgfVxuICBnZW5lcmF0ZVVpZElkZW50aWZpZXJCYXNlZE9uTm9kZShub2RlLCBkZWZhdWx0TmFtZSkge1xuICAgIHJldHVybiBpZGVudGlmaWVyKHRoaXMuZ2VuZXJhdGVVaWRCYXNlZE9uTm9kZShub2RlLCBkZWZhdWx0TmFtZSkpO1xuICB9XG4gIGlzU3RhdGljKG5vZGUpIHtcbiAgICBpZiAoaXNUaGlzRXhwcmVzc2lvbihub2RlKSB8fCBpc1N1cGVyKG5vZGUpIHx8IGlzVG9waWNSZWZlcmVuY2Uobm9kZSkpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBpZiAoaXNJZGVudGlmaWVyKG5vZGUpKSB7XG4gICAgICBjb25zdCBiaW5kaW5nID0gdGhpcy5nZXRCaW5kaW5nKG5vZGUubmFtZSk7XG4gICAgICBpZiAoYmluZGluZykge1xuICAgICAgICByZXR1cm4gYmluZGluZy5jb25zdGFudDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiB0aGlzLmhhc0JpbmRpbmcobm9kZS5uYW1lKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIG1heWJlR2VuZXJhdGVNZW1vaXNlZChub2RlLCBkb250UHVzaCkge1xuICAgIGlmICh0aGlzLmlzU3RhdGljKG5vZGUpKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgaWQgPSB0aGlzLmdlbmVyYXRlVWlkSWRlbnRpZmllckJhc2VkT25Ob2RlKG5vZGUpO1xuICAgICAgaWYgKCFkb250UHVzaCkge1xuICAgICAgICB0aGlzLnB1c2goe1xuICAgICAgICAgIGlkXG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gY2xvbmVOb2RlKGlkKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBpZDtcbiAgICB9XG4gIH1cbiAgY2hlY2tCbG9ja1Njb3BlZENvbGxpc2lvbnMobG9jYWwsIGtpbmQsIG5hbWUsIGlkKSB7XG4gICAgaWYgKGtpbmQgPT09IFwicGFyYW1cIikgcmV0dXJuO1xuICAgIGlmIChsb2NhbC5raW5kID09PSBcImxvY2FsXCIpIHJldHVybjtcbiAgICBjb25zdCBkdXBsaWNhdGUgPSBraW5kID09PSBcImxldFwiIHx8IGxvY2FsLmtpbmQgPT09IFwibGV0XCIgfHwgbG9jYWwua2luZCA9PT0gXCJjb25zdFwiIHx8IGxvY2FsLmtpbmQgPT09IFwibW9kdWxlXCIgfHwgbG9jYWwua2luZCA9PT0gXCJwYXJhbVwiICYmIGtpbmQgPT09IFwiY29uc3RcIjtcbiAgICBpZiAoZHVwbGljYXRlKSB7XG4gICAgICB0aHJvdyB0aGlzLnBhdGguaHViLmJ1aWxkRXJyb3IoaWQsIGBEdXBsaWNhdGUgZGVjbGFyYXRpb24gXCIke25hbWV9XCJgLCBUeXBlRXJyb3IpO1xuICAgIH1cbiAgfVxuICByZW5hbWUob2xkTmFtZSwgbmV3TmFtZSkge1xuICAgIGNvbnN0IGJpbmRpbmcgPSB0aGlzLmdldEJpbmRpbmcob2xkTmFtZSk7XG4gICAgaWYgKGJpbmRpbmcpIHtcbiAgICAgIG5ld05hbWUgfHwgKG5ld05hbWUgPSB0aGlzLmdlbmVyYXRlVWlkSWRlbnRpZmllcihvbGROYW1lKS5uYW1lKTtcbiAgICAgIGNvbnN0IHJlbmFtZXIgPSBuZXcgX3JlbmFtZXIuZGVmYXVsdChiaW5kaW5nLCBvbGROYW1lLCBuZXdOYW1lKTtcbiAgICAgIHJlbmFtZXIucmVuYW1lKGFyZ3VtZW50c1syXSk7XG4gICAgfVxuICB9XG4gIGR1bXAoKSB7XG4gICAgY29uc3Qgc2VwID0gXCItXCIucmVwZWF0KDYwKTtcbiAgICBjb25zb2xlLmxvZyhzZXApO1xuICAgIGxldCBzY29wZSA9IHRoaXM7XG4gICAgZG8ge1xuICAgICAgY29uc29sZS5sb2coXCIjXCIsIHNjb3BlLmJsb2NrLnR5cGUpO1xuICAgICAgZm9yIChjb25zdCBuYW1lIG9mIE9iamVjdC5rZXlzKHNjb3BlLmJpbmRpbmdzKSkge1xuICAgICAgICBjb25zdCBiaW5kaW5nID0gc2NvcGUuYmluZGluZ3NbbmFtZV07XG4gICAgICAgIGNvbnNvbGUubG9nKFwiIC1cIiwgbmFtZSwge1xuICAgICAgICAgIGNvbnN0YW50OiBiaW5kaW5nLmNvbnN0YW50LFxuICAgICAgICAgIHJlZmVyZW5jZXM6IGJpbmRpbmcucmVmZXJlbmNlcyxcbiAgICAgICAgICB2aW9sYXRpb25zOiBiaW5kaW5nLmNvbnN0YW50VmlvbGF0aW9ucy5sZW5ndGgsXG4gICAgICAgICAga2luZDogYmluZGluZy5raW5kXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0gd2hpbGUgKHNjb3BlID0gc2NvcGUucGFyZW50KTtcbiAgICBjb25zb2xlLmxvZyhzZXApO1xuICB9XG4gIGhhc0xhYmVsKG5hbWUpIHtcbiAgICByZXR1cm4gISF0aGlzLmdldExhYmVsKG5hbWUpO1xuICB9XG4gIGdldExhYmVsKG5hbWUpIHtcbiAgICByZXR1cm4gdGhpcy5sYWJlbHMuZ2V0KG5hbWUpO1xuICB9XG4gIHJlZ2lzdGVyTGFiZWwocGF0aCkge1xuICAgIHRoaXMubGFiZWxzLnNldChwYXRoLm5vZGUubGFiZWwubmFtZSwgcGF0aCk7XG4gIH1cbiAgcmVnaXN0ZXJEZWNsYXJhdGlvbihwYXRoKSB7XG4gICAgaWYgKHBhdGguaXNMYWJlbGVkU3RhdGVtZW50KCkpIHtcbiAgICAgIHRoaXMucmVnaXN0ZXJMYWJlbChwYXRoKTtcbiAgICB9IGVsc2UgaWYgKHBhdGguaXNGdW5jdGlvbkRlY2xhcmF0aW9uKCkpIHtcbiAgICAgIHRoaXMucmVnaXN0ZXJCaW5kaW5nKFwiaG9pc3RlZFwiLCBwYXRoLmdldChcImlkXCIpLCBwYXRoKTtcbiAgICB9IGVsc2UgaWYgKHBhdGguaXNWYXJpYWJsZURlY2xhcmF0aW9uKCkpIHtcbiAgICAgIGNvbnN0IGRlY2xhcmF0aW9ucyA9IHBhdGguZ2V0KFwiZGVjbGFyYXRpb25zXCIpO1xuICAgICAgY29uc3Qge1xuICAgICAgICBraW5kXG4gICAgICB9ID0gcGF0aC5ub2RlO1xuICAgICAgZm9yIChjb25zdCBkZWNsYXIgb2YgZGVjbGFyYXRpb25zKSB7XG4gICAgICAgIHRoaXMucmVnaXN0ZXJCaW5kaW5nKGtpbmQgPT09IFwidXNpbmdcIiB8fCBraW5kID09PSBcImF3YWl0IHVzaW5nXCIgPyBcImNvbnN0XCIgOiBraW5kLCBkZWNsYXIpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAocGF0aC5pc0NsYXNzRGVjbGFyYXRpb24oKSkge1xuICAgICAgaWYgKHBhdGgubm9kZS5kZWNsYXJlKSByZXR1cm47XG4gICAgICB0aGlzLnJlZ2lzdGVyQmluZGluZyhcImxldFwiLCBwYXRoKTtcbiAgICB9IGVsc2UgaWYgKHBhdGguaXNJbXBvcnREZWNsYXJhdGlvbigpKSB7XG4gICAgICBjb25zdCBpc1R5cGVEZWNsYXJhdGlvbiA9IHBhdGgubm9kZS5pbXBvcnRLaW5kID09PSBcInR5cGVcIiB8fCBwYXRoLm5vZGUuaW1wb3J0S2luZCA9PT0gXCJ0eXBlb2ZcIjtcbiAgICAgIGNvbnN0IHNwZWNpZmllcnMgPSBwYXRoLmdldChcInNwZWNpZmllcnNcIik7XG4gICAgICBmb3IgKGNvbnN0IHNwZWNpZmllciBvZiBzcGVjaWZpZXJzKSB7XG4gICAgICAgIGNvbnN0IGlzVHlwZVNwZWNpZmllciA9IGlzVHlwZURlY2xhcmF0aW9uIHx8IHNwZWNpZmllci5pc0ltcG9ydFNwZWNpZmllcigpICYmIChzcGVjaWZpZXIubm9kZS5pbXBvcnRLaW5kID09PSBcInR5cGVcIiB8fCBzcGVjaWZpZXIubm9kZS5pbXBvcnRLaW5kID09PSBcInR5cGVvZlwiKTtcbiAgICAgICAgdGhpcy5yZWdpc3RlckJpbmRpbmcoaXNUeXBlU3BlY2lmaWVyID8gXCJ1bmtub3duXCIgOiBcIm1vZHVsZVwiLCBzcGVjaWZpZXIpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAocGF0aC5pc0V4cG9ydERlY2xhcmF0aW9uKCkpIHtcbiAgICAgIGNvbnN0IGRlY2xhciA9IHBhdGguZ2V0KFwiZGVjbGFyYXRpb25cIik7XG4gICAgICBpZiAoZGVjbGFyLmlzQ2xhc3NEZWNsYXJhdGlvbigpIHx8IGRlY2xhci5pc0Z1bmN0aW9uRGVjbGFyYXRpb24oKSB8fCBkZWNsYXIuaXNWYXJpYWJsZURlY2xhcmF0aW9uKCkpIHtcbiAgICAgICAgdGhpcy5yZWdpc3RlckRlY2xhcmF0aW9uKGRlY2xhcik7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMucmVnaXN0ZXJCaW5kaW5nKFwidW5rbm93blwiLCBwYXRoKTtcbiAgICB9XG4gIH1cbiAgYnVpbGRVbmRlZmluZWROb2RlKCkge1xuICAgIHJldHVybiBidWlsZFVuZGVmaW5lZE5vZGUoKTtcbiAgfVxuICByZWdpc3RlckNvbnN0YW50VmlvbGF0aW9uKHBhdGgpIHtcbiAgICBjb25zdCBpZHMgPSBwYXRoLmdldEFzc2lnbm1lbnRJZGVudGlmaWVycygpO1xuICAgIGZvciAoY29uc3QgbmFtZSBvZiBPYmplY3Qua2V5cyhpZHMpKSB7XG4gICAgICB2YXIgX3RoaXMkZ2V0QmluZGluZztcbiAgICAgIChfdGhpcyRnZXRCaW5kaW5nID0gdGhpcy5nZXRCaW5kaW5nKG5hbWUpKSA9PSBudWxsIHx8IF90aGlzJGdldEJpbmRpbmcucmVhc3NpZ24ocGF0aCk7XG4gICAgfVxuICB9XG4gIHJlZ2lzdGVyQmluZGluZyhraW5kLCBwYXRoLCBiaW5kaW5nUGF0aCA9IHBhdGgpIHtcbiAgICBpZiAoIWtpbmQpIHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcIm5vIGBraW5kYFwiKTtcbiAgICBpZiAocGF0aC5pc1ZhcmlhYmxlRGVjbGFyYXRpb24oKSkge1xuICAgICAgY29uc3QgZGVjbGFyYXRvcnMgPSBwYXRoLmdldChcImRlY2xhcmF0aW9uc1wiKTtcbiAgICAgIGZvciAoY29uc3QgZGVjbGFyIG9mIGRlY2xhcmF0b3JzKSB7XG4gICAgICAgIHRoaXMucmVnaXN0ZXJCaW5kaW5nKGtpbmQsIGRlY2xhcik7XG4gICAgICB9XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHBhcmVudCA9IHRoaXMuZ2V0UHJvZ3JhbVBhcmVudCgpO1xuICAgIGNvbnN0IGlkcyA9IHBhdGguZ2V0T3V0ZXJCaW5kaW5nSWRlbnRpZmllcnModHJ1ZSk7XG4gICAgZm9yIChjb25zdCBuYW1lIG9mIE9iamVjdC5rZXlzKGlkcykpIHtcbiAgICAgIHBhcmVudC5yZWZlcmVuY2VzW25hbWVdID0gdHJ1ZTtcbiAgICAgIGZvciAoY29uc3QgaWQgb2YgaWRzW25hbWVdKSB7XG4gICAgICAgIGNvbnN0IGxvY2FsID0gdGhpcy5nZXRPd25CaW5kaW5nKG5hbWUpO1xuICAgICAgICBpZiAobG9jYWwpIHtcbiAgICAgICAgICBpZiAobG9jYWwuaWRlbnRpZmllciA9PT0gaWQpIGNvbnRpbnVlO1xuICAgICAgICAgIHRoaXMuY2hlY2tCbG9ja1Njb3BlZENvbGxpc2lvbnMobG9jYWwsIGtpbmQsIG5hbWUsIGlkKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobG9jYWwpIHtcbiAgICAgICAgICBsb2NhbC5yZWFzc2lnbihiaW5kaW5nUGF0aCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5iaW5kaW5nc1tuYW1lXSA9IG5ldyBfYmluZGluZy5kZWZhdWx0KHtcbiAgICAgICAgICAgIGlkZW50aWZpZXI6IGlkLFxuICAgICAgICAgICAgc2NvcGU6IHRoaXMsXG4gICAgICAgICAgICBwYXRoOiBiaW5kaW5nUGF0aCxcbiAgICAgICAgICAgIGtpbmQ6IGtpbmRcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuICBhZGRHbG9iYWwobm9kZSkge1xuICAgIHRoaXMuZ2xvYmFsc1tub2RlLm5hbWVdID0gbm9kZTtcbiAgfVxuICBoYXNVaWQobmFtZSkge1xuICAgIGxldCBzY29wZSA9IHRoaXM7XG4gICAgZG8ge1xuICAgICAgaWYgKHNjb3BlLnVpZHNbbmFtZV0pIHJldHVybiB0cnVlO1xuICAgIH0gd2hpbGUgKHNjb3BlID0gc2NvcGUucGFyZW50KTtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgaGFzR2xvYmFsKG5hbWUpIHtcbiAgICBsZXQgc2NvcGUgPSB0aGlzO1xuICAgIGRvIHtcbiAgICAgIGlmIChzY29wZS5nbG9iYWxzW25hbWVdKSByZXR1cm4gdHJ1ZTtcbiAgICB9IHdoaWxlIChzY29wZSA9IHNjb3BlLnBhcmVudCk7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGhhc1JlZmVyZW5jZShuYW1lKSB7XG4gICAgcmV0dXJuICEhdGhpcy5nZXRQcm9ncmFtUGFyZW50KCkucmVmZXJlbmNlc1tuYW1lXTtcbiAgfVxuICBpc1B1cmUobm9kZSwgY29uc3RhbnRzT25seSkge1xuICAgIGlmIChpc0lkZW50aWZpZXIobm9kZSkpIHtcbiAgICAgIGNvbnN0IGJpbmRpbmcgPSB0aGlzLmdldEJpbmRpbmcobm9kZS5uYW1lKTtcbiAgICAgIGlmICghYmluZGluZykgcmV0dXJuIGZhbHNlO1xuICAgICAgaWYgKGNvbnN0YW50c09ubHkpIHJldHVybiBiaW5kaW5nLmNvbnN0YW50O1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBlbHNlIGlmIChpc1RoaXNFeHByZXNzaW9uKG5vZGUpIHx8IGlzTWV0YVByb3BlcnR5KG5vZGUpIHx8IGlzVG9waWNSZWZlcmVuY2Uobm9kZSkgfHwgaXNQcml2YXRlTmFtZShub2RlKSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBlbHNlIGlmIChpc0NsYXNzKG5vZGUpKSB7XG4gICAgICB2YXIgX25vZGUkZGVjb3JhdG9ycztcbiAgICAgIGlmIChub2RlLnN1cGVyQ2xhc3MgJiYgIXRoaXMuaXNQdXJlKG5vZGUuc3VwZXJDbGFzcywgY29uc3RhbnRzT25seSkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgaWYgKCgoX25vZGUkZGVjb3JhdG9ycyA9IG5vZGUuZGVjb3JhdG9ycykgPT0gbnVsbCA/IHZvaWQgMCA6IF9ub2RlJGRlY29yYXRvcnMubGVuZ3RoKSA+IDApIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXMuaXNQdXJlKG5vZGUuYm9keSwgY29uc3RhbnRzT25seSk7XG4gICAgfSBlbHNlIGlmIChpc0NsYXNzQm9keShub2RlKSkge1xuICAgICAgZm9yIChjb25zdCBtZXRob2Qgb2Ygbm9kZS5ib2R5KSB7XG4gICAgICAgIGlmICghdGhpcy5pc1B1cmUobWV0aG9kLCBjb25zdGFudHNPbmx5KSkgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBlbHNlIGlmIChpc0JpbmFyeShub2RlKSkge1xuICAgICAgcmV0dXJuIHRoaXMuaXNQdXJlKG5vZGUubGVmdCwgY29uc3RhbnRzT25seSkgJiYgdGhpcy5pc1B1cmUobm9kZS5yaWdodCwgY29uc3RhbnRzT25seSk7XG4gICAgfSBlbHNlIGlmIChpc0FycmF5RXhwcmVzc2lvbihub2RlKSB8fCAobm9kZSA9PSBudWxsID8gdm9pZCAwIDogbm9kZS50eXBlKSA9PT0gXCJUdXBsZUV4cHJlc3Npb25cIikge1xuICAgICAgZm9yIChjb25zdCBlbGVtIG9mIG5vZGUuZWxlbWVudHMpIHtcbiAgICAgICAgaWYgKGVsZW0gIT09IG51bGwgJiYgIXRoaXMuaXNQdXJlKGVsZW0sIGNvbnN0YW50c09ubHkpKSByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGVsc2UgaWYgKGlzT2JqZWN0RXhwcmVzc2lvbihub2RlKSB8fCAobm9kZSA9PSBudWxsID8gdm9pZCAwIDogbm9kZS50eXBlKSA9PT0gXCJSZWNvcmRFeHByZXNzaW9uXCIpIHtcbiAgICAgIGZvciAoY29uc3QgcHJvcCBvZiBub2RlLnByb3BlcnRpZXMpIHtcbiAgICAgICAgaWYgKCF0aGlzLmlzUHVyZShwcm9wLCBjb25zdGFudHNPbmx5KSkgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBlbHNlIGlmIChpc01ldGhvZChub2RlKSkge1xuICAgICAgdmFyIF9ub2RlJGRlY29yYXRvcnMyO1xuICAgICAgaWYgKG5vZGUuY29tcHV0ZWQgJiYgIXRoaXMuaXNQdXJlKG5vZGUua2V5LCBjb25zdGFudHNPbmx5KSkgcmV0dXJuIGZhbHNlO1xuICAgICAgaWYgKCgoX25vZGUkZGVjb3JhdG9yczIgPSBub2RlLmRlY29yYXRvcnMpID09IG51bGwgPyB2b2lkIDAgOiBfbm9kZSRkZWNvcmF0b3JzMi5sZW5ndGgpID4gMCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGVsc2UgaWYgKGlzUHJvcGVydHkobm9kZSkpIHtcbiAgICAgIHZhciBfbm9kZSRkZWNvcmF0b3JzMztcbiAgICAgIGlmIChub2RlLmNvbXB1dGVkICYmICF0aGlzLmlzUHVyZShub2RlLmtleSwgY29uc3RhbnRzT25seSkpIHJldHVybiBmYWxzZTtcbiAgICAgIGlmICgoKF9ub2RlJGRlY29yYXRvcnMzID0gbm9kZS5kZWNvcmF0b3JzKSA9PSBudWxsID8gdm9pZCAwIDogX25vZGUkZGVjb3JhdG9yczMubGVuZ3RoKSA+IDApIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgaWYgKGlzT2JqZWN0UHJvcGVydHkobm9kZSkgfHwgbm9kZS5zdGF0aWMpIHtcbiAgICAgICAgaWYgKG5vZGUudmFsdWUgIT09IG51bGwgJiYgIXRoaXMuaXNQdXJlKG5vZGUudmFsdWUsIGNvbnN0YW50c09ubHkpKSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGVsc2UgaWYgKGlzVW5hcnlFeHByZXNzaW9uKG5vZGUpKSB7XG4gICAgICByZXR1cm4gdGhpcy5pc1B1cmUobm9kZS5hcmd1bWVudCwgY29uc3RhbnRzT25seSk7XG4gICAgfSBlbHNlIGlmIChpc1RlbXBsYXRlTGl0ZXJhbChub2RlKSkge1xuICAgICAgZm9yIChjb25zdCBleHByZXNzaW9uIG9mIG5vZGUuZXhwcmVzc2lvbnMpIHtcbiAgICAgICAgaWYgKCF0aGlzLmlzUHVyZShleHByZXNzaW9uLCBjb25zdGFudHNPbmx5KSkgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBlbHNlIGlmIChpc1RhZ2dlZFRlbXBsYXRlRXhwcmVzc2lvbihub2RlKSkge1xuICAgICAgcmV0dXJuIG1hdGNoZXNQYXR0ZXJuKG5vZGUudGFnLCBcIlN0cmluZy5yYXdcIikgJiYgIXRoaXMuaGFzQmluZGluZyhcIlN0cmluZ1wiLCB7XG4gICAgICAgIG5vR2xvYmFsczogdHJ1ZVxuICAgICAgfSkgJiYgdGhpcy5pc1B1cmUobm9kZS5xdWFzaSwgY29uc3RhbnRzT25seSk7XG4gICAgfSBlbHNlIGlmIChpc01lbWJlckV4cHJlc3Npb24obm9kZSkpIHtcbiAgICAgIHJldHVybiAhbm9kZS5jb21wdXRlZCAmJiBpc0lkZW50aWZpZXIobm9kZS5vYmplY3QpICYmIG5vZGUub2JqZWN0Lm5hbWUgPT09IFwiU3ltYm9sXCIgJiYgaXNJZGVudGlmaWVyKG5vZGUucHJvcGVydHkpICYmIG5vZGUucHJvcGVydHkubmFtZSAhPT0gXCJmb3JcIiAmJiAhdGhpcy5oYXNCaW5kaW5nKFwiU3ltYm9sXCIsIHtcbiAgICAgICAgbm9HbG9iYWxzOiB0cnVlXG4gICAgICB9KTtcbiAgICB9IGVsc2UgaWYgKGlzQ2FsbEV4cHJlc3Npb24obm9kZSkpIHtcbiAgICAgIHJldHVybiBtYXRjaGVzUGF0dGVybihub2RlLmNhbGxlZSwgXCJTeW1ib2wuZm9yXCIpICYmICF0aGlzLmhhc0JpbmRpbmcoXCJTeW1ib2xcIiwge1xuICAgICAgICBub0dsb2JhbHM6IHRydWVcbiAgICAgIH0pICYmIG5vZGUuYXJndW1lbnRzLmxlbmd0aCA9PT0gMSAmJiB0LmlzU3RyaW5nTGl0ZXJhbChub2RlLmFyZ3VtZW50c1swXSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBpc1B1cmVpc2gobm9kZSk7XG4gICAgfVxuICB9XG4gIHNldERhdGEoa2V5LCB2YWwpIHtcbiAgICByZXR1cm4gdGhpcy5kYXRhW2tleV0gPSB2YWw7XG4gIH1cbiAgZ2V0RGF0YShrZXkpIHtcbiAgICBsZXQgc2NvcGUgPSB0aGlzO1xuICAgIGRvIHtcbiAgICAgIGNvbnN0IGRhdGEgPSBzY29wZS5kYXRhW2tleV07XG4gICAgICBpZiAoZGF0YSAhPSBudWxsKSByZXR1cm4gZGF0YTtcbiAgICB9IHdoaWxlIChzY29wZSA9IHNjb3BlLnBhcmVudCk7XG4gIH1cbiAgcmVtb3ZlRGF0YShrZXkpIHtcbiAgICBsZXQgc2NvcGUgPSB0aGlzO1xuICAgIGRvIHtcbiAgICAgIGNvbnN0IGRhdGEgPSBzY29wZS5kYXRhW2tleV07XG4gICAgICBpZiAoZGF0YSAhPSBudWxsKSBzY29wZS5kYXRhW2tleV0gPSBudWxsO1xuICAgIH0gd2hpbGUgKHNjb3BlID0gc2NvcGUucGFyZW50KTtcbiAgfVxuICBpbml0KCkge1xuICAgIGlmICghdGhpcy5pbml0ZWQpIHtcbiAgICAgIHRoaXMuaW5pdGVkID0gdHJ1ZTtcbiAgICAgIHRoaXMuY3Jhd2woKTtcbiAgICB9XG4gIH1cbiAgY3Jhd2woKSB7XG4gICAgY29uc3QgcGF0aCA9IHRoaXMucGF0aDtcbiAgICByZXNldFNjb3BlKHRoaXMpO1xuICAgIHRoaXMuZGF0YSA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgbGV0IHNjb3BlID0gdGhpcztcbiAgICBkbyB7XG4gICAgICBpZiAoc2NvcGUuY3Jhd2xpbmcpIHJldHVybjtcbiAgICAgIGlmIChzY29wZS5wYXRoLmlzUHJvZ3JhbSgpKSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH0gd2hpbGUgKHNjb3BlID0gc2NvcGUucGFyZW50KTtcbiAgICBjb25zdCBwcm9ncmFtUGFyZW50ID0gc2NvcGU7XG4gICAgY29uc3Qgc3RhdGUgPSB7XG4gICAgICByZWZlcmVuY2VzOiBbXSxcbiAgICAgIGNvbnN0YW50VmlvbGF0aW9uczogW10sXG4gICAgICBhc3NpZ25tZW50czogW11cbiAgICB9O1xuICAgIHRoaXMuY3Jhd2xpbmcgPSB0cnVlO1xuICAgIHNjb3BlVmlzaXRvciB8fCAoc2NvcGVWaXNpdG9yID0gX2luZGV4LmRlZmF1bHQudmlzaXRvcnMubWVyZ2UoW3tcbiAgICAgIFNjb3BlKHBhdGgpIHtcbiAgICAgICAgcmVzZXRTY29wZShwYXRoLnNjb3BlKTtcbiAgICAgIH1cbiAgICB9LCBjb2xsZWN0b3JWaXNpdG9yXSkpO1xuICAgIGlmIChwYXRoLnR5cGUgIT09IFwiUHJvZ3JhbVwiKSB7XG4gICAgICBjb25zdCB0eXBlVmlzaXRvcnMgPSBzY29wZVZpc2l0b3JbcGF0aC50eXBlXTtcbiAgICAgIGlmICh0eXBlVmlzaXRvcnMpIHtcbiAgICAgICAgZm9yIChjb25zdCB2aXNpdCBvZiB0eXBlVmlzaXRvcnMuZW50ZXIpIHtcbiAgICAgICAgICB2aXNpdC5jYWxsKHN0YXRlLCBwYXRoLCBzdGF0ZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcGF0aC50cmF2ZXJzZShzY29wZVZpc2l0b3IsIHN0YXRlKTtcbiAgICB0aGlzLmNyYXdsaW5nID0gZmFsc2U7XG4gICAgZm9yIChjb25zdCBwYXRoIG9mIHN0YXRlLmFzc2lnbm1lbnRzKSB7XG4gICAgICBjb25zdCBpZHMgPSBwYXRoLmdldEFzc2lnbm1lbnRJZGVudGlmaWVycygpO1xuICAgICAgZm9yIChjb25zdCBuYW1lIG9mIE9iamVjdC5rZXlzKGlkcykpIHtcbiAgICAgICAgaWYgKHBhdGguc2NvcGUuZ2V0QmluZGluZyhuYW1lKSkgY29udGludWU7XG4gICAgICAgIHByb2dyYW1QYXJlbnQuYWRkR2xvYmFsKGlkc1tuYW1lXSk7XG4gICAgICB9XG4gICAgICBwYXRoLnNjb3BlLnJlZ2lzdGVyQ29uc3RhbnRWaW9sYXRpb24ocGF0aCk7XG4gICAgfVxuICAgIGZvciAoY29uc3QgcmVmIG9mIHN0YXRlLnJlZmVyZW5jZXMpIHtcbiAgICAgIGNvbnN0IGJpbmRpbmcgPSByZWYuc2NvcGUuZ2V0QmluZGluZyhyZWYubm9kZS5uYW1lKTtcbiAgICAgIGlmIChiaW5kaW5nKSB7XG4gICAgICAgIGJpbmRpbmcucmVmZXJlbmNlKHJlZik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBwcm9ncmFtUGFyZW50LmFkZEdsb2JhbChyZWYubm9kZSk7XG4gICAgICB9XG4gICAgfVxuICAgIGZvciAoY29uc3QgcGF0aCBvZiBzdGF0ZS5jb25zdGFudFZpb2xhdGlvbnMpIHtcbiAgICAgIHBhdGguc2NvcGUucmVnaXN0ZXJDb25zdGFudFZpb2xhdGlvbihwYXRoKTtcbiAgICB9XG4gIH1cbiAgcHVzaChvcHRzKSB7XG4gICAgbGV0IHBhdGggPSB0aGlzLnBhdGg7XG4gICAgaWYgKHBhdGguaXNQYXR0ZXJuKCkpIHtcbiAgICAgIHBhdGggPSB0aGlzLmdldFBhdHRlcm5QYXJlbnQoKS5wYXRoO1xuICAgIH0gZWxzZSBpZiAoIXBhdGguaXNCbG9ja1N0YXRlbWVudCgpICYmICFwYXRoLmlzUHJvZ3JhbSgpKSB7XG4gICAgICBwYXRoID0gdGhpcy5nZXRCbG9ja1BhcmVudCgpLnBhdGg7XG4gICAgfVxuICAgIGlmIChwYXRoLmlzU3dpdGNoU3RhdGVtZW50KCkpIHtcbiAgICAgIHBhdGggPSAodGhpcy5nZXRGdW5jdGlvblBhcmVudCgpIHx8IHRoaXMuZ2V0UHJvZ3JhbVBhcmVudCgpKS5wYXRoO1xuICAgIH1cbiAgICBjb25zdCB7XG4gICAgICBpbml0LFxuICAgICAgdW5pcXVlLFxuICAgICAga2luZCA9IFwidmFyXCIsXG4gICAgICBpZFxuICAgIH0gPSBvcHRzO1xuICAgIGlmICghaW5pdCAmJiAhdW5pcXVlICYmIChraW5kID09PSBcInZhclwiIHx8IGtpbmQgPT09IFwibGV0XCIpICYmIGlzQW5vbnltb3VzRnVuY3Rpb25FeHByZXNzaW9uKHBhdGgpICYmIGlzQ2FsbEV4cHJlc3Npb24ocGF0aC5wYXJlbnQsIHtcbiAgICAgIGNhbGxlZTogcGF0aC5ub2RlXG4gICAgfSkgJiYgcGF0aC5wYXJlbnQuYXJndW1lbnRzLmxlbmd0aCA8PSBwYXRoLm5vZGUucGFyYW1zLmxlbmd0aCAmJiBpc0lkZW50aWZpZXIoaWQpKSB7XG4gICAgICBwYXRoLnB1c2hDb250YWluZXIoXCJwYXJhbXNcIiwgaWQpO1xuICAgICAgcGF0aC5zY29wZS5yZWdpc3RlckJpbmRpbmcoXCJwYXJhbVwiLCBwYXRoLmdldChcInBhcmFtc1wiKVtwYXRoLm5vZGUucGFyYW1zLmxlbmd0aCAtIDFdKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKHBhdGguaXNMb29wKCkgfHwgcGF0aC5pc0NhdGNoQ2xhdXNlKCkgfHwgcGF0aC5pc0Z1bmN0aW9uKCkpIHtcbiAgICAgIHBhdGguZW5zdXJlQmxvY2soKTtcbiAgICAgIHBhdGggPSBwYXRoLmdldChcImJvZHlcIik7XG4gICAgfVxuICAgIGNvbnN0IGJsb2NrSG9pc3QgPSBvcHRzLl9ibG9ja0hvaXN0ID09IG51bGwgPyAyIDogb3B0cy5fYmxvY2tIb2lzdDtcbiAgICBjb25zdCBkYXRhS2V5ID0gYGRlY2xhcmF0aW9uOiR7a2luZH06JHtibG9ja0hvaXN0fWA7XG4gICAgbGV0IGRlY2xhclBhdGggPSAhdW5pcXVlICYmIHBhdGguZ2V0RGF0YShkYXRhS2V5KTtcbiAgICBpZiAoIWRlY2xhclBhdGgpIHtcbiAgICAgIGNvbnN0IGRlY2xhciA9IHZhcmlhYmxlRGVjbGFyYXRpb24oa2luZCwgW10pO1xuICAgICAgZGVjbGFyLl9ibG9ja0hvaXN0ID0gYmxvY2tIb2lzdDtcbiAgICAgIFtkZWNsYXJQYXRoXSA9IHBhdGgudW5zaGlmdENvbnRhaW5lcihcImJvZHlcIiwgW2RlY2xhcl0pO1xuICAgICAgaWYgKCF1bmlxdWUpIHBhdGguc2V0RGF0YShkYXRhS2V5LCBkZWNsYXJQYXRoKTtcbiAgICB9XG4gICAgY29uc3QgZGVjbGFyYXRvciA9IHZhcmlhYmxlRGVjbGFyYXRvcihpZCwgaW5pdCk7XG4gICAgY29uc3QgbGVuID0gZGVjbGFyUGF0aC5ub2RlLmRlY2xhcmF0aW9ucy5wdXNoKGRlY2xhcmF0b3IpO1xuICAgIHBhdGguc2NvcGUucmVnaXN0ZXJCaW5kaW5nKGtpbmQsIGRlY2xhclBhdGguZ2V0KFwiZGVjbGFyYXRpb25zXCIpW2xlbiAtIDFdKTtcbiAgfVxuICBnZXRQcm9ncmFtUGFyZW50KCkge1xuICAgIGxldCBzY29wZSA9IHRoaXM7XG4gICAgZG8ge1xuICAgICAgaWYgKHNjb3BlLnBhdGguaXNQcm9ncmFtKCkpIHtcbiAgICAgICAgcmV0dXJuIHNjb3BlO1xuICAgICAgfVxuICAgIH0gd2hpbGUgKHNjb3BlID0gc2NvcGUucGFyZW50KTtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJDb3VsZG4ndCBmaW5kIGEgUHJvZ3JhbVwiKTtcbiAgfVxuICBnZXRGdW5jdGlvblBhcmVudCgpIHtcbiAgICBsZXQgc2NvcGUgPSB0aGlzO1xuICAgIGRvIHtcbiAgICAgIGlmIChzY29wZS5wYXRoLmlzRnVuY3Rpb25QYXJlbnQoKSkge1xuICAgICAgICByZXR1cm4gc2NvcGU7XG4gICAgICB9XG4gICAgfSB3aGlsZSAoc2NvcGUgPSBzY29wZS5wYXJlbnQpO1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIGdldEJsb2NrUGFyZW50KCkge1xuICAgIGxldCBzY29wZSA9IHRoaXM7XG4gICAgZG8ge1xuICAgICAgaWYgKHNjb3BlLnBhdGguaXNCbG9ja1BhcmVudCgpKSB7XG4gICAgICAgIHJldHVybiBzY29wZTtcbiAgICAgIH1cbiAgICB9IHdoaWxlIChzY29wZSA9IHNjb3BlLnBhcmVudCk7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiV2UgY291bGRuJ3QgZmluZCBhIEJsb2NrU3RhdGVtZW50LCBGb3IsIFN3aXRjaCwgRnVuY3Rpb24sIExvb3Agb3IgUHJvZ3JhbS4uLlwiKTtcbiAgfVxuICBnZXRQYXR0ZXJuUGFyZW50KCkge1xuICAgIGxldCBzY29wZSA9IHRoaXM7XG4gICAgZG8ge1xuICAgICAgaWYgKCFzY29wZS5wYXRoLmlzUGF0dGVybigpKSB7XG4gICAgICAgIHJldHVybiBzY29wZS5nZXRCbG9ja1BhcmVudCgpO1xuICAgICAgfVxuICAgIH0gd2hpbGUgKHNjb3BlID0gc2NvcGUucGFyZW50LnBhcmVudCk7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiV2UgY291bGRuJ3QgZmluZCBhIEJsb2NrU3RhdGVtZW50LCBGb3IsIFN3aXRjaCwgRnVuY3Rpb24sIExvb3Agb3IgUHJvZ3JhbS4uLlwiKTtcbiAgfVxuICBnZXRBbGxCaW5kaW5ncygpIHtcbiAgICBjb25zdCBpZHMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgIGxldCBzY29wZSA9IHRoaXM7XG4gICAgZG8ge1xuICAgICAgZm9yIChjb25zdCBrZXkgb2YgT2JqZWN0LmtleXMoc2NvcGUuYmluZGluZ3MpKSB7XG4gICAgICAgIGlmIChrZXkgaW4gaWRzID09PSBmYWxzZSkge1xuICAgICAgICAgIGlkc1trZXldID0gc2NvcGUuYmluZGluZ3Nba2V5XTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgc2NvcGUgPSBzY29wZS5wYXJlbnQ7XG4gICAgfSB3aGlsZSAoc2NvcGUpO1xuICAgIHJldHVybiBpZHM7XG4gIH1cbiAgYmluZGluZ0lkZW50aWZpZXJFcXVhbHMobmFtZSwgbm9kZSkge1xuICAgIHJldHVybiB0aGlzLmdldEJpbmRpbmdJZGVudGlmaWVyKG5hbWUpID09PSBub2RlO1xuICB9XG4gIGdldEJpbmRpbmcobmFtZSkge1xuICAgIGxldCBzY29wZSA9IHRoaXM7XG4gICAgbGV0IHByZXZpb3VzUGF0aDtcbiAgICBkbyB7XG4gICAgICBjb25zdCBiaW5kaW5nID0gc2NvcGUuZ2V0T3duQmluZGluZyhuYW1lKTtcbiAgICAgIGlmIChiaW5kaW5nKSB7XG4gICAgICAgIHZhciBfcHJldmlvdXNQYXRoO1xuICAgICAgICBpZiAoKF9wcmV2aW91c1BhdGggPSBwcmV2aW91c1BhdGgpICE9IG51bGwgJiYgX3ByZXZpb3VzUGF0aC5pc1BhdHRlcm4oKSAmJiBiaW5kaW5nLmtpbmQgIT09IFwicGFyYW1cIiAmJiBiaW5kaW5nLmtpbmQgIT09IFwibG9jYWxcIikge30gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIGJpbmRpbmc7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoIWJpbmRpbmcgJiYgbmFtZSA9PT0gXCJhcmd1bWVudHNcIiAmJiBzY29wZS5wYXRoLmlzRnVuY3Rpb24oKSAmJiAhc2NvcGUucGF0aC5pc0Fycm93RnVuY3Rpb25FeHByZXNzaW9uKCkpIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBwcmV2aW91c1BhdGggPSBzY29wZS5wYXRoO1xuICAgIH0gd2hpbGUgKHNjb3BlID0gc2NvcGUucGFyZW50KTtcbiAgfVxuICBnZXRPd25CaW5kaW5nKG5hbWUpIHtcbiAgICByZXR1cm4gdGhpcy5iaW5kaW5nc1tuYW1lXTtcbiAgfVxuICBnZXRCaW5kaW5nSWRlbnRpZmllcihuYW1lKSB7XG4gICAgdmFyIF90aGlzJGdldEJpbmRpbmcyO1xuICAgIHJldHVybiAoX3RoaXMkZ2V0QmluZGluZzIgPSB0aGlzLmdldEJpbmRpbmcobmFtZSkpID09IG51bGwgPyB2b2lkIDAgOiBfdGhpcyRnZXRCaW5kaW5nMi5pZGVudGlmaWVyO1xuICB9XG4gIGdldE93bkJpbmRpbmdJZGVudGlmaWVyKG5hbWUpIHtcbiAgICBjb25zdCBiaW5kaW5nID0gdGhpcy5iaW5kaW5nc1tuYW1lXTtcbiAgICByZXR1cm4gYmluZGluZyA9PSBudWxsID8gdm9pZCAwIDogYmluZGluZy5pZGVudGlmaWVyO1xuICB9XG4gIGhhc093bkJpbmRpbmcobmFtZSkge1xuICAgIHJldHVybiAhIXRoaXMuZ2V0T3duQmluZGluZyhuYW1lKTtcbiAgfVxuICBoYXNCaW5kaW5nKG5hbWUsIG9wdHMpIHtcbiAgICBpZiAoIW5hbWUpIHJldHVybiBmYWxzZTtcbiAgICBsZXQgbm9HbG9iYWxzO1xuICAgIGxldCBub1VpZHM7XG4gICAgbGV0IHVwVG9TY29wZTtcbiAgICBpZiAodHlwZW9mIG9wdHMgPT09IFwib2JqZWN0XCIpIHtcbiAgICAgIG5vR2xvYmFscyA9IG9wdHMubm9HbG9iYWxzO1xuICAgICAgbm9VaWRzID0gb3B0cy5ub1VpZHM7XG4gICAgICB1cFRvU2NvcGUgPSBvcHRzLnVwVG9TY29wZTtcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBvcHRzID09PSBcImJvb2xlYW5cIikge1xuICAgICAgbm9HbG9iYWxzID0gb3B0cztcbiAgICB9XG4gICAgbGV0IHNjb3BlID0gdGhpcztcbiAgICBkbyB7XG4gICAgICBpZiAodXBUb1Njb3BlID09PSBzY29wZSkge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGlmIChzY29wZS5oYXNPd25CaW5kaW5nKG5hbWUpKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgIH0gd2hpbGUgKHNjb3BlID0gc2NvcGUucGFyZW50KTtcbiAgICBpZiAoIW5vVWlkcyAmJiB0aGlzLmhhc1VpZChuYW1lKSkgcmV0dXJuIHRydWU7XG4gICAgaWYgKCFub0dsb2JhbHMgJiYgU2NvcGUuZ2xvYmFscy5pbmNsdWRlcyhuYW1lKSkgcmV0dXJuIHRydWU7XG4gICAgaWYgKCFub0dsb2JhbHMgJiYgU2NvcGUuY29udGV4dFZhcmlhYmxlcy5pbmNsdWRlcyhuYW1lKSkgcmV0dXJuIHRydWU7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHBhcmVudEhhc0JpbmRpbmcobmFtZSwgb3B0cykge1xuICAgIHZhciBfdGhpcyRwYXJlbnQ7XG4gICAgcmV0dXJuIChfdGhpcyRwYXJlbnQgPSB0aGlzLnBhcmVudCkgPT0gbnVsbCA/IHZvaWQgMCA6IF90aGlzJHBhcmVudC5oYXNCaW5kaW5nKG5hbWUsIG9wdHMpO1xuICB9XG4gIG1vdmVCaW5kaW5nVG8obmFtZSwgc2NvcGUpIHtcbiAgICBjb25zdCBpbmZvID0gdGhpcy5nZXRCaW5kaW5nKG5hbWUpO1xuICAgIGlmIChpbmZvKSB7XG4gICAgICBpbmZvLnNjb3BlLnJlbW92ZU93bkJpbmRpbmcobmFtZSk7XG4gICAgICBpbmZvLnNjb3BlID0gc2NvcGU7XG4gICAgICBzY29wZS5iaW5kaW5nc1tuYW1lXSA9IGluZm87XG4gICAgfVxuICB9XG4gIHJlbW92ZU93bkJpbmRpbmcobmFtZSkge1xuICAgIGRlbGV0ZSB0aGlzLmJpbmRpbmdzW25hbWVdO1xuICB9XG4gIHJlbW92ZUJpbmRpbmcobmFtZSkge1xuICAgIHZhciBfdGhpcyRnZXRCaW5kaW5nMztcbiAgICAoX3RoaXMkZ2V0QmluZGluZzMgPSB0aGlzLmdldEJpbmRpbmcobmFtZSkpID09IG51bGwgfHwgX3RoaXMkZ2V0QmluZGluZzMuc2NvcGUucmVtb3ZlT3duQmluZGluZyhuYW1lKTtcbiAgICBsZXQgc2NvcGUgPSB0aGlzO1xuICAgIGRvIHtcbiAgICAgIGlmIChzY29wZS51aWRzW25hbWVdKSB7XG4gICAgICAgIHNjb3BlLnVpZHNbbmFtZV0gPSBmYWxzZTtcbiAgICAgIH1cbiAgICB9IHdoaWxlIChzY29wZSA9IHNjb3BlLnBhcmVudCk7XG4gIH1cbiAgaG9pc3RWYXJpYWJsZXMoZW1pdCA9IGlkID0+IHRoaXMucHVzaCh7XG4gICAgaWRcbiAgfSkpIHtcbiAgICB0aGlzLmNyYXdsKCk7XG4gICAgY29uc3Qgc2VlbiA9IG5ldyBTZXQoKTtcbiAgICBmb3IgKGNvbnN0IG5hbWUgb2YgT2JqZWN0LmtleXModGhpcy5iaW5kaW5ncykpIHtcbiAgICAgIGNvbnN0IGJpbmRpbmcgPSB0aGlzLmJpbmRpbmdzW25hbWVdO1xuICAgICAgaWYgKCFiaW5kaW5nKSBjb250aW51ZTtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgcGF0aFxuICAgICAgfSA9IGJpbmRpbmc7XG4gICAgICBpZiAoIXBhdGguaXNWYXJpYWJsZURlY2xhcmF0b3IoKSkgY29udGludWU7XG4gICAgICBjb25zdCB7XG4gICAgICAgIHBhcmVudCxcbiAgICAgICAgcGFyZW50UGF0aFxuICAgICAgfSA9IHBhdGg7XG4gICAgICBpZiAocGFyZW50LmtpbmQgIT09IFwidmFyXCIgfHwgc2Vlbi5oYXMocGFyZW50KSkgY29udGludWU7XG4gICAgICBzZWVuLmFkZChwYXRoLnBhcmVudCk7XG4gICAgICBsZXQgZmlyc3RJZDtcbiAgICAgIGNvbnN0IGluaXQgPSBbXTtcbiAgICAgIGZvciAoY29uc3QgZGVjbCBvZiBwYXJlbnQuZGVjbGFyYXRpb25zKSB7XG4gICAgICAgIGZpcnN0SWQgIT0gbnVsbCA/IGZpcnN0SWQgOiBmaXJzdElkID0gZGVjbC5pZDtcbiAgICAgICAgaWYgKGRlY2wuaW5pdCkge1xuICAgICAgICAgIGluaXQucHVzaChhc3NpZ25tZW50RXhwcmVzc2lvbihcIj1cIiwgZGVjbC5pZCwgZGVjbC5pbml0KSk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgaWRzID0gT2JqZWN0LmtleXMoZ2V0QmluZGluZ0lkZW50aWZpZXJzKGRlY2wsIGZhbHNlLCB0cnVlLCB0cnVlKSk7XG4gICAgICAgIGZvciAoY29uc3QgbmFtZSBvZiBpZHMpIHtcbiAgICAgICAgICBlbWl0KGlkZW50aWZpZXIobmFtZSksIGRlY2wuaW5pdCAhPSBudWxsKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKHBhcmVudFBhdGgucGFyZW50UGF0aC5pc0ZvclhTdGF0ZW1lbnQoe1xuICAgICAgICBsZWZ0OiBwYXJlbnRcbiAgICAgIH0pKSB7XG4gICAgICAgIHBhcmVudFBhdGgucmVwbGFjZVdpdGgoZmlyc3RJZCk7XG4gICAgICB9IGVsc2UgaWYgKGluaXQubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHBhcmVudFBhdGgucmVtb3ZlKCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zdCBleHByID0gaW5pdC5sZW5ndGggPT09IDEgPyBpbml0WzBdIDogc2VxdWVuY2VFeHByZXNzaW9uKGluaXQpO1xuICAgICAgICBpZiAocGFyZW50UGF0aC5wYXJlbnRQYXRoLmlzRm9yU3RhdGVtZW50KHtcbiAgICAgICAgICBpbml0OiBwYXJlbnRcbiAgICAgICAgfSkpIHtcbiAgICAgICAgICBwYXJlbnRQYXRoLnJlcGxhY2VXaXRoKGV4cHIpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHBhcmVudFBhdGgucmVwbGFjZVdpdGgoZXhwcmVzc2lvblN0YXRlbWVudChleHByKSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cbmV4cG9ydHMuZGVmYXVsdCA9IFNjb3BlO1xuU2NvcGUuZ2xvYmFscyA9IFsuLi5nbG9iYWxzQnVpbHRpbkxvd2VyLCAuLi5nbG9iYWxzQnVpbHRpblVwcGVyXTtcblNjb3BlLmNvbnRleHRWYXJpYWJsZXMgPSBbXCJhcmd1bWVudHNcIiwgXCJ1bmRlZmluZWRcIiwgXCJJbmZpbml0eVwiLCBcIk5hTlwiXTtcblNjb3BlLnByb3RvdHlwZS5fcmVuYW1lRnJvbU1hcCA9IGZ1bmN0aW9uIF9yZW5hbWVGcm9tTWFwKG1hcCwgb2xkTmFtZSwgbmV3TmFtZSwgdmFsdWUpIHtcbiAgaWYgKG1hcFtvbGROYW1lXSkge1xuICAgIG1hcFtuZXdOYW1lXSA9IHZhbHVlO1xuICAgIG1hcFtvbGROYW1lXSA9IG51bGw7XG4gIH1cbn07XG5TY29wZS5wcm90b3R5cGUudHJhdmVyc2UgPSBmdW5jdGlvbiAobm9kZSwgb3B0cywgc3RhdGUpIHtcbiAgKDAsIF9pbmRleC5kZWZhdWx0KShub2RlLCBvcHRzLCB0aGlzLCBzdGF0ZSwgdGhpcy5wYXRoKTtcbn07XG5TY29wZS5wcm90b3R5cGUuX2dlbmVyYXRlVWlkID0gZnVuY3Rpb24gX2dlbmVyYXRlVWlkKG5hbWUsIGkpIHtcbiAgbGV0IGlkID0gbmFtZTtcbiAgaWYgKGkgPiAxKSBpZCArPSBpO1xuICByZXR1cm4gYF8ke2lkfWA7XG59O1xuU2NvcGUucHJvdG90eXBlLnRvQXJyYXkgPSBmdW5jdGlvbiB0b0FycmF5KG5vZGUsIGksIGFycmF5TGlrZUlzSXRlcmFibGUpIHtcbiAgaWYgKGlzSWRlbnRpZmllcihub2RlKSkge1xuICAgIGNvbnN0IGJpbmRpbmcgPSB0aGlzLmdldEJpbmRpbmcobm9kZS5uYW1lKTtcbiAgICBpZiAoYmluZGluZyAhPSBudWxsICYmIGJpbmRpbmcuY29uc3RhbnQgJiYgYmluZGluZy5wYXRoLmlzR2VuZXJpY1R5cGUoXCJBcnJheVwiKSkge1xuICAgICAgcmV0dXJuIG5vZGU7XG4gICAgfVxuICB9XG4gIGlmIChpc0FycmF5RXhwcmVzc2lvbihub2RlKSkge1xuICAgIHJldHVybiBub2RlO1xuICB9XG4gIGlmIChpc0lkZW50aWZpZXIobm9kZSwge1xuICAgIG5hbWU6IFwiYXJndW1lbnRzXCJcbiAgfSkpIHtcbiAgICByZXR1cm4gY2FsbEV4cHJlc3Npb24obWVtYmVyRXhwcmVzc2lvbihtZW1iZXJFeHByZXNzaW9uKG1lbWJlckV4cHJlc3Npb24oaWRlbnRpZmllcihcIkFycmF5XCIpLCBpZGVudGlmaWVyKFwicHJvdG90eXBlXCIpKSwgaWRlbnRpZmllcihcInNsaWNlXCIpKSwgaWRlbnRpZmllcihcImNhbGxcIikpLCBbbm9kZV0pO1xuICB9XG4gIGxldCBoZWxwZXJOYW1lO1xuICBjb25zdCBhcmdzID0gW25vZGVdO1xuICBpZiAoaSA9PT0gdHJ1ZSkge1xuICAgIGhlbHBlck5hbWUgPSBcInRvQ29uc3VtYWJsZUFycmF5XCI7XG4gIH0gZWxzZSBpZiAodHlwZW9mIGkgPT09IFwibnVtYmVyXCIpIHtcbiAgICBhcmdzLnB1c2gobnVtZXJpY0xpdGVyYWwoaSkpO1xuICAgIGhlbHBlck5hbWUgPSBcInNsaWNlZFRvQXJyYXlcIjtcbiAgfSBlbHNlIHtcbiAgICBoZWxwZXJOYW1lID0gXCJ0b0FycmF5XCI7XG4gIH1cbiAgaWYgKGFycmF5TGlrZUlzSXRlcmFibGUpIHtcbiAgICBhcmdzLnVuc2hpZnQodGhpcy5wYXRoLmh1Yi5hZGRIZWxwZXIoaGVscGVyTmFtZSkpO1xuICAgIGhlbHBlck5hbWUgPSBcIm1heWJlQXJyYXlMaWtlXCI7XG4gIH1cbiAgcmV0dXJuIGNhbGxFeHByZXNzaW9uKHRoaXMucGF0aC5odWIuYWRkSGVscGVyKGhlbHBlck5hbWUpLCBhcmdzKTtcbn07XG5TY29wZS5wcm90b3R5cGUuZ2V0QWxsQmluZGluZ3NPZktpbmQgPSBmdW5jdGlvbiBnZXRBbGxCaW5kaW5nc09mS2luZCguLi5raW5kcykge1xuICBjb25zdCBpZHMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICBmb3IgKGNvbnN0IGtpbmQgb2Yga2luZHMpIHtcbiAgICBsZXQgc2NvcGUgPSB0aGlzO1xuICAgIGRvIHtcbiAgICAgIGZvciAoY29uc3QgbmFtZSBvZiBPYmplY3Qua2V5cyhzY29wZS5iaW5kaW5ncykpIHtcbiAgICAgICAgY29uc3QgYmluZGluZyA9IHNjb3BlLmJpbmRpbmdzW25hbWVdO1xuICAgICAgICBpZiAoYmluZGluZy5raW5kID09PSBraW5kKSBpZHNbbmFtZV0gPSBiaW5kaW5nO1xuICAgICAgfVxuICAgICAgc2NvcGUgPSBzY29wZS5wYXJlbnQ7XG4gICAgfSB3aGlsZSAoc2NvcGUpO1xuICB9XG4gIHJldHVybiBpZHM7XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoU2NvcGUucHJvdG90eXBlLCB7XG4gIHBhcmVudEJsb2NrOiB7XG4gICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgZ2V0KCkge1xuICAgICAgcmV0dXJuIHRoaXMucGF0aC5wYXJlbnQ7XG4gICAgfVxuICB9LFxuICBodWI6IHtcbiAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICBnZXQoKSB7XG4gICAgICByZXR1cm4gdGhpcy5wYXRoLmh1YjtcbiAgICB9XG4gIH1cbn0pO1xuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXBcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@babel/traverse/lib/scope/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@babel/traverse/lib/scope/lib/renamer.js":
/*!***************************************************************!*\
  !*** ./node_modules/@babel/traverse/lib/scope/lib/renamer.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports[\"default\"] = void 0;\nvar t = __webpack_require__(/*! @babel/types */ \"(ssr)/./node_modules/@babel/types/lib/index.js\");\nvar _t = t;\nvar _traverseNode = __webpack_require__(/*! ../../traverse-node.js */ \"(ssr)/./node_modules/@babel/traverse/lib/traverse-node.js\");\nvar _visitors = __webpack_require__(/*! ../../visitors.js */ \"(ssr)/./node_modules/@babel/traverse/lib/visitors.js\");\nvar _context = __webpack_require__(/*! ../../path/context.js */ \"(ssr)/./node_modules/@babel/traverse/lib/path/context.js\");\nconst {\n  getAssignmentIdentifiers\n} = _t;\nconst renameVisitor = {\n  ReferencedIdentifier({\n    node\n  }, state) {\n    if (node.name === state.oldName) {\n      node.name = state.newName;\n    }\n  },\n  Scope(path, state) {\n    if (!path.scope.bindingIdentifierEquals(state.oldName, state.binding.identifier)) {\n      path.skip();\n      if (path.isMethod()) {\n        if (!path.requeueComputedKeyAndDecorators) {\n          _context.requeueComputedKeyAndDecorators.call(path);\n        } else {\n          path.requeueComputedKeyAndDecorators();\n        }\n      }\n    }\n  },\n  ObjectProperty({\n    node,\n    scope\n  }, state) {\n    const {\n      name\n    } = node.key;\n    if (node.shorthand && (name === state.oldName || name === state.newName) && scope.getBindingIdentifier(name) === state.binding.identifier) {\n      var _node$extra;\n      node.shorthand = false;\n      if ((_node$extra = node.extra) != null && _node$extra.shorthand) node.extra.shorthand = false;\n    }\n  },\n  \"AssignmentExpression|Declaration|VariableDeclarator\"(path, state) {\n    if (path.isVariableDeclaration()) return;\n    const ids = path.isAssignmentExpression() ? getAssignmentIdentifiers(path.node) : path.getOuterBindingIdentifiers();\n    for (const name in ids) {\n      if (name === state.oldName) ids[name].name = state.newName;\n    }\n  }\n};\nclass Renamer {\n  constructor(binding, oldName, newName) {\n    this.newName = newName;\n    this.oldName = oldName;\n    this.binding = binding;\n  }\n  maybeConvertFromExportDeclaration(parentDeclar) {\n    const maybeExportDeclar = parentDeclar.parentPath;\n    if (!maybeExportDeclar.isExportDeclaration()) {\n      return;\n    }\n    if (maybeExportDeclar.isExportDefaultDeclaration()) {\n      const {\n        declaration\n      } = maybeExportDeclar.node;\n      if (t.isDeclaration(declaration) && !declaration.id) {\n        return;\n      }\n    }\n    if (maybeExportDeclar.isExportAllDeclaration()) {\n      return;\n    }\n    maybeExportDeclar.splitExportDeclaration();\n  }\n  maybeConvertFromClassFunctionDeclaration(path) {\n    return path;\n  }\n  maybeConvertFromClassFunctionExpression(path) {\n    return path;\n  }\n  rename() {\n    const {\n      binding,\n      oldName,\n      newName\n    } = this;\n    const {\n      scope,\n      path\n    } = binding;\n    const parentDeclar = path.find(path => path.isDeclaration() || path.isFunctionExpression() || path.isClassExpression());\n    if (parentDeclar) {\n      const bindingIds = parentDeclar.getOuterBindingIdentifiers();\n      if (bindingIds[oldName] === binding.identifier) {\n        this.maybeConvertFromExportDeclaration(parentDeclar);\n      }\n    }\n    const blockToTraverse = arguments[0] || scope.block;\n    const skipKeys = {\n      discriminant: true\n    };\n    if (t.isMethod(blockToTraverse)) {\n      if (blockToTraverse.computed) {\n        skipKeys.key = true;\n      }\n      if (!t.isObjectMethod(blockToTraverse)) {\n        skipKeys.decorators = true;\n      }\n    }\n    (0, _traverseNode.traverseNode)(blockToTraverse, (0, _visitors.explode)(renameVisitor), scope, this, scope.path, skipKeys);\n    if (!arguments[0]) {\n      scope.removeOwnBinding(oldName);\n      scope.bindings[newName] = binding;\n      this.binding.identifier.name = newName;\n    }\n    if (parentDeclar) {\n      this.maybeConvertFromClassFunctionDeclaration(path);\n      this.maybeConvertFromClassFunctionExpression(path);\n    }\n  }\n}\nexports[\"default\"] = Renamer;\n\n//# sourceMappingURL=renamer.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGJhYmVsL3RyYXZlcnNlL2xpYi9zY29wZS9saWIvcmVuYW1lci5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYiw4Q0FBNkM7QUFDN0M7QUFDQSxDQUFDLEVBQUM7QUFDRixrQkFBZTtBQUNmLFFBQVEsbUJBQU8sQ0FBQyxvRUFBYztBQUM5QjtBQUNBLG9CQUFvQixtQkFBTyxDQUFDLHlGQUF3QjtBQUNwRCxnQkFBZ0IsbUJBQU8sQ0FBQywrRUFBbUI7QUFDM0MsZUFBZSxtQkFBTyxDQUFDLHVGQUF1QjtBQUM5QztBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBZTs7QUFFZiIsInNvdXJjZXMiOlsid2VicGFjazovL3JlcG8tdmlzdWFsaXplci8uL25vZGVfbW9kdWxlcy9AYmFiZWwvdHJhdmVyc2UvbGliL3Njb3BlL2xpYi9yZW5hbWVyLmpzPzU0ZWUiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLmRlZmF1bHQgPSB2b2lkIDA7XG52YXIgdCA9IHJlcXVpcmUoXCJAYmFiZWwvdHlwZXNcIik7XG52YXIgX3QgPSB0O1xudmFyIF90cmF2ZXJzZU5vZGUgPSByZXF1aXJlKFwiLi4vLi4vdHJhdmVyc2Utbm9kZS5qc1wiKTtcbnZhciBfdmlzaXRvcnMgPSByZXF1aXJlKFwiLi4vLi4vdmlzaXRvcnMuanNcIik7XG52YXIgX2NvbnRleHQgPSByZXF1aXJlKFwiLi4vLi4vcGF0aC9jb250ZXh0LmpzXCIpO1xuY29uc3Qge1xuICBnZXRBc3NpZ25tZW50SWRlbnRpZmllcnNcbn0gPSBfdDtcbmNvbnN0IHJlbmFtZVZpc2l0b3IgPSB7XG4gIFJlZmVyZW5jZWRJZGVudGlmaWVyKHtcbiAgICBub2RlXG4gIH0sIHN0YXRlKSB7XG4gICAgaWYgKG5vZGUubmFtZSA9PT0gc3RhdGUub2xkTmFtZSkge1xuICAgICAgbm9kZS5uYW1lID0gc3RhdGUubmV3TmFtZTtcbiAgICB9XG4gIH0sXG4gIFNjb3BlKHBhdGgsIHN0YXRlKSB7XG4gICAgaWYgKCFwYXRoLnNjb3BlLmJpbmRpbmdJZGVudGlmaWVyRXF1YWxzKHN0YXRlLm9sZE5hbWUsIHN0YXRlLmJpbmRpbmcuaWRlbnRpZmllcikpIHtcbiAgICAgIHBhdGguc2tpcCgpO1xuICAgICAgaWYgKHBhdGguaXNNZXRob2QoKSkge1xuICAgICAgICBpZiAoIXBhdGgucmVxdWV1ZUNvbXB1dGVkS2V5QW5kRGVjb3JhdG9ycykge1xuICAgICAgICAgIF9jb250ZXh0LnJlcXVldWVDb21wdXRlZEtleUFuZERlY29yYXRvcnMuY2FsbChwYXRoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBwYXRoLnJlcXVldWVDb21wdXRlZEtleUFuZERlY29yYXRvcnMoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfSxcbiAgT2JqZWN0UHJvcGVydHkoe1xuICAgIG5vZGUsXG4gICAgc2NvcGVcbiAgfSwgc3RhdGUpIHtcbiAgICBjb25zdCB7XG4gICAgICBuYW1lXG4gICAgfSA9IG5vZGUua2V5O1xuICAgIGlmIChub2RlLnNob3J0aGFuZCAmJiAobmFtZSA9PT0gc3RhdGUub2xkTmFtZSB8fCBuYW1lID09PSBzdGF0ZS5uZXdOYW1lKSAmJiBzY29wZS5nZXRCaW5kaW5nSWRlbnRpZmllcihuYW1lKSA9PT0gc3RhdGUuYmluZGluZy5pZGVudGlmaWVyKSB7XG4gICAgICB2YXIgX25vZGUkZXh0cmE7XG4gICAgICBub2RlLnNob3J0aGFuZCA9IGZhbHNlO1xuICAgICAgaWYgKChfbm9kZSRleHRyYSA9IG5vZGUuZXh0cmEpICE9IG51bGwgJiYgX25vZGUkZXh0cmEuc2hvcnRoYW5kKSBub2RlLmV4dHJhLnNob3J0aGFuZCA9IGZhbHNlO1xuICAgIH1cbiAgfSxcbiAgXCJBc3NpZ25tZW50RXhwcmVzc2lvbnxEZWNsYXJhdGlvbnxWYXJpYWJsZURlY2xhcmF0b3JcIihwYXRoLCBzdGF0ZSkge1xuICAgIGlmIChwYXRoLmlzVmFyaWFibGVEZWNsYXJhdGlvbigpKSByZXR1cm47XG4gICAgY29uc3QgaWRzID0gcGF0aC5pc0Fzc2lnbm1lbnRFeHByZXNzaW9uKCkgPyBnZXRBc3NpZ25tZW50SWRlbnRpZmllcnMocGF0aC5ub2RlKSA6IHBhdGguZ2V0T3V0ZXJCaW5kaW5nSWRlbnRpZmllcnMoKTtcbiAgICBmb3IgKGNvbnN0IG5hbWUgaW4gaWRzKSB7XG4gICAgICBpZiAobmFtZSA9PT0gc3RhdGUub2xkTmFtZSkgaWRzW25hbWVdLm5hbWUgPSBzdGF0ZS5uZXdOYW1lO1xuICAgIH1cbiAgfVxufTtcbmNsYXNzIFJlbmFtZXIge1xuICBjb25zdHJ1Y3RvcihiaW5kaW5nLCBvbGROYW1lLCBuZXdOYW1lKSB7XG4gICAgdGhpcy5uZXdOYW1lID0gbmV3TmFtZTtcbiAgICB0aGlzLm9sZE5hbWUgPSBvbGROYW1lO1xuICAgIHRoaXMuYmluZGluZyA9IGJpbmRpbmc7XG4gIH1cbiAgbWF5YmVDb252ZXJ0RnJvbUV4cG9ydERlY2xhcmF0aW9uKHBhcmVudERlY2xhcikge1xuICAgIGNvbnN0IG1heWJlRXhwb3J0RGVjbGFyID0gcGFyZW50RGVjbGFyLnBhcmVudFBhdGg7XG4gICAgaWYgKCFtYXliZUV4cG9ydERlY2xhci5pc0V4cG9ydERlY2xhcmF0aW9uKCkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKG1heWJlRXhwb3J0RGVjbGFyLmlzRXhwb3J0RGVmYXVsdERlY2xhcmF0aW9uKCkpIHtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgZGVjbGFyYXRpb25cbiAgICAgIH0gPSBtYXliZUV4cG9ydERlY2xhci5ub2RlO1xuICAgICAgaWYgKHQuaXNEZWNsYXJhdGlvbihkZWNsYXJhdGlvbikgJiYgIWRlY2xhcmF0aW9uLmlkKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKG1heWJlRXhwb3J0RGVjbGFyLmlzRXhwb3J0QWxsRGVjbGFyYXRpb24oKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBtYXliZUV4cG9ydERlY2xhci5zcGxpdEV4cG9ydERlY2xhcmF0aW9uKCk7XG4gIH1cbiAgbWF5YmVDb252ZXJ0RnJvbUNsYXNzRnVuY3Rpb25EZWNsYXJhdGlvbihwYXRoKSB7XG4gICAgcmV0dXJuIHBhdGg7XG4gIH1cbiAgbWF5YmVDb252ZXJ0RnJvbUNsYXNzRnVuY3Rpb25FeHByZXNzaW9uKHBhdGgpIHtcbiAgICByZXR1cm4gcGF0aDtcbiAgfVxuICByZW5hbWUoKSB7XG4gICAgY29uc3Qge1xuICAgICAgYmluZGluZyxcbiAgICAgIG9sZE5hbWUsXG4gICAgICBuZXdOYW1lXG4gICAgfSA9IHRoaXM7XG4gICAgY29uc3Qge1xuICAgICAgc2NvcGUsXG4gICAgICBwYXRoXG4gICAgfSA9IGJpbmRpbmc7XG4gICAgY29uc3QgcGFyZW50RGVjbGFyID0gcGF0aC5maW5kKHBhdGggPT4gcGF0aC5pc0RlY2xhcmF0aW9uKCkgfHwgcGF0aC5pc0Z1bmN0aW9uRXhwcmVzc2lvbigpIHx8IHBhdGguaXNDbGFzc0V4cHJlc3Npb24oKSk7XG4gICAgaWYgKHBhcmVudERlY2xhcikge1xuICAgICAgY29uc3QgYmluZGluZ0lkcyA9IHBhcmVudERlY2xhci5nZXRPdXRlckJpbmRpbmdJZGVudGlmaWVycygpO1xuICAgICAgaWYgKGJpbmRpbmdJZHNbb2xkTmFtZV0gPT09IGJpbmRpbmcuaWRlbnRpZmllcikge1xuICAgICAgICB0aGlzLm1heWJlQ29udmVydEZyb21FeHBvcnREZWNsYXJhdGlvbihwYXJlbnREZWNsYXIpO1xuICAgICAgfVxuICAgIH1cbiAgICBjb25zdCBibG9ja1RvVHJhdmVyc2UgPSBhcmd1bWVudHNbMF0gfHwgc2NvcGUuYmxvY2s7XG4gICAgY29uc3Qgc2tpcEtleXMgPSB7XG4gICAgICBkaXNjcmltaW5hbnQ6IHRydWVcbiAgICB9O1xuICAgIGlmICh0LmlzTWV0aG9kKGJsb2NrVG9UcmF2ZXJzZSkpIHtcbiAgICAgIGlmIChibG9ja1RvVHJhdmVyc2UuY29tcHV0ZWQpIHtcbiAgICAgICAgc2tpcEtleXMua2V5ID0gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIGlmICghdC5pc09iamVjdE1ldGhvZChibG9ja1RvVHJhdmVyc2UpKSB7XG4gICAgICAgIHNraXBLZXlzLmRlY29yYXRvcnMgPSB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgICAoMCwgX3RyYXZlcnNlTm9kZS50cmF2ZXJzZU5vZGUpKGJsb2NrVG9UcmF2ZXJzZSwgKDAsIF92aXNpdG9ycy5leHBsb2RlKShyZW5hbWVWaXNpdG9yKSwgc2NvcGUsIHRoaXMsIHNjb3BlLnBhdGgsIHNraXBLZXlzKTtcbiAgICBpZiAoIWFyZ3VtZW50c1swXSkge1xuICAgICAgc2NvcGUucmVtb3ZlT3duQmluZGluZyhvbGROYW1lKTtcbiAgICAgIHNjb3BlLmJpbmRpbmdzW25ld05hbWVdID0gYmluZGluZztcbiAgICAgIHRoaXMuYmluZGluZy5pZGVudGlmaWVyLm5hbWUgPSBuZXdOYW1lO1xuICAgIH1cbiAgICBpZiAocGFyZW50RGVjbGFyKSB7XG4gICAgICB0aGlzLm1heWJlQ29udmVydEZyb21DbGFzc0Z1bmN0aW9uRGVjbGFyYXRpb24ocGF0aCk7XG4gICAgICB0aGlzLm1heWJlQ29udmVydEZyb21DbGFzc0Z1bmN0aW9uRXhwcmVzc2lvbihwYXRoKTtcbiAgICB9XG4gIH1cbn1cbmV4cG9ydHMuZGVmYXVsdCA9IFJlbmFtZXI7XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXJlbmFtZXIuanMubWFwXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@babel/traverse/lib/scope/lib/renamer.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@babel/traverse/lib/scope/traverseForScope.js":
/*!********************************************************************!*\
  !*** ./node_modules/@babel/traverse/lib/scope/traverseForScope.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports[\"default\"] = traverseForScope;\nvar _t = __webpack_require__(/*! @babel/types */ \"(ssr)/./node_modules/@babel/types/lib/index.js\");\nvar _index = __webpack_require__(/*! ../index.js */ \"(ssr)/./node_modules/@babel/traverse/lib/index.js\");\nvar _visitors = __webpack_require__(/*! ../visitors.js */ \"(ssr)/./node_modules/@babel/traverse/lib/visitors.js\");\nvar _context = __webpack_require__(/*! ../path/context.js */ \"(ssr)/./node_modules/@babel/traverse/lib/path/context.js\");\nconst {\n  VISITOR_KEYS\n} = _t;\nfunction traverseForScope(path, visitors, state) {\n  const exploded = (0, _visitors.explode)(visitors);\n  if (exploded.enter || exploded.exit) {\n    throw new Error(\"Should not be used with enter/exit visitors.\");\n  }\n  _traverse(path.parentPath, path.parent, path.node, path.container, path.key, path.listKey, path.hub, path);\n  function _traverse(parentPath, parent, node, container, key, listKey, hub, inPath) {\n    if (!node) {\n      return;\n    }\n    const path = inPath || _index.NodePath.get({\n      hub,\n      parentPath,\n      parent,\n      container,\n      listKey,\n      key\n    });\n    _context._forceSetScope.call(path);\n    const visitor = exploded[node.type];\n    if (visitor != null && visitor.enter) {\n      for (const visit of visitor.enter) {\n        visit.call(state, path, state);\n      }\n    }\n    if (path.shouldSkip) {\n      return;\n    }\n    const keys = VISITOR_KEYS[node.type];\n    if (!(keys != null && keys.length)) {\n      return;\n    }\n    for (const key of keys) {\n      const prop = node[key];\n      if (!prop) continue;\n      if (Array.isArray(prop)) {\n        for (let i = 0; i < prop.length; i++) {\n          const value = prop[i];\n          _traverse(path, node, value, prop, i, key);\n        }\n      } else {\n        _traverse(path, node, prop, node, key, null);\n      }\n    }\n    if (visitor != null && visitor.exit) {\n      for (const visit of visitor.exit) {\n        visit.call(state, path, state);\n      }\n    }\n  }\n}\n\n//# sourceMappingURL=traverseForScope.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGJhYmVsL3RyYXZlcnNlL2xpYi9zY29wZS90cmF2ZXJzZUZvclNjb3BlLmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViLDhDQUE2QztBQUM3QztBQUNBLENBQUMsRUFBQztBQUNGLGtCQUFlO0FBQ2YsU0FBUyxtQkFBTyxDQUFDLG9FQUFjO0FBQy9CLGFBQWEsbUJBQU8sQ0FBQyxzRUFBYTtBQUNsQyxnQkFBZ0IsbUJBQU8sQ0FBQyw0RUFBZ0I7QUFDeEMsZUFBZSxtQkFBTyxDQUFDLG9GQUFvQjtBQUMzQztBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLGlCQUFpQjtBQUN6QztBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9yZXBvLXZpc3VhbGl6ZXIvLi9ub2RlX21vZHVsZXMvQGJhYmVsL3RyYXZlcnNlL2xpYi9zY29wZS90cmF2ZXJzZUZvclNjb3BlLmpzPzU3ZmYiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLmRlZmF1bHQgPSB0cmF2ZXJzZUZvclNjb3BlO1xudmFyIF90ID0gcmVxdWlyZShcIkBiYWJlbC90eXBlc1wiKTtcbnZhciBfaW5kZXggPSByZXF1aXJlKFwiLi4vaW5kZXguanNcIik7XG52YXIgX3Zpc2l0b3JzID0gcmVxdWlyZShcIi4uL3Zpc2l0b3JzLmpzXCIpO1xudmFyIF9jb250ZXh0ID0gcmVxdWlyZShcIi4uL3BhdGgvY29udGV4dC5qc1wiKTtcbmNvbnN0IHtcbiAgVklTSVRPUl9LRVlTXG59ID0gX3Q7XG5mdW5jdGlvbiB0cmF2ZXJzZUZvclNjb3BlKHBhdGgsIHZpc2l0b3JzLCBzdGF0ZSkge1xuICBjb25zdCBleHBsb2RlZCA9ICgwLCBfdmlzaXRvcnMuZXhwbG9kZSkodmlzaXRvcnMpO1xuICBpZiAoZXhwbG9kZWQuZW50ZXIgfHwgZXhwbG9kZWQuZXhpdCkge1xuICAgIHRocm93IG5ldyBFcnJvcihcIlNob3VsZCBub3QgYmUgdXNlZCB3aXRoIGVudGVyL2V4aXQgdmlzaXRvcnMuXCIpO1xuICB9XG4gIF90cmF2ZXJzZShwYXRoLnBhcmVudFBhdGgsIHBhdGgucGFyZW50LCBwYXRoLm5vZGUsIHBhdGguY29udGFpbmVyLCBwYXRoLmtleSwgcGF0aC5saXN0S2V5LCBwYXRoLmh1YiwgcGF0aCk7XG4gIGZ1bmN0aW9uIF90cmF2ZXJzZShwYXJlbnRQYXRoLCBwYXJlbnQsIG5vZGUsIGNvbnRhaW5lciwga2V5LCBsaXN0S2V5LCBodWIsIGluUGF0aCkge1xuICAgIGlmICghbm9kZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBwYXRoID0gaW5QYXRoIHx8IF9pbmRleC5Ob2RlUGF0aC5nZXQoe1xuICAgICAgaHViLFxuICAgICAgcGFyZW50UGF0aCxcbiAgICAgIHBhcmVudCxcbiAgICAgIGNvbnRhaW5lcixcbiAgICAgIGxpc3RLZXksXG4gICAgICBrZXlcbiAgICB9KTtcbiAgICBfY29udGV4dC5fZm9yY2VTZXRTY29wZS5jYWxsKHBhdGgpO1xuICAgIGNvbnN0IHZpc2l0b3IgPSBleHBsb2RlZFtub2RlLnR5cGVdO1xuICAgIGlmICh2aXNpdG9yICE9IG51bGwgJiYgdmlzaXRvci5lbnRlcikge1xuICAgICAgZm9yIChjb25zdCB2aXNpdCBvZiB2aXNpdG9yLmVudGVyKSB7XG4gICAgICAgIHZpc2l0LmNhbGwoc3RhdGUsIHBhdGgsIHN0YXRlKTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHBhdGguc2hvdWxkU2tpcCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBrZXlzID0gVklTSVRPUl9LRVlTW25vZGUudHlwZV07XG4gICAgaWYgKCEoa2V5cyAhPSBudWxsICYmIGtleXMubGVuZ3RoKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBmb3IgKGNvbnN0IGtleSBvZiBrZXlzKSB7XG4gICAgICBjb25zdCBwcm9wID0gbm9kZVtrZXldO1xuICAgICAgaWYgKCFwcm9wKSBjb250aW51ZTtcbiAgICAgIGlmIChBcnJheS5pc0FycmF5KHByb3ApKSB7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcHJvcC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIGNvbnN0IHZhbHVlID0gcHJvcFtpXTtcbiAgICAgICAgICBfdHJhdmVyc2UocGF0aCwgbm9kZSwgdmFsdWUsIHByb3AsIGksIGtleSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIF90cmF2ZXJzZShwYXRoLCBub2RlLCBwcm9wLCBub2RlLCBrZXksIG51bGwpO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAodmlzaXRvciAhPSBudWxsICYmIHZpc2l0b3IuZXhpdCkge1xuICAgICAgZm9yIChjb25zdCB2aXNpdCBvZiB2aXNpdG9yLmV4aXQpIHtcbiAgICAgICAgdmlzaXQuY2FsbChzdGF0ZSwgcGF0aCwgc3RhdGUpO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG4vLyMgc291cmNlTWFwcGluZ1VSTD10cmF2ZXJzZUZvclNjb3BlLmpzLm1hcFxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@babel/traverse/lib/scope/traverseForScope.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@babel/traverse/lib/traverse-node.js":
/*!***********************************************************!*\
  !*** ./node_modules/@babel/traverse/lib/traverse-node.js ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports.traverseNode = traverseNode;\nvar _context = __webpack_require__(/*! ./context.js */ \"(ssr)/./node_modules/@babel/traverse/lib/context.js\");\nvar _index = __webpack_require__(/*! ./path/index.js */ \"(ssr)/./node_modules/@babel/traverse/lib/path/index.js\");\nvar _t = __webpack_require__(/*! @babel/types */ \"(ssr)/./node_modules/@babel/types/lib/index.js\");\nvar _context2 = __webpack_require__(/*! ./path/context.js */ \"(ssr)/./node_modules/@babel/traverse/lib/path/context.js\");\nconst {\n  VISITOR_KEYS\n} = _t;\nfunction _visitPaths(ctx, paths) {\n  ctx.queue = paths;\n  ctx.priorityQueue = [];\n  const visited = new Set();\n  let stop = false;\n  let visitIndex = 0;\n  for (; visitIndex < paths.length;) {\n    const path = paths[visitIndex];\n    visitIndex++;\n    _context2.resync.call(path);\n    if (path.contexts.length === 0 || path.contexts[path.contexts.length - 1] !== ctx) {\n      _context2.pushContext.call(path, ctx);\n    }\n    if (path.key === null) continue;\n    const {\n      node\n    } = path;\n    if (visited.has(node)) continue;\n    if (node) visited.add(node);\n    if (_visit(ctx, path)) {\n      stop = true;\n      break;\n    }\n    if (ctx.priorityQueue.length) {\n      stop = _visitPaths(ctx, ctx.priorityQueue);\n      ctx.priorityQueue = [];\n      ctx.queue = paths;\n      if (stop) break;\n    }\n  }\n  for (let i = 0; i < visitIndex; i++) {\n    _context2.popContext.call(paths[i]);\n  }\n  ctx.queue = null;\n  return stop;\n}\nfunction _visit(ctx, path) {\n  var _opts$denylist;\n  const node = path.node;\n  if (!node) {\n    return false;\n  }\n  const opts = ctx.opts;\n  const denylist = (_opts$denylist = opts.denylist) != null ? _opts$denylist : opts.blacklist;\n  if (denylist != null && denylist.includes(node.type)) {\n    return false;\n  }\n  if (opts.shouldSkip != null && opts.shouldSkip(path)) {\n    return false;\n  }\n  if (path.shouldSkip) return path.shouldStop;\n  if (_context2._call.call(path, opts.enter)) return path.shouldStop;\n  if (path.node) {\n    var _opts$node$type;\n    if (_context2._call.call(path, (_opts$node$type = opts[node.type]) == null ? void 0 : _opts$node$type.enter)) return path.shouldStop;\n  }\n  path.shouldStop = _traverse(path.node, opts, path.scope, ctx.state, path, path.skipKeys);\n  if (path.node) {\n    if (_context2._call.call(path, opts.exit)) return true;\n  }\n  if (path.node) {\n    var _opts$node$type2;\n    _context2._call.call(path, (_opts$node$type2 = opts[node.type]) == null ? void 0 : _opts$node$type2.exit);\n  }\n  return path.shouldStop;\n}\nfunction _traverse(node, opts, scope, state, path, skipKeys, visitSelf) {\n  const keys = VISITOR_KEYS[node.type];\n  if (!(keys != null && keys.length)) return false;\n  const ctx = new _context.default(scope, opts, state, path);\n  if (visitSelf) {\n    if (skipKeys != null && skipKeys[path.parentKey]) return false;\n    return _visitPaths(ctx, [path]);\n  }\n  for (const key of keys) {\n    if (skipKeys != null && skipKeys[key]) continue;\n    const prop = node[key];\n    if (!prop) continue;\n    if (Array.isArray(prop)) {\n      if (!prop.length) continue;\n      const paths = [];\n      for (let i = 0; i < prop.length; i++) {\n        const childPath = _index.default.get({\n          parentPath: path,\n          parent: node,\n          container: prop,\n          key: i,\n          listKey: key\n        });\n        paths.push(childPath);\n      }\n      if (_visitPaths(ctx, paths)) return true;\n    } else {\n      if (_visitPaths(ctx, [_index.default.get({\n        parentPath: path,\n        parent: node,\n        container: node,\n        key,\n        listKey: null\n      })])) {\n        return true;\n      }\n    }\n  }\n  return false;\n}\nfunction traverseNode(node, opts, scope, state, path, skipKeys, visitSelf) {\n  const keys = VISITOR_KEYS[node.type];\n  if (!keys) return false;\n  const context = new _context.default(scope, opts, state, path);\n  if (visitSelf) {\n    if (skipKeys != null && skipKeys[path.parentKey]) return false;\n    return context.visitQueue([path]);\n  }\n  for (const key of keys) {\n    if (skipKeys != null && skipKeys[key]) continue;\n    if (context.visit(node, key)) {\n      return true;\n    }\n  }\n  return false;\n}\n\n//# sourceMappingURL=traverse-node.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGJhYmVsL3RyYXZlcnNlL2xpYi90cmF2ZXJzZS1ub2RlLmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViLDhDQUE2QztBQUM3QztBQUNBLENBQUMsRUFBQztBQUNGLG9CQUFvQjtBQUNwQixlQUFlLG1CQUFPLENBQUMseUVBQWM7QUFDckMsYUFBYSxtQkFBTyxDQUFDLCtFQUFpQjtBQUN0QyxTQUFTLG1CQUFPLENBQUMsb0VBQWM7QUFDL0IsZ0JBQWdCLG1CQUFPLENBQUMsbUZBQW1CO0FBQzNDO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUywwQkFBMEI7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLGdCQUFnQjtBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLGlCQUFpQjtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSIsInNvdXJjZXMiOlsid2VicGFjazovL3JlcG8tdmlzdWFsaXplci8uL25vZGVfbW9kdWxlcy9AYmFiZWwvdHJhdmVyc2UvbGliL3RyYXZlcnNlLW5vZGUuanM/MjRkNSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMudHJhdmVyc2VOb2RlID0gdHJhdmVyc2VOb2RlO1xudmFyIF9jb250ZXh0ID0gcmVxdWlyZShcIi4vY29udGV4dC5qc1wiKTtcbnZhciBfaW5kZXggPSByZXF1aXJlKFwiLi9wYXRoL2luZGV4LmpzXCIpO1xudmFyIF90ID0gcmVxdWlyZShcIkBiYWJlbC90eXBlc1wiKTtcbnZhciBfY29udGV4dDIgPSByZXF1aXJlKFwiLi9wYXRoL2NvbnRleHQuanNcIik7XG5jb25zdCB7XG4gIFZJU0lUT1JfS0VZU1xufSA9IF90O1xuZnVuY3Rpb24gX3Zpc2l0UGF0aHMoY3R4LCBwYXRocykge1xuICBjdHgucXVldWUgPSBwYXRocztcbiAgY3R4LnByaW9yaXR5UXVldWUgPSBbXTtcbiAgY29uc3QgdmlzaXRlZCA9IG5ldyBTZXQoKTtcbiAgbGV0IHN0b3AgPSBmYWxzZTtcbiAgbGV0IHZpc2l0SW5kZXggPSAwO1xuICBmb3IgKDsgdmlzaXRJbmRleCA8IHBhdGhzLmxlbmd0aDspIHtcbiAgICBjb25zdCBwYXRoID0gcGF0aHNbdmlzaXRJbmRleF07XG4gICAgdmlzaXRJbmRleCsrO1xuICAgIF9jb250ZXh0Mi5yZXN5bmMuY2FsbChwYXRoKTtcbiAgICBpZiAocGF0aC5jb250ZXh0cy5sZW5ndGggPT09IDAgfHwgcGF0aC5jb250ZXh0c1twYXRoLmNvbnRleHRzLmxlbmd0aCAtIDFdICE9PSBjdHgpIHtcbiAgICAgIF9jb250ZXh0Mi5wdXNoQ29udGV4dC5jYWxsKHBhdGgsIGN0eCk7XG4gICAgfVxuICAgIGlmIChwYXRoLmtleSA9PT0gbnVsbCkgY29udGludWU7XG4gICAgY29uc3Qge1xuICAgICAgbm9kZVxuICAgIH0gPSBwYXRoO1xuICAgIGlmICh2aXNpdGVkLmhhcyhub2RlKSkgY29udGludWU7XG4gICAgaWYgKG5vZGUpIHZpc2l0ZWQuYWRkKG5vZGUpO1xuICAgIGlmIChfdmlzaXQoY3R4LCBwYXRoKSkge1xuICAgICAgc3RvcCA9IHRydWU7XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgaWYgKGN0eC5wcmlvcml0eVF1ZXVlLmxlbmd0aCkge1xuICAgICAgc3RvcCA9IF92aXNpdFBhdGhzKGN0eCwgY3R4LnByaW9yaXR5UXVldWUpO1xuICAgICAgY3R4LnByaW9yaXR5UXVldWUgPSBbXTtcbiAgICAgIGN0eC5xdWV1ZSA9IHBhdGhzO1xuICAgICAgaWYgKHN0b3ApIGJyZWFrO1xuICAgIH1cbiAgfVxuICBmb3IgKGxldCBpID0gMDsgaSA8IHZpc2l0SW5kZXg7IGkrKykge1xuICAgIF9jb250ZXh0Mi5wb3BDb250ZXh0LmNhbGwocGF0aHNbaV0pO1xuICB9XG4gIGN0eC5xdWV1ZSA9IG51bGw7XG4gIHJldHVybiBzdG9wO1xufVxuZnVuY3Rpb24gX3Zpc2l0KGN0eCwgcGF0aCkge1xuICB2YXIgX29wdHMkZGVueWxpc3Q7XG4gIGNvbnN0IG5vZGUgPSBwYXRoLm5vZGU7XG4gIGlmICghbm9kZSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBjb25zdCBvcHRzID0gY3R4Lm9wdHM7XG4gIGNvbnN0IGRlbnlsaXN0ID0gKF9vcHRzJGRlbnlsaXN0ID0gb3B0cy5kZW55bGlzdCkgIT0gbnVsbCA/IF9vcHRzJGRlbnlsaXN0IDogb3B0cy5ibGFja2xpc3Q7XG4gIGlmIChkZW55bGlzdCAhPSBudWxsICYmIGRlbnlsaXN0LmluY2x1ZGVzKG5vZGUudHlwZSkpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgaWYgKG9wdHMuc2hvdWxkU2tpcCAhPSBudWxsICYmIG9wdHMuc2hvdWxkU2tpcChwYXRoKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBpZiAocGF0aC5zaG91bGRTa2lwKSByZXR1cm4gcGF0aC5zaG91bGRTdG9wO1xuICBpZiAoX2NvbnRleHQyLl9jYWxsLmNhbGwocGF0aCwgb3B0cy5lbnRlcikpIHJldHVybiBwYXRoLnNob3VsZFN0b3A7XG4gIGlmIChwYXRoLm5vZGUpIHtcbiAgICB2YXIgX29wdHMkbm9kZSR0eXBlO1xuICAgIGlmIChfY29udGV4dDIuX2NhbGwuY2FsbChwYXRoLCAoX29wdHMkbm9kZSR0eXBlID0gb3B0c1tub2RlLnR5cGVdKSA9PSBudWxsID8gdm9pZCAwIDogX29wdHMkbm9kZSR0eXBlLmVudGVyKSkgcmV0dXJuIHBhdGguc2hvdWxkU3RvcDtcbiAgfVxuICBwYXRoLnNob3VsZFN0b3AgPSBfdHJhdmVyc2UocGF0aC5ub2RlLCBvcHRzLCBwYXRoLnNjb3BlLCBjdHguc3RhdGUsIHBhdGgsIHBhdGguc2tpcEtleXMpO1xuICBpZiAocGF0aC5ub2RlKSB7XG4gICAgaWYgKF9jb250ZXh0Mi5fY2FsbC5jYWxsKHBhdGgsIG9wdHMuZXhpdCkpIHJldHVybiB0cnVlO1xuICB9XG4gIGlmIChwYXRoLm5vZGUpIHtcbiAgICB2YXIgX29wdHMkbm9kZSR0eXBlMjtcbiAgICBfY29udGV4dDIuX2NhbGwuY2FsbChwYXRoLCAoX29wdHMkbm9kZSR0eXBlMiA9IG9wdHNbbm9kZS50eXBlXSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9vcHRzJG5vZGUkdHlwZTIuZXhpdCk7XG4gIH1cbiAgcmV0dXJuIHBhdGguc2hvdWxkU3RvcDtcbn1cbmZ1bmN0aW9uIF90cmF2ZXJzZShub2RlLCBvcHRzLCBzY29wZSwgc3RhdGUsIHBhdGgsIHNraXBLZXlzLCB2aXNpdFNlbGYpIHtcbiAgY29uc3Qga2V5cyA9IFZJU0lUT1JfS0VZU1tub2RlLnR5cGVdO1xuICBpZiAoIShrZXlzICE9IG51bGwgJiYga2V5cy5sZW5ndGgpKSByZXR1cm4gZmFsc2U7XG4gIGNvbnN0IGN0eCA9IG5ldyBfY29udGV4dC5kZWZhdWx0KHNjb3BlLCBvcHRzLCBzdGF0ZSwgcGF0aCk7XG4gIGlmICh2aXNpdFNlbGYpIHtcbiAgICBpZiAoc2tpcEtleXMgIT0gbnVsbCAmJiBza2lwS2V5c1twYXRoLnBhcmVudEtleV0pIHJldHVybiBmYWxzZTtcbiAgICByZXR1cm4gX3Zpc2l0UGF0aHMoY3R4LCBbcGF0aF0pO1xuICB9XG4gIGZvciAoY29uc3Qga2V5IG9mIGtleXMpIHtcbiAgICBpZiAoc2tpcEtleXMgIT0gbnVsbCAmJiBza2lwS2V5c1trZXldKSBjb250aW51ZTtcbiAgICBjb25zdCBwcm9wID0gbm9kZVtrZXldO1xuICAgIGlmICghcHJvcCkgY29udGludWU7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkocHJvcCkpIHtcbiAgICAgIGlmICghcHJvcC5sZW5ndGgpIGNvbnRpbnVlO1xuICAgICAgY29uc3QgcGF0aHMgPSBbXTtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcHJvcC5sZW5ndGg7IGkrKykge1xuICAgICAgICBjb25zdCBjaGlsZFBhdGggPSBfaW5kZXguZGVmYXVsdC5nZXQoe1xuICAgICAgICAgIHBhcmVudFBhdGg6IHBhdGgsXG4gICAgICAgICAgcGFyZW50OiBub2RlLFxuICAgICAgICAgIGNvbnRhaW5lcjogcHJvcCxcbiAgICAgICAgICBrZXk6IGksXG4gICAgICAgICAgbGlzdEtleToga2V5XG4gICAgICAgIH0pO1xuICAgICAgICBwYXRocy5wdXNoKGNoaWxkUGF0aCk7XG4gICAgICB9XG4gICAgICBpZiAoX3Zpc2l0UGF0aHMoY3R4LCBwYXRocykpIHJldHVybiB0cnVlO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoX3Zpc2l0UGF0aHMoY3R4LCBbX2luZGV4LmRlZmF1bHQuZ2V0KHtcbiAgICAgICAgcGFyZW50UGF0aDogcGF0aCxcbiAgICAgICAgcGFyZW50OiBub2RlLFxuICAgICAgICBjb250YWluZXI6IG5vZGUsXG4gICAgICAgIGtleSxcbiAgICAgICAgbGlzdEtleTogbnVsbFxuICAgICAgfSldKSkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufVxuZnVuY3Rpb24gdHJhdmVyc2VOb2RlKG5vZGUsIG9wdHMsIHNjb3BlLCBzdGF0ZSwgcGF0aCwgc2tpcEtleXMsIHZpc2l0U2VsZikge1xuICBjb25zdCBrZXlzID0gVklTSVRPUl9LRVlTW25vZGUudHlwZV07XG4gIGlmICgha2V5cykgcmV0dXJuIGZhbHNlO1xuICBjb25zdCBjb250ZXh0ID0gbmV3IF9jb250ZXh0LmRlZmF1bHQoc2NvcGUsIG9wdHMsIHN0YXRlLCBwYXRoKTtcbiAgaWYgKHZpc2l0U2VsZikge1xuICAgIGlmIChza2lwS2V5cyAhPSBudWxsICYmIHNraXBLZXlzW3BhdGgucGFyZW50S2V5XSkgcmV0dXJuIGZhbHNlO1xuICAgIHJldHVybiBjb250ZXh0LnZpc2l0UXVldWUoW3BhdGhdKTtcbiAgfVxuICBmb3IgKGNvbnN0IGtleSBvZiBrZXlzKSB7XG4gICAgaWYgKHNraXBLZXlzICE9IG51bGwgJiYgc2tpcEtleXNba2V5XSkgY29udGludWU7XG4gICAgaWYgKGNvbnRleHQudmlzaXQobm9kZSwga2V5KSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9XG4gIHJldHVybiBmYWxzZTtcbn1cblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dHJhdmVyc2Utbm9kZS5qcy5tYXBcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@babel/traverse/lib/traverse-node.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@babel/traverse/lib/visitors.js":
/*!******************************************************!*\
  !*** ./node_modules/@babel/traverse/lib/visitors.js ***!
  \******************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports.environmentVisitor = environmentVisitor;\nexports.explode = explode$1;\nexports.isExplodedVisitor = isExplodedVisitor;\nexports.merge = merge;\nexports.verify = verify$1;\nvar virtualTypes = __webpack_require__(/*! ./path/lib/virtual-types.js */ \"(ssr)/./node_modules/@babel/traverse/lib/path/lib/virtual-types.js\");\nvar virtualTypesValidators = __webpack_require__(/*! ./path/lib/virtual-types-validator.js */ \"(ssr)/./node_modules/@babel/traverse/lib/path/lib/virtual-types-validator.js\");\nvar _t = __webpack_require__(/*! @babel/types */ \"(ssr)/./node_modules/@babel/types/lib/index.js\");\nvar _context = __webpack_require__(/*! ./path/context.js */ \"(ssr)/./node_modules/@babel/traverse/lib/path/context.js\");\nconst {\n  DEPRECATED_KEYS,\n  DEPRECATED_ALIASES,\n  FLIPPED_ALIAS_KEYS,\n  TYPES,\n  __internal__deprecationWarning: deprecationWarning\n} = _t;\nfunction isVirtualType(type) {\n  return type in virtualTypes;\n}\nfunction isExplodedVisitor(visitor) {\n  return visitor == null ? void 0 : visitor._exploded;\n}\nfunction explode$1(visitor) {\n  if (isExplodedVisitor(visitor)) return visitor;\n  visitor._exploded = true;\n  for (const nodeType of Object.keys(visitor)) {\n    if (shouldIgnoreKey(nodeType)) continue;\n    const parts = nodeType.split(\"|\");\n    if (parts.length === 1) continue;\n    const fns = visitor[nodeType];\n    delete visitor[nodeType];\n    for (const part of parts) {\n      visitor[part] = fns;\n    }\n  }\n  verify$1(visitor);\n  delete visitor.__esModule;\n  ensureEntranceObjects(visitor);\n  ensureCallbackArrays(visitor);\n  for (const nodeType of Object.keys(visitor)) {\n    if (shouldIgnoreKey(nodeType)) continue;\n    if (!isVirtualType(nodeType)) continue;\n    const fns = visitor[nodeType];\n    for (const type of Object.keys(fns)) {\n      fns[type] = wrapCheck(nodeType, fns[type]);\n    }\n    delete visitor[nodeType];\n    const types = virtualTypes[nodeType];\n    if (types !== null) {\n      for (const type of types) {\n        var _visitor$type;\n        (_visitor$type = visitor[type]) != null ? _visitor$type : visitor[type] = {};\n        mergePair(visitor[type], fns);\n      }\n    } else {\n      mergePair(visitor, fns);\n    }\n  }\n  for (const nodeType of Object.keys(visitor)) {\n    if (shouldIgnoreKey(nodeType)) continue;\n    let aliases = FLIPPED_ALIAS_KEYS[nodeType];\n    if (nodeType in DEPRECATED_KEYS) {\n      const deprecatedKey = DEPRECATED_KEYS[nodeType];\n      deprecationWarning(nodeType, deprecatedKey, \"Visitor \");\n      aliases = [deprecatedKey];\n    } else if (nodeType in DEPRECATED_ALIASES) {\n      const deprecatedAlias = DEPRECATED_ALIASES[nodeType];\n      deprecationWarning(nodeType, deprecatedAlias, \"Visitor \");\n      aliases = FLIPPED_ALIAS_KEYS[deprecatedAlias];\n    }\n    if (!aliases) continue;\n    const fns = visitor[nodeType];\n    delete visitor[nodeType];\n    for (const alias of aliases) {\n      const existing = visitor[alias];\n      if (existing) {\n        mergePair(existing, fns);\n      } else {\n        visitor[alias] = Object.assign({}, fns);\n      }\n    }\n  }\n  for (const nodeType of Object.keys(visitor)) {\n    if (shouldIgnoreKey(nodeType)) continue;\n    ensureCallbackArrays(visitor[nodeType]);\n  }\n  return visitor;\n}\nfunction verify$1(visitor) {\n  if (visitor._verified) return;\n  if (typeof visitor === \"function\") {\n    throw new Error(\"You passed `traverse()` a function when it expected a visitor object, \" + \"are you sure you didn't mean `{ enter: Function }`?\");\n  }\n  for (const nodeType of Object.keys(visitor)) {\n    if (nodeType === \"enter\" || nodeType === \"exit\") {\n      validateVisitorMethods(nodeType, visitor[nodeType]);\n    }\n    if (shouldIgnoreKey(nodeType)) continue;\n    if (!TYPES.includes(nodeType)) {\n      throw new Error(`You gave us a visitor for the node type ${nodeType} but it's not a valid type in @babel/traverse ${\"7.28.6\"}`);\n    }\n    const visitors = visitor[nodeType];\n    if (typeof visitors === \"object\") {\n      for (const visitorKey of Object.keys(visitors)) {\n        if (visitorKey === \"enter\" || visitorKey === \"exit\") {\n          validateVisitorMethods(`${nodeType}.${visitorKey}`, visitors[visitorKey]);\n        } else {\n          throw new Error(\"You passed `traverse()` a visitor object with the property \" + `${nodeType} that has the invalid property ${visitorKey}`);\n        }\n      }\n    }\n  }\n  visitor._verified = true;\n}\nfunction validateVisitorMethods(path, val) {\n  const fns = [].concat(val);\n  for (const fn of fns) {\n    if (typeof fn !== \"function\") {\n      throw new TypeError(`Non-function found defined in ${path} with type ${typeof fn}`);\n    }\n  }\n}\nfunction merge(visitors, states = [], wrapper) {\n  const mergedVisitor = {\n    _verified: true,\n    _exploded: true\n  };\n  Object.defineProperty(mergedVisitor, \"_exploded\", {\n    enumerable: false\n  });\n  Object.defineProperty(mergedVisitor, \"_verified\", {\n    enumerable: false\n  });\n  for (let i = 0; i < visitors.length; i++) {\n    const visitor = explode$1(visitors[i]);\n    const state = states[i];\n    let topVisitor = visitor;\n    if (state || wrapper) {\n      topVisitor = wrapWithStateOrWrapper(topVisitor, state, wrapper);\n    }\n    mergePair(mergedVisitor, topVisitor);\n    for (const key of Object.keys(visitor)) {\n      if (shouldIgnoreKey(key)) continue;\n      let typeVisitor = visitor[key];\n      if (state || wrapper) {\n        typeVisitor = wrapWithStateOrWrapper(typeVisitor, state, wrapper);\n      }\n      const nodeVisitor = mergedVisitor[key] || (mergedVisitor[key] = {});\n      mergePair(nodeVisitor, typeVisitor);\n    }\n  }\n  return mergedVisitor;\n}\nfunction wrapWithStateOrWrapper(oldVisitor, state, wrapper) {\n  const newVisitor = {};\n  for (const phase of [\"enter\", \"exit\"]) {\n    let fns = oldVisitor[phase];\n    if (!Array.isArray(fns)) continue;\n    fns = fns.map(function (fn) {\n      let newFn = fn;\n      if (state) {\n        newFn = function (path) {\n          fn.call(state, path, state);\n        };\n      }\n      if (wrapper) {\n        newFn = wrapper(state == null ? void 0 : state.key, phase, newFn);\n      }\n      if (newFn !== fn) {\n        newFn.toString = () => fn.toString();\n      }\n      return newFn;\n    });\n    newVisitor[phase] = fns;\n  }\n  return newVisitor;\n}\nfunction ensureEntranceObjects(obj) {\n  for (const key of Object.keys(obj)) {\n    if (shouldIgnoreKey(key)) continue;\n    const fns = obj[key];\n    if (typeof fns === \"function\") {\n      obj[key] = {\n        enter: fns\n      };\n    }\n  }\n}\nfunction ensureCallbackArrays(obj) {\n  if (obj.enter && !Array.isArray(obj.enter)) obj.enter = [obj.enter];\n  if (obj.exit && !Array.isArray(obj.exit)) obj.exit = [obj.exit];\n}\nfunction wrapCheck(nodeType, fn) {\n  const fnKey = `is${nodeType}`;\n  const validator = virtualTypesValidators[fnKey];\n  const newFn = function (path) {\n    if (validator.call(path)) {\n      return fn.apply(this, arguments);\n    }\n  };\n  newFn.toString = () => fn.toString();\n  return newFn;\n}\nfunction shouldIgnoreKey(key) {\n  if (key.startsWith(\"_\")) return true;\n  if (key === \"enter\" || key === \"exit\" || key === \"shouldSkip\") return true;\n  if (key === \"denylist\" || key === \"noScope\" || key === \"skipKeys\") {\n    return true;\n  }\n  if (key === \"blacklist\") {\n    return true;\n  }\n  return false;\n}\nfunction mergePair(dest, src) {\n  for (const phase of [\"enter\", \"exit\"]) {\n    if (!src[phase]) continue;\n    dest[phase] = [].concat(dest[phase] || [], src[phase]);\n  }\n}\nconst _environmentVisitor = {\n  FunctionParent(path) {\n    if (path.isArrowFunctionExpression()) return;\n    path.skip();\n    if (path.isMethod()) {\n      if (!path.requeueComputedKeyAndDecorators) {\n        _context.requeueComputedKeyAndDecorators.call(path);\n      } else {\n        path.requeueComputedKeyAndDecorators();\n      }\n    }\n  },\n  Property(path) {\n    if (path.isObjectProperty()) return;\n    path.skip();\n    if (!path.requeueComputedKeyAndDecorators) {\n      _context.requeueComputedKeyAndDecorators.call(path);\n    } else {\n      path.requeueComputedKeyAndDecorators();\n    }\n  }\n};\nfunction environmentVisitor(visitor) {\n  return merge([_environmentVisitor, visitor]);\n}\n\n//# sourceMappingURL=visitors.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGJhYmVsL3RyYXZlcnNlL2xpYi92aXNpdG9ycy5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYiw4Q0FBNkM7QUFDN0M7QUFDQSxDQUFDLEVBQUM7QUFDRiwwQkFBMEI7QUFDMUIsZUFBZTtBQUNmLHlCQUF5QjtBQUN6QixhQUFhO0FBQ2IsY0FBYztBQUNkLG1CQUFtQixtQkFBTyxDQUFDLHVHQUE2QjtBQUN4RCw2QkFBNkIsbUJBQU8sQ0FBQywySEFBdUM7QUFDNUUsU0FBUyxtQkFBTyxDQUFDLG9FQUFjO0FBQy9CLGVBQWUsbUJBQU8sQ0FBQyxtRkFBbUI7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUix5Q0FBeUM7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0lBQWdJLGlCQUFpQjtBQUNqSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlFQUFpRSxVQUFVLCtDQUErQyxTQUFTO0FBQ25JO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0MsU0FBUyxHQUFHLFdBQVc7QUFDM0QsVUFBVTtBQUNWLDZGQUE2RixVQUFVLGdDQUFnQyxXQUFXO0FBQ2xKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkRBQTJELE1BQU0sWUFBWSxVQUFVO0FBQ3ZGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsa0JBQWtCLHFCQUFxQjtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdFQUF3RTtBQUN4RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixTQUFTO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSIsInNvdXJjZXMiOlsid2VicGFjazovL3JlcG8tdmlzdWFsaXplci8uL25vZGVfbW9kdWxlcy9AYmFiZWwvdHJhdmVyc2UvbGliL3Zpc2l0b3JzLmpzP2ExMGQiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLmVudmlyb25tZW50VmlzaXRvciA9IGVudmlyb25tZW50VmlzaXRvcjtcbmV4cG9ydHMuZXhwbG9kZSA9IGV4cGxvZGUkMTtcbmV4cG9ydHMuaXNFeHBsb2RlZFZpc2l0b3IgPSBpc0V4cGxvZGVkVmlzaXRvcjtcbmV4cG9ydHMubWVyZ2UgPSBtZXJnZTtcbmV4cG9ydHMudmVyaWZ5ID0gdmVyaWZ5JDE7XG52YXIgdmlydHVhbFR5cGVzID0gcmVxdWlyZShcIi4vcGF0aC9saWIvdmlydHVhbC10eXBlcy5qc1wiKTtcbnZhciB2aXJ0dWFsVHlwZXNWYWxpZGF0b3JzID0gcmVxdWlyZShcIi4vcGF0aC9saWIvdmlydHVhbC10eXBlcy12YWxpZGF0b3IuanNcIik7XG52YXIgX3QgPSByZXF1aXJlKFwiQGJhYmVsL3R5cGVzXCIpO1xudmFyIF9jb250ZXh0ID0gcmVxdWlyZShcIi4vcGF0aC9jb250ZXh0LmpzXCIpO1xuY29uc3Qge1xuICBERVBSRUNBVEVEX0tFWVMsXG4gIERFUFJFQ0FURURfQUxJQVNFUyxcbiAgRkxJUFBFRF9BTElBU19LRVlTLFxuICBUWVBFUyxcbiAgX19pbnRlcm5hbF9fZGVwcmVjYXRpb25XYXJuaW5nOiBkZXByZWNhdGlvbldhcm5pbmdcbn0gPSBfdDtcbmZ1bmN0aW9uIGlzVmlydHVhbFR5cGUodHlwZSkge1xuICByZXR1cm4gdHlwZSBpbiB2aXJ0dWFsVHlwZXM7XG59XG5mdW5jdGlvbiBpc0V4cGxvZGVkVmlzaXRvcih2aXNpdG9yKSB7XG4gIHJldHVybiB2aXNpdG9yID09IG51bGwgPyB2b2lkIDAgOiB2aXNpdG9yLl9leHBsb2RlZDtcbn1cbmZ1bmN0aW9uIGV4cGxvZGUkMSh2aXNpdG9yKSB7XG4gIGlmIChpc0V4cGxvZGVkVmlzaXRvcih2aXNpdG9yKSkgcmV0dXJuIHZpc2l0b3I7XG4gIHZpc2l0b3IuX2V4cGxvZGVkID0gdHJ1ZTtcbiAgZm9yIChjb25zdCBub2RlVHlwZSBvZiBPYmplY3Qua2V5cyh2aXNpdG9yKSkge1xuICAgIGlmIChzaG91bGRJZ25vcmVLZXkobm9kZVR5cGUpKSBjb250aW51ZTtcbiAgICBjb25zdCBwYXJ0cyA9IG5vZGVUeXBlLnNwbGl0KFwifFwiKTtcbiAgICBpZiAocGFydHMubGVuZ3RoID09PSAxKSBjb250aW51ZTtcbiAgICBjb25zdCBmbnMgPSB2aXNpdG9yW25vZGVUeXBlXTtcbiAgICBkZWxldGUgdmlzaXRvcltub2RlVHlwZV07XG4gICAgZm9yIChjb25zdCBwYXJ0IG9mIHBhcnRzKSB7XG4gICAgICB2aXNpdG9yW3BhcnRdID0gZm5zO1xuICAgIH1cbiAgfVxuICB2ZXJpZnkkMSh2aXNpdG9yKTtcbiAgZGVsZXRlIHZpc2l0b3IuX19lc01vZHVsZTtcbiAgZW5zdXJlRW50cmFuY2VPYmplY3RzKHZpc2l0b3IpO1xuICBlbnN1cmVDYWxsYmFja0FycmF5cyh2aXNpdG9yKTtcbiAgZm9yIChjb25zdCBub2RlVHlwZSBvZiBPYmplY3Qua2V5cyh2aXNpdG9yKSkge1xuICAgIGlmIChzaG91bGRJZ25vcmVLZXkobm9kZVR5cGUpKSBjb250aW51ZTtcbiAgICBpZiAoIWlzVmlydHVhbFR5cGUobm9kZVR5cGUpKSBjb250aW51ZTtcbiAgICBjb25zdCBmbnMgPSB2aXNpdG9yW25vZGVUeXBlXTtcbiAgICBmb3IgKGNvbnN0IHR5cGUgb2YgT2JqZWN0LmtleXMoZm5zKSkge1xuICAgICAgZm5zW3R5cGVdID0gd3JhcENoZWNrKG5vZGVUeXBlLCBmbnNbdHlwZV0pO1xuICAgIH1cbiAgICBkZWxldGUgdmlzaXRvcltub2RlVHlwZV07XG4gICAgY29uc3QgdHlwZXMgPSB2aXJ0dWFsVHlwZXNbbm9kZVR5cGVdO1xuICAgIGlmICh0eXBlcyAhPT0gbnVsbCkge1xuICAgICAgZm9yIChjb25zdCB0eXBlIG9mIHR5cGVzKSB7XG4gICAgICAgIHZhciBfdmlzaXRvciR0eXBlO1xuICAgICAgICAoX3Zpc2l0b3IkdHlwZSA9IHZpc2l0b3JbdHlwZV0pICE9IG51bGwgPyBfdmlzaXRvciR0eXBlIDogdmlzaXRvclt0eXBlXSA9IHt9O1xuICAgICAgICBtZXJnZVBhaXIodmlzaXRvclt0eXBlXSwgZm5zKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgbWVyZ2VQYWlyKHZpc2l0b3IsIGZucyk7XG4gICAgfVxuICB9XG4gIGZvciAoY29uc3Qgbm9kZVR5cGUgb2YgT2JqZWN0LmtleXModmlzaXRvcikpIHtcbiAgICBpZiAoc2hvdWxkSWdub3JlS2V5KG5vZGVUeXBlKSkgY29udGludWU7XG4gICAgbGV0IGFsaWFzZXMgPSBGTElQUEVEX0FMSUFTX0tFWVNbbm9kZVR5cGVdO1xuICAgIGlmIChub2RlVHlwZSBpbiBERVBSRUNBVEVEX0tFWVMpIHtcbiAgICAgIGNvbnN0IGRlcHJlY2F0ZWRLZXkgPSBERVBSRUNBVEVEX0tFWVNbbm9kZVR5cGVdO1xuICAgICAgZGVwcmVjYXRpb25XYXJuaW5nKG5vZGVUeXBlLCBkZXByZWNhdGVkS2V5LCBcIlZpc2l0b3IgXCIpO1xuICAgICAgYWxpYXNlcyA9IFtkZXByZWNhdGVkS2V5XTtcbiAgICB9IGVsc2UgaWYgKG5vZGVUeXBlIGluIERFUFJFQ0FURURfQUxJQVNFUykge1xuICAgICAgY29uc3QgZGVwcmVjYXRlZEFsaWFzID0gREVQUkVDQVRFRF9BTElBU0VTW25vZGVUeXBlXTtcbiAgICAgIGRlcHJlY2F0aW9uV2FybmluZyhub2RlVHlwZSwgZGVwcmVjYXRlZEFsaWFzLCBcIlZpc2l0b3IgXCIpO1xuICAgICAgYWxpYXNlcyA9IEZMSVBQRURfQUxJQVNfS0VZU1tkZXByZWNhdGVkQWxpYXNdO1xuICAgIH1cbiAgICBpZiAoIWFsaWFzZXMpIGNvbnRpbnVlO1xuICAgIGNvbnN0IGZucyA9IHZpc2l0b3Jbbm9kZVR5cGVdO1xuICAgIGRlbGV0ZSB2aXNpdG9yW25vZGVUeXBlXTtcbiAgICBmb3IgKGNvbnN0IGFsaWFzIG9mIGFsaWFzZXMpIHtcbiAgICAgIGNvbnN0IGV4aXN0aW5nID0gdmlzaXRvclthbGlhc107XG4gICAgICBpZiAoZXhpc3RpbmcpIHtcbiAgICAgICAgbWVyZ2VQYWlyKGV4aXN0aW5nLCBmbnMpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmlzaXRvclthbGlhc10gPSBPYmplY3QuYXNzaWduKHt9LCBmbnMpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBmb3IgKGNvbnN0IG5vZGVUeXBlIG9mIE9iamVjdC5rZXlzKHZpc2l0b3IpKSB7XG4gICAgaWYgKHNob3VsZElnbm9yZUtleShub2RlVHlwZSkpIGNvbnRpbnVlO1xuICAgIGVuc3VyZUNhbGxiYWNrQXJyYXlzKHZpc2l0b3Jbbm9kZVR5cGVdKTtcbiAgfVxuICByZXR1cm4gdmlzaXRvcjtcbn1cbmZ1bmN0aW9uIHZlcmlmeSQxKHZpc2l0b3IpIHtcbiAgaWYgKHZpc2l0b3IuX3ZlcmlmaWVkKSByZXR1cm47XG4gIGlmICh0eXBlb2YgdmlzaXRvciA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiWW91IHBhc3NlZCBgdHJhdmVyc2UoKWAgYSBmdW5jdGlvbiB3aGVuIGl0IGV4cGVjdGVkIGEgdmlzaXRvciBvYmplY3QsIFwiICsgXCJhcmUgeW91IHN1cmUgeW91IGRpZG4ndCBtZWFuIGB7IGVudGVyOiBGdW5jdGlvbiB9YD9cIik7XG4gIH1cbiAgZm9yIChjb25zdCBub2RlVHlwZSBvZiBPYmplY3Qua2V5cyh2aXNpdG9yKSkge1xuICAgIGlmIChub2RlVHlwZSA9PT0gXCJlbnRlclwiIHx8IG5vZGVUeXBlID09PSBcImV4aXRcIikge1xuICAgICAgdmFsaWRhdGVWaXNpdG9yTWV0aG9kcyhub2RlVHlwZSwgdmlzaXRvcltub2RlVHlwZV0pO1xuICAgIH1cbiAgICBpZiAoc2hvdWxkSWdub3JlS2V5KG5vZGVUeXBlKSkgY29udGludWU7XG4gICAgaWYgKCFUWVBFUy5pbmNsdWRlcyhub2RlVHlwZSkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgWW91IGdhdmUgdXMgYSB2aXNpdG9yIGZvciB0aGUgbm9kZSB0eXBlICR7bm9kZVR5cGV9IGJ1dCBpdCdzIG5vdCBhIHZhbGlkIHR5cGUgaW4gQGJhYmVsL3RyYXZlcnNlICR7XCI3LjI4LjZcIn1gKTtcbiAgICB9XG4gICAgY29uc3QgdmlzaXRvcnMgPSB2aXNpdG9yW25vZGVUeXBlXTtcbiAgICBpZiAodHlwZW9mIHZpc2l0b3JzID09PSBcIm9iamVjdFwiKSB7XG4gICAgICBmb3IgKGNvbnN0IHZpc2l0b3JLZXkgb2YgT2JqZWN0LmtleXModmlzaXRvcnMpKSB7XG4gICAgICAgIGlmICh2aXNpdG9yS2V5ID09PSBcImVudGVyXCIgfHwgdmlzaXRvcktleSA9PT0gXCJleGl0XCIpIHtcbiAgICAgICAgICB2YWxpZGF0ZVZpc2l0b3JNZXRob2RzKGAke25vZGVUeXBlfS4ke3Zpc2l0b3JLZXl9YCwgdmlzaXRvcnNbdmlzaXRvcktleV0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIllvdSBwYXNzZWQgYHRyYXZlcnNlKClgIGEgdmlzaXRvciBvYmplY3Qgd2l0aCB0aGUgcHJvcGVydHkgXCIgKyBgJHtub2RlVHlwZX0gdGhhdCBoYXMgdGhlIGludmFsaWQgcHJvcGVydHkgJHt2aXNpdG9yS2V5fWApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHZpc2l0b3IuX3ZlcmlmaWVkID0gdHJ1ZTtcbn1cbmZ1bmN0aW9uIHZhbGlkYXRlVmlzaXRvck1ldGhvZHMocGF0aCwgdmFsKSB7XG4gIGNvbnN0IGZucyA9IFtdLmNvbmNhdCh2YWwpO1xuICBmb3IgKGNvbnN0IGZuIG9mIGZucykge1xuICAgIGlmICh0eXBlb2YgZm4gIT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgTm9uLWZ1bmN0aW9uIGZvdW5kIGRlZmluZWQgaW4gJHtwYXRofSB3aXRoIHR5cGUgJHt0eXBlb2YgZm59YCk7XG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiBtZXJnZSh2aXNpdG9ycywgc3RhdGVzID0gW10sIHdyYXBwZXIpIHtcbiAgY29uc3QgbWVyZ2VkVmlzaXRvciA9IHtcbiAgICBfdmVyaWZpZWQ6IHRydWUsXG4gICAgX2V4cGxvZGVkOiB0cnVlXG4gIH07XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShtZXJnZWRWaXNpdG9yLCBcIl9leHBsb2RlZFwiLCB7XG4gICAgZW51bWVyYWJsZTogZmFsc2VcbiAgfSk7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShtZXJnZWRWaXNpdG9yLCBcIl92ZXJpZmllZFwiLCB7XG4gICAgZW51bWVyYWJsZTogZmFsc2VcbiAgfSk7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgdmlzaXRvcnMubGVuZ3RoOyBpKyspIHtcbiAgICBjb25zdCB2aXNpdG9yID0gZXhwbG9kZSQxKHZpc2l0b3JzW2ldKTtcbiAgICBjb25zdCBzdGF0ZSA9IHN0YXRlc1tpXTtcbiAgICBsZXQgdG9wVmlzaXRvciA9IHZpc2l0b3I7XG4gICAgaWYgKHN0YXRlIHx8IHdyYXBwZXIpIHtcbiAgICAgIHRvcFZpc2l0b3IgPSB3cmFwV2l0aFN0YXRlT3JXcmFwcGVyKHRvcFZpc2l0b3IsIHN0YXRlLCB3cmFwcGVyKTtcbiAgICB9XG4gICAgbWVyZ2VQYWlyKG1lcmdlZFZpc2l0b3IsIHRvcFZpc2l0b3IpO1xuICAgIGZvciAoY29uc3Qga2V5IG9mIE9iamVjdC5rZXlzKHZpc2l0b3IpKSB7XG4gICAgICBpZiAoc2hvdWxkSWdub3JlS2V5KGtleSkpIGNvbnRpbnVlO1xuICAgICAgbGV0IHR5cGVWaXNpdG9yID0gdmlzaXRvcltrZXldO1xuICAgICAgaWYgKHN0YXRlIHx8IHdyYXBwZXIpIHtcbiAgICAgICAgdHlwZVZpc2l0b3IgPSB3cmFwV2l0aFN0YXRlT3JXcmFwcGVyKHR5cGVWaXNpdG9yLCBzdGF0ZSwgd3JhcHBlcik7XG4gICAgICB9XG4gICAgICBjb25zdCBub2RlVmlzaXRvciA9IG1lcmdlZFZpc2l0b3Jba2V5XSB8fCAobWVyZ2VkVmlzaXRvcltrZXldID0ge30pO1xuICAgICAgbWVyZ2VQYWlyKG5vZGVWaXNpdG9yLCB0eXBlVmlzaXRvcik7XG4gICAgfVxuICB9XG4gIHJldHVybiBtZXJnZWRWaXNpdG9yO1xufVxuZnVuY3Rpb24gd3JhcFdpdGhTdGF0ZU9yV3JhcHBlcihvbGRWaXNpdG9yLCBzdGF0ZSwgd3JhcHBlcikge1xuICBjb25zdCBuZXdWaXNpdG9yID0ge307XG4gIGZvciAoY29uc3QgcGhhc2Ugb2YgW1wiZW50ZXJcIiwgXCJleGl0XCJdKSB7XG4gICAgbGV0IGZucyA9IG9sZFZpc2l0b3JbcGhhc2VdO1xuICAgIGlmICghQXJyYXkuaXNBcnJheShmbnMpKSBjb250aW51ZTtcbiAgICBmbnMgPSBmbnMubWFwKGZ1bmN0aW9uIChmbikge1xuICAgICAgbGV0IG5ld0ZuID0gZm47XG4gICAgICBpZiAoc3RhdGUpIHtcbiAgICAgICAgbmV3Rm4gPSBmdW5jdGlvbiAocGF0aCkge1xuICAgICAgICAgIGZuLmNhbGwoc3RhdGUsIHBhdGgsIHN0YXRlKTtcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICAgIGlmICh3cmFwcGVyKSB7XG4gICAgICAgIG5ld0ZuID0gd3JhcHBlcihzdGF0ZSA9PSBudWxsID8gdm9pZCAwIDogc3RhdGUua2V5LCBwaGFzZSwgbmV3Rm4pO1xuICAgICAgfVxuICAgICAgaWYgKG5ld0ZuICE9PSBmbikge1xuICAgICAgICBuZXdGbi50b1N0cmluZyA9ICgpID0+IGZuLnRvU3RyaW5nKCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gbmV3Rm47XG4gICAgfSk7XG4gICAgbmV3VmlzaXRvcltwaGFzZV0gPSBmbnM7XG4gIH1cbiAgcmV0dXJuIG5ld1Zpc2l0b3I7XG59XG5mdW5jdGlvbiBlbnN1cmVFbnRyYW5jZU9iamVjdHMob2JqKSB7XG4gIGZvciAoY29uc3Qga2V5IG9mIE9iamVjdC5rZXlzKG9iaikpIHtcbiAgICBpZiAoc2hvdWxkSWdub3JlS2V5KGtleSkpIGNvbnRpbnVlO1xuICAgIGNvbnN0IGZucyA9IG9ialtrZXldO1xuICAgIGlmICh0eXBlb2YgZm5zID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgIG9ialtrZXldID0ge1xuICAgICAgICBlbnRlcjogZm5zXG4gICAgICB9O1xuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gZW5zdXJlQ2FsbGJhY2tBcnJheXMob2JqKSB7XG4gIGlmIChvYmouZW50ZXIgJiYgIUFycmF5LmlzQXJyYXkob2JqLmVudGVyKSkgb2JqLmVudGVyID0gW29iai5lbnRlcl07XG4gIGlmIChvYmouZXhpdCAmJiAhQXJyYXkuaXNBcnJheShvYmouZXhpdCkpIG9iai5leGl0ID0gW29iai5leGl0XTtcbn1cbmZ1bmN0aW9uIHdyYXBDaGVjayhub2RlVHlwZSwgZm4pIHtcbiAgY29uc3QgZm5LZXkgPSBgaXMke25vZGVUeXBlfWA7XG4gIGNvbnN0IHZhbGlkYXRvciA9IHZpcnR1YWxUeXBlc1ZhbGlkYXRvcnNbZm5LZXldO1xuICBjb25zdCBuZXdGbiA9IGZ1bmN0aW9uIChwYXRoKSB7XG4gICAgaWYgKHZhbGlkYXRvci5jYWxsKHBhdGgpKSB7XG4gICAgICByZXR1cm4gZm4uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9XG4gIH07XG4gIG5ld0ZuLnRvU3RyaW5nID0gKCkgPT4gZm4udG9TdHJpbmcoKTtcbiAgcmV0dXJuIG5ld0ZuO1xufVxuZnVuY3Rpb24gc2hvdWxkSWdub3JlS2V5KGtleSkge1xuICBpZiAoa2V5LnN0YXJ0c1dpdGgoXCJfXCIpKSByZXR1cm4gdHJ1ZTtcbiAgaWYgKGtleSA9PT0gXCJlbnRlclwiIHx8IGtleSA9PT0gXCJleGl0XCIgfHwga2V5ID09PSBcInNob3VsZFNraXBcIikgcmV0dXJuIHRydWU7XG4gIGlmIChrZXkgPT09IFwiZGVueWxpc3RcIiB8fCBrZXkgPT09IFwibm9TY29wZVwiIHx8IGtleSA9PT0gXCJza2lwS2V5c1wiKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgaWYgKGtleSA9PT0gXCJibGFja2xpc3RcIikge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIHJldHVybiBmYWxzZTtcbn1cbmZ1bmN0aW9uIG1lcmdlUGFpcihkZXN0LCBzcmMpIHtcbiAgZm9yIChjb25zdCBwaGFzZSBvZiBbXCJlbnRlclwiLCBcImV4aXRcIl0pIHtcbiAgICBpZiAoIXNyY1twaGFzZV0pIGNvbnRpbnVlO1xuICAgIGRlc3RbcGhhc2VdID0gW10uY29uY2F0KGRlc3RbcGhhc2VdIHx8IFtdLCBzcmNbcGhhc2VdKTtcbiAgfVxufVxuY29uc3QgX2Vudmlyb25tZW50VmlzaXRvciA9IHtcbiAgRnVuY3Rpb25QYXJlbnQocGF0aCkge1xuICAgIGlmIChwYXRoLmlzQXJyb3dGdW5jdGlvbkV4cHJlc3Npb24oKSkgcmV0dXJuO1xuICAgIHBhdGguc2tpcCgpO1xuICAgIGlmIChwYXRoLmlzTWV0aG9kKCkpIHtcbiAgICAgIGlmICghcGF0aC5yZXF1ZXVlQ29tcHV0ZWRLZXlBbmREZWNvcmF0b3JzKSB7XG4gICAgICAgIF9jb250ZXh0LnJlcXVldWVDb21wdXRlZEtleUFuZERlY29yYXRvcnMuY2FsbChwYXRoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHBhdGgucmVxdWV1ZUNvbXB1dGVkS2V5QW5kRGVjb3JhdG9ycygpO1xuICAgICAgfVxuICAgIH1cbiAgfSxcbiAgUHJvcGVydHkocGF0aCkge1xuICAgIGlmIChwYXRoLmlzT2JqZWN0UHJvcGVydHkoKSkgcmV0dXJuO1xuICAgIHBhdGguc2tpcCgpO1xuICAgIGlmICghcGF0aC5yZXF1ZXVlQ29tcHV0ZWRLZXlBbmREZWNvcmF0b3JzKSB7XG4gICAgICBfY29udGV4dC5yZXF1ZXVlQ29tcHV0ZWRLZXlBbmREZWNvcmF0b3JzLmNhbGwocGF0aCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHBhdGgucmVxdWV1ZUNvbXB1dGVkS2V5QW5kRGVjb3JhdG9ycygpO1xuICAgIH1cbiAgfVxufTtcbmZ1bmN0aW9uIGVudmlyb25tZW50VmlzaXRvcih2aXNpdG9yKSB7XG4gIHJldHVybiBtZXJnZShbX2Vudmlyb25tZW50VmlzaXRvciwgdmlzaXRvcl0pO1xufVxuXG4vLyMgc291cmNlTWFwcGluZ1VSTD12aXNpdG9ycy5qcy5tYXBcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@babel/traverse/lib/visitors.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@babel/types/lib/asserts/assertNode.js":
/*!*************************************************************!*\
  !*** ./node_modules/@babel/types/lib/asserts/assertNode.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports[\"default\"] = assertNode;\nvar _isNode = __webpack_require__(/*! ../validators/isNode.js */ \"(ssr)/./node_modules/@babel/types/lib/validators/isNode.js\");\nfunction assertNode(node) {\n  if (!(0, _isNode.default)(node)) {\n    var _node$type;\n    const type = (_node$type = node == null ? void 0 : node.type) != null ? _node$type : JSON.stringify(node);\n    throw new TypeError(`Not a valid node of type \"${type}\"`);\n  }\n}\n\n//# sourceMappingURL=assertNode.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGJhYmVsL3R5cGVzL2xpYi9hc3NlcnRzL2Fzc2VydE5vZGUuanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWIsOENBQTZDO0FBQzdDO0FBQ0EsQ0FBQyxFQUFDO0FBQ0Ysa0JBQWU7QUFDZixjQUFjLG1CQUFPLENBQUMsMkZBQXlCO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscURBQXFELEtBQUs7QUFDMUQ7QUFDQTs7QUFFQSIsInNvdXJjZXMiOlsid2VicGFjazovL3JlcG8tdmlzdWFsaXplci8uL25vZGVfbW9kdWxlcy9AYmFiZWwvdHlwZXMvbGliL2Fzc2VydHMvYXNzZXJ0Tm9kZS5qcz80YjcwIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5kZWZhdWx0ID0gYXNzZXJ0Tm9kZTtcbnZhciBfaXNOb2RlID0gcmVxdWlyZShcIi4uL3ZhbGlkYXRvcnMvaXNOb2RlLmpzXCIpO1xuZnVuY3Rpb24gYXNzZXJ0Tm9kZShub2RlKSB7XG4gIGlmICghKDAsIF9pc05vZGUuZGVmYXVsdCkobm9kZSkpIHtcbiAgICB2YXIgX25vZGUkdHlwZTtcbiAgICBjb25zdCB0eXBlID0gKF9ub2RlJHR5cGUgPSBub2RlID09IG51bGwgPyB2b2lkIDAgOiBub2RlLnR5cGUpICE9IG51bGwgPyBfbm9kZSR0eXBlIDogSlNPTi5zdHJpbmdpZnkobm9kZSk7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgTm90IGEgdmFsaWQgbm9kZSBvZiB0eXBlIFwiJHt0eXBlfVwiYCk7XG4gIH1cbn1cblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YXNzZXJ0Tm9kZS5qcy5tYXBcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@babel/types/lib/asserts/assertNode.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@babel/types/lib/asserts/generated/index.js":
/*!******************************************************************!*\
  !*** ./node_modules/@babel/types/lib/asserts/generated/index.js ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports.assertAccessor = assertAccessor;\nexports.assertAnyTypeAnnotation = assertAnyTypeAnnotation;\nexports.assertArgumentPlaceholder = assertArgumentPlaceholder;\nexports.assertArrayExpression = assertArrayExpression;\nexports.assertArrayPattern = assertArrayPattern;\nexports.assertArrayTypeAnnotation = assertArrayTypeAnnotation;\nexports.assertArrowFunctionExpression = assertArrowFunctionExpression;\nexports.assertAssignmentExpression = assertAssignmentExpression;\nexports.assertAssignmentPattern = assertAssignmentPattern;\nexports.assertAwaitExpression = assertAwaitExpression;\nexports.assertBigIntLiteral = assertBigIntLiteral;\nexports.assertBinary = assertBinary;\nexports.assertBinaryExpression = assertBinaryExpression;\nexports.assertBindExpression = assertBindExpression;\nexports.assertBlock = assertBlock;\nexports.assertBlockParent = assertBlockParent;\nexports.assertBlockStatement = assertBlockStatement;\nexports.assertBooleanLiteral = assertBooleanLiteral;\nexports.assertBooleanLiteralTypeAnnotation = assertBooleanLiteralTypeAnnotation;\nexports.assertBooleanTypeAnnotation = assertBooleanTypeAnnotation;\nexports.assertBreakStatement = assertBreakStatement;\nexports.assertCallExpression = assertCallExpression;\nexports.assertCatchClause = assertCatchClause;\nexports.assertClass = assertClass;\nexports.assertClassAccessorProperty = assertClassAccessorProperty;\nexports.assertClassBody = assertClassBody;\nexports.assertClassDeclaration = assertClassDeclaration;\nexports.assertClassExpression = assertClassExpression;\nexports.assertClassImplements = assertClassImplements;\nexports.assertClassMethod = assertClassMethod;\nexports.assertClassPrivateMethod = assertClassPrivateMethod;\nexports.assertClassPrivateProperty = assertClassPrivateProperty;\nexports.assertClassProperty = assertClassProperty;\nexports.assertCompletionStatement = assertCompletionStatement;\nexports.assertConditional = assertConditional;\nexports.assertConditionalExpression = assertConditionalExpression;\nexports.assertContinueStatement = assertContinueStatement;\nexports.assertDebuggerStatement = assertDebuggerStatement;\nexports.assertDecimalLiteral = assertDecimalLiteral;\nexports.assertDeclaration = assertDeclaration;\nexports.assertDeclareClass = assertDeclareClass;\nexports.assertDeclareExportAllDeclaration = assertDeclareExportAllDeclaration;\nexports.assertDeclareExportDeclaration = assertDeclareExportDeclaration;\nexports.assertDeclareFunction = assertDeclareFunction;\nexports.assertDeclareInterface = assertDeclareInterface;\nexports.assertDeclareModule = assertDeclareModule;\nexports.assertDeclareModuleExports = assertDeclareModuleExports;\nexports.assertDeclareOpaqueType = assertDeclareOpaqueType;\nexports.assertDeclareTypeAlias = assertDeclareTypeAlias;\nexports.assertDeclareVariable = assertDeclareVariable;\nexports.assertDeclaredPredicate = assertDeclaredPredicate;\nexports.assertDecorator = assertDecorator;\nexports.assertDirective = assertDirective;\nexports.assertDirectiveLiteral = assertDirectiveLiteral;\nexports.assertDoExpression = assertDoExpression;\nexports.assertDoWhileStatement = assertDoWhileStatement;\nexports.assertEmptyStatement = assertEmptyStatement;\nexports.assertEmptyTypeAnnotation = assertEmptyTypeAnnotation;\nexports.assertEnumBody = assertEnumBody;\nexports.assertEnumBooleanBody = assertEnumBooleanBody;\nexports.assertEnumBooleanMember = assertEnumBooleanMember;\nexports.assertEnumDeclaration = assertEnumDeclaration;\nexports.assertEnumDefaultedMember = assertEnumDefaultedMember;\nexports.assertEnumMember = assertEnumMember;\nexports.assertEnumNumberBody = assertEnumNumberBody;\nexports.assertEnumNumberMember = assertEnumNumberMember;\nexports.assertEnumStringBody = assertEnumStringBody;\nexports.assertEnumStringMember = assertEnumStringMember;\nexports.assertEnumSymbolBody = assertEnumSymbolBody;\nexports.assertExistsTypeAnnotation = assertExistsTypeAnnotation;\nexports.assertExportAllDeclaration = assertExportAllDeclaration;\nexports.assertExportDeclaration = assertExportDeclaration;\nexports.assertExportDefaultDeclaration = assertExportDefaultDeclaration;\nexports.assertExportDefaultSpecifier = assertExportDefaultSpecifier;\nexports.assertExportNamedDeclaration = assertExportNamedDeclaration;\nexports.assertExportNamespaceSpecifier = assertExportNamespaceSpecifier;\nexports.assertExportSpecifier = assertExportSpecifier;\nexports.assertExpression = assertExpression;\nexports.assertExpressionStatement = assertExpressionStatement;\nexports.assertExpressionWrapper = assertExpressionWrapper;\nexports.assertFile = assertFile;\nexports.assertFlow = assertFlow;\nexports.assertFlowBaseAnnotation = assertFlowBaseAnnotation;\nexports.assertFlowDeclaration = assertFlowDeclaration;\nexports.assertFlowPredicate = assertFlowPredicate;\nexports.assertFlowType = assertFlowType;\nexports.assertFor = assertFor;\nexports.assertForInStatement = assertForInStatement;\nexports.assertForOfStatement = assertForOfStatement;\nexports.assertForStatement = assertForStatement;\nexports.assertForXStatement = assertForXStatement;\nexports.assertFunction = assertFunction;\nexports.assertFunctionDeclaration = assertFunctionDeclaration;\nexports.assertFunctionExpression = assertFunctionExpression;\nexports.assertFunctionParameter = assertFunctionParameter;\nexports.assertFunctionParent = assertFunctionParent;\nexports.assertFunctionTypeAnnotation = assertFunctionTypeAnnotation;\nexports.assertFunctionTypeParam = assertFunctionTypeParam;\nexports.assertGenericTypeAnnotation = assertGenericTypeAnnotation;\nexports.assertIdentifier = assertIdentifier;\nexports.assertIfStatement = assertIfStatement;\nexports.assertImmutable = assertImmutable;\nexports.assertImport = assertImport;\nexports.assertImportAttribute = assertImportAttribute;\nexports.assertImportDeclaration = assertImportDeclaration;\nexports.assertImportDefaultSpecifier = assertImportDefaultSpecifier;\nexports.assertImportExpression = assertImportExpression;\nexports.assertImportNamespaceSpecifier = assertImportNamespaceSpecifier;\nexports.assertImportOrExportDeclaration = assertImportOrExportDeclaration;\nexports.assertImportSpecifier = assertImportSpecifier;\nexports.assertIndexedAccessType = assertIndexedAccessType;\nexports.assertInferredPredicate = assertInferredPredicate;\nexports.assertInterfaceDeclaration = assertInterfaceDeclaration;\nexports.assertInterfaceExtends = assertInterfaceExtends;\nexports.assertInterfaceTypeAnnotation = assertInterfaceTypeAnnotation;\nexports.assertInterpreterDirective = assertInterpreterDirective;\nexports.assertIntersectionTypeAnnotation = assertIntersectionTypeAnnotation;\nexports.assertJSX = assertJSX;\nexports.assertJSXAttribute = assertJSXAttribute;\nexports.assertJSXClosingElement = assertJSXClosingElement;\nexports.assertJSXClosingFragment = assertJSXClosingFragment;\nexports.assertJSXElement = assertJSXElement;\nexports.assertJSXEmptyExpression = assertJSXEmptyExpression;\nexports.assertJSXExpressionContainer = assertJSXExpressionContainer;\nexports.assertJSXFragment = assertJSXFragment;\nexports.assertJSXIdentifier = assertJSXIdentifier;\nexports.assertJSXMemberExpression = assertJSXMemberExpression;\nexports.assertJSXNamespacedName = assertJSXNamespacedName;\nexports.assertJSXOpeningElement = assertJSXOpeningElement;\nexports.assertJSXOpeningFragment = assertJSXOpeningFragment;\nexports.assertJSXSpreadAttribute = assertJSXSpreadAttribute;\nexports.assertJSXSpreadChild = assertJSXSpreadChild;\nexports.assertJSXText = assertJSXText;\nexports.assertLVal = assertLVal;\nexports.assertLabeledStatement = assertLabeledStatement;\nexports.assertLiteral = assertLiteral;\nexports.assertLogicalExpression = assertLogicalExpression;\nexports.assertLoop = assertLoop;\nexports.assertMemberExpression = assertMemberExpression;\nexports.assertMetaProperty = assertMetaProperty;\nexports.assertMethod = assertMethod;\nexports.assertMiscellaneous = assertMiscellaneous;\nexports.assertMixedTypeAnnotation = assertMixedTypeAnnotation;\nexports.assertModuleDeclaration = assertModuleDeclaration;\nexports.assertModuleExpression = assertModuleExpression;\nexports.assertModuleSpecifier = assertModuleSpecifier;\nexports.assertNewExpression = assertNewExpression;\nexports.assertNoop = assertNoop;\nexports.assertNullLiteral = assertNullLiteral;\nexports.assertNullLiteralTypeAnnotation = assertNullLiteralTypeAnnotation;\nexports.assertNullableTypeAnnotation = assertNullableTypeAnnotation;\nexports.assertNumberLiteral = assertNumberLiteral;\nexports.assertNumberLiteralTypeAnnotation = assertNumberLiteralTypeAnnotation;\nexports.assertNumberTypeAnnotation = assertNumberTypeAnnotation;\nexports.assertNumericLiteral = assertNumericLiteral;\nexports.assertObjectExpression = assertObjectExpression;\nexports.assertObjectMember = assertObjectMember;\nexports.assertObjectMethod = assertObjectMethod;\nexports.assertObjectPattern = assertObjectPattern;\nexports.assertObjectProperty = assertObjectProperty;\nexports.assertObjectTypeAnnotation = assertObjectTypeAnnotation;\nexports.assertObjectTypeCallProperty = assertObjectTypeCallProperty;\nexports.assertObjectTypeIndexer = assertObjectTypeIndexer;\nexports.assertObjectTypeInternalSlot = assertObjectTypeInternalSlot;\nexports.assertObjectTypeProperty = assertObjectTypeProperty;\nexports.assertObjectTypeSpreadProperty = assertObjectTypeSpreadProperty;\nexports.assertOpaqueType = assertOpaqueType;\nexports.assertOptionalCallExpression = assertOptionalCallExpression;\nexports.assertOptionalIndexedAccessType = assertOptionalIndexedAccessType;\nexports.assertOptionalMemberExpression = assertOptionalMemberExpression;\nexports.assertParenthesizedExpression = assertParenthesizedExpression;\nexports.assertPattern = assertPattern;\nexports.assertPatternLike = assertPatternLike;\nexports.assertPipelineBareFunction = assertPipelineBareFunction;\nexports.assertPipelinePrimaryTopicReference = assertPipelinePrimaryTopicReference;\nexports.assertPipelineTopicExpression = assertPipelineTopicExpression;\nexports.assertPlaceholder = assertPlaceholder;\nexports.assertPrivate = assertPrivate;\nexports.assertPrivateName = assertPrivateName;\nexports.assertProgram = assertProgram;\nexports.assertProperty = assertProperty;\nexports.assertPureish = assertPureish;\nexports.assertQualifiedTypeIdentifier = assertQualifiedTypeIdentifier;\nexports.assertRecordExpression = assertRecordExpression;\nexports.assertRegExpLiteral = assertRegExpLiteral;\nexports.assertRegexLiteral = assertRegexLiteral;\nexports.assertRestElement = assertRestElement;\nexports.assertRestProperty = assertRestProperty;\nexports.assertReturnStatement = assertReturnStatement;\nexports.assertScopable = assertScopable;\nexports.assertSequenceExpression = assertSequenceExpression;\nexports.assertSpreadElement = assertSpreadElement;\nexports.assertSpreadProperty = assertSpreadProperty;\nexports.assertStandardized = assertStandardized;\nexports.assertStatement = assertStatement;\nexports.assertStaticBlock = assertStaticBlock;\nexports.assertStringLiteral = assertStringLiteral;\nexports.assertStringLiteralTypeAnnotation = assertStringLiteralTypeAnnotation;\nexports.assertStringTypeAnnotation = assertStringTypeAnnotation;\nexports.assertSuper = assertSuper;\nexports.assertSwitchCase = assertSwitchCase;\nexports.assertSwitchStatement = assertSwitchStatement;\nexports.assertSymbolTypeAnnotation = assertSymbolTypeAnnotation;\nexports.assertTSAnyKeyword = assertTSAnyKeyword;\nexports.assertTSArrayType = assertTSArrayType;\nexports.assertTSAsExpression = assertTSAsExpression;\nexports.assertTSBaseType = assertTSBaseType;\nexports.assertTSBigIntKeyword = assertTSBigIntKeyword;\nexports.assertTSBooleanKeyword = assertTSBooleanKeyword;\nexports.assertTSCallSignatureDeclaration = assertTSCallSignatureDeclaration;\nexports.assertTSConditionalType = assertTSConditionalType;\nexports.assertTSConstructSignatureDeclaration = assertTSConstructSignatureDeclaration;\nexports.assertTSConstructorType = assertTSConstructorType;\nexports.assertTSDeclareFunction = assertTSDeclareFunction;\nexports.assertTSDeclareMethod = assertTSDeclareMethod;\nexports.assertTSEntityName = assertTSEntityName;\nexports.assertTSEnumBody = assertTSEnumBody;\nexports.assertTSEnumDeclaration = assertTSEnumDeclaration;\nexports.assertTSEnumMember = assertTSEnumMember;\nexports.assertTSExportAssignment = assertTSExportAssignment;\nexports.assertTSExpressionWithTypeArguments = assertTSExpressionWithTypeArguments;\nexports.assertTSExternalModuleReference = assertTSExternalModuleReference;\nexports.assertTSFunctionType = assertTSFunctionType;\nexports.assertTSImportEqualsDeclaration = assertTSImportEqualsDeclaration;\nexports.assertTSImportType = assertTSImportType;\nexports.assertTSIndexSignature = assertTSIndexSignature;\nexports.assertTSIndexedAccessType = assertTSIndexedAccessType;\nexports.assertTSInferType = assertTSInferType;\nexports.assertTSInstantiationExpression = assertTSInstantiationExpression;\nexports.assertTSInterfaceBody = assertTSInterfaceBody;\nexports.assertTSInterfaceDeclaration = assertTSInterfaceDeclaration;\nexports.assertTSIntersectionType = assertTSIntersectionType;\nexports.assertTSIntrinsicKeyword = assertTSIntrinsicKeyword;\nexports.assertTSLiteralType = assertTSLiteralType;\nexports.assertTSMappedType = assertTSMappedType;\nexports.assertTSMethodSignature = assertTSMethodSignature;\nexports.assertTSModuleBlock = assertTSModuleBlock;\nexports.assertTSModuleDeclaration = assertTSModuleDeclaration;\nexports.assertTSNamedTupleMember = assertTSNamedTupleMember;\nexports.assertTSNamespaceExportDeclaration = assertTSNamespaceExportDeclaration;\nexports.assertTSNeverKeyword = assertTSNeverKeyword;\nexports.assertTSNonNullExpression = assertTSNonNullExpression;\nexports.assertTSNullKeyword = assertTSNullKeyword;\nexports.assertTSNumberKeyword = assertTSNumberKeyword;\nexports.assertTSObjectKeyword = assertTSObjectKeyword;\nexports.assertTSOptionalType = assertTSOptionalType;\nexports.assertTSParameterProperty = assertTSParameterProperty;\nexports.assertTSParenthesizedType = assertTSParenthesizedType;\nexports.assertTSPropertySignature = assertTSPropertySignature;\nexports.assertTSQualifiedName = assertTSQualifiedName;\nexports.assertTSRestType = assertTSRestType;\nexports.assertTSSatisfiesExpression = assertTSSatisfiesExpression;\nexports.assertTSStringKeyword = assertTSStringKeyword;\nexports.assertTSSymbolKeyword = assertTSSymbolKeyword;\nexports.assertTSTemplateLiteralType = assertTSTemplateLiteralType;\nexports.assertTSThisType = assertTSThisType;\nexports.assertTSTupleType = assertTSTupleType;\nexports.assertTSType = assertTSType;\nexports.assertTSTypeAliasDeclaration = assertTSTypeAliasDeclaration;\nexports.assertTSTypeAnnotation = assertTSTypeAnnotation;\nexports.assertTSTypeAssertion = assertTSTypeAssertion;\nexports.assertTSTypeElement = assertTSTypeElement;\nexports.assertTSTypeLiteral = assertTSTypeLiteral;\nexports.assertTSTypeOperator = assertTSTypeOperator;\nexports.assertTSTypeParameter = assertTSTypeParameter;\nexports.assertTSTypeParameterDeclaration = assertTSTypeParameterDeclaration;\nexports.assertTSTypeParameterInstantiation = assertTSTypeParameterInstantiation;\nexports.assertTSTypePredicate = assertTSTypePredicate;\nexports.assertTSTypeQuery = assertTSTypeQuery;\nexports.assertTSTypeReference = assertTSTypeReference;\nexports.assertTSUndefinedKeyword = assertTSUndefinedKeyword;\nexports.assertTSUnionType = assertTSUnionType;\nexports.assertTSUnknownKeyword = assertTSUnknownKeyword;\nexports.assertTSVoidKeyword = assertTSVoidKeyword;\nexports.assertTaggedTemplateExpression = assertTaggedTemplateExpression;\nexports.assertTemplateElement = assertTemplateElement;\nexports.assertTemplateLiteral = assertTemplateLiteral;\nexports.assertTerminatorless = assertTerminatorless;\nexports.assertThisExpression = assertThisExpression;\nexports.assertThisTypeAnnotation = assertThisTypeAnnotation;\nexports.assertThrowStatement = assertThrowStatement;\nexports.assertTopicReference = assertTopicReference;\nexports.assertTryStatement = assertTryStatement;\nexports.assertTupleExpression = assertTupleExpression;\nexports.assertTupleTypeAnnotation = assertTupleTypeAnnotation;\nexports.assertTypeAlias = assertTypeAlias;\nexports.assertTypeAnnotation = assertTypeAnnotation;\nexports.assertTypeCastExpression = assertTypeCastExpression;\nexports.assertTypeParameter = assertTypeParameter;\nexports.assertTypeParameterDeclaration = assertTypeParameterDeclaration;\nexports.assertTypeParameterInstantiation = assertTypeParameterInstantiation;\nexports.assertTypeScript = assertTypeScript;\nexports.assertTypeofTypeAnnotation = assertTypeofTypeAnnotation;\nexports.assertUnaryExpression = assertUnaryExpression;\nexports.assertUnaryLike = assertUnaryLike;\nexports.assertUnionTypeAnnotation = assertUnionTypeAnnotation;\nexports.assertUpdateExpression = assertUpdateExpression;\nexports.assertUserWhitespacable = assertUserWhitespacable;\nexports.assertV8IntrinsicIdentifier = assertV8IntrinsicIdentifier;\nexports.assertVariableDeclaration = assertVariableDeclaration;\nexports.assertVariableDeclarator = assertVariableDeclarator;\nexports.assertVariance = assertVariance;\nexports.assertVoidPattern = assertVoidPattern;\nexports.assertVoidTypeAnnotation = assertVoidTypeAnnotation;\nexports.assertWhile = assertWhile;\nexports.assertWhileStatement = assertWhileStatement;\nexports.assertWithStatement = assertWithStatement;\nexports.assertYieldExpression = assertYieldExpression;\nvar _is = __webpack_require__(/*! ../../validators/is.js */ \"(ssr)/./node_modules/@babel/types/lib/validators/is.js\");\nvar _deprecationWarning = __webpack_require__(/*! ../../utils/deprecationWarning.js */ \"(ssr)/./node_modules/@babel/types/lib/utils/deprecationWarning.js\");\nfunction assert(type, node, opts) {\n  if (!(0, _is.default)(type, node, opts)) {\n    throw new Error(`Expected type \"${type}\" with option ${JSON.stringify(opts)}, ` + `but instead got \"${node.type}\".`);\n  }\n}\nfunction assertArrayExpression(node, opts) {\n  assert(\"ArrayExpression\", node, opts);\n}\nfunction assertAssignmentExpression(node, opts) {\n  assert(\"AssignmentExpression\", node, opts);\n}\nfunction assertBinaryExpression(node, opts) {\n  assert(\"BinaryExpression\", node, opts);\n}\nfunction assertInterpreterDirective(node, opts) {\n  assert(\"InterpreterDirective\", node, opts);\n}\nfunction assertDirective(node, opts) {\n  assert(\"Directive\", node, opts);\n}\nfunction assertDirectiveLiteral(node, opts) {\n  assert(\"DirectiveLiteral\", node, opts);\n}\nfunction assertBlockStatement(node, opts) {\n  assert(\"BlockStatement\", node, opts);\n}\nfunction assertBreakStatement(node, opts) {\n  assert(\"BreakStatement\", node, opts);\n}\nfunction assertCallExpression(node, opts) {\n  assert(\"CallExpression\", node, opts);\n}\nfunction assertCatchClause(node, opts) {\n  assert(\"CatchClause\", node, opts);\n}\nfunction assertConditionalExpression(node, opts) {\n  assert(\"ConditionalExpression\", node, opts);\n}\nfunction assertContinueStatement(node, opts) {\n  assert(\"ContinueStatement\", node, opts);\n}\nfunction assertDebuggerStatement(node, opts) {\n  assert(\"DebuggerStatement\", node, opts);\n}\nfunction assertDoWhileStatement(node, opts) {\n  assert(\"DoWhileStatement\", node, opts);\n}\nfunction assertEmptyStatement(node, opts) {\n  assert(\"EmptyStatement\", node, opts);\n}\nfunction assertExpressionStatement(node, opts) {\n  assert(\"ExpressionStatement\", node, opts);\n}\nfunction assertFile(node, opts) {\n  assert(\"File\", node, opts);\n}\nfunction assertForInStatement(node, opts) {\n  assert(\"ForInStatement\", node, opts);\n}\nfunction assertForStatement(node, opts) {\n  assert(\"ForStatement\", node, opts);\n}\nfunction assertFunctionDeclaration(node, opts) {\n  assert(\"FunctionDeclaration\", node, opts);\n}\nfunction assertFunctionExpression(node, opts) {\n  assert(\"FunctionExpression\", node, opts);\n}\nfunction assertIdentifier(node, opts) {\n  assert(\"Identifier\", node, opts);\n}\nfunction assertIfStatement(node, opts) {\n  assert(\"IfStatement\", node, opts);\n}\nfunction assertLabeledStatement(node, opts) {\n  assert(\"LabeledStatement\", node, opts);\n}\nfunction assertStringLiteral(node, opts) {\n  assert(\"StringLiteral\", node, opts);\n}\nfunction assertNumericLiteral(node, opts) {\n  assert(\"NumericLiteral\", node, opts);\n}\nfunction assertNullLiteral(node, opts) {\n  assert(\"NullLiteral\", node, opts);\n}\nfunction assertBooleanLiteral(node, opts) {\n  assert(\"BooleanLiteral\", node, opts);\n}\nfunction assertRegExpLiteral(node, opts) {\n  assert(\"RegExpLiteral\", node, opts);\n}\nfunction assertLogicalExpression(node, opts) {\n  assert(\"LogicalExpression\", node, opts);\n}\nfunction assertMemberExpression(node, opts) {\n  assert(\"MemberExpression\", node, opts);\n}\nfunction assertNewExpression(node, opts) {\n  assert(\"NewExpression\", node, opts);\n}\nfunction assertProgram(node, opts) {\n  assert(\"Program\", node, opts);\n}\nfunction assertObjectExpression(node, opts) {\n  assert(\"ObjectExpression\", node, opts);\n}\nfunction assertObjectMethod(node, opts) {\n  assert(\"ObjectMethod\", node, opts);\n}\nfunction assertObjectProperty(node, opts) {\n  assert(\"ObjectProperty\", node, opts);\n}\nfunction assertRestElement(node, opts) {\n  assert(\"RestElement\", node, opts);\n}\nfunction assertReturnStatement(node, opts) {\n  assert(\"ReturnStatement\", node, opts);\n}\nfunction assertSequenceExpression(node, opts) {\n  assert(\"SequenceExpression\", node, opts);\n}\nfunction assertParenthesizedExpression(node, opts) {\n  assert(\"ParenthesizedExpression\", node, opts);\n}\nfunction assertSwitchCase(node, opts) {\n  assert(\"SwitchCase\", node, opts);\n}\nfunction assertSwitchStatement(node, opts) {\n  assert(\"SwitchStatement\", node, opts);\n}\nfunction assertThisExpression(node, opts) {\n  assert(\"ThisExpression\", node, opts);\n}\nfunction assertThrowStatement(node, opts) {\n  assert(\"ThrowStatement\", node, opts);\n}\nfunction assertTryStatement(node, opts) {\n  assert(\"TryStatement\", node, opts);\n}\nfunction assertUnaryExpression(node, opts) {\n  assert(\"UnaryExpression\", node, opts);\n}\nfunction assertUpdateExpression(node, opts) {\n  assert(\"UpdateExpression\", node, opts);\n}\nfunction assertVariableDeclaration(node, opts) {\n  assert(\"VariableDeclaration\", node, opts);\n}\nfunction assertVariableDeclarator(node, opts) {\n  assert(\"VariableDeclarator\", node, opts);\n}\nfunction assertWhileStatement(node, opts) {\n  assert(\"WhileStatement\", node, opts);\n}\nfunction assertWithStatement(node, opts) {\n  assert(\"WithStatement\", node, opts);\n}\nfunction assertAssignmentPattern(node, opts) {\n  assert(\"AssignmentPattern\", node, opts);\n}\nfunction assertArrayPattern(node, opts) {\n  assert(\"ArrayPattern\", node, opts);\n}\nfunction assertArrowFunctionExpression(node, opts) {\n  assert(\"ArrowFunctionExpression\", node, opts);\n}\nfunction assertClassBody(node, opts) {\n  assert(\"ClassBody\", node, opts);\n}\nfunction assertClassExpression(node, opts) {\n  assert(\"ClassExpression\", node, opts);\n}\nfunction assertClassDeclaration(node, opts) {\n  assert(\"ClassDeclaration\", node, opts);\n}\nfunction assertExportAllDeclaration(node, opts) {\n  assert(\"ExportAllDeclaration\", node, opts);\n}\nfunction assertExportDefaultDeclaration(node, opts) {\n  assert(\"ExportDefaultDeclaration\", node, opts);\n}\nfunction assertExportNamedDeclaration(node, opts) {\n  assert(\"ExportNamedDeclaration\", node, opts);\n}\nfunction assertExportSpecifier(node, opts) {\n  assert(\"ExportSpecifier\", node, opts);\n}\nfunction assertForOfStatement(node, opts) {\n  assert(\"ForOfStatement\", node, opts);\n}\nfunction assertImportDeclaration(node, opts) {\n  assert(\"ImportDeclaration\", node, opts);\n}\nfunction assertImportDefaultSpecifier(node, opts) {\n  assert(\"ImportDefaultSpecifier\", node, opts);\n}\nfunction assertImportNamespaceSpecifier(node, opts) {\n  assert(\"ImportNamespaceSpecifier\", node, opts);\n}\nfunction assertImportSpecifier(node, opts) {\n  assert(\"ImportSpecifier\", node, opts);\n}\nfunction assertImportExpression(node, opts) {\n  assert(\"ImportExpression\", node, opts);\n}\nfunction assertMetaProperty(node, opts) {\n  assert(\"MetaProperty\", node, opts);\n}\nfunction assertClassMethod(node, opts) {\n  assert(\"ClassMethod\", node, opts);\n}\nfunction assertObjectPattern(node, opts) {\n  assert(\"ObjectPattern\", node, opts);\n}\nfunction assertSpreadElement(node, opts) {\n  assert(\"SpreadElement\", node, opts);\n}\nfunction assertSuper(node, opts) {\n  assert(\"Super\", node, opts);\n}\nfunction assertTaggedTemplateExpression(node, opts) {\n  assert(\"TaggedTemplateExpression\", node, opts);\n}\nfunction assertTemplateElement(node, opts) {\n  assert(\"TemplateElement\", node, opts);\n}\nfunction assertTemplateLiteral(node, opts) {\n  assert(\"TemplateLiteral\", node, opts);\n}\nfunction assertYieldExpression(node, opts) {\n  assert(\"YieldExpression\", node, opts);\n}\nfunction assertAwaitExpression(node, opts) {\n  assert(\"AwaitExpression\", node, opts);\n}\nfunction assertImport(node, opts) {\n  assert(\"Import\", node, opts);\n}\nfunction assertBigIntLiteral(node, opts) {\n  assert(\"BigIntLiteral\", node, opts);\n}\nfunction assertExportNamespaceSpecifier(node, opts) {\n  assert(\"ExportNamespaceSpecifier\", node, opts);\n}\nfunction assertOptionalMemberExpression(node, opts) {\n  assert(\"OptionalMemberExpression\", node, opts);\n}\nfunction assertOptionalCallExpression(node, opts) {\n  assert(\"OptionalCallExpression\", node, opts);\n}\nfunction assertClassProperty(node, opts) {\n  assert(\"ClassProperty\", node, opts);\n}\nfunction assertClassAccessorProperty(node, opts) {\n  assert(\"ClassAccessorProperty\", node, opts);\n}\nfunction assertClassPrivateProperty(node, opts) {\n  assert(\"ClassPrivateProperty\", node, opts);\n}\nfunction assertClassPrivateMethod(node, opts) {\n  assert(\"ClassPrivateMethod\", node, opts);\n}\nfunction assertPrivateName(node, opts) {\n  assert(\"PrivateName\", node, opts);\n}\nfunction assertStaticBlock(node, opts) {\n  assert(\"StaticBlock\", node, opts);\n}\nfunction assertImportAttribute(node, opts) {\n  assert(\"ImportAttribute\", node, opts);\n}\nfunction assertAnyTypeAnnotation(node, opts) {\n  assert(\"AnyTypeAnnotation\", node, opts);\n}\nfunction assertArrayTypeAnnotation(node, opts) {\n  assert(\"ArrayTypeAnnotation\", node, opts);\n}\nfunction assertBooleanTypeAnnotation(node, opts) {\n  assert(\"BooleanTypeAnnotation\", node, opts);\n}\nfunction assertBooleanLiteralTypeAnnotation(node, opts) {\n  assert(\"BooleanLiteralTypeAnnotation\", node, opts);\n}\nfunction assertNullLiteralTypeAnnotation(node, opts) {\n  assert(\"NullLiteralTypeAnnotation\", node, opts);\n}\nfunction assertClassImplements(node, opts) {\n  assert(\"ClassImplements\", node, opts);\n}\nfunction assertDeclareClass(node, opts) {\n  assert(\"DeclareClass\", node, opts);\n}\nfunction assertDeclareFunction(node, opts) {\n  assert(\"DeclareFunction\", node, opts);\n}\nfunction assertDeclareInterface(node, opts) {\n  assert(\"DeclareInterface\", node, opts);\n}\nfunction assertDeclareModule(node, opts) {\n  assert(\"DeclareModule\", node, opts);\n}\nfunction assertDeclareModuleExports(node, opts) {\n  assert(\"DeclareModuleExports\", node, opts);\n}\nfunction assertDeclareTypeAlias(node, opts) {\n  assert(\"DeclareTypeAlias\", node, opts);\n}\nfunction assertDeclareOpaqueType(node, opts) {\n  assert(\"DeclareOpaqueType\", node, opts);\n}\nfunction assertDeclareVariable(node, opts) {\n  assert(\"DeclareVariable\", node, opts);\n}\nfunction assertDeclareExportDeclaration(node, opts) {\n  assert(\"DeclareExportDeclaration\", node, opts);\n}\nfunction assertDeclareExportAllDeclaration(node, opts) {\n  assert(\"DeclareExportAllDeclaration\", node, opts);\n}\nfunction assertDeclaredPredicate(node, opts) {\n  assert(\"DeclaredPredicate\", node, opts);\n}\nfunction assertExistsTypeAnnotation(node, opts) {\n  assert(\"ExistsTypeAnnotation\", node, opts);\n}\nfunction assertFunctionTypeAnnotation(node, opts) {\n  assert(\"FunctionTypeAnnotation\", node, opts);\n}\nfunction assertFunctionTypeParam(node, opts) {\n  assert(\"FunctionTypeParam\", node, opts);\n}\nfunction assertGenericTypeAnnotation(node, opts) {\n  assert(\"GenericTypeAnnotation\", node, opts);\n}\nfunction assertInferredPredicate(node, opts) {\n  assert(\"InferredPredicate\", node, opts);\n}\nfunction assertInterfaceExtends(node, opts) {\n  assert(\"InterfaceExtends\", node, opts);\n}\nfunction assertInterfaceDeclaration(node, opts) {\n  assert(\"InterfaceDeclaration\", node, opts);\n}\nfunction assertInterfaceTypeAnnotation(node, opts) {\n  assert(\"InterfaceTypeAnnotation\", node, opts);\n}\nfunction assertIntersectionTypeAnnotation(node, opts) {\n  assert(\"IntersectionTypeAnnotation\", node, opts);\n}\nfunction assertMixedTypeAnnotation(node, opts) {\n  assert(\"MixedTypeAnnotation\", node, opts);\n}\nfunction assertEmptyTypeAnnotation(node, opts) {\n  assert(\"EmptyTypeAnnotation\", node, opts);\n}\nfunction assertNullableTypeAnnotation(node, opts) {\n  assert(\"NullableTypeAnnotation\", node, opts);\n}\nfunction assertNumberLiteralTypeAnnotation(node, opts) {\n  assert(\"NumberLiteralTypeAnnotation\", node, opts);\n}\nfunction assertNumberTypeAnnotation(node, opts) {\n  assert(\"NumberTypeAnnotation\", node, opts);\n}\nfunction assertObjectTypeAnnotation(node, opts) {\n  assert(\"ObjectTypeAnnotation\", node, opts);\n}\nfunction assertObjectTypeInternalSlot(node, opts) {\n  assert(\"ObjectTypeInternalSlot\", node, opts);\n}\nfunction assertObjectTypeCallProperty(node, opts) {\n  assert(\"ObjectTypeCallProperty\", node, opts);\n}\nfunction assertObjectTypeIndexer(node, opts) {\n  assert(\"ObjectTypeIndexer\", node, opts);\n}\nfunction assertObjectTypeProperty(node, opts) {\n  assert(\"ObjectTypeProperty\", node, opts);\n}\nfunction assertObjectTypeSpreadProperty(node, opts) {\n  assert(\"ObjectTypeSpreadProperty\", node, opts);\n}\nfunction assertOpaqueType(node, opts) {\n  assert(\"OpaqueType\", node, opts);\n}\nfunction assertQualifiedTypeIdentifier(node, opts) {\n  assert(\"QualifiedTypeIdentifier\", node, opts);\n}\nfunction assertStringLiteralTypeAnnotation(node, opts) {\n  assert(\"StringLiteralTypeAnnotation\", node, opts);\n}\nfunction assertStringTypeAnnotation(node, opts) {\n  assert(\"StringTypeAnnotation\", node, opts);\n}\nfunction assertSymbolTypeAnnotation(node, opts) {\n  assert(\"SymbolTypeAnnotation\", node, opts);\n}\nfunction assertThisTypeAnnotation(node, opts) {\n  assert(\"ThisTypeAnnotation\", node, opts);\n}\nfunction assertTupleTypeAnnotation(node, opts) {\n  assert(\"TupleTypeAnnotation\", node, opts);\n}\nfunction assertTypeofTypeAnnotation(node, opts) {\n  assert(\"TypeofTypeAnnotation\", node, opts);\n}\nfunction assertTypeAlias(node, opts) {\n  assert(\"TypeAlias\", node, opts);\n}\nfunction assertTypeAnnotation(node, opts) {\n  assert(\"TypeAnnotation\", node, opts);\n}\nfunction assertTypeCastExpression(node, opts) {\n  assert(\"TypeCastExpression\", node, opts);\n}\nfunction assertTypeParameter(node, opts) {\n  assert(\"TypeParameter\", node, opts);\n}\nfunction assertTypeParameterDeclaration(node, opts) {\n  assert(\"TypeParameterDeclaration\", node, opts);\n}\nfunction assertTypeParameterInstantiation(node, opts) {\n  assert(\"TypeParameterInstantiation\", node, opts);\n}\nfunction assertUnionTypeAnnotation(node, opts) {\n  assert(\"UnionTypeAnnotation\", node, opts);\n}\nfunction assertVariance(node, opts) {\n  assert(\"Variance\", node, opts);\n}\nfunction assertVoidTypeAnnotation(node, opts) {\n  assert(\"VoidTypeAnnotation\", node, opts);\n}\nfunction assertEnumDeclaration(node, opts) {\n  assert(\"EnumDeclaration\", node, opts);\n}\nfunction assertEnumBooleanBody(node, opts) {\n  assert(\"EnumBooleanBody\", node, opts);\n}\nfunction assertEnumNumberBody(node, opts) {\n  assert(\"EnumNumberBody\", node, opts);\n}\nfunction assertEnumStringBody(node, opts) {\n  assert(\"EnumStringBody\", node, opts);\n}\nfunction assertEnumSymbolBody(node, opts) {\n  assert(\"EnumSymbolBody\", node, opts);\n}\nfunction assertEnumBooleanMember(node, opts) {\n  assert(\"EnumBooleanMember\", node, opts);\n}\nfunction assertEnumNumberMember(node, opts) {\n  assert(\"EnumNumberMember\", node, opts);\n}\nfunction assertEnumStringMember(node, opts) {\n  assert(\"EnumStringMember\", node, opts);\n}\nfunction assertEnumDefaultedMember(node, opts) {\n  assert(\"EnumDefaultedMember\", node, opts);\n}\nfunction assertIndexedAccessType(node, opts) {\n  assert(\"IndexedAccessType\", node, opts);\n}\nfunction assertOptionalIndexedAccessType(node, opts) {\n  assert(\"OptionalIndexedAccessType\", node, opts);\n}\nfunction assertJSXAttribute(node, opts) {\n  assert(\"JSXAttribute\", node, opts);\n}\nfunction assertJSXClosingElement(node, opts) {\n  assert(\"JSXClosingElement\", node, opts);\n}\nfunction assertJSXElement(node, opts) {\n  assert(\"JSXElement\", node, opts);\n}\nfunction assertJSXEmptyExpression(node, opts) {\n  assert(\"JSXEmptyExpression\", node, opts);\n}\nfunction assertJSXExpressionContainer(node, opts) {\n  assert(\"JSXExpressionContainer\", node, opts);\n}\nfunction assertJSXSpreadChild(node, opts) {\n  assert(\"JSXSpreadChild\", node, opts);\n}\nfunction assertJSXIdentifier(node, opts) {\n  assert(\"JSXIdentifier\", node, opts);\n}\nfunction assertJSXMemberExpression(node, opts) {\n  assert(\"JSXMemberExpression\", node, opts);\n}\nfunction assertJSXNamespacedName(node, opts) {\n  assert(\"JSXNamespacedName\", node, opts);\n}\nfunction assertJSXOpeningElement(node, opts) {\n  assert(\"JSXOpeningElement\", node, opts);\n}\nfunction assertJSXSpreadAttribute(node, opts) {\n  assert(\"JSXSpreadAttribute\", node, opts);\n}\nfunction assertJSXText(node, opts) {\n  assert(\"JSXText\", node, opts);\n}\nfunction assertJSXFragment(node, opts) {\n  assert(\"JSXFragment\", node, opts);\n}\nfunction assertJSXOpeningFragment(node, opts) {\n  assert(\"JSXOpeningFragment\", node, opts);\n}\nfunction assertJSXClosingFragment(node, opts) {\n  assert(\"JSXClosingFragment\", node, opts);\n}\nfunction assertNoop(node, opts) {\n  assert(\"Noop\", node, opts);\n}\nfunction assertPlaceholder(node, opts) {\n  assert(\"Placeholder\", node, opts);\n}\nfunction assertV8IntrinsicIdentifier(node, opts) {\n  assert(\"V8IntrinsicIdentifier\", node, opts);\n}\nfunction assertArgumentPlaceholder(node, opts) {\n  assert(\"ArgumentPlaceholder\", node, opts);\n}\nfunction assertBindExpression(node, opts) {\n  assert(\"BindExpression\", node, opts);\n}\nfunction assertDecorator(node, opts) {\n  assert(\"Decorator\", node, opts);\n}\nfunction assertDoExpression(node, opts) {\n  assert(\"DoExpression\", node, opts);\n}\nfunction assertExportDefaultSpecifier(node, opts) {\n  assert(\"ExportDefaultSpecifier\", node, opts);\n}\nfunction assertRecordExpression(node, opts) {\n  assert(\"RecordExpression\", node, opts);\n}\nfunction assertTupleExpression(node, opts) {\n  assert(\"TupleExpression\", node, opts);\n}\nfunction assertDecimalLiteral(node, opts) {\n  assert(\"DecimalLiteral\", node, opts);\n}\nfunction assertModuleExpression(node, opts) {\n  assert(\"ModuleExpression\", node, opts);\n}\nfunction assertTopicReference(node, opts) {\n  assert(\"TopicReference\", node, opts);\n}\nfunction assertPipelineTopicExpression(node, opts) {\n  assert(\"PipelineTopicExpression\", node, opts);\n}\nfunction assertPipelineBareFunction(node, opts) {\n  assert(\"PipelineBareFunction\", node, opts);\n}\nfunction assertPipelinePrimaryTopicReference(node, opts) {\n  assert(\"PipelinePrimaryTopicReference\", node, opts);\n}\nfunction assertVoidPattern(node, opts) {\n  assert(\"VoidPattern\", node, opts);\n}\nfunction assertTSParameterProperty(node, opts) {\n  assert(\"TSParameterProperty\", node, opts);\n}\nfunction assertTSDeclareFunction(node, opts) {\n  assert(\"TSDeclareFunction\", node, opts);\n}\nfunction assertTSDeclareMethod(node, opts) {\n  assert(\"TSDeclareMethod\", node, opts);\n}\nfunction assertTSQualifiedName(node, opts) {\n  assert(\"TSQualifiedName\", node, opts);\n}\nfunction assertTSCallSignatureDeclaration(node, opts) {\n  assert(\"TSCallSignatureDeclaration\", node, opts);\n}\nfunction assertTSConstructSignatureDeclaration(node, opts) {\n  assert(\"TSConstructSignatureDeclaration\", node, opts);\n}\nfunction assertTSPropertySignature(node, opts) {\n  assert(\"TSPropertySignature\", node, opts);\n}\nfunction assertTSMethodSignature(node, opts) {\n  assert(\"TSMethodSignature\", node, opts);\n}\nfunction assertTSIndexSignature(node, opts) {\n  assert(\"TSIndexSignature\", node, opts);\n}\nfunction assertTSAnyKeyword(node, opts) {\n  assert(\"TSAnyKeyword\", node, opts);\n}\nfunction assertTSBooleanKeyword(node, opts) {\n  assert(\"TSBooleanKeyword\", node, opts);\n}\nfunction assertTSBigIntKeyword(node, opts) {\n  assert(\"TSBigIntKeyword\", node, opts);\n}\nfunction assertTSIntrinsicKeyword(node, opts) {\n  assert(\"TSIntrinsicKeyword\", node, opts);\n}\nfunction assertTSNeverKeyword(node, opts) {\n  assert(\"TSNeverKeyword\", node, opts);\n}\nfunction assertTSNullKeyword(node, opts) {\n  assert(\"TSNullKeyword\", node, opts);\n}\nfunction assertTSNumberKeyword(node, opts) {\n  assert(\"TSNumberKeyword\", node, opts);\n}\nfunction assertTSObjectKeyword(node, opts) {\n  assert(\"TSObjectKeyword\", node, opts);\n}\nfunction assertTSStringKeyword(node, opts) {\n  assert(\"TSStringKeyword\", node, opts);\n}\nfunction assertTSSymbolKeyword(node, opts) {\n  assert(\"TSSymbolKeyword\", node, opts);\n}\nfunction assertTSUndefinedKeyword(node, opts) {\n  assert(\"TSUndefinedKeyword\", node, opts);\n}\nfunction assertTSUnknownKeyword(node, opts) {\n  assert(\"TSUnknownKeyword\", node, opts);\n}\nfunction assertTSVoidKeyword(node, opts) {\n  assert(\"TSVoidKeyword\", node, opts);\n}\nfunction assertTSThisType(node, opts) {\n  assert(\"TSThisType\", node, opts);\n}\nfunction assertTSFunctionType(node, opts) {\n  assert(\"TSFunctionType\", node, opts);\n}\nfunction assertTSConstructorType(node, opts) {\n  assert(\"TSConstructorType\", node, opts);\n}\nfunction assertTSTypeReference(node, opts) {\n  assert(\"TSTypeReference\", node, opts);\n}\nfunction assertTSTypePredicate(node, opts) {\n  assert(\"TSTypePredicate\", node, opts);\n}\nfunction assertTSTypeQuery(node, opts) {\n  assert(\"TSTypeQuery\", node, opts);\n}\nfunction assertTSTypeLiteral(node, opts) {\n  assert(\"TSTypeLiteral\", node, opts);\n}\nfunction assertTSArrayType(node, opts) {\n  assert(\"TSArrayType\", node, opts);\n}\nfunction assertTSTupleType(node, opts) {\n  assert(\"TSTupleType\", node, opts);\n}\nfunction assertTSOptionalType(node, opts) {\n  assert(\"TSOptionalType\", node, opts);\n}\nfunction assertTSRestType(node, opts) {\n  assert(\"TSRestType\", node, opts);\n}\nfunction assertTSNamedTupleMember(node, opts) {\n  assert(\"TSNamedTupleMember\", node, opts);\n}\nfunction assertTSUnionType(node, opts) {\n  assert(\"TSUnionType\", node, opts);\n}\nfunction assertTSIntersectionType(node, opts) {\n  assert(\"TSIntersectionType\", node, opts);\n}\nfunction assertTSConditionalType(node, opts) {\n  assert(\"TSConditionalType\", node, opts);\n}\nfunction assertTSInferType(node, opts) {\n  assert(\"TSInferType\", node, opts);\n}\nfunction assertTSParenthesizedType(node, opts) {\n  assert(\"TSParenthesizedType\", node, opts);\n}\nfunction assertTSTypeOperator(node, opts) {\n  assert(\"TSTypeOperator\", node, opts);\n}\nfunction assertTSIndexedAccessType(node, opts) {\n  assert(\"TSIndexedAccessType\", node, opts);\n}\nfunction assertTSMappedType(node, opts) {\n  assert(\"TSMappedType\", node, opts);\n}\nfunction assertTSTemplateLiteralType(node, opts) {\n  assert(\"TSTemplateLiteralType\", node, opts);\n}\nfunction assertTSLiteralType(node, opts) {\n  assert(\"TSLiteralType\", node, opts);\n}\nfunction assertTSExpressionWithTypeArguments(node, opts) {\n  assert(\"TSExpressionWithTypeArguments\", node, opts);\n}\nfunction assertTSInterfaceDeclaration(node, opts) {\n  assert(\"TSInterfaceDeclaration\", node, opts);\n}\nfunction assertTSInterfaceBody(node, opts) {\n  assert(\"TSInterfaceBody\", node, opts);\n}\nfunction assertTSTypeAliasDeclaration(node, opts) {\n  assert(\"TSTypeAliasDeclaration\", node, opts);\n}\nfunction assertTSInstantiationExpression(node, opts) {\n  assert(\"TSInstantiationExpression\", node, opts);\n}\nfunction assertTSAsExpression(node, opts) {\n  assert(\"TSAsExpression\", node, opts);\n}\nfunction assertTSSatisfiesExpression(node, opts) {\n  assert(\"TSSatisfiesExpression\", node, opts);\n}\nfunction assertTSTypeAssertion(node, opts) {\n  assert(\"TSTypeAssertion\", node, opts);\n}\nfunction assertTSEnumBody(node, opts) {\n  assert(\"TSEnumBody\", node, opts);\n}\nfunction assertTSEnumDeclaration(node, opts) {\n  assert(\"TSEnumDeclaration\", node, opts);\n}\nfunction assertTSEnumMember(node, opts) {\n  assert(\"TSEnumMember\", node, opts);\n}\nfunction assertTSModuleDeclaration(node, opts) {\n  assert(\"TSModuleDeclaration\", node, opts);\n}\nfunction assertTSModuleBlock(node, opts) {\n  assert(\"TSModuleBlock\", node, opts);\n}\nfunction assertTSImportType(node, opts) {\n  assert(\"TSImportType\", node, opts);\n}\nfunction assertTSImportEqualsDeclaration(node, opts) {\n  assert(\"TSImportEqualsDeclaration\", node, opts);\n}\nfunction assertTSExternalModuleReference(node, opts) {\n  assert(\"TSExternalModuleReference\", node, opts);\n}\nfunction assertTSNonNullExpression(node, opts) {\n  assert(\"TSNonNullExpression\", node, opts);\n}\nfunction assertTSExportAssignment(node, opts) {\n  assert(\"TSExportAssignment\", node, opts);\n}\nfunction assertTSNamespaceExportDeclaration(node, opts) {\n  assert(\"TSNamespaceExportDeclaration\", node, opts);\n}\nfunction assertTSTypeAnnotation(node, opts) {\n  assert(\"TSTypeAnnotation\", node, opts);\n}\nfunction assertTSTypeParameterInstantiation(node, opts) {\n  assert(\"TSTypeParameterInstantiation\", node, opts);\n}\nfunction assertTSTypeParameterDeclaration(node, opts) {\n  assert(\"TSTypeParameterDeclaration\", node, opts);\n}\nfunction assertTSTypeParameter(node, opts) {\n  assert(\"TSTypeParameter\", node, opts);\n}\nfunction assertStandardized(node, opts) {\n  assert(\"Standardized\", node, opts);\n}\nfunction assertExpression(node, opts) {\n  assert(\"Expression\", node, opts);\n}\nfunction assertBinary(node, opts) {\n  assert(\"Binary\", node, opts);\n}\nfunction assertScopable(node, opts) {\n  assert(\"Scopable\", node, opts);\n}\nfunction assertBlockParent(node, opts) {\n  assert(\"BlockParent\", node, opts);\n}\nfunction assertBlock(node, opts) {\n  assert(\"Block\", node, opts);\n}\nfunction assertStatement(node, opts) {\n  assert(\"Statement\", node, opts);\n}\nfunction assertTerminatorless(node, opts) {\n  assert(\"Terminatorless\", node, opts);\n}\nfunction assertCompletionStatement(node, opts) {\n  assert(\"CompletionStatement\", node, opts);\n}\nfunction assertConditional(node, opts) {\n  assert(\"Conditional\", node, opts);\n}\nfunction assertLoop(node, opts) {\n  assert(\"Loop\", node, opts);\n}\nfunction assertWhile(node, opts) {\n  assert(\"While\", node, opts);\n}\nfunction assertExpressionWrapper(node, opts) {\n  assert(\"ExpressionWrapper\", node, opts);\n}\nfunction assertFor(node, opts) {\n  assert(\"For\", node, opts);\n}\nfunction assertForXStatement(node, opts) {\n  assert(\"ForXStatement\", node, opts);\n}\nfunction assertFunction(node, opts) {\n  assert(\"Function\", node, opts);\n}\nfunction assertFunctionParent(node, opts) {\n  assert(\"FunctionParent\", node, opts);\n}\nfunction assertPureish(node, opts) {\n  assert(\"Pureish\", node, opts);\n}\nfunction assertDeclaration(node, opts) {\n  assert(\"Declaration\", node, opts);\n}\nfunction assertFunctionParameter(node, opts) {\n  assert(\"FunctionParameter\", node, opts);\n}\nfunction assertPatternLike(node, opts) {\n  assert(\"PatternLike\", node, opts);\n}\nfunction assertLVal(node, opts) {\n  assert(\"LVal\", node, opts);\n}\nfunction assertTSEntityName(node, opts) {\n  assert(\"TSEntityName\", node, opts);\n}\nfunction assertLiteral(node, opts) {\n  assert(\"Literal\", node, opts);\n}\nfunction assertImmutable(node, opts) {\n  assert(\"Immutable\", node, opts);\n}\nfunction assertUserWhitespacable(node, opts) {\n  assert(\"UserWhitespacable\", node, opts);\n}\nfunction assertMethod(node, opts) {\n  assert(\"Method\", node, opts);\n}\nfunction assertObjectMember(node, opts) {\n  assert(\"ObjectMember\", node, opts);\n}\nfunction assertProperty(node, opts) {\n  assert(\"Property\", node, opts);\n}\nfunction assertUnaryLike(node, opts) {\n  assert(\"UnaryLike\", node, opts);\n}\nfunction assertPattern(node, opts) {\n  assert(\"Pattern\", node, opts);\n}\nfunction assertClass(node, opts) {\n  assert(\"Class\", node, opts);\n}\nfunction assertImportOrExportDeclaration(node, opts) {\n  assert(\"ImportOrExportDeclaration\", node, opts);\n}\nfunction assertExportDeclaration(node, opts) {\n  assert(\"ExportDeclaration\", node, opts);\n}\nfunction assertModuleSpecifier(node, opts) {\n  assert(\"ModuleSpecifier\", node, opts);\n}\nfunction assertAccessor(node, opts) {\n  assert(\"Accessor\", node, opts);\n}\nfunction assertPrivate(node, opts) {\n  assert(\"Private\", node, opts);\n}\nfunction assertFlow(node, opts) {\n  assert(\"Flow\", node, opts);\n}\nfunction assertFlowType(node, opts) {\n  assert(\"FlowType\", node, opts);\n}\nfunction assertFlowBaseAnnotation(node, opts) {\n  assert(\"FlowBaseAnnotation\", node, opts);\n}\nfunction assertFlowDeclaration(node, opts) {\n  assert(\"FlowDeclaration\", node, opts);\n}\nfunction assertFlowPredicate(node, opts) {\n  assert(\"FlowPredicate\", node, opts);\n}\nfunction assertEnumBody(node, opts) {\n  assert(\"EnumBody\", node, opts);\n}\nfunction assertEnumMember(node, opts) {\n  assert(\"EnumMember\", node, opts);\n}\nfunction assertJSX(node, opts) {\n  assert(\"JSX\", node, opts);\n}\nfunction assertMiscellaneous(node, opts) {\n  assert(\"Miscellaneous\", node, opts);\n}\nfunction assertTypeScript(node, opts) {\n  assert(\"TypeScript\", node, opts);\n}\nfunction assertTSTypeElement(node, opts) {\n  assert(\"TSTypeElement\", node, opts);\n}\nfunction assertTSType(node, opts) {\n  assert(\"TSType\", node, opts);\n}\nfunction assertTSBaseType(node, opts) {\n  assert(\"TSBaseType\", node, opts);\n}\nfunction assertNumberLiteral(node, opts) {\n  (0, _deprecationWarning.default)(\"assertNumberLiteral\", \"assertNumericLiteral\");\n  assert(\"NumberLiteral\", node, opts);\n}\nfunction assertRegexLiteral(node, opts) {\n  (0, _deprecationWarning.default)(\"assertRegexLiteral\", \"assertRegExpLiteral\");\n  assert(\"RegexLiteral\", node, opts);\n}\nfunction assertRestProperty(node, opts) {\n  (0, _deprecationWarning.default)(\"assertRestProperty\", \"assertRestElement\");\n  assert(\"RestProperty\", node, opts);\n}\nfunction assertSpreadProperty(node, opts) {\n  (0, _deprecationWarning.default)(\"assertSpreadProperty\", \"assertSpreadElement\");\n  assert(\"SpreadProperty\", node, opts);\n}\nfunction assertModuleDeclaration(node, opts) {\n  (0, _deprecationWarning.default)(\"assertModuleDeclaration\", \"assertImportOrExportDeclaration\");\n  assert(\"ModuleDeclaration\", node, opts);\n}\n\n//# sourceMappingURL=index.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGJhYmVsL3R5cGVzL2xpYi9hc3NlcnRzL2dlbmVyYXRlZC9pbmRleC5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYiw4Q0FBNkM7QUFDN0M7QUFDQSxDQUFDLEVBQUM7QUFDRixzQkFBc0I7QUFDdEIsK0JBQStCO0FBQy9CLGlDQUFpQztBQUNqQyw2QkFBNkI7QUFDN0IsMEJBQTBCO0FBQzFCLGlDQUFpQztBQUNqQyxxQ0FBcUM7QUFDckMsa0NBQWtDO0FBQ2xDLCtCQUErQjtBQUMvQiw2QkFBNkI7QUFDN0IsMkJBQTJCO0FBQzNCLG9CQUFvQjtBQUNwQiw4QkFBOEI7QUFDOUIsNEJBQTRCO0FBQzVCLG1CQUFtQjtBQUNuQix5QkFBeUI7QUFDekIsNEJBQTRCO0FBQzVCLDRCQUE0QjtBQUM1QiwwQ0FBMEM7QUFDMUMsbUNBQW1DO0FBQ25DLDRCQUE0QjtBQUM1Qiw0QkFBNEI7QUFDNUIseUJBQXlCO0FBQ3pCLG1CQUFtQjtBQUNuQixtQ0FBbUM7QUFDbkMsdUJBQXVCO0FBQ3ZCLDhCQUE4QjtBQUM5Qiw2QkFBNkI7QUFDN0IsNkJBQTZCO0FBQzdCLHlCQUF5QjtBQUN6QixnQ0FBZ0M7QUFDaEMsa0NBQWtDO0FBQ2xDLDJCQUEyQjtBQUMzQixpQ0FBaUM7QUFDakMseUJBQXlCO0FBQ3pCLG1DQUFtQztBQUNuQywrQkFBK0I7QUFDL0IsK0JBQStCO0FBQy9CLDRCQUE0QjtBQUM1Qix5QkFBeUI7QUFDekIsMEJBQTBCO0FBQzFCLHlDQUF5QztBQUN6QyxzQ0FBc0M7QUFDdEMsNkJBQTZCO0FBQzdCLDhCQUE4QjtBQUM5QiwyQkFBMkI7QUFDM0Isa0NBQWtDO0FBQ2xDLCtCQUErQjtBQUMvQiw4QkFBOEI7QUFDOUIsNkJBQTZCO0FBQzdCLCtCQUErQjtBQUMvQix1QkFBdUI7QUFDdkIsdUJBQXVCO0FBQ3ZCLDhCQUE4QjtBQUM5QiwwQkFBMEI7QUFDMUIsOEJBQThCO0FBQzlCLDRCQUE0QjtBQUM1QixpQ0FBaUM7QUFDakMsc0JBQXNCO0FBQ3RCLDZCQUE2QjtBQUM3QiwrQkFBK0I7QUFDL0IsNkJBQTZCO0FBQzdCLGlDQUFpQztBQUNqQyx3QkFBd0I7QUFDeEIsNEJBQTRCO0FBQzVCLDhCQUE4QjtBQUM5Qiw0QkFBNEI7QUFDNUIsOEJBQThCO0FBQzlCLDRCQUE0QjtBQUM1QixrQ0FBa0M7QUFDbEMsa0NBQWtDO0FBQ2xDLCtCQUErQjtBQUMvQixzQ0FBc0M7QUFDdEMsb0NBQW9DO0FBQ3BDLG9DQUFvQztBQUNwQyxzQ0FBc0M7QUFDdEMsNkJBQTZCO0FBQzdCLHdCQUF3QjtBQUN4QixpQ0FBaUM7QUFDakMsK0JBQStCO0FBQy9CLGtCQUFrQjtBQUNsQixrQkFBa0I7QUFDbEIsZ0NBQWdDO0FBQ2hDLDZCQUE2QjtBQUM3QiwyQkFBMkI7QUFDM0Isc0JBQXNCO0FBQ3RCLGlCQUFpQjtBQUNqQiw0QkFBNEI7QUFDNUIsNEJBQTRCO0FBQzVCLDBCQUEwQjtBQUMxQiwyQkFBMkI7QUFDM0Isc0JBQXNCO0FBQ3RCLGlDQUFpQztBQUNqQyxnQ0FBZ0M7QUFDaEMsK0JBQStCO0FBQy9CLDRCQUE0QjtBQUM1QixvQ0FBb0M7QUFDcEMsK0JBQStCO0FBQy9CLG1DQUFtQztBQUNuQyx3QkFBd0I7QUFDeEIseUJBQXlCO0FBQ3pCLHVCQUF1QjtBQUN2QixvQkFBb0I7QUFDcEIsNkJBQTZCO0FBQzdCLCtCQUErQjtBQUMvQixvQ0FBb0M7QUFDcEMsOEJBQThCO0FBQzlCLHNDQUFzQztBQUN0Qyx1Q0FBdUM7QUFDdkMsNkJBQTZCO0FBQzdCLCtCQUErQjtBQUMvQiwrQkFBK0I7QUFDL0Isa0NBQWtDO0FBQ2xDLDhCQUE4QjtBQUM5QixxQ0FBcUM7QUFDckMsa0NBQWtDO0FBQ2xDLHdDQUF3QztBQUN4QyxpQkFBaUI7QUFDakIsMEJBQTBCO0FBQzFCLCtCQUErQjtBQUMvQixnQ0FBZ0M7QUFDaEMsd0JBQXdCO0FBQ3hCLGdDQUFnQztBQUNoQyxvQ0FBb0M7QUFDcEMseUJBQXlCO0FBQ3pCLDJCQUEyQjtBQUMzQixpQ0FBaUM7QUFDakMsK0JBQStCO0FBQy9CLCtCQUErQjtBQUMvQixnQ0FBZ0M7QUFDaEMsZ0NBQWdDO0FBQ2hDLDRCQUE0QjtBQUM1QixxQkFBcUI7QUFDckIsa0JBQWtCO0FBQ2xCLDhCQUE4QjtBQUM5QixxQkFBcUI7QUFDckIsK0JBQStCO0FBQy9CLGtCQUFrQjtBQUNsQiw4QkFBOEI7QUFDOUIsMEJBQTBCO0FBQzFCLG9CQUFvQjtBQUNwQiwyQkFBMkI7QUFDM0IsaUNBQWlDO0FBQ2pDLCtCQUErQjtBQUMvQiw4QkFBOEI7QUFDOUIsNkJBQTZCO0FBQzdCLDJCQUEyQjtBQUMzQixrQkFBa0I7QUFDbEIseUJBQXlCO0FBQ3pCLHVDQUF1QztBQUN2QyxvQ0FBb0M7QUFDcEMsMkJBQTJCO0FBQzNCLHlDQUF5QztBQUN6QyxrQ0FBa0M7QUFDbEMsNEJBQTRCO0FBQzVCLDhCQUE4QjtBQUM5QiwwQkFBMEI7QUFDMUIsMEJBQTBCO0FBQzFCLDJCQUEyQjtBQUMzQiw0QkFBNEI7QUFDNUIsa0NBQWtDO0FBQ2xDLG9DQUFvQztBQUNwQywrQkFBK0I7QUFDL0Isb0NBQW9DO0FBQ3BDLGdDQUFnQztBQUNoQyxzQ0FBc0M7QUFDdEMsd0JBQXdCO0FBQ3hCLG9DQUFvQztBQUNwQyx1Q0FBdUM7QUFDdkMsc0NBQXNDO0FBQ3RDLHFDQUFxQztBQUNyQyxxQkFBcUI7QUFDckIseUJBQXlCO0FBQ3pCLGtDQUFrQztBQUNsQywyQ0FBMkM7QUFDM0MscUNBQXFDO0FBQ3JDLHlCQUF5QjtBQUN6QixxQkFBcUI7QUFDckIseUJBQXlCO0FBQ3pCLHFCQUFxQjtBQUNyQixzQkFBc0I7QUFDdEIscUJBQXFCO0FBQ3JCLHFDQUFxQztBQUNyQyw4QkFBOEI7QUFDOUIsMkJBQTJCO0FBQzNCLDBCQUEwQjtBQUMxQix5QkFBeUI7QUFDekIsMEJBQTBCO0FBQzFCLDZCQUE2QjtBQUM3QixzQkFBc0I7QUFDdEIsZ0NBQWdDO0FBQ2hDLDJCQUEyQjtBQUMzQiw0QkFBNEI7QUFDNUIsMEJBQTBCO0FBQzFCLHVCQUF1QjtBQUN2Qix5QkFBeUI7QUFDekIsMkJBQTJCO0FBQzNCLHlDQUF5QztBQUN6QyxrQ0FBa0M7QUFDbEMsbUJBQW1CO0FBQ25CLHdCQUF3QjtBQUN4Qiw2QkFBNkI7QUFDN0Isa0NBQWtDO0FBQ2xDLDBCQUEwQjtBQUMxQix5QkFBeUI7QUFDekIsNEJBQTRCO0FBQzVCLHdCQUF3QjtBQUN4Qiw2QkFBNkI7QUFDN0IsOEJBQThCO0FBQzlCLHdDQUF3QztBQUN4QywrQkFBK0I7QUFDL0IsNkNBQTZDO0FBQzdDLCtCQUErQjtBQUMvQiwrQkFBK0I7QUFDL0IsNkJBQTZCO0FBQzdCLDBCQUEwQjtBQUMxQix3QkFBd0I7QUFDeEIsK0JBQStCO0FBQy9CLDBCQUEwQjtBQUMxQixnQ0FBZ0M7QUFDaEMsMkNBQTJDO0FBQzNDLHVDQUF1QztBQUN2Qyw0QkFBNEI7QUFDNUIsdUNBQXVDO0FBQ3ZDLDBCQUEwQjtBQUMxQiw4QkFBOEI7QUFDOUIsaUNBQWlDO0FBQ2pDLHlCQUF5QjtBQUN6Qix1Q0FBdUM7QUFDdkMsNkJBQTZCO0FBQzdCLG9DQUFvQztBQUNwQyxnQ0FBZ0M7QUFDaEMsZ0NBQWdDO0FBQ2hDLDJCQUEyQjtBQUMzQiwwQkFBMEI7QUFDMUIsK0JBQStCO0FBQy9CLDJCQUEyQjtBQUMzQixpQ0FBaUM7QUFDakMsZ0NBQWdDO0FBQ2hDLDBDQUEwQztBQUMxQyw0QkFBNEI7QUFDNUIsaUNBQWlDO0FBQ2pDLDJCQUEyQjtBQUMzQiw2QkFBNkI7QUFDN0IsNkJBQTZCO0FBQzdCLDRCQUE0QjtBQUM1QixpQ0FBaUM7QUFDakMsaUNBQWlDO0FBQ2pDLGlDQUFpQztBQUNqQyw2QkFBNkI7QUFDN0Isd0JBQXdCO0FBQ3hCLG1DQUFtQztBQUNuQyw2QkFBNkI7QUFDN0IsNkJBQTZCO0FBQzdCLG1DQUFtQztBQUNuQyx3QkFBd0I7QUFDeEIseUJBQXlCO0FBQ3pCLG9CQUFvQjtBQUNwQixvQ0FBb0M7QUFDcEMsOEJBQThCO0FBQzlCLDZCQUE2QjtBQUM3QiwyQkFBMkI7QUFDM0IsMkJBQTJCO0FBQzNCLDRCQUE0QjtBQUM1Qiw2QkFBNkI7QUFDN0Isd0NBQXdDO0FBQ3hDLDBDQUEwQztBQUMxQyw2QkFBNkI7QUFDN0IseUJBQXlCO0FBQ3pCLDZCQUE2QjtBQUM3QixnQ0FBZ0M7QUFDaEMseUJBQXlCO0FBQ3pCLDhCQUE4QjtBQUM5QiwyQkFBMkI7QUFDM0Isc0NBQXNDO0FBQ3RDLDZCQUE2QjtBQUM3Qiw2QkFBNkI7QUFDN0IsNEJBQTRCO0FBQzVCLDRCQUE0QjtBQUM1QixnQ0FBZ0M7QUFDaEMsNEJBQTRCO0FBQzVCLDRCQUE0QjtBQUM1QiwwQkFBMEI7QUFDMUIsNkJBQTZCO0FBQzdCLGlDQUFpQztBQUNqQyx1QkFBdUI7QUFDdkIsNEJBQTRCO0FBQzVCLGdDQUFnQztBQUNoQywyQkFBMkI7QUFDM0Isc0NBQXNDO0FBQ3RDLHdDQUF3QztBQUN4Qyx3QkFBd0I7QUFDeEIsa0NBQWtDO0FBQ2xDLDZCQUE2QjtBQUM3Qix1QkFBdUI7QUFDdkIsaUNBQWlDO0FBQ2pDLDhCQUE4QjtBQUM5QiwrQkFBK0I7QUFDL0IsbUNBQW1DO0FBQ25DLGlDQUFpQztBQUNqQyxnQ0FBZ0M7QUFDaEMsc0JBQXNCO0FBQ3RCLHlCQUF5QjtBQUN6QixnQ0FBZ0M7QUFDaEMsbUJBQW1CO0FBQ25CLDRCQUE0QjtBQUM1QiwyQkFBMkI7QUFDM0IsNkJBQTZCO0FBQzdCLFVBQVUsbUJBQU8sQ0FBQyxzRkFBd0I7QUFDMUMsMEJBQTBCLG1CQUFPLENBQUMsNEdBQW1DO0FBQ3JFO0FBQ0E7QUFDQSxzQ0FBc0MsS0FBSyxnQkFBZ0IscUJBQXFCLDBCQUEwQixVQUFVO0FBQ3BIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcmVwby12aXN1YWxpemVyLy4vbm9kZV9tb2R1bGVzL0BiYWJlbC90eXBlcy9saWIvYXNzZXJ0cy9nZW5lcmF0ZWQvaW5kZXguanM/MzNhMCJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuYXNzZXJ0QWNjZXNzb3IgPSBhc3NlcnRBY2Nlc3NvcjtcbmV4cG9ydHMuYXNzZXJ0QW55VHlwZUFubm90YXRpb24gPSBhc3NlcnRBbnlUeXBlQW5ub3RhdGlvbjtcbmV4cG9ydHMuYXNzZXJ0QXJndW1lbnRQbGFjZWhvbGRlciA9IGFzc2VydEFyZ3VtZW50UGxhY2Vob2xkZXI7XG5leHBvcnRzLmFzc2VydEFycmF5RXhwcmVzc2lvbiA9IGFzc2VydEFycmF5RXhwcmVzc2lvbjtcbmV4cG9ydHMuYXNzZXJ0QXJyYXlQYXR0ZXJuID0gYXNzZXJ0QXJyYXlQYXR0ZXJuO1xuZXhwb3J0cy5hc3NlcnRBcnJheVR5cGVBbm5vdGF0aW9uID0gYXNzZXJ0QXJyYXlUeXBlQW5ub3RhdGlvbjtcbmV4cG9ydHMuYXNzZXJ0QXJyb3dGdW5jdGlvbkV4cHJlc3Npb24gPSBhc3NlcnRBcnJvd0Z1bmN0aW9uRXhwcmVzc2lvbjtcbmV4cG9ydHMuYXNzZXJ0QXNzaWdubWVudEV4cHJlc3Npb24gPSBhc3NlcnRBc3NpZ25tZW50RXhwcmVzc2lvbjtcbmV4cG9ydHMuYXNzZXJ0QXNzaWdubWVudFBhdHRlcm4gPSBhc3NlcnRBc3NpZ25tZW50UGF0dGVybjtcbmV4cG9ydHMuYXNzZXJ0QXdhaXRFeHByZXNzaW9uID0gYXNzZXJ0QXdhaXRFeHByZXNzaW9uO1xuZXhwb3J0cy5hc3NlcnRCaWdJbnRMaXRlcmFsID0gYXNzZXJ0QmlnSW50TGl0ZXJhbDtcbmV4cG9ydHMuYXNzZXJ0QmluYXJ5ID0gYXNzZXJ0QmluYXJ5O1xuZXhwb3J0cy5hc3NlcnRCaW5hcnlFeHByZXNzaW9uID0gYXNzZXJ0QmluYXJ5RXhwcmVzc2lvbjtcbmV4cG9ydHMuYXNzZXJ0QmluZEV4cHJlc3Npb24gPSBhc3NlcnRCaW5kRXhwcmVzc2lvbjtcbmV4cG9ydHMuYXNzZXJ0QmxvY2sgPSBhc3NlcnRCbG9jaztcbmV4cG9ydHMuYXNzZXJ0QmxvY2tQYXJlbnQgPSBhc3NlcnRCbG9ja1BhcmVudDtcbmV4cG9ydHMuYXNzZXJ0QmxvY2tTdGF0ZW1lbnQgPSBhc3NlcnRCbG9ja1N0YXRlbWVudDtcbmV4cG9ydHMuYXNzZXJ0Qm9vbGVhbkxpdGVyYWwgPSBhc3NlcnRCb29sZWFuTGl0ZXJhbDtcbmV4cG9ydHMuYXNzZXJ0Qm9vbGVhbkxpdGVyYWxUeXBlQW5ub3RhdGlvbiA9IGFzc2VydEJvb2xlYW5MaXRlcmFsVHlwZUFubm90YXRpb247XG5leHBvcnRzLmFzc2VydEJvb2xlYW5UeXBlQW5ub3RhdGlvbiA9IGFzc2VydEJvb2xlYW5UeXBlQW5ub3RhdGlvbjtcbmV4cG9ydHMuYXNzZXJ0QnJlYWtTdGF0ZW1lbnQgPSBhc3NlcnRCcmVha1N0YXRlbWVudDtcbmV4cG9ydHMuYXNzZXJ0Q2FsbEV4cHJlc3Npb24gPSBhc3NlcnRDYWxsRXhwcmVzc2lvbjtcbmV4cG9ydHMuYXNzZXJ0Q2F0Y2hDbGF1c2UgPSBhc3NlcnRDYXRjaENsYXVzZTtcbmV4cG9ydHMuYXNzZXJ0Q2xhc3MgPSBhc3NlcnRDbGFzcztcbmV4cG9ydHMuYXNzZXJ0Q2xhc3NBY2Nlc3NvclByb3BlcnR5ID0gYXNzZXJ0Q2xhc3NBY2Nlc3NvclByb3BlcnR5O1xuZXhwb3J0cy5hc3NlcnRDbGFzc0JvZHkgPSBhc3NlcnRDbGFzc0JvZHk7XG5leHBvcnRzLmFzc2VydENsYXNzRGVjbGFyYXRpb24gPSBhc3NlcnRDbGFzc0RlY2xhcmF0aW9uO1xuZXhwb3J0cy5hc3NlcnRDbGFzc0V4cHJlc3Npb24gPSBhc3NlcnRDbGFzc0V4cHJlc3Npb247XG5leHBvcnRzLmFzc2VydENsYXNzSW1wbGVtZW50cyA9IGFzc2VydENsYXNzSW1wbGVtZW50cztcbmV4cG9ydHMuYXNzZXJ0Q2xhc3NNZXRob2QgPSBhc3NlcnRDbGFzc01ldGhvZDtcbmV4cG9ydHMuYXNzZXJ0Q2xhc3NQcml2YXRlTWV0aG9kID0gYXNzZXJ0Q2xhc3NQcml2YXRlTWV0aG9kO1xuZXhwb3J0cy5hc3NlcnRDbGFzc1ByaXZhdGVQcm9wZXJ0eSA9IGFzc2VydENsYXNzUHJpdmF0ZVByb3BlcnR5O1xuZXhwb3J0cy5hc3NlcnRDbGFzc1Byb3BlcnR5ID0gYXNzZXJ0Q2xhc3NQcm9wZXJ0eTtcbmV4cG9ydHMuYXNzZXJ0Q29tcGxldGlvblN0YXRlbWVudCA9IGFzc2VydENvbXBsZXRpb25TdGF0ZW1lbnQ7XG5leHBvcnRzLmFzc2VydENvbmRpdGlvbmFsID0gYXNzZXJ0Q29uZGl0aW9uYWw7XG5leHBvcnRzLmFzc2VydENvbmRpdGlvbmFsRXhwcmVzc2lvbiA9IGFzc2VydENvbmRpdGlvbmFsRXhwcmVzc2lvbjtcbmV4cG9ydHMuYXNzZXJ0Q29udGludWVTdGF0ZW1lbnQgPSBhc3NlcnRDb250aW51ZVN0YXRlbWVudDtcbmV4cG9ydHMuYXNzZXJ0RGVidWdnZXJTdGF0ZW1lbnQgPSBhc3NlcnREZWJ1Z2dlclN0YXRlbWVudDtcbmV4cG9ydHMuYXNzZXJ0RGVjaW1hbExpdGVyYWwgPSBhc3NlcnREZWNpbWFsTGl0ZXJhbDtcbmV4cG9ydHMuYXNzZXJ0RGVjbGFyYXRpb24gPSBhc3NlcnREZWNsYXJhdGlvbjtcbmV4cG9ydHMuYXNzZXJ0RGVjbGFyZUNsYXNzID0gYXNzZXJ0RGVjbGFyZUNsYXNzO1xuZXhwb3J0cy5hc3NlcnREZWNsYXJlRXhwb3J0QWxsRGVjbGFyYXRpb24gPSBhc3NlcnREZWNsYXJlRXhwb3J0QWxsRGVjbGFyYXRpb247XG5leHBvcnRzLmFzc2VydERlY2xhcmVFeHBvcnREZWNsYXJhdGlvbiA9IGFzc2VydERlY2xhcmVFeHBvcnREZWNsYXJhdGlvbjtcbmV4cG9ydHMuYXNzZXJ0RGVjbGFyZUZ1bmN0aW9uID0gYXNzZXJ0RGVjbGFyZUZ1bmN0aW9uO1xuZXhwb3J0cy5hc3NlcnREZWNsYXJlSW50ZXJmYWNlID0gYXNzZXJ0RGVjbGFyZUludGVyZmFjZTtcbmV4cG9ydHMuYXNzZXJ0RGVjbGFyZU1vZHVsZSA9IGFzc2VydERlY2xhcmVNb2R1bGU7XG5leHBvcnRzLmFzc2VydERlY2xhcmVNb2R1bGVFeHBvcnRzID0gYXNzZXJ0RGVjbGFyZU1vZHVsZUV4cG9ydHM7XG5leHBvcnRzLmFzc2VydERlY2xhcmVPcGFxdWVUeXBlID0gYXNzZXJ0RGVjbGFyZU9wYXF1ZVR5cGU7XG5leHBvcnRzLmFzc2VydERlY2xhcmVUeXBlQWxpYXMgPSBhc3NlcnREZWNsYXJlVHlwZUFsaWFzO1xuZXhwb3J0cy5hc3NlcnREZWNsYXJlVmFyaWFibGUgPSBhc3NlcnREZWNsYXJlVmFyaWFibGU7XG5leHBvcnRzLmFzc2VydERlY2xhcmVkUHJlZGljYXRlID0gYXNzZXJ0RGVjbGFyZWRQcmVkaWNhdGU7XG5leHBvcnRzLmFzc2VydERlY29yYXRvciA9IGFzc2VydERlY29yYXRvcjtcbmV4cG9ydHMuYXNzZXJ0RGlyZWN0aXZlID0gYXNzZXJ0RGlyZWN0aXZlO1xuZXhwb3J0cy5hc3NlcnREaXJlY3RpdmVMaXRlcmFsID0gYXNzZXJ0RGlyZWN0aXZlTGl0ZXJhbDtcbmV4cG9ydHMuYXNzZXJ0RG9FeHByZXNzaW9uID0gYXNzZXJ0RG9FeHByZXNzaW9uO1xuZXhwb3J0cy5hc3NlcnREb1doaWxlU3RhdGVtZW50ID0gYXNzZXJ0RG9XaGlsZVN0YXRlbWVudDtcbmV4cG9ydHMuYXNzZXJ0RW1wdHlTdGF0ZW1lbnQgPSBhc3NlcnRFbXB0eVN0YXRlbWVudDtcbmV4cG9ydHMuYXNzZXJ0RW1wdHlUeXBlQW5ub3RhdGlvbiA9IGFzc2VydEVtcHR5VHlwZUFubm90YXRpb247XG5leHBvcnRzLmFzc2VydEVudW1Cb2R5ID0gYXNzZXJ0RW51bUJvZHk7XG5leHBvcnRzLmFzc2VydEVudW1Cb29sZWFuQm9keSA9IGFzc2VydEVudW1Cb29sZWFuQm9keTtcbmV4cG9ydHMuYXNzZXJ0RW51bUJvb2xlYW5NZW1iZXIgPSBhc3NlcnRFbnVtQm9vbGVhbk1lbWJlcjtcbmV4cG9ydHMuYXNzZXJ0RW51bURlY2xhcmF0aW9uID0gYXNzZXJ0RW51bURlY2xhcmF0aW9uO1xuZXhwb3J0cy5hc3NlcnRFbnVtRGVmYXVsdGVkTWVtYmVyID0gYXNzZXJ0RW51bURlZmF1bHRlZE1lbWJlcjtcbmV4cG9ydHMuYXNzZXJ0RW51bU1lbWJlciA9IGFzc2VydEVudW1NZW1iZXI7XG5leHBvcnRzLmFzc2VydEVudW1OdW1iZXJCb2R5ID0gYXNzZXJ0RW51bU51bWJlckJvZHk7XG5leHBvcnRzLmFzc2VydEVudW1OdW1iZXJNZW1iZXIgPSBhc3NlcnRFbnVtTnVtYmVyTWVtYmVyO1xuZXhwb3J0cy5hc3NlcnRFbnVtU3RyaW5nQm9keSA9IGFzc2VydEVudW1TdHJpbmdCb2R5O1xuZXhwb3J0cy5hc3NlcnRFbnVtU3RyaW5nTWVtYmVyID0gYXNzZXJ0RW51bVN0cmluZ01lbWJlcjtcbmV4cG9ydHMuYXNzZXJ0RW51bVN5bWJvbEJvZHkgPSBhc3NlcnRFbnVtU3ltYm9sQm9keTtcbmV4cG9ydHMuYXNzZXJ0RXhpc3RzVHlwZUFubm90YXRpb24gPSBhc3NlcnRFeGlzdHNUeXBlQW5ub3RhdGlvbjtcbmV4cG9ydHMuYXNzZXJ0RXhwb3J0QWxsRGVjbGFyYXRpb24gPSBhc3NlcnRFeHBvcnRBbGxEZWNsYXJhdGlvbjtcbmV4cG9ydHMuYXNzZXJ0RXhwb3J0RGVjbGFyYXRpb24gPSBhc3NlcnRFeHBvcnREZWNsYXJhdGlvbjtcbmV4cG9ydHMuYXNzZXJ0RXhwb3J0RGVmYXVsdERlY2xhcmF0aW9uID0gYXNzZXJ0RXhwb3J0RGVmYXVsdERlY2xhcmF0aW9uO1xuZXhwb3J0cy5hc3NlcnRFeHBvcnREZWZhdWx0U3BlY2lmaWVyID0gYXNzZXJ0RXhwb3J0RGVmYXVsdFNwZWNpZmllcjtcbmV4cG9ydHMuYXNzZXJ0RXhwb3J0TmFtZWREZWNsYXJhdGlvbiA9IGFzc2VydEV4cG9ydE5hbWVkRGVjbGFyYXRpb247XG5leHBvcnRzLmFzc2VydEV4cG9ydE5hbWVzcGFjZVNwZWNpZmllciA9IGFzc2VydEV4cG9ydE5hbWVzcGFjZVNwZWNpZmllcjtcbmV4cG9ydHMuYXNzZXJ0RXhwb3J0U3BlY2lmaWVyID0gYXNzZXJ0RXhwb3J0U3BlY2lmaWVyO1xuZXhwb3J0cy5hc3NlcnRFeHByZXNzaW9uID0gYXNzZXJ0RXhwcmVzc2lvbjtcbmV4cG9ydHMuYXNzZXJ0RXhwcmVzc2lvblN0YXRlbWVudCA9IGFzc2VydEV4cHJlc3Npb25TdGF0ZW1lbnQ7XG5leHBvcnRzLmFzc2VydEV4cHJlc3Npb25XcmFwcGVyID0gYXNzZXJ0RXhwcmVzc2lvbldyYXBwZXI7XG5leHBvcnRzLmFzc2VydEZpbGUgPSBhc3NlcnRGaWxlO1xuZXhwb3J0cy5hc3NlcnRGbG93ID0gYXNzZXJ0RmxvdztcbmV4cG9ydHMuYXNzZXJ0Rmxvd0Jhc2VBbm5vdGF0aW9uID0gYXNzZXJ0Rmxvd0Jhc2VBbm5vdGF0aW9uO1xuZXhwb3J0cy5hc3NlcnRGbG93RGVjbGFyYXRpb24gPSBhc3NlcnRGbG93RGVjbGFyYXRpb247XG5leHBvcnRzLmFzc2VydEZsb3dQcmVkaWNhdGUgPSBhc3NlcnRGbG93UHJlZGljYXRlO1xuZXhwb3J0cy5hc3NlcnRGbG93VHlwZSA9IGFzc2VydEZsb3dUeXBlO1xuZXhwb3J0cy5hc3NlcnRGb3IgPSBhc3NlcnRGb3I7XG5leHBvcnRzLmFzc2VydEZvckluU3RhdGVtZW50ID0gYXNzZXJ0Rm9ySW5TdGF0ZW1lbnQ7XG5leHBvcnRzLmFzc2VydEZvck9mU3RhdGVtZW50ID0gYXNzZXJ0Rm9yT2ZTdGF0ZW1lbnQ7XG5leHBvcnRzLmFzc2VydEZvclN0YXRlbWVudCA9IGFzc2VydEZvclN0YXRlbWVudDtcbmV4cG9ydHMuYXNzZXJ0Rm9yWFN0YXRlbWVudCA9IGFzc2VydEZvclhTdGF0ZW1lbnQ7XG5leHBvcnRzLmFzc2VydEZ1bmN0aW9uID0gYXNzZXJ0RnVuY3Rpb247XG5leHBvcnRzLmFzc2VydEZ1bmN0aW9uRGVjbGFyYXRpb24gPSBhc3NlcnRGdW5jdGlvbkRlY2xhcmF0aW9uO1xuZXhwb3J0cy5hc3NlcnRGdW5jdGlvbkV4cHJlc3Npb24gPSBhc3NlcnRGdW5jdGlvbkV4cHJlc3Npb247XG5leHBvcnRzLmFzc2VydEZ1bmN0aW9uUGFyYW1ldGVyID0gYXNzZXJ0RnVuY3Rpb25QYXJhbWV0ZXI7XG5leHBvcnRzLmFzc2VydEZ1bmN0aW9uUGFyZW50ID0gYXNzZXJ0RnVuY3Rpb25QYXJlbnQ7XG5leHBvcnRzLmFzc2VydEZ1bmN0aW9uVHlwZUFubm90YXRpb24gPSBhc3NlcnRGdW5jdGlvblR5cGVBbm5vdGF0aW9uO1xuZXhwb3J0cy5hc3NlcnRGdW5jdGlvblR5cGVQYXJhbSA9IGFzc2VydEZ1bmN0aW9uVHlwZVBhcmFtO1xuZXhwb3J0cy5hc3NlcnRHZW5lcmljVHlwZUFubm90YXRpb24gPSBhc3NlcnRHZW5lcmljVHlwZUFubm90YXRpb247XG5leHBvcnRzLmFzc2VydElkZW50aWZpZXIgPSBhc3NlcnRJZGVudGlmaWVyO1xuZXhwb3J0cy5hc3NlcnRJZlN0YXRlbWVudCA9IGFzc2VydElmU3RhdGVtZW50O1xuZXhwb3J0cy5hc3NlcnRJbW11dGFibGUgPSBhc3NlcnRJbW11dGFibGU7XG5leHBvcnRzLmFzc2VydEltcG9ydCA9IGFzc2VydEltcG9ydDtcbmV4cG9ydHMuYXNzZXJ0SW1wb3J0QXR0cmlidXRlID0gYXNzZXJ0SW1wb3J0QXR0cmlidXRlO1xuZXhwb3J0cy5hc3NlcnRJbXBvcnREZWNsYXJhdGlvbiA9IGFzc2VydEltcG9ydERlY2xhcmF0aW9uO1xuZXhwb3J0cy5hc3NlcnRJbXBvcnREZWZhdWx0U3BlY2lmaWVyID0gYXNzZXJ0SW1wb3J0RGVmYXVsdFNwZWNpZmllcjtcbmV4cG9ydHMuYXNzZXJ0SW1wb3J0RXhwcmVzc2lvbiA9IGFzc2VydEltcG9ydEV4cHJlc3Npb247XG5leHBvcnRzLmFzc2VydEltcG9ydE5hbWVzcGFjZVNwZWNpZmllciA9IGFzc2VydEltcG9ydE5hbWVzcGFjZVNwZWNpZmllcjtcbmV4cG9ydHMuYXNzZXJ0SW1wb3J0T3JFeHBvcnREZWNsYXJhdGlvbiA9IGFzc2VydEltcG9ydE9yRXhwb3J0RGVjbGFyYXRpb247XG5leHBvcnRzLmFzc2VydEltcG9ydFNwZWNpZmllciA9IGFzc2VydEltcG9ydFNwZWNpZmllcjtcbmV4cG9ydHMuYXNzZXJ0SW5kZXhlZEFjY2Vzc1R5cGUgPSBhc3NlcnRJbmRleGVkQWNjZXNzVHlwZTtcbmV4cG9ydHMuYXNzZXJ0SW5mZXJyZWRQcmVkaWNhdGUgPSBhc3NlcnRJbmZlcnJlZFByZWRpY2F0ZTtcbmV4cG9ydHMuYXNzZXJ0SW50ZXJmYWNlRGVjbGFyYXRpb24gPSBhc3NlcnRJbnRlcmZhY2VEZWNsYXJhdGlvbjtcbmV4cG9ydHMuYXNzZXJ0SW50ZXJmYWNlRXh0ZW5kcyA9IGFzc2VydEludGVyZmFjZUV4dGVuZHM7XG5leHBvcnRzLmFzc2VydEludGVyZmFjZVR5cGVBbm5vdGF0aW9uID0gYXNzZXJ0SW50ZXJmYWNlVHlwZUFubm90YXRpb247XG5leHBvcnRzLmFzc2VydEludGVycHJldGVyRGlyZWN0aXZlID0gYXNzZXJ0SW50ZXJwcmV0ZXJEaXJlY3RpdmU7XG5leHBvcnRzLmFzc2VydEludGVyc2VjdGlvblR5cGVBbm5vdGF0aW9uID0gYXNzZXJ0SW50ZXJzZWN0aW9uVHlwZUFubm90YXRpb247XG5leHBvcnRzLmFzc2VydEpTWCA9IGFzc2VydEpTWDtcbmV4cG9ydHMuYXNzZXJ0SlNYQXR0cmlidXRlID0gYXNzZXJ0SlNYQXR0cmlidXRlO1xuZXhwb3J0cy5hc3NlcnRKU1hDbG9zaW5nRWxlbWVudCA9IGFzc2VydEpTWENsb3NpbmdFbGVtZW50O1xuZXhwb3J0cy5hc3NlcnRKU1hDbG9zaW5nRnJhZ21lbnQgPSBhc3NlcnRKU1hDbG9zaW5nRnJhZ21lbnQ7XG5leHBvcnRzLmFzc2VydEpTWEVsZW1lbnQgPSBhc3NlcnRKU1hFbGVtZW50O1xuZXhwb3J0cy5hc3NlcnRKU1hFbXB0eUV4cHJlc3Npb24gPSBhc3NlcnRKU1hFbXB0eUV4cHJlc3Npb247XG5leHBvcnRzLmFzc2VydEpTWEV4cHJlc3Npb25Db250YWluZXIgPSBhc3NlcnRKU1hFeHByZXNzaW9uQ29udGFpbmVyO1xuZXhwb3J0cy5hc3NlcnRKU1hGcmFnbWVudCA9IGFzc2VydEpTWEZyYWdtZW50O1xuZXhwb3J0cy5hc3NlcnRKU1hJZGVudGlmaWVyID0gYXNzZXJ0SlNYSWRlbnRpZmllcjtcbmV4cG9ydHMuYXNzZXJ0SlNYTWVtYmVyRXhwcmVzc2lvbiA9IGFzc2VydEpTWE1lbWJlckV4cHJlc3Npb247XG5leHBvcnRzLmFzc2VydEpTWE5hbWVzcGFjZWROYW1lID0gYXNzZXJ0SlNYTmFtZXNwYWNlZE5hbWU7XG5leHBvcnRzLmFzc2VydEpTWE9wZW5pbmdFbGVtZW50ID0gYXNzZXJ0SlNYT3BlbmluZ0VsZW1lbnQ7XG5leHBvcnRzLmFzc2VydEpTWE9wZW5pbmdGcmFnbWVudCA9IGFzc2VydEpTWE9wZW5pbmdGcmFnbWVudDtcbmV4cG9ydHMuYXNzZXJ0SlNYU3ByZWFkQXR0cmlidXRlID0gYXNzZXJ0SlNYU3ByZWFkQXR0cmlidXRlO1xuZXhwb3J0cy5hc3NlcnRKU1hTcHJlYWRDaGlsZCA9IGFzc2VydEpTWFNwcmVhZENoaWxkO1xuZXhwb3J0cy5hc3NlcnRKU1hUZXh0ID0gYXNzZXJ0SlNYVGV4dDtcbmV4cG9ydHMuYXNzZXJ0TFZhbCA9IGFzc2VydExWYWw7XG5leHBvcnRzLmFzc2VydExhYmVsZWRTdGF0ZW1lbnQgPSBhc3NlcnRMYWJlbGVkU3RhdGVtZW50O1xuZXhwb3J0cy5hc3NlcnRMaXRlcmFsID0gYXNzZXJ0TGl0ZXJhbDtcbmV4cG9ydHMuYXNzZXJ0TG9naWNhbEV4cHJlc3Npb24gPSBhc3NlcnRMb2dpY2FsRXhwcmVzc2lvbjtcbmV4cG9ydHMuYXNzZXJ0TG9vcCA9IGFzc2VydExvb3A7XG5leHBvcnRzLmFzc2VydE1lbWJlckV4cHJlc3Npb24gPSBhc3NlcnRNZW1iZXJFeHByZXNzaW9uO1xuZXhwb3J0cy5hc3NlcnRNZXRhUHJvcGVydHkgPSBhc3NlcnRNZXRhUHJvcGVydHk7XG5leHBvcnRzLmFzc2VydE1ldGhvZCA9IGFzc2VydE1ldGhvZDtcbmV4cG9ydHMuYXNzZXJ0TWlzY2VsbGFuZW91cyA9IGFzc2VydE1pc2NlbGxhbmVvdXM7XG5leHBvcnRzLmFzc2VydE1peGVkVHlwZUFubm90YXRpb24gPSBhc3NlcnRNaXhlZFR5cGVBbm5vdGF0aW9uO1xuZXhwb3J0cy5hc3NlcnRNb2R1bGVEZWNsYXJhdGlvbiA9IGFzc2VydE1vZHVsZURlY2xhcmF0aW9uO1xuZXhwb3J0cy5hc3NlcnRNb2R1bGVFeHByZXNzaW9uID0gYXNzZXJ0TW9kdWxlRXhwcmVzc2lvbjtcbmV4cG9ydHMuYXNzZXJ0TW9kdWxlU3BlY2lmaWVyID0gYXNzZXJ0TW9kdWxlU3BlY2lmaWVyO1xuZXhwb3J0cy5hc3NlcnROZXdFeHByZXNzaW9uID0gYXNzZXJ0TmV3RXhwcmVzc2lvbjtcbmV4cG9ydHMuYXNzZXJ0Tm9vcCA9IGFzc2VydE5vb3A7XG5leHBvcnRzLmFzc2VydE51bGxMaXRlcmFsID0gYXNzZXJ0TnVsbExpdGVyYWw7XG5leHBvcnRzLmFzc2VydE51bGxMaXRlcmFsVHlwZUFubm90YXRpb24gPSBhc3NlcnROdWxsTGl0ZXJhbFR5cGVBbm5vdGF0aW9uO1xuZXhwb3J0cy5hc3NlcnROdWxsYWJsZVR5cGVBbm5vdGF0aW9uID0gYXNzZXJ0TnVsbGFibGVUeXBlQW5ub3RhdGlvbjtcbmV4cG9ydHMuYXNzZXJ0TnVtYmVyTGl0ZXJhbCA9IGFzc2VydE51bWJlckxpdGVyYWw7XG5leHBvcnRzLmFzc2VydE51bWJlckxpdGVyYWxUeXBlQW5ub3RhdGlvbiA9IGFzc2VydE51bWJlckxpdGVyYWxUeXBlQW5ub3RhdGlvbjtcbmV4cG9ydHMuYXNzZXJ0TnVtYmVyVHlwZUFubm90YXRpb24gPSBhc3NlcnROdW1iZXJUeXBlQW5ub3RhdGlvbjtcbmV4cG9ydHMuYXNzZXJ0TnVtZXJpY0xpdGVyYWwgPSBhc3NlcnROdW1lcmljTGl0ZXJhbDtcbmV4cG9ydHMuYXNzZXJ0T2JqZWN0RXhwcmVzc2lvbiA9IGFzc2VydE9iamVjdEV4cHJlc3Npb247XG5leHBvcnRzLmFzc2VydE9iamVjdE1lbWJlciA9IGFzc2VydE9iamVjdE1lbWJlcjtcbmV4cG9ydHMuYXNzZXJ0T2JqZWN0TWV0aG9kID0gYXNzZXJ0T2JqZWN0TWV0aG9kO1xuZXhwb3J0cy5hc3NlcnRPYmplY3RQYXR0ZXJuID0gYXNzZXJ0T2JqZWN0UGF0dGVybjtcbmV4cG9ydHMuYXNzZXJ0T2JqZWN0UHJvcGVydHkgPSBhc3NlcnRPYmplY3RQcm9wZXJ0eTtcbmV4cG9ydHMuYXNzZXJ0T2JqZWN0VHlwZUFubm90YXRpb24gPSBhc3NlcnRPYmplY3RUeXBlQW5ub3RhdGlvbjtcbmV4cG9ydHMuYXNzZXJ0T2JqZWN0VHlwZUNhbGxQcm9wZXJ0eSA9IGFzc2VydE9iamVjdFR5cGVDYWxsUHJvcGVydHk7XG5leHBvcnRzLmFzc2VydE9iamVjdFR5cGVJbmRleGVyID0gYXNzZXJ0T2JqZWN0VHlwZUluZGV4ZXI7XG5leHBvcnRzLmFzc2VydE9iamVjdFR5cGVJbnRlcm5hbFNsb3QgPSBhc3NlcnRPYmplY3RUeXBlSW50ZXJuYWxTbG90O1xuZXhwb3J0cy5hc3NlcnRPYmplY3RUeXBlUHJvcGVydHkgPSBhc3NlcnRPYmplY3RUeXBlUHJvcGVydHk7XG5leHBvcnRzLmFzc2VydE9iamVjdFR5cGVTcHJlYWRQcm9wZXJ0eSA9IGFzc2VydE9iamVjdFR5cGVTcHJlYWRQcm9wZXJ0eTtcbmV4cG9ydHMuYXNzZXJ0T3BhcXVlVHlwZSA9IGFzc2VydE9wYXF1ZVR5cGU7XG5leHBvcnRzLmFzc2VydE9wdGlvbmFsQ2FsbEV4cHJlc3Npb24gPSBhc3NlcnRPcHRpb25hbENhbGxFeHByZXNzaW9uO1xuZXhwb3J0cy5hc3NlcnRPcHRpb25hbEluZGV4ZWRBY2Nlc3NUeXBlID0gYXNzZXJ0T3B0aW9uYWxJbmRleGVkQWNjZXNzVHlwZTtcbmV4cG9ydHMuYXNzZXJ0T3B0aW9uYWxNZW1iZXJFeHByZXNzaW9uID0gYXNzZXJ0T3B0aW9uYWxNZW1iZXJFeHByZXNzaW9uO1xuZXhwb3J0cy5hc3NlcnRQYXJlbnRoZXNpemVkRXhwcmVzc2lvbiA9IGFzc2VydFBhcmVudGhlc2l6ZWRFeHByZXNzaW9uO1xuZXhwb3J0cy5hc3NlcnRQYXR0ZXJuID0gYXNzZXJ0UGF0dGVybjtcbmV4cG9ydHMuYXNzZXJ0UGF0dGVybkxpa2UgPSBhc3NlcnRQYXR0ZXJuTGlrZTtcbmV4cG9ydHMuYXNzZXJ0UGlwZWxpbmVCYXJlRnVuY3Rpb24gPSBhc3NlcnRQaXBlbGluZUJhcmVGdW5jdGlvbjtcbmV4cG9ydHMuYXNzZXJ0UGlwZWxpbmVQcmltYXJ5VG9waWNSZWZlcmVuY2UgPSBhc3NlcnRQaXBlbGluZVByaW1hcnlUb3BpY1JlZmVyZW5jZTtcbmV4cG9ydHMuYXNzZXJ0UGlwZWxpbmVUb3BpY0V4cHJlc3Npb24gPSBhc3NlcnRQaXBlbGluZVRvcGljRXhwcmVzc2lvbjtcbmV4cG9ydHMuYXNzZXJ0UGxhY2Vob2xkZXIgPSBhc3NlcnRQbGFjZWhvbGRlcjtcbmV4cG9ydHMuYXNzZXJ0UHJpdmF0ZSA9IGFzc2VydFByaXZhdGU7XG5leHBvcnRzLmFzc2VydFByaXZhdGVOYW1lID0gYXNzZXJ0UHJpdmF0ZU5hbWU7XG5leHBvcnRzLmFzc2VydFByb2dyYW0gPSBhc3NlcnRQcm9ncmFtO1xuZXhwb3J0cy5hc3NlcnRQcm9wZXJ0eSA9IGFzc2VydFByb3BlcnR5O1xuZXhwb3J0cy5hc3NlcnRQdXJlaXNoID0gYXNzZXJ0UHVyZWlzaDtcbmV4cG9ydHMuYXNzZXJ0UXVhbGlmaWVkVHlwZUlkZW50aWZpZXIgPSBhc3NlcnRRdWFsaWZpZWRUeXBlSWRlbnRpZmllcjtcbmV4cG9ydHMuYXNzZXJ0UmVjb3JkRXhwcmVzc2lvbiA9IGFzc2VydFJlY29yZEV4cHJlc3Npb247XG5leHBvcnRzLmFzc2VydFJlZ0V4cExpdGVyYWwgPSBhc3NlcnRSZWdFeHBMaXRlcmFsO1xuZXhwb3J0cy5hc3NlcnRSZWdleExpdGVyYWwgPSBhc3NlcnRSZWdleExpdGVyYWw7XG5leHBvcnRzLmFzc2VydFJlc3RFbGVtZW50ID0gYXNzZXJ0UmVzdEVsZW1lbnQ7XG5leHBvcnRzLmFzc2VydFJlc3RQcm9wZXJ0eSA9IGFzc2VydFJlc3RQcm9wZXJ0eTtcbmV4cG9ydHMuYXNzZXJ0UmV0dXJuU3RhdGVtZW50ID0gYXNzZXJ0UmV0dXJuU3RhdGVtZW50O1xuZXhwb3J0cy5hc3NlcnRTY29wYWJsZSA9IGFzc2VydFNjb3BhYmxlO1xuZXhwb3J0cy5hc3NlcnRTZXF1ZW5jZUV4cHJlc3Npb24gPSBhc3NlcnRTZXF1ZW5jZUV4cHJlc3Npb247XG5leHBvcnRzLmFzc2VydFNwcmVhZEVsZW1lbnQgPSBhc3NlcnRTcHJlYWRFbGVtZW50O1xuZXhwb3J0cy5hc3NlcnRTcHJlYWRQcm9wZXJ0eSA9IGFzc2VydFNwcmVhZFByb3BlcnR5O1xuZXhwb3J0cy5hc3NlcnRTdGFuZGFyZGl6ZWQgPSBhc3NlcnRTdGFuZGFyZGl6ZWQ7XG5leHBvcnRzLmFzc2VydFN0YXRlbWVudCA9IGFzc2VydFN0YXRlbWVudDtcbmV4cG9ydHMuYXNzZXJ0U3RhdGljQmxvY2sgPSBhc3NlcnRTdGF0aWNCbG9jaztcbmV4cG9ydHMuYXNzZXJ0U3RyaW5nTGl0ZXJhbCA9IGFzc2VydFN0cmluZ0xpdGVyYWw7XG5leHBvcnRzLmFzc2VydFN0cmluZ0xpdGVyYWxUeXBlQW5ub3RhdGlvbiA9IGFzc2VydFN0cmluZ0xpdGVyYWxUeXBlQW5ub3RhdGlvbjtcbmV4cG9ydHMuYXNzZXJ0U3RyaW5nVHlwZUFubm90YXRpb24gPSBhc3NlcnRTdHJpbmdUeXBlQW5ub3RhdGlvbjtcbmV4cG9ydHMuYXNzZXJ0U3VwZXIgPSBhc3NlcnRTdXBlcjtcbmV4cG9ydHMuYXNzZXJ0U3dpdGNoQ2FzZSA9IGFzc2VydFN3aXRjaENhc2U7XG5leHBvcnRzLmFzc2VydFN3aXRjaFN0YXRlbWVudCA9IGFzc2VydFN3aXRjaFN0YXRlbWVudDtcbmV4cG9ydHMuYXNzZXJ0U3ltYm9sVHlwZUFubm90YXRpb24gPSBhc3NlcnRTeW1ib2xUeXBlQW5ub3RhdGlvbjtcbmV4cG9ydHMuYXNzZXJ0VFNBbnlLZXl3b3JkID0gYXNzZXJ0VFNBbnlLZXl3b3JkO1xuZXhwb3J0cy5hc3NlcnRUU0FycmF5VHlwZSA9IGFzc2VydFRTQXJyYXlUeXBlO1xuZXhwb3J0cy5hc3NlcnRUU0FzRXhwcmVzc2lvbiA9IGFzc2VydFRTQXNFeHByZXNzaW9uO1xuZXhwb3J0cy5hc3NlcnRUU0Jhc2VUeXBlID0gYXNzZXJ0VFNCYXNlVHlwZTtcbmV4cG9ydHMuYXNzZXJ0VFNCaWdJbnRLZXl3b3JkID0gYXNzZXJ0VFNCaWdJbnRLZXl3b3JkO1xuZXhwb3J0cy5hc3NlcnRUU0Jvb2xlYW5LZXl3b3JkID0gYXNzZXJ0VFNCb29sZWFuS2V5d29yZDtcbmV4cG9ydHMuYXNzZXJ0VFNDYWxsU2lnbmF0dXJlRGVjbGFyYXRpb24gPSBhc3NlcnRUU0NhbGxTaWduYXR1cmVEZWNsYXJhdGlvbjtcbmV4cG9ydHMuYXNzZXJ0VFNDb25kaXRpb25hbFR5cGUgPSBhc3NlcnRUU0NvbmRpdGlvbmFsVHlwZTtcbmV4cG9ydHMuYXNzZXJ0VFNDb25zdHJ1Y3RTaWduYXR1cmVEZWNsYXJhdGlvbiA9IGFzc2VydFRTQ29uc3RydWN0U2lnbmF0dXJlRGVjbGFyYXRpb247XG5leHBvcnRzLmFzc2VydFRTQ29uc3RydWN0b3JUeXBlID0gYXNzZXJ0VFNDb25zdHJ1Y3RvclR5cGU7XG5leHBvcnRzLmFzc2VydFRTRGVjbGFyZUZ1bmN0aW9uID0gYXNzZXJ0VFNEZWNsYXJlRnVuY3Rpb247XG5leHBvcnRzLmFzc2VydFRTRGVjbGFyZU1ldGhvZCA9IGFzc2VydFRTRGVjbGFyZU1ldGhvZDtcbmV4cG9ydHMuYXNzZXJ0VFNFbnRpdHlOYW1lID0gYXNzZXJ0VFNFbnRpdHlOYW1lO1xuZXhwb3J0cy5hc3NlcnRUU0VudW1Cb2R5ID0gYXNzZXJ0VFNFbnVtQm9keTtcbmV4cG9ydHMuYXNzZXJ0VFNFbnVtRGVjbGFyYXRpb24gPSBhc3NlcnRUU0VudW1EZWNsYXJhdGlvbjtcbmV4cG9ydHMuYXNzZXJ0VFNFbnVtTWVtYmVyID0gYXNzZXJ0VFNFbnVtTWVtYmVyO1xuZXhwb3J0cy5hc3NlcnRUU0V4cG9ydEFzc2lnbm1lbnQgPSBhc3NlcnRUU0V4cG9ydEFzc2lnbm1lbnQ7XG5leHBvcnRzLmFzc2VydFRTRXhwcmVzc2lvbldpdGhUeXBlQXJndW1lbnRzID0gYXNzZXJ0VFNFeHByZXNzaW9uV2l0aFR5cGVBcmd1bWVudHM7XG5leHBvcnRzLmFzc2VydFRTRXh0ZXJuYWxNb2R1bGVSZWZlcmVuY2UgPSBhc3NlcnRUU0V4dGVybmFsTW9kdWxlUmVmZXJlbmNlO1xuZXhwb3J0cy5hc3NlcnRUU0Z1bmN0aW9uVHlwZSA9IGFzc2VydFRTRnVuY3Rpb25UeXBlO1xuZXhwb3J0cy5hc3NlcnRUU0ltcG9ydEVxdWFsc0RlY2xhcmF0aW9uID0gYXNzZXJ0VFNJbXBvcnRFcXVhbHNEZWNsYXJhdGlvbjtcbmV4cG9ydHMuYXNzZXJ0VFNJbXBvcnRUeXBlID0gYXNzZXJ0VFNJbXBvcnRUeXBlO1xuZXhwb3J0cy5hc3NlcnRUU0luZGV4U2lnbmF0dXJlID0gYXNzZXJ0VFNJbmRleFNpZ25hdHVyZTtcbmV4cG9ydHMuYXNzZXJ0VFNJbmRleGVkQWNjZXNzVHlwZSA9IGFzc2VydFRTSW5kZXhlZEFjY2Vzc1R5cGU7XG5leHBvcnRzLmFzc2VydFRTSW5mZXJUeXBlID0gYXNzZXJ0VFNJbmZlclR5cGU7XG5leHBvcnRzLmFzc2VydFRTSW5zdGFudGlhdGlvbkV4cHJlc3Npb24gPSBhc3NlcnRUU0luc3RhbnRpYXRpb25FeHByZXNzaW9uO1xuZXhwb3J0cy5hc3NlcnRUU0ludGVyZmFjZUJvZHkgPSBhc3NlcnRUU0ludGVyZmFjZUJvZHk7XG5leHBvcnRzLmFzc2VydFRTSW50ZXJmYWNlRGVjbGFyYXRpb24gPSBhc3NlcnRUU0ludGVyZmFjZURlY2xhcmF0aW9uO1xuZXhwb3J0cy5hc3NlcnRUU0ludGVyc2VjdGlvblR5cGUgPSBhc3NlcnRUU0ludGVyc2VjdGlvblR5cGU7XG5leHBvcnRzLmFzc2VydFRTSW50cmluc2ljS2V5d29yZCA9IGFzc2VydFRTSW50cmluc2ljS2V5d29yZDtcbmV4cG9ydHMuYXNzZXJ0VFNMaXRlcmFsVHlwZSA9IGFzc2VydFRTTGl0ZXJhbFR5cGU7XG5leHBvcnRzLmFzc2VydFRTTWFwcGVkVHlwZSA9IGFzc2VydFRTTWFwcGVkVHlwZTtcbmV4cG9ydHMuYXNzZXJ0VFNNZXRob2RTaWduYXR1cmUgPSBhc3NlcnRUU01ldGhvZFNpZ25hdHVyZTtcbmV4cG9ydHMuYXNzZXJ0VFNNb2R1bGVCbG9jayA9IGFzc2VydFRTTW9kdWxlQmxvY2s7XG5leHBvcnRzLmFzc2VydFRTTW9kdWxlRGVjbGFyYXRpb24gPSBhc3NlcnRUU01vZHVsZURlY2xhcmF0aW9uO1xuZXhwb3J0cy5hc3NlcnRUU05hbWVkVHVwbGVNZW1iZXIgPSBhc3NlcnRUU05hbWVkVHVwbGVNZW1iZXI7XG5leHBvcnRzLmFzc2VydFRTTmFtZXNwYWNlRXhwb3J0RGVjbGFyYXRpb24gPSBhc3NlcnRUU05hbWVzcGFjZUV4cG9ydERlY2xhcmF0aW9uO1xuZXhwb3J0cy5hc3NlcnRUU05ldmVyS2V5d29yZCA9IGFzc2VydFRTTmV2ZXJLZXl3b3JkO1xuZXhwb3J0cy5hc3NlcnRUU05vbk51bGxFeHByZXNzaW9uID0gYXNzZXJ0VFNOb25OdWxsRXhwcmVzc2lvbjtcbmV4cG9ydHMuYXNzZXJ0VFNOdWxsS2V5d29yZCA9IGFzc2VydFRTTnVsbEtleXdvcmQ7XG5leHBvcnRzLmFzc2VydFRTTnVtYmVyS2V5d29yZCA9IGFzc2VydFRTTnVtYmVyS2V5d29yZDtcbmV4cG9ydHMuYXNzZXJ0VFNPYmplY3RLZXl3b3JkID0gYXNzZXJ0VFNPYmplY3RLZXl3b3JkO1xuZXhwb3J0cy5hc3NlcnRUU09wdGlvbmFsVHlwZSA9IGFzc2VydFRTT3B0aW9uYWxUeXBlO1xuZXhwb3J0cy5hc3NlcnRUU1BhcmFtZXRlclByb3BlcnR5ID0gYXNzZXJ0VFNQYXJhbWV0ZXJQcm9wZXJ0eTtcbmV4cG9ydHMuYXNzZXJ0VFNQYXJlbnRoZXNpemVkVHlwZSA9IGFzc2VydFRTUGFyZW50aGVzaXplZFR5cGU7XG5leHBvcnRzLmFzc2VydFRTUHJvcGVydHlTaWduYXR1cmUgPSBhc3NlcnRUU1Byb3BlcnR5U2lnbmF0dXJlO1xuZXhwb3J0cy5hc3NlcnRUU1F1YWxpZmllZE5hbWUgPSBhc3NlcnRUU1F1YWxpZmllZE5hbWU7XG5leHBvcnRzLmFzc2VydFRTUmVzdFR5cGUgPSBhc3NlcnRUU1Jlc3RUeXBlO1xuZXhwb3J0cy5hc3NlcnRUU1NhdGlzZmllc0V4cHJlc3Npb24gPSBhc3NlcnRUU1NhdGlzZmllc0V4cHJlc3Npb247XG5leHBvcnRzLmFzc2VydFRTU3RyaW5nS2V5d29yZCA9IGFzc2VydFRTU3RyaW5nS2V5d29yZDtcbmV4cG9ydHMuYXNzZXJ0VFNTeW1ib2xLZXl3b3JkID0gYXNzZXJ0VFNTeW1ib2xLZXl3b3JkO1xuZXhwb3J0cy5hc3NlcnRUU1RlbXBsYXRlTGl0ZXJhbFR5cGUgPSBhc3NlcnRUU1RlbXBsYXRlTGl0ZXJhbFR5cGU7XG5leHBvcnRzLmFzc2VydFRTVGhpc1R5cGUgPSBhc3NlcnRUU1RoaXNUeXBlO1xuZXhwb3J0cy5hc3NlcnRUU1R1cGxlVHlwZSA9IGFzc2VydFRTVHVwbGVUeXBlO1xuZXhwb3J0cy5hc3NlcnRUU1R5cGUgPSBhc3NlcnRUU1R5cGU7XG5leHBvcnRzLmFzc2VydFRTVHlwZUFsaWFzRGVjbGFyYXRpb24gPSBhc3NlcnRUU1R5cGVBbGlhc0RlY2xhcmF0aW9uO1xuZXhwb3J0cy5hc3NlcnRUU1R5cGVBbm5vdGF0aW9uID0gYXNzZXJ0VFNUeXBlQW5ub3RhdGlvbjtcbmV4cG9ydHMuYXNzZXJ0VFNUeXBlQXNzZXJ0aW9uID0gYXNzZXJ0VFNUeXBlQXNzZXJ0aW9uO1xuZXhwb3J0cy5hc3NlcnRUU1R5cGVFbGVtZW50ID0gYXNzZXJ0VFNUeXBlRWxlbWVudDtcbmV4cG9ydHMuYXNzZXJ0VFNUeXBlTGl0ZXJhbCA9IGFzc2VydFRTVHlwZUxpdGVyYWw7XG5leHBvcnRzLmFzc2VydFRTVHlwZU9wZXJhdG9yID0gYXNzZXJ0VFNUeXBlT3BlcmF0b3I7XG5leHBvcnRzLmFzc2VydFRTVHlwZVBhcmFtZXRlciA9IGFzc2VydFRTVHlwZVBhcmFtZXRlcjtcbmV4cG9ydHMuYXNzZXJ0VFNUeXBlUGFyYW1ldGVyRGVjbGFyYXRpb24gPSBhc3NlcnRUU1R5cGVQYXJhbWV0ZXJEZWNsYXJhdGlvbjtcbmV4cG9ydHMuYXNzZXJ0VFNUeXBlUGFyYW1ldGVySW5zdGFudGlhdGlvbiA9IGFzc2VydFRTVHlwZVBhcmFtZXRlckluc3RhbnRpYXRpb247XG5leHBvcnRzLmFzc2VydFRTVHlwZVByZWRpY2F0ZSA9IGFzc2VydFRTVHlwZVByZWRpY2F0ZTtcbmV4cG9ydHMuYXNzZXJ0VFNUeXBlUXVlcnkgPSBhc3NlcnRUU1R5cGVRdWVyeTtcbmV4cG9ydHMuYXNzZXJ0VFNUeXBlUmVmZXJlbmNlID0gYXNzZXJ0VFNUeXBlUmVmZXJlbmNlO1xuZXhwb3J0cy5hc3NlcnRUU1VuZGVmaW5lZEtleXdvcmQgPSBhc3NlcnRUU1VuZGVmaW5lZEtleXdvcmQ7XG5leHBvcnRzLmFzc2VydFRTVW5pb25UeXBlID0gYXNzZXJ0VFNVbmlvblR5cGU7XG5leHBvcnRzLmFzc2VydFRTVW5rbm93bktleXdvcmQgPSBhc3NlcnRUU1Vua25vd25LZXl3b3JkO1xuZXhwb3J0cy5hc3NlcnRUU1ZvaWRLZXl3b3JkID0gYXNzZXJ0VFNWb2lkS2V5d29yZDtcbmV4cG9ydHMuYXNzZXJ0VGFnZ2VkVGVtcGxhdGVFeHByZXNzaW9uID0gYXNzZXJ0VGFnZ2VkVGVtcGxhdGVFeHByZXNzaW9uO1xuZXhwb3J0cy5hc3NlcnRUZW1wbGF0ZUVsZW1lbnQgPSBhc3NlcnRUZW1wbGF0ZUVsZW1lbnQ7XG5leHBvcnRzLmFzc2VydFRlbXBsYXRlTGl0ZXJhbCA9IGFzc2VydFRlbXBsYXRlTGl0ZXJhbDtcbmV4cG9ydHMuYXNzZXJ0VGVybWluYXRvcmxlc3MgPSBhc3NlcnRUZXJtaW5hdG9ybGVzcztcbmV4cG9ydHMuYXNzZXJ0VGhpc0V4cHJlc3Npb24gPSBhc3NlcnRUaGlzRXhwcmVzc2lvbjtcbmV4cG9ydHMuYXNzZXJ0VGhpc1R5cGVBbm5vdGF0aW9uID0gYXNzZXJ0VGhpc1R5cGVBbm5vdGF0aW9uO1xuZXhwb3J0cy5hc3NlcnRUaHJvd1N0YXRlbWVudCA9IGFzc2VydFRocm93U3RhdGVtZW50O1xuZXhwb3J0cy5hc3NlcnRUb3BpY1JlZmVyZW5jZSA9IGFzc2VydFRvcGljUmVmZXJlbmNlO1xuZXhwb3J0cy5hc3NlcnRUcnlTdGF0ZW1lbnQgPSBhc3NlcnRUcnlTdGF0ZW1lbnQ7XG5leHBvcnRzLmFzc2VydFR1cGxlRXhwcmVzc2lvbiA9IGFzc2VydFR1cGxlRXhwcmVzc2lvbjtcbmV4cG9ydHMuYXNzZXJ0VHVwbGVUeXBlQW5ub3RhdGlvbiA9IGFzc2VydFR1cGxlVHlwZUFubm90YXRpb247XG5leHBvcnRzLmFzc2VydFR5cGVBbGlhcyA9IGFzc2VydFR5cGVBbGlhcztcbmV4cG9ydHMuYXNzZXJ0VHlwZUFubm90YXRpb24gPSBhc3NlcnRUeXBlQW5ub3RhdGlvbjtcbmV4cG9ydHMuYXNzZXJ0VHlwZUNhc3RFeHByZXNzaW9uID0gYXNzZXJ0VHlwZUNhc3RFeHByZXNzaW9uO1xuZXhwb3J0cy5hc3NlcnRUeXBlUGFyYW1ldGVyID0gYXNzZXJ0VHlwZVBhcmFtZXRlcjtcbmV4cG9ydHMuYXNzZXJ0VHlwZVBhcmFtZXRlckRlY2xhcmF0aW9uID0gYXNzZXJ0VHlwZVBhcmFtZXRlckRlY2xhcmF0aW9uO1xuZXhwb3J0cy5hc3NlcnRUeXBlUGFyYW1ldGVySW5zdGFudGlhdGlvbiA9IGFzc2VydFR5cGVQYXJhbWV0ZXJJbnN0YW50aWF0aW9uO1xuZXhwb3J0cy5hc3NlcnRUeXBlU2NyaXB0ID0gYXNzZXJ0VHlwZVNjcmlwdDtcbmV4cG9ydHMuYXNzZXJ0VHlwZW9mVHlwZUFubm90YXRpb24gPSBhc3NlcnRUeXBlb2ZUeXBlQW5ub3RhdGlvbjtcbmV4cG9ydHMuYXNzZXJ0VW5hcnlFeHByZXNzaW9uID0gYXNzZXJ0VW5hcnlFeHByZXNzaW9uO1xuZXhwb3J0cy5hc3NlcnRVbmFyeUxpa2UgPSBhc3NlcnRVbmFyeUxpa2U7XG5leHBvcnRzLmFzc2VydFVuaW9uVHlwZUFubm90YXRpb24gPSBhc3NlcnRVbmlvblR5cGVBbm5vdGF0aW9uO1xuZXhwb3J0cy5hc3NlcnRVcGRhdGVFeHByZXNzaW9uID0gYXNzZXJ0VXBkYXRlRXhwcmVzc2lvbjtcbmV4cG9ydHMuYXNzZXJ0VXNlcldoaXRlc3BhY2FibGUgPSBhc3NlcnRVc2VyV2hpdGVzcGFjYWJsZTtcbmV4cG9ydHMuYXNzZXJ0VjhJbnRyaW5zaWNJZGVudGlmaWVyID0gYXNzZXJ0VjhJbnRyaW5zaWNJZGVudGlmaWVyO1xuZXhwb3J0cy5hc3NlcnRWYXJpYWJsZURlY2xhcmF0aW9uID0gYXNzZXJ0VmFyaWFibGVEZWNsYXJhdGlvbjtcbmV4cG9ydHMuYXNzZXJ0VmFyaWFibGVEZWNsYXJhdG9yID0gYXNzZXJ0VmFyaWFibGVEZWNsYXJhdG9yO1xuZXhwb3J0cy5hc3NlcnRWYXJpYW5jZSA9IGFzc2VydFZhcmlhbmNlO1xuZXhwb3J0cy5hc3NlcnRWb2lkUGF0dGVybiA9IGFzc2VydFZvaWRQYXR0ZXJuO1xuZXhwb3J0cy5hc3NlcnRWb2lkVHlwZUFubm90YXRpb24gPSBhc3NlcnRWb2lkVHlwZUFubm90YXRpb247XG5leHBvcnRzLmFzc2VydFdoaWxlID0gYXNzZXJ0V2hpbGU7XG5leHBvcnRzLmFzc2VydFdoaWxlU3RhdGVtZW50ID0gYXNzZXJ0V2hpbGVTdGF0ZW1lbnQ7XG5leHBvcnRzLmFzc2VydFdpdGhTdGF0ZW1lbnQgPSBhc3NlcnRXaXRoU3RhdGVtZW50O1xuZXhwb3J0cy5hc3NlcnRZaWVsZEV4cHJlc3Npb24gPSBhc3NlcnRZaWVsZEV4cHJlc3Npb247XG52YXIgX2lzID0gcmVxdWlyZShcIi4uLy4uL3ZhbGlkYXRvcnMvaXMuanNcIik7XG52YXIgX2RlcHJlY2F0aW9uV2FybmluZyA9IHJlcXVpcmUoXCIuLi8uLi91dGlscy9kZXByZWNhdGlvbldhcm5pbmcuanNcIik7XG5mdW5jdGlvbiBhc3NlcnQodHlwZSwgbm9kZSwgb3B0cykge1xuICBpZiAoISgwLCBfaXMuZGVmYXVsdCkodHlwZSwgbm9kZSwgb3B0cykpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYEV4cGVjdGVkIHR5cGUgXCIke3R5cGV9XCIgd2l0aCBvcHRpb24gJHtKU09OLnN0cmluZ2lmeShvcHRzKX0sIGAgKyBgYnV0IGluc3RlYWQgZ290IFwiJHtub2RlLnR5cGV9XCIuYCk7XG4gIH1cbn1cbmZ1bmN0aW9uIGFzc2VydEFycmF5RXhwcmVzc2lvbihub2RlLCBvcHRzKSB7XG4gIGFzc2VydChcIkFycmF5RXhwcmVzc2lvblwiLCBub2RlLCBvcHRzKTtcbn1cbmZ1bmN0aW9uIGFzc2VydEFzc2lnbm1lbnRFeHByZXNzaW9uKG5vZGUsIG9wdHMpIHtcbiAgYXNzZXJ0KFwiQXNzaWdubWVudEV4cHJlc3Npb25cIiwgbm9kZSwgb3B0cyk7XG59XG5mdW5jdGlvbiBhc3NlcnRCaW5hcnlFeHByZXNzaW9uKG5vZGUsIG9wdHMpIHtcbiAgYXNzZXJ0KFwiQmluYXJ5RXhwcmVzc2lvblwiLCBub2RlLCBvcHRzKTtcbn1cbmZ1bmN0aW9uIGFzc2VydEludGVycHJldGVyRGlyZWN0aXZlKG5vZGUsIG9wdHMpIHtcbiAgYXNzZXJ0KFwiSW50ZXJwcmV0ZXJEaXJlY3RpdmVcIiwgbm9kZSwgb3B0cyk7XG59XG5mdW5jdGlvbiBhc3NlcnREaXJlY3RpdmUobm9kZSwgb3B0cykge1xuICBhc3NlcnQoXCJEaXJlY3RpdmVcIiwgbm9kZSwgb3B0cyk7XG59XG5mdW5jdGlvbiBhc3NlcnREaXJlY3RpdmVMaXRlcmFsKG5vZGUsIG9wdHMpIHtcbiAgYXNzZXJ0KFwiRGlyZWN0aXZlTGl0ZXJhbFwiLCBub2RlLCBvcHRzKTtcbn1cbmZ1bmN0aW9uIGFzc2VydEJsb2NrU3RhdGVtZW50KG5vZGUsIG9wdHMpIHtcbiAgYXNzZXJ0KFwiQmxvY2tTdGF0ZW1lbnRcIiwgbm9kZSwgb3B0cyk7XG59XG5mdW5jdGlvbiBhc3NlcnRCcmVha1N0YXRlbWVudChub2RlLCBvcHRzKSB7XG4gIGFzc2VydChcIkJyZWFrU3RhdGVtZW50XCIsIG5vZGUsIG9wdHMpO1xufVxuZnVuY3Rpb24gYXNzZXJ0Q2FsbEV4cHJlc3Npb24obm9kZSwgb3B0cykge1xuICBhc3NlcnQoXCJDYWxsRXhwcmVzc2lvblwiLCBub2RlLCBvcHRzKTtcbn1cbmZ1bmN0aW9uIGFzc2VydENhdGNoQ2xhdXNlKG5vZGUsIG9wdHMpIHtcbiAgYXNzZXJ0KFwiQ2F0Y2hDbGF1c2VcIiwgbm9kZSwgb3B0cyk7XG59XG5mdW5jdGlvbiBhc3NlcnRDb25kaXRpb25hbEV4cHJlc3Npb24obm9kZSwgb3B0cykge1xuICBhc3NlcnQoXCJDb25kaXRpb25hbEV4cHJlc3Npb25cIiwgbm9kZSwgb3B0cyk7XG59XG5mdW5jdGlvbiBhc3NlcnRDb250aW51ZVN0YXRlbWVudChub2RlLCBvcHRzKSB7XG4gIGFzc2VydChcIkNvbnRpbnVlU3RhdGVtZW50XCIsIG5vZGUsIG9wdHMpO1xufVxuZnVuY3Rpb24gYXNzZXJ0RGVidWdnZXJTdGF0ZW1lbnQobm9kZSwgb3B0cykge1xuICBhc3NlcnQoXCJEZWJ1Z2dlclN0YXRlbWVudFwiLCBub2RlLCBvcHRzKTtcbn1cbmZ1bmN0aW9uIGFzc2VydERvV2hpbGVTdGF0ZW1lbnQobm9kZSwgb3B0cykge1xuICBhc3NlcnQoXCJEb1doaWxlU3RhdGVtZW50XCIsIG5vZGUsIG9wdHMpO1xufVxuZnVuY3Rpb24gYXNzZXJ0RW1wdHlTdGF0ZW1lbnQobm9kZSwgb3B0cykge1xuICBhc3NlcnQoXCJFbXB0eVN0YXRlbWVudFwiLCBub2RlLCBvcHRzKTtcbn1cbmZ1bmN0aW9uIGFzc2VydEV4cHJlc3Npb25TdGF0ZW1lbnQobm9kZSwgb3B0cykge1xuICBhc3NlcnQoXCJFeHByZXNzaW9uU3RhdGVtZW50XCIsIG5vZGUsIG9wdHMpO1xufVxuZnVuY3Rpb24gYXNzZXJ0RmlsZShub2RlLCBvcHRzKSB7XG4gIGFzc2VydChcIkZpbGVcIiwgbm9kZSwgb3B0cyk7XG59XG5mdW5jdGlvbiBhc3NlcnRGb3JJblN0YXRlbWVudChub2RlLCBvcHRzKSB7XG4gIGFzc2VydChcIkZvckluU3RhdGVtZW50XCIsIG5vZGUsIG9wdHMpO1xufVxuZnVuY3Rpb24gYXNzZXJ0Rm9yU3RhdGVtZW50KG5vZGUsIG9wdHMpIHtcbiAgYXNzZXJ0KFwiRm9yU3RhdGVtZW50XCIsIG5vZGUsIG9wdHMpO1xufVxuZnVuY3Rpb24gYXNzZXJ0RnVuY3Rpb25EZWNsYXJhdGlvbihub2RlLCBvcHRzKSB7XG4gIGFzc2VydChcIkZ1bmN0aW9uRGVjbGFyYXRpb25cIiwgbm9kZSwgb3B0cyk7XG59XG5mdW5jdGlvbiBhc3NlcnRGdW5jdGlvbkV4cHJlc3Npb24obm9kZSwgb3B0cykge1xuICBhc3NlcnQoXCJGdW5jdGlvbkV4cHJlc3Npb25cIiwgbm9kZSwgb3B0cyk7XG59XG5mdW5jdGlvbiBhc3NlcnRJZGVudGlmaWVyKG5vZGUsIG9wdHMpIHtcbiAgYXNzZXJ0KFwiSWRlbnRpZmllclwiLCBub2RlLCBvcHRzKTtcbn1cbmZ1bmN0aW9uIGFzc2VydElmU3RhdGVtZW50KG5vZGUsIG9wdHMpIHtcbiAgYXNzZXJ0KFwiSWZTdGF0ZW1lbnRcIiwgbm9kZSwgb3B0cyk7XG59XG5mdW5jdGlvbiBhc3NlcnRMYWJlbGVkU3RhdGVtZW50KG5vZGUsIG9wdHMpIHtcbiAgYXNzZXJ0KFwiTGFiZWxlZFN0YXRlbWVudFwiLCBub2RlLCBvcHRzKTtcbn1cbmZ1bmN0aW9uIGFzc2VydFN0cmluZ0xpdGVyYWwobm9kZSwgb3B0cykge1xuICBhc3NlcnQoXCJTdHJpbmdMaXRlcmFsXCIsIG5vZGUsIG9wdHMpO1xufVxuZnVuY3Rpb24gYXNzZXJ0TnVtZXJpY0xpdGVyYWwobm9kZSwgb3B0cykge1xuICBhc3NlcnQoXCJOdW1lcmljTGl0ZXJhbFwiLCBub2RlLCBvcHRzKTtcbn1cbmZ1bmN0aW9uIGFzc2VydE51bGxMaXRlcmFsKG5vZGUsIG9wdHMpIHtcbiAgYXNzZXJ0KFwiTnVsbExpdGVyYWxcIiwgbm9kZSwgb3B0cyk7XG59XG5mdW5jdGlvbiBhc3NlcnRCb29sZWFuTGl0ZXJhbChub2RlLCBvcHRzKSB7XG4gIGFzc2VydChcIkJvb2xlYW5MaXRlcmFsXCIsIG5vZGUsIG9wdHMpO1xufVxuZnVuY3Rpb24gYXNzZXJ0UmVnRXhwTGl0ZXJhbChub2RlLCBvcHRzKSB7XG4gIGFzc2VydChcIlJlZ0V4cExpdGVyYWxcIiwgbm9kZSwgb3B0cyk7XG59XG5mdW5jdGlvbiBhc3NlcnRMb2dpY2FsRXhwcmVzc2lvbihub2RlLCBvcHRzKSB7XG4gIGFzc2VydChcIkxvZ2ljYWxFeHByZXNzaW9uXCIsIG5vZGUsIG9wdHMpO1xufVxuZnVuY3Rpb24gYXNzZXJ0TWVtYmVyRXhwcmVzc2lvbihub2RlLCBvcHRzKSB7XG4gIGFzc2VydChcIk1lbWJlckV4cHJlc3Npb25cIiwgbm9kZSwgb3B0cyk7XG59XG5mdW5jdGlvbiBhc3NlcnROZXdFeHByZXNzaW9uKG5vZGUsIG9wdHMpIHtcbiAgYXNzZXJ0KFwiTmV3RXhwcmVzc2lvblwiLCBub2RlLCBvcHRzKTtcbn1cbmZ1bmN0aW9uIGFzc2VydFByb2dyYW0obm9kZSwgb3B0cykge1xuICBhc3NlcnQoXCJQcm9ncmFtXCIsIG5vZGUsIG9wdHMpO1xufVxuZnVuY3Rpb24gYXNzZXJ0T2JqZWN0RXhwcmVzc2lvbihub2RlLCBvcHRzKSB7XG4gIGFzc2VydChcIk9iamVjdEV4cHJlc3Npb25cIiwgbm9kZSwgb3B0cyk7XG59XG5mdW5jdGlvbiBhc3NlcnRPYmplY3RNZXRob2Qobm9kZSwgb3B0cykge1xuICBhc3NlcnQoXCJPYmplY3RNZXRob2RcIiwgbm9kZSwgb3B0cyk7XG59XG5mdW5jdGlvbiBhc3NlcnRPYmplY3RQcm9wZXJ0eShub2RlLCBvcHRzKSB7XG4gIGFzc2VydChcIk9iamVjdFByb3BlcnR5XCIsIG5vZGUsIG9wdHMpO1xufVxuZnVuY3Rpb24gYXNzZXJ0UmVzdEVsZW1lbnQobm9kZSwgb3B0cykge1xuICBhc3NlcnQoXCJSZXN0RWxlbWVudFwiLCBub2RlLCBvcHRzKTtcbn1cbmZ1bmN0aW9uIGFzc2VydFJldHVyblN0YXRlbWVudChub2RlLCBvcHRzKSB7XG4gIGFzc2VydChcIlJldHVyblN0YXRlbWVudFwiLCBub2RlLCBvcHRzKTtcbn1cbmZ1bmN0aW9uIGFzc2VydFNlcXVlbmNlRXhwcmVzc2lvbihub2RlLCBvcHRzKSB7XG4gIGFzc2VydChcIlNlcXVlbmNlRXhwcmVzc2lvblwiLCBub2RlLCBvcHRzKTtcbn1cbmZ1bmN0aW9uIGFzc2VydFBhcmVudGhlc2l6ZWRFeHByZXNzaW9uKG5vZGUsIG9wdHMpIHtcbiAgYXNzZXJ0KFwiUGFyZW50aGVzaXplZEV4cHJlc3Npb25cIiwgbm9kZSwgb3B0cyk7XG59XG5mdW5jdGlvbiBhc3NlcnRTd2l0Y2hDYXNlKG5vZGUsIG9wdHMpIHtcbiAgYXNzZXJ0KFwiU3dpdGNoQ2FzZVwiLCBub2RlLCBvcHRzKTtcbn1cbmZ1bmN0aW9uIGFzc2VydFN3aXRjaFN0YXRlbWVudChub2RlLCBvcHRzKSB7XG4gIGFzc2VydChcIlN3aXRjaFN0YXRlbWVudFwiLCBub2RlLCBvcHRzKTtcbn1cbmZ1bmN0aW9uIGFzc2VydFRoaXNFeHByZXNzaW9uKG5vZGUsIG9wdHMpIHtcbiAgYXNzZXJ0KFwiVGhpc0V4cHJlc3Npb25cIiwgbm9kZSwgb3B0cyk7XG59XG5mdW5jdGlvbiBhc3NlcnRUaHJvd1N0YXRlbWVudChub2RlLCBvcHRzKSB7XG4gIGFzc2VydChcIlRocm93U3RhdGVtZW50XCIsIG5vZGUsIG9wdHMpO1xufVxuZnVuY3Rpb24gYXNzZXJ0VHJ5U3RhdGVtZW50KG5vZGUsIG9wdHMpIHtcbiAgYXNzZXJ0KFwiVHJ5U3RhdGVtZW50XCIsIG5vZGUsIG9wdHMpO1xufVxuZnVuY3Rpb24gYXNzZXJ0VW5hcnlFeHByZXNzaW9uKG5vZGUsIG9wdHMpIHtcbiAgYXNzZXJ0KFwiVW5hcnlFeHByZXNzaW9uXCIsIG5vZGUsIG9wdHMpO1xufVxuZnVuY3Rpb24gYXNzZXJ0VXBkYXRlRXhwcmVzc2lvbihub2RlLCBvcHRzKSB7XG4gIGFzc2VydChcIlVwZGF0ZUV4cHJlc3Npb25cIiwgbm9kZSwgb3B0cyk7XG59XG5mdW5jdGlvbiBhc3NlcnRWYXJpYWJsZURlY2xhcmF0aW9uKG5vZGUsIG9wdHMpIHtcbiAgYXNzZXJ0KFwiVmFyaWFibGVEZWNsYXJhdGlvblwiLCBub2RlLCBvcHRzKTtcbn1cbmZ1bmN0aW9uIGFzc2VydFZhcmlhYmxlRGVjbGFyYXRvcihub2RlLCBvcHRzKSB7XG4gIGFzc2VydChcIlZhcmlhYmxlRGVjbGFyYXRvclwiLCBub2RlLCBvcHRzKTtcbn1cbmZ1bmN0aW9uIGFzc2VydFdoaWxlU3RhdGVtZW50KG5vZGUsIG9wdHMpIHtcbiAgYXNzZXJ0KFwiV2hpbGVTdGF0ZW1lbnRcIiwgbm9kZSwgb3B0cyk7XG59XG5mdW5jdGlvbiBhc3NlcnRXaXRoU3RhdGVtZW50KG5vZGUsIG9wdHMpIHtcbiAgYXNzZXJ0KFwiV2l0aFN0YXRlbWVudFwiLCBub2RlLCBvcHRzKTtcbn1cbmZ1bmN0aW9uIGFzc2VydEFzc2lnbm1lbnRQYXR0ZXJuKG5vZGUsIG9wdHMpIHtcbiAgYXNzZXJ0KFwiQXNzaWdubWVudFBhdHRlcm5cIiwgbm9kZSwgb3B0cyk7XG59XG5mdW5jdGlvbiBhc3NlcnRBcnJheVBhdHRlcm4obm9kZSwgb3B0cykge1xuICBhc3NlcnQoXCJBcnJheVBhdHRlcm5cIiwgbm9kZSwgb3B0cyk7XG59XG5mdW5jdGlvbiBhc3NlcnRBcnJvd0Z1bmN0aW9uRXhwcmVzc2lvbihub2RlLCBvcHRzKSB7XG4gIGFzc2VydChcIkFycm93RnVuY3Rpb25FeHByZXNzaW9uXCIsIG5vZGUsIG9wdHMpO1xufVxuZnVuY3Rpb24gYXNzZXJ0Q2xhc3NCb2R5KG5vZGUsIG9wdHMpIHtcbiAgYXNzZXJ0KFwiQ2xhc3NCb2R5XCIsIG5vZGUsIG9wdHMpO1xufVxuZnVuY3Rpb24gYXNzZXJ0Q2xhc3NFeHByZXNzaW9uKG5vZGUsIG9wdHMpIHtcbiAgYXNzZXJ0KFwiQ2xhc3NFeHByZXNzaW9uXCIsIG5vZGUsIG9wdHMpO1xufVxuZnVuY3Rpb24gYXNzZXJ0Q2xhc3NEZWNsYXJhdGlvbihub2RlLCBvcHRzKSB7XG4gIGFzc2VydChcIkNsYXNzRGVjbGFyYXRpb25cIiwgbm9kZSwgb3B0cyk7XG59XG5mdW5jdGlvbiBhc3NlcnRFeHBvcnRBbGxEZWNsYXJhdGlvbihub2RlLCBvcHRzKSB7XG4gIGFzc2VydChcIkV4cG9ydEFsbERlY2xhcmF0aW9uXCIsIG5vZGUsIG9wdHMpO1xufVxuZnVuY3Rpb24gYXNzZXJ0RXhwb3J0RGVmYXVsdERlY2xhcmF0aW9uKG5vZGUsIG9wdHMpIHtcbiAgYXNzZXJ0KFwiRXhwb3J0RGVmYXVsdERlY2xhcmF0aW9uXCIsIG5vZGUsIG9wdHMpO1xufVxuZnVuY3Rpb24gYXNzZXJ0RXhwb3J0TmFtZWREZWNsYXJhdGlvbihub2RlLCBvcHRzKSB7XG4gIGFzc2VydChcIkV4cG9ydE5hbWVkRGVjbGFyYXRpb25cIiwgbm9kZSwgb3B0cyk7XG59XG5mdW5jdGlvbiBhc3NlcnRFeHBvcnRTcGVjaWZpZXIobm9kZSwgb3B0cykge1xuICBhc3NlcnQoXCJFeHBvcnRTcGVjaWZpZXJcIiwgbm9kZSwgb3B0cyk7XG59XG5mdW5jdGlvbiBhc3NlcnRGb3JPZlN0YXRlbWVudChub2RlLCBvcHRzKSB7XG4gIGFzc2VydChcIkZvck9mU3RhdGVtZW50XCIsIG5vZGUsIG9wdHMpO1xufVxuZnVuY3Rpb24gYXNzZXJ0SW1wb3J0RGVjbGFyYXRpb24obm9kZSwgb3B0cykge1xuICBhc3NlcnQoXCJJbXBvcnREZWNsYXJhdGlvblwiLCBub2RlLCBvcHRzKTtcbn1cbmZ1bmN0aW9uIGFzc2VydEltcG9ydERlZmF1bHRTcGVjaWZpZXIobm9kZSwgb3B0cykge1xuICBhc3NlcnQoXCJJbXBvcnREZWZhdWx0U3BlY2lmaWVyXCIsIG5vZGUsIG9wdHMpO1xufVxuZnVuY3Rpb24gYXNzZXJ0SW1wb3J0TmFtZXNwYWNlU3BlY2lmaWVyKG5vZGUsIG9wdHMpIHtcbiAgYXNzZXJ0KFwiSW1wb3J0TmFtZXNwYWNlU3BlY2lmaWVyXCIsIG5vZGUsIG9wdHMpO1xufVxuZnVuY3Rpb24gYXNzZXJ0SW1wb3J0U3BlY2lmaWVyKG5vZGUsIG9wdHMpIHtcbiAgYXNzZXJ0KFwiSW1wb3J0U3BlY2lmaWVyXCIsIG5vZGUsIG9wdHMpO1xufVxuZnVuY3Rpb24gYXNzZXJ0SW1wb3J0RXhwcmVzc2lvbihub2RlLCBvcHRzKSB7XG4gIGFzc2VydChcIkltcG9ydEV4cHJlc3Npb25cIiwgbm9kZSwgb3B0cyk7XG59XG5mdW5jdGlvbiBhc3NlcnRNZXRhUHJvcGVydHkobm9kZSwgb3B0cykge1xuICBhc3NlcnQoXCJNZXRhUHJvcGVydHlcIiwgbm9kZSwgb3B0cyk7XG59XG5mdW5jdGlvbiBhc3NlcnRDbGFzc01ldGhvZChub2RlLCBvcHRzKSB7XG4gIGFzc2VydChcIkNsYXNzTWV0aG9kXCIsIG5vZGUsIG9wdHMpO1xufVxuZnVuY3Rpb24gYXNzZXJ0T2JqZWN0UGF0dGVybihub2RlLCBvcHRzKSB7XG4gIGFzc2VydChcIk9iamVjdFBhdHRlcm5cIiwgbm9kZSwgb3B0cyk7XG59XG5mdW5jdGlvbiBhc3NlcnRTcHJlYWRFbGVtZW50KG5vZGUsIG9wdHMpIHtcbiAgYXNzZXJ0KFwiU3ByZWFkRWxlbWVudFwiLCBub2RlLCBvcHRzKTtcbn1cbmZ1bmN0aW9uIGFzc2VydFN1cGVyKG5vZGUsIG9wdHMpIHtcbiAgYXNzZXJ0KFwiU3VwZXJcIiwgbm9kZSwgb3B0cyk7XG59XG5mdW5jdGlvbiBhc3NlcnRUYWdnZWRUZW1wbGF0ZUV4cHJlc3Npb24obm9kZSwgb3B0cykge1xuICBhc3NlcnQoXCJUYWdnZWRUZW1wbGF0ZUV4cHJlc3Npb25cIiwgbm9kZSwgb3B0cyk7XG59XG5mdW5jdGlvbiBhc3NlcnRUZW1wbGF0ZUVsZW1lbnQobm9kZSwgb3B0cykge1xuICBhc3NlcnQoXCJUZW1wbGF0ZUVsZW1lbnRcIiwgbm9kZSwgb3B0cyk7XG59XG5mdW5jdGlvbiBhc3NlcnRUZW1wbGF0ZUxpdGVyYWwobm9kZSwgb3B0cykge1xuICBhc3NlcnQoXCJUZW1wbGF0ZUxpdGVyYWxcIiwgbm9kZSwgb3B0cyk7XG59XG5mdW5jdGlvbiBhc3NlcnRZaWVsZEV4cHJlc3Npb24obm9kZSwgb3B0cykge1xuICBhc3NlcnQoXCJZaWVsZEV4cHJlc3Npb25cIiwgbm9kZSwgb3B0cyk7XG59XG5mdW5jdGlvbiBhc3NlcnRBd2FpdEV4cHJlc3Npb24obm9kZSwgb3B0cykge1xuICBhc3NlcnQoXCJBd2FpdEV4cHJlc3Npb25cIiwgbm9kZSwgb3B0cyk7XG59XG5mdW5jdGlvbiBhc3NlcnRJbXBvcnQobm9kZSwgb3B0cykge1xuICBhc3NlcnQoXCJJbXBvcnRcIiwgbm9kZSwgb3B0cyk7XG59XG5mdW5jdGlvbiBhc3NlcnRCaWdJbnRMaXRlcmFsKG5vZGUsIG9wdHMpIHtcbiAgYXNzZXJ0KFwiQmlnSW50TGl0ZXJhbFwiLCBub2RlLCBvcHRzKTtcbn1cbmZ1bmN0aW9uIGFzc2VydEV4cG9ydE5hbWVzcGFjZVNwZWNpZmllcihub2RlLCBvcHRzKSB7XG4gIGFzc2VydChcIkV4cG9ydE5hbWVzcGFjZVNwZWNpZmllclwiLCBub2RlLCBvcHRzKTtcbn1cbmZ1bmN0aW9uIGFzc2VydE9wdGlvbmFsTWVtYmVyRXhwcmVzc2lvbihub2RlLCBvcHRzKSB7XG4gIGFzc2VydChcIk9wdGlvbmFsTWVtYmVyRXhwcmVzc2lvblwiLCBub2RlLCBvcHRzKTtcbn1cbmZ1bmN0aW9uIGFzc2VydE9wdGlvbmFsQ2FsbEV4cHJlc3Npb24obm9kZSwgb3B0cykge1xuICBhc3NlcnQoXCJPcHRpb25hbENhbGxFeHByZXNzaW9uXCIsIG5vZGUsIG9wdHMpO1xufVxuZnVuY3Rpb24gYXNzZXJ0Q2xhc3NQcm9wZXJ0eShub2RlLCBvcHRzKSB7XG4gIGFzc2VydChcIkNsYXNzUHJvcGVydHlcIiwgbm9kZSwgb3B0cyk7XG59XG5mdW5jdGlvbiBhc3NlcnRDbGFzc0FjY2Vzc29yUHJvcGVydHkobm9kZSwgb3B0cykge1xuICBhc3NlcnQoXCJDbGFzc0FjY2Vzc29yUHJvcGVydHlcIiwgbm9kZSwgb3B0cyk7XG59XG5mdW5jdGlvbiBhc3NlcnRDbGFzc1ByaXZhdGVQcm9wZXJ0eShub2RlLCBvcHRzKSB7XG4gIGFzc2VydChcIkNsYXNzUHJpdmF0ZVByb3BlcnR5XCIsIG5vZGUsIG9wdHMpO1xufVxuZnVuY3Rpb24gYXNzZXJ0Q2xhc3NQcml2YXRlTWV0aG9kKG5vZGUsIG9wdHMpIHtcbiAgYXNzZXJ0KFwiQ2xhc3NQcml2YXRlTWV0aG9kXCIsIG5vZGUsIG9wdHMpO1xufVxuZnVuY3Rpb24gYXNzZXJ0UHJpdmF0ZU5hbWUobm9kZSwgb3B0cykge1xuICBhc3NlcnQoXCJQcml2YXRlTmFtZVwiLCBub2RlLCBvcHRzKTtcbn1cbmZ1bmN0aW9uIGFzc2VydFN0YXRpY0Jsb2NrKG5vZGUsIG9wdHMpIHtcbiAgYXNzZXJ0KFwiU3RhdGljQmxvY2tcIiwgbm9kZSwgb3B0cyk7XG59XG5mdW5jdGlvbiBhc3NlcnRJbXBvcnRBdHRyaWJ1dGUobm9kZSwgb3B0cykge1xuICBhc3NlcnQoXCJJbXBvcnRBdHRyaWJ1dGVcIiwgbm9kZSwgb3B0cyk7XG59XG5mdW5jdGlvbiBhc3NlcnRBbnlUeXBlQW5ub3RhdGlvbihub2RlLCBvcHRzKSB7XG4gIGFzc2VydChcIkFueVR5cGVBbm5vdGF0aW9uXCIsIG5vZGUsIG9wdHMpO1xufVxuZnVuY3Rpb24gYXNzZXJ0QXJyYXlUeXBlQW5ub3RhdGlvbihub2RlLCBvcHRzKSB7XG4gIGFzc2VydChcIkFycmF5VHlwZUFubm90YXRpb25cIiwgbm9kZSwgb3B0cyk7XG59XG5mdW5jdGlvbiBhc3NlcnRCb29sZWFuVHlwZUFubm90YXRpb24obm9kZSwgb3B0cykge1xuICBhc3NlcnQoXCJCb29sZWFuVHlwZUFubm90YXRpb25cIiwgbm9kZSwgb3B0cyk7XG59XG5mdW5jdGlvbiBhc3NlcnRCb29sZWFuTGl0ZXJhbFR5cGVBbm5vdGF0aW9uKG5vZGUsIG9wdHMpIHtcbiAgYXNzZXJ0KFwiQm9vbGVhbkxpdGVyYWxUeXBlQW5ub3RhdGlvblwiLCBub2RlLCBvcHRzKTtcbn1cbmZ1bmN0aW9uIGFzc2VydE51bGxMaXRlcmFsVHlwZUFubm90YXRpb24obm9kZSwgb3B0cykge1xuICBhc3NlcnQoXCJOdWxsTGl0ZXJhbFR5cGVBbm5vdGF0aW9uXCIsIG5vZGUsIG9wdHMpO1xufVxuZnVuY3Rpb24gYXNzZXJ0Q2xhc3NJbXBsZW1lbnRzKG5vZGUsIG9wdHMpIHtcbiAgYXNzZXJ0KFwiQ2xhc3NJbXBsZW1lbnRzXCIsIG5vZGUsIG9wdHMpO1xufVxuZnVuY3Rpb24gYXNzZXJ0RGVjbGFyZUNsYXNzKG5vZGUsIG9wdHMpIHtcbiAgYXNzZXJ0KFwiRGVjbGFyZUNsYXNzXCIsIG5vZGUsIG9wdHMpO1xufVxuZnVuY3Rpb24gYXNzZXJ0RGVjbGFyZUZ1bmN0aW9uKG5vZGUsIG9wdHMpIHtcbiAgYXNzZXJ0KFwiRGVjbGFyZUZ1bmN0aW9uXCIsIG5vZGUsIG9wdHMpO1xufVxuZnVuY3Rpb24gYXNzZXJ0RGVjbGFyZUludGVyZmFjZShub2RlLCBvcHRzKSB7XG4gIGFzc2VydChcIkRlY2xhcmVJbnRlcmZhY2VcIiwgbm9kZSwgb3B0cyk7XG59XG5mdW5jdGlvbiBhc3NlcnREZWNsYXJlTW9kdWxlKG5vZGUsIG9wdHMpIHtcbiAgYXNzZXJ0KFwiRGVjbGFyZU1vZHVsZVwiLCBub2RlLCBvcHRzKTtcbn1cbmZ1bmN0aW9uIGFzc2VydERlY2xhcmVNb2R1bGVFeHBvcnRzKG5vZGUsIG9wdHMpIHtcbiAgYXNzZXJ0KFwiRGVjbGFyZU1vZHVsZUV4cG9ydHNcIiwgbm9kZSwgb3B0cyk7XG59XG5mdW5jdGlvbiBhc3NlcnREZWNsYXJlVHlwZUFsaWFzKG5vZGUsIG9wdHMpIHtcbiAgYXNzZXJ0KFwiRGVjbGFyZVR5cGVBbGlhc1wiLCBub2RlLCBvcHRzKTtcbn1cbmZ1bmN0aW9uIGFzc2VydERlY2xhcmVPcGFxdWVUeXBlKG5vZGUsIG9wdHMpIHtcbiAgYXNzZXJ0KFwiRGVjbGFyZU9wYXF1ZVR5cGVcIiwgbm9kZSwgb3B0cyk7XG59XG5mdW5jdGlvbiBhc3NlcnREZWNsYXJlVmFyaWFibGUobm9kZSwgb3B0cykge1xuICBhc3NlcnQoXCJEZWNsYXJlVmFyaWFibGVcIiwgbm9kZSwgb3B0cyk7XG59XG5mdW5jdGlvbiBhc3NlcnREZWNsYXJlRXhwb3J0RGVjbGFyYXRpb24obm9kZSwgb3B0cykge1xuICBhc3NlcnQoXCJEZWNsYXJlRXhwb3J0RGVjbGFyYXRpb25cIiwgbm9kZSwgb3B0cyk7XG59XG5mdW5jdGlvbiBhc3NlcnREZWNsYXJlRXhwb3J0QWxsRGVjbGFyYXRpb24obm9kZSwgb3B0cykge1xuICBhc3NlcnQoXCJEZWNsYXJlRXhwb3J0QWxsRGVjbGFyYXRpb25cIiwgbm9kZSwgb3B0cyk7XG59XG5mdW5jdGlvbiBhc3NlcnREZWNsYXJlZFByZWRpY2F0ZShub2RlLCBvcHRzKSB7XG4gIGFzc2VydChcIkRlY2xhcmVkUHJlZGljYXRlXCIsIG5vZGUsIG9wdHMpO1xufVxuZnVuY3Rpb24gYXNzZXJ0RXhpc3RzVHlwZUFubm90YXRpb24obm9kZSwgb3B0cykge1xuICBhc3NlcnQoXCJFeGlzdHNUeXBlQW5ub3RhdGlvblwiLCBub2RlLCBvcHRzKTtcbn1cbmZ1bmN0aW9uIGFzc2VydEZ1bmN0aW9uVHlwZUFubm90YXRpb24obm9kZSwgb3B0cykge1xuICBhc3NlcnQoXCJGdW5jdGlvblR5cGVBbm5vdGF0aW9uXCIsIG5vZGUsIG9wdHMpO1xufVxuZnVuY3Rpb24gYXNzZXJ0RnVuY3Rpb25UeXBlUGFyYW0obm9kZSwgb3B0cykge1xuICBhc3NlcnQoXCJGdW5jdGlvblR5cGVQYXJhbVwiLCBub2RlLCBvcHRzKTtcbn1cbmZ1bmN0aW9uIGFzc2VydEdlbmVyaWNUeXBlQW5ub3RhdGlvbihub2RlLCBvcHRzKSB7XG4gIGFzc2VydChcIkdlbmVyaWNUeXBlQW5ub3RhdGlvblwiLCBub2RlLCBvcHRzKTtcbn1cbmZ1bmN0aW9uIGFzc2VydEluZmVycmVkUHJlZGljYXRlKG5vZGUsIG9wdHMpIHtcbiAgYXNzZXJ0KFwiSW5mZXJyZWRQcmVkaWNhdGVcIiwgbm9kZSwgb3B0cyk7XG59XG5mdW5jdGlvbiBhc3NlcnRJbnRlcmZhY2VFeHRlbmRzKG5vZGUsIG9wdHMpIHtcbiAgYXNzZXJ0KFwiSW50ZXJmYWNlRXh0ZW5kc1wiLCBub2RlLCBvcHRzKTtcbn1cbmZ1bmN0aW9uIGFzc2VydEludGVyZmFjZURlY2xhcmF0aW9uKG5vZGUsIG9wdHMpIHtcbiAgYXNzZXJ0KFwiSW50ZXJmYWNlRGVjbGFyYXRpb25cIiwgbm9kZSwgb3B0cyk7XG59XG5mdW5jdGlvbiBhc3NlcnRJbnRlcmZhY2VUeXBlQW5ub3RhdGlvbihub2RlLCBvcHRzKSB7XG4gIGFzc2VydChcIkludGVyZmFjZVR5cGVBbm5vdGF0aW9uXCIsIG5vZGUsIG9wdHMpO1xufVxuZnVuY3Rpb24gYXNzZXJ0SW50ZXJzZWN0aW9uVHlwZUFubm90YXRpb24obm9kZSwgb3B0cykge1xuICBhc3NlcnQoXCJJbnRlcnNlY3Rpb25UeXBlQW5ub3RhdGlvblwiLCBub2RlLCBvcHRzKTtcbn1cbmZ1bmN0aW9uIGFzc2VydE1peGVkVHlwZUFubm90YXRpb24obm9kZSwgb3B0cykge1xuICBhc3NlcnQoXCJNaXhlZFR5cGVBbm5vdGF0aW9uXCIsIG5vZGUsIG9wdHMpO1xufVxuZnVuY3Rpb24gYXNzZXJ0RW1wdHlUeXBlQW5ub3RhdGlvbihub2RlLCBvcHRzKSB7XG4gIGFzc2VydChcIkVtcHR5VHlwZUFubm90YXRpb25cIiwgbm9kZSwgb3B0cyk7XG59XG5mdW5jdGlvbiBhc3NlcnROdWxsYWJsZVR5cGVBbm5vdGF0aW9uKG5vZGUsIG9wdHMpIHtcbiAgYXNzZXJ0KFwiTnVsbGFibGVUeXBlQW5ub3RhdGlvblwiLCBub2RlLCBvcHRzKTtcbn1cbmZ1bmN0aW9uIGFzc2VydE51bWJlckxpdGVyYWxUeXBlQW5ub3RhdGlvbihub2RlLCBvcHRzKSB7XG4gIGFzc2VydChcIk51bWJlckxpdGVyYWxUeXBlQW5ub3RhdGlvblwiLCBub2RlLCBvcHRzKTtcbn1cbmZ1bmN0aW9uIGFzc2VydE51bWJlclR5cGVBbm5vdGF0aW9uKG5vZGUsIG9wdHMpIHtcbiAgYXNzZXJ0KFwiTnVtYmVyVHlwZUFubm90YXRpb25cIiwgbm9kZSwgb3B0cyk7XG59XG5mdW5jdGlvbiBhc3NlcnRPYmplY3RUeXBlQW5ub3RhdGlvbihub2RlLCBvcHRzKSB7XG4gIGFzc2VydChcIk9iamVjdFR5cGVBbm5vdGF0aW9uXCIsIG5vZGUsIG9wdHMpO1xufVxuZnVuY3Rpb24gYXNzZXJ0T2JqZWN0VHlwZUludGVybmFsU2xvdChub2RlLCBvcHRzKSB7XG4gIGFzc2VydChcIk9iamVjdFR5cGVJbnRlcm5hbFNsb3RcIiwgbm9kZSwgb3B0cyk7XG59XG5mdW5jdGlvbiBhc3NlcnRPYmplY3RUeXBlQ2FsbFByb3BlcnR5KG5vZGUsIG9wdHMpIHtcbiAgYXNzZXJ0KFwiT2JqZWN0VHlwZUNhbGxQcm9wZXJ0eVwiLCBub2RlLCBvcHRzKTtcbn1cbmZ1bmN0aW9uIGFzc2VydE9iamVjdFR5cGVJbmRleGVyKG5vZGUsIG9wdHMpIHtcbiAgYXNzZXJ0KFwiT2JqZWN0VHlwZUluZGV4ZXJcIiwgbm9kZSwgb3B0cyk7XG59XG5mdW5jdGlvbiBhc3NlcnRPYmplY3RUeXBlUHJvcGVydHkobm9kZSwgb3B0cykge1xuICBhc3NlcnQoXCJPYmplY3RUeXBlUHJvcGVydHlcIiwgbm9kZSwgb3B0cyk7XG59XG5mdW5jdGlvbiBhc3NlcnRPYmplY3RUeXBlU3ByZWFkUHJvcGVydHkobm9kZSwgb3B0cykge1xuICBhc3NlcnQoXCJPYmplY3RUeXBlU3ByZWFkUHJvcGVydHlcIiwgbm9kZSwgb3B0cyk7XG59XG5mdW5jdGlvbiBhc3NlcnRPcGFxdWVUeXBlKG5vZGUsIG9wdHMpIHtcbiAgYXNzZXJ0KFwiT3BhcXVlVHlwZVwiLCBub2RlLCBvcHRzKTtcbn1cbmZ1bmN0aW9uIGFzc2VydFF1YWxpZmllZFR5cGVJZGVudGlmaWVyKG5vZGUsIG9wdHMpIHtcbiAgYXNzZXJ0KFwiUXVhbGlmaWVkVHlwZUlkZW50aWZpZXJcIiwgbm9kZSwgb3B0cyk7XG59XG5mdW5jdGlvbiBhc3NlcnRTdHJpbmdMaXRlcmFsVHlwZUFubm90YXRpb24obm9kZSwgb3B0cykge1xuICBhc3NlcnQoXCJTdHJpbmdMaXRlcmFsVHlwZUFubm90YXRpb25cIiwgbm9kZSwgb3B0cyk7XG59XG5mdW5jdGlvbiBhc3NlcnRTdHJpbmdUeXBlQW5ub3RhdGlvbihub2RlLCBvcHRzKSB7XG4gIGFzc2VydChcIlN0cmluZ1R5cGVBbm5vdGF0aW9uXCIsIG5vZGUsIG9wdHMpO1xufVxuZnVuY3Rpb24gYXNzZXJ0U3ltYm9sVHlwZUFubm90YXRpb24obm9kZSwgb3B0cykge1xuICBhc3NlcnQoXCJTeW1ib2xUeXBlQW5ub3RhdGlvblwiLCBub2RlLCBvcHRzKTtcbn1cbmZ1bmN0aW9uIGFzc2VydFRoaXNUeXBlQW5ub3RhdGlvbihub2RlLCBvcHRzKSB7XG4gIGFzc2VydChcIlRoaXNUeXBlQW5ub3RhdGlvblwiLCBub2RlLCBvcHRzKTtcbn1cbmZ1bmN0aW9uIGFzc2VydFR1cGxlVHlwZUFubm90YXRpb24obm9kZSwgb3B0cykge1xuICBhc3NlcnQoXCJUdXBsZVR5cGVBbm5vdGF0aW9uXCIsIG5vZGUsIG9wdHMpO1xufVxuZnVuY3Rpb24gYXNzZXJ0VHlwZW9mVHlwZUFubm90YXRpb24obm9kZSwgb3B0cykge1xuICBhc3NlcnQoXCJUeXBlb2ZUeXBlQW5ub3RhdGlvblwiLCBub2RlLCBvcHRzKTtcbn1cbmZ1bmN0aW9uIGFzc2VydFR5cGVBbGlhcyhub2RlLCBvcHRzKSB7XG4gIGFzc2VydChcIlR5cGVBbGlhc1wiLCBub2RlLCBvcHRzKTtcbn1cbmZ1bmN0aW9uIGFzc2VydFR5cGVBbm5vdGF0aW9uKG5vZGUsIG9wdHMpIHtcbiAgYXNzZXJ0KFwiVHlwZUFubm90YXRpb25cIiwgbm9kZSwgb3B0cyk7XG59XG5mdW5jdGlvbiBhc3NlcnRUeXBlQ2FzdEV4cHJlc3Npb24obm9kZSwgb3B0cykge1xuICBhc3NlcnQoXCJUeXBlQ2FzdEV4cHJlc3Npb25cIiwgbm9kZSwgb3B0cyk7XG59XG5mdW5jdGlvbiBhc3NlcnRUeXBlUGFyYW1ldGVyKG5vZGUsIG9wdHMpIHtcbiAgYXNzZXJ0KFwiVHlwZVBhcmFtZXRlclwiLCBub2RlLCBvcHRzKTtcbn1cbmZ1bmN0aW9uIGFzc2VydFR5cGVQYXJhbWV0ZXJEZWNsYXJhdGlvbihub2RlLCBvcHRzKSB7XG4gIGFzc2VydChcIlR5cGVQYXJhbWV0ZXJEZWNsYXJhdGlvblwiLCBub2RlLCBvcHRzKTtcbn1cbmZ1bmN0aW9uIGFzc2VydFR5cGVQYXJhbWV0ZXJJbnN0YW50aWF0aW9uKG5vZGUsIG9wdHMpIHtcbiAgYXNzZXJ0KFwiVHlwZVBhcmFtZXRlckluc3RhbnRpYXRpb25cIiwgbm9kZSwgb3B0cyk7XG59XG5mdW5jdGlvbiBhc3NlcnRVbmlvblR5cGVBbm5vdGF0aW9uKG5vZGUsIG9wdHMpIHtcbiAgYXNzZXJ0KFwiVW5pb25UeXBlQW5ub3RhdGlvblwiLCBub2RlLCBvcHRzKTtcbn1cbmZ1bmN0aW9uIGFzc2VydFZhcmlhbmNlKG5vZGUsIG9wdHMpIHtcbiAgYXNzZXJ0KFwiVmFyaWFuY2VcIiwgbm9kZSwgb3B0cyk7XG59XG5mdW5jdGlvbiBhc3NlcnRWb2lkVHlwZUFubm90YXRpb24obm9kZSwgb3B0cykge1xuICBhc3NlcnQoXCJWb2lkVHlwZUFubm90YXRpb25cIiwgbm9kZSwgb3B0cyk7XG59XG5mdW5jdGlvbiBhc3NlcnRFbnVtRGVjbGFyYXRpb24obm9kZSwgb3B0cykge1xuICBhc3NlcnQoXCJFbnVtRGVjbGFyYXRpb25cIiwgbm9kZSwgb3B0cyk7XG59XG5mdW5jdGlvbiBhc3NlcnRFbnVtQm9vbGVhbkJvZHkobm9kZSwgb3B0cykge1xuICBhc3NlcnQoXCJFbnVtQm9vbGVhbkJvZHlcIiwgbm9kZSwgb3B0cyk7XG59XG5mdW5jdGlvbiBhc3NlcnRFbnVtTnVtYmVyQm9keShub2RlLCBvcHRzKSB7XG4gIGFzc2VydChcIkVudW1OdW1iZXJCb2R5XCIsIG5vZGUsIG9wdHMpO1xufVxuZnVuY3Rpb24gYXNzZXJ0RW51bVN0cmluZ0JvZHkobm9kZSwgb3B0cykge1xuICBhc3NlcnQoXCJFbnVtU3RyaW5nQm9keVwiLCBub2RlLCBvcHRzKTtcbn1cbmZ1bmN0aW9uIGFzc2VydEVudW1TeW1ib2xCb2R5KG5vZGUsIG9wdHMpIHtcbiAgYXNzZXJ0KFwiRW51bVN5bWJvbEJvZHlcIiwgbm9kZSwgb3B0cyk7XG59XG5mdW5jdGlvbiBhc3NlcnRFbnVtQm9vbGVhbk1lbWJlcihub2RlLCBvcHRzKSB7XG4gIGFzc2VydChcIkVudW1Cb29sZWFuTWVtYmVyXCIsIG5vZGUsIG9wdHMpO1xufVxuZnVuY3Rpb24gYXNzZXJ0RW51bU51bWJlck1lbWJlcihub2RlLCBvcHRzKSB7XG4gIGFzc2VydChcIkVudW1OdW1iZXJNZW1iZXJcIiwgbm9kZSwgb3B0cyk7XG59XG5mdW5jdGlvbiBhc3NlcnRFbnVtU3RyaW5nTWVtYmVyKG5vZGUsIG9wdHMpIHtcbiAgYXNzZXJ0KFwiRW51bVN0cmluZ01lbWJlclwiLCBub2RlLCBvcHRzKTtcbn1cbmZ1bmN0aW9uIGFzc2VydEVudW1EZWZhdWx0ZWRNZW1iZXIobm9kZSwgb3B0cykge1xuICBhc3NlcnQoXCJFbnVtRGVmYXVsdGVkTWVtYmVyXCIsIG5vZGUsIG9wdHMpO1xufVxuZnVuY3Rpb24gYXNzZXJ0SW5kZXhlZEFjY2Vzc1R5cGUobm9kZSwgb3B0cykge1xuICBhc3NlcnQoXCJJbmRleGVkQWNjZXNzVHlwZVwiLCBub2RlLCBvcHRzKTtcbn1cbmZ1bmN0aW9uIGFzc2VydE9wdGlvbmFsSW5kZXhlZEFjY2Vzc1R5cGUobm9kZSwgb3B0cykge1xuICBhc3NlcnQoXCJPcHRpb25hbEluZGV4ZWRBY2Nlc3NUeXBlXCIsIG5vZGUsIG9wdHMpO1xufVxuZnVuY3Rpb24gYXNzZXJ0SlNYQXR0cmlidXRlKG5vZGUsIG9wdHMpIHtcbiAgYXNzZXJ0KFwiSlNYQXR0cmlidXRlXCIsIG5vZGUsIG9wdHMpO1xufVxuZnVuY3Rpb24gYXNzZXJ0SlNYQ2xvc2luZ0VsZW1lbnQobm9kZSwgb3B0cykge1xuICBhc3NlcnQoXCJKU1hDbG9zaW5nRWxlbWVudFwiLCBub2RlLCBvcHRzKTtcbn1cbmZ1bmN0aW9uIGFzc2VydEpTWEVsZW1lbnQobm9kZSwgb3B0cykge1xuICBhc3NlcnQoXCJKU1hFbGVtZW50XCIsIG5vZGUsIG9wdHMpO1xufVxuZnVuY3Rpb24gYXNzZXJ0SlNYRW1wdHlFeHByZXNzaW9uKG5vZGUsIG9wdHMpIHtcbiAgYXNzZXJ0KFwiSlNYRW1wdHlFeHByZXNzaW9uXCIsIG5vZGUsIG9wdHMpO1xufVxuZnVuY3Rpb24gYXNzZXJ0SlNYRXhwcmVzc2lvbkNvbnRhaW5lcihub2RlLCBvcHRzKSB7XG4gIGFzc2VydChcIkpTWEV4cHJlc3Npb25Db250YWluZXJcIiwgbm9kZSwgb3B0cyk7XG59XG5mdW5jdGlvbiBhc3NlcnRKU1hTcHJlYWRDaGlsZChub2RlLCBvcHRzKSB7XG4gIGFzc2VydChcIkpTWFNwcmVhZENoaWxkXCIsIG5vZGUsIG9wdHMpO1xufVxuZnVuY3Rpb24gYXNzZXJ0SlNYSWRlbnRpZmllcihub2RlLCBvcHRzKSB7XG4gIGFzc2VydChcIkpTWElkZW50aWZpZXJcIiwgbm9kZSwgb3B0cyk7XG59XG5mdW5jdGlvbiBhc3NlcnRKU1hNZW1iZXJFeHByZXNzaW9uKG5vZGUsIG9wdHMpIHtcbiAgYXNzZXJ0KFwiSlNYTWVtYmVyRXhwcmVzc2lvblwiLCBub2RlLCBvcHRzKTtcbn1cbmZ1bmN0aW9uIGFzc2VydEpTWE5hbWVzcGFjZWROYW1lKG5vZGUsIG9wdHMpIHtcbiAgYXNzZXJ0KFwiSlNYTmFtZXNwYWNlZE5hbWVcIiwgbm9kZSwgb3B0cyk7XG59XG5mdW5jdGlvbiBhc3NlcnRKU1hPcGVuaW5nRWxlbWVudChub2RlLCBvcHRzKSB7XG4gIGFzc2VydChcIkpTWE9wZW5pbmdFbGVtZW50XCIsIG5vZGUsIG9wdHMpO1xufVxuZnVuY3Rpb24gYXNzZXJ0SlNYU3ByZWFkQXR0cmlidXRlKG5vZGUsIG9wdHMpIHtcbiAgYXNzZXJ0KFwiSlNYU3ByZWFkQXR0cmlidXRlXCIsIG5vZGUsIG9wdHMpO1xufVxuZnVuY3Rpb24gYXNzZXJ0SlNYVGV4dChub2RlLCBvcHRzKSB7XG4gIGFzc2VydChcIkpTWFRleHRcIiwgbm9kZSwgb3B0cyk7XG59XG5mdW5jdGlvbiBhc3NlcnRKU1hGcmFnbWVudChub2RlLCBvcHRzKSB7XG4gIGFzc2VydChcIkpTWEZyYWdtZW50XCIsIG5vZGUsIG9wdHMpO1xufVxuZnVuY3Rpb24gYXNzZXJ0SlNYT3BlbmluZ0ZyYWdtZW50KG5vZGUsIG9wdHMpIHtcbiAgYXNzZXJ0KFwiSlNYT3BlbmluZ0ZyYWdtZW50XCIsIG5vZGUsIG9wdHMpO1xufVxuZnVuY3Rpb24gYXNzZXJ0SlNYQ2xvc2luZ0ZyYWdtZW50KG5vZGUsIG9wdHMpIHtcbiAgYXNzZXJ0KFwiSlNYQ2xvc2luZ0ZyYWdtZW50XCIsIG5vZGUsIG9wdHMpO1xufVxuZnVuY3Rpb24gYXNzZXJ0Tm9vcChub2RlLCBvcHRzKSB7XG4gIGFzc2VydChcIk5vb3BcIiwgbm9kZSwgb3B0cyk7XG59XG5mdW5jdGlvbiBhc3NlcnRQbGFjZWhvbGRlcihub2RlLCBvcHRzKSB7XG4gIGFzc2VydChcIlBsYWNlaG9sZGVyXCIsIG5vZGUsIG9wdHMpO1xufVxuZnVuY3Rpb24gYXNzZXJ0VjhJbnRyaW5zaWNJZGVudGlmaWVyKG5vZGUsIG9wdHMpIHtcbiAgYXNzZXJ0KFwiVjhJbnRyaW5zaWNJZGVudGlmaWVyXCIsIG5vZGUsIG9wdHMpO1xufVxuZnVuY3Rpb24gYXNzZXJ0QXJndW1lbnRQbGFjZWhvbGRlcihub2RlLCBvcHRzKSB7XG4gIGFzc2VydChcIkFyZ3VtZW50UGxhY2Vob2xkZXJcIiwgbm9kZSwgb3B0cyk7XG59XG5mdW5jdGlvbiBhc3NlcnRCaW5kRXhwcmVzc2lvbihub2RlLCBvcHRzKSB7XG4gIGFzc2VydChcIkJpbmRFeHByZXNzaW9uXCIsIG5vZGUsIG9wdHMpO1xufVxuZnVuY3Rpb24gYXNzZXJ0RGVjb3JhdG9yKG5vZGUsIG9wdHMpIHtcbiAgYXNzZXJ0KFwiRGVjb3JhdG9yXCIsIG5vZGUsIG9wdHMpO1xufVxuZnVuY3Rpb24gYXNzZXJ0RG9FeHByZXNzaW9uKG5vZGUsIG9wdHMpIHtcbiAgYXNzZXJ0KFwiRG9FeHByZXNzaW9uXCIsIG5vZGUsIG9wdHMpO1xufVxuZnVuY3Rpb24gYXNzZXJ0RXhwb3J0RGVmYXVsdFNwZWNpZmllcihub2RlLCBvcHRzKSB7XG4gIGFzc2VydChcIkV4cG9ydERlZmF1bHRTcGVjaWZpZXJcIiwgbm9kZSwgb3B0cyk7XG59XG5mdW5jdGlvbiBhc3NlcnRSZWNvcmRFeHByZXNzaW9uKG5vZGUsIG9wdHMpIHtcbiAgYXNzZXJ0KFwiUmVjb3JkRXhwcmVzc2lvblwiLCBub2RlLCBvcHRzKTtcbn1cbmZ1bmN0aW9uIGFzc2VydFR1cGxlRXhwcmVzc2lvbihub2RlLCBvcHRzKSB7XG4gIGFzc2VydChcIlR1cGxlRXhwcmVzc2lvblwiLCBub2RlLCBvcHRzKTtcbn1cbmZ1bmN0aW9uIGFzc2VydERlY2ltYWxMaXRlcmFsKG5vZGUsIG9wdHMpIHtcbiAgYXNzZXJ0KFwiRGVjaW1hbExpdGVyYWxcIiwgbm9kZSwgb3B0cyk7XG59XG5mdW5jdGlvbiBhc3NlcnRNb2R1bGVFeHByZXNzaW9uKG5vZGUsIG9wdHMpIHtcbiAgYXNzZXJ0KFwiTW9kdWxlRXhwcmVzc2lvblwiLCBub2RlLCBvcHRzKTtcbn1cbmZ1bmN0aW9uIGFzc2VydFRvcGljUmVmZXJlbmNlKG5vZGUsIG9wdHMpIHtcbiAgYXNzZXJ0KFwiVG9waWNSZWZlcmVuY2VcIiwgbm9kZSwgb3B0cyk7XG59XG5mdW5jdGlvbiBhc3NlcnRQaXBlbGluZVRvcGljRXhwcmVzc2lvbihub2RlLCBvcHRzKSB7XG4gIGFzc2VydChcIlBpcGVsaW5lVG9waWNFeHByZXNzaW9uXCIsIG5vZGUsIG9wdHMpO1xufVxuZnVuY3Rpb24gYXNzZXJ0UGlwZWxpbmVCYXJlRnVuY3Rpb24obm9kZSwgb3B0cykge1xuICBhc3NlcnQoXCJQaXBlbGluZUJhcmVGdW5jdGlvblwiLCBub2RlLCBvcHRzKTtcbn1cbmZ1bmN0aW9uIGFzc2VydFBpcGVsaW5lUHJpbWFyeVRvcGljUmVmZXJlbmNlKG5vZGUsIG9wdHMpIHtcbiAgYXNzZXJ0KFwiUGlwZWxpbmVQcmltYXJ5VG9waWNSZWZlcmVuY2VcIiwgbm9kZSwgb3B0cyk7XG59XG5mdW5jdGlvbiBhc3NlcnRWb2lkUGF0dGVybihub2RlLCBvcHRzKSB7XG4gIGFzc2VydChcIlZvaWRQYXR0ZXJuXCIsIG5vZGUsIG9wdHMpO1xufVxuZnVuY3Rpb24gYXNzZXJ0VFNQYXJhbWV0ZXJQcm9wZXJ0eShub2RlLCBvcHRzKSB7XG4gIGFzc2VydChcIlRTUGFyYW1ldGVyUHJvcGVydHlcIiwgbm9kZSwgb3B0cyk7XG59XG5mdW5jdGlvbiBhc3NlcnRUU0RlY2xhcmVGdW5jdGlvbihub2RlLCBvcHRzKSB7XG4gIGFzc2VydChcIlRTRGVjbGFyZUZ1bmN0aW9uXCIsIG5vZGUsIG9wdHMpO1xufVxuZnVuY3Rpb24gYXNzZXJ0VFNEZWNsYXJlTWV0aG9kKG5vZGUsIG9wdHMpIHtcbiAgYXNzZXJ0KFwiVFNEZWNsYXJlTWV0aG9kXCIsIG5vZGUsIG9wdHMpO1xufVxuZnVuY3Rpb24gYXNzZXJ0VFNRdWFsaWZpZWROYW1lKG5vZGUsIG9wdHMpIHtcbiAgYXNzZXJ0KFwiVFNRdWFsaWZpZWROYW1lXCIsIG5vZGUsIG9wdHMpO1xufVxuZnVuY3Rpb24gYXNzZXJ0VFNDYWxsU2lnbmF0dXJlRGVjbGFyYXRpb24obm9kZSwgb3B0cykge1xuICBhc3NlcnQoXCJUU0NhbGxTaWduYXR1cmVEZWNsYXJhdGlvblwiLCBub2RlLCBvcHRzKTtcbn1cbmZ1bmN0aW9uIGFzc2VydFRTQ29uc3RydWN0U2lnbmF0dXJlRGVjbGFyYXRpb24obm9kZSwgb3B0cykge1xuICBhc3NlcnQoXCJUU0NvbnN0cnVjdFNpZ25hdHVyZURlY2xhcmF0aW9uXCIsIG5vZGUsIG9wdHMpO1xufVxuZnVuY3Rpb24gYXNzZXJ0VFNQcm9wZXJ0eVNpZ25hdHVyZShub2RlLCBvcHRzKSB7XG4gIGFzc2VydChcIlRTUHJvcGVydHlTaWduYXR1cmVcIiwgbm9kZSwgb3B0cyk7XG59XG5mdW5jdGlvbiBhc3NlcnRUU01ldGhvZFNpZ25hdHVyZShub2RlLCBvcHRzKSB7XG4gIGFzc2VydChcIlRTTWV0aG9kU2lnbmF0dXJlXCIsIG5vZGUsIG9wdHMpO1xufVxuZnVuY3Rpb24gYXNzZXJ0VFNJbmRleFNpZ25hdHVyZShub2RlLCBvcHRzKSB7XG4gIGFzc2VydChcIlRTSW5kZXhTaWduYXR1cmVcIiwgbm9kZSwgb3B0cyk7XG59XG5mdW5jdGlvbiBhc3NlcnRUU0FueUtleXdvcmQobm9kZSwgb3B0cykge1xuICBhc3NlcnQoXCJUU0FueUtleXdvcmRcIiwgbm9kZSwgb3B0cyk7XG59XG5mdW5jdGlvbiBhc3NlcnRUU0Jvb2xlYW5LZXl3b3JkKG5vZGUsIG9wdHMpIHtcbiAgYXNzZXJ0KFwiVFNCb29sZWFuS2V5d29yZFwiLCBub2RlLCBvcHRzKTtcbn1cbmZ1bmN0aW9uIGFzc2VydFRTQmlnSW50S2V5d29yZChub2RlLCBvcHRzKSB7XG4gIGFzc2VydChcIlRTQmlnSW50S2V5d29yZFwiLCBub2RlLCBvcHRzKTtcbn1cbmZ1bmN0aW9uIGFzc2VydFRTSW50cmluc2ljS2V5d29yZChub2RlLCBvcHRzKSB7XG4gIGFzc2VydChcIlRTSW50cmluc2ljS2V5d29yZFwiLCBub2RlLCBvcHRzKTtcbn1cbmZ1bmN0aW9uIGFzc2VydFRTTmV2ZXJLZXl3b3JkKG5vZGUsIG9wdHMpIHtcbiAgYXNzZXJ0KFwiVFNOZXZlcktleXdvcmRcIiwgbm9kZSwgb3B0cyk7XG59XG5mdW5jdGlvbiBhc3NlcnRUU051bGxLZXl3b3JkKG5vZGUsIG9wdHMpIHtcbiAgYXNzZXJ0KFwiVFNOdWxsS2V5d29yZFwiLCBub2RlLCBvcHRzKTtcbn1cbmZ1bmN0aW9uIGFzc2VydFRTTnVtYmVyS2V5d29yZChub2RlLCBvcHRzKSB7XG4gIGFzc2VydChcIlRTTnVtYmVyS2V5d29yZFwiLCBub2RlLCBvcHRzKTtcbn1cbmZ1bmN0aW9uIGFzc2VydFRTT2JqZWN0S2V5d29yZChub2RlLCBvcHRzKSB7XG4gIGFzc2VydChcIlRTT2JqZWN0S2V5d29yZFwiLCBub2RlLCBvcHRzKTtcbn1cbmZ1bmN0aW9uIGFzc2VydFRTU3RyaW5nS2V5d29yZChub2RlLCBvcHRzKSB7XG4gIGFzc2VydChcIlRTU3RyaW5nS2V5d29yZFwiLCBub2RlLCBvcHRzKTtcbn1cbmZ1bmN0aW9uIGFzc2VydFRTU3ltYm9sS2V5d29yZChub2RlLCBvcHRzKSB7XG4gIGFzc2VydChcIlRTU3ltYm9sS2V5d29yZFwiLCBub2RlLCBvcHRzKTtcbn1cbmZ1bmN0aW9uIGFzc2VydFRTVW5kZWZpbmVkS2V5d29yZChub2RlLCBvcHRzKSB7XG4gIGFzc2VydChcIlRTVW5kZWZpbmVkS2V5d29yZFwiLCBub2RlLCBvcHRzKTtcbn1cbmZ1bmN0aW9uIGFzc2VydFRTVW5rbm93bktleXdvcmQobm9kZSwgb3B0cykge1xuICBhc3NlcnQoXCJUU1Vua25vd25LZXl3b3JkXCIsIG5vZGUsIG9wdHMpO1xufVxuZnVuY3Rpb24gYXNzZXJ0VFNWb2lkS2V5d29yZChub2RlLCBvcHRzKSB7XG4gIGFzc2VydChcIlRTVm9pZEtleXdvcmRcIiwgbm9kZSwgb3B0cyk7XG59XG5mdW5jdGlvbiBhc3NlcnRUU1RoaXNUeXBlKG5vZGUsIG9wdHMpIHtcbiAgYXNzZXJ0KFwiVFNUaGlzVHlwZVwiLCBub2RlLCBvcHRzKTtcbn1cbmZ1bmN0aW9uIGFzc2VydFRTRnVuY3Rpb25UeXBlKG5vZGUsIG9wdHMpIHtcbiAgYXNzZXJ0KFwiVFNGdW5jdGlvblR5cGVcIiwgbm9kZSwgb3B0cyk7XG59XG5mdW5jdGlvbiBhc3NlcnRUU0NvbnN0cnVjdG9yVHlwZShub2RlLCBvcHRzKSB7XG4gIGFzc2VydChcIlRTQ29uc3RydWN0b3JUeXBlXCIsIG5vZGUsIG9wdHMpO1xufVxuZnVuY3Rpb24gYXNzZXJ0VFNUeXBlUmVmZXJlbmNlKG5vZGUsIG9wdHMpIHtcbiAgYXNzZXJ0KFwiVFNUeXBlUmVmZXJlbmNlXCIsIG5vZGUsIG9wdHMpO1xufVxuZnVuY3Rpb24gYXNzZXJ0VFNUeXBlUHJlZGljYXRlKG5vZGUsIG9wdHMpIHtcbiAgYXNzZXJ0KFwiVFNUeXBlUHJlZGljYXRlXCIsIG5vZGUsIG9wdHMpO1xufVxuZnVuY3Rpb24gYXNzZXJ0VFNUeXBlUXVlcnkobm9kZSwgb3B0cykge1xuICBhc3NlcnQoXCJUU1R5cGVRdWVyeVwiLCBub2RlLCBvcHRzKTtcbn1cbmZ1bmN0aW9uIGFzc2VydFRTVHlwZUxpdGVyYWwobm9kZSwgb3B0cykge1xuICBhc3NlcnQoXCJUU1R5cGVMaXRlcmFsXCIsIG5vZGUsIG9wdHMpO1xufVxuZnVuY3Rpb24gYXNzZXJ0VFNBcnJheVR5cGUobm9kZSwgb3B0cykge1xuICBhc3NlcnQoXCJUU0FycmF5VHlwZVwiLCBub2RlLCBvcHRzKTtcbn1cbmZ1bmN0aW9uIGFzc2VydFRTVHVwbGVUeXBlKG5vZGUsIG9wdHMpIHtcbiAgYXNzZXJ0KFwiVFNUdXBsZVR5cGVcIiwgbm9kZSwgb3B0cyk7XG59XG5mdW5jdGlvbiBhc3NlcnRUU09wdGlvbmFsVHlwZShub2RlLCBvcHRzKSB7XG4gIGFzc2VydChcIlRTT3B0aW9uYWxUeXBlXCIsIG5vZGUsIG9wdHMpO1xufVxuZnVuY3Rpb24gYXNzZXJ0VFNSZXN0VHlwZShub2RlLCBvcHRzKSB7XG4gIGFzc2VydChcIlRTUmVzdFR5cGVcIiwgbm9kZSwgb3B0cyk7XG59XG5mdW5jdGlvbiBhc3NlcnRUU05hbWVkVHVwbGVNZW1iZXIobm9kZSwgb3B0cykge1xuICBhc3NlcnQoXCJUU05hbWVkVHVwbGVNZW1iZXJcIiwgbm9kZSwgb3B0cyk7XG59XG5mdW5jdGlvbiBhc3NlcnRUU1VuaW9uVHlwZShub2RlLCBvcHRzKSB7XG4gIGFzc2VydChcIlRTVW5pb25UeXBlXCIsIG5vZGUsIG9wdHMpO1xufVxuZnVuY3Rpb24gYXNzZXJ0VFNJbnRlcnNlY3Rpb25UeXBlKG5vZGUsIG9wdHMpIHtcbiAgYXNzZXJ0KFwiVFNJbnRlcnNlY3Rpb25UeXBlXCIsIG5vZGUsIG9wdHMpO1xufVxuZnVuY3Rpb24gYXNzZXJ0VFNDb25kaXRpb25hbFR5cGUobm9kZSwgb3B0cykge1xuICBhc3NlcnQoXCJUU0NvbmRpdGlvbmFsVHlwZVwiLCBub2RlLCBvcHRzKTtcbn1cbmZ1bmN0aW9uIGFzc2VydFRTSW5mZXJUeXBlKG5vZGUsIG9wdHMpIHtcbiAgYXNzZXJ0KFwiVFNJbmZlclR5cGVcIiwgbm9kZSwgb3B0cyk7XG59XG5mdW5jdGlvbiBhc3NlcnRUU1BhcmVudGhlc2l6ZWRUeXBlKG5vZGUsIG9wdHMpIHtcbiAgYXNzZXJ0KFwiVFNQYXJlbnRoZXNpemVkVHlwZVwiLCBub2RlLCBvcHRzKTtcbn1cbmZ1bmN0aW9uIGFzc2VydFRTVHlwZU9wZXJhdG9yKG5vZGUsIG9wdHMpIHtcbiAgYXNzZXJ0KFwiVFNUeXBlT3BlcmF0b3JcIiwgbm9kZSwgb3B0cyk7XG59XG5mdW5jdGlvbiBhc3NlcnRUU0luZGV4ZWRBY2Nlc3NUeXBlKG5vZGUsIG9wdHMpIHtcbiAgYXNzZXJ0KFwiVFNJbmRleGVkQWNjZXNzVHlwZVwiLCBub2RlLCBvcHRzKTtcbn1cbmZ1bmN0aW9uIGFzc2VydFRTTWFwcGVkVHlwZShub2RlLCBvcHRzKSB7XG4gIGFzc2VydChcIlRTTWFwcGVkVHlwZVwiLCBub2RlLCBvcHRzKTtcbn1cbmZ1bmN0aW9uIGFzc2VydFRTVGVtcGxhdGVMaXRlcmFsVHlwZShub2RlLCBvcHRzKSB7XG4gIGFzc2VydChcIlRTVGVtcGxhdGVMaXRlcmFsVHlwZVwiLCBub2RlLCBvcHRzKTtcbn1cbmZ1bmN0aW9uIGFzc2VydFRTTGl0ZXJhbFR5cGUobm9kZSwgb3B0cykge1xuICBhc3NlcnQoXCJUU0xpdGVyYWxUeXBlXCIsIG5vZGUsIG9wdHMpO1xufVxuZnVuY3Rpb24gYXNzZXJ0VFNFeHByZXNzaW9uV2l0aFR5cGVBcmd1bWVudHMobm9kZSwgb3B0cykge1xuICBhc3NlcnQoXCJUU0V4cHJlc3Npb25XaXRoVHlwZUFyZ3VtZW50c1wiLCBub2RlLCBvcHRzKTtcbn1cbmZ1bmN0aW9uIGFzc2VydFRTSW50ZXJmYWNlRGVjbGFyYXRpb24obm9kZSwgb3B0cykge1xuICBhc3NlcnQoXCJUU0ludGVyZmFjZURlY2xhcmF0aW9uXCIsIG5vZGUsIG9wdHMpO1xufVxuZnVuY3Rpb24gYXNzZXJ0VFNJbnRlcmZhY2VCb2R5KG5vZGUsIG9wdHMpIHtcbiAgYXNzZXJ0KFwiVFNJbnRlcmZhY2VCb2R5XCIsIG5vZGUsIG9wdHMpO1xufVxuZnVuY3Rpb24gYXNzZXJ0VFNUeXBlQWxpYXNEZWNsYXJhdGlvbihub2RlLCBvcHRzKSB7XG4gIGFzc2VydChcIlRTVHlwZUFsaWFzRGVjbGFyYXRpb25cIiwgbm9kZSwgb3B0cyk7XG59XG5mdW5jdGlvbiBhc3NlcnRUU0luc3RhbnRpYXRpb25FeHByZXNzaW9uKG5vZGUsIG9wdHMpIHtcbiAgYXNzZXJ0KFwiVFNJbnN0YW50aWF0aW9uRXhwcmVzc2lvblwiLCBub2RlLCBvcHRzKTtcbn1cbmZ1bmN0aW9uIGFzc2VydFRTQXNFeHByZXNzaW9uKG5vZGUsIG9wdHMpIHtcbiAgYXNzZXJ0KFwiVFNBc0V4cHJlc3Npb25cIiwgbm9kZSwgb3B0cyk7XG59XG5mdW5jdGlvbiBhc3NlcnRUU1NhdGlzZmllc0V4cHJlc3Npb24obm9kZSwgb3B0cykge1xuICBhc3NlcnQoXCJUU1NhdGlzZmllc0V4cHJlc3Npb25cIiwgbm9kZSwgb3B0cyk7XG59XG5mdW5jdGlvbiBhc3NlcnRUU1R5cGVBc3NlcnRpb24obm9kZSwgb3B0cykge1xuICBhc3NlcnQoXCJUU1R5cGVBc3NlcnRpb25cIiwgbm9kZSwgb3B0cyk7XG59XG5mdW5jdGlvbiBhc3NlcnRUU0VudW1Cb2R5KG5vZGUsIG9wdHMpIHtcbiAgYXNzZXJ0KFwiVFNFbnVtQm9keVwiLCBub2RlLCBvcHRzKTtcbn1cbmZ1bmN0aW9uIGFzc2VydFRTRW51bURlY2xhcmF0aW9uKG5vZGUsIG9wdHMpIHtcbiAgYXNzZXJ0KFwiVFNFbnVtRGVjbGFyYXRpb25cIiwgbm9kZSwgb3B0cyk7XG59XG5mdW5jdGlvbiBhc3NlcnRUU0VudW1NZW1iZXIobm9kZSwgb3B0cykge1xuICBhc3NlcnQoXCJUU0VudW1NZW1iZXJcIiwgbm9kZSwgb3B0cyk7XG59XG5mdW5jdGlvbiBhc3NlcnRUU01vZHVsZURlY2xhcmF0aW9uKG5vZGUsIG9wdHMpIHtcbiAgYXNzZXJ0KFwiVFNNb2R1bGVEZWNsYXJhdGlvblwiLCBub2RlLCBvcHRzKTtcbn1cbmZ1bmN0aW9uIGFzc2VydFRTTW9kdWxlQmxvY2sobm9kZSwgb3B0cykge1xuICBhc3NlcnQoXCJUU01vZHVsZUJsb2NrXCIsIG5vZGUsIG9wdHMpO1xufVxuZnVuY3Rpb24gYXNzZXJ0VFNJbXBvcnRUeXBlKG5vZGUsIG9wdHMpIHtcbiAgYXNzZXJ0KFwiVFNJbXBvcnRUeXBlXCIsIG5vZGUsIG9wdHMpO1xufVxuZnVuY3Rpb24gYXNzZXJ0VFNJbXBvcnRFcXVhbHNEZWNsYXJhdGlvbihub2RlLCBvcHRzKSB7XG4gIGFzc2VydChcIlRTSW1wb3J0RXF1YWxzRGVjbGFyYXRpb25cIiwgbm9kZSwgb3B0cyk7XG59XG5mdW5jdGlvbiBhc3NlcnRUU0V4dGVybmFsTW9kdWxlUmVmZXJlbmNlKG5vZGUsIG9wdHMpIHtcbiAgYXNzZXJ0KFwiVFNFeHRlcm5hbE1vZHVsZVJlZmVyZW5jZVwiLCBub2RlLCBvcHRzKTtcbn1cbmZ1bmN0aW9uIGFzc2VydFRTTm9uTnVsbEV4cHJlc3Npb24obm9kZSwgb3B0cykge1xuICBhc3NlcnQoXCJUU05vbk51bGxFeHByZXNzaW9uXCIsIG5vZGUsIG9wdHMpO1xufVxuZnVuY3Rpb24gYXNzZXJ0VFNFeHBvcnRBc3NpZ25tZW50KG5vZGUsIG9wdHMpIHtcbiAgYXNzZXJ0KFwiVFNFeHBvcnRBc3NpZ25tZW50XCIsIG5vZGUsIG9wdHMpO1xufVxuZnVuY3Rpb24gYXNzZXJ0VFNOYW1lc3BhY2VFeHBvcnREZWNsYXJhdGlvbihub2RlLCBvcHRzKSB7XG4gIGFzc2VydChcIlRTTmFtZXNwYWNlRXhwb3J0RGVjbGFyYXRpb25cIiwgbm9kZSwgb3B0cyk7XG59XG5mdW5jdGlvbiBhc3NlcnRUU1R5cGVBbm5vdGF0aW9uKG5vZGUsIG9wdHMpIHtcbiAgYXNzZXJ0KFwiVFNUeXBlQW5ub3RhdGlvblwiLCBub2RlLCBvcHRzKTtcbn1cbmZ1bmN0aW9uIGFzc2VydFRTVHlwZVBhcmFtZXRlckluc3RhbnRpYXRpb24obm9kZSwgb3B0cykge1xuICBhc3NlcnQoXCJUU1R5cGVQYXJhbWV0ZXJJbnN0YW50aWF0aW9uXCIsIG5vZGUsIG9wdHMpO1xufVxuZnVuY3Rpb24gYXNzZXJ0VFNUeXBlUGFyYW1ldGVyRGVjbGFyYXRpb24obm9kZSwgb3B0cykge1xuICBhc3NlcnQoXCJUU1R5cGVQYXJhbWV0ZXJEZWNsYXJhdGlvblwiLCBub2RlLCBvcHRzKTtcbn1cbmZ1bmN0aW9uIGFzc2VydFRTVHlwZVBhcmFtZXRlcihub2RlLCBvcHRzKSB7XG4gIGFzc2VydChcIlRTVHlwZVBhcmFtZXRlclwiLCBub2RlLCBvcHRzKTtcbn1cbmZ1bmN0aW9uIGFzc2VydFN0YW5kYXJkaXplZChub2RlLCBvcHRzKSB7XG4gIGFzc2VydChcIlN0YW5kYXJkaXplZFwiLCBub2RlLCBvcHRzKTtcbn1cbmZ1bmN0aW9uIGFzc2VydEV4cHJlc3Npb24obm9kZSwgb3B0cykge1xuICBhc3NlcnQoXCJFeHByZXNzaW9uXCIsIG5vZGUsIG9wdHMpO1xufVxuZnVuY3Rpb24gYXNzZXJ0QmluYXJ5KG5vZGUsIG9wdHMpIHtcbiAgYXNzZXJ0KFwiQmluYXJ5XCIsIG5vZGUsIG9wdHMpO1xufVxuZnVuY3Rpb24gYXNzZXJ0U2NvcGFibGUobm9kZSwgb3B0cykge1xuICBhc3NlcnQoXCJTY29wYWJsZVwiLCBub2RlLCBvcHRzKTtcbn1cbmZ1bmN0aW9uIGFzc2VydEJsb2NrUGFyZW50KG5vZGUsIG9wdHMpIHtcbiAgYXNzZXJ0KFwiQmxvY2tQYXJlbnRcIiwgbm9kZSwgb3B0cyk7XG59XG5mdW5jdGlvbiBhc3NlcnRCbG9jayhub2RlLCBvcHRzKSB7XG4gIGFzc2VydChcIkJsb2NrXCIsIG5vZGUsIG9wdHMpO1xufVxuZnVuY3Rpb24gYXNzZXJ0U3RhdGVtZW50KG5vZGUsIG9wdHMpIHtcbiAgYXNzZXJ0KFwiU3RhdGVtZW50XCIsIG5vZGUsIG9wdHMpO1xufVxuZnVuY3Rpb24gYXNzZXJ0VGVybWluYXRvcmxlc3Mobm9kZSwgb3B0cykge1xuICBhc3NlcnQoXCJUZXJtaW5hdG9ybGVzc1wiLCBub2RlLCBvcHRzKTtcbn1cbmZ1bmN0aW9uIGFzc2VydENvbXBsZXRpb25TdGF0ZW1lbnQobm9kZSwgb3B0cykge1xuICBhc3NlcnQoXCJDb21wbGV0aW9uU3RhdGVtZW50XCIsIG5vZGUsIG9wdHMpO1xufVxuZnVuY3Rpb24gYXNzZXJ0Q29uZGl0aW9uYWwobm9kZSwgb3B0cykge1xuICBhc3NlcnQoXCJDb25kaXRpb25hbFwiLCBub2RlLCBvcHRzKTtcbn1cbmZ1bmN0aW9uIGFzc2VydExvb3Aobm9kZSwgb3B0cykge1xuICBhc3NlcnQoXCJMb29wXCIsIG5vZGUsIG9wdHMpO1xufVxuZnVuY3Rpb24gYXNzZXJ0V2hpbGUobm9kZSwgb3B0cykge1xuICBhc3NlcnQoXCJXaGlsZVwiLCBub2RlLCBvcHRzKTtcbn1cbmZ1bmN0aW9uIGFzc2VydEV4cHJlc3Npb25XcmFwcGVyKG5vZGUsIG9wdHMpIHtcbiAgYXNzZXJ0KFwiRXhwcmVzc2lvbldyYXBwZXJcIiwgbm9kZSwgb3B0cyk7XG59XG5mdW5jdGlvbiBhc3NlcnRGb3Iobm9kZSwgb3B0cykge1xuICBhc3NlcnQoXCJGb3JcIiwgbm9kZSwgb3B0cyk7XG59XG5mdW5jdGlvbiBhc3NlcnRGb3JYU3RhdGVtZW50KG5vZGUsIG9wdHMpIHtcbiAgYXNzZXJ0KFwiRm9yWFN0YXRlbWVudFwiLCBub2RlLCBvcHRzKTtcbn1cbmZ1bmN0aW9uIGFzc2VydEZ1bmN0aW9uKG5vZGUsIG9wdHMpIHtcbiAgYXNzZXJ0KFwiRnVuY3Rpb25cIiwgbm9kZSwgb3B0cyk7XG59XG5mdW5jdGlvbiBhc3NlcnRGdW5jdGlvblBhcmVudChub2RlLCBvcHRzKSB7XG4gIGFzc2VydChcIkZ1bmN0aW9uUGFyZW50XCIsIG5vZGUsIG9wdHMpO1xufVxuZnVuY3Rpb24gYXNzZXJ0UHVyZWlzaChub2RlLCBvcHRzKSB7XG4gIGFzc2VydChcIlB1cmVpc2hcIiwgbm9kZSwgb3B0cyk7XG59XG5mdW5jdGlvbiBhc3NlcnREZWNsYXJhdGlvbihub2RlLCBvcHRzKSB7XG4gIGFzc2VydChcIkRlY2xhcmF0aW9uXCIsIG5vZGUsIG9wdHMpO1xufVxuZnVuY3Rpb24gYXNzZXJ0RnVuY3Rpb25QYXJhbWV0ZXIobm9kZSwgb3B0cykge1xuICBhc3NlcnQoXCJGdW5jdGlvblBhcmFtZXRlclwiLCBub2RlLCBvcHRzKTtcbn1cbmZ1bmN0aW9uIGFzc2VydFBhdHRlcm5MaWtlKG5vZGUsIG9wdHMpIHtcbiAgYXNzZXJ0KFwiUGF0dGVybkxpa2VcIiwgbm9kZSwgb3B0cyk7XG59XG5mdW5jdGlvbiBhc3NlcnRMVmFsKG5vZGUsIG9wdHMpIHtcbiAgYXNzZXJ0KFwiTFZhbFwiLCBub2RlLCBvcHRzKTtcbn1cbmZ1bmN0aW9uIGFzc2VydFRTRW50aXR5TmFtZShub2RlLCBvcHRzKSB7XG4gIGFzc2VydChcIlRTRW50aXR5TmFtZVwiLCBub2RlLCBvcHRzKTtcbn1cbmZ1bmN0aW9uIGFzc2VydExpdGVyYWwobm9kZSwgb3B0cykge1xuICBhc3NlcnQoXCJMaXRlcmFsXCIsIG5vZGUsIG9wdHMpO1xufVxuZnVuY3Rpb24gYXNzZXJ0SW1tdXRhYmxlKG5vZGUsIG9wdHMpIHtcbiAgYXNzZXJ0KFwiSW1tdXRhYmxlXCIsIG5vZGUsIG9wdHMpO1xufVxuZnVuY3Rpb24gYXNzZXJ0VXNlcldoaXRlc3BhY2FibGUobm9kZSwgb3B0cykge1xuICBhc3NlcnQoXCJVc2VyV2hpdGVzcGFjYWJsZVwiLCBub2RlLCBvcHRzKTtcbn1cbmZ1bmN0aW9uIGFzc2VydE1ldGhvZChub2RlLCBvcHRzKSB7XG4gIGFzc2VydChcIk1ldGhvZFwiLCBub2RlLCBvcHRzKTtcbn1cbmZ1bmN0aW9uIGFzc2VydE9iamVjdE1lbWJlcihub2RlLCBvcHRzKSB7XG4gIGFzc2VydChcIk9iamVjdE1lbWJlclwiLCBub2RlLCBvcHRzKTtcbn1cbmZ1bmN0aW9uIGFzc2VydFByb3BlcnR5KG5vZGUsIG9wdHMpIHtcbiAgYXNzZXJ0KFwiUHJvcGVydHlcIiwgbm9kZSwgb3B0cyk7XG59XG5mdW5jdGlvbiBhc3NlcnRVbmFyeUxpa2Uobm9kZSwgb3B0cykge1xuICBhc3NlcnQoXCJVbmFyeUxpa2VcIiwgbm9kZSwgb3B0cyk7XG59XG5mdW5jdGlvbiBhc3NlcnRQYXR0ZXJuKG5vZGUsIG9wdHMpIHtcbiAgYXNzZXJ0KFwiUGF0dGVyblwiLCBub2RlLCBvcHRzKTtcbn1cbmZ1bmN0aW9uIGFzc2VydENsYXNzKG5vZGUsIG9wdHMpIHtcbiAgYXNzZXJ0KFwiQ2xhc3NcIiwgbm9kZSwgb3B0cyk7XG59XG5mdW5jdGlvbiBhc3NlcnRJbXBvcnRPckV4cG9ydERlY2xhcmF0aW9uKG5vZGUsIG9wdHMpIHtcbiAgYXNzZXJ0KFwiSW1wb3J0T3JFeHBvcnREZWNsYXJhdGlvblwiLCBub2RlLCBvcHRzKTtcbn1cbmZ1bmN0aW9uIGFzc2VydEV4cG9ydERlY2xhcmF0aW9uKG5vZGUsIG9wdHMpIHtcbiAgYXNzZXJ0KFwiRXhwb3J0RGVjbGFyYXRpb25cIiwgbm9kZSwgb3B0cyk7XG59XG5mdW5jdGlvbiBhc3NlcnRNb2R1bGVTcGVjaWZpZXIobm9kZSwgb3B0cykge1xuICBhc3NlcnQoXCJNb2R1bGVTcGVjaWZpZXJcIiwgbm9kZSwgb3B0cyk7XG59XG5mdW5jdGlvbiBhc3NlcnRBY2Nlc3Nvcihub2RlLCBvcHRzKSB7XG4gIGFzc2VydChcIkFjY2Vzc29yXCIsIG5vZGUsIG9wdHMpO1xufVxuZnVuY3Rpb24gYXNzZXJ0UHJpdmF0ZShub2RlLCBvcHRzKSB7XG4gIGFzc2VydChcIlByaXZhdGVcIiwgbm9kZSwgb3B0cyk7XG59XG5mdW5jdGlvbiBhc3NlcnRGbG93KG5vZGUsIG9wdHMpIHtcbiAgYXNzZXJ0KFwiRmxvd1wiLCBub2RlLCBvcHRzKTtcbn1cbmZ1bmN0aW9uIGFzc2VydEZsb3dUeXBlKG5vZGUsIG9wdHMpIHtcbiAgYXNzZXJ0KFwiRmxvd1R5cGVcIiwgbm9kZSwgb3B0cyk7XG59XG5mdW5jdGlvbiBhc3NlcnRGbG93QmFzZUFubm90YXRpb24obm9kZSwgb3B0cykge1xuICBhc3NlcnQoXCJGbG93QmFzZUFubm90YXRpb25cIiwgbm9kZSwgb3B0cyk7XG59XG5mdW5jdGlvbiBhc3NlcnRGbG93RGVjbGFyYXRpb24obm9kZSwgb3B0cykge1xuICBhc3NlcnQoXCJGbG93RGVjbGFyYXRpb25cIiwgbm9kZSwgb3B0cyk7XG59XG5mdW5jdGlvbiBhc3NlcnRGbG93UHJlZGljYXRlKG5vZGUsIG9wdHMpIHtcbiAgYXNzZXJ0KFwiRmxvd1ByZWRpY2F0ZVwiLCBub2RlLCBvcHRzKTtcbn1cbmZ1bmN0aW9uIGFzc2VydEVudW1Cb2R5KG5vZGUsIG9wdHMpIHtcbiAgYXNzZXJ0KFwiRW51bUJvZHlcIiwgbm9kZSwgb3B0cyk7XG59XG5mdW5jdGlvbiBhc3NlcnRFbnVtTWVtYmVyKG5vZGUsIG9wdHMpIHtcbiAgYXNzZXJ0KFwiRW51bU1lbWJlclwiLCBub2RlLCBvcHRzKTtcbn1cbmZ1bmN0aW9uIGFzc2VydEpTWChub2RlLCBvcHRzKSB7XG4gIGFzc2VydChcIkpTWFwiLCBub2RlLCBvcHRzKTtcbn1cbmZ1bmN0aW9uIGFzc2VydE1pc2NlbGxhbmVvdXMobm9kZSwgb3B0cykge1xuICBhc3NlcnQoXCJNaXNjZWxsYW5lb3VzXCIsIG5vZGUsIG9wdHMpO1xufVxuZnVuY3Rpb24gYXNzZXJ0VHlwZVNjcmlwdChub2RlLCBvcHRzKSB7XG4gIGFzc2VydChcIlR5cGVTY3JpcHRcIiwgbm9kZSwgb3B0cyk7XG59XG5mdW5jdGlvbiBhc3NlcnRUU1R5cGVFbGVtZW50KG5vZGUsIG9wdHMpIHtcbiAgYXNzZXJ0KFwiVFNUeXBlRWxlbWVudFwiLCBub2RlLCBvcHRzKTtcbn1cbmZ1bmN0aW9uIGFzc2VydFRTVHlwZShub2RlLCBvcHRzKSB7XG4gIGFzc2VydChcIlRTVHlwZVwiLCBub2RlLCBvcHRzKTtcbn1cbmZ1bmN0aW9uIGFzc2VydFRTQmFzZVR5cGUobm9kZSwgb3B0cykge1xuICBhc3NlcnQoXCJUU0Jhc2VUeXBlXCIsIG5vZGUsIG9wdHMpO1xufVxuZnVuY3Rpb24gYXNzZXJ0TnVtYmVyTGl0ZXJhbChub2RlLCBvcHRzKSB7XG4gICgwLCBfZGVwcmVjYXRpb25XYXJuaW5nLmRlZmF1bHQpKFwiYXNzZXJ0TnVtYmVyTGl0ZXJhbFwiLCBcImFzc2VydE51bWVyaWNMaXRlcmFsXCIpO1xuICBhc3NlcnQoXCJOdW1iZXJMaXRlcmFsXCIsIG5vZGUsIG9wdHMpO1xufVxuZnVuY3Rpb24gYXNzZXJ0UmVnZXhMaXRlcmFsKG5vZGUsIG9wdHMpIHtcbiAgKDAsIF9kZXByZWNhdGlvbldhcm5pbmcuZGVmYXVsdCkoXCJhc3NlcnRSZWdleExpdGVyYWxcIiwgXCJhc3NlcnRSZWdFeHBMaXRlcmFsXCIpO1xuICBhc3NlcnQoXCJSZWdleExpdGVyYWxcIiwgbm9kZSwgb3B0cyk7XG59XG5mdW5jdGlvbiBhc3NlcnRSZXN0UHJvcGVydHkobm9kZSwgb3B0cykge1xuICAoMCwgX2RlcHJlY2F0aW9uV2FybmluZy5kZWZhdWx0KShcImFzc2VydFJlc3RQcm9wZXJ0eVwiLCBcImFzc2VydFJlc3RFbGVtZW50XCIpO1xuICBhc3NlcnQoXCJSZXN0UHJvcGVydHlcIiwgbm9kZSwgb3B0cyk7XG59XG5mdW5jdGlvbiBhc3NlcnRTcHJlYWRQcm9wZXJ0eShub2RlLCBvcHRzKSB7XG4gICgwLCBfZGVwcmVjYXRpb25XYXJuaW5nLmRlZmF1bHQpKFwiYXNzZXJ0U3ByZWFkUHJvcGVydHlcIiwgXCJhc3NlcnRTcHJlYWRFbGVtZW50XCIpO1xuICBhc3NlcnQoXCJTcHJlYWRQcm9wZXJ0eVwiLCBub2RlLCBvcHRzKTtcbn1cbmZ1bmN0aW9uIGFzc2VydE1vZHVsZURlY2xhcmF0aW9uKG5vZGUsIG9wdHMpIHtcbiAgKDAsIF9kZXByZWNhdGlvbldhcm5pbmcuZGVmYXVsdCkoXCJhc3NlcnRNb2R1bGVEZWNsYXJhdGlvblwiLCBcImFzc2VydEltcG9ydE9yRXhwb3J0RGVjbGFyYXRpb25cIik7XG4gIGFzc2VydChcIk1vZHVsZURlY2xhcmF0aW9uXCIsIG5vZGUsIG9wdHMpO1xufVxuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXBcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@babel/types/lib/asserts/generated/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@babel/types/lib/builders/flow/createFlowUnionType.js":
/*!****************************************************************************!*\
  !*** ./node_modules/@babel/types/lib/builders/flow/createFlowUnionType.js ***!
  \****************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports[\"default\"] = createFlowUnionType;\nvar _index = __webpack_require__(/*! ../generated/index.js */ \"(ssr)/./node_modules/@babel/types/lib/builders/generated/index.js\");\nvar _removeTypeDuplicates = __webpack_require__(/*! ../../modifications/flow/removeTypeDuplicates.js */ \"(ssr)/./node_modules/@babel/types/lib/modifications/flow/removeTypeDuplicates.js\");\nfunction createFlowUnionType(types) {\n  const flattened = (0, _removeTypeDuplicates.default)(types);\n  if (flattened.length === 1) {\n    return flattened[0];\n  } else {\n    return (0, _index.unionTypeAnnotation)(flattened);\n  }\n}\n\n//# sourceMappingURL=createFlowUnionType.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGJhYmVsL3R5cGVzL2xpYi9idWlsZGVycy9mbG93L2NyZWF0ZUZsb3dVbmlvblR5cGUuanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWIsOENBQTZDO0FBQzdDO0FBQ0EsQ0FBQyxFQUFDO0FBQ0Ysa0JBQWU7QUFDZixhQUFhLG1CQUFPLENBQUMsZ0dBQXVCO0FBQzVDLDRCQUE0QixtQkFBTyxDQUFDLDBJQUFrRDtBQUN0RjtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7O0FBRUEiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9yZXBvLXZpc3VhbGl6ZXIvLi9ub2RlX21vZHVsZXMvQGJhYmVsL3R5cGVzL2xpYi9idWlsZGVycy9mbG93L2NyZWF0ZUZsb3dVbmlvblR5cGUuanM/Mjk2YiJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuZGVmYXVsdCA9IGNyZWF0ZUZsb3dVbmlvblR5cGU7XG52YXIgX2luZGV4ID0gcmVxdWlyZShcIi4uL2dlbmVyYXRlZC9pbmRleC5qc1wiKTtcbnZhciBfcmVtb3ZlVHlwZUR1cGxpY2F0ZXMgPSByZXF1aXJlKFwiLi4vLi4vbW9kaWZpY2F0aW9ucy9mbG93L3JlbW92ZVR5cGVEdXBsaWNhdGVzLmpzXCIpO1xuZnVuY3Rpb24gY3JlYXRlRmxvd1VuaW9uVHlwZSh0eXBlcykge1xuICBjb25zdCBmbGF0dGVuZWQgPSAoMCwgX3JlbW92ZVR5cGVEdXBsaWNhdGVzLmRlZmF1bHQpKHR5cGVzKTtcbiAgaWYgKGZsYXR0ZW5lZC5sZW5ndGggPT09IDEpIHtcbiAgICByZXR1cm4gZmxhdHRlbmVkWzBdO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiAoMCwgX2luZGV4LnVuaW9uVHlwZUFubm90YXRpb24pKGZsYXR0ZW5lZCk7XG4gIH1cbn1cblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y3JlYXRlRmxvd1VuaW9uVHlwZS5qcy5tYXBcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@babel/types/lib/builders/flow/createFlowUnionType.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@babel/types/lib/builders/flow/createTypeAnnotationBasedOnTypeof.js":
/*!******************************************************************************************!*\
  !*** ./node_modules/@babel/types/lib/builders/flow/createTypeAnnotationBasedOnTypeof.js ***!
  \******************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports[\"default\"] = void 0;\nvar _index = __webpack_require__(/*! ../generated/index.js */ \"(ssr)/./node_modules/@babel/types/lib/builders/generated/index.js\");\nvar _default = exports[\"default\"] = createTypeAnnotationBasedOnTypeof;\nfunction createTypeAnnotationBasedOnTypeof(type) {\n  switch (type) {\n    case \"string\":\n      return (0, _index.stringTypeAnnotation)();\n    case \"number\":\n      return (0, _index.numberTypeAnnotation)();\n    case \"undefined\":\n      return (0, _index.voidTypeAnnotation)();\n    case \"boolean\":\n      return (0, _index.booleanTypeAnnotation)();\n    case \"function\":\n      return (0, _index.genericTypeAnnotation)((0, _index.identifier)(\"Function\"));\n    case \"object\":\n      return (0, _index.genericTypeAnnotation)((0, _index.identifier)(\"Object\"));\n    case \"symbol\":\n      return (0, _index.genericTypeAnnotation)((0, _index.identifier)(\"Symbol\"));\n    case \"bigint\":\n      return (0, _index.anyTypeAnnotation)();\n  }\n  throw new Error(\"Invalid typeof value: \" + type);\n}\n\n//# sourceMappingURL=createTypeAnnotationBasedOnTypeof.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGJhYmVsL3R5cGVzL2xpYi9idWlsZGVycy9mbG93L2NyZWF0ZVR5cGVBbm5vdGF0aW9uQmFzZWRPblR5cGVvZi5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYiw4Q0FBNkM7QUFDN0M7QUFDQSxDQUFDLEVBQUM7QUFDRixrQkFBZTtBQUNmLGFBQWEsbUJBQU8sQ0FBQyxnR0FBdUI7QUFDNUMsZUFBZSxrQkFBZTtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9yZXBvLXZpc3VhbGl6ZXIvLi9ub2RlX21vZHVsZXMvQGJhYmVsL3R5cGVzL2xpYi9idWlsZGVycy9mbG93L2NyZWF0ZVR5cGVBbm5vdGF0aW9uQmFzZWRPblR5cGVvZi5qcz9lZmY2Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5kZWZhdWx0ID0gdm9pZCAwO1xudmFyIF9pbmRleCA9IHJlcXVpcmUoXCIuLi9nZW5lcmF0ZWQvaW5kZXguanNcIik7XG52YXIgX2RlZmF1bHQgPSBleHBvcnRzLmRlZmF1bHQgPSBjcmVhdGVUeXBlQW5ub3RhdGlvbkJhc2VkT25UeXBlb2Y7XG5mdW5jdGlvbiBjcmVhdGVUeXBlQW5ub3RhdGlvbkJhc2VkT25UeXBlb2YodHlwZSkge1xuICBzd2l0Y2ggKHR5cGUpIHtcbiAgICBjYXNlIFwic3RyaW5nXCI6XG4gICAgICByZXR1cm4gKDAsIF9pbmRleC5zdHJpbmdUeXBlQW5ub3RhdGlvbikoKTtcbiAgICBjYXNlIFwibnVtYmVyXCI6XG4gICAgICByZXR1cm4gKDAsIF9pbmRleC5udW1iZXJUeXBlQW5ub3RhdGlvbikoKTtcbiAgICBjYXNlIFwidW5kZWZpbmVkXCI6XG4gICAgICByZXR1cm4gKDAsIF9pbmRleC52b2lkVHlwZUFubm90YXRpb24pKCk7XG4gICAgY2FzZSBcImJvb2xlYW5cIjpcbiAgICAgIHJldHVybiAoMCwgX2luZGV4LmJvb2xlYW5UeXBlQW5ub3RhdGlvbikoKTtcbiAgICBjYXNlIFwiZnVuY3Rpb25cIjpcbiAgICAgIHJldHVybiAoMCwgX2luZGV4LmdlbmVyaWNUeXBlQW5ub3RhdGlvbikoKDAsIF9pbmRleC5pZGVudGlmaWVyKShcIkZ1bmN0aW9uXCIpKTtcbiAgICBjYXNlIFwib2JqZWN0XCI6XG4gICAgICByZXR1cm4gKDAsIF9pbmRleC5nZW5lcmljVHlwZUFubm90YXRpb24pKCgwLCBfaW5kZXguaWRlbnRpZmllcikoXCJPYmplY3RcIikpO1xuICAgIGNhc2UgXCJzeW1ib2xcIjpcbiAgICAgIHJldHVybiAoMCwgX2luZGV4LmdlbmVyaWNUeXBlQW5ub3RhdGlvbikoKDAsIF9pbmRleC5pZGVudGlmaWVyKShcIlN5bWJvbFwiKSk7XG4gICAgY2FzZSBcImJpZ2ludFwiOlxuICAgICAgcmV0dXJuICgwLCBfaW5kZXguYW55VHlwZUFubm90YXRpb24pKCk7XG4gIH1cbiAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCB0eXBlb2YgdmFsdWU6IFwiICsgdHlwZSk7XG59XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNyZWF0ZVR5cGVBbm5vdGF0aW9uQmFzZWRPblR5cGVvZi5qcy5tYXBcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@babel/types/lib/builders/flow/createTypeAnnotationBasedOnTypeof.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@babel/types/lib/builders/generated/index.js":
/*!*******************************************************************!*\
  !*** ./node_modules/@babel/types/lib/builders/generated/index.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nvar _lowercase = __webpack_require__(/*! ./lowercase.js */ \"(ssr)/./node_modules/@babel/types/lib/builders/generated/lowercase.js\");\nObject.keys(_lowercase).forEach(function (key) {\n  if (key === \"default\" || key === \"__esModule\") return;\n  if (key in exports && exports[key] === _lowercase[key]) return;\n  Object.defineProperty(exports, key, {\n    enumerable: true,\n    get: function () {\n      return _lowercase[key];\n    }\n  });\n});\nvar _uppercase = __webpack_require__(/*! ./uppercase.js */ \"(ssr)/./node_modules/@babel/types/lib/builders/generated/uppercase.js\");\nObject.keys(_uppercase).forEach(function (key) {\n  if (key === \"default\" || key === \"__esModule\") return;\n  if (key in exports && exports[key] === _uppercase[key]) return;\n  Object.defineProperty(exports, key, {\n    enumerable: true,\n    get: function () {\n      return _uppercase[key];\n    }\n  });\n});\n\n//# sourceMappingURL=index.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGJhYmVsL3R5cGVzL2xpYi9idWlsZGVycy9nZW5lcmF0ZWQvaW5kZXguanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWIsOENBQTZDO0FBQzdDO0FBQ0EsQ0FBQyxFQUFDO0FBQ0YsaUJBQWlCLG1CQUFPLENBQUMsNkZBQWdCO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsQ0FBQztBQUNELGlCQUFpQixtQkFBTyxDQUFDLDZGQUFnQjtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILENBQUM7O0FBRUQiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9yZXBvLXZpc3VhbGl6ZXIvLi9ub2RlX21vZHVsZXMvQGJhYmVsL3R5cGVzL2xpYi9idWlsZGVycy9nZW5lcmF0ZWQvaW5kZXguanM/NTIwNiJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbnZhciBfbG93ZXJjYXNlID0gcmVxdWlyZShcIi4vbG93ZXJjYXNlLmpzXCIpO1xuT2JqZWN0LmtleXMoX2xvd2VyY2FzZSkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gIGlmIChrZXkgPT09IFwiZGVmYXVsdFwiIHx8IGtleSA9PT0gXCJfX2VzTW9kdWxlXCIpIHJldHVybjtcbiAgaWYgKGtleSBpbiBleHBvcnRzICYmIGV4cG9ydHNba2V5XSA9PT0gX2xvd2VyY2FzZVtrZXldKSByZXR1cm47XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBrZXksIHtcbiAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIF9sb3dlcmNhc2Vba2V5XTtcbiAgICB9XG4gIH0pO1xufSk7XG52YXIgX3VwcGVyY2FzZSA9IHJlcXVpcmUoXCIuL3VwcGVyY2FzZS5qc1wiKTtcbk9iamVjdC5rZXlzKF91cHBlcmNhc2UpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICBpZiAoa2V5ID09PSBcImRlZmF1bHRcIiB8fCBrZXkgPT09IFwiX19lc01vZHVsZVwiKSByZXR1cm47XG4gIGlmIChrZXkgaW4gZXhwb3J0cyAmJiBleHBvcnRzW2tleV0gPT09IF91cHBlcmNhc2Vba2V5XSkgcmV0dXJuO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywga2V5LCB7XG4gICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBfdXBwZXJjYXNlW2tleV07XG4gICAgfVxuICB9KTtcbn0pO1xuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXBcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@babel/types/lib/builders/generated/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@babel/types/lib/builders/generated/lowercase.js":
/*!***********************************************************************!*\
  !*** ./node_modules/@babel/types/lib/builders/generated/lowercase.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports.anyTypeAnnotation = anyTypeAnnotation;\nexports.argumentPlaceholder = argumentPlaceholder;\nexports.arrayExpression = arrayExpression;\nexports.arrayPattern = arrayPattern;\nexports.arrayTypeAnnotation = arrayTypeAnnotation;\nexports.arrowFunctionExpression = arrowFunctionExpression;\nexports.assignmentExpression = assignmentExpression;\nexports.assignmentPattern = assignmentPattern;\nexports.awaitExpression = awaitExpression;\nexports.bigIntLiteral = bigIntLiteral;\nexports.binaryExpression = binaryExpression;\nexports.bindExpression = bindExpression;\nexports.blockStatement = blockStatement;\nexports.booleanLiteral = booleanLiteral;\nexports.booleanLiteralTypeAnnotation = booleanLiteralTypeAnnotation;\nexports.booleanTypeAnnotation = booleanTypeAnnotation;\nexports.breakStatement = breakStatement;\nexports.callExpression = callExpression;\nexports.catchClause = catchClause;\nexports.classAccessorProperty = classAccessorProperty;\nexports.classBody = classBody;\nexports.classDeclaration = classDeclaration;\nexports.classExpression = classExpression;\nexports.classImplements = classImplements;\nexports.classMethod = classMethod;\nexports.classPrivateMethod = classPrivateMethod;\nexports.classPrivateProperty = classPrivateProperty;\nexports.classProperty = classProperty;\nexports.conditionalExpression = conditionalExpression;\nexports.continueStatement = continueStatement;\nexports.debuggerStatement = debuggerStatement;\nexports.decimalLiteral = decimalLiteral;\nexports.declareClass = declareClass;\nexports.declareExportAllDeclaration = declareExportAllDeclaration;\nexports.declareExportDeclaration = declareExportDeclaration;\nexports.declareFunction = declareFunction;\nexports.declareInterface = declareInterface;\nexports.declareModule = declareModule;\nexports.declareModuleExports = declareModuleExports;\nexports.declareOpaqueType = declareOpaqueType;\nexports.declareTypeAlias = declareTypeAlias;\nexports.declareVariable = declareVariable;\nexports.declaredPredicate = declaredPredicate;\nexports.decorator = decorator;\nexports.directive = directive;\nexports.directiveLiteral = directiveLiteral;\nexports.doExpression = doExpression;\nexports.doWhileStatement = doWhileStatement;\nexports.emptyStatement = emptyStatement;\nexports.emptyTypeAnnotation = emptyTypeAnnotation;\nexports.enumBooleanBody = enumBooleanBody;\nexports.enumBooleanMember = enumBooleanMember;\nexports.enumDeclaration = enumDeclaration;\nexports.enumDefaultedMember = enumDefaultedMember;\nexports.enumNumberBody = enumNumberBody;\nexports.enumNumberMember = enumNumberMember;\nexports.enumStringBody = enumStringBody;\nexports.enumStringMember = enumStringMember;\nexports.enumSymbolBody = enumSymbolBody;\nexports.existsTypeAnnotation = existsTypeAnnotation;\nexports.exportAllDeclaration = exportAllDeclaration;\nexports.exportDefaultDeclaration = exportDefaultDeclaration;\nexports.exportDefaultSpecifier = exportDefaultSpecifier;\nexports.exportNamedDeclaration = exportNamedDeclaration;\nexports.exportNamespaceSpecifier = exportNamespaceSpecifier;\nexports.exportSpecifier = exportSpecifier;\nexports.expressionStatement = expressionStatement;\nexports.file = file;\nexports.forInStatement = forInStatement;\nexports.forOfStatement = forOfStatement;\nexports.forStatement = forStatement;\nexports.functionDeclaration = functionDeclaration;\nexports.functionExpression = functionExpression;\nexports.functionTypeAnnotation = functionTypeAnnotation;\nexports.functionTypeParam = functionTypeParam;\nexports.genericTypeAnnotation = genericTypeAnnotation;\nexports.identifier = identifier;\nexports.ifStatement = ifStatement;\nexports[\"import\"] = _import;\nexports.importAttribute = importAttribute;\nexports.importDeclaration = importDeclaration;\nexports.importDefaultSpecifier = importDefaultSpecifier;\nexports.importExpression = importExpression;\nexports.importNamespaceSpecifier = importNamespaceSpecifier;\nexports.importSpecifier = importSpecifier;\nexports.indexedAccessType = indexedAccessType;\nexports.inferredPredicate = inferredPredicate;\nexports.interfaceDeclaration = interfaceDeclaration;\nexports.interfaceExtends = interfaceExtends;\nexports.interfaceTypeAnnotation = interfaceTypeAnnotation;\nexports.interpreterDirective = interpreterDirective;\nexports.intersectionTypeAnnotation = intersectionTypeAnnotation;\nexports.jSXAttribute = exports.jsxAttribute = jsxAttribute;\nexports.jSXClosingElement = exports.jsxClosingElement = jsxClosingElement;\nexports.jSXClosingFragment = exports.jsxClosingFragment = jsxClosingFragment;\nexports.jSXElement = exports.jsxElement = jsxElement;\nexports.jSXEmptyExpression = exports.jsxEmptyExpression = jsxEmptyExpression;\nexports.jSXExpressionContainer = exports.jsxExpressionContainer = jsxExpressionContainer;\nexports.jSXFragment = exports.jsxFragment = jsxFragment;\nexports.jSXIdentifier = exports.jsxIdentifier = jsxIdentifier;\nexports.jSXMemberExpression = exports.jsxMemberExpression = jsxMemberExpression;\nexports.jSXNamespacedName = exports.jsxNamespacedName = jsxNamespacedName;\nexports.jSXOpeningElement = exports.jsxOpeningElement = jsxOpeningElement;\nexports.jSXOpeningFragment = exports.jsxOpeningFragment = jsxOpeningFragment;\nexports.jSXSpreadAttribute = exports.jsxSpreadAttribute = jsxSpreadAttribute;\nexports.jSXSpreadChild = exports.jsxSpreadChild = jsxSpreadChild;\nexports.jSXText = exports.jsxText = jsxText;\nexports.labeledStatement = labeledStatement;\nexports.logicalExpression = logicalExpression;\nexports.memberExpression = memberExpression;\nexports.metaProperty = metaProperty;\nexports.mixedTypeAnnotation = mixedTypeAnnotation;\nexports.moduleExpression = moduleExpression;\nexports.newExpression = newExpression;\nexports.noop = noop;\nexports.nullLiteral = nullLiteral;\nexports.nullLiteralTypeAnnotation = nullLiteralTypeAnnotation;\nexports.nullableTypeAnnotation = nullableTypeAnnotation;\nexports.numberLiteral = NumberLiteral;\nexports.numberLiteralTypeAnnotation = numberLiteralTypeAnnotation;\nexports.numberTypeAnnotation = numberTypeAnnotation;\nexports.numericLiteral = numericLiteral;\nexports.objectExpression = objectExpression;\nexports.objectMethod = objectMethod;\nexports.objectPattern = objectPattern;\nexports.objectProperty = objectProperty;\nexports.objectTypeAnnotation = objectTypeAnnotation;\nexports.objectTypeCallProperty = objectTypeCallProperty;\nexports.objectTypeIndexer = objectTypeIndexer;\nexports.objectTypeInternalSlot = objectTypeInternalSlot;\nexports.objectTypeProperty = objectTypeProperty;\nexports.objectTypeSpreadProperty = objectTypeSpreadProperty;\nexports.opaqueType = opaqueType;\nexports.optionalCallExpression = optionalCallExpression;\nexports.optionalIndexedAccessType = optionalIndexedAccessType;\nexports.optionalMemberExpression = optionalMemberExpression;\nexports.parenthesizedExpression = parenthesizedExpression;\nexports.pipelineBareFunction = pipelineBareFunction;\nexports.pipelinePrimaryTopicReference = pipelinePrimaryTopicReference;\nexports.pipelineTopicExpression = pipelineTopicExpression;\nexports.placeholder = placeholder;\nexports.privateName = privateName;\nexports.program = program;\nexports.qualifiedTypeIdentifier = qualifiedTypeIdentifier;\nexports.recordExpression = recordExpression;\nexports.regExpLiteral = regExpLiteral;\nexports.regexLiteral = RegexLiteral;\nexports.restElement = restElement;\nexports.restProperty = RestProperty;\nexports.returnStatement = returnStatement;\nexports.sequenceExpression = sequenceExpression;\nexports.spreadElement = spreadElement;\nexports.spreadProperty = SpreadProperty;\nexports.staticBlock = staticBlock;\nexports.stringLiteral = stringLiteral;\nexports.stringLiteralTypeAnnotation = stringLiteralTypeAnnotation;\nexports.stringTypeAnnotation = stringTypeAnnotation;\nexports[\"super\"] = _super;\nexports.switchCase = switchCase;\nexports.switchStatement = switchStatement;\nexports.symbolTypeAnnotation = symbolTypeAnnotation;\nexports.taggedTemplateExpression = taggedTemplateExpression;\nexports.templateElement = templateElement;\nexports.templateLiteral = templateLiteral;\nexports.thisExpression = thisExpression;\nexports.thisTypeAnnotation = thisTypeAnnotation;\nexports.throwStatement = throwStatement;\nexports.topicReference = topicReference;\nexports.tryStatement = tryStatement;\nexports.tSAnyKeyword = exports.tsAnyKeyword = tsAnyKeyword;\nexports.tSArrayType = exports.tsArrayType = tsArrayType;\nexports.tSAsExpression = exports.tsAsExpression = tsAsExpression;\nexports.tSBigIntKeyword = exports.tsBigIntKeyword = tsBigIntKeyword;\nexports.tSBooleanKeyword = exports.tsBooleanKeyword = tsBooleanKeyword;\nexports.tSCallSignatureDeclaration = exports.tsCallSignatureDeclaration = tsCallSignatureDeclaration;\nexports.tSConditionalType = exports.tsConditionalType = tsConditionalType;\nexports.tSConstructSignatureDeclaration = exports.tsConstructSignatureDeclaration = tsConstructSignatureDeclaration;\nexports.tSConstructorType = exports.tsConstructorType = tsConstructorType;\nexports.tSDeclareFunction = exports.tsDeclareFunction = tsDeclareFunction;\nexports.tSDeclareMethod = exports.tsDeclareMethod = tsDeclareMethod;\nexports.tSEnumBody = exports.tsEnumBody = tsEnumBody;\nexports.tSEnumDeclaration = exports.tsEnumDeclaration = tsEnumDeclaration;\nexports.tSEnumMember = exports.tsEnumMember = tsEnumMember;\nexports.tSExportAssignment = exports.tsExportAssignment = tsExportAssignment;\nexports.tSExpressionWithTypeArguments = exports.tsExpressionWithTypeArguments = tsExpressionWithTypeArguments;\nexports.tSExternalModuleReference = exports.tsExternalModuleReference = tsExternalModuleReference;\nexports.tSFunctionType = exports.tsFunctionType = tsFunctionType;\nexports.tSImportEqualsDeclaration = exports.tsImportEqualsDeclaration = tsImportEqualsDeclaration;\nexports.tSImportType = exports.tsImportType = tsImportType;\nexports.tSIndexSignature = exports.tsIndexSignature = tsIndexSignature;\nexports.tSIndexedAccessType = exports.tsIndexedAccessType = tsIndexedAccessType;\nexports.tSInferType = exports.tsInferType = tsInferType;\nexports.tSInstantiationExpression = exports.tsInstantiationExpression = tsInstantiationExpression;\nexports.tSInterfaceBody = exports.tsInterfaceBody = tsInterfaceBody;\nexports.tSInterfaceDeclaration = exports.tsInterfaceDeclaration = tsInterfaceDeclaration;\nexports.tSIntersectionType = exports.tsIntersectionType = tsIntersectionType;\nexports.tSIntrinsicKeyword = exports.tsIntrinsicKeyword = tsIntrinsicKeyword;\nexports.tSLiteralType = exports.tsLiteralType = tsLiteralType;\nexports.tSMappedType = exports.tsMappedType = tsMappedType;\nexports.tSMethodSignature = exports.tsMethodSignature = tsMethodSignature;\nexports.tSModuleBlock = exports.tsModuleBlock = tsModuleBlock;\nexports.tSModuleDeclaration = exports.tsModuleDeclaration = tsModuleDeclaration;\nexports.tSNamedTupleMember = exports.tsNamedTupleMember = tsNamedTupleMember;\nexports.tSNamespaceExportDeclaration = exports.tsNamespaceExportDeclaration = tsNamespaceExportDeclaration;\nexports.tSNeverKeyword = exports.tsNeverKeyword = tsNeverKeyword;\nexports.tSNonNullExpression = exports.tsNonNullExpression = tsNonNullExpression;\nexports.tSNullKeyword = exports.tsNullKeyword = tsNullKeyword;\nexports.tSNumberKeyword = exports.tsNumberKeyword = tsNumberKeyword;\nexports.tSObjectKeyword = exports.tsObjectKeyword = tsObjectKeyword;\nexports.tSOptionalType = exports.tsOptionalType = tsOptionalType;\nexports.tSParameterProperty = exports.tsParameterProperty = tsParameterProperty;\nexports.tSParenthesizedType = exports.tsParenthesizedType = tsParenthesizedType;\nexports.tSPropertySignature = exports.tsPropertySignature = tsPropertySignature;\nexports.tSQualifiedName = exports.tsQualifiedName = tsQualifiedName;\nexports.tSRestType = exports.tsRestType = tsRestType;\nexports.tSSatisfiesExpression = exports.tsSatisfiesExpression = tsSatisfiesExpression;\nexports.tSStringKeyword = exports.tsStringKeyword = tsStringKeyword;\nexports.tSSymbolKeyword = exports.tsSymbolKeyword = tsSymbolKeyword;\nexports.tSTemplateLiteralType = exports.tsTemplateLiteralType = tsTemplateLiteralType;\nexports.tSThisType = exports.tsThisType = tsThisType;\nexports.tSTupleType = exports.tsTupleType = tsTupleType;\nexports.tSTypeAliasDeclaration = exports.tsTypeAliasDeclaration = tsTypeAliasDeclaration;\nexports.tSTypeAnnotation = exports.tsTypeAnnotation = tsTypeAnnotation;\nexports.tSTypeAssertion = exports.tsTypeAssertion = tsTypeAssertion;\nexports.tSTypeLiteral = exports.tsTypeLiteral = tsTypeLiteral;\nexports.tSTypeOperator = exports.tsTypeOperator = tsTypeOperator;\nexports.tSTypeParameter = exports.tsTypeParameter = tsTypeParameter;\nexports.tSTypeParameterDeclaration = exports.tsTypeParameterDeclaration = tsTypeParameterDeclaration;\nexports.tSTypeParameterInstantiation = exports.tsTypeParameterInstantiation = tsTypeParameterInstantiation;\nexports.tSTypePredicate = exports.tsTypePredicate = tsTypePredicate;\nexports.tSTypeQuery = exports.tsTypeQuery = tsTypeQuery;\nexports.tSTypeReference = exports.tsTypeReference = tsTypeReference;\nexports.tSUndefinedKeyword = exports.tsUndefinedKeyword = tsUndefinedKeyword;\nexports.tSUnionType = exports.tsUnionType = tsUnionType;\nexports.tSUnknownKeyword = exports.tsUnknownKeyword = tsUnknownKeyword;\nexports.tSVoidKeyword = exports.tsVoidKeyword = tsVoidKeyword;\nexports.tupleExpression = tupleExpression;\nexports.tupleTypeAnnotation = tupleTypeAnnotation;\nexports.typeAlias = typeAlias;\nexports.typeAnnotation = typeAnnotation;\nexports.typeCastExpression = typeCastExpression;\nexports.typeParameter = typeParameter;\nexports.typeParameterDeclaration = typeParameterDeclaration;\nexports.typeParameterInstantiation = typeParameterInstantiation;\nexports.typeofTypeAnnotation = typeofTypeAnnotation;\nexports.unaryExpression = unaryExpression;\nexports.unionTypeAnnotation = unionTypeAnnotation;\nexports.updateExpression = updateExpression;\nexports.v8IntrinsicIdentifier = v8IntrinsicIdentifier;\nexports.variableDeclaration = variableDeclaration;\nexports.variableDeclarator = variableDeclarator;\nexports.variance = variance;\nexports.voidPattern = voidPattern;\nexports.voidTypeAnnotation = voidTypeAnnotation;\nexports.whileStatement = whileStatement;\nexports.withStatement = withStatement;\nexports.yieldExpression = yieldExpression;\nvar _validate = __webpack_require__(/*! ../../validators/validate.js */ \"(ssr)/./node_modules/@babel/types/lib/validators/validate.js\");\nvar _deprecationWarning = __webpack_require__(/*! ../../utils/deprecationWarning.js */ \"(ssr)/./node_modules/@babel/types/lib/utils/deprecationWarning.js\");\nvar utils = __webpack_require__(/*! ../../definitions/utils.js */ \"(ssr)/./node_modules/@babel/types/lib/definitions/utils.js\");\nconst {\n  validateInternal: validate\n} = _validate;\nconst {\n  NODE_FIELDS\n} = utils;\nfunction bigIntLiteral(value) {\n  if (typeof value === \"bigint\") {\n    value = value.toString();\n  }\n  const node = {\n    type: \"BigIntLiteral\",\n    value\n  };\n  const defs = NODE_FIELDS.BigIntLiteral;\n  validate(defs.value, node, \"value\", value);\n  return node;\n}\nfunction arrayExpression(elements = []) {\n  const node = {\n    type: \"ArrayExpression\",\n    elements\n  };\n  const defs = NODE_FIELDS.ArrayExpression;\n  validate(defs.elements, node, \"elements\", elements, 1);\n  return node;\n}\nfunction assignmentExpression(operator, left, right) {\n  const node = {\n    type: \"AssignmentExpression\",\n    operator,\n    left,\n    right\n  };\n  const defs = NODE_FIELDS.AssignmentExpression;\n  validate(defs.operator, node, \"operator\", operator);\n  validate(defs.left, node, \"left\", left, 1);\n  validate(defs.right, node, \"right\", right, 1);\n  return node;\n}\nfunction binaryExpression(operator, left, right) {\n  const node = {\n    type: \"BinaryExpression\",\n    operator,\n    left,\n    right\n  };\n  const defs = NODE_FIELDS.BinaryExpression;\n  validate(defs.operator, node, \"operator\", operator);\n  validate(defs.left, node, \"left\", left, 1);\n  validate(defs.right, node, \"right\", right, 1);\n  return node;\n}\nfunction interpreterDirective(value) {\n  const node = {\n    type: \"InterpreterDirective\",\n    value\n  };\n  const defs = NODE_FIELDS.InterpreterDirective;\n  validate(defs.value, node, \"value\", value);\n  return node;\n}\nfunction directive(value) {\n  const node = {\n    type: \"Directive\",\n    value\n  };\n  const defs = NODE_FIELDS.Directive;\n  validate(defs.value, node, \"value\", value, 1);\n  return node;\n}\nfunction directiveLiteral(value) {\n  const node = {\n    type: \"DirectiveLiteral\",\n    value\n  };\n  const defs = NODE_FIELDS.DirectiveLiteral;\n  validate(defs.value, node, \"value\", value);\n  return node;\n}\nfunction blockStatement(body, directives = []) {\n  const node = {\n    type: \"BlockStatement\",\n    body,\n    directives\n  };\n  const defs = NODE_FIELDS.BlockStatement;\n  validate(defs.body, node, \"body\", body, 1);\n  validate(defs.directives, node, \"directives\", directives, 1);\n  return node;\n}\nfunction breakStatement(label = null) {\n  const node = {\n    type: \"BreakStatement\",\n    label\n  };\n  const defs = NODE_FIELDS.BreakStatement;\n  validate(defs.label, node, \"label\", label, 1);\n  return node;\n}\nfunction callExpression(callee, _arguments) {\n  const node = {\n    type: \"CallExpression\",\n    callee,\n    arguments: _arguments\n  };\n  const defs = NODE_FIELDS.CallExpression;\n  validate(defs.callee, node, \"callee\", callee, 1);\n  validate(defs.arguments, node, \"arguments\", _arguments, 1);\n  return node;\n}\nfunction catchClause(param = null, body) {\n  const node = {\n    type: \"CatchClause\",\n    param,\n    body\n  };\n  const defs = NODE_FIELDS.CatchClause;\n  validate(defs.param, node, \"param\", param, 1);\n  validate(defs.body, node, \"body\", body, 1);\n  return node;\n}\nfunction conditionalExpression(test, consequent, alternate) {\n  const node = {\n    type: \"ConditionalExpression\",\n    test,\n    consequent,\n    alternate\n  };\n  const defs = NODE_FIELDS.ConditionalExpression;\n  validate(defs.test, node, \"test\", test, 1);\n  validate(defs.consequent, node, \"consequent\", consequent, 1);\n  validate(defs.alternate, node, \"alternate\", alternate, 1);\n  return node;\n}\nfunction continueStatement(label = null) {\n  const node = {\n    type: \"ContinueStatement\",\n    label\n  };\n  const defs = NODE_FIELDS.ContinueStatement;\n  validate(defs.label, node, \"label\", label, 1);\n  return node;\n}\nfunction debuggerStatement() {\n  return {\n    type: \"DebuggerStatement\"\n  };\n}\nfunction doWhileStatement(test, body) {\n  const node = {\n    type: \"DoWhileStatement\",\n    test,\n    body\n  };\n  const defs = NODE_FIELDS.DoWhileStatement;\n  validate(defs.test, node, \"test\", test, 1);\n  validate(defs.body, node, \"body\", body, 1);\n  return node;\n}\nfunction emptyStatement() {\n  return {\n    type: \"EmptyStatement\"\n  };\n}\nfunction expressionStatement(expression) {\n  const node = {\n    type: \"ExpressionStatement\",\n    expression\n  };\n  const defs = NODE_FIELDS.ExpressionStatement;\n  validate(defs.expression, node, \"expression\", expression, 1);\n  return node;\n}\nfunction file(program, comments = null, tokens = null) {\n  const node = {\n    type: \"File\",\n    program,\n    comments,\n    tokens\n  };\n  const defs = NODE_FIELDS.File;\n  validate(defs.program, node, \"program\", program, 1);\n  validate(defs.comments, node, \"comments\", comments, 1);\n  validate(defs.tokens, node, \"tokens\", tokens);\n  return node;\n}\nfunction forInStatement(left, right, body) {\n  const node = {\n    type: \"ForInStatement\",\n    left,\n    right,\n    body\n  };\n  const defs = NODE_FIELDS.ForInStatement;\n  validate(defs.left, node, \"left\", left, 1);\n  validate(defs.right, node, \"right\", right, 1);\n  validate(defs.body, node, \"body\", body, 1);\n  return node;\n}\nfunction forStatement(init = null, test = null, update = null, body) {\n  const node = {\n    type: \"ForStatement\",\n    init,\n    test,\n    update,\n    body\n  };\n  const defs = NODE_FIELDS.ForStatement;\n  validate(defs.init, node, \"init\", init, 1);\n  validate(defs.test, node, \"test\", test, 1);\n  validate(defs.update, node, \"update\", update, 1);\n  validate(defs.body, node, \"body\", body, 1);\n  return node;\n}\nfunction functionDeclaration(id = null, params, body, generator = false, async = false) {\n  const node = {\n    type: \"FunctionDeclaration\",\n    id,\n    params,\n    body,\n    generator,\n    async\n  };\n  const defs = NODE_FIELDS.FunctionDeclaration;\n  validate(defs.id, node, \"id\", id, 1);\n  validate(defs.params, node, \"params\", params, 1);\n  validate(defs.body, node, \"body\", body, 1);\n  validate(defs.generator, node, \"generator\", generator);\n  validate(defs.async, node, \"async\", async);\n  return node;\n}\nfunction functionExpression(id = null, params, body, generator = false, async = false) {\n  const node = {\n    type: \"FunctionExpression\",\n    id,\n    params,\n    body,\n    generator,\n    async\n  };\n  const defs = NODE_FIELDS.FunctionExpression;\n  validate(defs.id, node, \"id\", id, 1);\n  validate(defs.params, node, \"params\", params, 1);\n  validate(defs.body, node, \"body\", body, 1);\n  validate(defs.generator, node, \"generator\", generator);\n  validate(defs.async, node, \"async\", async);\n  return node;\n}\nfunction identifier(name) {\n  const node = {\n    type: \"Identifier\",\n    name\n  };\n  const defs = NODE_FIELDS.Identifier;\n  validate(defs.name, node, \"name\", name);\n  return node;\n}\nfunction ifStatement(test, consequent, alternate = null) {\n  const node = {\n    type: \"IfStatement\",\n    test,\n    consequent,\n    alternate\n  };\n  const defs = NODE_FIELDS.IfStatement;\n  validate(defs.test, node, \"test\", test, 1);\n  validate(defs.consequent, node, \"consequent\", consequent, 1);\n  validate(defs.alternate, node, \"alternate\", alternate, 1);\n  return node;\n}\nfunction labeledStatement(label, body) {\n  const node = {\n    type: \"LabeledStatement\",\n    label,\n    body\n  };\n  const defs = NODE_FIELDS.LabeledStatement;\n  validate(defs.label, node, \"label\", label, 1);\n  validate(defs.body, node, \"body\", body, 1);\n  return node;\n}\nfunction stringLiteral(value) {\n  const node = {\n    type: \"StringLiteral\",\n    value\n  };\n  const defs = NODE_FIELDS.StringLiteral;\n  validate(defs.value, node, \"value\", value);\n  return node;\n}\nfunction numericLiteral(value) {\n  const node = {\n    type: \"NumericLiteral\",\n    value\n  };\n  const defs = NODE_FIELDS.NumericLiteral;\n  validate(defs.value, node, \"value\", value);\n  return node;\n}\nfunction nullLiteral() {\n  return {\n    type: \"NullLiteral\"\n  };\n}\nfunction booleanLiteral(value) {\n  const node = {\n    type: \"BooleanLiteral\",\n    value\n  };\n  const defs = NODE_FIELDS.BooleanLiteral;\n  validate(defs.value, node, \"value\", value);\n  return node;\n}\nfunction regExpLiteral(pattern, flags = \"\") {\n  const node = {\n    type: \"RegExpLiteral\",\n    pattern,\n    flags\n  };\n  const defs = NODE_FIELDS.RegExpLiteral;\n  validate(defs.pattern, node, \"pattern\", pattern);\n  validate(defs.flags, node, \"flags\", flags);\n  return node;\n}\nfunction logicalExpression(operator, left, right) {\n  const node = {\n    type: \"LogicalExpression\",\n    operator,\n    left,\n    right\n  };\n  const defs = NODE_FIELDS.LogicalExpression;\n  validate(defs.operator, node, \"operator\", operator);\n  validate(defs.left, node, \"left\", left, 1);\n  validate(defs.right, node, \"right\", right, 1);\n  return node;\n}\nfunction memberExpression(object, property, computed = false, optional = null) {\n  const node = {\n    type: \"MemberExpression\",\n    object,\n    property,\n    computed,\n    optional\n  };\n  const defs = NODE_FIELDS.MemberExpression;\n  validate(defs.object, node, \"object\", object, 1);\n  validate(defs.property, node, \"property\", property, 1);\n  validate(defs.computed, node, \"computed\", computed);\n  validate(defs.optional, node, \"optional\", optional);\n  return node;\n}\nfunction newExpression(callee, _arguments) {\n  const node = {\n    type: \"NewExpression\",\n    callee,\n    arguments: _arguments\n  };\n  const defs = NODE_FIELDS.NewExpression;\n  validate(defs.callee, node, \"callee\", callee, 1);\n  validate(defs.arguments, node, \"arguments\", _arguments, 1);\n  return node;\n}\nfunction program(body, directives = [], sourceType = \"script\", interpreter = null) {\n  const node = {\n    type: \"Program\",\n    body,\n    directives,\n    sourceType,\n    interpreter\n  };\n  const defs = NODE_FIELDS.Program;\n  validate(defs.body, node, \"body\", body, 1);\n  validate(defs.directives, node, \"directives\", directives, 1);\n  validate(defs.sourceType, node, \"sourceType\", sourceType);\n  validate(defs.interpreter, node, \"interpreter\", interpreter, 1);\n  return node;\n}\nfunction objectExpression(properties) {\n  const node = {\n    type: \"ObjectExpression\",\n    properties\n  };\n  const defs = NODE_FIELDS.ObjectExpression;\n  validate(defs.properties, node, \"properties\", properties, 1);\n  return node;\n}\nfunction objectMethod(kind = \"method\", key, params, body, computed = false, generator = false, async = false) {\n  const node = {\n    type: \"ObjectMethod\",\n    kind,\n    key,\n    params,\n    body,\n    computed,\n    generator,\n    async\n  };\n  const defs = NODE_FIELDS.ObjectMethod;\n  validate(defs.kind, node, \"kind\", kind);\n  validate(defs.key, node, \"key\", key, 1);\n  validate(defs.params, node, \"params\", params, 1);\n  validate(defs.body, node, \"body\", body, 1);\n  validate(defs.computed, node, \"computed\", computed);\n  validate(defs.generator, node, \"generator\", generator);\n  validate(defs.async, node, \"async\", async);\n  return node;\n}\nfunction objectProperty(key, value, computed = false, shorthand = false, decorators = null) {\n  const node = {\n    type: \"ObjectProperty\",\n    key,\n    value,\n    computed,\n    shorthand,\n    decorators\n  };\n  const defs = NODE_FIELDS.ObjectProperty;\n  validate(defs.key, node, \"key\", key, 1);\n  validate(defs.value, node, \"value\", value, 1);\n  validate(defs.computed, node, \"computed\", computed);\n  validate(defs.shorthand, node, \"shorthand\", shorthand);\n  validate(defs.decorators, node, \"decorators\", decorators, 1);\n  return node;\n}\nfunction restElement(argument) {\n  const node = {\n    type: \"RestElement\",\n    argument\n  };\n  const defs = NODE_FIELDS.RestElement;\n  validate(defs.argument, node, \"argument\", argument, 1);\n  return node;\n}\nfunction returnStatement(argument = null) {\n  const node = {\n    type: \"ReturnStatement\",\n    argument\n  };\n  const defs = NODE_FIELDS.ReturnStatement;\n  validate(defs.argument, node, \"argument\", argument, 1);\n  return node;\n}\nfunction sequenceExpression(expressions) {\n  const node = {\n    type: \"SequenceExpression\",\n    expressions\n  };\n  const defs = NODE_FIELDS.SequenceExpression;\n  validate(defs.expressions, node, \"expressions\", expressions, 1);\n  return node;\n}\nfunction parenthesizedExpression(expression) {\n  const node = {\n    type: \"ParenthesizedExpression\",\n    expression\n  };\n  const defs = NODE_FIELDS.ParenthesizedExpression;\n  validate(defs.expression, node, \"expression\", expression, 1);\n  return node;\n}\nfunction switchCase(test = null, consequent) {\n  const node = {\n    type: \"SwitchCase\",\n    test,\n    consequent\n  };\n  const defs = NODE_FIELDS.SwitchCase;\n  validate(defs.test, node, \"test\", test, 1);\n  validate(defs.consequent, node, \"consequent\", consequent, 1);\n  return node;\n}\nfunction switchStatement(discriminant, cases) {\n  const node = {\n    type: \"SwitchStatement\",\n    discriminant,\n    cases\n  };\n  const defs = NODE_FIELDS.SwitchStatement;\n  validate(defs.discriminant, node, \"discriminant\", discriminant, 1);\n  validate(defs.cases, node, \"cases\", cases, 1);\n  return node;\n}\nfunction thisExpression() {\n  return {\n    type: \"ThisExpression\"\n  };\n}\nfunction throwStatement(argument) {\n  const node = {\n    type: \"ThrowStatement\",\n    argument\n  };\n  const defs = NODE_FIELDS.ThrowStatement;\n  validate(defs.argument, node, \"argument\", argument, 1);\n  return node;\n}\nfunction tryStatement(block, handler = null, finalizer = null) {\n  const node = {\n    type: \"TryStatement\",\n    block,\n    handler,\n    finalizer\n  };\n  const defs = NODE_FIELDS.TryStatement;\n  validate(defs.block, node, \"block\", block, 1);\n  validate(defs.handler, node, \"handler\", handler, 1);\n  validate(defs.finalizer, node, \"finalizer\", finalizer, 1);\n  return node;\n}\nfunction unaryExpression(operator, argument, prefix = true) {\n  const node = {\n    type: \"UnaryExpression\",\n    operator,\n    argument,\n    prefix\n  };\n  const defs = NODE_FIELDS.UnaryExpression;\n  validate(defs.operator, node, \"operator\", operator);\n  validate(defs.argument, node, \"argument\", argument, 1);\n  validate(defs.prefix, node, \"prefix\", prefix);\n  return node;\n}\nfunction updateExpression(operator, argument, prefix = false) {\n  const node = {\n    type: \"UpdateExpression\",\n    operator,\n    argument,\n    prefix\n  };\n  const defs = NODE_FIELDS.UpdateExpression;\n  validate(defs.operator, node, \"operator\", operator);\n  validate(defs.argument, node, \"argument\", argument, 1);\n  validate(defs.prefix, node, \"prefix\", prefix);\n  return node;\n}\nfunction variableDeclaration(kind, declarations) {\n  const node = {\n    type: \"VariableDeclaration\",\n    kind,\n    declarations\n  };\n  const defs = NODE_FIELDS.VariableDeclaration;\n  validate(defs.kind, node, \"kind\", kind);\n  validate(defs.declarations, node, \"declarations\", declarations, 1);\n  return node;\n}\nfunction variableDeclarator(id, init = null) {\n  const node = {\n    type: \"VariableDeclarator\",\n    id,\n    init\n  };\n  const defs = NODE_FIELDS.VariableDeclarator;\n  validate(defs.id, node, \"id\", id, 1);\n  validate(defs.init, node, \"init\", init, 1);\n  return node;\n}\nfunction whileStatement(test, body) {\n  const node = {\n    type: \"WhileStatement\",\n    test,\n    body\n  };\n  const defs = NODE_FIELDS.WhileStatement;\n  validate(defs.test, node, \"test\", test, 1);\n  validate(defs.body, node, \"body\", body, 1);\n  return node;\n}\nfunction withStatement(object, body) {\n  const node = {\n    type: \"WithStatement\",\n    object,\n    body\n  };\n  const defs = NODE_FIELDS.WithStatement;\n  validate(defs.object, node, \"object\", object, 1);\n  validate(defs.body, node, \"body\", body, 1);\n  return node;\n}\nfunction assignmentPattern(left, right) {\n  const node = {\n    type: \"AssignmentPattern\",\n    left,\n    right\n  };\n  const defs = NODE_FIELDS.AssignmentPattern;\n  validate(defs.left, node, \"left\", left, 1);\n  validate(defs.right, node, \"right\", right, 1);\n  return node;\n}\nfunction arrayPattern(elements) {\n  const node = {\n    type: \"ArrayPattern\",\n    elements\n  };\n  const defs = NODE_FIELDS.ArrayPattern;\n  validate(defs.elements, node, \"elements\", elements, 1);\n  return node;\n}\nfunction arrowFunctionExpression(params, body, async = false) {\n  const node = {\n    type: \"ArrowFunctionExpression\",\n    params,\n    body,\n    async,\n    expression: null\n  };\n  const defs = NODE_FIELDS.ArrowFunctionExpression;\n  validate(defs.params, node, \"params\", params, 1);\n  validate(defs.body, node, \"body\", body, 1);\n  validate(defs.async, node, \"async\", async);\n  return node;\n}\nfunction classBody(body) {\n  const node = {\n    type: \"ClassBody\",\n    body\n  };\n  const defs = NODE_FIELDS.ClassBody;\n  validate(defs.body, node, \"body\", body, 1);\n  return node;\n}\nfunction classExpression(id = null, superClass = null, body, decorators = null) {\n  const node = {\n    type: \"ClassExpression\",\n    id,\n    superClass,\n    body,\n    decorators\n  };\n  const defs = NODE_FIELDS.ClassExpression;\n  validate(defs.id, node, \"id\", id, 1);\n  validate(defs.superClass, node, \"superClass\", superClass, 1);\n  validate(defs.body, node, \"body\", body, 1);\n  validate(defs.decorators, node, \"decorators\", decorators, 1);\n  return node;\n}\nfunction classDeclaration(id = null, superClass = null, body, decorators = null) {\n  const node = {\n    type: \"ClassDeclaration\",\n    id,\n    superClass,\n    body,\n    decorators\n  };\n  const defs = NODE_FIELDS.ClassDeclaration;\n  validate(defs.id, node, \"id\", id, 1);\n  validate(defs.superClass, node, \"superClass\", superClass, 1);\n  validate(defs.body, node, \"body\", body, 1);\n  validate(defs.decorators, node, \"decorators\", decorators, 1);\n  return node;\n}\nfunction exportAllDeclaration(source) {\n  const node = {\n    type: \"ExportAllDeclaration\",\n    source\n  };\n  const defs = NODE_FIELDS.ExportAllDeclaration;\n  validate(defs.source, node, \"source\", source, 1);\n  return node;\n}\nfunction exportDefaultDeclaration(declaration) {\n  const node = {\n    type: \"ExportDefaultDeclaration\",\n    declaration\n  };\n  const defs = NODE_FIELDS.ExportDefaultDeclaration;\n  validate(defs.declaration, node, \"declaration\", declaration, 1);\n  return node;\n}\nfunction exportNamedDeclaration(declaration = null, specifiers = [], source = null) {\n  const node = {\n    type: \"ExportNamedDeclaration\",\n    declaration,\n    specifiers,\n    source\n  };\n  const defs = NODE_FIELDS.ExportNamedDeclaration;\n  validate(defs.declaration, node, \"declaration\", declaration, 1);\n  validate(defs.specifiers, node, \"specifiers\", specifiers, 1);\n  validate(defs.source, node, \"source\", source, 1);\n  return node;\n}\nfunction exportSpecifier(local, exported) {\n  const node = {\n    type: \"ExportSpecifier\",\n    local,\n    exported\n  };\n  const defs = NODE_FIELDS.ExportSpecifier;\n  validate(defs.local, node, \"local\", local, 1);\n  validate(defs.exported, node, \"exported\", exported, 1);\n  return node;\n}\nfunction forOfStatement(left, right, body, _await = false) {\n  const node = {\n    type: \"ForOfStatement\",\n    left,\n    right,\n    body,\n    await: _await\n  };\n  const defs = NODE_FIELDS.ForOfStatement;\n  validate(defs.left, node, \"left\", left, 1);\n  validate(defs.right, node, \"right\", right, 1);\n  validate(defs.body, node, \"body\", body, 1);\n  validate(defs.await, node, \"await\", _await);\n  return node;\n}\nfunction importDeclaration(specifiers, source) {\n  const node = {\n    type: \"ImportDeclaration\",\n    specifiers,\n    source\n  };\n  const defs = NODE_FIELDS.ImportDeclaration;\n  validate(defs.specifiers, node, \"specifiers\", specifiers, 1);\n  validate(defs.source, node, \"source\", source, 1);\n  return node;\n}\nfunction importDefaultSpecifier(local) {\n  const node = {\n    type: \"ImportDefaultSpecifier\",\n    local\n  };\n  const defs = NODE_FIELDS.ImportDefaultSpecifier;\n  validate(defs.local, node, \"local\", local, 1);\n  return node;\n}\nfunction importNamespaceSpecifier(local) {\n  const node = {\n    type: \"ImportNamespaceSpecifier\",\n    local\n  };\n  const defs = NODE_FIELDS.ImportNamespaceSpecifier;\n  validate(defs.local, node, \"local\", local, 1);\n  return node;\n}\nfunction importSpecifier(local, imported) {\n  const node = {\n    type: \"ImportSpecifier\",\n    local,\n    imported\n  };\n  const defs = NODE_FIELDS.ImportSpecifier;\n  validate(defs.local, node, \"local\", local, 1);\n  validate(defs.imported, node, \"imported\", imported, 1);\n  return node;\n}\nfunction importExpression(source, options = null) {\n  const node = {\n    type: \"ImportExpression\",\n    source,\n    options\n  };\n  const defs = NODE_FIELDS.ImportExpression;\n  validate(defs.source, node, \"source\", source, 1);\n  validate(defs.options, node, \"options\", options, 1);\n  return node;\n}\nfunction metaProperty(meta, property) {\n  const node = {\n    type: \"MetaProperty\",\n    meta,\n    property\n  };\n  const defs = NODE_FIELDS.MetaProperty;\n  validate(defs.meta, node, \"meta\", meta, 1);\n  validate(defs.property, node, \"property\", property, 1);\n  return node;\n}\nfunction classMethod(kind = \"method\", key, params, body, computed = false, _static = false, generator = false, async = false) {\n  const node = {\n    type: \"ClassMethod\",\n    kind,\n    key,\n    params,\n    body,\n    computed,\n    static: _static,\n    generator,\n    async\n  };\n  const defs = NODE_FIELDS.ClassMethod;\n  validate(defs.kind, node, \"kind\", kind);\n  validate(defs.key, node, \"key\", key, 1);\n  validate(defs.params, node, \"params\", params, 1);\n  validate(defs.body, node, \"body\", body, 1);\n  validate(defs.computed, node, \"computed\", computed);\n  validate(defs.static, node, \"static\", _static);\n  validate(defs.generator, node, \"generator\", generator);\n  validate(defs.async, node, \"async\", async);\n  return node;\n}\nfunction objectPattern(properties) {\n  const node = {\n    type: \"ObjectPattern\",\n    properties\n  };\n  const defs = NODE_FIELDS.ObjectPattern;\n  validate(defs.properties, node, \"properties\", properties, 1);\n  return node;\n}\nfunction spreadElement(argument) {\n  const node = {\n    type: \"SpreadElement\",\n    argument\n  };\n  const defs = NODE_FIELDS.SpreadElement;\n  validate(defs.argument, node, \"argument\", argument, 1);\n  return node;\n}\nfunction _super() {\n  return {\n    type: \"Super\"\n  };\n}\nfunction taggedTemplateExpression(tag, quasi) {\n  const node = {\n    type: \"TaggedTemplateExpression\",\n    tag,\n    quasi\n  };\n  const defs = NODE_FIELDS.TaggedTemplateExpression;\n  validate(defs.tag, node, \"tag\", tag, 1);\n  validate(defs.quasi, node, \"quasi\", quasi, 1);\n  return node;\n}\nfunction templateElement(value, tail = false) {\n  const node = {\n    type: \"TemplateElement\",\n    value,\n    tail\n  };\n  const defs = NODE_FIELDS.TemplateElement;\n  validate(defs.value, node, \"value\", value);\n  validate(defs.tail, node, \"tail\", tail);\n  return node;\n}\nfunction templateLiteral(quasis, expressions) {\n  const node = {\n    type: \"TemplateLiteral\",\n    quasis,\n    expressions\n  };\n  const defs = NODE_FIELDS.TemplateLiteral;\n  validate(defs.quasis, node, \"quasis\", quasis, 1);\n  validate(defs.expressions, node, \"expressions\", expressions, 1);\n  return node;\n}\nfunction yieldExpression(argument = null, delegate = false) {\n  const node = {\n    type: \"YieldExpression\",\n    argument,\n    delegate\n  };\n  const defs = NODE_FIELDS.YieldExpression;\n  validate(defs.argument, node, \"argument\", argument, 1);\n  validate(defs.delegate, node, \"delegate\", delegate);\n  return node;\n}\nfunction awaitExpression(argument) {\n  const node = {\n    type: \"AwaitExpression\",\n    argument\n  };\n  const defs = NODE_FIELDS.AwaitExpression;\n  validate(defs.argument, node, \"argument\", argument, 1);\n  return node;\n}\nfunction _import() {\n  return {\n    type: \"Import\"\n  };\n}\nfunction exportNamespaceSpecifier(exported) {\n  const node = {\n    type: \"ExportNamespaceSpecifier\",\n    exported\n  };\n  const defs = NODE_FIELDS.ExportNamespaceSpecifier;\n  validate(defs.exported, node, \"exported\", exported, 1);\n  return node;\n}\nfunction optionalMemberExpression(object, property, computed = false, optional) {\n  const node = {\n    type: \"OptionalMemberExpression\",\n    object,\n    property,\n    computed,\n    optional\n  };\n  const defs = NODE_FIELDS.OptionalMemberExpression;\n  validate(defs.object, node, \"object\", object, 1);\n  validate(defs.property, node, \"property\", property, 1);\n  validate(defs.computed, node, \"computed\", computed);\n  validate(defs.optional, node, \"optional\", optional);\n  return node;\n}\nfunction optionalCallExpression(callee, _arguments, optional) {\n  const node = {\n    type: \"OptionalCallExpression\",\n    callee,\n    arguments: _arguments,\n    optional\n  };\n  const defs = NODE_FIELDS.OptionalCallExpression;\n  validate(defs.callee, node, \"callee\", callee, 1);\n  validate(defs.arguments, node, \"arguments\", _arguments, 1);\n  validate(defs.optional, node, \"optional\", optional);\n  return node;\n}\nfunction classProperty(key, value = null, typeAnnotation = null, decorators = null, computed = false, _static = false) {\n  const node = {\n    type: \"ClassProperty\",\n    key,\n    value,\n    typeAnnotation,\n    decorators,\n    computed,\n    static: _static\n  };\n  const defs = NODE_FIELDS.ClassProperty;\n  validate(defs.key, node, \"key\", key, 1);\n  validate(defs.value, node, \"value\", value, 1);\n  validate(defs.typeAnnotation, node, \"typeAnnotation\", typeAnnotation, 1);\n  validate(defs.decorators, node, \"decorators\", decorators, 1);\n  validate(defs.computed, node, \"computed\", computed);\n  validate(defs.static, node, \"static\", _static);\n  return node;\n}\nfunction classAccessorProperty(key, value = null, typeAnnotation = null, decorators = null, computed = false, _static = false) {\n  const node = {\n    type: \"ClassAccessorProperty\",\n    key,\n    value,\n    typeAnnotation,\n    decorators,\n    computed,\n    static: _static\n  };\n  const defs = NODE_FIELDS.ClassAccessorProperty;\n  validate(defs.key, node, \"key\", key, 1);\n  validate(defs.value, node, \"value\", value, 1);\n  validate(defs.typeAnnotation, node, \"typeAnnotation\", typeAnnotation, 1);\n  validate(defs.decorators, node, \"decorators\", decorators, 1);\n  validate(defs.computed, node, \"computed\", computed);\n  validate(defs.static, node, \"static\", _static);\n  return node;\n}\nfunction classPrivateProperty(key, value = null, decorators = null, _static = false) {\n  const node = {\n    type: \"ClassPrivateProperty\",\n    key,\n    value,\n    decorators,\n    static: _static\n  };\n  const defs = NODE_FIELDS.ClassPrivateProperty;\n  validate(defs.key, node, \"key\", key, 1);\n  validate(defs.value, node, \"value\", value, 1);\n  validate(defs.decorators, node, \"decorators\", decorators, 1);\n  validate(defs.static, node, \"static\", _static);\n  return node;\n}\nfunction classPrivateMethod(kind = \"method\", key, params, body, _static = false) {\n  const node = {\n    type: \"ClassPrivateMethod\",\n    kind,\n    key,\n    params,\n    body,\n    static: _static\n  };\n  const defs = NODE_FIELDS.ClassPrivateMethod;\n  validate(defs.kind, node, \"kind\", kind);\n  validate(defs.key, node, \"key\", key, 1);\n  validate(defs.params, node, \"params\", params, 1);\n  validate(defs.body, node, \"body\", body, 1);\n  validate(defs.static, node, \"static\", _static);\n  return node;\n}\nfunction privateName(id) {\n  const node = {\n    type: \"PrivateName\",\n    id\n  };\n  const defs = NODE_FIELDS.PrivateName;\n  validate(defs.id, node, \"id\", id, 1);\n  return node;\n}\nfunction staticBlock(body) {\n  const node = {\n    type: \"StaticBlock\",\n    body\n  };\n  const defs = NODE_FIELDS.StaticBlock;\n  validate(defs.body, node, \"body\", body, 1);\n  return node;\n}\nfunction importAttribute(key, value) {\n  const node = {\n    type: \"ImportAttribute\",\n    key,\n    value\n  };\n  const defs = NODE_FIELDS.ImportAttribute;\n  validate(defs.key, node, \"key\", key, 1);\n  validate(defs.value, node, \"value\", value, 1);\n  return node;\n}\nfunction anyTypeAnnotation() {\n  return {\n    type: \"AnyTypeAnnotation\"\n  };\n}\nfunction arrayTypeAnnotation(elementType) {\n  const node = {\n    type: \"ArrayTypeAnnotation\",\n    elementType\n  };\n  const defs = NODE_FIELDS.ArrayTypeAnnotation;\n  validate(defs.elementType, node, \"elementType\", elementType, 1);\n  return node;\n}\nfunction booleanTypeAnnotation() {\n  return {\n    type: \"BooleanTypeAnnotation\"\n  };\n}\nfunction booleanLiteralTypeAnnotation(value) {\n  const node = {\n    type: \"BooleanLiteralTypeAnnotation\",\n    value\n  };\n  const defs = NODE_FIELDS.BooleanLiteralTypeAnnotation;\n  validate(defs.value, node, \"value\", value);\n  return node;\n}\nfunction nullLiteralTypeAnnotation() {\n  return {\n    type: \"NullLiteralTypeAnnotation\"\n  };\n}\nfunction classImplements(id, typeParameters = null) {\n  const node = {\n    type: \"ClassImplements\",\n    id,\n    typeParameters\n  };\n  const defs = NODE_FIELDS.ClassImplements;\n  validate(defs.id, node, \"id\", id, 1);\n  validate(defs.typeParameters, node, \"typeParameters\", typeParameters, 1);\n  return node;\n}\nfunction declareClass(id, typeParameters = null, _extends = null, body) {\n  const node = {\n    type: \"DeclareClass\",\n    id,\n    typeParameters,\n    extends: _extends,\n    body\n  };\n  const defs = NODE_FIELDS.DeclareClass;\n  validate(defs.id, node, \"id\", id, 1);\n  validate(defs.typeParameters, node, \"typeParameters\", typeParameters, 1);\n  validate(defs.extends, node, \"extends\", _extends, 1);\n  validate(defs.body, node, \"body\", body, 1);\n  return node;\n}\nfunction declareFunction(id) {\n  const node = {\n    type: \"DeclareFunction\",\n    id\n  };\n  const defs = NODE_FIELDS.DeclareFunction;\n  validate(defs.id, node, \"id\", id, 1);\n  return node;\n}\nfunction declareInterface(id, typeParameters = null, _extends = null, body) {\n  const node = {\n    type: \"DeclareInterface\",\n    id,\n    typeParameters,\n    extends: _extends,\n    body\n  };\n  const defs = NODE_FIELDS.DeclareInterface;\n  validate(defs.id, node, \"id\", id, 1);\n  validate(defs.typeParameters, node, \"typeParameters\", typeParameters, 1);\n  validate(defs.extends, node, \"extends\", _extends, 1);\n  validate(defs.body, node, \"body\", body, 1);\n  return node;\n}\nfunction declareModule(id, body, kind = null) {\n  const node = {\n    type: \"DeclareModule\",\n    id,\n    body,\n    kind\n  };\n  const defs = NODE_FIELDS.DeclareModule;\n  validate(defs.id, node, \"id\", id, 1);\n  validate(defs.body, node, \"body\", body, 1);\n  validate(defs.kind, node, \"kind\", kind);\n  return node;\n}\nfunction declareModuleExports(typeAnnotation) {\n  const node = {\n    type: \"DeclareModuleExports\",\n    typeAnnotation\n  };\n  const defs = NODE_FIELDS.DeclareModuleExports;\n  validate(defs.typeAnnotation, node, \"typeAnnotation\", typeAnnotation, 1);\n  return node;\n}\nfunction declareTypeAlias(id, typeParameters = null, right) {\n  const node = {\n    type: \"DeclareTypeAlias\",\n    id,\n    typeParameters,\n    right\n  };\n  const defs = NODE_FIELDS.DeclareTypeAlias;\n  validate(defs.id, node, \"id\", id, 1);\n  validate(defs.typeParameters, node, \"typeParameters\", typeParameters, 1);\n  validate(defs.right, node, \"right\", right, 1);\n  return node;\n}\nfunction declareOpaqueType(id, typeParameters = null, supertype = null) {\n  const node = {\n    type: \"DeclareOpaqueType\",\n    id,\n    typeParameters,\n    supertype\n  };\n  const defs = NODE_FIELDS.DeclareOpaqueType;\n  validate(defs.id, node, \"id\", id, 1);\n  validate(defs.typeParameters, node, \"typeParameters\", typeParameters, 1);\n  validate(defs.supertype, node, \"supertype\", supertype, 1);\n  return node;\n}\nfunction declareVariable(id) {\n  const node = {\n    type: \"DeclareVariable\",\n    id\n  };\n  const defs = NODE_FIELDS.DeclareVariable;\n  validate(defs.id, node, \"id\", id, 1);\n  return node;\n}\nfunction declareExportDeclaration(declaration = null, specifiers = null, source = null, attributes = null) {\n  const node = {\n    type: \"DeclareExportDeclaration\",\n    declaration,\n    specifiers,\n    source,\n    attributes\n  };\n  const defs = NODE_FIELDS.DeclareExportDeclaration;\n  validate(defs.declaration, node, \"declaration\", declaration, 1);\n  validate(defs.specifiers, node, \"specifiers\", specifiers, 1);\n  validate(defs.source, node, \"source\", source, 1);\n  validate(defs.attributes, node, \"attributes\", attributes, 1);\n  return node;\n}\nfunction declareExportAllDeclaration(source, attributes = null) {\n  const node = {\n    type: \"DeclareExportAllDeclaration\",\n    source,\n    attributes\n  };\n  const defs = NODE_FIELDS.DeclareExportAllDeclaration;\n  validate(defs.source, node, \"source\", source, 1);\n  validate(defs.attributes, node, \"attributes\", attributes, 1);\n  return node;\n}\nfunction declaredPredicate(value) {\n  const node = {\n    type: \"DeclaredPredicate\",\n    value\n  };\n  const defs = NODE_FIELDS.DeclaredPredicate;\n  validate(defs.value, node, \"value\", value, 1);\n  return node;\n}\nfunction existsTypeAnnotation() {\n  return {\n    type: \"ExistsTypeAnnotation\"\n  };\n}\nfunction functionTypeAnnotation(typeParameters = null, params, rest = null, returnType) {\n  const node = {\n    type: \"FunctionTypeAnnotation\",\n    typeParameters,\n    params,\n    rest,\n    returnType\n  };\n  const defs = NODE_FIELDS.FunctionTypeAnnotation;\n  validate(defs.typeParameters, node, \"typeParameters\", typeParameters, 1);\n  validate(defs.params, node, \"params\", params, 1);\n  validate(defs.rest, node, \"rest\", rest, 1);\n  validate(defs.returnType, node, \"returnType\", returnType, 1);\n  return node;\n}\nfunction functionTypeParam(name = null, typeAnnotation) {\n  const node = {\n    type: \"FunctionTypeParam\",\n    name,\n    typeAnnotation\n  };\n  const defs = NODE_FIELDS.FunctionTypeParam;\n  validate(defs.name, node, \"name\", name, 1);\n  validate(defs.typeAnnotation, node, \"typeAnnotation\", typeAnnotation, 1);\n  return node;\n}\nfunction genericTypeAnnotation(id, typeParameters = null) {\n  const node = {\n    type: \"GenericTypeAnnotation\",\n    id,\n    typeParameters\n  };\n  const defs = NODE_FIELDS.GenericTypeAnnotation;\n  validate(defs.id, node, \"id\", id, 1);\n  validate(defs.typeParameters, node, \"typeParameters\", typeParameters, 1);\n  return node;\n}\nfunction inferredPredicate() {\n  return {\n    type: \"InferredPredicate\"\n  };\n}\nfunction interfaceExtends(id, typeParameters = null) {\n  const node = {\n    type: \"InterfaceExtends\",\n    id,\n    typeParameters\n  };\n  const defs = NODE_FIELDS.InterfaceExtends;\n  validate(defs.id, node, \"id\", id, 1);\n  validate(defs.typeParameters, node, \"typeParameters\", typeParameters, 1);\n  return node;\n}\nfunction interfaceDeclaration(id, typeParameters = null, _extends = null, body) {\n  const node = {\n    type: \"InterfaceDeclaration\",\n    id,\n    typeParameters,\n    extends: _extends,\n    body\n  };\n  const defs = NODE_FIELDS.InterfaceDeclaration;\n  validate(defs.id, node, \"id\", id, 1);\n  validate(defs.typeParameters, node, \"typeParameters\", typeParameters, 1);\n  validate(defs.extends, node, \"extends\", _extends, 1);\n  validate(defs.body, node, \"body\", body, 1);\n  return node;\n}\nfunction interfaceTypeAnnotation(_extends = null, body) {\n  const node = {\n    type: \"InterfaceTypeAnnotation\",\n    extends: _extends,\n    body\n  };\n  const defs = NODE_FIELDS.InterfaceTypeAnnotation;\n  validate(defs.extends, node, \"extends\", _extends, 1);\n  validate(defs.body, node, \"body\", body, 1);\n  return node;\n}\nfunction intersectionTypeAnnotation(types) {\n  const node = {\n    type: \"IntersectionTypeAnnotation\",\n    types\n  };\n  const defs = NODE_FIELDS.IntersectionTypeAnnotation;\n  validate(defs.types, node, \"types\", types, 1);\n  return node;\n}\nfunction mixedTypeAnnotation() {\n  return {\n    type: \"MixedTypeAnnotation\"\n  };\n}\nfunction emptyTypeAnnotation() {\n  return {\n    type: \"EmptyTypeAnnotation\"\n  };\n}\nfunction nullableTypeAnnotation(typeAnnotation) {\n  const node = {\n    type: \"NullableTypeAnnotation\",\n    typeAnnotation\n  };\n  const defs = NODE_FIELDS.NullableTypeAnnotation;\n  validate(defs.typeAnnotation, node, \"typeAnnotation\", typeAnnotation, 1);\n  return node;\n}\nfunction numberLiteralTypeAnnotation(value) {\n  const node = {\n    type: \"NumberLiteralTypeAnnotation\",\n    value\n  };\n  const defs = NODE_FIELDS.NumberLiteralTypeAnnotation;\n  validate(defs.value, node, \"value\", value);\n  return node;\n}\nfunction numberTypeAnnotation() {\n  return {\n    type: \"NumberTypeAnnotation\"\n  };\n}\nfunction objectTypeAnnotation(properties, indexers = [], callProperties = [], internalSlots = [], exact = false) {\n  const node = {\n    type: \"ObjectTypeAnnotation\",\n    properties,\n    indexers,\n    callProperties,\n    internalSlots,\n    exact\n  };\n  const defs = NODE_FIELDS.ObjectTypeAnnotation;\n  validate(defs.properties, node, \"properties\", properties, 1);\n  validate(defs.indexers, node, \"indexers\", indexers, 1);\n  validate(defs.callProperties, node, \"callProperties\", callProperties, 1);\n  validate(defs.internalSlots, node, \"internalSlots\", internalSlots, 1);\n  validate(defs.exact, node, \"exact\", exact);\n  return node;\n}\nfunction objectTypeInternalSlot(id, value, optional, _static, method) {\n  const node = {\n    type: \"ObjectTypeInternalSlot\",\n    id,\n    value,\n    optional,\n    static: _static,\n    method\n  };\n  const defs = NODE_FIELDS.ObjectTypeInternalSlot;\n  validate(defs.id, node, \"id\", id, 1);\n  validate(defs.value, node, \"value\", value, 1);\n  validate(defs.optional, node, \"optional\", optional);\n  validate(defs.static, node, \"static\", _static);\n  validate(defs.method, node, \"method\", method);\n  return node;\n}\nfunction objectTypeCallProperty(value) {\n  const node = {\n    type: \"ObjectTypeCallProperty\",\n    value,\n    static: null\n  };\n  const defs = NODE_FIELDS.ObjectTypeCallProperty;\n  validate(defs.value, node, \"value\", value, 1);\n  return node;\n}\nfunction objectTypeIndexer(id = null, key, value, variance = null) {\n  const node = {\n    type: \"ObjectTypeIndexer\",\n    id,\n    key,\n    value,\n    variance,\n    static: null\n  };\n  const defs = NODE_FIELDS.ObjectTypeIndexer;\n  validate(defs.id, node, \"id\", id, 1);\n  validate(defs.key, node, \"key\", key, 1);\n  validate(defs.value, node, \"value\", value, 1);\n  validate(defs.variance, node, \"variance\", variance, 1);\n  return node;\n}\nfunction objectTypeProperty(key, value, variance = null) {\n  const node = {\n    type: \"ObjectTypeProperty\",\n    key,\n    value,\n    variance,\n    kind: null,\n    method: null,\n    optional: null,\n    proto: null,\n    static: null\n  };\n  const defs = NODE_FIELDS.ObjectTypeProperty;\n  validate(defs.key, node, \"key\", key, 1);\n  validate(defs.value, node, \"value\", value, 1);\n  validate(defs.variance, node, \"variance\", variance, 1);\n  return node;\n}\nfunction objectTypeSpreadProperty(argument) {\n  const node = {\n    type: \"ObjectTypeSpreadProperty\",\n    argument\n  };\n  const defs = NODE_FIELDS.ObjectTypeSpreadProperty;\n  validate(defs.argument, node, \"argument\", argument, 1);\n  return node;\n}\nfunction opaqueType(id, typeParameters = null, supertype = null, impltype) {\n  const node = {\n    type: \"OpaqueType\",\n    id,\n    typeParameters,\n    supertype,\n    impltype\n  };\n  const defs = NODE_FIELDS.OpaqueType;\n  validate(defs.id, node, \"id\", id, 1);\n  validate(defs.typeParameters, node, \"typeParameters\", typeParameters, 1);\n  validate(defs.supertype, node, \"supertype\", supertype, 1);\n  validate(defs.impltype, node, \"impltype\", impltype, 1);\n  return node;\n}\nfunction qualifiedTypeIdentifier(id, qualification) {\n  const node = {\n    type: \"QualifiedTypeIdentifier\",\n    id,\n    qualification\n  };\n  const defs = NODE_FIELDS.QualifiedTypeIdentifier;\n  validate(defs.id, node, \"id\", id, 1);\n  validate(defs.qualification, node, \"qualification\", qualification, 1);\n  return node;\n}\nfunction stringLiteralTypeAnnotation(value) {\n  const node = {\n    type: \"StringLiteralTypeAnnotation\",\n    value\n  };\n  const defs = NODE_FIELDS.StringLiteralTypeAnnotation;\n  validate(defs.value, node, \"value\", value);\n  return node;\n}\nfunction stringTypeAnnotation() {\n  return {\n    type: \"StringTypeAnnotation\"\n  };\n}\nfunction symbolTypeAnnotation() {\n  return {\n    type: \"SymbolTypeAnnotation\"\n  };\n}\nfunction thisTypeAnnotation() {\n  return {\n    type: \"ThisTypeAnnotation\"\n  };\n}\nfunction tupleTypeAnnotation(types) {\n  const node = {\n    type: \"TupleTypeAnnotation\",\n    types\n  };\n  const defs = NODE_FIELDS.TupleTypeAnnotation;\n  validate(defs.types, node, \"types\", types, 1);\n  return node;\n}\nfunction typeofTypeAnnotation(argument) {\n  const node = {\n    type: \"TypeofTypeAnnotation\",\n    argument\n  };\n  const defs = NODE_FIELDS.TypeofTypeAnnotation;\n  validate(defs.argument, node, \"argument\", argument, 1);\n  return node;\n}\nfunction typeAlias(id, typeParameters = null, right) {\n  const node = {\n    type: \"TypeAlias\",\n    id,\n    typeParameters,\n    right\n  };\n  const defs = NODE_FIELDS.TypeAlias;\n  validate(defs.id, node, \"id\", id, 1);\n  validate(defs.typeParameters, node, \"typeParameters\", typeParameters, 1);\n  validate(defs.right, node, \"right\", right, 1);\n  return node;\n}\nfunction typeAnnotation(typeAnnotation) {\n  const node = {\n    type: \"TypeAnnotation\",\n    typeAnnotation\n  };\n  const defs = NODE_FIELDS.TypeAnnotation;\n  validate(defs.typeAnnotation, node, \"typeAnnotation\", typeAnnotation, 1);\n  return node;\n}\nfunction typeCastExpression(expression, typeAnnotation) {\n  const node = {\n    type: \"TypeCastExpression\",\n    expression,\n    typeAnnotation\n  };\n  const defs = NODE_FIELDS.TypeCastExpression;\n  validate(defs.expression, node, \"expression\", expression, 1);\n  validate(defs.typeAnnotation, node, \"typeAnnotation\", typeAnnotation, 1);\n  return node;\n}\nfunction typeParameter(bound = null, _default = null, variance = null) {\n  const node = {\n    type: \"TypeParameter\",\n    bound,\n    default: _default,\n    variance,\n    name: null\n  };\n  const defs = NODE_FIELDS.TypeParameter;\n  validate(defs.bound, node, \"bound\", bound, 1);\n  validate(defs.default, node, \"default\", _default, 1);\n  validate(defs.variance, node, \"variance\", variance, 1);\n  return node;\n}\nfunction typeParameterDeclaration(params) {\n  const node = {\n    type: \"TypeParameterDeclaration\",\n    params\n  };\n  const defs = NODE_FIELDS.TypeParameterDeclaration;\n  validate(defs.params, node, \"params\", params, 1);\n  return node;\n}\nfunction typeParameterInstantiation(params) {\n  const node = {\n    type: \"TypeParameterInstantiation\",\n    params\n  };\n  const defs = NODE_FIELDS.TypeParameterInstantiation;\n  validate(defs.params, node, \"params\", params, 1);\n  return node;\n}\nfunction unionTypeAnnotation(types) {\n  const node = {\n    type: \"UnionTypeAnnotation\",\n    types\n  };\n  const defs = NODE_FIELDS.UnionTypeAnnotation;\n  validate(defs.types, node, \"types\", types, 1);\n  return node;\n}\nfunction variance(kind) {\n  const node = {\n    type: \"Variance\",\n    kind\n  };\n  const defs = NODE_FIELDS.Variance;\n  validate(defs.kind, node, \"kind\", kind);\n  return node;\n}\nfunction voidTypeAnnotation() {\n  return {\n    type: \"VoidTypeAnnotation\"\n  };\n}\nfunction enumDeclaration(id, body) {\n  const node = {\n    type: \"EnumDeclaration\",\n    id,\n    body\n  };\n  const defs = NODE_FIELDS.EnumDeclaration;\n  validate(defs.id, node, \"id\", id, 1);\n  validate(defs.body, node, \"body\", body, 1);\n  return node;\n}\nfunction enumBooleanBody(members) {\n  const node = {\n    type: \"EnumBooleanBody\",\n    members,\n    explicitType: null,\n    hasUnknownMembers: null\n  };\n  const defs = NODE_FIELDS.EnumBooleanBody;\n  validate(defs.members, node, \"members\", members, 1);\n  return node;\n}\nfunction enumNumberBody(members) {\n  const node = {\n    type: \"EnumNumberBody\",\n    members,\n    explicitType: null,\n    hasUnknownMembers: null\n  };\n  const defs = NODE_FIELDS.EnumNumberBody;\n  validate(defs.members, node, \"members\", members, 1);\n  return node;\n}\nfunction enumStringBody(members) {\n  const node = {\n    type: \"EnumStringBody\",\n    members,\n    explicitType: null,\n    hasUnknownMembers: null\n  };\n  const defs = NODE_FIELDS.EnumStringBody;\n  validate(defs.members, node, \"members\", members, 1);\n  return node;\n}\nfunction enumSymbolBody(members) {\n  const node = {\n    type: \"EnumSymbolBody\",\n    members,\n    hasUnknownMembers: null\n  };\n  const defs = NODE_FIELDS.EnumSymbolBody;\n  validate(defs.members, node, \"members\", members, 1);\n  return node;\n}\nfunction enumBooleanMember(id) {\n  const node = {\n    type: \"EnumBooleanMember\",\n    id,\n    init: null\n  };\n  const defs = NODE_FIELDS.EnumBooleanMember;\n  validate(defs.id, node, \"id\", id, 1);\n  return node;\n}\nfunction enumNumberMember(id, init) {\n  const node = {\n    type: \"EnumNumberMember\",\n    id,\n    init\n  };\n  const defs = NODE_FIELDS.EnumNumberMember;\n  validate(defs.id, node, \"id\", id, 1);\n  validate(defs.init, node, \"init\", init, 1);\n  return node;\n}\nfunction enumStringMember(id, init) {\n  const node = {\n    type: \"EnumStringMember\",\n    id,\n    init\n  };\n  const defs = NODE_FIELDS.EnumStringMember;\n  validate(defs.id, node, \"id\", id, 1);\n  validate(defs.init, node, \"init\", init, 1);\n  return node;\n}\nfunction enumDefaultedMember(id) {\n  const node = {\n    type: \"EnumDefaultedMember\",\n    id\n  };\n  const defs = NODE_FIELDS.EnumDefaultedMember;\n  validate(defs.id, node, \"id\", id, 1);\n  return node;\n}\nfunction indexedAccessType(objectType, indexType) {\n  const node = {\n    type: \"IndexedAccessType\",\n    objectType,\n    indexType\n  };\n  const defs = NODE_FIELDS.IndexedAccessType;\n  validate(defs.objectType, node, \"objectType\", objectType, 1);\n  validate(defs.indexType, node, \"indexType\", indexType, 1);\n  return node;\n}\nfunction optionalIndexedAccessType(objectType, indexType) {\n  const node = {\n    type: \"OptionalIndexedAccessType\",\n    objectType,\n    indexType,\n    optional: null\n  };\n  const defs = NODE_FIELDS.OptionalIndexedAccessType;\n  validate(defs.objectType, node, \"objectType\", objectType, 1);\n  validate(defs.indexType, node, \"indexType\", indexType, 1);\n  return node;\n}\nfunction jsxAttribute(name, value = null) {\n  const node = {\n    type: \"JSXAttribute\",\n    name,\n    value\n  };\n  const defs = NODE_FIELDS.JSXAttribute;\n  validate(defs.name, node, \"name\", name, 1);\n  validate(defs.value, node, \"value\", value, 1);\n  return node;\n}\nfunction jsxClosingElement(name) {\n  const node = {\n    type: \"JSXClosingElement\",\n    name\n  };\n  const defs = NODE_FIELDS.JSXClosingElement;\n  validate(defs.name, node, \"name\", name, 1);\n  return node;\n}\nfunction jsxElement(openingElement, closingElement = null, children, selfClosing = null) {\n  const node = {\n    type: \"JSXElement\",\n    openingElement,\n    closingElement,\n    children,\n    selfClosing\n  };\n  const defs = NODE_FIELDS.JSXElement;\n  validate(defs.openingElement, node, \"openingElement\", openingElement, 1);\n  validate(defs.closingElement, node, \"closingElement\", closingElement, 1);\n  validate(defs.children, node, \"children\", children, 1);\n  validate(defs.selfClosing, node, \"selfClosing\", selfClosing);\n  return node;\n}\nfunction jsxEmptyExpression() {\n  return {\n    type: \"JSXEmptyExpression\"\n  };\n}\nfunction jsxExpressionContainer(expression) {\n  const node = {\n    type: \"JSXExpressionContainer\",\n    expression\n  };\n  const defs = NODE_FIELDS.JSXExpressionContainer;\n  validate(defs.expression, node, \"expression\", expression, 1);\n  return node;\n}\nfunction jsxSpreadChild(expression) {\n  const node = {\n    type: \"JSXSpreadChild\",\n    expression\n  };\n  const defs = NODE_FIELDS.JSXSpreadChild;\n  validate(defs.expression, node, \"expression\", expression, 1);\n  return node;\n}\nfunction jsxIdentifier(name) {\n  const node = {\n    type: \"JSXIdentifier\",\n    name\n  };\n  const defs = NODE_FIELDS.JSXIdentifier;\n  validate(defs.name, node, \"name\", name);\n  return node;\n}\nfunction jsxMemberExpression(object, property) {\n  const node = {\n    type: \"JSXMemberExpression\",\n    object,\n    property\n  };\n  const defs = NODE_FIELDS.JSXMemberExpression;\n  validate(defs.object, node, \"object\", object, 1);\n  validate(defs.property, node, \"property\", property, 1);\n  return node;\n}\nfunction jsxNamespacedName(namespace, name) {\n  const node = {\n    type: \"JSXNamespacedName\",\n    namespace,\n    name\n  };\n  const defs = NODE_FIELDS.JSXNamespacedName;\n  validate(defs.namespace, node, \"namespace\", namespace, 1);\n  validate(defs.name, node, \"name\", name, 1);\n  return node;\n}\nfunction jsxOpeningElement(name, attributes, selfClosing = false) {\n  const node = {\n    type: \"JSXOpeningElement\",\n    name,\n    attributes,\n    selfClosing\n  };\n  const defs = NODE_FIELDS.JSXOpeningElement;\n  validate(defs.name, node, \"name\", name, 1);\n  validate(defs.attributes, node, \"attributes\", attributes, 1);\n  validate(defs.selfClosing, node, \"selfClosing\", selfClosing);\n  return node;\n}\nfunction jsxSpreadAttribute(argument) {\n  const node = {\n    type: \"JSXSpreadAttribute\",\n    argument\n  };\n  const defs = NODE_FIELDS.JSXSpreadAttribute;\n  validate(defs.argument, node, \"argument\", argument, 1);\n  return node;\n}\nfunction jsxText(value) {\n  const node = {\n    type: \"JSXText\",\n    value\n  };\n  const defs = NODE_FIELDS.JSXText;\n  validate(defs.value, node, \"value\", value);\n  return node;\n}\nfunction jsxFragment(openingFragment, closingFragment, children) {\n  const node = {\n    type: \"JSXFragment\",\n    openingFragment,\n    closingFragment,\n    children\n  };\n  const defs = NODE_FIELDS.JSXFragment;\n  validate(defs.openingFragment, node, \"openingFragment\", openingFragment, 1);\n  validate(defs.closingFragment, node, \"closingFragment\", closingFragment, 1);\n  validate(defs.children, node, \"children\", children, 1);\n  return node;\n}\nfunction jsxOpeningFragment() {\n  return {\n    type: \"JSXOpeningFragment\"\n  };\n}\nfunction jsxClosingFragment() {\n  return {\n    type: \"JSXClosingFragment\"\n  };\n}\nfunction noop() {\n  return {\n    type: \"Noop\"\n  };\n}\nfunction placeholder(expectedNode, name) {\n  const node = {\n    type: \"Placeholder\",\n    expectedNode,\n    name\n  };\n  const defs = NODE_FIELDS.Placeholder;\n  validate(defs.expectedNode, node, \"expectedNode\", expectedNode);\n  validate(defs.name, node, \"name\", name, 1);\n  return node;\n}\nfunction v8IntrinsicIdentifier(name) {\n  const node = {\n    type: \"V8IntrinsicIdentifier\",\n    name\n  };\n  const defs = NODE_FIELDS.V8IntrinsicIdentifier;\n  validate(defs.name, node, \"name\", name);\n  return node;\n}\nfunction argumentPlaceholder() {\n  return {\n    type: \"ArgumentPlaceholder\"\n  };\n}\nfunction bindExpression(object, callee) {\n  const node = {\n    type: \"BindExpression\",\n    object,\n    callee\n  };\n  const defs = NODE_FIELDS.BindExpression;\n  validate(defs.object, node, \"object\", object, 1);\n  validate(defs.callee, node, \"callee\", callee, 1);\n  return node;\n}\nfunction decorator(expression) {\n  const node = {\n    type: \"Decorator\",\n    expression\n  };\n  const defs = NODE_FIELDS.Decorator;\n  validate(defs.expression, node, \"expression\", expression, 1);\n  return node;\n}\nfunction doExpression(body, async = false) {\n  const node = {\n    type: \"DoExpression\",\n    body,\n    async\n  };\n  const defs = NODE_FIELDS.DoExpression;\n  validate(defs.body, node, \"body\", body, 1);\n  validate(defs.async, node, \"async\", async);\n  return node;\n}\nfunction exportDefaultSpecifier(exported) {\n  const node = {\n    type: \"ExportDefaultSpecifier\",\n    exported\n  };\n  const defs = NODE_FIELDS.ExportDefaultSpecifier;\n  validate(defs.exported, node, \"exported\", exported, 1);\n  return node;\n}\nfunction recordExpression(properties) {\n  const node = {\n    type: \"RecordExpression\",\n    properties\n  };\n  const defs = NODE_FIELDS.RecordExpression;\n  validate(defs.properties, node, \"properties\", properties, 1);\n  return node;\n}\nfunction tupleExpression(elements = []) {\n  const node = {\n    type: \"TupleExpression\",\n    elements\n  };\n  const defs = NODE_FIELDS.TupleExpression;\n  validate(defs.elements, node, \"elements\", elements, 1);\n  return node;\n}\nfunction decimalLiteral(value) {\n  const node = {\n    type: \"DecimalLiteral\",\n    value\n  };\n  const defs = NODE_FIELDS.DecimalLiteral;\n  validate(defs.value, node, \"value\", value);\n  return node;\n}\nfunction moduleExpression(body) {\n  const node = {\n    type: \"ModuleExpression\",\n    body\n  };\n  const defs = NODE_FIELDS.ModuleExpression;\n  validate(defs.body, node, \"body\", body, 1);\n  return node;\n}\nfunction topicReference() {\n  return {\n    type: \"TopicReference\"\n  };\n}\nfunction pipelineTopicExpression(expression) {\n  const node = {\n    type: \"PipelineTopicExpression\",\n    expression\n  };\n  const defs = NODE_FIELDS.PipelineTopicExpression;\n  validate(defs.expression, node, \"expression\", expression, 1);\n  return node;\n}\nfunction pipelineBareFunction(callee) {\n  const node = {\n    type: \"PipelineBareFunction\",\n    callee\n  };\n  const defs = NODE_FIELDS.PipelineBareFunction;\n  validate(defs.callee, node, \"callee\", callee, 1);\n  return node;\n}\nfunction pipelinePrimaryTopicReference() {\n  return {\n    type: \"PipelinePrimaryTopicReference\"\n  };\n}\nfunction voidPattern() {\n  return {\n    type: \"VoidPattern\"\n  };\n}\nfunction tsParameterProperty(parameter) {\n  const node = {\n    type: \"TSParameterProperty\",\n    parameter\n  };\n  const defs = NODE_FIELDS.TSParameterProperty;\n  validate(defs.parameter, node, \"parameter\", parameter, 1);\n  return node;\n}\nfunction tsDeclareFunction(id = null, typeParameters = null, params, returnType = null) {\n  const node = {\n    type: \"TSDeclareFunction\",\n    id,\n    typeParameters,\n    params,\n    returnType\n  };\n  const defs = NODE_FIELDS.TSDeclareFunction;\n  validate(defs.id, node, \"id\", id, 1);\n  validate(defs.typeParameters, node, \"typeParameters\", typeParameters, 1);\n  validate(defs.params, node, \"params\", params, 1);\n  validate(defs.returnType, node, \"returnType\", returnType, 1);\n  return node;\n}\nfunction tsDeclareMethod(decorators = null, key, typeParameters = null, params, returnType = null) {\n  const node = {\n    type: \"TSDeclareMethod\",\n    decorators,\n    key,\n    typeParameters,\n    params,\n    returnType\n  };\n  const defs = NODE_FIELDS.TSDeclareMethod;\n  validate(defs.decorators, node, \"decorators\", decorators, 1);\n  validate(defs.key, node, \"key\", key, 1);\n  validate(defs.typeParameters, node, \"typeParameters\", typeParameters, 1);\n  validate(defs.params, node, \"params\", params, 1);\n  validate(defs.returnType, node, \"returnType\", returnType, 1);\n  return node;\n}\nfunction tsQualifiedName(left, right) {\n  const node = {\n    type: \"TSQualifiedName\",\n    left,\n    right\n  };\n  const defs = NODE_FIELDS.TSQualifiedName;\n  validate(defs.left, node, \"left\", left, 1);\n  validate(defs.right, node, \"right\", right, 1);\n  return node;\n}\nfunction tsCallSignatureDeclaration(typeParameters = null, parameters, typeAnnotation = null) {\n  const node = {\n    type: \"TSCallSignatureDeclaration\",\n    typeParameters,\n    parameters,\n    typeAnnotation\n  };\n  const defs = NODE_FIELDS.TSCallSignatureDeclaration;\n  validate(defs.typeParameters, node, \"typeParameters\", typeParameters, 1);\n  validate(defs.parameters, node, \"parameters\", parameters, 1);\n  validate(defs.typeAnnotation, node, \"typeAnnotation\", typeAnnotation, 1);\n  return node;\n}\nfunction tsConstructSignatureDeclaration(typeParameters = null, parameters, typeAnnotation = null) {\n  const node = {\n    type: \"TSConstructSignatureDeclaration\",\n    typeParameters,\n    parameters,\n    typeAnnotation\n  };\n  const defs = NODE_FIELDS.TSConstructSignatureDeclaration;\n  validate(defs.typeParameters, node, \"typeParameters\", typeParameters, 1);\n  validate(defs.parameters, node, \"parameters\", parameters, 1);\n  validate(defs.typeAnnotation, node, \"typeAnnotation\", typeAnnotation, 1);\n  return node;\n}\nfunction tsPropertySignature(key, typeAnnotation = null) {\n  const node = {\n    type: \"TSPropertySignature\",\n    key,\n    typeAnnotation\n  };\n  const defs = NODE_FIELDS.TSPropertySignature;\n  validate(defs.key, node, \"key\", key, 1);\n  validate(defs.typeAnnotation, node, \"typeAnnotation\", typeAnnotation, 1);\n  return node;\n}\nfunction tsMethodSignature(key, typeParameters = null, parameters, typeAnnotation = null) {\n  const node = {\n    type: \"TSMethodSignature\",\n    key,\n    typeParameters,\n    parameters,\n    typeAnnotation,\n    kind: null\n  };\n  const defs = NODE_FIELDS.TSMethodSignature;\n  validate(defs.key, node, \"key\", key, 1);\n  validate(defs.typeParameters, node, \"typeParameters\", typeParameters, 1);\n  validate(defs.parameters, node, \"parameters\", parameters, 1);\n  validate(defs.typeAnnotation, node, \"typeAnnotation\", typeAnnotation, 1);\n  return node;\n}\nfunction tsIndexSignature(parameters, typeAnnotation = null) {\n  const node = {\n    type: \"TSIndexSignature\",\n    parameters,\n    typeAnnotation\n  };\n  const defs = NODE_FIELDS.TSIndexSignature;\n  validate(defs.parameters, node, \"parameters\", parameters, 1);\n  validate(defs.typeAnnotation, node, \"typeAnnotation\", typeAnnotation, 1);\n  return node;\n}\nfunction tsAnyKeyword() {\n  return {\n    type: \"TSAnyKeyword\"\n  };\n}\nfunction tsBooleanKeyword() {\n  return {\n    type: \"TSBooleanKeyword\"\n  };\n}\nfunction tsBigIntKeyword() {\n  return {\n    type: \"TSBigIntKeyword\"\n  };\n}\nfunction tsIntrinsicKeyword() {\n  return {\n    type: \"TSIntrinsicKeyword\"\n  };\n}\nfunction tsNeverKeyword() {\n  return {\n    type: \"TSNeverKeyword\"\n  };\n}\nfunction tsNullKeyword() {\n  return {\n    type: \"TSNullKeyword\"\n  };\n}\nfunction tsNumberKeyword() {\n  return {\n    type: \"TSNumberKeyword\"\n  };\n}\nfunction tsObjectKeyword() {\n  return {\n    type: \"TSObjectKeyword\"\n  };\n}\nfunction tsStringKeyword() {\n  return {\n    type: \"TSStringKeyword\"\n  };\n}\nfunction tsSymbolKeyword() {\n  return {\n    type: \"TSSymbolKeyword\"\n  };\n}\nfunction tsUndefinedKeyword() {\n  return {\n    type: \"TSUndefinedKeyword\"\n  };\n}\nfunction tsUnknownKeyword() {\n  return {\n    type: \"TSUnknownKeyword\"\n  };\n}\nfunction tsVoidKeyword() {\n  return {\n    type: \"TSVoidKeyword\"\n  };\n}\nfunction tsThisType() {\n  return {\n    type: \"TSThisType\"\n  };\n}\nfunction tsFunctionType(typeParameters = null, parameters, typeAnnotation = null) {\n  const node = {\n    type: \"TSFunctionType\",\n    typeParameters,\n    parameters,\n    typeAnnotation\n  };\n  const defs = NODE_FIELDS.TSFunctionType;\n  validate(defs.typeParameters, node, \"typeParameters\", typeParameters, 1);\n  validate(defs.parameters, node, \"parameters\", parameters, 1);\n  validate(defs.typeAnnotation, node, \"typeAnnotation\", typeAnnotation, 1);\n  return node;\n}\nfunction tsConstructorType(typeParameters = null, parameters, typeAnnotation = null) {\n  const node = {\n    type: \"TSConstructorType\",\n    typeParameters,\n    parameters,\n    typeAnnotation\n  };\n  const defs = NODE_FIELDS.TSConstructorType;\n  validate(defs.typeParameters, node, \"typeParameters\", typeParameters, 1);\n  validate(defs.parameters, node, \"parameters\", parameters, 1);\n  validate(defs.typeAnnotation, node, \"typeAnnotation\", typeAnnotation, 1);\n  return node;\n}\nfunction tsTypeReference(typeName, typeParameters = null) {\n  const node = {\n    type: \"TSTypeReference\",\n    typeName,\n    typeParameters\n  };\n  const defs = NODE_FIELDS.TSTypeReference;\n  validate(defs.typeName, node, \"typeName\", typeName, 1);\n  validate(defs.typeParameters, node, \"typeParameters\", typeParameters, 1);\n  return node;\n}\nfunction tsTypePredicate(parameterName, typeAnnotation = null, asserts = null) {\n  const node = {\n    type: \"TSTypePredicate\",\n    parameterName,\n    typeAnnotation,\n    asserts\n  };\n  const defs = NODE_FIELDS.TSTypePredicate;\n  validate(defs.parameterName, node, \"parameterName\", parameterName, 1);\n  validate(defs.typeAnnotation, node, \"typeAnnotation\", typeAnnotation, 1);\n  validate(defs.asserts, node, \"asserts\", asserts);\n  return node;\n}\nfunction tsTypeQuery(exprName, typeParameters = null) {\n  const node = {\n    type: \"TSTypeQuery\",\n    exprName,\n    typeParameters\n  };\n  const defs = NODE_FIELDS.TSTypeQuery;\n  validate(defs.exprName, node, \"exprName\", exprName, 1);\n  validate(defs.typeParameters, node, \"typeParameters\", typeParameters, 1);\n  return node;\n}\nfunction tsTypeLiteral(members) {\n  const node = {\n    type: \"TSTypeLiteral\",\n    members\n  };\n  const defs = NODE_FIELDS.TSTypeLiteral;\n  validate(defs.members, node, \"members\", members, 1);\n  return node;\n}\nfunction tsArrayType(elementType) {\n  const node = {\n    type: \"TSArrayType\",\n    elementType\n  };\n  const defs = NODE_FIELDS.TSArrayType;\n  validate(defs.elementType, node, \"elementType\", elementType, 1);\n  return node;\n}\nfunction tsTupleType(elementTypes) {\n  const node = {\n    type: \"TSTupleType\",\n    elementTypes\n  };\n  const defs = NODE_FIELDS.TSTupleType;\n  validate(defs.elementTypes, node, \"elementTypes\", elementTypes, 1);\n  return node;\n}\nfunction tsOptionalType(typeAnnotation) {\n  const node = {\n    type: \"TSOptionalType\",\n    typeAnnotation\n  };\n  const defs = NODE_FIELDS.TSOptionalType;\n  validate(defs.typeAnnotation, node, \"typeAnnotation\", typeAnnotation, 1);\n  return node;\n}\nfunction tsRestType(typeAnnotation) {\n  const node = {\n    type: \"TSRestType\",\n    typeAnnotation\n  };\n  const defs = NODE_FIELDS.TSRestType;\n  validate(defs.typeAnnotation, node, \"typeAnnotation\", typeAnnotation, 1);\n  return node;\n}\nfunction tsNamedTupleMember(label, elementType, optional = false) {\n  const node = {\n    type: \"TSNamedTupleMember\",\n    label,\n    elementType,\n    optional\n  };\n  const defs = NODE_FIELDS.TSNamedTupleMember;\n  validate(defs.label, node, \"label\", label, 1);\n  validate(defs.elementType, node, \"elementType\", elementType, 1);\n  validate(defs.optional, node, \"optional\", optional);\n  return node;\n}\nfunction tsUnionType(types) {\n  const node = {\n    type: \"TSUnionType\",\n    types\n  };\n  const defs = NODE_FIELDS.TSUnionType;\n  validate(defs.types, node, \"types\", types, 1);\n  return node;\n}\nfunction tsIntersectionType(types) {\n  const node = {\n    type: \"TSIntersectionType\",\n    types\n  };\n  const defs = NODE_FIELDS.TSIntersectionType;\n  validate(defs.types, node, \"types\", types, 1);\n  return node;\n}\nfunction tsConditionalType(checkType, extendsType, trueType, falseType) {\n  const node = {\n    type: \"TSConditionalType\",\n    checkType,\n    extendsType,\n    trueType,\n    falseType\n  };\n  const defs = NODE_FIELDS.TSConditionalType;\n  validate(defs.checkType, node, \"checkType\", checkType, 1);\n  validate(defs.extendsType, node, \"extendsType\", extendsType, 1);\n  validate(defs.trueType, node, \"trueType\", trueType, 1);\n  validate(defs.falseType, node, \"falseType\", falseType, 1);\n  return node;\n}\nfunction tsInferType(typeParameter) {\n  const node = {\n    type: \"TSInferType\",\n    typeParameter\n  };\n  const defs = NODE_FIELDS.TSInferType;\n  validate(defs.typeParameter, node, \"typeParameter\", typeParameter, 1);\n  return node;\n}\nfunction tsParenthesizedType(typeAnnotation) {\n  const node = {\n    type: \"TSParenthesizedType\",\n    typeAnnotation\n  };\n  const defs = NODE_FIELDS.TSParenthesizedType;\n  validate(defs.typeAnnotation, node, \"typeAnnotation\", typeAnnotation, 1);\n  return node;\n}\nfunction tsTypeOperator(typeAnnotation, operator = \"keyof\") {\n  const node = {\n    type: \"TSTypeOperator\",\n    typeAnnotation,\n    operator\n  };\n  const defs = NODE_FIELDS.TSTypeOperator;\n  validate(defs.typeAnnotation, node, \"typeAnnotation\", typeAnnotation, 1);\n  validate(defs.operator, node, \"operator\", operator);\n  return node;\n}\nfunction tsIndexedAccessType(objectType, indexType) {\n  const node = {\n    type: \"TSIndexedAccessType\",\n    objectType,\n    indexType\n  };\n  const defs = NODE_FIELDS.TSIndexedAccessType;\n  validate(defs.objectType, node, \"objectType\", objectType, 1);\n  validate(defs.indexType, node, \"indexType\", indexType, 1);\n  return node;\n}\nfunction tsMappedType(typeParameter, typeAnnotation = null, nameType = null) {\n  const node = {\n    type: \"TSMappedType\",\n    typeParameter,\n    typeAnnotation,\n    nameType\n  };\n  const defs = NODE_FIELDS.TSMappedType;\n  validate(defs.typeParameter, node, \"typeParameter\", typeParameter, 1);\n  validate(defs.typeAnnotation, node, \"typeAnnotation\", typeAnnotation, 1);\n  validate(defs.nameType, node, \"nameType\", nameType, 1);\n  return node;\n}\nfunction tsTemplateLiteralType(quasis, types) {\n  const node = {\n    type: \"TSTemplateLiteralType\",\n    quasis,\n    types\n  };\n  const defs = NODE_FIELDS.TSTemplateLiteralType;\n  validate(defs.quasis, node, \"quasis\", quasis, 1);\n  validate(defs.types, node, \"types\", types, 1);\n  return node;\n}\nfunction tsLiteralType(literal) {\n  const node = {\n    type: \"TSLiteralType\",\n    literal\n  };\n  const defs = NODE_FIELDS.TSLiteralType;\n  validate(defs.literal, node, \"literal\", literal, 1);\n  return node;\n}\nfunction tsExpressionWithTypeArguments(expression, typeParameters = null) {\n  const node = {\n    type: \"TSExpressionWithTypeArguments\",\n    expression,\n    typeParameters\n  };\n  const defs = NODE_FIELDS.TSExpressionWithTypeArguments;\n  validate(defs.expression, node, \"expression\", expression, 1);\n  validate(defs.typeParameters, node, \"typeParameters\", typeParameters, 1);\n  return node;\n}\nfunction tsInterfaceDeclaration(id, typeParameters = null, _extends = null, body) {\n  const node = {\n    type: \"TSInterfaceDeclaration\",\n    id,\n    typeParameters,\n    extends: _extends,\n    body\n  };\n  const defs = NODE_FIELDS.TSInterfaceDeclaration;\n  validate(defs.id, node, \"id\", id, 1);\n  validate(defs.typeParameters, node, \"typeParameters\", typeParameters, 1);\n  validate(defs.extends, node, \"extends\", _extends, 1);\n  validate(defs.body, node, \"body\", body, 1);\n  return node;\n}\nfunction tsInterfaceBody(body) {\n  const node = {\n    type: \"TSInterfaceBody\",\n    body\n  };\n  const defs = NODE_FIELDS.TSInterfaceBody;\n  validate(defs.body, node, \"body\", body, 1);\n  return node;\n}\nfunction tsTypeAliasDeclaration(id, typeParameters = null, typeAnnotation) {\n  const node = {\n    type: \"TSTypeAliasDeclaration\",\n    id,\n    typeParameters,\n    typeAnnotation\n  };\n  const defs = NODE_FIELDS.TSTypeAliasDeclaration;\n  validate(defs.id, node, \"id\", id, 1);\n  validate(defs.typeParameters, node, \"typeParameters\", typeParameters, 1);\n  validate(defs.typeAnnotation, node, \"typeAnnotation\", typeAnnotation, 1);\n  return node;\n}\nfunction tsInstantiationExpression(expression, typeParameters = null) {\n  const node = {\n    type: \"TSInstantiationExpression\",\n    expression,\n    typeParameters\n  };\n  const defs = NODE_FIELDS.TSInstantiationExpression;\n  validate(defs.expression, node, \"expression\", expression, 1);\n  validate(defs.typeParameters, node, \"typeParameters\", typeParameters, 1);\n  return node;\n}\nfunction tsAsExpression(expression, typeAnnotation) {\n  const node = {\n    type: \"TSAsExpression\",\n    expression,\n    typeAnnotation\n  };\n  const defs = NODE_FIELDS.TSAsExpression;\n  validate(defs.expression, node, \"expression\", expression, 1);\n  validate(defs.typeAnnotation, node, \"typeAnnotation\", typeAnnotation, 1);\n  return node;\n}\nfunction tsSatisfiesExpression(expression, typeAnnotation) {\n  const node = {\n    type: \"TSSatisfiesExpression\",\n    expression,\n    typeAnnotation\n  };\n  const defs = NODE_FIELDS.TSSatisfiesExpression;\n  validate(defs.expression, node, \"expression\", expression, 1);\n  validate(defs.typeAnnotation, node, \"typeAnnotation\", typeAnnotation, 1);\n  return node;\n}\nfunction tsTypeAssertion(typeAnnotation, expression) {\n  const node = {\n    type: \"TSTypeAssertion\",\n    typeAnnotation,\n    expression\n  };\n  const defs = NODE_FIELDS.TSTypeAssertion;\n  validate(defs.typeAnnotation, node, \"typeAnnotation\", typeAnnotation, 1);\n  validate(defs.expression, node, \"expression\", expression, 1);\n  return node;\n}\nfunction tsEnumBody(members) {\n  const node = {\n    type: \"TSEnumBody\",\n    members\n  };\n  const defs = NODE_FIELDS.TSEnumBody;\n  validate(defs.members, node, \"members\", members, 1);\n  return node;\n}\nfunction tsEnumDeclaration(id, members) {\n  const node = {\n    type: \"TSEnumDeclaration\",\n    id,\n    members\n  };\n  const defs = NODE_FIELDS.TSEnumDeclaration;\n  validate(defs.id, node, \"id\", id, 1);\n  validate(defs.members, node, \"members\", members, 1);\n  return node;\n}\nfunction tsEnumMember(id, initializer = null) {\n  const node = {\n    type: \"TSEnumMember\",\n    id,\n    initializer\n  };\n  const defs = NODE_FIELDS.TSEnumMember;\n  validate(defs.id, node, \"id\", id, 1);\n  validate(defs.initializer, node, \"initializer\", initializer, 1);\n  return node;\n}\nfunction tsModuleDeclaration(id, body) {\n  const node = {\n    type: \"TSModuleDeclaration\",\n    id,\n    body,\n    kind: null\n  };\n  const defs = NODE_FIELDS.TSModuleDeclaration;\n  validate(defs.id, node, \"id\", id, 1);\n  validate(defs.body, node, \"body\", body, 1);\n  return node;\n}\nfunction tsModuleBlock(body) {\n  const node = {\n    type: \"TSModuleBlock\",\n    body\n  };\n  const defs = NODE_FIELDS.TSModuleBlock;\n  validate(defs.body, node, \"body\", body, 1);\n  return node;\n}\nfunction tsImportType(argument, qualifier = null, typeParameters = null) {\n  const node = {\n    type: \"TSImportType\",\n    argument,\n    qualifier,\n    typeParameters\n  };\n  const defs = NODE_FIELDS.TSImportType;\n  validate(defs.argument, node, \"argument\", argument, 1);\n  validate(defs.qualifier, node, \"qualifier\", qualifier, 1);\n  validate(defs.typeParameters, node, \"typeParameters\", typeParameters, 1);\n  return node;\n}\nfunction tsImportEqualsDeclaration(id, moduleReference) {\n  const node = {\n    type: \"TSImportEqualsDeclaration\",\n    id,\n    moduleReference,\n    isExport: null\n  };\n  const defs = NODE_FIELDS.TSImportEqualsDeclaration;\n  validate(defs.id, node, \"id\", id, 1);\n  validate(defs.moduleReference, node, \"moduleReference\", moduleReference, 1);\n  return node;\n}\nfunction tsExternalModuleReference(expression) {\n  const node = {\n    type: \"TSExternalModuleReference\",\n    expression\n  };\n  const defs = NODE_FIELDS.TSExternalModuleReference;\n  validate(defs.expression, node, \"expression\", expression, 1);\n  return node;\n}\nfunction tsNonNullExpression(expression) {\n  const node = {\n    type: \"TSNonNullExpression\",\n    expression\n  };\n  const defs = NODE_FIELDS.TSNonNullExpression;\n  validate(defs.expression, node, \"expression\", expression, 1);\n  return node;\n}\nfunction tsExportAssignment(expression) {\n  const node = {\n    type: \"TSExportAssignment\",\n    expression\n  };\n  const defs = NODE_FIELDS.TSExportAssignment;\n  validate(defs.expression, node, \"expression\", expression, 1);\n  return node;\n}\nfunction tsNamespaceExportDeclaration(id) {\n  const node = {\n    type: \"TSNamespaceExportDeclaration\",\n    id\n  };\n  const defs = NODE_FIELDS.TSNamespaceExportDeclaration;\n  validate(defs.id, node, \"id\", id, 1);\n  return node;\n}\nfunction tsTypeAnnotation(typeAnnotation) {\n  const node = {\n    type: \"TSTypeAnnotation\",\n    typeAnnotation\n  };\n  const defs = NODE_FIELDS.TSTypeAnnotation;\n  validate(defs.typeAnnotation, node, \"typeAnnotation\", typeAnnotation, 1);\n  return node;\n}\nfunction tsTypeParameterInstantiation(params) {\n  const node = {\n    type: \"TSTypeParameterInstantiation\",\n    params\n  };\n  const defs = NODE_FIELDS.TSTypeParameterInstantiation;\n  validate(defs.params, node, \"params\", params, 1);\n  return node;\n}\nfunction tsTypeParameterDeclaration(params) {\n  const node = {\n    type: \"TSTypeParameterDeclaration\",\n    params\n  };\n  const defs = NODE_FIELDS.TSTypeParameterDeclaration;\n  validate(defs.params, node, \"params\", params, 1);\n  return node;\n}\nfunction tsTypeParameter(constraint = null, _default = null, name) {\n  const node = {\n    type: \"TSTypeParameter\",\n    constraint,\n    default: _default,\n    name\n  };\n  const defs = NODE_FIELDS.TSTypeParameter;\n  validate(defs.constraint, node, \"constraint\", constraint, 1);\n  validate(defs.default, node, \"default\", _default, 1);\n  validate(defs.name, node, \"name\", name);\n  return node;\n}\nfunction NumberLiteral(value) {\n  (0, _deprecationWarning.default)(\"NumberLiteral\", \"NumericLiteral\", \"The node type \");\n  return numericLiteral(value);\n}\nfunction RegexLiteral(pattern, flags = \"\") {\n  (0, _deprecationWarning.default)(\"RegexLiteral\", \"RegExpLiteral\", \"The node type \");\n  return regExpLiteral(pattern, flags);\n}\nfunction RestProperty(argument) {\n  (0, _deprecationWarning.default)(\"RestProperty\", \"RestElement\", \"The node type \");\n  return restElement(argument);\n}\nfunction SpreadProperty(argument) {\n  (0, _deprecationWarning.default)(\"SpreadProperty\", \"SpreadElement\", \"The node type \");\n  return spreadElement(argument);\n}\n\n//# sourceMappingURL=lowercase.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGJhYmVsL3R5cGVzL2xpYi9idWlsZGVycy9nZW5lcmF0ZWQvbG93ZXJjYXNlLmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViLDhDQUE2QztBQUM3QztBQUNBLENBQUMsRUFBQztBQUNGLHlCQUF5QjtBQUN6QiwyQkFBMkI7QUFDM0IsdUJBQXVCO0FBQ3ZCLG9CQUFvQjtBQUNwQiwyQkFBMkI7QUFDM0IsK0JBQStCO0FBQy9CLDRCQUE0QjtBQUM1Qix5QkFBeUI7QUFDekIsdUJBQXVCO0FBQ3ZCLHFCQUFxQjtBQUNyQix3QkFBd0I7QUFDeEIsc0JBQXNCO0FBQ3RCLHNCQUFzQjtBQUN0QixzQkFBc0I7QUFDdEIsb0NBQW9DO0FBQ3BDLDZCQUE2QjtBQUM3QixzQkFBc0I7QUFDdEIsc0JBQXNCO0FBQ3RCLG1CQUFtQjtBQUNuQiw2QkFBNkI7QUFDN0IsaUJBQWlCO0FBQ2pCLHdCQUF3QjtBQUN4Qix1QkFBdUI7QUFDdkIsdUJBQXVCO0FBQ3ZCLG1CQUFtQjtBQUNuQiwwQkFBMEI7QUFDMUIsNEJBQTRCO0FBQzVCLHFCQUFxQjtBQUNyQiw2QkFBNkI7QUFDN0IseUJBQXlCO0FBQ3pCLHlCQUF5QjtBQUN6QixzQkFBc0I7QUFDdEIsb0JBQW9CO0FBQ3BCLG1DQUFtQztBQUNuQyxnQ0FBZ0M7QUFDaEMsdUJBQXVCO0FBQ3ZCLHdCQUF3QjtBQUN4QixxQkFBcUI7QUFDckIsNEJBQTRCO0FBQzVCLHlCQUF5QjtBQUN6Qix3QkFBd0I7QUFDeEIsdUJBQXVCO0FBQ3ZCLHlCQUF5QjtBQUN6QixpQkFBaUI7QUFDakIsaUJBQWlCO0FBQ2pCLHdCQUF3QjtBQUN4QixvQkFBb0I7QUFDcEIsd0JBQXdCO0FBQ3hCLHNCQUFzQjtBQUN0QiwyQkFBMkI7QUFDM0IsdUJBQXVCO0FBQ3ZCLHlCQUF5QjtBQUN6Qix1QkFBdUI7QUFDdkIsMkJBQTJCO0FBQzNCLHNCQUFzQjtBQUN0Qix3QkFBd0I7QUFDeEIsc0JBQXNCO0FBQ3RCLHdCQUF3QjtBQUN4QixzQkFBc0I7QUFDdEIsNEJBQTRCO0FBQzVCLDRCQUE0QjtBQUM1QixnQ0FBZ0M7QUFDaEMsOEJBQThCO0FBQzlCLDhCQUE4QjtBQUM5QixnQ0FBZ0M7QUFDaEMsdUJBQXVCO0FBQ3ZCLDJCQUEyQjtBQUMzQixZQUFZO0FBQ1osc0JBQXNCO0FBQ3RCLHNCQUFzQjtBQUN0QixvQkFBb0I7QUFDcEIsMkJBQTJCO0FBQzNCLDBCQUEwQjtBQUMxQiw4QkFBOEI7QUFDOUIseUJBQXlCO0FBQ3pCLDZCQUE2QjtBQUM3QixrQkFBa0I7QUFDbEIsbUJBQW1CO0FBQ25CLGlCQUFjO0FBQ2QsdUJBQXVCO0FBQ3ZCLHlCQUF5QjtBQUN6Qiw4QkFBOEI7QUFDOUIsd0JBQXdCO0FBQ3hCLGdDQUFnQztBQUNoQyx1QkFBdUI7QUFDdkIseUJBQXlCO0FBQ3pCLHlCQUF5QjtBQUN6Qiw0QkFBNEI7QUFDNUIsd0JBQXdCO0FBQ3hCLCtCQUErQjtBQUMvQiw0QkFBNEI7QUFDNUIsa0NBQWtDO0FBQ2xDLG9CQUFvQixHQUFHLG9CQUFvQjtBQUMzQyx5QkFBeUIsR0FBRyx5QkFBeUI7QUFDckQsMEJBQTBCLEdBQUcsMEJBQTBCO0FBQ3ZELGtCQUFrQixHQUFHLGtCQUFrQjtBQUN2QywwQkFBMEIsR0FBRywwQkFBMEI7QUFDdkQsOEJBQThCLEdBQUcsOEJBQThCO0FBQy9ELG1CQUFtQixHQUFHLG1CQUFtQjtBQUN6QyxxQkFBcUIsR0FBRyxxQkFBcUI7QUFDN0MsMkJBQTJCLEdBQUcsMkJBQTJCO0FBQ3pELHlCQUF5QixHQUFHLHlCQUF5QjtBQUNyRCx5QkFBeUIsR0FBRyx5QkFBeUI7QUFDckQsMEJBQTBCLEdBQUcsMEJBQTBCO0FBQ3ZELDBCQUEwQixHQUFHLDBCQUEwQjtBQUN2RCxzQkFBc0IsR0FBRyxzQkFBc0I7QUFDL0MsZUFBZSxHQUFHLGVBQWU7QUFDakMsd0JBQXdCO0FBQ3hCLHlCQUF5QjtBQUN6Qix3QkFBd0I7QUFDeEIsb0JBQW9CO0FBQ3BCLDJCQUEyQjtBQUMzQix3QkFBd0I7QUFDeEIscUJBQXFCO0FBQ3JCLFlBQVk7QUFDWixtQkFBbUI7QUFDbkIsaUNBQWlDO0FBQ2pDLDhCQUE4QjtBQUM5QixxQkFBcUI7QUFDckIsbUNBQW1DO0FBQ25DLDRCQUE0QjtBQUM1QixzQkFBc0I7QUFDdEIsd0JBQXdCO0FBQ3hCLG9CQUFvQjtBQUNwQixxQkFBcUI7QUFDckIsc0JBQXNCO0FBQ3RCLDRCQUE0QjtBQUM1Qiw4QkFBOEI7QUFDOUIseUJBQXlCO0FBQ3pCLDhCQUE4QjtBQUM5QiwwQkFBMEI7QUFDMUIsZ0NBQWdDO0FBQ2hDLGtCQUFrQjtBQUNsQiw4QkFBOEI7QUFDOUIsaUNBQWlDO0FBQ2pDLGdDQUFnQztBQUNoQywrQkFBK0I7QUFDL0IsNEJBQTRCO0FBQzVCLHFDQUFxQztBQUNyQywrQkFBK0I7QUFDL0IsbUJBQW1CO0FBQ25CLG1CQUFtQjtBQUNuQixlQUFlO0FBQ2YsK0JBQStCO0FBQy9CLHdCQUF3QjtBQUN4QixxQkFBcUI7QUFDckIsb0JBQW9CO0FBQ3BCLG1CQUFtQjtBQUNuQixvQkFBb0I7QUFDcEIsdUJBQXVCO0FBQ3ZCLDBCQUEwQjtBQUMxQixxQkFBcUI7QUFDckIsc0JBQXNCO0FBQ3RCLG1CQUFtQjtBQUNuQixxQkFBcUI7QUFDckIsbUNBQW1DO0FBQ25DLDRCQUE0QjtBQUM1QixnQkFBYTtBQUNiLGtCQUFrQjtBQUNsQix1QkFBdUI7QUFDdkIsNEJBQTRCO0FBQzVCLGdDQUFnQztBQUNoQyx1QkFBdUI7QUFDdkIsdUJBQXVCO0FBQ3ZCLHNCQUFzQjtBQUN0QiwwQkFBMEI7QUFDMUIsc0JBQXNCO0FBQ3RCLHNCQUFzQjtBQUN0QixvQkFBb0I7QUFDcEIsb0JBQW9CLEdBQUcsb0JBQW9CO0FBQzNDLG1CQUFtQixHQUFHLG1CQUFtQjtBQUN6QyxzQkFBc0IsR0FBRyxzQkFBc0I7QUFDL0MsdUJBQXVCLEdBQUcsdUJBQXVCO0FBQ2pELHdCQUF3QixHQUFHLHdCQUF3QjtBQUNuRCxrQ0FBa0MsR0FBRyxrQ0FBa0M7QUFDdkUseUJBQXlCLEdBQUcseUJBQXlCO0FBQ3JELHVDQUF1QyxHQUFHLHVDQUF1QztBQUNqRix5QkFBeUIsR0FBRyx5QkFBeUI7QUFDckQseUJBQXlCLEdBQUcseUJBQXlCO0FBQ3JELHVCQUF1QixHQUFHLHVCQUF1QjtBQUNqRCxrQkFBa0IsR0FBRyxrQkFBa0I7QUFDdkMseUJBQXlCLEdBQUcseUJBQXlCO0FBQ3JELG9CQUFvQixHQUFHLG9CQUFvQjtBQUMzQywwQkFBMEIsR0FBRywwQkFBMEI7QUFDdkQscUNBQXFDLEdBQUcscUNBQXFDO0FBQzdFLGlDQUFpQyxHQUFHLGlDQUFpQztBQUNyRSxzQkFBc0IsR0FBRyxzQkFBc0I7QUFDL0MsaUNBQWlDLEdBQUcsaUNBQWlDO0FBQ3JFLG9CQUFvQixHQUFHLG9CQUFvQjtBQUMzQyx3QkFBd0IsR0FBRyx3QkFBd0I7QUFDbkQsMkJBQTJCLEdBQUcsMkJBQTJCO0FBQ3pELG1CQUFtQixHQUFHLG1CQUFtQjtBQUN6QyxpQ0FBaUMsR0FBRyxpQ0FBaUM7QUFDckUsdUJBQXVCLEdBQUcsdUJBQXVCO0FBQ2pELDhCQUE4QixHQUFHLDhCQUE4QjtBQUMvRCwwQkFBMEIsR0FBRywwQkFBMEI7QUFDdkQsMEJBQTBCLEdBQUcsMEJBQTBCO0FBQ3ZELHFCQUFxQixHQUFHLHFCQUFxQjtBQUM3QyxvQkFBb0IsR0FBRyxvQkFBb0I7QUFDM0MseUJBQXlCLEdBQUcseUJBQXlCO0FBQ3JELHFCQUFxQixHQUFHLHFCQUFxQjtBQUM3QywyQkFBMkIsR0FBRywyQkFBMkI7QUFDekQsMEJBQTBCLEdBQUcsMEJBQTBCO0FBQ3ZELG9DQUFvQyxHQUFHLG9DQUFvQztBQUMzRSxzQkFBc0IsR0FBRyxzQkFBc0I7QUFDL0MsMkJBQTJCLEdBQUcsMkJBQTJCO0FBQ3pELHFCQUFxQixHQUFHLHFCQUFxQjtBQUM3Qyx1QkFBdUIsR0FBRyx1QkFBdUI7QUFDakQsdUJBQXVCLEdBQUcsdUJBQXVCO0FBQ2pELHNCQUFzQixHQUFHLHNCQUFzQjtBQUMvQywyQkFBMkIsR0FBRywyQkFBMkI7QUFDekQsMkJBQTJCLEdBQUcsMkJBQTJCO0FBQ3pELDJCQUEyQixHQUFHLDJCQUEyQjtBQUN6RCx1QkFBdUIsR0FBRyx1QkFBdUI7QUFDakQsa0JBQWtCLEdBQUcsa0JBQWtCO0FBQ3ZDLDZCQUE2QixHQUFHLDZCQUE2QjtBQUM3RCx1QkFBdUIsR0FBRyx1QkFBdUI7QUFDakQsdUJBQXVCLEdBQUcsdUJBQXVCO0FBQ2pELDZCQUE2QixHQUFHLDZCQUE2QjtBQUM3RCxrQkFBa0IsR0FBRyxrQkFBa0I7QUFDdkMsbUJBQW1CLEdBQUcsbUJBQW1CO0FBQ3pDLDhCQUE4QixHQUFHLDhCQUE4QjtBQUMvRCx3QkFBd0IsR0FBRyx3QkFBd0I7QUFDbkQsdUJBQXVCLEdBQUcsdUJBQXVCO0FBQ2pELHFCQUFxQixHQUFHLHFCQUFxQjtBQUM3QyxzQkFBc0IsR0FBRyxzQkFBc0I7QUFDL0MsdUJBQXVCLEdBQUcsdUJBQXVCO0FBQ2pELGtDQUFrQyxHQUFHLGtDQUFrQztBQUN2RSxvQ0FBb0MsR0FBRyxvQ0FBb0M7QUFDM0UsdUJBQXVCLEdBQUcsdUJBQXVCO0FBQ2pELG1CQUFtQixHQUFHLG1CQUFtQjtBQUN6Qyx1QkFBdUIsR0FBRyx1QkFBdUI7QUFDakQsMEJBQTBCLEdBQUcsMEJBQTBCO0FBQ3ZELG1CQUFtQixHQUFHLG1CQUFtQjtBQUN6Qyx3QkFBd0IsR0FBRyx3QkFBd0I7QUFDbkQscUJBQXFCLEdBQUcscUJBQXFCO0FBQzdDLHVCQUF1QjtBQUN2QiwyQkFBMkI7QUFDM0IsaUJBQWlCO0FBQ2pCLHNCQUFzQjtBQUN0QiwwQkFBMEI7QUFDMUIscUJBQXFCO0FBQ3JCLGdDQUFnQztBQUNoQyxrQ0FBa0M7QUFDbEMsNEJBQTRCO0FBQzVCLHVCQUF1QjtBQUN2QiwyQkFBMkI7QUFDM0Isd0JBQXdCO0FBQ3hCLDZCQUE2QjtBQUM3QiwyQkFBMkI7QUFDM0IsMEJBQTBCO0FBQzFCLGdCQUFnQjtBQUNoQixtQkFBbUI7QUFDbkIsMEJBQTBCO0FBQzFCLHNCQUFzQjtBQUN0QixxQkFBcUI7QUFDckIsdUJBQXVCO0FBQ3ZCLGdCQUFnQixtQkFBTyxDQUFDLGtHQUE4QjtBQUN0RCwwQkFBMEIsbUJBQU8sQ0FBQyw0R0FBbUM7QUFDckUsWUFBWSxtQkFBTyxDQUFDLDhGQUE0QjtBQUNoRDtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9yZXBvLXZpc3VhbGl6ZXIvLi9ub2RlX21vZHVsZXMvQGJhYmVsL3R5cGVzL2xpYi9idWlsZGVycy9nZW5lcmF0ZWQvbG93ZXJjYXNlLmpzPzFlYzUiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLmFueVR5cGVBbm5vdGF0aW9uID0gYW55VHlwZUFubm90YXRpb247XG5leHBvcnRzLmFyZ3VtZW50UGxhY2Vob2xkZXIgPSBhcmd1bWVudFBsYWNlaG9sZGVyO1xuZXhwb3J0cy5hcnJheUV4cHJlc3Npb24gPSBhcnJheUV4cHJlc3Npb247XG5leHBvcnRzLmFycmF5UGF0dGVybiA9IGFycmF5UGF0dGVybjtcbmV4cG9ydHMuYXJyYXlUeXBlQW5ub3RhdGlvbiA9IGFycmF5VHlwZUFubm90YXRpb247XG5leHBvcnRzLmFycm93RnVuY3Rpb25FeHByZXNzaW9uID0gYXJyb3dGdW5jdGlvbkV4cHJlc3Npb247XG5leHBvcnRzLmFzc2lnbm1lbnRFeHByZXNzaW9uID0gYXNzaWdubWVudEV4cHJlc3Npb247XG5leHBvcnRzLmFzc2lnbm1lbnRQYXR0ZXJuID0gYXNzaWdubWVudFBhdHRlcm47XG5leHBvcnRzLmF3YWl0RXhwcmVzc2lvbiA9IGF3YWl0RXhwcmVzc2lvbjtcbmV4cG9ydHMuYmlnSW50TGl0ZXJhbCA9IGJpZ0ludExpdGVyYWw7XG5leHBvcnRzLmJpbmFyeUV4cHJlc3Npb24gPSBiaW5hcnlFeHByZXNzaW9uO1xuZXhwb3J0cy5iaW5kRXhwcmVzc2lvbiA9IGJpbmRFeHByZXNzaW9uO1xuZXhwb3J0cy5ibG9ja1N0YXRlbWVudCA9IGJsb2NrU3RhdGVtZW50O1xuZXhwb3J0cy5ib29sZWFuTGl0ZXJhbCA9IGJvb2xlYW5MaXRlcmFsO1xuZXhwb3J0cy5ib29sZWFuTGl0ZXJhbFR5cGVBbm5vdGF0aW9uID0gYm9vbGVhbkxpdGVyYWxUeXBlQW5ub3RhdGlvbjtcbmV4cG9ydHMuYm9vbGVhblR5cGVBbm5vdGF0aW9uID0gYm9vbGVhblR5cGVBbm5vdGF0aW9uO1xuZXhwb3J0cy5icmVha1N0YXRlbWVudCA9IGJyZWFrU3RhdGVtZW50O1xuZXhwb3J0cy5jYWxsRXhwcmVzc2lvbiA9IGNhbGxFeHByZXNzaW9uO1xuZXhwb3J0cy5jYXRjaENsYXVzZSA9IGNhdGNoQ2xhdXNlO1xuZXhwb3J0cy5jbGFzc0FjY2Vzc29yUHJvcGVydHkgPSBjbGFzc0FjY2Vzc29yUHJvcGVydHk7XG5leHBvcnRzLmNsYXNzQm9keSA9IGNsYXNzQm9keTtcbmV4cG9ydHMuY2xhc3NEZWNsYXJhdGlvbiA9IGNsYXNzRGVjbGFyYXRpb247XG5leHBvcnRzLmNsYXNzRXhwcmVzc2lvbiA9IGNsYXNzRXhwcmVzc2lvbjtcbmV4cG9ydHMuY2xhc3NJbXBsZW1lbnRzID0gY2xhc3NJbXBsZW1lbnRzO1xuZXhwb3J0cy5jbGFzc01ldGhvZCA9IGNsYXNzTWV0aG9kO1xuZXhwb3J0cy5jbGFzc1ByaXZhdGVNZXRob2QgPSBjbGFzc1ByaXZhdGVNZXRob2Q7XG5leHBvcnRzLmNsYXNzUHJpdmF0ZVByb3BlcnR5ID0gY2xhc3NQcml2YXRlUHJvcGVydHk7XG5leHBvcnRzLmNsYXNzUHJvcGVydHkgPSBjbGFzc1Byb3BlcnR5O1xuZXhwb3J0cy5jb25kaXRpb25hbEV4cHJlc3Npb24gPSBjb25kaXRpb25hbEV4cHJlc3Npb247XG5leHBvcnRzLmNvbnRpbnVlU3RhdGVtZW50ID0gY29udGludWVTdGF0ZW1lbnQ7XG5leHBvcnRzLmRlYnVnZ2VyU3RhdGVtZW50ID0gZGVidWdnZXJTdGF0ZW1lbnQ7XG5leHBvcnRzLmRlY2ltYWxMaXRlcmFsID0gZGVjaW1hbExpdGVyYWw7XG5leHBvcnRzLmRlY2xhcmVDbGFzcyA9IGRlY2xhcmVDbGFzcztcbmV4cG9ydHMuZGVjbGFyZUV4cG9ydEFsbERlY2xhcmF0aW9uID0gZGVjbGFyZUV4cG9ydEFsbERlY2xhcmF0aW9uO1xuZXhwb3J0cy5kZWNsYXJlRXhwb3J0RGVjbGFyYXRpb24gPSBkZWNsYXJlRXhwb3J0RGVjbGFyYXRpb247XG5leHBvcnRzLmRlY2xhcmVGdW5jdGlvbiA9IGRlY2xhcmVGdW5jdGlvbjtcbmV4cG9ydHMuZGVjbGFyZUludGVyZmFjZSA9IGRlY2xhcmVJbnRlcmZhY2U7XG5leHBvcnRzLmRlY2xhcmVNb2R1bGUgPSBkZWNsYXJlTW9kdWxlO1xuZXhwb3J0cy5kZWNsYXJlTW9kdWxlRXhwb3J0cyA9IGRlY2xhcmVNb2R1bGVFeHBvcnRzO1xuZXhwb3J0cy5kZWNsYXJlT3BhcXVlVHlwZSA9IGRlY2xhcmVPcGFxdWVUeXBlO1xuZXhwb3J0cy5kZWNsYXJlVHlwZUFsaWFzID0gZGVjbGFyZVR5cGVBbGlhcztcbmV4cG9ydHMuZGVjbGFyZVZhcmlhYmxlID0gZGVjbGFyZVZhcmlhYmxlO1xuZXhwb3J0cy5kZWNsYXJlZFByZWRpY2F0ZSA9IGRlY2xhcmVkUHJlZGljYXRlO1xuZXhwb3J0cy5kZWNvcmF0b3IgPSBkZWNvcmF0b3I7XG5leHBvcnRzLmRpcmVjdGl2ZSA9IGRpcmVjdGl2ZTtcbmV4cG9ydHMuZGlyZWN0aXZlTGl0ZXJhbCA9IGRpcmVjdGl2ZUxpdGVyYWw7XG5leHBvcnRzLmRvRXhwcmVzc2lvbiA9IGRvRXhwcmVzc2lvbjtcbmV4cG9ydHMuZG9XaGlsZVN0YXRlbWVudCA9IGRvV2hpbGVTdGF0ZW1lbnQ7XG5leHBvcnRzLmVtcHR5U3RhdGVtZW50ID0gZW1wdHlTdGF0ZW1lbnQ7XG5leHBvcnRzLmVtcHR5VHlwZUFubm90YXRpb24gPSBlbXB0eVR5cGVBbm5vdGF0aW9uO1xuZXhwb3J0cy5lbnVtQm9vbGVhbkJvZHkgPSBlbnVtQm9vbGVhbkJvZHk7XG5leHBvcnRzLmVudW1Cb29sZWFuTWVtYmVyID0gZW51bUJvb2xlYW5NZW1iZXI7XG5leHBvcnRzLmVudW1EZWNsYXJhdGlvbiA9IGVudW1EZWNsYXJhdGlvbjtcbmV4cG9ydHMuZW51bURlZmF1bHRlZE1lbWJlciA9IGVudW1EZWZhdWx0ZWRNZW1iZXI7XG5leHBvcnRzLmVudW1OdW1iZXJCb2R5ID0gZW51bU51bWJlckJvZHk7XG5leHBvcnRzLmVudW1OdW1iZXJNZW1iZXIgPSBlbnVtTnVtYmVyTWVtYmVyO1xuZXhwb3J0cy5lbnVtU3RyaW5nQm9keSA9IGVudW1TdHJpbmdCb2R5O1xuZXhwb3J0cy5lbnVtU3RyaW5nTWVtYmVyID0gZW51bVN0cmluZ01lbWJlcjtcbmV4cG9ydHMuZW51bVN5bWJvbEJvZHkgPSBlbnVtU3ltYm9sQm9keTtcbmV4cG9ydHMuZXhpc3RzVHlwZUFubm90YXRpb24gPSBleGlzdHNUeXBlQW5ub3RhdGlvbjtcbmV4cG9ydHMuZXhwb3J0QWxsRGVjbGFyYXRpb24gPSBleHBvcnRBbGxEZWNsYXJhdGlvbjtcbmV4cG9ydHMuZXhwb3J0RGVmYXVsdERlY2xhcmF0aW9uID0gZXhwb3J0RGVmYXVsdERlY2xhcmF0aW9uO1xuZXhwb3J0cy5leHBvcnREZWZhdWx0U3BlY2lmaWVyID0gZXhwb3J0RGVmYXVsdFNwZWNpZmllcjtcbmV4cG9ydHMuZXhwb3J0TmFtZWREZWNsYXJhdGlvbiA9IGV4cG9ydE5hbWVkRGVjbGFyYXRpb247XG5leHBvcnRzLmV4cG9ydE5hbWVzcGFjZVNwZWNpZmllciA9IGV4cG9ydE5hbWVzcGFjZVNwZWNpZmllcjtcbmV4cG9ydHMuZXhwb3J0U3BlY2lmaWVyID0gZXhwb3J0U3BlY2lmaWVyO1xuZXhwb3J0cy5leHByZXNzaW9uU3RhdGVtZW50ID0gZXhwcmVzc2lvblN0YXRlbWVudDtcbmV4cG9ydHMuZmlsZSA9IGZpbGU7XG5leHBvcnRzLmZvckluU3RhdGVtZW50ID0gZm9ySW5TdGF0ZW1lbnQ7XG5leHBvcnRzLmZvck9mU3RhdGVtZW50ID0gZm9yT2ZTdGF0ZW1lbnQ7XG5leHBvcnRzLmZvclN0YXRlbWVudCA9IGZvclN0YXRlbWVudDtcbmV4cG9ydHMuZnVuY3Rpb25EZWNsYXJhdGlvbiA9IGZ1bmN0aW9uRGVjbGFyYXRpb247XG5leHBvcnRzLmZ1bmN0aW9uRXhwcmVzc2lvbiA9IGZ1bmN0aW9uRXhwcmVzc2lvbjtcbmV4cG9ydHMuZnVuY3Rpb25UeXBlQW5ub3RhdGlvbiA9IGZ1bmN0aW9uVHlwZUFubm90YXRpb247XG5leHBvcnRzLmZ1bmN0aW9uVHlwZVBhcmFtID0gZnVuY3Rpb25UeXBlUGFyYW07XG5leHBvcnRzLmdlbmVyaWNUeXBlQW5ub3RhdGlvbiA9IGdlbmVyaWNUeXBlQW5ub3RhdGlvbjtcbmV4cG9ydHMuaWRlbnRpZmllciA9IGlkZW50aWZpZXI7XG5leHBvcnRzLmlmU3RhdGVtZW50ID0gaWZTdGF0ZW1lbnQ7XG5leHBvcnRzLmltcG9ydCA9IF9pbXBvcnQ7XG5leHBvcnRzLmltcG9ydEF0dHJpYnV0ZSA9IGltcG9ydEF0dHJpYnV0ZTtcbmV4cG9ydHMuaW1wb3J0RGVjbGFyYXRpb24gPSBpbXBvcnREZWNsYXJhdGlvbjtcbmV4cG9ydHMuaW1wb3J0RGVmYXVsdFNwZWNpZmllciA9IGltcG9ydERlZmF1bHRTcGVjaWZpZXI7XG5leHBvcnRzLmltcG9ydEV4cHJlc3Npb24gPSBpbXBvcnRFeHByZXNzaW9uO1xuZXhwb3J0cy5pbXBvcnROYW1lc3BhY2VTcGVjaWZpZXIgPSBpbXBvcnROYW1lc3BhY2VTcGVjaWZpZXI7XG5leHBvcnRzLmltcG9ydFNwZWNpZmllciA9IGltcG9ydFNwZWNpZmllcjtcbmV4cG9ydHMuaW5kZXhlZEFjY2Vzc1R5cGUgPSBpbmRleGVkQWNjZXNzVHlwZTtcbmV4cG9ydHMuaW5mZXJyZWRQcmVkaWNhdGUgPSBpbmZlcnJlZFByZWRpY2F0ZTtcbmV4cG9ydHMuaW50ZXJmYWNlRGVjbGFyYXRpb24gPSBpbnRlcmZhY2VEZWNsYXJhdGlvbjtcbmV4cG9ydHMuaW50ZXJmYWNlRXh0ZW5kcyA9IGludGVyZmFjZUV4dGVuZHM7XG5leHBvcnRzLmludGVyZmFjZVR5cGVBbm5vdGF0aW9uID0gaW50ZXJmYWNlVHlwZUFubm90YXRpb247XG5leHBvcnRzLmludGVycHJldGVyRGlyZWN0aXZlID0gaW50ZXJwcmV0ZXJEaXJlY3RpdmU7XG5leHBvcnRzLmludGVyc2VjdGlvblR5cGVBbm5vdGF0aW9uID0gaW50ZXJzZWN0aW9uVHlwZUFubm90YXRpb247XG5leHBvcnRzLmpTWEF0dHJpYnV0ZSA9IGV4cG9ydHMuanN4QXR0cmlidXRlID0ganN4QXR0cmlidXRlO1xuZXhwb3J0cy5qU1hDbG9zaW5nRWxlbWVudCA9IGV4cG9ydHMuanN4Q2xvc2luZ0VsZW1lbnQgPSBqc3hDbG9zaW5nRWxlbWVudDtcbmV4cG9ydHMualNYQ2xvc2luZ0ZyYWdtZW50ID0gZXhwb3J0cy5qc3hDbG9zaW5nRnJhZ21lbnQgPSBqc3hDbG9zaW5nRnJhZ21lbnQ7XG5leHBvcnRzLmpTWEVsZW1lbnQgPSBleHBvcnRzLmpzeEVsZW1lbnQgPSBqc3hFbGVtZW50O1xuZXhwb3J0cy5qU1hFbXB0eUV4cHJlc3Npb24gPSBleHBvcnRzLmpzeEVtcHR5RXhwcmVzc2lvbiA9IGpzeEVtcHR5RXhwcmVzc2lvbjtcbmV4cG9ydHMualNYRXhwcmVzc2lvbkNvbnRhaW5lciA9IGV4cG9ydHMuanN4RXhwcmVzc2lvbkNvbnRhaW5lciA9IGpzeEV4cHJlc3Npb25Db250YWluZXI7XG5leHBvcnRzLmpTWEZyYWdtZW50ID0gZXhwb3J0cy5qc3hGcmFnbWVudCA9IGpzeEZyYWdtZW50O1xuZXhwb3J0cy5qU1hJZGVudGlmaWVyID0gZXhwb3J0cy5qc3hJZGVudGlmaWVyID0ganN4SWRlbnRpZmllcjtcbmV4cG9ydHMualNYTWVtYmVyRXhwcmVzc2lvbiA9IGV4cG9ydHMuanN4TWVtYmVyRXhwcmVzc2lvbiA9IGpzeE1lbWJlckV4cHJlc3Npb247XG5leHBvcnRzLmpTWE5hbWVzcGFjZWROYW1lID0gZXhwb3J0cy5qc3hOYW1lc3BhY2VkTmFtZSA9IGpzeE5hbWVzcGFjZWROYW1lO1xuZXhwb3J0cy5qU1hPcGVuaW5nRWxlbWVudCA9IGV4cG9ydHMuanN4T3BlbmluZ0VsZW1lbnQgPSBqc3hPcGVuaW5nRWxlbWVudDtcbmV4cG9ydHMualNYT3BlbmluZ0ZyYWdtZW50ID0gZXhwb3J0cy5qc3hPcGVuaW5nRnJhZ21lbnQgPSBqc3hPcGVuaW5nRnJhZ21lbnQ7XG5leHBvcnRzLmpTWFNwcmVhZEF0dHJpYnV0ZSA9IGV4cG9ydHMuanN4U3ByZWFkQXR0cmlidXRlID0ganN4U3ByZWFkQXR0cmlidXRlO1xuZXhwb3J0cy5qU1hTcHJlYWRDaGlsZCA9IGV4cG9ydHMuanN4U3ByZWFkQ2hpbGQgPSBqc3hTcHJlYWRDaGlsZDtcbmV4cG9ydHMualNYVGV4dCA9IGV4cG9ydHMuanN4VGV4dCA9IGpzeFRleHQ7XG5leHBvcnRzLmxhYmVsZWRTdGF0ZW1lbnQgPSBsYWJlbGVkU3RhdGVtZW50O1xuZXhwb3J0cy5sb2dpY2FsRXhwcmVzc2lvbiA9IGxvZ2ljYWxFeHByZXNzaW9uO1xuZXhwb3J0cy5tZW1iZXJFeHByZXNzaW9uID0gbWVtYmVyRXhwcmVzc2lvbjtcbmV4cG9ydHMubWV0YVByb3BlcnR5ID0gbWV0YVByb3BlcnR5O1xuZXhwb3J0cy5taXhlZFR5cGVBbm5vdGF0aW9uID0gbWl4ZWRUeXBlQW5ub3RhdGlvbjtcbmV4cG9ydHMubW9kdWxlRXhwcmVzc2lvbiA9IG1vZHVsZUV4cHJlc3Npb247XG5leHBvcnRzLm5ld0V4cHJlc3Npb24gPSBuZXdFeHByZXNzaW9uO1xuZXhwb3J0cy5ub29wID0gbm9vcDtcbmV4cG9ydHMubnVsbExpdGVyYWwgPSBudWxsTGl0ZXJhbDtcbmV4cG9ydHMubnVsbExpdGVyYWxUeXBlQW5ub3RhdGlvbiA9IG51bGxMaXRlcmFsVHlwZUFubm90YXRpb247XG5leHBvcnRzLm51bGxhYmxlVHlwZUFubm90YXRpb24gPSBudWxsYWJsZVR5cGVBbm5vdGF0aW9uO1xuZXhwb3J0cy5udW1iZXJMaXRlcmFsID0gTnVtYmVyTGl0ZXJhbDtcbmV4cG9ydHMubnVtYmVyTGl0ZXJhbFR5cGVBbm5vdGF0aW9uID0gbnVtYmVyTGl0ZXJhbFR5cGVBbm5vdGF0aW9uO1xuZXhwb3J0cy5udW1iZXJUeXBlQW5ub3RhdGlvbiA9IG51bWJlclR5cGVBbm5vdGF0aW9uO1xuZXhwb3J0cy5udW1lcmljTGl0ZXJhbCA9IG51bWVyaWNMaXRlcmFsO1xuZXhwb3J0cy5vYmplY3RFeHByZXNzaW9uID0gb2JqZWN0RXhwcmVzc2lvbjtcbmV4cG9ydHMub2JqZWN0TWV0aG9kID0gb2JqZWN0TWV0aG9kO1xuZXhwb3J0cy5vYmplY3RQYXR0ZXJuID0gb2JqZWN0UGF0dGVybjtcbmV4cG9ydHMub2JqZWN0UHJvcGVydHkgPSBvYmplY3RQcm9wZXJ0eTtcbmV4cG9ydHMub2JqZWN0VHlwZUFubm90YXRpb24gPSBvYmplY3RUeXBlQW5ub3RhdGlvbjtcbmV4cG9ydHMub2JqZWN0VHlwZUNhbGxQcm9wZXJ0eSA9IG9iamVjdFR5cGVDYWxsUHJvcGVydHk7XG5leHBvcnRzLm9iamVjdFR5cGVJbmRleGVyID0gb2JqZWN0VHlwZUluZGV4ZXI7XG5leHBvcnRzLm9iamVjdFR5cGVJbnRlcm5hbFNsb3QgPSBvYmplY3RUeXBlSW50ZXJuYWxTbG90O1xuZXhwb3J0cy5vYmplY3RUeXBlUHJvcGVydHkgPSBvYmplY3RUeXBlUHJvcGVydHk7XG5leHBvcnRzLm9iamVjdFR5cGVTcHJlYWRQcm9wZXJ0eSA9IG9iamVjdFR5cGVTcHJlYWRQcm9wZXJ0eTtcbmV4cG9ydHMub3BhcXVlVHlwZSA9IG9wYXF1ZVR5cGU7XG5leHBvcnRzLm9wdGlvbmFsQ2FsbEV4cHJlc3Npb24gPSBvcHRpb25hbENhbGxFeHByZXNzaW9uO1xuZXhwb3J0cy5vcHRpb25hbEluZGV4ZWRBY2Nlc3NUeXBlID0gb3B0aW9uYWxJbmRleGVkQWNjZXNzVHlwZTtcbmV4cG9ydHMub3B0aW9uYWxNZW1iZXJFeHByZXNzaW9uID0gb3B0aW9uYWxNZW1iZXJFeHByZXNzaW9uO1xuZXhwb3J0cy5wYXJlbnRoZXNpemVkRXhwcmVzc2lvbiA9IHBhcmVudGhlc2l6ZWRFeHByZXNzaW9uO1xuZXhwb3J0cy5waXBlbGluZUJhcmVGdW5jdGlvbiA9IHBpcGVsaW5lQmFyZUZ1bmN0aW9uO1xuZXhwb3J0cy5waXBlbGluZVByaW1hcnlUb3BpY1JlZmVyZW5jZSA9IHBpcGVsaW5lUHJpbWFyeVRvcGljUmVmZXJlbmNlO1xuZXhwb3J0cy5waXBlbGluZVRvcGljRXhwcmVzc2lvbiA9IHBpcGVsaW5lVG9waWNFeHByZXNzaW9uO1xuZXhwb3J0cy5wbGFjZWhvbGRlciA9IHBsYWNlaG9sZGVyO1xuZXhwb3J0cy5wcml2YXRlTmFtZSA9IHByaXZhdGVOYW1lO1xuZXhwb3J0cy5wcm9ncmFtID0gcHJvZ3JhbTtcbmV4cG9ydHMucXVhbGlmaWVkVHlwZUlkZW50aWZpZXIgPSBxdWFsaWZpZWRUeXBlSWRlbnRpZmllcjtcbmV4cG9ydHMucmVjb3JkRXhwcmVzc2lvbiA9IHJlY29yZEV4cHJlc3Npb247XG5leHBvcnRzLnJlZ0V4cExpdGVyYWwgPSByZWdFeHBMaXRlcmFsO1xuZXhwb3J0cy5yZWdleExpdGVyYWwgPSBSZWdleExpdGVyYWw7XG5leHBvcnRzLnJlc3RFbGVtZW50ID0gcmVzdEVsZW1lbnQ7XG5leHBvcnRzLnJlc3RQcm9wZXJ0eSA9IFJlc3RQcm9wZXJ0eTtcbmV4cG9ydHMucmV0dXJuU3RhdGVtZW50ID0gcmV0dXJuU3RhdGVtZW50O1xuZXhwb3J0cy5zZXF1ZW5jZUV4cHJlc3Npb24gPSBzZXF1ZW5jZUV4cHJlc3Npb247XG5leHBvcnRzLnNwcmVhZEVsZW1lbnQgPSBzcHJlYWRFbGVtZW50O1xuZXhwb3J0cy5zcHJlYWRQcm9wZXJ0eSA9IFNwcmVhZFByb3BlcnR5O1xuZXhwb3J0cy5zdGF0aWNCbG9jayA9IHN0YXRpY0Jsb2NrO1xuZXhwb3J0cy5zdHJpbmdMaXRlcmFsID0gc3RyaW5nTGl0ZXJhbDtcbmV4cG9ydHMuc3RyaW5nTGl0ZXJhbFR5cGVBbm5vdGF0aW9uID0gc3RyaW5nTGl0ZXJhbFR5cGVBbm5vdGF0aW9uO1xuZXhwb3J0cy5zdHJpbmdUeXBlQW5ub3RhdGlvbiA9IHN0cmluZ1R5cGVBbm5vdGF0aW9uO1xuZXhwb3J0cy5zdXBlciA9IF9zdXBlcjtcbmV4cG9ydHMuc3dpdGNoQ2FzZSA9IHN3aXRjaENhc2U7XG5leHBvcnRzLnN3aXRjaFN0YXRlbWVudCA9IHN3aXRjaFN0YXRlbWVudDtcbmV4cG9ydHMuc3ltYm9sVHlwZUFubm90YXRpb24gPSBzeW1ib2xUeXBlQW5ub3RhdGlvbjtcbmV4cG9ydHMudGFnZ2VkVGVtcGxhdGVFeHByZXNzaW9uID0gdGFnZ2VkVGVtcGxhdGVFeHByZXNzaW9uO1xuZXhwb3J0cy50ZW1wbGF0ZUVsZW1lbnQgPSB0ZW1wbGF0ZUVsZW1lbnQ7XG5leHBvcnRzLnRlbXBsYXRlTGl0ZXJhbCA9IHRlbXBsYXRlTGl0ZXJhbDtcbmV4cG9ydHMudGhpc0V4cHJlc3Npb24gPSB0aGlzRXhwcmVzc2lvbjtcbmV4cG9ydHMudGhpc1R5cGVBbm5vdGF0aW9uID0gdGhpc1R5cGVBbm5vdGF0aW9uO1xuZXhwb3J0cy50aHJvd1N0YXRlbWVudCA9IHRocm93U3RhdGVtZW50O1xuZXhwb3J0cy50b3BpY1JlZmVyZW5jZSA9IHRvcGljUmVmZXJlbmNlO1xuZXhwb3J0cy50cnlTdGF0ZW1lbnQgPSB0cnlTdGF0ZW1lbnQ7XG5leHBvcnRzLnRTQW55S2V5d29yZCA9IGV4cG9ydHMudHNBbnlLZXl3b3JkID0gdHNBbnlLZXl3b3JkO1xuZXhwb3J0cy50U0FycmF5VHlwZSA9IGV4cG9ydHMudHNBcnJheVR5cGUgPSB0c0FycmF5VHlwZTtcbmV4cG9ydHMudFNBc0V4cHJlc3Npb24gPSBleHBvcnRzLnRzQXNFeHByZXNzaW9uID0gdHNBc0V4cHJlc3Npb247XG5leHBvcnRzLnRTQmlnSW50S2V5d29yZCA9IGV4cG9ydHMudHNCaWdJbnRLZXl3b3JkID0gdHNCaWdJbnRLZXl3b3JkO1xuZXhwb3J0cy50U0Jvb2xlYW5LZXl3b3JkID0gZXhwb3J0cy50c0Jvb2xlYW5LZXl3b3JkID0gdHNCb29sZWFuS2V5d29yZDtcbmV4cG9ydHMudFNDYWxsU2lnbmF0dXJlRGVjbGFyYXRpb24gPSBleHBvcnRzLnRzQ2FsbFNpZ25hdHVyZURlY2xhcmF0aW9uID0gdHNDYWxsU2lnbmF0dXJlRGVjbGFyYXRpb247XG5leHBvcnRzLnRTQ29uZGl0aW9uYWxUeXBlID0gZXhwb3J0cy50c0NvbmRpdGlvbmFsVHlwZSA9IHRzQ29uZGl0aW9uYWxUeXBlO1xuZXhwb3J0cy50U0NvbnN0cnVjdFNpZ25hdHVyZURlY2xhcmF0aW9uID0gZXhwb3J0cy50c0NvbnN0cnVjdFNpZ25hdHVyZURlY2xhcmF0aW9uID0gdHNDb25zdHJ1Y3RTaWduYXR1cmVEZWNsYXJhdGlvbjtcbmV4cG9ydHMudFNDb25zdHJ1Y3RvclR5cGUgPSBleHBvcnRzLnRzQ29uc3RydWN0b3JUeXBlID0gdHNDb25zdHJ1Y3RvclR5cGU7XG5leHBvcnRzLnRTRGVjbGFyZUZ1bmN0aW9uID0gZXhwb3J0cy50c0RlY2xhcmVGdW5jdGlvbiA9IHRzRGVjbGFyZUZ1bmN0aW9uO1xuZXhwb3J0cy50U0RlY2xhcmVNZXRob2QgPSBleHBvcnRzLnRzRGVjbGFyZU1ldGhvZCA9IHRzRGVjbGFyZU1ldGhvZDtcbmV4cG9ydHMudFNFbnVtQm9keSA9IGV4cG9ydHMudHNFbnVtQm9keSA9IHRzRW51bUJvZHk7XG5leHBvcnRzLnRTRW51bURlY2xhcmF0aW9uID0gZXhwb3J0cy50c0VudW1EZWNsYXJhdGlvbiA9IHRzRW51bURlY2xhcmF0aW9uO1xuZXhwb3J0cy50U0VudW1NZW1iZXIgPSBleHBvcnRzLnRzRW51bU1lbWJlciA9IHRzRW51bU1lbWJlcjtcbmV4cG9ydHMudFNFeHBvcnRBc3NpZ25tZW50ID0gZXhwb3J0cy50c0V4cG9ydEFzc2lnbm1lbnQgPSB0c0V4cG9ydEFzc2lnbm1lbnQ7XG5leHBvcnRzLnRTRXhwcmVzc2lvbldpdGhUeXBlQXJndW1lbnRzID0gZXhwb3J0cy50c0V4cHJlc3Npb25XaXRoVHlwZUFyZ3VtZW50cyA9IHRzRXhwcmVzc2lvbldpdGhUeXBlQXJndW1lbnRzO1xuZXhwb3J0cy50U0V4dGVybmFsTW9kdWxlUmVmZXJlbmNlID0gZXhwb3J0cy50c0V4dGVybmFsTW9kdWxlUmVmZXJlbmNlID0gdHNFeHRlcm5hbE1vZHVsZVJlZmVyZW5jZTtcbmV4cG9ydHMudFNGdW5jdGlvblR5cGUgPSBleHBvcnRzLnRzRnVuY3Rpb25UeXBlID0gdHNGdW5jdGlvblR5cGU7XG5leHBvcnRzLnRTSW1wb3J0RXF1YWxzRGVjbGFyYXRpb24gPSBleHBvcnRzLnRzSW1wb3J0RXF1YWxzRGVjbGFyYXRpb24gPSB0c0ltcG9ydEVxdWFsc0RlY2xhcmF0aW9uO1xuZXhwb3J0cy50U0ltcG9ydFR5cGUgPSBleHBvcnRzLnRzSW1wb3J0VHlwZSA9IHRzSW1wb3J0VHlwZTtcbmV4cG9ydHMudFNJbmRleFNpZ25hdHVyZSA9IGV4cG9ydHMudHNJbmRleFNpZ25hdHVyZSA9IHRzSW5kZXhTaWduYXR1cmU7XG5leHBvcnRzLnRTSW5kZXhlZEFjY2Vzc1R5cGUgPSBleHBvcnRzLnRzSW5kZXhlZEFjY2Vzc1R5cGUgPSB0c0luZGV4ZWRBY2Nlc3NUeXBlO1xuZXhwb3J0cy50U0luZmVyVHlwZSA9IGV4cG9ydHMudHNJbmZlclR5cGUgPSB0c0luZmVyVHlwZTtcbmV4cG9ydHMudFNJbnN0YW50aWF0aW9uRXhwcmVzc2lvbiA9IGV4cG9ydHMudHNJbnN0YW50aWF0aW9uRXhwcmVzc2lvbiA9IHRzSW5zdGFudGlhdGlvbkV4cHJlc3Npb247XG5leHBvcnRzLnRTSW50ZXJmYWNlQm9keSA9IGV4cG9ydHMudHNJbnRlcmZhY2VCb2R5ID0gdHNJbnRlcmZhY2VCb2R5O1xuZXhwb3J0cy50U0ludGVyZmFjZURlY2xhcmF0aW9uID0gZXhwb3J0cy50c0ludGVyZmFjZURlY2xhcmF0aW9uID0gdHNJbnRlcmZhY2VEZWNsYXJhdGlvbjtcbmV4cG9ydHMudFNJbnRlcnNlY3Rpb25UeXBlID0gZXhwb3J0cy50c0ludGVyc2VjdGlvblR5cGUgPSB0c0ludGVyc2VjdGlvblR5cGU7XG5leHBvcnRzLnRTSW50cmluc2ljS2V5d29yZCA9IGV4cG9ydHMudHNJbnRyaW5zaWNLZXl3b3JkID0gdHNJbnRyaW5zaWNLZXl3b3JkO1xuZXhwb3J0cy50U0xpdGVyYWxUeXBlID0gZXhwb3J0cy50c0xpdGVyYWxUeXBlID0gdHNMaXRlcmFsVHlwZTtcbmV4cG9ydHMudFNNYXBwZWRUeXBlID0gZXhwb3J0cy50c01hcHBlZFR5cGUgPSB0c01hcHBlZFR5cGU7XG5leHBvcnRzLnRTTWV0aG9kU2lnbmF0dXJlID0gZXhwb3J0cy50c01ldGhvZFNpZ25hdHVyZSA9IHRzTWV0aG9kU2lnbmF0dXJlO1xuZXhwb3J0cy50U01vZHVsZUJsb2NrID0gZXhwb3J0cy50c01vZHVsZUJsb2NrID0gdHNNb2R1bGVCbG9jaztcbmV4cG9ydHMudFNNb2R1bGVEZWNsYXJhdGlvbiA9IGV4cG9ydHMudHNNb2R1bGVEZWNsYXJhdGlvbiA9IHRzTW9kdWxlRGVjbGFyYXRpb247XG5leHBvcnRzLnRTTmFtZWRUdXBsZU1lbWJlciA9IGV4cG9ydHMudHNOYW1lZFR1cGxlTWVtYmVyID0gdHNOYW1lZFR1cGxlTWVtYmVyO1xuZXhwb3J0cy50U05hbWVzcGFjZUV4cG9ydERlY2xhcmF0aW9uID0gZXhwb3J0cy50c05hbWVzcGFjZUV4cG9ydERlY2xhcmF0aW9uID0gdHNOYW1lc3BhY2VFeHBvcnREZWNsYXJhdGlvbjtcbmV4cG9ydHMudFNOZXZlcktleXdvcmQgPSBleHBvcnRzLnRzTmV2ZXJLZXl3b3JkID0gdHNOZXZlcktleXdvcmQ7XG5leHBvcnRzLnRTTm9uTnVsbEV4cHJlc3Npb24gPSBleHBvcnRzLnRzTm9uTnVsbEV4cHJlc3Npb24gPSB0c05vbk51bGxFeHByZXNzaW9uO1xuZXhwb3J0cy50U051bGxLZXl3b3JkID0gZXhwb3J0cy50c051bGxLZXl3b3JkID0gdHNOdWxsS2V5d29yZDtcbmV4cG9ydHMudFNOdW1iZXJLZXl3b3JkID0gZXhwb3J0cy50c051bWJlcktleXdvcmQgPSB0c051bWJlcktleXdvcmQ7XG5leHBvcnRzLnRTT2JqZWN0S2V5d29yZCA9IGV4cG9ydHMudHNPYmplY3RLZXl3b3JkID0gdHNPYmplY3RLZXl3b3JkO1xuZXhwb3J0cy50U09wdGlvbmFsVHlwZSA9IGV4cG9ydHMudHNPcHRpb25hbFR5cGUgPSB0c09wdGlvbmFsVHlwZTtcbmV4cG9ydHMudFNQYXJhbWV0ZXJQcm9wZXJ0eSA9IGV4cG9ydHMudHNQYXJhbWV0ZXJQcm9wZXJ0eSA9IHRzUGFyYW1ldGVyUHJvcGVydHk7XG5leHBvcnRzLnRTUGFyZW50aGVzaXplZFR5cGUgPSBleHBvcnRzLnRzUGFyZW50aGVzaXplZFR5cGUgPSB0c1BhcmVudGhlc2l6ZWRUeXBlO1xuZXhwb3J0cy50U1Byb3BlcnR5U2lnbmF0dXJlID0gZXhwb3J0cy50c1Byb3BlcnR5U2lnbmF0dXJlID0gdHNQcm9wZXJ0eVNpZ25hdHVyZTtcbmV4cG9ydHMudFNRdWFsaWZpZWROYW1lID0gZXhwb3J0cy50c1F1YWxpZmllZE5hbWUgPSB0c1F1YWxpZmllZE5hbWU7XG5leHBvcnRzLnRTUmVzdFR5cGUgPSBleHBvcnRzLnRzUmVzdFR5cGUgPSB0c1Jlc3RUeXBlO1xuZXhwb3J0cy50U1NhdGlzZmllc0V4cHJlc3Npb24gPSBleHBvcnRzLnRzU2F0aXNmaWVzRXhwcmVzc2lvbiA9IHRzU2F0aXNmaWVzRXhwcmVzc2lvbjtcbmV4cG9ydHMudFNTdHJpbmdLZXl3b3JkID0gZXhwb3J0cy50c1N0cmluZ0tleXdvcmQgPSB0c1N0cmluZ0tleXdvcmQ7XG5leHBvcnRzLnRTU3ltYm9sS2V5d29yZCA9IGV4cG9ydHMudHNTeW1ib2xLZXl3b3JkID0gdHNTeW1ib2xLZXl3b3JkO1xuZXhwb3J0cy50U1RlbXBsYXRlTGl0ZXJhbFR5cGUgPSBleHBvcnRzLnRzVGVtcGxhdGVMaXRlcmFsVHlwZSA9IHRzVGVtcGxhdGVMaXRlcmFsVHlwZTtcbmV4cG9ydHMudFNUaGlzVHlwZSA9IGV4cG9ydHMudHNUaGlzVHlwZSA9IHRzVGhpc1R5cGU7XG5leHBvcnRzLnRTVHVwbGVUeXBlID0gZXhwb3J0cy50c1R1cGxlVHlwZSA9IHRzVHVwbGVUeXBlO1xuZXhwb3J0cy50U1R5cGVBbGlhc0RlY2xhcmF0aW9uID0gZXhwb3J0cy50c1R5cGVBbGlhc0RlY2xhcmF0aW9uID0gdHNUeXBlQWxpYXNEZWNsYXJhdGlvbjtcbmV4cG9ydHMudFNUeXBlQW5ub3RhdGlvbiA9IGV4cG9ydHMudHNUeXBlQW5ub3RhdGlvbiA9IHRzVHlwZUFubm90YXRpb247XG5leHBvcnRzLnRTVHlwZUFzc2VydGlvbiA9IGV4cG9ydHMudHNUeXBlQXNzZXJ0aW9uID0gdHNUeXBlQXNzZXJ0aW9uO1xuZXhwb3J0cy50U1R5cGVMaXRlcmFsID0gZXhwb3J0cy50c1R5cGVMaXRlcmFsID0gdHNUeXBlTGl0ZXJhbDtcbmV4cG9ydHMudFNUeXBlT3BlcmF0b3IgPSBleHBvcnRzLnRzVHlwZU9wZXJhdG9yID0gdHNUeXBlT3BlcmF0b3I7XG5leHBvcnRzLnRTVHlwZVBhcmFtZXRlciA9IGV4cG9ydHMudHNUeXBlUGFyYW1ldGVyID0gdHNUeXBlUGFyYW1ldGVyO1xuZXhwb3J0cy50U1R5cGVQYXJhbWV0ZXJEZWNsYXJhdGlvbiA9IGV4cG9ydHMudHNUeXBlUGFyYW1ldGVyRGVjbGFyYXRpb24gPSB0c1R5cGVQYXJhbWV0ZXJEZWNsYXJhdGlvbjtcbmV4cG9ydHMudFNUeXBlUGFyYW1ldGVySW5zdGFudGlhdGlvbiA9IGV4cG9ydHMudHNUeXBlUGFyYW1ldGVySW5zdGFudGlhdGlvbiA9IHRzVHlwZVBhcmFtZXRlckluc3RhbnRpYXRpb247XG5leHBvcnRzLnRTVHlwZVByZWRpY2F0ZSA9IGV4cG9ydHMudHNUeXBlUHJlZGljYXRlID0gdHNUeXBlUHJlZGljYXRlO1xuZXhwb3J0cy50U1R5cGVRdWVyeSA9IGV4cG9ydHMudHNUeXBlUXVlcnkgPSB0c1R5cGVRdWVyeTtcbmV4cG9ydHMudFNUeXBlUmVmZXJlbmNlID0gZXhwb3J0cy50c1R5cGVSZWZlcmVuY2UgPSB0c1R5cGVSZWZlcmVuY2U7XG5leHBvcnRzLnRTVW5kZWZpbmVkS2V5d29yZCA9IGV4cG9ydHMudHNVbmRlZmluZWRLZXl3b3JkID0gdHNVbmRlZmluZWRLZXl3b3JkO1xuZXhwb3J0cy50U1VuaW9uVHlwZSA9IGV4cG9ydHMudHNVbmlvblR5cGUgPSB0c1VuaW9uVHlwZTtcbmV4cG9ydHMudFNVbmtub3duS2V5d29yZCA9IGV4cG9ydHMudHNVbmtub3duS2V5d29yZCA9IHRzVW5rbm93bktleXdvcmQ7XG5leHBvcnRzLnRTVm9pZEtleXdvcmQgPSBleHBvcnRzLnRzVm9pZEtleXdvcmQgPSB0c1ZvaWRLZXl3b3JkO1xuZXhwb3J0cy50dXBsZUV4cHJlc3Npb24gPSB0dXBsZUV4cHJlc3Npb247XG5leHBvcnRzLnR1cGxlVHlwZUFubm90YXRpb24gPSB0dXBsZVR5cGVBbm5vdGF0aW9uO1xuZXhwb3J0cy50eXBlQWxpYXMgPSB0eXBlQWxpYXM7XG5leHBvcnRzLnR5cGVBbm5vdGF0aW9uID0gdHlwZUFubm90YXRpb247XG5leHBvcnRzLnR5cGVDYXN0RXhwcmVzc2lvbiA9IHR5cGVDYXN0RXhwcmVzc2lvbjtcbmV4cG9ydHMudHlwZVBhcmFtZXRlciA9IHR5cGVQYXJhbWV0ZXI7XG5leHBvcnRzLnR5cGVQYXJhbWV0ZXJEZWNsYXJhdGlvbiA9IHR5cGVQYXJhbWV0ZXJEZWNsYXJhdGlvbjtcbmV4cG9ydHMudHlwZVBhcmFtZXRlckluc3RhbnRpYXRpb24gPSB0eXBlUGFyYW1ldGVySW5zdGFudGlhdGlvbjtcbmV4cG9ydHMudHlwZW9mVHlwZUFubm90YXRpb24gPSB0eXBlb2ZUeXBlQW5ub3RhdGlvbjtcbmV4cG9ydHMudW5hcnlFeHByZXNzaW9uID0gdW5hcnlFeHByZXNzaW9uO1xuZXhwb3J0cy51bmlvblR5cGVBbm5vdGF0aW9uID0gdW5pb25UeXBlQW5ub3RhdGlvbjtcbmV4cG9ydHMudXBkYXRlRXhwcmVzc2lvbiA9IHVwZGF0ZUV4cHJlc3Npb247XG5leHBvcnRzLnY4SW50cmluc2ljSWRlbnRpZmllciA9IHY4SW50cmluc2ljSWRlbnRpZmllcjtcbmV4cG9ydHMudmFyaWFibGVEZWNsYXJhdGlvbiA9IHZhcmlhYmxlRGVjbGFyYXRpb247XG5leHBvcnRzLnZhcmlhYmxlRGVjbGFyYXRvciA9IHZhcmlhYmxlRGVjbGFyYXRvcjtcbmV4cG9ydHMudmFyaWFuY2UgPSB2YXJpYW5jZTtcbmV4cG9ydHMudm9pZFBhdHRlcm4gPSB2b2lkUGF0dGVybjtcbmV4cG9ydHMudm9pZFR5cGVBbm5vdGF0aW9uID0gdm9pZFR5cGVBbm5vdGF0aW9uO1xuZXhwb3J0cy53aGlsZVN0YXRlbWVudCA9IHdoaWxlU3RhdGVtZW50O1xuZXhwb3J0cy53aXRoU3RhdGVtZW50ID0gd2l0aFN0YXRlbWVudDtcbmV4cG9ydHMueWllbGRFeHByZXNzaW9uID0geWllbGRFeHByZXNzaW9uO1xudmFyIF92YWxpZGF0ZSA9IHJlcXVpcmUoXCIuLi8uLi92YWxpZGF0b3JzL3ZhbGlkYXRlLmpzXCIpO1xudmFyIF9kZXByZWNhdGlvbldhcm5pbmcgPSByZXF1aXJlKFwiLi4vLi4vdXRpbHMvZGVwcmVjYXRpb25XYXJuaW5nLmpzXCIpO1xudmFyIHV0aWxzID0gcmVxdWlyZShcIi4uLy4uL2RlZmluaXRpb25zL3V0aWxzLmpzXCIpO1xuY29uc3Qge1xuICB2YWxpZGF0ZUludGVybmFsOiB2YWxpZGF0ZVxufSA9IF92YWxpZGF0ZTtcbmNvbnN0IHtcbiAgTk9ERV9GSUVMRFNcbn0gPSB1dGlscztcbmZ1bmN0aW9uIGJpZ0ludExpdGVyYWwodmFsdWUpIHtcbiAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gXCJiaWdpbnRcIikge1xuICAgIHZhbHVlID0gdmFsdWUudG9TdHJpbmcoKTtcbiAgfVxuICBjb25zdCBub2RlID0ge1xuICAgIHR5cGU6IFwiQmlnSW50TGl0ZXJhbFwiLFxuICAgIHZhbHVlXG4gIH07XG4gIGNvbnN0IGRlZnMgPSBOT0RFX0ZJRUxEUy5CaWdJbnRMaXRlcmFsO1xuICB2YWxpZGF0ZShkZWZzLnZhbHVlLCBub2RlLCBcInZhbHVlXCIsIHZhbHVlKTtcbiAgcmV0dXJuIG5vZGU7XG59XG5mdW5jdGlvbiBhcnJheUV4cHJlc3Npb24oZWxlbWVudHMgPSBbXSkge1xuICBjb25zdCBub2RlID0ge1xuICAgIHR5cGU6IFwiQXJyYXlFeHByZXNzaW9uXCIsXG4gICAgZWxlbWVudHNcbiAgfTtcbiAgY29uc3QgZGVmcyA9IE5PREVfRklFTERTLkFycmF5RXhwcmVzc2lvbjtcbiAgdmFsaWRhdGUoZGVmcy5lbGVtZW50cywgbm9kZSwgXCJlbGVtZW50c1wiLCBlbGVtZW50cywgMSk7XG4gIHJldHVybiBub2RlO1xufVxuZnVuY3Rpb24gYXNzaWdubWVudEV4cHJlc3Npb24ob3BlcmF0b3IsIGxlZnQsIHJpZ2h0KSB7XG4gIGNvbnN0IG5vZGUgPSB7XG4gICAgdHlwZTogXCJBc3NpZ25tZW50RXhwcmVzc2lvblwiLFxuICAgIG9wZXJhdG9yLFxuICAgIGxlZnQsXG4gICAgcmlnaHRcbiAgfTtcbiAgY29uc3QgZGVmcyA9IE5PREVfRklFTERTLkFzc2lnbm1lbnRFeHByZXNzaW9uO1xuICB2YWxpZGF0ZShkZWZzLm9wZXJhdG9yLCBub2RlLCBcIm9wZXJhdG9yXCIsIG9wZXJhdG9yKTtcbiAgdmFsaWRhdGUoZGVmcy5sZWZ0LCBub2RlLCBcImxlZnRcIiwgbGVmdCwgMSk7XG4gIHZhbGlkYXRlKGRlZnMucmlnaHQsIG5vZGUsIFwicmlnaHRcIiwgcmlnaHQsIDEpO1xuICByZXR1cm4gbm9kZTtcbn1cbmZ1bmN0aW9uIGJpbmFyeUV4cHJlc3Npb24ob3BlcmF0b3IsIGxlZnQsIHJpZ2h0KSB7XG4gIGNvbnN0IG5vZGUgPSB7XG4gICAgdHlwZTogXCJCaW5hcnlFeHByZXNzaW9uXCIsXG4gICAgb3BlcmF0b3IsXG4gICAgbGVmdCxcbiAgICByaWdodFxuICB9O1xuICBjb25zdCBkZWZzID0gTk9ERV9GSUVMRFMuQmluYXJ5RXhwcmVzc2lvbjtcbiAgdmFsaWRhdGUoZGVmcy5vcGVyYXRvciwgbm9kZSwgXCJvcGVyYXRvclwiLCBvcGVyYXRvcik7XG4gIHZhbGlkYXRlKGRlZnMubGVmdCwgbm9kZSwgXCJsZWZ0XCIsIGxlZnQsIDEpO1xuICB2YWxpZGF0ZShkZWZzLnJpZ2h0LCBub2RlLCBcInJpZ2h0XCIsIHJpZ2h0LCAxKTtcbiAgcmV0dXJuIG5vZGU7XG59XG5mdW5jdGlvbiBpbnRlcnByZXRlckRpcmVjdGl2ZSh2YWx1ZSkge1xuICBjb25zdCBub2RlID0ge1xuICAgIHR5cGU6IFwiSW50ZXJwcmV0ZXJEaXJlY3RpdmVcIixcbiAgICB2YWx1ZVxuICB9O1xuICBjb25zdCBkZWZzID0gTk9ERV9GSUVMRFMuSW50ZXJwcmV0ZXJEaXJlY3RpdmU7XG4gIHZhbGlkYXRlKGRlZnMudmFsdWUsIG5vZGUsIFwidmFsdWVcIiwgdmFsdWUpO1xuICByZXR1cm4gbm9kZTtcbn1cbmZ1bmN0aW9uIGRpcmVjdGl2ZSh2YWx1ZSkge1xuICBjb25zdCBub2RlID0ge1xuICAgIHR5cGU6IFwiRGlyZWN0aXZlXCIsXG4gICAgdmFsdWVcbiAgfTtcbiAgY29uc3QgZGVmcyA9IE5PREVfRklFTERTLkRpcmVjdGl2ZTtcbiAgdmFsaWRhdGUoZGVmcy52YWx1ZSwgbm9kZSwgXCJ2YWx1ZVwiLCB2YWx1ZSwgMSk7XG4gIHJldHVybiBub2RlO1xufVxuZnVuY3Rpb24gZGlyZWN0aXZlTGl0ZXJhbCh2YWx1ZSkge1xuICBjb25zdCBub2RlID0ge1xuICAgIHR5cGU6IFwiRGlyZWN0aXZlTGl0ZXJhbFwiLFxuICAgIHZhbHVlXG4gIH07XG4gIGNvbnN0IGRlZnMgPSBOT0RFX0ZJRUxEUy5EaXJlY3RpdmVMaXRlcmFsO1xuICB2YWxpZGF0ZShkZWZzLnZhbHVlLCBub2RlLCBcInZhbHVlXCIsIHZhbHVlKTtcbiAgcmV0dXJuIG5vZGU7XG59XG5mdW5jdGlvbiBibG9ja1N0YXRlbWVudChib2R5LCBkaXJlY3RpdmVzID0gW10pIHtcbiAgY29uc3Qgbm9kZSA9IHtcbiAgICB0eXBlOiBcIkJsb2NrU3RhdGVtZW50XCIsXG4gICAgYm9keSxcbiAgICBkaXJlY3RpdmVzXG4gIH07XG4gIGNvbnN0IGRlZnMgPSBOT0RFX0ZJRUxEUy5CbG9ja1N0YXRlbWVudDtcbiAgdmFsaWRhdGUoZGVmcy5ib2R5LCBub2RlLCBcImJvZHlcIiwgYm9keSwgMSk7XG4gIHZhbGlkYXRlKGRlZnMuZGlyZWN0aXZlcywgbm9kZSwgXCJkaXJlY3RpdmVzXCIsIGRpcmVjdGl2ZXMsIDEpO1xuICByZXR1cm4gbm9kZTtcbn1cbmZ1bmN0aW9uIGJyZWFrU3RhdGVtZW50KGxhYmVsID0gbnVsbCkge1xuICBjb25zdCBub2RlID0ge1xuICAgIHR5cGU6IFwiQnJlYWtTdGF0ZW1lbnRcIixcbiAgICBsYWJlbFxuICB9O1xuICBjb25zdCBkZWZzID0gTk9ERV9GSUVMRFMuQnJlYWtTdGF0ZW1lbnQ7XG4gIHZhbGlkYXRlKGRlZnMubGFiZWwsIG5vZGUsIFwibGFiZWxcIiwgbGFiZWwsIDEpO1xuICByZXR1cm4gbm9kZTtcbn1cbmZ1bmN0aW9uIGNhbGxFeHByZXNzaW9uKGNhbGxlZSwgX2FyZ3VtZW50cykge1xuICBjb25zdCBub2RlID0ge1xuICAgIHR5cGU6IFwiQ2FsbEV4cHJlc3Npb25cIixcbiAgICBjYWxsZWUsXG4gICAgYXJndW1lbnRzOiBfYXJndW1lbnRzXG4gIH07XG4gIGNvbnN0IGRlZnMgPSBOT0RFX0ZJRUxEUy5DYWxsRXhwcmVzc2lvbjtcbiAgdmFsaWRhdGUoZGVmcy5jYWxsZWUsIG5vZGUsIFwiY2FsbGVlXCIsIGNhbGxlZSwgMSk7XG4gIHZhbGlkYXRlKGRlZnMuYXJndW1lbnRzLCBub2RlLCBcImFyZ3VtZW50c1wiLCBfYXJndW1lbnRzLCAxKTtcbiAgcmV0dXJuIG5vZGU7XG59XG5mdW5jdGlvbiBjYXRjaENsYXVzZShwYXJhbSA9IG51bGwsIGJvZHkpIHtcbiAgY29uc3Qgbm9kZSA9IHtcbiAgICB0eXBlOiBcIkNhdGNoQ2xhdXNlXCIsXG4gICAgcGFyYW0sXG4gICAgYm9keVxuICB9O1xuICBjb25zdCBkZWZzID0gTk9ERV9GSUVMRFMuQ2F0Y2hDbGF1c2U7XG4gIHZhbGlkYXRlKGRlZnMucGFyYW0sIG5vZGUsIFwicGFyYW1cIiwgcGFyYW0sIDEpO1xuICB2YWxpZGF0ZShkZWZzLmJvZHksIG5vZGUsIFwiYm9keVwiLCBib2R5LCAxKTtcbiAgcmV0dXJuIG5vZGU7XG59XG5mdW5jdGlvbiBjb25kaXRpb25hbEV4cHJlc3Npb24odGVzdCwgY29uc2VxdWVudCwgYWx0ZXJuYXRlKSB7XG4gIGNvbnN0IG5vZGUgPSB7XG4gICAgdHlwZTogXCJDb25kaXRpb25hbEV4cHJlc3Npb25cIixcbiAgICB0ZXN0LFxuICAgIGNvbnNlcXVlbnQsXG4gICAgYWx0ZXJuYXRlXG4gIH07XG4gIGNvbnN0IGRlZnMgPSBOT0RFX0ZJRUxEUy5Db25kaXRpb25hbEV4cHJlc3Npb247XG4gIHZhbGlkYXRlKGRlZnMudGVzdCwgbm9kZSwgXCJ0ZXN0XCIsIHRlc3QsIDEpO1xuICB2YWxpZGF0ZShkZWZzLmNvbnNlcXVlbnQsIG5vZGUsIFwiY29uc2VxdWVudFwiLCBjb25zZXF1ZW50LCAxKTtcbiAgdmFsaWRhdGUoZGVmcy5hbHRlcm5hdGUsIG5vZGUsIFwiYWx0ZXJuYXRlXCIsIGFsdGVybmF0ZSwgMSk7XG4gIHJldHVybiBub2RlO1xufVxuZnVuY3Rpb24gY29udGludWVTdGF0ZW1lbnQobGFiZWwgPSBudWxsKSB7XG4gIGNvbnN0IG5vZGUgPSB7XG4gICAgdHlwZTogXCJDb250aW51ZVN0YXRlbWVudFwiLFxuICAgIGxhYmVsXG4gIH07XG4gIGNvbnN0IGRlZnMgPSBOT0RFX0ZJRUxEUy5Db250aW51ZVN0YXRlbWVudDtcbiAgdmFsaWRhdGUoZGVmcy5sYWJlbCwgbm9kZSwgXCJsYWJlbFwiLCBsYWJlbCwgMSk7XG4gIHJldHVybiBub2RlO1xufVxuZnVuY3Rpb24gZGVidWdnZXJTdGF0ZW1lbnQoKSB7XG4gIHJldHVybiB7XG4gICAgdHlwZTogXCJEZWJ1Z2dlclN0YXRlbWVudFwiXG4gIH07XG59XG5mdW5jdGlvbiBkb1doaWxlU3RhdGVtZW50KHRlc3QsIGJvZHkpIHtcbiAgY29uc3Qgbm9kZSA9IHtcbiAgICB0eXBlOiBcIkRvV2hpbGVTdGF0ZW1lbnRcIixcbiAgICB0ZXN0LFxuICAgIGJvZHlcbiAgfTtcbiAgY29uc3QgZGVmcyA9IE5PREVfRklFTERTLkRvV2hpbGVTdGF0ZW1lbnQ7XG4gIHZhbGlkYXRlKGRlZnMudGVzdCwgbm9kZSwgXCJ0ZXN0XCIsIHRlc3QsIDEpO1xuICB2YWxpZGF0ZShkZWZzLmJvZHksIG5vZGUsIFwiYm9keVwiLCBib2R5LCAxKTtcbiAgcmV0dXJuIG5vZGU7XG59XG5mdW5jdGlvbiBlbXB0eVN0YXRlbWVudCgpIHtcbiAgcmV0dXJuIHtcbiAgICB0eXBlOiBcIkVtcHR5U3RhdGVtZW50XCJcbiAgfTtcbn1cbmZ1bmN0aW9uIGV4cHJlc3Npb25TdGF0ZW1lbnQoZXhwcmVzc2lvbikge1xuICBjb25zdCBub2RlID0ge1xuICAgIHR5cGU6IFwiRXhwcmVzc2lvblN0YXRlbWVudFwiLFxuICAgIGV4cHJlc3Npb25cbiAgfTtcbiAgY29uc3QgZGVmcyA9IE5PREVfRklFTERTLkV4cHJlc3Npb25TdGF0ZW1lbnQ7XG4gIHZhbGlkYXRlKGRlZnMuZXhwcmVzc2lvbiwgbm9kZSwgXCJleHByZXNzaW9uXCIsIGV4cHJlc3Npb24sIDEpO1xuICByZXR1cm4gbm9kZTtcbn1cbmZ1bmN0aW9uIGZpbGUocHJvZ3JhbSwgY29tbWVudHMgPSBudWxsLCB0b2tlbnMgPSBudWxsKSB7XG4gIGNvbnN0IG5vZGUgPSB7XG4gICAgdHlwZTogXCJGaWxlXCIsXG4gICAgcHJvZ3JhbSxcbiAgICBjb21tZW50cyxcbiAgICB0b2tlbnNcbiAgfTtcbiAgY29uc3QgZGVmcyA9IE5PREVfRklFTERTLkZpbGU7XG4gIHZhbGlkYXRlKGRlZnMucHJvZ3JhbSwgbm9kZSwgXCJwcm9ncmFtXCIsIHByb2dyYW0sIDEpO1xuICB2YWxpZGF0ZShkZWZzLmNvbW1lbnRzLCBub2RlLCBcImNvbW1lbnRzXCIsIGNvbW1lbnRzLCAxKTtcbiAgdmFsaWRhdGUoZGVmcy50b2tlbnMsIG5vZGUsIFwidG9rZW5zXCIsIHRva2Vucyk7XG4gIHJldHVybiBub2RlO1xufVxuZnVuY3Rpb24gZm9ySW5TdGF0ZW1lbnQobGVmdCwgcmlnaHQsIGJvZHkpIHtcbiAgY29uc3Qgbm9kZSA9IHtcbiAgICB0eXBlOiBcIkZvckluU3RhdGVtZW50XCIsXG4gICAgbGVmdCxcbiAgICByaWdodCxcbiAgICBib2R5XG4gIH07XG4gIGNvbnN0IGRlZnMgPSBOT0RFX0ZJRUxEUy5Gb3JJblN0YXRlbWVudDtcbiAgdmFsaWRhdGUoZGVmcy5sZWZ0LCBub2RlLCBcImxlZnRcIiwgbGVmdCwgMSk7XG4gIHZhbGlkYXRlKGRlZnMucmlnaHQsIG5vZGUsIFwicmlnaHRcIiwgcmlnaHQsIDEpO1xuICB2YWxpZGF0ZShkZWZzLmJvZHksIG5vZGUsIFwiYm9keVwiLCBib2R5LCAxKTtcbiAgcmV0dXJuIG5vZGU7XG59XG5mdW5jdGlvbiBmb3JTdGF0ZW1lbnQoaW5pdCA9IG51bGwsIHRlc3QgPSBudWxsLCB1cGRhdGUgPSBudWxsLCBib2R5KSB7XG4gIGNvbnN0IG5vZGUgPSB7XG4gICAgdHlwZTogXCJGb3JTdGF0ZW1lbnRcIixcbiAgICBpbml0LFxuICAgIHRlc3QsXG4gICAgdXBkYXRlLFxuICAgIGJvZHlcbiAgfTtcbiAgY29uc3QgZGVmcyA9IE5PREVfRklFTERTLkZvclN0YXRlbWVudDtcbiAgdmFsaWRhdGUoZGVmcy5pbml0LCBub2RlLCBcImluaXRcIiwgaW5pdCwgMSk7XG4gIHZhbGlkYXRlKGRlZnMudGVzdCwgbm9kZSwgXCJ0ZXN0XCIsIHRlc3QsIDEpO1xuICB2YWxpZGF0ZShkZWZzLnVwZGF0ZSwgbm9kZSwgXCJ1cGRhdGVcIiwgdXBkYXRlLCAxKTtcbiAgdmFsaWRhdGUoZGVmcy5ib2R5LCBub2RlLCBcImJvZHlcIiwgYm9keSwgMSk7XG4gIHJldHVybiBub2RlO1xufVxuZnVuY3Rpb24gZnVuY3Rpb25EZWNsYXJhdGlvbihpZCA9IG51bGwsIHBhcmFtcywgYm9keSwgZ2VuZXJhdG9yID0gZmFsc2UsIGFzeW5jID0gZmFsc2UpIHtcbiAgY29uc3Qgbm9kZSA9IHtcbiAgICB0eXBlOiBcIkZ1bmN0aW9uRGVjbGFyYXRpb25cIixcbiAgICBpZCxcbiAgICBwYXJhbXMsXG4gICAgYm9keSxcbiAgICBnZW5lcmF0b3IsXG4gICAgYXN5bmNcbiAgfTtcbiAgY29uc3QgZGVmcyA9IE5PREVfRklFTERTLkZ1bmN0aW9uRGVjbGFyYXRpb247XG4gIHZhbGlkYXRlKGRlZnMuaWQsIG5vZGUsIFwiaWRcIiwgaWQsIDEpO1xuICB2YWxpZGF0ZShkZWZzLnBhcmFtcywgbm9kZSwgXCJwYXJhbXNcIiwgcGFyYW1zLCAxKTtcbiAgdmFsaWRhdGUoZGVmcy5ib2R5LCBub2RlLCBcImJvZHlcIiwgYm9keSwgMSk7XG4gIHZhbGlkYXRlKGRlZnMuZ2VuZXJhdG9yLCBub2RlLCBcImdlbmVyYXRvclwiLCBnZW5lcmF0b3IpO1xuICB2YWxpZGF0ZShkZWZzLmFzeW5jLCBub2RlLCBcImFzeW5jXCIsIGFzeW5jKTtcbiAgcmV0dXJuIG5vZGU7XG59XG5mdW5jdGlvbiBmdW5jdGlvbkV4cHJlc3Npb24oaWQgPSBudWxsLCBwYXJhbXMsIGJvZHksIGdlbmVyYXRvciA9IGZhbHNlLCBhc3luYyA9IGZhbHNlKSB7XG4gIGNvbnN0IG5vZGUgPSB7XG4gICAgdHlwZTogXCJGdW5jdGlvbkV4cHJlc3Npb25cIixcbiAgICBpZCxcbiAgICBwYXJhbXMsXG4gICAgYm9keSxcbiAgICBnZW5lcmF0b3IsXG4gICAgYXN5bmNcbiAgfTtcbiAgY29uc3QgZGVmcyA9IE5PREVfRklFTERTLkZ1bmN0aW9uRXhwcmVzc2lvbjtcbiAgdmFsaWRhdGUoZGVmcy5pZCwgbm9kZSwgXCJpZFwiLCBpZCwgMSk7XG4gIHZhbGlkYXRlKGRlZnMucGFyYW1zLCBub2RlLCBcInBhcmFtc1wiLCBwYXJhbXMsIDEpO1xuICB2YWxpZGF0ZShkZWZzLmJvZHksIG5vZGUsIFwiYm9keVwiLCBib2R5LCAxKTtcbiAgdmFsaWRhdGUoZGVmcy5nZW5lcmF0b3IsIG5vZGUsIFwiZ2VuZXJhdG9yXCIsIGdlbmVyYXRvcik7XG4gIHZhbGlkYXRlKGRlZnMuYXN5bmMsIG5vZGUsIFwiYXN5bmNcIiwgYXN5bmMpO1xuICByZXR1cm4gbm9kZTtcbn1cbmZ1bmN0aW9uIGlkZW50aWZpZXIobmFtZSkge1xuICBjb25zdCBub2RlID0ge1xuICAgIHR5cGU6IFwiSWRlbnRpZmllclwiLFxuICAgIG5hbWVcbiAgfTtcbiAgY29uc3QgZGVmcyA9IE5PREVfRklFTERTLklkZW50aWZpZXI7XG4gIHZhbGlkYXRlKGRlZnMubmFtZSwgbm9kZSwgXCJuYW1lXCIsIG5hbWUpO1xuICByZXR1cm4gbm9kZTtcbn1cbmZ1bmN0aW9uIGlmU3RhdGVtZW50KHRlc3QsIGNvbnNlcXVlbnQsIGFsdGVybmF0ZSA9IG51bGwpIHtcbiAgY29uc3Qgbm9kZSA9IHtcbiAgICB0eXBlOiBcIklmU3RhdGVtZW50XCIsXG4gICAgdGVzdCxcbiAgICBjb25zZXF1ZW50LFxuICAgIGFsdGVybmF0ZVxuICB9O1xuICBjb25zdCBkZWZzID0gTk9ERV9GSUVMRFMuSWZTdGF0ZW1lbnQ7XG4gIHZhbGlkYXRlKGRlZnMudGVzdCwgbm9kZSwgXCJ0ZXN0XCIsIHRlc3QsIDEpO1xuICB2YWxpZGF0ZShkZWZzLmNvbnNlcXVlbnQsIG5vZGUsIFwiY29uc2VxdWVudFwiLCBjb25zZXF1ZW50LCAxKTtcbiAgdmFsaWRhdGUoZGVmcy5hbHRlcm5hdGUsIG5vZGUsIFwiYWx0ZXJuYXRlXCIsIGFsdGVybmF0ZSwgMSk7XG4gIHJldHVybiBub2RlO1xufVxuZnVuY3Rpb24gbGFiZWxlZFN0YXRlbWVudChsYWJlbCwgYm9keSkge1xuICBjb25zdCBub2RlID0ge1xuICAgIHR5cGU6IFwiTGFiZWxlZFN0YXRlbWVudFwiLFxuICAgIGxhYmVsLFxuICAgIGJvZHlcbiAgfTtcbiAgY29uc3QgZGVmcyA9IE5PREVfRklFTERTLkxhYmVsZWRTdGF0ZW1lbnQ7XG4gIHZhbGlkYXRlKGRlZnMubGFiZWwsIG5vZGUsIFwibGFiZWxcIiwgbGFiZWwsIDEpO1xuICB2YWxpZGF0ZShkZWZzLmJvZHksIG5vZGUsIFwiYm9keVwiLCBib2R5LCAxKTtcbiAgcmV0dXJuIG5vZGU7XG59XG5mdW5jdGlvbiBzdHJpbmdMaXRlcmFsKHZhbHVlKSB7XG4gIGNvbnN0IG5vZGUgPSB7XG4gICAgdHlwZTogXCJTdHJpbmdMaXRlcmFsXCIsXG4gICAgdmFsdWVcbiAgfTtcbiAgY29uc3QgZGVmcyA9IE5PREVfRklFTERTLlN0cmluZ0xpdGVyYWw7XG4gIHZhbGlkYXRlKGRlZnMudmFsdWUsIG5vZGUsIFwidmFsdWVcIiwgdmFsdWUpO1xuICByZXR1cm4gbm9kZTtcbn1cbmZ1bmN0aW9uIG51bWVyaWNMaXRlcmFsKHZhbHVlKSB7XG4gIGNvbnN0IG5vZGUgPSB7XG4gICAgdHlwZTogXCJOdW1lcmljTGl0ZXJhbFwiLFxuICAgIHZhbHVlXG4gIH07XG4gIGNvbnN0IGRlZnMgPSBOT0RFX0ZJRUxEUy5OdW1lcmljTGl0ZXJhbDtcbiAgdmFsaWRhdGUoZGVmcy52YWx1ZSwgbm9kZSwgXCJ2YWx1ZVwiLCB2YWx1ZSk7XG4gIHJldHVybiBub2RlO1xufVxuZnVuY3Rpb24gbnVsbExpdGVyYWwoKSB7XG4gIHJldHVybiB7XG4gICAgdHlwZTogXCJOdWxsTGl0ZXJhbFwiXG4gIH07XG59XG5mdW5jdGlvbiBib29sZWFuTGl0ZXJhbCh2YWx1ZSkge1xuICBjb25zdCBub2RlID0ge1xuICAgIHR5cGU6IFwiQm9vbGVhbkxpdGVyYWxcIixcbiAgICB2YWx1ZVxuICB9O1xuICBjb25zdCBkZWZzID0gTk9ERV9GSUVMRFMuQm9vbGVhbkxpdGVyYWw7XG4gIHZhbGlkYXRlKGRlZnMudmFsdWUsIG5vZGUsIFwidmFsdWVcIiwgdmFsdWUpO1xuICByZXR1cm4gbm9kZTtcbn1cbmZ1bmN0aW9uIHJlZ0V4cExpdGVyYWwocGF0dGVybiwgZmxhZ3MgPSBcIlwiKSB7XG4gIGNvbnN0IG5vZGUgPSB7XG4gICAgdHlwZTogXCJSZWdFeHBMaXRlcmFsXCIsXG4gICAgcGF0dGVybixcbiAgICBmbGFnc1xuICB9O1xuICBjb25zdCBkZWZzID0gTk9ERV9GSUVMRFMuUmVnRXhwTGl0ZXJhbDtcbiAgdmFsaWRhdGUoZGVmcy5wYXR0ZXJuLCBub2RlLCBcInBhdHRlcm5cIiwgcGF0dGVybik7XG4gIHZhbGlkYXRlKGRlZnMuZmxhZ3MsIG5vZGUsIFwiZmxhZ3NcIiwgZmxhZ3MpO1xuICByZXR1cm4gbm9kZTtcbn1cbmZ1bmN0aW9uIGxvZ2ljYWxFeHByZXNzaW9uKG9wZXJhdG9yLCBsZWZ0LCByaWdodCkge1xuICBjb25zdCBub2RlID0ge1xuICAgIHR5cGU6IFwiTG9naWNhbEV4cHJlc3Npb25cIixcbiAgICBvcGVyYXRvcixcbiAgICBsZWZ0LFxuICAgIHJpZ2h0XG4gIH07XG4gIGNvbnN0IGRlZnMgPSBOT0RFX0ZJRUxEUy5Mb2dpY2FsRXhwcmVzc2lvbjtcbiAgdmFsaWRhdGUoZGVmcy5vcGVyYXRvciwgbm9kZSwgXCJvcGVyYXRvclwiLCBvcGVyYXRvcik7XG4gIHZhbGlkYXRlKGRlZnMubGVmdCwgbm9kZSwgXCJsZWZ0XCIsIGxlZnQsIDEpO1xuICB2YWxpZGF0ZShkZWZzLnJpZ2h0LCBub2RlLCBcInJpZ2h0XCIsIHJpZ2h0LCAxKTtcbiAgcmV0dXJuIG5vZGU7XG59XG5mdW5jdGlvbiBtZW1iZXJFeHByZXNzaW9uKG9iamVjdCwgcHJvcGVydHksIGNvbXB1dGVkID0gZmFsc2UsIG9wdGlvbmFsID0gbnVsbCkge1xuICBjb25zdCBub2RlID0ge1xuICAgIHR5cGU6IFwiTWVtYmVyRXhwcmVzc2lvblwiLFxuICAgIG9iamVjdCxcbiAgICBwcm9wZXJ0eSxcbiAgICBjb21wdXRlZCxcbiAgICBvcHRpb25hbFxuICB9O1xuICBjb25zdCBkZWZzID0gTk9ERV9GSUVMRFMuTWVtYmVyRXhwcmVzc2lvbjtcbiAgdmFsaWRhdGUoZGVmcy5vYmplY3QsIG5vZGUsIFwib2JqZWN0XCIsIG9iamVjdCwgMSk7XG4gIHZhbGlkYXRlKGRlZnMucHJvcGVydHksIG5vZGUsIFwicHJvcGVydHlcIiwgcHJvcGVydHksIDEpO1xuICB2YWxpZGF0ZShkZWZzLmNvbXB1dGVkLCBub2RlLCBcImNvbXB1dGVkXCIsIGNvbXB1dGVkKTtcbiAgdmFsaWRhdGUoZGVmcy5vcHRpb25hbCwgbm9kZSwgXCJvcHRpb25hbFwiLCBvcHRpb25hbCk7XG4gIHJldHVybiBub2RlO1xufVxuZnVuY3Rpb24gbmV3RXhwcmVzc2lvbihjYWxsZWUsIF9hcmd1bWVudHMpIHtcbiAgY29uc3Qgbm9kZSA9IHtcbiAgICB0eXBlOiBcIk5ld0V4cHJlc3Npb25cIixcbiAgICBjYWxsZWUsXG4gICAgYXJndW1lbnRzOiBfYXJndW1lbnRzXG4gIH07XG4gIGNvbnN0IGRlZnMgPSBOT0RFX0ZJRUxEUy5OZXdFeHByZXNzaW9uO1xuICB2YWxpZGF0ZShkZWZzLmNhbGxlZSwgbm9kZSwgXCJjYWxsZWVcIiwgY2FsbGVlLCAxKTtcbiAgdmFsaWRhdGUoZGVmcy5hcmd1bWVudHMsIG5vZGUsIFwiYXJndW1lbnRzXCIsIF9hcmd1bWVudHMsIDEpO1xuICByZXR1cm4gbm9kZTtcbn1cbmZ1bmN0aW9uIHByb2dyYW0oYm9keSwgZGlyZWN0aXZlcyA9IFtdLCBzb3VyY2VUeXBlID0gXCJzY3JpcHRcIiwgaW50ZXJwcmV0ZXIgPSBudWxsKSB7XG4gIGNvbnN0IG5vZGUgPSB7XG4gICAgdHlwZTogXCJQcm9ncmFtXCIsXG4gICAgYm9keSxcbiAgICBkaXJlY3RpdmVzLFxuICAgIHNvdXJjZVR5cGUsXG4gICAgaW50ZXJwcmV0ZXJcbiAgfTtcbiAgY29uc3QgZGVmcyA9IE5PREVfRklFTERTLlByb2dyYW07XG4gIHZhbGlkYXRlKGRlZnMuYm9keSwgbm9kZSwgXCJib2R5XCIsIGJvZHksIDEpO1xuICB2YWxpZGF0ZShkZWZzLmRpcmVjdGl2ZXMsIG5vZGUsIFwiZGlyZWN0aXZlc1wiLCBkaXJlY3RpdmVzLCAxKTtcbiAgdmFsaWRhdGUoZGVmcy5zb3VyY2VUeXBlLCBub2RlLCBcInNvdXJjZVR5cGVcIiwgc291cmNlVHlwZSk7XG4gIHZhbGlkYXRlKGRlZnMuaW50ZXJwcmV0ZXIsIG5vZGUsIFwiaW50ZXJwcmV0ZXJcIiwgaW50ZXJwcmV0ZXIsIDEpO1xuICByZXR1cm4gbm9kZTtcbn1cbmZ1bmN0aW9uIG9iamVjdEV4cHJlc3Npb24ocHJvcGVydGllcykge1xuICBjb25zdCBub2RlID0ge1xuICAgIHR5cGU6IFwiT2JqZWN0RXhwcmVzc2lvblwiLFxuICAgIHByb3BlcnRpZXNcbiAgfTtcbiAgY29uc3QgZGVmcyA9IE5PREVfRklFTERTLk9iamVjdEV4cHJlc3Npb247XG4gIHZhbGlkYXRlKGRlZnMucHJvcGVydGllcywgbm9kZSwgXCJwcm9wZXJ0aWVzXCIsIHByb3BlcnRpZXMsIDEpO1xuICByZXR1cm4gbm9kZTtcbn1cbmZ1bmN0aW9uIG9iamVjdE1ldGhvZChraW5kID0gXCJtZXRob2RcIiwga2V5LCBwYXJhbXMsIGJvZHksIGNvbXB1dGVkID0gZmFsc2UsIGdlbmVyYXRvciA9IGZhbHNlLCBhc3luYyA9IGZhbHNlKSB7XG4gIGNvbnN0IG5vZGUgPSB7XG4gICAgdHlwZTogXCJPYmplY3RNZXRob2RcIixcbiAgICBraW5kLFxuICAgIGtleSxcbiAgICBwYXJhbXMsXG4gICAgYm9keSxcbiAgICBjb21wdXRlZCxcbiAgICBnZW5lcmF0b3IsXG4gICAgYXN5bmNcbiAgfTtcbiAgY29uc3QgZGVmcyA9IE5PREVfRklFTERTLk9iamVjdE1ldGhvZDtcbiAgdmFsaWRhdGUoZGVmcy5raW5kLCBub2RlLCBcImtpbmRcIiwga2luZCk7XG4gIHZhbGlkYXRlKGRlZnMua2V5LCBub2RlLCBcImtleVwiLCBrZXksIDEpO1xuICB2YWxpZGF0ZShkZWZzLnBhcmFtcywgbm9kZSwgXCJwYXJhbXNcIiwgcGFyYW1zLCAxKTtcbiAgdmFsaWRhdGUoZGVmcy5ib2R5LCBub2RlLCBcImJvZHlcIiwgYm9keSwgMSk7XG4gIHZhbGlkYXRlKGRlZnMuY29tcHV0ZWQsIG5vZGUsIFwiY29tcHV0ZWRcIiwgY29tcHV0ZWQpO1xuICB2YWxpZGF0ZShkZWZzLmdlbmVyYXRvciwgbm9kZSwgXCJnZW5lcmF0b3JcIiwgZ2VuZXJhdG9yKTtcbiAgdmFsaWRhdGUoZGVmcy5hc3luYywgbm9kZSwgXCJhc3luY1wiLCBhc3luYyk7XG4gIHJldHVybiBub2RlO1xufVxuZnVuY3Rpb24gb2JqZWN0UHJvcGVydHkoa2V5LCB2YWx1ZSwgY29tcHV0ZWQgPSBmYWxzZSwgc2hvcnRoYW5kID0gZmFsc2UsIGRlY29yYXRvcnMgPSBudWxsKSB7XG4gIGNvbnN0IG5vZGUgPSB7XG4gICAgdHlwZTogXCJPYmplY3RQcm9wZXJ0eVwiLFxuICAgIGtleSxcbiAgICB2YWx1ZSxcbiAgICBjb21wdXRlZCxcbiAgICBzaG9ydGhhbmQsXG4gICAgZGVjb3JhdG9yc1xuICB9O1xuICBjb25zdCBkZWZzID0gTk9ERV9GSUVMRFMuT2JqZWN0UHJvcGVydHk7XG4gIHZhbGlkYXRlKGRlZnMua2V5LCBub2RlLCBcImtleVwiLCBrZXksIDEpO1xuICB2YWxpZGF0ZShkZWZzLnZhbHVlLCBub2RlLCBcInZhbHVlXCIsIHZhbHVlLCAxKTtcbiAgdmFsaWRhdGUoZGVmcy5jb21wdXRlZCwgbm9kZSwgXCJjb21wdXRlZFwiLCBjb21wdXRlZCk7XG4gIHZhbGlkYXRlKGRlZnMuc2hvcnRoYW5kLCBub2RlLCBcInNob3J0aGFuZFwiLCBzaG9ydGhhbmQpO1xuICB2YWxpZGF0ZShkZWZzLmRlY29yYXRvcnMsIG5vZGUsIFwiZGVjb3JhdG9yc1wiLCBkZWNvcmF0b3JzLCAxKTtcbiAgcmV0dXJuIG5vZGU7XG59XG5mdW5jdGlvbiByZXN0RWxlbWVudChhcmd1bWVudCkge1xuICBjb25zdCBub2RlID0ge1xuICAgIHR5cGU6IFwiUmVzdEVsZW1lbnRcIixcbiAgICBhcmd1bWVudFxuICB9O1xuICBjb25zdCBkZWZzID0gTk9ERV9GSUVMRFMuUmVzdEVsZW1lbnQ7XG4gIHZhbGlkYXRlKGRlZnMuYXJndW1lbnQsIG5vZGUsIFwiYXJndW1lbnRcIiwgYXJndW1lbnQsIDEpO1xuICByZXR1cm4gbm9kZTtcbn1cbmZ1bmN0aW9uIHJldHVyblN0YXRlbWVudChhcmd1bWVudCA9IG51bGwpIHtcbiAgY29uc3Qgbm9kZSA9IHtcbiAgICB0eXBlOiBcIlJldHVyblN0YXRlbWVudFwiLFxuICAgIGFyZ3VtZW50XG4gIH07XG4gIGNvbnN0IGRlZnMgPSBOT0RFX0ZJRUxEUy5SZXR1cm5TdGF0ZW1lbnQ7XG4gIHZhbGlkYXRlKGRlZnMuYXJndW1lbnQsIG5vZGUsIFwiYXJndW1lbnRcIiwgYXJndW1lbnQsIDEpO1xuICByZXR1cm4gbm9kZTtcbn1cbmZ1bmN0aW9uIHNlcXVlbmNlRXhwcmVzc2lvbihleHByZXNzaW9ucykge1xuICBjb25zdCBub2RlID0ge1xuICAgIHR5cGU6IFwiU2VxdWVuY2VFeHByZXNzaW9uXCIsXG4gICAgZXhwcmVzc2lvbnNcbiAgfTtcbiAgY29uc3QgZGVmcyA9IE5PREVfRklFTERTLlNlcXVlbmNlRXhwcmVzc2lvbjtcbiAgdmFsaWRhdGUoZGVmcy5leHByZXNzaW9ucywgbm9kZSwgXCJleHByZXNzaW9uc1wiLCBleHByZXNzaW9ucywgMSk7XG4gIHJldHVybiBub2RlO1xufVxuZnVuY3Rpb24gcGFyZW50aGVzaXplZEV4cHJlc3Npb24oZXhwcmVzc2lvbikge1xuICBjb25zdCBub2RlID0ge1xuICAgIHR5cGU6IFwiUGFyZW50aGVzaXplZEV4cHJlc3Npb25cIixcbiAgICBleHByZXNzaW9uXG4gIH07XG4gIGNvbnN0IGRlZnMgPSBOT0RFX0ZJRUxEUy5QYXJlbnRoZXNpemVkRXhwcmVzc2lvbjtcbiAgdmFsaWRhdGUoZGVmcy5leHByZXNzaW9uLCBub2RlLCBcImV4cHJlc3Npb25cIiwgZXhwcmVzc2lvbiwgMSk7XG4gIHJldHVybiBub2RlO1xufVxuZnVuY3Rpb24gc3dpdGNoQ2FzZSh0ZXN0ID0gbnVsbCwgY29uc2VxdWVudCkge1xuICBjb25zdCBub2RlID0ge1xuICAgIHR5cGU6IFwiU3dpdGNoQ2FzZVwiLFxuICAgIHRlc3QsXG4gICAgY29uc2VxdWVudFxuICB9O1xuICBjb25zdCBkZWZzID0gTk9ERV9GSUVMRFMuU3dpdGNoQ2FzZTtcbiAgdmFsaWRhdGUoZGVmcy50ZXN0LCBub2RlLCBcInRlc3RcIiwgdGVzdCwgMSk7XG4gIHZhbGlkYXRlKGRlZnMuY29uc2VxdWVudCwgbm9kZSwgXCJjb25zZXF1ZW50XCIsIGNvbnNlcXVlbnQsIDEpO1xuICByZXR1cm4gbm9kZTtcbn1cbmZ1bmN0aW9uIHN3aXRjaFN0YXRlbWVudChkaXNjcmltaW5hbnQsIGNhc2VzKSB7XG4gIGNvbnN0IG5vZGUgPSB7XG4gICAgdHlwZTogXCJTd2l0Y2hTdGF0ZW1lbnRcIixcbiAgICBkaXNjcmltaW5hbnQsXG4gICAgY2FzZXNcbiAgfTtcbiAgY29uc3QgZGVmcyA9IE5PREVfRklFTERTLlN3aXRjaFN0YXRlbWVudDtcbiAgdmFsaWRhdGUoZGVmcy5kaXNjcmltaW5hbnQsIG5vZGUsIFwiZGlzY3JpbWluYW50XCIsIGRpc2NyaW1pbmFudCwgMSk7XG4gIHZhbGlkYXRlKGRlZnMuY2FzZXMsIG5vZGUsIFwiY2FzZXNcIiwgY2FzZXMsIDEpO1xuICByZXR1cm4gbm9kZTtcbn1cbmZ1bmN0aW9uIHRoaXNFeHByZXNzaW9uKCkge1xuICByZXR1cm4ge1xuICAgIHR5cGU6IFwiVGhpc0V4cHJlc3Npb25cIlxuICB9O1xufVxuZnVuY3Rpb24gdGhyb3dTdGF0ZW1lbnQoYXJndW1lbnQpIHtcbiAgY29uc3Qgbm9kZSA9IHtcbiAgICB0eXBlOiBcIlRocm93U3RhdGVtZW50XCIsXG4gICAgYXJndW1lbnRcbiAgfTtcbiAgY29uc3QgZGVmcyA9IE5PREVfRklFTERTLlRocm93U3RhdGVtZW50O1xuICB2YWxpZGF0ZShkZWZzLmFyZ3VtZW50LCBub2RlLCBcImFyZ3VtZW50XCIsIGFyZ3VtZW50LCAxKTtcbiAgcmV0dXJuIG5vZGU7XG59XG5mdW5jdGlvbiB0cnlTdGF0ZW1lbnQoYmxvY2ssIGhhbmRsZXIgPSBudWxsLCBmaW5hbGl6ZXIgPSBudWxsKSB7XG4gIGNvbnN0IG5vZGUgPSB7XG4gICAgdHlwZTogXCJUcnlTdGF0ZW1lbnRcIixcbiAgICBibG9jayxcbiAgICBoYW5kbGVyLFxuICAgIGZpbmFsaXplclxuICB9O1xuICBjb25zdCBkZWZzID0gTk9ERV9GSUVMRFMuVHJ5U3RhdGVtZW50O1xuICB2YWxpZGF0ZShkZWZzLmJsb2NrLCBub2RlLCBcImJsb2NrXCIsIGJsb2NrLCAxKTtcbiAgdmFsaWRhdGUoZGVmcy5oYW5kbGVyLCBub2RlLCBcImhhbmRsZXJcIiwgaGFuZGxlciwgMSk7XG4gIHZhbGlkYXRlKGRlZnMuZmluYWxpemVyLCBub2RlLCBcImZpbmFsaXplclwiLCBmaW5hbGl6ZXIsIDEpO1xuICByZXR1cm4gbm9kZTtcbn1cbmZ1bmN0aW9uIHVuYXJ5RXhwcmVzc2lvbihvcGVyYXRvciwgYXJndW1lbnQsIHByZWZpeCA9IHRydWUpIHtcbiAgY29uc3Qgbm9kZSA9IHtcbiAgICB0eXBlOiBcIlVuYXJ5RXhwcmVzc2lvblwiLFxuICAgIG9wZXJhdG9yLFxuICAgIGFyZ3VtZW50LFxuICAgIHByZWZpeFxuICB9O1xuICBjb25zdCBkZWZzID0gTk9ERV9GSUVMRFMuVW5hcnlFeHByZXNzaW9uO1xuICB2YWxpZGF0ZShkZWZzLm9wZXJhdG9yLCBub2RlLCBcIm9wZXJhdG9yXCIsIG9wZXJhdG9yKTtcbiAgdmFsaWRhdGUoZGVmcy5hcmd1bWVudCwgbm9kZSwgXCJhcmd1bWVudFwiLCBhcmd1bWVudCwgMSk7XG4gIHZhbGlkYXRlKGRlZnMucHJlZml4LCBub2RlLCBcInByZWZpeFwiLCBwcmVmaXgpO1xuICByZXR1cm4gbm9kZTtcbn1cbmZ1bmN0aW9uIHVwZGF0ZUV4cHJlc3Npb24ob3BlcmF0b3IsIGFyZ3VtZW50LCBwcmVmaXggPSBmYWxzZSkge1xuICBjb25zdCBub2RlID0ge1xuICAgIHR5cGU6IFwiVXBkYXRlRXhwcmVzc2lvblwiLFxuICAgIG9wZXJhdG9yLFxuICAgIGFyZ3VtZW50LFxuICAgIHByZWZpeFxuICB9O1xuICBjb25zdCBkZWZzID0gTk9ERV9GSUVMRFMuVXBkYXRlRXhwcmVzc2lvbjtcbiAgdmFsaWRhdGUoZGVmcy5vcGVyYXRvciwgbm9kZSwgXCJvcGVyYXRvclwiLCBvcGVyYXRvcik7XG4gIHZhbGlkYXRlKGRlZnMuYXJndW1lbnQsIG5vZGUsIFwiYXJndW1lbnRcIiwgYXJndW1lbnQsIDEpO1xuICB2YWxpZGF0ZShkZWZzLnByZWZpeCwgbm9kZSwgXCJwcmVmaXhcIiwgcHJlZml4KTtcbiAgcmV0dXJuIG5vZGU7XG59XG5mdW5jdGlvbiB2YXJpYWJsZURlY2xhcmF0aW9uKGtpbmQsIGRlY2xhcmF0aW9ucykge1xuICBjb25zdCBub2RlID0ge1xuICAgIHR5cGU6IFwiVmFyaWFibGVEZWNsYXJhdGlvblwiLFxuICAgIGtpbmQsXG4gICAgZGVjbGFyYXRpb25zXG4gIH07XG4gIGNvbnN0IGRlZnMgPSBOT0RFX0ZJRUxEUy5WYXJpYWJsZURlY2xhcmF0aW9uO1xuICB2YWxpZGF0ZShkZWZzLmtpbmQsIG5vZGUsIFwia2luZFwiLCBraW5kKTtcbiAgdmFsaWRhdGUoZGVmcy5kZWNsYXJhdGlvbnMsIG5vZGUsIFwiZGVjbGFyYXRpb25zXCIsIGRlY2xhcmF0aW9ucywgMSk7XG4gIHJldHVybiBub2RlO1xufVxuZnVuY3Rpb24gdmFyaWFibGVEZWNsYXJhdG9yKGlkLCBpbml0ID0gbnVsbCkge1xuICBjb25zdCBub2RlID0ge1xuICAgIHR5cGU6IFwiVmFyaWFibGVEZWNsYXJhdG9yXCIsXG4gICAgaWQsXG4gICAgaW5pdFxuICB9O1xuICBjb25zdCBkZWZzID0gTk9ERV9GSUVMRFMuVmFyaWFibGVEZWNsYXJhdG9yO1xuICB2YWxpZGF0ZShkZWZzLmlkLCBub2RlLCBcImlkXCIsIGlkLCAxKTtcbiAgdmFsaWRhdGUoZGVmcy5pbml0LCBub2RlLCBcImluaXRcIiwgaW5pdCwgMSk7XG4gIHJldHVybiBub2RlO1xufVxuZnVuY3Rpb24gd2hpbGVTdGF0ZW1lbnQodGVzdCwgYm9keSkge1xuICBjb25zdCBub2RlID0ge1xuICAgIHR5cGU6IFwiV2hpbGVTdGF0ZW1lbnRcIixcbiAgICB0ZXN0LFxuICAgIGJvZHlcbiAgfTtcbiAgY29uc3QgZGVmcyA9IE5PREVfRklFTERTLldoaWxlU3RhdGVtZW50O1xuICB2YWxpZGF0ZShkZWZzLnRlc3QsIG5vZGUsIFwidGVzdFwiLCB0ZXN0LCAxKTtcbiAgdmFsaWRhdGUoZGVmcy5ib2R5LCBub2RlLCBcImJvZHlcIiwgYm9keSwgMSk7XG4gIHJldHVybiBub2RlO1xufVxuZnVuY3Rpb24gd2l0aFN0YXRlbWVudChvYmplY3QsIGJvZHkpIHtcbiAgY29uc3Qgbm9kZSA9IHtcbiAgICB0eXBlOiBcIldpdGhTdGF0ZW1lbnRcIixcbiAgICBvYmplY3QsXG4gICAgYm9keVxuICB9O1xuICBjb25zdCBkZWZzID0gTk9ERV9GSUVMRFMuV2l0aFN0YXRlbWVudDtcbiAgdmFsaWRhdGUoZGVmcy5vYmplY3QsIG5vZGUsIFwib2JqZWN0XCIsIG9iamVjdCwgMSk7XG4gIHZhbGlkYXRlKGRlZnMuYm9keSwgbm9kZSwgXCJib2R5XCIsIGJvZHksIDEpO1xuICByZXR1cm4gbm9kZTtcbn1cbmZ1bmN0aW9uIGFzc2lnbm1lbnRQYXR0ZXJuKGxlZnQsIHJpZ2h0KSB7XG4gIGNvbnN0IG5vZGUgPSB7XG4gICAgdHlwZTogXCJBc3NpZ25tZW50UGF0dGVyblwiLFxuICAgIGxlZnQsXG4gICAgcmlnaHRcbiAgfTtcbiAgY29uc3QgZGVmcyA9IE5PREVfRklFTERTLkFzc2lnbm1lbnRQYXR0ZXJuO1xuICB2YWxpZGF0ZShkZWZzLmxlZnQsIG5vZGUsIFwibGVmdFwiLCBsZWZ0LCAxKTtcbiAgdmFsaWRhdGUoZGVmcy5yaWdodCwgbm9kZSwgXCJyaWdodFwiLCByaWdodCwgMSk7XG4gIHJldHVybiBub2RlO1xufVxuZnVuY3Rpb24gYXJyYXlQYXR0ZXJuKGVsZW1lbnRzKSB7XG4gIGNvbnN0IG5vZGUgPSB7XG4gICAgdHlwZTogXCJBcnJheVBhdHRlcm5cIixcbiAgICBlbGVtZW50c1xuICB9O1xuICBjb25zdCBkZWZzID0gTk9ERV9GSUVMRFMuQXJyYXlQYXR0ZXJuO1xuICB2YWxpZGF0ZShkZWZzLmVsZW1lbnRzLCBub2RlLCBcImVsZW1lbnRzXCIsIGVsZW1lbnRzLCAxKTtcbiAgcmV0dXJuIG5vZGU7XG59XG5mdW5jdGlvbiBhcnJvd0Z1bmN0aW9uRXhwcmVzc2lvbihwYXJhbXMsIGJvZHksIGFzeW5jID0gZmFsc2UpIHtcbiAgY29uc3Qgbm9kZSA9IHtcbiAgICB0eXBlOiBcIkFycm93RnVuY3Rpb25FeHByZXNzaW9uXCIsXG4gICAgcGFyYW1zLFxuICAgIGJvZHksXG4gICAgYXN5bmMsXG4gICAgZXhwcmVzc2lvbjogbnVsbFxuICB9O1xuICBjb25zdCBkZWZzID0gTk9ERV9GSUVMRFMuQXJyb3dGdW5jdGlvbkV4cHJlc3Npb247XG4gIHZhbGlkYXRlKGRlZnMucGFyYW1zLCBub2RlLCBcInBhcmFtc1wiLCBwYXJhbXMsIDEpO1xuICB2YWxpZGF0ZShkZWZzLmJvZHksIG5vZGUsIFwiYm9keVwiLCBib2R5LCAxKTtcbiAgdmFsaWRhdGUoZGVmcy5hc3luYywgbm9kZSwgXCJhc3luY1wiLCBhc3luYyk7XG4gIHJldHVybiBub2RlO1xufVxuZnVuY3Rpb24gY2xhc3NCb2R5KGJvZHkpIHtcbiAgY29uc3Qgbm9kZSA9IHtcbiAgICB0eXBlOiBcIkNsYXNzQm9keVwiLFxuICAgIGJvZHlcbiAgfTtcbiAgY29uc3QgZGVmcyA9IE5PREVfRklFTERTLkNsYXNzQm9keTtcbiAgdmFsaWRhdGUoZGVmcy5ib2R5LCBub2RlLCBcImJvZHlcIiwgYm9keSwgMSk7XG4gIHJldHVybiBub2RlO1xufVxuZnVuY3Rpb24gY2xhc3NFeHByZXNzaW9uKGlkID0gbnVsbCwgc3VwZXJDbGFzcyA9IG51bGwsIGJvZHksIGRlY29yYXRvcnMgPSBudWxsKSB7XG4gIGNvbnN0IG5vZGUgPSB7XG4gICAgdHlwZTogXCJDbGFzc0V4cHJlc3Npb25cIixcbiAgICBpZCxcbiAgICBzdXBlckNsYXNzLFxuICAgIGJvZHksXG4gICAgZGVjb3JhdG9yc1xuICB9O1xuICBjb25zdCBkZWZzID0gTk9ERV9GSUVMRFMuQ2xhc3NFeHByZXNzaW9uO1xuICB2YWxpZGF0ZShkZWZzLmlkLCBub2RlLCBcImlkXCIsIGlkLCAxKTtcbiAgdmFsaWRhdGUoZGVmcy5zdXBlckNsYXNzLCBub2RlLCBcInN1cGVyQ2xhc3NcIiwgc3VwZXJDbGFzcywgMSk7XG4gIHZhbGlkYXRlKGRlZnMuYm9keSwgbm9kZSwgXCJib2R5XCIsIGJvZHksIDEpO1xuICB2YWxpZGF0ZShkZWZzLmRlY29yYXRvcnMsIG5vZGUsIFwiZGVjb3JhdG9yc1wiLCBkZWNvcmF0b3JzLCAxKTtcbiAgcmV0dXJuIG5vZGU7XG59XG5mdW5jdGlvbiBjbGFzc0RlY2xhcmF0aW9uKGlkID0gbnVsbCwgc3VwZXJDbGFzcyA9IG51bGwsIGJvZHksIGRlY29yYXRvcnMgPSBudWxsKSB7XG4gIGNvbnN0IG5vZGUgPSB7XG4gICAgdHlwZTogXCJDbGFzc0RlY2xhcmF0aW9uXCIsXG4gICAgaWQsXG4gICAgc3VwZXJDbGFzcyxcbiAgICBib2R5LFxuICAgIGRlY29yYXRvcnNcbiAgfTtcbiAgY29uc3QgZGVmcyA9IE5PREVfRklFTERTLkNsYXNzRGVjbGFyYXRpb247XG4gIHZhbGlkYXRlKGRlZnMuaWQsIG5vZGUsIFwiaWRcIiwgaWQsIDEpO1xuICB2YWxpZGF0ZShkZWZzLnN1cGVyQ2xhc3MsIG5vZGUsIFwic3VwZXJDbGFzc1wiLCBzdXBlckNsYXNzLCAxKTtcbiAgdmFsaWRhdGUoZGVmcy5ib2R5LCBub2RlLCBcImJvZHlcIiwgYm9keSwgMSk7XG4gIHZhbGlkYXRlKGRlZnMuZGVjb3JhdG9ycywgbm9kZSwgXCJkZWNvcmF0b3JzXCIsIGRlY29yYXRvcnMsIDEpO1xuICByZXR1cm4gbm9kZTtcbn1cbmZ1bmN0aW9uIGV4cG9ydEFsbERlY2xhcmF0aW9uKHNvdXJjZSkge1xuICBjb25zdCBub2RlID0ge1xuICAgIHR5cGU6IFwiRXhwb3J0QWxsRGVjbGFyYXRpb25cIixcbiAgICBzb3VyY2VcbiAgfTtcbiAgY29uc3QgZGVmcyA9IE5PREVfRklFTERTLkV4cG9ydEFsbERlY2xhcmF0aW9uO1xuICB2YWxpZGF0ZShkZWZzLnNvdXJjZSwgbm9kZSwgXCJzb3VyY2VcIiwgc291cmNlLCAxKTtcbiAgcmV0dXJuIG5vZGU7XG59XG5mdW5jdGlvbiBleHBvcnREZWZhdWx0RGVjbGFyYXRpb24oZGVjbGFyYXRpb24pIHtcbiAgY29uc3Qgbm9kZSA9IHtcbiAgICB0eXBlOiBcIkV4cG9ydERlZmF1bHREZWNsYXJhdGlvblwiLFxuICAgIGRlY2xhcmF0aW9uXG4gIH07XG4gIGNvbnN0IGRlZnMgPSBOT0RFX0ZJRUxEUy5FeHBvcnREZWZhdWx0RGVjbGFyYXRpb247XG4gIHZhbGlkYXRlKGRlZnMuZGVjbGFyYXRpb24sIG5vZGUsIFwiZGVjbGFyYXRpb25cIiwgZGVjbGFyYXRpb24sIDEpO1xuICByZXR1cm4gbm9kZTtcbn1cbmZ1bmN0aW9uIGV4cG9ydE5hbWVkRGVjbGFyYXRpb24oZGVjbGFyYXRpb24gPSBudWxsLCBzcGVjaWZpZXJzID0gW10sIHNvdXJjZSA9IG51bGwpIHtcbiAgY29uc3Qgbm9kZSA9IHtcbiAgICB0eXBlOiBcIkV4cG9ydE5hbWVkRGVjbGFyYXRpb25cIixcbiAgICBkZWNsYXJhdGlvbixcbiAgICBzcGVjaWZpZXJzLFxuICAgIHNvdXJjZVxuICB9O1xuICBjb25zdCBkZWZzID0gTk9ERV9GSUVMRFMuRXhwb3J0TmFtZWREZWNsYXJhdGlvbjtcbiAgdmFsaWRhdGUoZGVmcy5kZWNsYXJhdGlvbiwgbm9kZSwgXCJkZWNsYXJhdGlvblwiLCBkZWNsYXJhdGlvbiwgMSk7XG4gIHZhbGlkYXRlKGRlZnMuc3BlY2lmaWVycywgbm9kZSwgXCJzcGVjaWZpZXJzXCIsIHNwZWNpZmllcnMsIDEpO1xuICB2YWxpZGF0ZShkZWZzLnNvdXJjZSwgbm9kZSwgXCJzb3VyY2VcIiwgc291cmNlLCAxKTtcbiAgcmV0dXJuIG5vZGU7XG59XG5mdW5jdGlvbiBleHBvcnRTcGVjaWZpZXIobG9jYWwsIGV4cG9ydGVkKSB7XG4gIGNvbnN0IG5vZGUgPSB7XG4gICAgdHlwZTogXCJFeHBvcnRTcGVjaWZpZXJcIixcbiAgICBsb2NhbCxcbiAgICBleHBvcnRlZFxuICB9O1xuICBjb25zdCBkZWZzID0gTk9ERV9GSUVMRFMuRXhwb3J0U3BlY2lmaWVyO1xuICB2YWxpZGF0ZShkZWZzLmxvY2FsLCBub2RlLCBcImxvY2FsXCIsIGxvY2FsLCAxKTtcbiAgdmFsaWRhdGUoZGVmcy5leHBvcnRlZCwgbm9kZSwgXCJleHBvcnRlZFwiLCBleHBvcnRlZCwgMSk7XG4gIHJldHVybiBub2RlO1xufVxuZnVuY3Rpb24gZm9yT2ZTdGF0ZW1lbnQobGVmdCwgcmlnaHQsIGJvZHksIF9hd2FpdCA9IGZhbHNlKSB7XG4gIGNvbnN0IG5vZGUgPSB7XG4gICAgdHlwZTogXCJGb3JPZlN0YXRlbWVudFwiLFxuICAgIGxlZnQsXG4gICAgcmlnaHQsXG4gICAgYm9keSxcbiAgICBhd2FpdDogX2F3YWl0XG4gIH07XG4gIGNvbnN0IGRlZnMgPSBOT0RFX0ZJRUxEUy5Gb3JPZlN0YXRlbWVudDtcbiAgdmFsaWRhdGUoZGVmcy5sZWZ0LCBub2RlLCBcImxlZnRcIiwgbGVmdCwgMSk7XG4gIHZhbGlkYXRlKGRlZnMucmlnaHQsIG5vZGUsIFwicmlnaHRcIiwgcmlnaHQsIDEpO1xuICB2YWxpZGF0ZShkZWZzLmJvZHksIG5vZGUsIFwiYm9keVwiLCBib2R5LCAxKTtcbiAgdmFsaWRhdGUoZGVmcy5hd2FpdCwgbm9kZSwgXCJhd2FpdFwiLCBfYXdhaXQpO1xuICByZXR1cm4gbm9kZTtcbn1cbmZ1bmN0aW9uIGltcG9ydERlY2xhcmF0aW9uKHNwZWNpZmllcnMsIHNvdXJjZSkge1xuICBjb25zdCBub2RlID0ge1xuICAgIHR5cGU6IFwiSW1wb3J0RGVjbGFyYXRpb25cIixcbiAgICBzcGVjaWZpZXJzLFxuICAgIHNvdXJjZVxuICB9O1xuICBjb25zdCBkZWZzID0gTk9ERV9GSUVMRFMuSW1wb3J0RGVjbGFyYXRpb247XG4gIHZhbGlkYXRlKGRlZnMuc3BlY2lmaWVycywgbm9kZSwgXCJzcGVjaWZpZXJzXCIsIHNwZWNpZmllcnMsIDEpO1xuICB2YWxpZGF0ZShkZWZzLnNvdXJjZSwgbm9kZSwgXCJzb3VyY2VcIiwgc291cmNlLCAxKTtcbiAgcmV0dXJuIG5vZGU7XG59XG5mdW5jdGlvbiBpbXBvcnREZWZhdWx0U3BlY2lmaWVyKGxvY2FsKSB7XG4gIGNvbnN0IG5vZGUgPSB7XG4gICAgdHlwZTogXCJJbXBvcnREZWZhdWx0U3BlY2lmaWVyXCIsXG4gICAgbG9jYWxcbiAgfTtcbiAgY29uc3QgZGVmcyA9IE5PREVfRklFTERTLkltcG9ydERlZmF1bHRTcGVjaWZpZXI7XG4gIHZhbGlkYXRlKGRlZnMubG9jYWwsIG5vZGUsIFwibG9jYWxcIiwgbG9jYWwsIDEpO1xuICByZXR1cm4gbm9kZTtcbn1cbmZ1bmN0aW9uIGltcG9ydE5hbWVzcGFjZVNwZWNpZmllcihsb2NhbCkge1xuICBjb25zdCBub2RlID0ge1xuICAgIHR5cGU6IFwiSW1wb3J0TmFtZXNwYWNlU3BlY2lmaWVyXCIsXG4gICAgbG9jYWxcbiAgfTtcbiAgY29uc3QgZGVmcyA9IE5PREVfRklFTERTLkltcG9ydE5hbWVzcGFjZVNwZWNpZmllcjtcbiAgdmFsaWRhdGUoZGVmcy5sb2NhbCwgbm9kZSwgXCJsb2NhbFwiLCBsb2NhbCwgMSk7XG4gIHJldHVybiBub2RlO1xufVxuZnVuY3Rpb24gaW1wb3J0U3BlY2lmaWVyKGxvY2FsLCBpbXBvcnRlZCkge1xuICBjb25zdCBub2RlID0ge1xuICAgIHR5cGU6IFwiSW1wb3J0U3BlY2lmaWVyXCIsXG4gICAgbG9jYWwsXG4gICAgaW1wb3J0ZWRcbiAgfTtcbiAgY29uc3QgZGVmcyA9IE5PREVfRklFTERTLkltcG9ydFNwZWNpZmllcjtcbiAgdmFsaWRhdGUoZGVmcy5sb2NhbCwgbm9kZSwgXCJsb2NhbFwiLCBsb2NhbCwgMSk7XG4gIHZhbGlkYXRlKGRlZnMuaW1wb3J0ZWQsIG5vZGUsIFwiaW1wb3J0ZWRcIiwgaW1wb3J0ZWQsIDEpO1xuICByZXR1cm4gbm9kZTtcbn1cbmZ1bmN0aW9uIGltcG9ydEV4cHJlc3Npb24oc291cmNlLCBvcHRpb25zID0gbnVsbCkge1xuICBjb25zdCBub2RlID0ge1xuICAgIHR5cGU6IFwiSW1wb3J0RXhwcmVzc2lvblwiLFxuICAgIHNvdXJjZSxcbiAgICBvcHRpb25zXG4gIH07XG4gIGNvbnN0IGRlZnMgPSBOT0RFX0ZJRUxEUy5JbXBvcnRFeHByZXNzaW9uO1xuICB2YWxpZGF0ZShkZWZzLnNvdXJjZSwgbm9kZSwgXCJzb3VyY2VcIiwgc291cmNlLCAxKTtcbiAgdmFsaWRhdGUoZGVmcy5vcHRpb25zLCBub2RlLCBcIm9wdGlvbnNcIiwgb3B0aW9ucywgMSk7XG4gIHJldHVybiBub2RlO1xufVxuZnVuY3Rpb24gbWV0YVByb3BlcnR5KG1ldGEsIHByb3BlcnR5KSB7XG4gIGNvbnN0IG5vZGUgPSB7XG4gICAgdHlwZTogXCJNZXRhUHJvcGVydHlcIixcbiAgICBtZXRhLFxuICAgIHByb3BlcnR5XG4gIH07XG4gIGNvbnN0IGRlZnMgPSBOT0RFX0ZJRUxEUy5NZXRhUHJvcGVydHk7XG4gIHZhbGlkYXRlKGRlZnMubWV0YSwgbm9kZSwgXCJtZXRhXCIsIG1ldGEsIDEpO1xuICB2YWxpZGF0ZShkZWZzLnByb3BlcnR5LCBub2RlLCBcInByb3BlcnR5XCIsIHByb3BlcnR5LCAxKTtcbiAgcmV0dXJuIG5vZGU7XG59XG5mdW5jdGlvbiBjbGFzc01ldGhvZChraW5kID0gXCJtZXRob2RcIiwga2V5LCBwYXJhbXMsIGJvZHksIGNvbXB1dGVkID0gZmFsc2UsIF9zdGF0aWMgPSBmYWxzZSwgZ2VuZXJhdG9yID0gZmFsc2UsIGFzeW5jID0gZmFsc2UpIHtcbiAgY29uc3Qgbm9kZSA9IHtcbiAgICB0eXBlOiBcIkNsYXNzTWV0aG9kXCIsXG4gICAga2luZCxcbiAgICBrZXksXG4gICAgcGFyYW1zLFxuICAgIGJvZHksXG4gICAgY29tcHV0ZWQsXG4gICAgc3RhdGljOiBfc3RhdGljLFxuICAgIGdlbmVyYXRvcixcbiAgICBhc3luY1xuICB9O1xuICBjb25zdCBkZWZzID0gTk9ERV9GSUVMRFMuQ2xhc3NNZXRob2Q7XG4gIHZhbGlkYXRlKGRlZnMua2luZCwgbm9kZSwgXCJraW5kXCIsIGtpbmQpO1xuICB2YWxpZGF0ZShkZWZzLmtleSwgbm9kZSwgXCJrZXlcIiwga2V5LCAxKTtcbiAgdmFsaWRhdGUoZGVmcy5wYXJhbXMsIG5vZGUsIFwicGFyYW1zXCIsIHBhcmFtcywgMSk7XG4gIHZhbGlkYXRlKGRlZnMuYm9keSwgbm9kZSwgXCJib2R5XCIsIGJvZHksIDEpO1xuICB2YWxpZGF0ZShkZWZzLmNvbXB1dGVkLCBub2RlLCBcImNvbXB1dGVkXCIsIGNvbXB1dGVkKTtcbiAgdmFsaWRhdGUoZGVmcy5zdGF0aWMsIG5vZGUsIFwic3RhdGljXCIsIF9zdGF0aWMpO1xuICB2YWxpZGF0ZShkZWZzLmdlbmVyYXRvciwgbm9kZSwgXCJnZW5lcmF0b3JcIiwgZ2VuZXJhdG9yKTtcbiAgdmFsaWRhdGUoZGVmcy5hc3luYywgbm9kZSwgXCJhc3luY1wiLCBhc3luYyk7XG4gIHJldHVybiBub2RlO1xufVxuZnVuY3Rpb24gb2JqZWN0UGF0dGVybihwcm9wZXJ0aWVzKSB7XG4gIGNvbnN0IG5vZGUgPSB7XG4gICAgdHlwZTogXCJPYmplY3RQYXR0ZXJuXCIsXG4gICAgcHJvcGVydGllc1xuICB9O1xuICBjb25zdCBkZWZzID0gTk9ERV9GSUVMRFMuT2JqZWN0UGF0dGVybjtcbiAgdmFsaWRhdGUoZGVmcy5wcm9wZXJ0aWVzLCBub2RlLCBcInByb3BlcnRpZXNcIiwgcHJvcGVydGllcywgMSk7XG4gIHJldHVybiBub2RlO1xufVxuZnVuY3Rpb24gc3ByZWFkRWxlbWVudChhcmd1bWVudCkge1xuICBjb25zdCBub2RlID0ge1xuICAgIHR5cGU6IFwiU3ByZWFkRWxlbWVudFwiLFxuICAgIGFyZ3VtZW50XG4gIH07XG4gIGNvbnN0IGRlZnMgPSBOT0RFX0ZJRUxEUy5TcHJlYWRFbGVtZW50O1xuICB2YWxpZGF0ZShkZWZzLmFyZ3VtZW50LCBub2RlLCBcImFyZ3VtZW50XCIsIGFyZ3VtZW50LCAxKTtcbiAgcmV0dXJuIG5vZGU7XG59XG5mdW5jdGlvbiBfc3VwZXIoKSB7XG4gIHJldHVybiB7XG4gICAgdHlwZTogXCJTdXBlclwiXG4gIH07XG59XG5mdW5jdGlvbiB0YWdnZWRUZW1wbGF0ZUV4cHJlc3Npb24odGFnLCBxdWFzaSkge1xuICBjb25zdCBub2RlID0ge1xuICAgIHR5cGU6IFwiVGFnZ2VkVGVtcGxhdGVFeHByZXNzaW9uXCIsXG4gICAgdGFnLFxuICAgIHF1YXNpXG4gIH07XG4gIGNvbnN0IGRlZnMgPSBOT0RFX0ZJRUxEUy5UYWdnZWRUZW1wbGF0ZUV4cHJlc3Npb247XG4gIHZhbGlkYXRlKGRlZnMudGFnLCBub2RlLCBcInRhZ1wiLCB0YWcsIDEpO1xuICB2YWxpZGF0ZShkZWZzLnF1YXNpLCBub2RlLCBcInF1YXNpXCIsIHF1YXNpLCAxKTtcbiAgcmV0dXJuIG5vZGU7XG59XG5mdW5jdGlvbiB0ZW1wbGF0ZUVsZW1lbnQodmFsdWUsIHRhaWwgPSBmYWxzZSkge1xuICBjb25zdCBub2RlID0ge1xuICAgIHR5cGU6IFwiVGVtcGxhdGVFbGVtZW50XCIsXG4gICAgdmFsdWUsXG4gICAgdGFpbFxuICB9O1xuICBjb25zdCBkZWZzID0gTk9ERV9GSUVMRFMuVGVtcGxhdGVFbGVtZW50O1xuICB2YWxpZGF0ZShkZWZzLnZhbHVlLCBub2RlLCBcInZhbHVlXCIsIHZhbHVlKTtcbiAgdmFsaWRhdGUoZGVmcy50YWlsLCBub2RlLCBcInRhaWxcIiwgdGFpbCk7XG4gIHJldHVybiBub2RlO1xufVxuZnVuY3Rpb24gdGVtcGxhdGVMaXRlcmFsKHF1YXNpcywgZXhwcmVzc2lvbnMpIHtcbiAgY29uc3Qgbm9kZSA9IHtcbiAgICB0eXBlOiBcIlRlbXBsYXRlTGl0ZXJhbFwiLFxuICAgIHF1YXNpcyxcbiAgICBleHByZXNzaW9uc1xuICB9O1xuICBjb25zdCBkZWZzID0gTk9ERV9GSUVMRFMuVGVtcGxhdGVMaXRlcmFsO1xuICB2YWxpZGF0ZShkZWZzLnF1YXNpcywgbm9kZSwgXCJxdWFzaXNcIiwgcXVhc2lzLCAxKTtcbiAgdmFsaWRhdGUoZGVmcy5leHByZXNzaW9ucywgbm9kZSwgXCJleHByZXNzaW9uc1wiLCBleHByZXNzaW9ucywgMSk7XG4gIHJldHVybiBub2RlO1xufVxuZnVuY3Rpb24geWllbGRFeHByZXNzaW9uKGFyZ3VtZW50ID0gbnVsbCwgZGVsZWdhdGUgPSBmYWxzZSkge1xuICBjb25zdCBub2RlID0ge1xuICAgIHR5cGU6IFwiWWllbGRFeHByZXNzaW9uXCIsXG4gICAgYXJndW1lbnQsXG4gICAgZGVsZWdhdGVcbiAgfTtcbiAgY29uc3QgZGVmcyA9IE5PREVfRklFTERTLllpZWxkRXhwcmVzc2lvbjtcbiAgdmFsaWRhdGUoZGVmcy5hcmd1bWVudCwgbm9kZSwgXCJhcmd1bWVudFwiLCBhcmd1bWVudCwgMSk7XG4gIHZhbGlkYXRlKGRlZnMuZGVsZWdhdGUsIG5vZGUsIFwiZGVsZWdhdGVcIiwgZGVsZWdhdGUpO1xuICByZXR1cm4gbm9kZTtcbn1cbmZ1bmN0aW9uIGF3YWl0RXhwcmVzc2lvbihhcmd1bWVudCkge1xuICBjb25zdCBub2RlID0ge1xuICAgIHR5cGU6IFwiQXdhaXRFeHByZXNzaW9uXCIsXG4gICAgYXJndW1lbnRcbiAgfTtcbiAgY29uc3QgZGVmcyA9IE5PREVfRklFTERTLkF3YWl0RXhwcmVzc2lvbjtcbiAgdmFsaWRhdGUoZGVmcy5hcmd1bWVudCwgbm9kZSwgXCJhcmd1bWVudFwiLCBhcmd1bWVudCwgMSk7XG4gIHJldHVybiBub2RlO1xufVxuZnVuY3Rpb24gX2ltcG9ydCgpIHtcbiAgcmV0dXJuIHtcbiAgICB0eXBlOiBcIkltcG9ydFwiXG4gIH07XG59XG5mdW5jdGlvbiBleHBvcnROYW1lc3BhY2VTcGVjaWZpZXIoZXhwb3J0ZWQpIHtcbiAgY29uc3Qgbm9kZSA9IHtcbiAgICB0eXBlOiBcIkV4cG9ydE5hbWVzcGFjZVNwZWNpZmllclwiLFxuICAgIGV4cG9ydGVkXG4gIH07XG4gIGNvbnN0IGRlZnMgPSBOT0RFX0ZJRUxEUy5FeHBvcnROYW1lc3BhY2VTcGVjaWZpZXI7XG4gIHZhbGlkYXRlKGRlZnMuZXhwb3J0ZWQsIG5vZGUsIFwiZXhwb3J0ZWRcIiwgZXhwb3J0ZWQsIDEpO1xuICByZXR1cm4gbm9kZTtcbn1cbmZ1bmN0aW9uIG9wdGlvbmFsTWVtYmVyRXhwcmVzc2lvbihvYmplY3QsIHByb3BlcnR5LCBjb21wdXRlZCA9IGZhbHNlLCBvcHRpb25hbCkge1xuICBjb25zdCBub2RlID0ge1xuICAgIHR5cGU6IFwiT3B0aW9uYWxNZW1iZXJFeHByZXNzaW9uXCIsXG4gICAgb2JqZWN0LFxuICAgIHByb3BlcnR5LFxuICAgIGNvbXB1dGVkLFxuICAgIG9wdGlvbmFsXG4gIH07XG4gIGNvbnN0IGRlZnMgPSBOT0RFX0ZJRUxEUy5PcHRpb25hbE1lbWJlckV4cHJlc3Npb247XG4gIHZhbGlkYXRlKGRlZnMub2JqZWN0LCBub2RlLCBcIm9iamVjdFwiLCBvYmplY3QsIDEpO1xuICB2YWxpZGF0ZShkZWZzLnByb3BlcnR5LCBub2RlLCBcInByb3BlcnR5XCIsIHByb3BlcnR5LCAxKTtcbiAgdmFsaWRhdGUoZGVmcy5jb21wdXRlZCwgbm9kZSwgXCJjb21wdXRlZFwiLCBjb21wdXRlZCk7XG4gIHZhbGlkYXRlKGRlZnMub3B0aW9uYWwsIG5vZGUsIFwib3B0aW9uYWxcIiwgb3B0aW9uYWwpO1xuICByZXR1cm4gbm9kZTtcbn1cbmZ1bmN0aW9uIG9wdGlvbmFsQ2FsbEV4cHJlc3Npb24oY2FsbGVlLCBfYXJndW1lbnRzLCBvcHRpb25hbCkge1xuICBjb25zdCBub2RlID0ge1xuICAgIHR5cGU6IFwiT3B0aW9uYWxDYWxsRXhwcmVzc2lvblwiLFxuICAgIGNhbGxlZSxcbiAgICBhcmd1bWVudHM6IF9hcmd1bWVudHMsXG4gICAgb3B0aW9uYWxcbiAgfTtcbiAgY29uc3QgZGVmcyA9IE5PREVfRklFTERTLk9wdGlvbmFsQ2FsbEV4cHJlc3Npb247XG4gIHZhbGlkYXRlKGRlZnMuY2FsbGVlLCBub2RlLCBcImNhbGxlZVwiLCBjYWxsZWUsIDEpO1xuICB2YWxpZGF0ZShkZWZzLmFyZ3VtZW50cywgbm9kZSwgXCJhcmd1bWVudHNcIiwgX2FyZ3VtZW50cywgMSk7XG4gIHZhbGlkYXRlKGRlZnMub3B0aW9uYWwsIG5vZGUsIFwib3B0aW9uYWxcIiwgb3B0aW9uYWwpO1xuICByZXR1cm4gbm9kZTtcbn1cbmZ1bmN0aW9uIGNsYXNzUHJvcGVydHkoa2V5LCB2YWx1ZSA9IG51bGwsIHR5cGVBbm5vdGF0aW9uID0gbnVsbCwgZGVjb3JhdG9ycyA9IG51bGwsIGNvbXB1dGVkID0gZmFsc2UsIF9zdGF0aWMgPSBmYWxzZSkge1xuICBjb25zdCBub2RlID0ge1xuICAgIHR5cGU6IFwiQ2xhc3NQcm9wZXJ0eVwiLFxuICAgIGtleSxcbiAgICB2YWx1ZSxcbiAgICB0eXBlQW5ub3RhdGlvbixcbiAgICBkZWNvcmF0b3JzLFxuICAgIGNvbXB1dGVkLFxuICAgIHN0YXRpYzogX3N0YXRpY1xuICB9O1xuICBjb25zdCBkZWZzID0gTk9ERV9GSUVMRFMuQ2xhc3NQcm9wZXJ0eTtcbiAgdmFsaWRhdGUoZGVmcy5rZXksIG5vZGUsIFwia2V5XCIsIGtleSwgMSk7XG4gIHZhbGlkYXRlKGRlZnMudmFsdWUsIG5vZGUsIFwidmFsdWVcIiwgdmFsdWUsIDEpO1xuICB2YWxpZGF0ZShkZWZzLnR5cGVBbm5vdGF0aW9uLCBub2RlLCBcInR5cGVBbm5vdGF0aW9uXCIsIHR5cGVBbm5vdGF0aW9uLCAxKTtcbiAgdmFsaWRhdGUoZGVmcy5kZWNvcmF0b3JzLCBub2RlLCBcImRlY29yYXRvcnNcIiwgZGVjb3JhdG9ycywgMSk7XG4gIHZhbGlkYXRlKGRlZnMuY29tcHV0ZWQsIG5vZGUsIFwiY29tcHV0ZWRcIiwgY29tcHV0ZWQpO1xuICB2YWxpZGF0ZShkZWZzLnN0YXRpYywgbm9kZSwgXCJzdGF0aWNcIiwgX3N0YXRpYyk7XG4gIHJldHVybiBub2RlO1xufVxuZnVuY3Rpb24gY2xhc3NBY2Nlc3NvclByb3BlcnR5KGtleSwgdmFsdWUgPSBudWxsLCB0eXBlQW5ub3RhdGlvbiA9IG51bGwsIGRlY29yYXRvcnMgPSBudWxsLCBjb21wdXRlZCA9IGZhbHNlLCBfc3RhdGljID0gZmFsc2UpIHtcbiAgY29uc3Qgbm9kZSA9IHtcbiAgICB0eXBlOiBcIkNsYXNzQWNjZXNzb3JQcm9wZXJ0eVwiLFxuICAgIGtleSxcbiAgICB2YWx1ZSxcbiAgICB0eXBlQW5ub3RhdGlvbixcbiAgICBkZWNvcmF0b3JzLFxuICAgIGNvbXB1dGVkLFxuICAgIHN0YXRpYzogX3N0YXRpY1xuICB9O1xuICBjb25zdCBkZWZzID0gTk9ERV9GSUVMRFMuQ2xhc3NBY2Nlc3NvclByb3BlcnR5O1xuICB2YWxpZGF0ZShkZWZzLmtleSwgbm9kZSwgXCJrZXlcIiwga2V5LCAxKTtcbiAgdmFsaWRhdGUoZGVmcy52YWx1ZSwgbm9kZSwgXCJ2YWx1ZVwiLCB2YWx1ZSwgMSk7XG4gIHZhbGlkYXRlKGRlZnMudHlwZUFubm90YXRpb24sIG5vZGUsIFwidHlwZUFubm90YXRpb25cIiwgdHlwZUFubm90YXRpb24sIDEpO1xuICB2YWxpZGF0ZShkZWZzLmRlY29yYXRvcnMsIG5vZGUsIFwiZGVjb3JhdG9yc1wiLCBkZWNvcmF0b3JzLCAxKTtcbiAgdmFsaWRhdGUoZGVmcy5jb21wdXRlZCwgbm9kZSwgXCJjb21wdXRlZFwiLCBjb21wdXRlZCk7XG4gIHZhbGlkYXRlKGRlZnMuc3RhdGljLCBub2RlLCBcInN0YXRpY1wiLCBfc3RhdGljKTtcbiAgcmV0dXJuIG5vZGU7XG59XG5mdW5jdGlvbiBjbGFzc1ByaXZhdGVQcm9wZXJ0eShrZXksIHZhbHVlID0gbnVsbCwgZGVjb3JhdG9ycyA9IG51bGwsIF9zdGF0aWMgPSBmYWxzZSkge1xuICBjb25zdCBub2RlID0ge1xuICAgIHR5cGU6IFwiQ2xhc3NQcml2YXRlUHJvcGVydHlcIixcbiAgICBrZXksXG4gICAgdmFsdWUsXG4gICAgZGVjb3JhdG9ycyxcbiAgICBzdGF0aWM6IF9zdGF0aWNcbiAgfTtcbiAgY29uc3QgZGVmcyA9IE5PREVfRklFTERTLkNsYXNzUHJpdmF0ZVByb3BlcnR5O1xuICB2YWxpZGF0ZShkZWZzLmtleSwgbm9kZSwgXCJrZXlcIiwga2V5LCAxKTtcbiAgdmFsaWRhdGUoZGVmcy52YWx1ZSwgbm9kZSwgXCJ2YWx1ZVwiLCB2YWx1ZSwgMSk7XG4gIHZhbGlkYXRlKGRlZnMuZGVjb3JhdG9ycywgbm9kZSwgXCJkZWNvcmF0b3JzXCIsIGRlY29yYXRvcnMsIDEpO1xuICB2YWxpZGF0ZShkZWZzLnN0YXRpYywgbm9kZSwgXCJzdGF0aWNcIiwgX3N0YXRpYyk7XG4gIHJldHVybiBub2RlO1xufVxuZnVuY3Rpb24gY2xhc3NQcml2YXRlTWV0aG9kKGtpbmQgPSBcIm1ldGhvZFwiLCBrZXksIHBhcmFtcywgYm9keSwgX3N0YXRpYyA9IGZhbHNlKSB7XG4gIGNvbnN0IG5vZGUgPSB7XG4gICAgdHlwZTogXCJDbGFzc1ByaXZhdGVNZXRob2RcIixcbiAgICBraW5kLFxuICAgIGtleSxcbiAgICBwYXJhbXMsXG4gICAgYm9keSxcbiAgICBzdGF0aWM6IF9zdGF0aWNcbiAgfTtcbiAgY29uc3QgZGVmcyA9IE5PREVfRklFTERTLkNsYXNzUHJpdmF0ZU1ldGhvZDtcbiAgdmFsaWRhdGUoZGVmcy5raW5kLCBub2RlLCBcImtpbmRcIiwga2luZCk7XG4gIHZhbGlkYXRlKGRlZnMua2V5LCBub2RlLCBcImtleVwiLCBrZXksIDEpO1xuICB2YWxpZGF0ZShkZWZzLnBhcmFtcywgbm9kZSwgXCJwYXJhbXNcIiwgcGFyYW1zLCAxKTtcbiAgdmFsaWRhdGUoZGVmcy5ib2R5LCBub2RlLCBcImJvZHlcIiwgYm9keSwgMSk7XG4gIHZhbGlkYXRlKGRlZnMuc3RhdGljLCBub2RlLCBcInN0YXRpY1wiLCBfc3RhdGljKTtcbiAgcmV0dXJuIG5vZGU7XG59XG5mdW5jdGlvbiBwcml2YXRlTmFtZShpZCkge1xuICBjb25zdCBub2RlID0ge1xuICAgIHR5cGU6IFwiUHJpdmF0ZU5hbWVcIixcbiAgICBpZFxuICB9O1xuICBjb25zdCBkZWZzID0gTk9ERV9GSUVMRFMuUHJpdmF0ZU5hbWU7XG4gIHZhbGlkYXRlKGRlZnMuaWQsIG5vZGUsIFwiaWRcIiwgaWQsIDEpO1xuICByZXR1cm4gbm9kZTtcbn1cbmZ1bmN0aW9uIHN0YXRpY0Jsb2NrKGJvZHkpIHtcbiAgY29uc3Qgbm9kZSA9IHtcbiAgICB0eXBlOiBcIlN0YXRpY0Jsb2NrXCIsXG4gICAgYm9keVxuICB9O1xuICBjb25zdCBkZWZzID0gTk9ERV9GSUVMRFMuU3RhdGljQmxvY2s7XG4gIHZhbGlkYXRlKGRlZnMuYm9keSwgbm9kZSwgXCJib2R5XCIsIGJvZHksIDEpO1xuICByZXR1cm4gbm9kZTtcbn1cbmZ1bmN0aW9uIGltcG9ydEF0dHJpYnV0ZShrZXksIHZhbHVlKSB7XG4gIGNvbnN0IG5vZGUgPSB7XG4gICAgdHlwZTogXCJJbXBvcnRBdHRyaWJ1dGVcIixcbiAgICBrZXksXG4gICAgdmFsdWVcbiAgfTtcbiAgY29uc3QgZGVmcyA9IE5PREVfRklFTERTLkltcG9ydEF0dHJpYnV0ZTtcbiAgdmFsaWRhdGUoZGVmcy5rZXksIG5vZGUsIFwia2V5XCIsIGtleSwgMSk7XG4gIHZhbGlkYXRlKGRlZnMudmFsdWUsIG5vZGUsIFwidmFsdWVcIiwgdmFsdWUsIDEpO1xuICByZXR1cm4gbm9kZTtcbn1cbmZ1bmN0aW9uIGFueVR5cGVBbm5vdGF0aW9uKCkge1xuICByZXR1cm4ge1xuICAgIHR5cGU6IFwiQW55VHlwZUFubm90YXRpb25cIlxuICB9O1xufVxuZnVuY3Rpb24gYXJyYXlUeXBlQW5ub3RhdGlvbihlbGVtZW50VHlwZSkge1xuICBjb25zdCBub2RlID0ge1xuICAgIHR5cGU6IFwiQXJyYXlUeXBlQW5ub3RhdGlvblwiLFxuICAgIGVsZW1lbnRUeXBlXG4gIH07XG4gIGNvbnN0IGRlZnMgPSBOT0RFX0ZJRUxEUy5BcnJheVR5cGVBbm5vdGF0aW9uO1xuICB2YWxpZGF0ZShkZWZzLmVsZW1lbnRUeXBlLCBub2RlLCBcImVsZW1lbnRUeXBlXCIsIGVsZW1lbnRUeXBlLCAxKTtcbiAgcmV0dXJuIG5vZGU7XG59XG5mdW5jdGlvbiBib29sZWFuVHlwZUFubm90YXRpb24oKSB7XG4gIHJldHVybiB7XG4gICAgdHlwZTogXCJCb29sZWFuVHlwZUFubm90YXRpb25cIlxuICB9O1xufVxuZnVuY3Rpb24gYm9vbGVhbkxpdGVyYWxUeXBlQW5ub3RhdGlvbih2YWx1ZSkge1xuICBjb25zdCBub2RlID0ge1xuICAgIHR5cGU6IFwiQm9vbGVhbkxpdGVyYWxUeXBlQW5ub3RhdGlvblwiLFxuICAgIHZhbHVlXG4gIH07XG4gIGNvbnN0IGRlZnMgPSBOT0RFX0ZJRUxEUy5Cb29sZWFuTGl0ZXJhbFR5cGVBbm5vdGF0aW9uO1xuICB2YWxpZGF0ZShkZWZzLnZhbHVlLCBub2RlLCBcInZhbHVlXCIsIHZhbHVlKTtcbiAgcmV0dXJuIG5vZGU7XG59XG5mdW5jdGlvbiBudWxsTGl0ZXJhbFR5cGVBbm5vdGF0aW9uKCkge1xuICByZXR1cm4ge1xuICAgIHR5cGU6IFwiTnVsbExpdGVyYWxUeXBlQW5ub3RhdGlvblwiXG4gIH07XG59XG5mdW5jdGlvbiBjbGFzc0ltcGxlbWVudHMoaWQsIHR5cGVQYXJhbWV0ZXJzID0gbnVsbCkge1xuICBjb25zdCBub2RlID0ge1xuICAgIHR5cGU6IFwiQ2xhc3NJbXBsZW1lbnRzXCIsXG4gICAgaWQsXG4gICAgdHlwZVBhcmFtZXRlcnNcbiAgfTtcbiAgY29uc3QgZGVmcyA9IE5PREVfRklFTERTLkNsYXNzSW1wbGVtZW50cztcbiAgdmFsaWRhdGUoZGVmcy5pZCwgbm9kZSwgXCJpZFwiLCBpZCwgMSk7XG4gIHZhbGlkYXRlKGRlZnMudHlwZVBhcmFtZXRlcnMsIG5vZGUsIFwidHlwZVBhcmFtZXRlcnNcIiwgdHlwZVBhcmFtZXRlcnMsIDEpO1xuICByZXR1cm4gbm9kZTtcbn1cbmZ1bmN0aW9uIGRlY2xhcmVDbGFzcyhpZCwgdHlwZVBhcmFtZXRlcnMgPSBudWxsLCBfZXh0ZW5kcyA9IG51bGwsIGJvZHkpIHtcbiAgY29uc3Qgbm9kZSA9IHtcbiAgICB0eXBlOiBcIkRlY2xhcmVDbGFzc1wiLFxuICAgIGlkLFxuICAgIHR5cGVQYXJhbWV0ZXJzLFxuICAgIGV4dGVuZHM6IF9leHRlbmRzLFxuICAgIGJvZHlcbiAgfTtcbiAgY29uc3QgZGVmcyA9IE5PREVfRklFTERTLkRlY2xhcmVDbGFzcztcbiAgdmFsaWRhdGUoZGVmcy5pZCwgbm9kZSwgXCJpZFwiLCBpZCwgMSk7XG4gIHZhbGlkYXRlKGRlZnMudHlwZVBhcmFtZXRlcnMsIG5vZGUsIFwidHlwZVBhcmFtZXRlcnNcIiwgdHlwZVBhcmFtZXRlcnMsIDEpO1xuICB2YWxpZGF0ZShkZWZzLmV4dGVuZHMsIG5vZGUsIFwiZXh0ZW5kc1wiLCBfZXh0ZW5kcywgMSk7XG4gIHZhbGlkYXRlKGRlZnMuYm9keSwgbm9kZSwgXCJib2R5XCIsIGJvZHksIDEpO1xuICByZXR1cm4gbm9kZTtcbn1cbmZ1bmN0aW9uIGRlY2xhcmVGdW5jdGlvbihpZCkge1xuICBjb25zdCBub2RlID0ge1xuICAgIHR5cGU6IFwiRGVjbGFyZUZ1bmN0aW9uXCIsXG4gICAgaWRcbiAgfTtcbiAgY29uc3QgZGVmcyA9IE5PREVfRklFTERTLkRlY2xhcmVGdW5jdGlvbjtcbiAgdmFsaWRhdGUoZGVmcy5pZCwgbm9kZSwgXCJpZFwiLCBpZCwgMSk7XG4gIHJldHVybiBub2RlO1xufVxuZnVuY3Rpb24gZGVjbGFyZUludGVyZmFjZShpZCwgdHlwZVBhcmFtZXRlcnMgPSBudWxsLCBfZXh0ZW5kcyA9IG51bGwsIGJvZHkpIHtcbiAgY29uc3Qgbm9kZSA9IHtcbiAgICB0eXBlOiBcIkRlY2xhcmVJbnRlcmZhY2VcIixcbiAgICBpZCxcbiAgICB0eXBlUGFyYW1ldGVycyxcbiAgICBleHRlbmRzOiBfZXh0ZW5kcyxcbiAgICBib2R5XG4gIH07XG4gIGNvbnN0IGRlZnMgPSBOT0RFX0ZJRUxEUy5EZWNsYXJlSW50ZXJmYWNlO1xuICB2YWxpZGF0ZShkZWZzLmlkLCBub2RlLCBcImlkXCIsIGlkLCAxKTtcbiAgdmFsaWRhdGUoZGVmcy50eXBlUGFyYW1ldGVycywgbm9kZSwgXCJ0eXBlUGFyYW1ldGVyc1wiLCB0eXBlUGFyYW1ldGVycywgMSk7XG4gIHZhbGlkYXRlKGRlZnMuZXh0ZW5kcywgbm9kZSwgXCJleHRlbmRzXCIsIF9leHRlbmRzLCAxKTtcbiAgdmFsaWRhdGUoZGVmcy5ib2R5LCBub2RlLCBcImJvZHlcIiwgYm9keSwgMSk7XG4gIHJldHVybiBub2RlO1xufVxuZnVuY3Rpb24gZGVjbGFyZU1vZHVsZShpZCwgYm9keSwga2luZCA9IG51bGwpIHtcbiAgY29uc3Qgbm9kZSA9IHtcbiAgICB0eXBlOiBcIkRlY2xhcmVNb2R1bGVcIixcbiAgICBpZCxcbiAgICBib2R5LFxuICAgIGtpbmRcbiAgfTtcbiAgY29uc3QgZGVmcyA9IE5PREVfRklFTERTLkRlY2xhcmVNb2R1bGU7XG4gIHZhbGlkYXRlKGRlZnMuaWQsIG5vZGUsIFwiaWRcIiwgaWQsIDEpO1xuICB2YWxpZGF0ZShkZWZzLmJvZHksIG5vZGUsIFwiYm9keVwiLCBib2R5LCAxKTtcbiAgdmFsaWRhdGUoZGVmcy5raW5kLCBub2RlLCBcImtpbmRcIiwga2luZCk7XG4gIHJldHVybiBub2RlO1xufVxuZnVuY3Rpb24gZGVjbGFyZU1vZHVsZUV4cG9ydHModHlwZUFubm90YXRpb24pIHtcbiAgY29uc3Qgbm9kZSA9IHtcbiAgICB0eXBlOiBcIkRlY2xhcmVNb2R1bGVFeHBvcnRzXCIsXG4gICAgdHlwZUFubm90YXRpb25cbiAgfTtcbiAgY29uc3QgZGVmcyA9IE5PREVfRklFTERTLkRlY2xhcmVNb2R1bGVFeHBvcnRzO1xuICB2YWxpZGF0ZShkZWZzLnR5cGVBbm5vdGF0aW9uLCBub2RlLCBcInR5cGVBbm5vdGF0aW9uXCIsIHR5cGVBbm5vdGF0aW9uLCAxKTtcbiAgcmV0dXJuIG5vZGU7XG59XG5mdW5jdGlvbiBkZWNsYXJlVHlwZUFsaWFzKGlkLCB0eXBlUGFyYW1ldGVycyA9IG51bGwsIHJpZ2h0KSB7XG4gIGNvbnN0IG5vZGUgPSB7XG4gICAgdHlwZTogXCJEZWNsYXJlVHlwZUFsaWFzXCIsXG4gICAgaWQsXG4gICAgdHlwZVBhcmFtZXRlcnMsXG4gICAgcmlnaHRcbiAgfTtcbiAgY29uc3QgZGVmcyA9IE5PREVfRklFTERTLkRlY2xhcmVUeXBlQWxpYXM7XG4gIHZhbGlkYXRlKGRlZnMuaWQsIG5vZGUsIFwiaWRcIiwgaWQsIDEpO1xuICB2YWxpZGF0ZShkZWZzLnR5cGVQYXJhbWV0ZXJzLCBub2RlLCBcInR5cGVQYXJhbWV0ZXJzXCIsIHR5cGVQYXJhbWV0ZXJzLCAxKTtcbiAgdmFsaWRhdGUoZGVmcy5yaWdodCwgbm9kZSwgXCJyaWdodFwiLCByaWdodCwgMSk7XG4gIHJldHVybiBub2RlO1xufVxuZnVuY3Rpb24gZGVjbGFyZU9wYXF1ZVR5cGUoaWQsIHR5cGVQYXJhbWV0ZXJzID0gbnVsbCwgc3VwZXJ0eXBlID0gbnVsbCkge1xuICBjb25zdCBub2RlID0ge1xuICAgIHR5cGU6IFwiRGVjbGFyZU9wYXF1ZVR5cGVcIixcbiAgICBpZCxcbiAgICB0eXBlUGFyYW1ldGVycyxcbiAgICBzdXBlcnR5cGVcbiAgfTtcbiAgY29uc3QgZGVmcyA9IE5PREVfRklFTERTLkRlY2xhcmVPcGFxdWVUeXBlO1xuICB2YWxpZGF0ZShkZWZzLmlkLCBub2RlLCBcImlkXCIsIGlkLCAxKTtcbiAgdmFsaWRhdGUoZGVmcy50eXBlUGFyYW1ldGVycywgbm9kZSwgXCJ0eXBlUGFyYW1ldGVyc1wiLCB0eXBlUGFyYW1ldGVycywgMSk7XG4gIHZhbGlkYXRlKGRlZnMuc3VwZXJ0eXBlLCBub2RlLCBcInN1cGVydHlwZVwiLCBzdXBlcnR5cGUsIDEpO1xuICByZXR1cm4gbm9kZTtcbn1cbmZ1bmN0aW9uIGRlY2xhcmVWYXJpYWJsZShpZCkge1xuICBjb25zdCBub2RlID0ge1xuICAgIHR5cGU6IFwiRGVjbGFyZVZhcmlhYmxlXCIsXG4gICAgaWRcbiAgfTtcbiAgY29uc3QgZGVmcyA9IE5PREVfRklFTERTLkRlY2xhcmVWYXJpYWJsZTtcbiAgdmFsaWRhdGUoZGVmcy5pZCwgbm9kZSwgXCJpZFwiLCBpZCwgMSk7XG4gIHJldHVybiBub2RlO1xufVxuZnVuY3Rpb24gZGVjbGFyZUV4cG9ydERlY2xhcmF0aW9uKGRlY2xhcmF0aW9uID0gbnVsbCwgc3BlY2lmaWVycyA9IG51bGwsIHNvdXJjZSA9IG51bGwsIGF0dHJpYnV0ZXMgPSBudWxsKSB7XG4gIGNvbnN0IG5vZGUgPSB7XG4gICAgdHlwZTogXCJEZWNsYXJlRXhwb3J0RGVjbGFyYXRpb25cIixcbiAgICBkZWNsYXJhdGlvbixcbiAgICBzcGVjaWZpZXJzLFxuICAgIHNvdXJjZSxcbiAgICBhdHRyaWJ1dGVzXG4gIH07XG4gIGNvbnN0IGRlZnMgPSBOT0RFX0ZJRUxEUy5EZWNsYXJlRXhwb3J0RGVjbGFyYXRpb247XG4gIHZhbGlkYXRlKGRlZnMuZGVjbGFyYXRpb24sIG5vZGUsIFwiZGVjbGFyYXRpb25cIiwgZGVjbGFyYXRpb24sIDEpO1xuICB2YWxpZGF0ZShkZWZzLnNwZWNpZmllcnMsIG5vZGUsIFwic3BlY2lmaWVyc1wiLCBzcGVjaWZpZXJzLCAxKTtcbiAgdmFsaWRhdGUoZGVmcy5zb3VyY2UsIG5vZGUsIFwic291cmNlXCIsIHNvdXJjZSwgMSk7XG4gIHZhbGlkYXRlKGRlZnMuYXR0cmlidXRlcywgbm9kZSwgXCJhdHRyaWJ1dGVzXCIsIGF0dHJpYnV0ZXMsIDEpO1xuICByZXR1cm4gbm9kZTtcbn1cbmZ1bmN0aW9uIGRlY2xhcmVFeHBvcnRBbGxEZWNsYXJhdGlvbihzb3VyY2UsIGF0dHJpYnV0ZXMgPSBudWxsKSB7XG4gIGNvbnN0IG5vZGUgPSB7XG4gICAgdHlwZTogXCJEZWNsYXJlRXhwb3J0QWxsRGVjbGFyYXRpb25cIixcbiAgICBzb3VyY2UsXG4gICAgYXR0cmlidXRlc1xuICB9O1xuICBjb25zdCBkZWZzID0gTk9ERV9GSUVMRFMuRGVjbGFyZUV4cG9ydEFsbERlY2xhcmF0aW9uO1xuICB2YWxpZGF0ZShkZWZzLnNvdXJjZSwgbm9kZSwgXCJzb3VyY2VcIiwgc291cmNlLCAxKTtcbiAgdmFsaWRhdGUoZGVmcy5hdHRyaWJ1dGVzLCBub2RlLCBcImF0dHJpYnV0ZXNcIiwgYXR0cmlidXRlcywgMSk7XG4gIHJldHVybiBub2RlO1xufVxuZnVuY3Rpb24gZGVjbGFyZWRQcmVkaWNhdGUodmFsdWUpIHtcbiAgY29uc3Qgbm9kZSA9IHtcbiAgICB0eXBlOiBcIkRlY2xhcmVkUHJlZGljYXRlXCIsXG4gICAgdmFsdWVcbiAgfTtcbiAgY29uc3QgZGVmcyA9IE5PREVfRklFTERTLkRlY2xhcmVkUHJlZGljYXRlO1xuICB2YWxpZGF0ZShkZWZzLnZhbHVlLCBub2RlLCBcInZhbHVlXCIsIHZhbHVlLCAxKTtcbiAgcmV0dXJuIG5vZGU7XG59XG5mdW5jdGlvbiBleGlzdHNUeXBlQW5ub3RhdGlvbigpIHtcbiAgcmV0dXJuIHtcbiAgICB0eXBlOiBcIkV4aXN0c1R5cGVBbm5vdGF0aW9uXCJcbiAgfTtcbn1cbmZ1bmN0aW9uIGZ1bmN0aW9uVHlwZUFubm90YXRpb24odHlwZVBhcmFtZXRlcnMgPSBudWxsLCBwYXJhbXMsIHJlc3QgPSBudWxsLCByZXR1cm5UeXBlKSB7XG4gIGNvbnN0IG5vZGUgPSB7XG4gICAgdHlwZTogXCJGdW5jdGlvblR5cGVBbm5vdGF0aW9uXCIsXG4gICAgdHlwZVBhcmFtZXRlcnMsXG4gICAgcGFyYW1zLFxuICAgIHJlc3QsXG4gICAgcmV0dXJuVHlwZVxuICB9O1xuICBjb25zdCBkZWZzID0gTk9ERV9GSUVMRFMuRnVuY3Rpb25UeXBlQW5ub3RhdGlvbjtcbiAgdmFsaWRhdGUoZGVmcy50eXBlUGFyYW1ldGVycywgbm9kZSwgXCJ0eXBlUGFyYW1ldGVyc1wiLCB0eXBlUGFyYW1ldGVycywgMSk7XG4gIHZhbGlkYXRlKGRlZnMucGFyYW1zLCBub2RlLCBcInBhcmFtc1wiLCBwYXJhbXMsIDEpO1xuICB2YWxpZGF0ZShkZWZzLnJlc3QsIG5vZGUsIFwicmVzdFwiLCByZXN0LCAxKTtcbiAgdmFsaWRhdGUoZGVmcy5yZXR1cm5UeXBlLCBub2RlLCBcInJldHVyblR5cGVcIiwgcmV0dXJuVHlwZSwgMSk7XG4gIHJldHVybiBub2RlO1xufVxuZnVuY3Rpb24gZnVuY3Rpb25UeXBlUGFyYW0obmFtZSA9IG51bGwsIHR5cGVBbm5vdGF0aW9uKSB7XG4gIGNvbnN0IG5vZGUgPSB7XG4gICAgdHlwZTogXCJGdW5jdGlvblR5cGVQYXJhbVwiLFxuICAgIG5hbWUsXG4gICAgdHlwZUFubm90YXRpb25cbiAgfTtcbiAgY29uc3QgZGVmcyA9IE5PREVfRklFTERTLkZ1bmN0aW9uVHlwZVBhcmFtO1xuICB2YWxpZGF0ZShkZWZzLm5hbWUsIG5vZGUsIFwibmFtZVwiLCBuYW1lLCAxKTtcbiAgdmFsaWRhdGUoZGVmcy50eXBlQW5ub3RhdGlvbiwgbm9kZSwgXCJ0eXBlQW5ub3RhdGlvblwiLCB0eXBlQW5ub3RhdGlvbiwgMSk7XG4gIHJldHVybiBub2RlO1xufVxuZnVuY3Rpb24gZ2VuZXJpY1R5cGVBbm5vdGF0aW9uKGlkLCB0eXBlUGFyYW1ldGVycyA9IG51bGwpIHtcbiAgY29uc3Qgbm9kZSA9IHtcbiAgICB0eXBlOiBcIkdlbmVyaWNUeXBlQW5ub3RhdGlvblwiLFxuICAgIGlkLFxuICAgIHR5cGVQYXJhbWV0ZXJzXG4gIH07XG4gIGNvbnN0IGRlZnMgPSBOT0RFX0ZJRUxEUy5HZW5lcmljVHlwZUFubm90YXRpb247XG4gIHZhbGlkYXRlKGRlZnMuaWQsIG5vZGUsIFwiaWRcIiwgaWQsIDEpO1xuICB2YWxpZGF0ZShkZWZzLnR5cGVQYXJhbWV0ZXJzLCBub2RlLCBcInR5cGVQYXJhbWV0ZXJzXCIsIHR5cGVQYXJhbWV0ZXJzLCAxKTtcbiAgcmV0dXJuIG5vZGU7XG59XG5mdW5jdGlvbiBpbmZlcnJlZFByZWRpY2F0ZSgpIHtcbiAgcmV0dXJuIHtcbiAgICB0eXBlOiBcIkluZmVycmVkUHJlZGljYXRlXCJcbiAgfTtcbn1cbmZ1bmN0aW9uIGludGVyZmFjZUV4dGVuZHMoaWQsIHR5cGVQYXJhbWV0ZXJzID0gbnVsbCkge1xuICBjb25zdCBub2RlID0ge1xuICAgIHR5cGU6IFwiSW50ZXJmYWNlRXh0ZW5kc1wiLFxuICAgIGlkLFxuICAgIHR5cGVQYXJhbWV0ZXJzXG4gIH07XG4gIGNvbnN0IGRlZnMgPSBOT0RFX0ZJRUxEUy5JbnRlcmZhY2VFeHRlbmRzO1xuICB2YWxpZGF0ZShkZWZzLmlkLCBub2RlLCBcImlkXCIsIGlkLCAxKTtcbiAgdmFsaWRhdGUoZGVmcy50eXBlUGFyYW1ldGVycywgbm9kZSwgXCJ0eXBlUGFyYW1ldGVyc1wiLCB0eXBlUGFyYW1ldGVycywgMSk7XG4gIHJldHVybiBub2RlO1xufVxuZnVuY3Rpb24gaW50ZXJmYWNlRGVjbGFyYXRpb24oaWQsIHR5cGVQYXJhbWV0ZXJzID0gbnVsbCwgX2V4dGVuZHMgPSBudWxsLCBib2R5KSB7XG4gIGNvbnN0IG5vZGUgPSB7XG4gICAgdHlwZTogXCJJbnRlcmZhY2VEZWNsYXJhdGlvblwiLFxuICAgIGlkLFxuICAgIHR5cGVQYXJhbWV0ZXJzLFxuICAgIGV4dGVuZHM6IF9leHRlbmRzLFxuICAgIGJvZHlcbiAgfTtcbiAgY29uc3QgZGVmcyA9IE5PREVfRklFTERTLkludGVyZmFjZURlY2xhcmF0aW9uO1xuICB2YWxpZGF0ZShkZWZzLmlkLCBub2RlLCBcImlkXCIsIGlkLCAxKTtcbiAgdmFsaWRhdGUoZGVmcy50eXBlUGFyYW1ldGVycywgbm9kZSwgXCJ0eXBlUGFyYW1ldGVyc1wiLCB0eXBlUGFyYW1ldGVycywgMSk7XG4gIHZhbGlkYXRlKGRlZnMuZXh0ZW5kcywgbm9kZSwgXCJleHRlbmRzXCIsIF9leHRlbmRzLCAxKTtcbiAgdmFsaWRhdGUoZGVmcy5ib2R5LCBub2RlLCBcImJvZHlcIiwgYm9keSwgMSk7XG4gIHJldHVybiBub2RlO1xufVxuZnVuY3Rpb24gaW50ZXJmYWNlVHlwZUFubm90YXRpb24oX2V4dGVuZHMgPSBudWxsLCBib2R5KSB7XG4gIGNvbnN0IG5vZGUgPSB7XG4gICAgdHlwZTogXCJJbnRlcmZhY2VUeXBlQW5ub3RhdGlvblwiLFxuICAgIGV4dGVuZHM6IF9leHRlbmRzLFxuICAgIGJvZHlcbiAgfTtcbiAgY29uc3QgZGVmcyA9IE5PREVfRklFTERTLkludGVyZmFjZVR5cGVBbm5vdGF0aW9uO1xuICB2YWxpZGF0ZShkZWZzLmV4dGVuZHMsIG5vZGUsIFwiZXh0ZW5kc1wiLCBfZXh0ZW5kcywgMSk7XG4gIHZhbGlkYXRlKGRlZnMuYm9keSwgbm9kZSwgXCJib2R5XCIsIGJvZHksIDEpO1xuICByZXR1cm4gbm9kZTtcbn1cbmZ1bmN0aW9uIGludGVyc2VjdGlvblR5cGVBbm5vdGF0aW9uKHR5cGVzKSB7XG4gIGNvbnN0IG5vZGUgPSB7XG4gICAgdHlwZTogXCJJbnRlcnNlY3Rpb25UeXBlQW5ub3RhdGlvblwiLFxuICAgIHR5cGVzXG4gIH07XG4gIGNvbnN0IGRlZnMgPSBOT0RFX0ZJRUxEUy5JbnRlcnNlY3Rpb25UeXBlQW5ub3RhdGlvbjtcbiAgdmFsaWRhdGUoZGVmcy50eXBlcywgbm9kZSwgXCJ0eXBlc1wiLCB0eXBlcywgMSk7XG4gIHJldHVybiBub2RlO1xufVxuZnVuY3Rpb24gbWl4ZWRUeXBlQW5ub3RhdGlvbigpIHtcbiAgcmV0dXJuIHtcbiAgICB0eXBlOiBcIk1peGVkVHlwZUFubm90YXRpb25cIlxuICB9O1xufVxuZnVuY3Rpb24gZW1wdHlUeXBlQW5ub3RhdGlvbigpIHtcbiAgcmV0dXJuIHtcbiAgICB0eXBlOiBcIkVtcHR5VHlwZUFubm90YXRpb25cIlxuICB9O1xufVxuZnVuY3Rpb24gbnVsbGFibGVUeXBlQW5ub3RhdGlvbih0eXBlQW5ub3RhdGlvbikge1xuICBjb25zdCBub2RlID0ge1xuICAgIHR5cGU6IFwiTnVsbGFibGVUeXBlQW5ub3RhdGlvblwiLFxuICAgIHR5cGVBbm5vdGF0aW9uXG4gIH07XG4gIGNvbnN0IGRlZnMgPSBOT0RFX0ZJRUxEUy5OdWxsYWJsZVR5cGVBbm5vdGF0aW9uO1xuICB2YWxpZGF0ZShkZWZzLnR5cGVBbm5vdGF0aW9uLCBub2RlLCBcInR5cGVBbm5vdGF0aW9uXCIsIHR5cGVBbm5vdGF0aW9uLCAxKTtcbiAgcmV0dXJuIG5vZGU7XG59XG5mdW5jdGlvbiBudW1iZXJMaXRlcmFsVHlwZUFubm90YXRpb24odmFsdWUpIHtcbiAgY29uc3Qgbm9kZSA9IHtcbiAgICB0eXBlOiBcIk51bWJlckxpdGVyYWxUeXBlQW5ub3RhdGlvblwiLFxuICAgIHZhbHVlXG4gIH07XG4gIGNvbnN0IGRlZnMgPSBOT0RFX0ZJRUxEUy5OdW1iZXJMaXRlcmFsVHlwZUFubm90YXRpb247XG4gIHZhbGlkYXRlKGRlZnMudmFsdWUsIG5vZGUsIFwidmFsdWVcIiwgdmFsdWUpO1xuICByZXR1cm4gbm9kZTtcbn1cbmZ1bmN0aW9uIG51bWJlclR5cGVBbm5vdGF0aW9uKCkge1xuICByZXR1cm4ge1xuICAgIHR5cGU6IFwiTnVtYmVyVHlwZUFubm90YXRpb25cIlxuICB9O1xufVxuZnVuY3Rpb24gb2JqZWN0VHlwZUFubm90YXRpb24ocHJvcGVydGllcywgaW5kZXhlcnMgPSBbXSwgY2FsbFByb3BlcnRpZXMgPSBbXSwgaW50ZXJuYWxTbG90cyA9IFtdLCBleGFjdCA9IGZhbHNlKSB7XG4gIGNvbnN0IG5vZGUgPSB7XG4gICAgdHlwZTogXCJPYmplY3RUeXBlQW5ub3RhdGlvblwiLFxuICAgIHByb3BlcnRpZXMsXG4gICAgaW5kZXhlcnMsXG4gICAgY2FsbFByb3BlcnRpZXMsXG4gICAgaW50ZXJuYWxTbG90cyxcbiAgICBleGFjdFxuICB9O1xuICBjb25zdCBkZWZzID0gTk9ERV9GSUVMRFMuT2JqZWN0VHlwZUFubm90YXRpb247XG4gIHZhbGlkYXRlKGRlZnMucHJvcGVydGllcywgbm9kZSwgXCJwcm9wZXJ0aWVzXCIsIHByb3BlcnRpZXMsIDEpO1xuICB2YWxpZGF0ZShkZWZzLmluZGV4ZXJzLCBub2RlLCBcImluZGV4ZXJzXCIsIGluZGV4ZXJzLCAxKTtcbiAgdmFsaWRhdGUoZGVmcy5jYWxsUHJvcGVydGllcywgbm9kZSwgXCJjYWxsUHJvcGVydGllc1wiLCBjYWxsUHJvcGVydGllcywgMSk7XG4gIHZhbGlkYXRlKGRlZnMuaW50ZXJuYWxTbG90cywgbm9kZSwgXCJpbnRlcm5hbFNsb3RzXCIsIGludGVybmFsU2xvdHMsIDEpO1xuICB2YWxpZGF0ZShkZWZzLmV4YWN0LCBub2RlLCBcImV4YWN0XCIsIGV4YWN0KTtcbiAgcmV0dXJuIG5vZGU7XG59XG5mdW5jdGlvbiBvYmplY3RUeXBlSW50ZXJuYWxTbG90KGlkLCB2YWx1ZSwgb3B0aW9uYWwsIF9zdGF0aWMsIG1ldGhvZCkge1xuICBjb25zdCBub2RlID0ge1xuICAgIHR5cGU6IFwiT2JqZWN0VHlwZUludGVybmFsU2xvdFwiLFxuICAgIGlkLFxuICAgIHZhbHVlLFxuICAgIG9wdGlvbmFsLFxuICAgIHN0YXRpYzogX3N0YXRpYyxcbiAgICBtZXRob2RcbiAgfTtcbiAgY29uc3QgZGVmcyA9IE5PREVfRklFTERTLk9iamVjdFR5cGVJbnRlcm5hbFNsb3Q7XG4gIHZhbGlkYXRlKGRlZnMuaWQsIG5vZGUsIFwiaWRcIiwgaWQsIDEpO1xuICB2YWxpZGF0ZShkZWZzLnZhbHVlLCBub2RlLCBcInZhbHVlXCIsIHZhbHVlLCAxKTtcbiAgdmFsaWRhdGUoZGVmcy5vcHRpb25hbCwgbm9kZSwgXCJvcHRpb25hbFwiLCBvcHRpb25hbCk7XG4gIHZhbGlkYXRlKGRlZnMuc3RhdGljLCBub2RlLCBcInN0YXRpY1wiLCBfc3RhdGljKTtcbiAgdmFsaWRhdGUoZGVmcy5tZXRob2QsIG5vZGUsIFwibWV0aG9kXCIsIG1ldGhvZCk7XG4gIHJldHVybiBub2RlO1xufVxuZnVuY3Rpb24gb2JqZWN0VHlwZUNhbGxQcm9wZXJ0eSh2YWx1ZSkge1xuICBjb25zdCBub2RlID0ge1xuICAgIHR5cGU6IFwiT2JqZWN0VHlwZUNhbGxQcm9wZXJ0eVwiLFxuICAgIHZhbHVlLFxuICAgIHN0YXRpYzogbnVsbFxuICB9O1xuICBjb25zdCBkZWZzID0gTk9ERV9GSUVMRFMuT2JqZWN0VHlwZUNhbGxQcm9wZXJ0eTtcbiAgdmFsaWRhdGUoZGVmcy52YWx1ZSwgbm9kZSwgXCJ2YWx1ZVwiLCB2YWx1ZSwgMSk7XG4gIHJldHVybiBub2RlO1xufVxuZnVuY3Rpb24gb2JqZWN0VHlwZUluZGV4ZXIoaWQgPSBudWxsLCBrZXksIHZhbHVlLCB2YXJpYW5jZSA9IG51bGwpIHtcbiAgY29uc3Qgbm9kZSA9IHtcbiAgICB0eXBlOiBcIk9iamVjdFR5cGVJbmRleGVyXCIsXG4gICAgaWQsXG4gICAga2V5LFxuICAgIHZhbHVlLFxuICAgIHZhcmlhbmNlLFxuICAgIHN0YXRpYzogbnVsbFxuICB9O1xuICBjb25zdCBkZWZzID0gTk9ERV9GSUVMRFMuT2JqZWN0VHlwZUluZGV4ZXI7XG4gIHZhbGlkYXRlKGRlZnMuaWQsIG5vZGUsIFwiaWRcIiwgaWQsIDEpO1xuICB2YWxpZGF0ZShkZWZzLmtleSwgbm9kZSwgXCJrZXlcIiwga2V5LCAxKTtcbiAgdmFsaWRhdGUoZGVmcy52YWx1ZSwgbm9kZSwgXCJ2YWx1ZVwiLCB2YWx1ZSwgMSk7XG4gIHZhbGlkYXRlKGRlZnMudmFyaWFuY2UsIG5vZGUsIFwidmFyaWFuY2VcIiwgdmFyaWFuY2UsIDEpO1xuICByZXR1cm4gbm9kZTtcbn1cbmZ1bmN0aW9uIG9iamVjdFR5cGVQcm9wZXJ0eShrZXksIHZhbHVlLCB2YXJpYW5jZSA9IG51bGwpIHtcbiAgY29uc3Qgbm9kZSA9IHtcbiAgICB0eXBlOiBcIk9iamVjdFR5cGVQcm9wZXJ0eVwiLFxuICAgIGtleSxcbiAgICB2YWx1ZSxcbiAgICB2YXJpYW5jZSxcbiAgICBraW5kOiBudWxsLFxuICAgIG1ldGhvZDogbnVsbCxcbiAgICBvcHRpb25hbDogbnVsbCxcbiAgICBwcm90bzogbnVsbCxcbiAgICBzdGF0aWM6IG51bGxcbiAgfTtcbiAgY29uc3QgZGVmcyA9IE5PREVfRklFTERTLk9iamVjdFR5cGVQcm9wZXJ0eTtcbiAgdmFsaWRhdGUoZGVmcy5rZXksIG5vZGUsIFwia2V5XCIsIGtleSwgMSk7XG4gIHZhbGlkYXRlKGRlZnMudmFsdWUsIG5vZGUsIFwidmFsdWVcIiwgdmFsdWUsIDEpO1xuICB2YWxpZGF0ZShkZWZzLnZhcmlhbmNlLCBub2RlLCBcInZhcmlhbmNlXCIsIHZhcmlhbmNlLCAxKTtcbiAgcmV0dXJuIG5vZGU7XG59XG5mdW5jdGlvbiBvYmplY3RUeXBlU3ByZWFkUHJvcGVydHkoYXJndW1lbnQpIHtcbiAgY29uc3Qgbm9kZSA9IHtcbiAgICB0eXBlOiBcIk9iamVjdFR5cGVTcHJlYWRQcm9wZXJ0eVwiLFxuICAgIGFyZ3VtZW50XG4gIH07XG4gIGNvbnN0IGRlZnMgPSBOT0RFX0ZJRUxEUy5PYmplY3RUeXBlU3ByZWFkUHJvcGVydHk7XG4gIHZhbGlkYXRlKGRlZnMuYXJndW1lbnQsIG5vZGUsIFwiYXJndW1lbnRcIiwgYXJndW1lbnQsIDEpO1xuICByZXR1cm4gbm9kZTtcbn1cbmZ1bmN0aW9uIG9wYXF1ZVR5cGUoaWQsIHR5cGVQYXJhbWV0ZXJzID0gbnVsbCwgc3VwZXJ0eXBlID0gbnVsbCwgaW1wbHR5cGUpIHtcbiAgY29uc3Qgbm9kZSA9IHtcbiAgICB0eXBlOiBcIk9wYXF1ZVR5cGVcIixcbiAgICBpZCxcbiAgICB0eXBlUGFyYW1ldGVycyxcbiAgICBzdXBlcnR5cGUsXG4gICAgaW1wbHR5cGVcbiAgfTtcbiAgY29uc3QgZGVmcyA9IE5PREVfRklFTERTLk9wYXF1ZVR5cGU7XG4gIHZhbGlkYXRlKGRlZnMuaWQsIG5vZGUsIFwiaWRcIiwgaWQsIDEpO1xuICB2YWxpZGF0ZShkZWZzLnR5cGVQYXJhbWV0ZXJzLCBub2RlLCBcInR5cGVQYXJhbWV0ZXJzXCIsIHR5cGVQYXJhbWV0ZXJzLCAxKTtcbiAgdmFsaWRhdGUoZGVmcy5zdXBlcnR5cGUsIG5vZGUsIFwic3VwZXJ0eXBlXCIsIHN1cGVydHlwZSwgMSk7XG4gIHZhbGlkYXRlKGRlZnMuaW1wbHR5cGUsIG5vZGUsIFwiaW1wbHR5cGVcIiwgaW1wbHR5cGUsIDEpO1xuICByZXR1cm4gbm9kZTtcbn1cbmZ1bmN0aW9uIHF1YWxpZmllZFR5cGVJZGVudGlmaWVyKGlkLCBxdWFsaWZpY2F0aW9uKSB7XG4gIGNvbnN0IG5vZGUgPSB7XG4gICAgdHlwZTogXCJRdWFsaWZpZWRUeXBlSWRlbnRpZmllclwiLFxuICAgIGlkLFxuICAgIHF1YWxpZmljYXRpb25cbiAgfTtcbiAgY29uc3QgZGVmcyA9IE5PREVfRklFTERTLlF1YWxpZmllZFR5cGVJZGVudGlmaWVyO1xuICB2YWxpZGF0ZShkZWZzLmlkLCBub2RlLCBcImlkXCIsIGlkLCAxKTtcbiAgdmFsaWRhdGUoZGVmcy5xdWFsaWZpY2F0aW9uLCBub2RlLCBcInF1YWxpZmljYXRpb25cIiwgcXVhbGlmaWNhdGlvbiwgMSk7XG4gIHJldHVybiBub2RlO1xufVxuZnVuY3Rpb24gc3RyaW5nTGl0ZXJhbFR5cGVBbm5vdGF0aW9uKHZhbHVlKSB7XG4gIGNvbnN0IG5vZGUgPSB7XG4gICAgdHlwZTogXCJTdHJpbmdMaXRlcmFsVHlwZUFubm90YXRpb25cIixcbiAgICB2YWx1ZVxuICB9O1xuICBjb25zdCBkZWZzID0gTk9ERV9GSUVMRFMuU3RyaW5nTGl0ZXJhbFR5cGVBbm5vdGF0aW9uO1xuICB2YWxpZGF0ZShkZWZzLnZhbHVlLCBub2RlLCBcInZhbHVlXCIsIHZhbHVlKTtcbiAgcmV0dXJuIG5vZGU7XG59XG5mdW5jdGlvbiBzdHJpbmdUeXBlQW5ub3RhdGlvbigpIHtcbiAgcmV0dXJuIHtcbiAgICB0eXBlOiBcIlN0cmluZ1R5cGVBbm5vdGF0aW9uXCJcbiAgfTtcbn1cbmZ1bmN0aW9uIHN5bWJvbFR5cGVBbm5vdGF0aW9uKCkge1xuICByZXR1cm4ge1xuICAgIHR5cGU6IFwiU3ltYm9sVHlwZUFubm90YXRpb25cIlxuICB9O1xufVxuZnVuY3Rpb24gdGhpc1R5cGVBbm5vdGF0aW9uKCkge1xuICByZXR1cm4ge1xuICAgIHR5cGU6IFwiVGhpc1R5cGVBbm5vdGF0aW9uXCJcbiAgfTtcbn1cbmZ1bmN0aW9uIHR1cGxlVHlwZUFubm90YXRpb24odHlwZXMpIHtcbiAgY29uc3Qgbm9kZSA9IHtcbiAgICB0eXBlOiBcIlR1cGxlVHlwZUFubm90YXRpb25cIixcbiAgICB0eXBlc1xuICB9O1xuICBjb25zdCBkZWZzID0gTk9ERV9GSUVMRFMuVHVwbGVUeXBlQW5ub3RhdGlvbjtcbiAgdmFsaWRhdGUoZGVmcy50eXBlcywgbm9kZSwgXCJ0eXBlc1wiLCB0eXBlcywgMSk7XG4gIHJldHVybiBub2RlO1xufVxuZnVuY3Rpb24gdHlwZW9mVHlwZUFubm90YXRpb24oYXJndW1lbnQpIHtcbiAgY29uc3Qgbm9kZSA9IHtcbiAgICB0eXBlOiBcIlR5cGVvZlR5cGVBbm5vdGF0aW9uXCIsXG4gICAgYXJndW1lbnRcbiAgfTtcbiAgY29uc3QgZGVmcyA9IE5PREVfRklFTERTLlR5cGVvZlR5cGVBbm5vdGF0aW9uO1xuICB2YWxpZGF0ZShkZWZzLmFyZ3VtZW50LCBub2RlLCBcImFyZ3VtZW50XCIsIGFyZ3VtZW50LCAxKTtcbiAgcmV0dXJuIG5vZGU7XG59XG5mdW5jdGlvbiB0eXBlQWxpYXMoaWQsIHR5cGVQYXJhbWV0ZXJzID0gbnVsbCwgcmlnaHQpIHtcbiAgY29uc3Qgbm9kZSA9IHtcbiAgICB0eXBlOiBcIlR5cGVBbGlhc1wiLFxuICAgIGlkLFxuICAgIHR5cGVQYXJhbWV0ZXJzLFxuICAgIHJpZ2h0XG4gIH07XG4gIGNvbnN0IGRlZnMgPSBOT0RFX0ZJRUxEUy5UeXBlQWxpYXM7XG4gIHZhbGlkYXRlKGRlZnMuaWQsIG5vZGUsIFwiaWRcIiwgaWQsIDEpO1xuICB2YWxpZGF0ZShkZWZzLnR5cGVQYXJhbWV0ZXJzLCBub2RlLCBcInR5cGVQYXJhbWV0ZXJzXCIsIHR5cGVQYXJhbWV0ZXJzLCAxKTtcbiAgdmFsaWRhdGUoZGVmcy5yaWdodCwgbm9kZSwgXCJyaWdodFwiLCByaWdodCwgMSk7XG4gIHJldHVybiBub2RlO1xufVxuZnVuY3Rpb24gdHlwZUFubm90YXRpb24odHlwZUFubm90YXRpb24pIHtcbiAgY29uc3Qgbm9kZSA9IHtcbiAgICB0eXBlOiBcIlR5cGVBbm5vdGF0aW9uXCIsXG4gICAgdHlwZUFubm90YXRpb25cbiAgfTtcbiAgY29uc3QgZGVmcyA9IE5PREVfRklFTERTLlR5cGVBbm5vdGF0aW9uO1xuICB2YWxpZGF0ZShkZWZzLnR5cGVBbm5vdGF0aW9uLCBub2RlLCBcInR5cGVBbm5vdGF0aW9uXCIsIHR5cGVBbm5vdGF0aW9uLCAxKTtcbiAgcmV0dXJuIG5vZGU7XG59XG5mdW5jdGlvbiB0eXBlQ2FzdEV4cHJlc3Npb24oZXhwcmVzc2lvbiwgdHlwZUFubm90YXRpb24pIHtcbiAgY29uc3Qgbm9kZSA9IHtcbiAgICB0eXBlOiBcIlR5cGVDYXN0RXhwcmVzc2lvblwiLFxuICAgIGV4cHJlc3Npb24sXG4gICAgdHlwZUFubm90YXRpb25cbiAgfTtcbiAgY29uc3QgZGVmcyA9IE5PREVfRklFTERTLlR5cGVDYXN0RXhwcmVzc2lvbjtcbiAgdmFsaWRhdGUoZGVmcy5leHByZXNzaW9uLCBub2RlLCBcImV4cHJlc3Npb25cIiwgZXhwcmVzc2lvbiwgMSk7XG4gIHZhbGlkYXRlKGRlZnMudHlwZUFubm90YXRpb24sIG5vZGUsIFwidHlwZUFubm90YXRpb25cIiwgdHlwZUFubm90YXRpb24sIDEpO1xuICByZXR1cm4gbm9kZTtcbn1cbmZ1bmN0aW9uIHR5cGVQYXJhbWV0ZXIoYm91bmQgPSBudWxsLCBfZGVmYXVsdCA9IG51bGwsIHZhcmlhbmNlID0gbnVsbCkge1xuICBjb25zdCBub2RlID0ge1xuICAgIHR5cGU6IFwiVHlwZVBhcmFtZXRlclwiLFxuICAgIGJvdW5kLFxuICAgIGRlZmF1bHQ6IF9kZWZhdWx0LFxuICAgIHZhcmlhbmNlLFxuICAgIG5hbWU6IG51bGxcbiAgfTtcbiAgY29uc3QgZGVmcyA9IE5PREVfRklFTERTLlR5cGVQYXJhbWV0ZXI7XG4gIHZhbGlkYXRlKGRlZnMuYm91bmQsIG5vZGUsIFwiYm91bmRcIiwgYm91bmQsIDEpO1xuICB2YWxpZGF0ZShkZWZzLmRlZmF1bHQsIG5vZGUsIFwiZGVmYXVsdFwiLCBfZGVmYXVsdCwgMSk7XG4gIHZhbGlkYXRlKGRlZnMudmFyaWFuY2UsIG5vZGUsIFwidmFyaWFuY2VcIiwgdmFyaWFuY2UsIDEpO1xuICByZXR1cm4gbm9kZTtcbn1cbmZ1bmN0aW9uIHR5cGVQYXJhbWV0ZXJEZWNsYXJhdGlvbihwYXJhbXMpIHtcbiAgY29uc3Qgbm9kZSA9IHtcbiAgICB0eXBlOiBcIlR5cGVQYXJhbWV0ZXJEZWNsYXJhdGlvblwiLFxuICAgIHBhcmFtc1xuICB9O1xuICBjb25zdCBkZWZzID0gTk9ERV9GSUVMRFMuVHlwZVBhcmFtZXRlckRlY2xhcmF0aW9uO1xuICB2YWxpZGF0ZShkZWZzLnBhcmFtcywgbm9kZSwgXCJwYXJhbXNcIiwgcGFyYW1zLCAxKTtcbiAgcmV0dXJuIG5vZGU7XG59XG5mdW5jdGlvbiB0eXBlUGFyYW1ldGVySW5zdGFudGlhdGlvbihwYXJhbXMpIHtcbiAgY29uc3Qgbm9kZSA9IHtcbiAgICB0eXBlOiBcIlR5cGVQYXJhbWV0ZXJJbnN0YW50aWF0aW9uXCIsXG4gICAgcGFyYW1zXG4gIH07XG4gIGNvbnN0IGRlZnMgPSBOT0RFX0ZJRUxEUy5UeXBlUGFyYW1ldGVySW5zdGFudGlhdGlvbjtcbiAgdmFsaWRhdGUoZGVmcy5wYXJhbXMsIG5vZGUsIFwicGFyYW1zXCIsIHBhcmFtcywgMSk7XG4gIHJldHVybiBub2RlO1xufVxuZnVuY3Rpb24gdW5pb25UeXBlQW5ub3RhdGlvbih0eXBlcykge1xuICBjb25zdCBub2RlID0ge1xuICAgIHR5cGU6IFwiVW5pb25UeXBlQW5ub3RhdGlvblwiLFxuICAgIHR5cGVzXG4gIH07XG4gIGNvbnN0IGRlZnMgPSBOT0RFX0ZJRUxEUy5VbmlvblR5cGVBbm5vdGF0aW9uO1xuICB2YWxpZGF0ZShkZWZzLnR5cGVzLCBub2RlLCBcInR5cGVzXCIsIHR5cGVzLCAxKTtcbiAgcmV0dXJuIG5vZGU7XG59XG5mdW5jdGlvbiB2YXJpYW5jZShraW5kKSB7XG4gIGNvbnN0IG5vZGUgPSB7XG4gICAgdHlwZTogXCJWYXJpYW5jZVwiLFxuICAgIGtpbmRcbiAgfTtcbiAgY29uc3QgZGVmcyA9IE5PREVfRklFTERTLlZhcmlhbmNlO1xuICB2YWxpZGF0ZShkZWZzLmtpbmQsIG5vZGUsIFwia2luZFwiLCBraW5kKTtcbiAgcmV0dXJuIG5vZGU7XG59XG5mdW5jdGlvbiB2b2lkVHlwZUFubm90YXRpb24oKSB7XG4gIHJldHVybiB7XG4gICAgdHlwZTogXCJWb2lkVHlwZUFubm90YXRpb25cIlxuICB9O1xufVxuZnVuY3Rpb24gZW51bURlY2xhcmF0aW9uKGlkLCBib2R5KSB7XG4gIGNvbnN0IG5vZGUgPSB7XG4gICAgdHlwZTogXCJFbnVtRGVjbGFyYXRpb25cIixcbiAgICBpZCxcbiAgICBib2R5XG4gIH07XG4gIGNvbnN0IGRlZnMgPSBOT0RFX0ZJRUxEUy5FbnVtRGVjbGFyYXRpb247XG4gIHZhbGlkYXRlKGRlZnMuaWQsIG5vZGUsIFwiaWRcIiwgaWQsIDEpO1xuICB2YWxpZGF0ZShkZWZzLmJvZHksIG5vZGUsIFwiYm9keVwiLCBib2R5LCAxKTtcbiAgcmV0dXJuIG5vZGU7XG59XG5mdW5jdGlvbiBlbnVtQm9vbGVhbkJvZHkobWVtYmVycykge1xuICBjb25zdCBub2RlID0ge1xuICAgIHR5cGU6IFwiRW51bUJvb2xlYW5Cb2R5XCIsXG4gICAgbWVtYmVycyxcbiAgICBleHBsaWNpdFR5cGU6IG51bGwsXG4gICAgaGFzVW5rbm93bk1lbWJlcnM6IG51bGxcbiAgfTtcbiAgY29uc3QgZGVmcyA9IE5PREVfRklFTERTLkVudW1Cb29sZWFuQm9keTtcbiAgdmFsaWRhdGUoZGVmcy5tZW1iZXJzLCBub2RlLCBcIm1lbWJlcnNcIiwgbWVtYmVycywgMSk7XG4gIHJldHVybiBub2RlO1xufVxuZnVuY3Rpb24gZW51bU51bWJlckJvZHkobWVtYmVycykge1xuICBjb25zdCBub2RlID0ge1xuICAgIHR5cGU6IFwiRW51bU51bWJlckJvZHlcIixcbiAgICBtZW1iZXJzLFxuICAgIGV4cGxpY2l0VHlwZTogbnVsbCxcbiAgICBoYXNVbmtub3duTWVtYmVyczogbnVsbFxuICB9O1xuICBjb25zdCBkZWZzID0gTk9ERV9GSUVMRFMuRW51bU51bWJlckJvZHk7XG4gIHZhbGlkYXRlKGRlZnMubWVtYmVycywgbm9kZSwgXCJtZW1iZXJzXCIsIG1lbWJlcnMsIDEpO1xuICByZXR1cm4gbm9kZTtcbn1cbmZ1bmN0aW9uIGVudW1TdHJpbmdCb2R5KG1lbWJlcnMpIHtcbiAgY29uc3Qgbm9kZSA9IHtcbiAgICB0eXBlOiBcIkVudW1TdHJpbmdCb2R5XCIsXG4gICAgbWVtYmVycyxcbiAgICBleHBsaWNpdFR5cGU6IG51bGwsXG4gICAgaGFzVW5rbm93bk1lbWJlcnM6IG51bGxcbiAgfTtcbiAgY29uc3QgZGVmcyA9IE5PREVfRklFTERTLkVudW1TdHJpbmdCb2R5O1xuICB2YWxpZGF0ZShkZWZzLm1lbWJlcnMsIG5vZGUsIFwibWVtYmVyc1wiLCBtZW1iZXJzLCAxKTtcbiAgcmV0dXJuIG5vZGU7XG59XG5mdW5jdGlvbiBlbnVtU3ltYm9sQm9keShtZW1iZXJzKSB7XG4gIGNvbnN0IG5vZGUgPSB7XG4gICAgdHlwZTogXCJFbnVtU3ltYm9sQm9keVwiLFxuICAgIG1lbWJlcnMsXG4gICAgaGFzVW5rbm93bk1lbWJlcnM6IG51bGxcbiAgfTtcbiAgY29uc3QgZGVmcyA9IE5PREVfRklFTERTLkVudW1TeW1ib2xCb2R5O1xuICB2YWxpZGF0ZShkZWZzLm1lbWJlcnMsIG5vZGUsIFwibWVtYmVyc1wiLCBtZW1iZXJzLCAxKTtcbiAgcmV0dXJuIG5vZGU7XG59XG5mdW5jdGlvbiBlbnVtQm9vbGVhbk1lbWJlcihpZCkge1xuICBjb25zdCBub2RlID0ge1xuICAgIHR5cGU6IFwiRW51bUJvb2xlYW5NZW1iZXJcIixcbiAgICBpZCxcbiAgICBpbml0OiBudWxsXG4gIH07XG4gIGNvbnN0IGRlZnMgPSBOT0RFX0ZJRUxEUy5FbnVtQm9vbGVhbk1lbWJlcjtcbiAgdmFsaWRhdGUoZGVmcy5pZCwgbm9kZSwgXCJpZFwiLCBpZCwgMSk7XG4gIHJldHVybiBub2RlO1xufVxuZnVuY3Rpb24gZW51bU51bWJlck1lbWJlcihpZCwgaW5pdCkge1xuICBjb25zdCBub2RlID0ge1xuICAgIHR5cGU6IFwiRW51bU51bWJlck1lbWJlclwiLFxuICAgIGlkLFxuICAgIGluaXRcbiAgfTtcbiAgY29uc3QgZGVmcyA9IE5PREVfRklFTERTLkVudW1OdW1iZXJNZW1iZXI7XG4gIHZhbGlkYXRlKGRlZnMuaWQsIG5vZGUsIFwiaWRcIiwgaWQsIDEpO1xuICB2YWxpZGF0ZShkZWZzLmluaXQsIG5vZGUsIFwiaW5pdFwiLCBpbml0LCAxKTtcbiAgcmV0dXJuIG5vZGU7XG59XG5mdW5jdGlvbiBlbnVtU3RyaW5nTWVtYmVyKGlkLCBpbml0KSB7XG4gIGNvbnN0IG5vZGUgPSB7XG4gICAgdHlwZTogXCJFbnVtU3RyaW5nTWVtYmVyXCIsXG4gICAgaWQsXG4gICAgaW5pdFxuICB9O1xuICBjb25zdCBkZWZzID0gTk9ERV9GSUVMRFMuRW51bVN0cmluZ01lbWJlcjtcbiAgdmFsaWRhdGUoZGVmcy5pZCwgbm9kZSwgXCJpZFwiLCBpZCwgMSk7XG4gIHZhbGlkYXRlKGRlZnMuaW5pdCwgbm9kZSwgXCJpbml0XCIsIGluaXQsIDEpO1xuICByZXR1cm4gbm9kZTtcbn1cbmZ1bmN0aW9uIGVudW1EZWZhdWx0ZWRNZW1iZXIoaWQpIHtcbiAgY29uc3Qgbm9kZSA9IHtcbiAgICB0eXBlOiBcIkVudW1EZWZhdWx0ZWRNZW1iZXJcIixcbiAgICBpZFxuICB9O1xuICBjb25zdCBkZWZzID0gTk9ERV9GSUVMRFMuRW51bURlZmF1bHRlZE1lbWJlcjtcbiAgdmFsaWRhdGUoZGVmcy5pZCwgbm9kZSwgXCJpZFwiLCBpZCwgMSk7XG4gIHJldHVybiBub2RlO1xufVxuZnVuY3Rpb24gaW5kZXhlZEFjY2Vzc1R5cGUob2JqZWN0VHlwZSwgaW5kZXhUeXBlKSB7XG4gIGNvbnN0IG5vZGUgPSB7XG4gICAgdHlwZTogXCJJbmRleGVkQWNjZXNzVHlwZVwiLFxuICAgIG9iamVjdFR5cGUsXG4gICAgaW5kZXhUeXBlXG4gIH07XG4gIGNvbnN0IGRlZnMgPSBOT0RFX0ZJRUxEUy5JbmRleGVkQWNjZXNzVHlwZTtcbiAgdmFsaWRhdGUoZGVmcy5vYmplY3RUeXBlLCBub2RlLCBcIm9iamVjdFR5cGVcIiwgb2JqZWN0VHlwZSwgMSk7XG4gIHZhbGlkYXRlKGRlZnMuaW5kZXhUeXBlLCBub2RlLCBcImluZGV4VHlwZVwiLCBpbmRleFR5cGUsIDEpO1xuICByZXR1cm4gbm9kZTtcbn1cbmZ1bmN0aW9uIG9wdGlvbmFsSW5kZXhlZEFjY2Vzc1R5cGUob2JqZWN0VHlwZSwgaW5kZXhUeXBlKSB7XG4gIGNvbnN0IG5vZGUgPSB7XG4gICAgdHlwZTogXCJPcHRpb25hbEluZGV4ZWRBY2Nlc3NUeXBlXCIsXG4gICAgb2JqZWN0VHlwZSxcbiAgICBpbmRleFR5cGUsXG4gICAgb3B0aW9uYWw6IG51bGxcbiAgfTtcbiAgY29uc3QgZGVmcyA9IE5PREVfRklFTERTLk9wdGlvbmFsSW5kZXhlZEFjY2Vzc1R5cGU7XG4gIHZhbGlkYXRlKGRlZnMub2JqZWN0VHlwZSwgbm9kZSwgXCJvYmplY3RUeXBlXCIsIG9iamVjdFR5cGUsIDEpO1xuICB2YWxpZGF0ZShkZWZzLmluZGV4VHlwZSwgbm9kZSwgXCJpbmRleFR5cGVcIiwgaW5kZXhUeXBlLCAxKTtcbiAgcmV0dXJuIG5vZGU7XG59XG5mdW5jdGlvbiBqc3hBdHRyaWJ1dGUobmFtZSwgdmFsdWUgPSBudWxsKSB7XG4gIGNvbnN0IG5vZGUgPSB7XG4gICAgdHlwZTogXCJKU1hBdHRyaWJ1dGVcIixcbiAgICBuYW1lLFxuICAgIHZhbHVlXG4gIH07XG4gIGNvbnN0IGRlZnMgPSBOT0RFX0ZJRUxEUy5KU1hBdHRyaWJ1dGU7XG4gIHZhbGlkYXRlKGRlZnMubmFtZSwgbm9kZSwgXCJuYW1lXCIsIG5hbWUsIDEpO1xuICB2YWxpZGF0ZShkZWZzLnZhbHVlLCBub2RlLCBcInZhbHVlXCIsIHZhbHVlLCAxKTtcbiAgcmV0dXJuIG5vZGU7XG59XG5mdW5jdGlvbiBqc3hDbG9zaW5nRWxlbWVudChuYW1lKSB7XG4gIGNvbnN0IG5vZGUgPSB7XG4gICAgdHlwZTogXCJKU1hDbG9zaW5nRWxlbWVudFwiLFxuICAgIG5hbWVcbiAgfTtcbiAgY29uc3QgZGVmcyA9IE5PREVfRklFTERTLkpTWENsb3NpbmdFbGVtZW50O1xuICB2YWxpZGF0ZShkZWZzLm5hbWUsIG5vZGUsIFwibmFtZVwiLCBuYW1lLCAxKTtcbiAgcmV0dXJuIG5vZGU7XG59XG5mdW5jdGlvbiBqc3hFbGVtZW50KG9wZW5pbmdFbGVtZW50LCBjbG9zaW5nRWxlbWVudCA9IG51bGwsIGNoaWxkcmVuLCBzZWxmQ2xvc2luZyA9IG51bGwpIHtcbiAgY29uc3Qgbm9kZSA9IHtcbiAgICB0eXBlOiBcIkpTWEVsZW1lbnRcIixcbiAgICBvcGVuaW5nRWxlbWVudCxcbiAgICBjbG9zaW5nRWxlbWVudCxcbiAgICBjaGlsZHJlbixcbiAgICBzZWxmQ2xvc2luZ1xuICB9O1xuICBjb25zdCBkZWZzID0gTk9ERV9GSUVMRFMuSlNYRWxlbWVudDtcbiAgdmFsaWRhdGUoZGVmcy5vcGVuaW5nRWxlbWVudCwgbm9kZSwgXCJvcGVuaW5nRWxlbWVudFwiLCBvcGVuaW5nRWxlbWVudCwgMSk7XG4gIHZhbGlkYXRlKGRlZnMuY2xvc2luZ0VsZW1lbnQsIG5vZGUsIFwiY2xvc2luZ0VsZW1lbnRcIiwgY2xvc2luZ0VsZW1lbnQsIDEpO1xuICB2YWxpZGF0ZShkZWZzLmNoaWxkcmVuLCBub2RlLCBcImNoaWxkcmVuXCIsIGNoaWxkcmVuLCAxKTtcbiAgdmFsaWRhdGUoZGVmcy5zZWxmQ2xvc2luZywgbm9kZSwgXCJzZWxmQ2xvc2luZ1wiLCBzZWxmQ2xvc2luZyk7XG4gIHJldHVybiBub2RlO1xufVxuZnVuY3Rpb24ganN4RW1wdHlFeHByZXNzaW9uKCkge1xuICByZXR1cm4ge1xuICAgIHR5cGU6IFwiSlNYRW1wdHlFeHByZXNzaW9uXCJcbiAgfTtcbn1cbmZ1bmN0aW9uIGpzeEV4cHJlc3Npb25Db250YWluZXIoZXhwcmVzc2lvbikge1xuICBjb25zdCBub2RlID0ge1xuICAgIHR5cGU6IFwiSlNYRXhwcmVzc2lvbkNvbnRhaW5lclwiLFxuICAgIGV4cHJlc3Npb25cbiAgfTtcbiAgY29uc3QgZGVmcyA9IE5PREVfRklFTERTLkpTWEV4cHJlc3Npb25Db250YWluZXI7XG4gIHZhbGlkYXRlKGRlZnMuZXhwcmVzc2lvbiwgbm9kZSwgXCJleHByZXNzaW9uXCIsIGV4cHJlc3Npb24sIDEpO1xuICByZXR1cm4gbm9kZTtcbn1cbmZ1bmN0aW9uIGpzeFNwcmVhZENoaWxkKGV4cHJlc3Npb24pIHtcbiAgY29uc3Qgbm9kZSA9IHtcbiAgICB0eXBlOiBcIkpTWFNwcmVhZENoaWxkXCIsXG4gICAgZXhwcmVzc2lvblxuICB9O1xuICBjb25zdCBkZWZzID0gTk9ERV9GSUVMRFMuSlNYU3ByZWFkQ2hpbGQ7XG4gIHZhbGlkYXRlKGRlZnMuZXhwcmVzc2lvbiwgbm9kZSwgXCJleHByZXNzaW9uXCIsIGV4cHJlc3Npb24sIDEpO1xuICByZXR1cm4gbm9kZTtcbn1cbmZ1bmN0aW9uIGpzeElkZW50aWZpZXIobmFtZSkge1xuICBjb25zdCBub2RlID0ge1xuICAgIHR5cGU6IFwiSlNYSWRlbnRpZmllclwiLFxuICAgIG5hbWVcbiAgfTtcbiAgY29uc3QgZGVmcyA9IE5PREVfRklFTERTLkpTWElkZW50aWZpZXI7XG4gIHZhbGlkYXRlKGRlZnMubmFtZSwgbm9kZSwgXCJuYW1lXCIsIG5hbWUpO1xuICByZXR1cm4gbm9kZTtcbn1cbmZ1bmN0aW9uIGpzeE1lbWJlckV4cHJlc3Npb24ob2JqZWN0LCBwcm9wZXJ0eSkge1xuICBjb25zdCBub2RlID0ge1xuICAgIHR5cGU6IFwiSlNYTWVtYmVyRXhwcmVzc2lvblwiLFxuICAgIG9iamVjdCxcbiAgICBwcm9wZXJ0eVxuICB9O1xuICBjb25zdCBkZWZzID0gTk9ERV9GSUVMRFMuSlNYTWVtYmVyRXhwcmVzc2lvbjtcbiAgdmFsaWRhdGUoZGVmcy5vYmplY3QsIG5vZGUsIFwib2JqZWN0XCIsIG9iamVjdCwgMSk7XG4gIHZhbGlkYXRlKGRlZnMucHJvcGVydHksIG5vZGUsIFwicHJvcGVydHlcIiwgcHJvcGVydHksIDEpO1xuICByZXR1cm4gbm9kZTtcbn1cbmZ1bmN0aW9uIGpzeE5hbWVzcGFjZWROYW1lKG5hbWVzcGFjZSwgbmFtZSkge1xuICBjb25zdCBub2RlID0ge1xuICAgIHR5cGU6IFwiSlNYTmFtZXNwYWNlZE5hbWVcIixcbiAgICBuYW1lc3BhY2UsXG4gICAgbmFtZVxuICB9O1xuICBjb25zdCBkZWZzID0gTk9ERV9GSUVMRFMuSlNYTmFtZXNwYWNlZE5hbWU7XG4gIHZhbGlkYXRlKGRlZnMubmFtZXNwYWNlLCBub2RlLCBcIm5hbWVzcGFjZVwiLCBuYW1lc3BhY2UsIDEpO1xuICB2YWxpZGF0ZShkZWZzLm5hbWUsIG5vZGUsIFwibmFtZVwiLCBuYW1lLCAxKTtcbiAgcmV0dXJuIG5vZGU7XG59XG5mdW5jdGlvbiBqc3hPcGVuaW5nRWxlbWVudChuYW1lLCBhdHRyaWJ1dGVzLCBzZWxmQ2xvc2luZyA9IGZhbHNlKSB7XG4gIGNvbnN0IG5vZGUgPSB7XG4gICAgdHlwZTogXCJKU1hPcGVuaW5nRWxlbWVudFwiLFxuICAgIG5hbWUsXG4gICAgYXR0cmlidXRlcyxcbiAgICBzZWxmQ2xvc2luZ1xuICB9O1xuICBjb25zdCBkZWZzID0gTk9ERV9GSUVMRFMuSlNYT3BlbmluZ0VsZW1lbnQ7XG4gIHZhbGlkYXRlKGRlZnMubmFtZSwgbm9kZSwgXCJuYW1lXCIsIG5hbWUsIDEpO1xuICB2YWxpZGF0ZShkZWZzLmF0dHJpYnV0ZXMsIG5vZGUsIFwiYXR0cmlidXRlc1wiLCBhdHRyaWJ1dGVzLCAxKTtcbiAgdmFsaWRhdGUoZGVmcy5zZWxmQ2xvc2luZywgbm9kZSwgXCJzZWxmQ2xvc2luZ1wiLCBzZWxmQ2xvc2luZyk7XG4gIHJldHVybiBub2RlO1xufVxuZnVuY3Rpb24ganN4U3ByZWFkQXR0cmlidXRlKGFyZ3VtZW50KSB7XG4gIGNvbnN0IG5vZGUgPSB7XG4gICAgdHlwZTogXCJKU1hTcHJlYWRBdHRyaWJ1dGVcIixcbiAgICBhcmd1bWVudFxuICB9O1xuICBjb25zdCBkZWZzID0gTk9ERV9GSUVMRFMuSlNYU3ByZWFkQXR0cmlidXRlO1xuICB2YWxpZGF0ZShkZWZzLmFyZ3VtZW50LCBub2RlLCBcImFyZ3VtZW50XCIsIGFyZ3VtZW50LCAxKTtcbiAgcmV0dXJuIG5vZGU7XG59XG5mdW5jdGlvbiBqc3hUZXh0KHZhbHVlKSB7XG4gIGNvbnN0IG5vZGUgPSB7XG4gICAgdHlwZTogXCJKU1hUZXh0XCIsXG4gICAgdmFsdWVcbiAgfTtcbiAgY29uc3QgZGVmcyA9IE5PREVfRklFTERTLkpTWFRleHQ7XG4gIHZhbGlkYXRlKGRlZnMudmFsdWUsIG5vZGUsIFwidmFsdWVcIiwgdmFsdWUpO1xuICByZXR1cm4gbm9kZTtcbn1cbmZ1bmN0aW9uIGpzeEZyYWdtZW50KG9wZW5pbmdGcmFnbWVudCwgY2xvc2luZ0ZyYWdtZW50LCBjaGlsZHJlbikge1xuICBjb25zdCBub2RlID0ge1xuICAgIHR5cGU6IFwiSlNYRnJhZ21lbnRcIixcbiAgICBvcGVuaW5nRnJhZ21lbnQsXG4gICAgY2xvc2luZ0ZyYWdtZW50LFxuICAgIGNoaWxkcmVuXG4gIH07XG4gIGNvbnN0IGRlZnMgPSBOT0RFX0ZJRUxEUy5KU1hGcmFnbWVudDtcbiAgdmFsaWRhdGUoZGVmcy5vcGVuaW5nRnJhZ21lbnQsIG5vZGUsIFwib3BlbmluZ0ZyYWdtZW50XCIsIG9wZW5pbmdGcmFnbWVudCwgMSk7XG4gIHZhbGlkYXRlKGRlZnMuY2xvc2luZ0ZyYWdtZW50LCBub2RlLCBcImNsb3NpbmdGcmFnbWVudFwiLCBjbG9zaW5nRnJhZ21lbnQsIDEpO1xuICB2YWxpZGF0ZShkZWZzLmNoaWxkcmVuLCBub2RlLCBcImNoaWxkcmVuXCIsIGNoaWxkcmVuLCAxKTtcbiAgcmV0dXJuIG5vZGU7XG59XG5mdW5jdGlvbiBqc3hPcGVuaW5nRnJhZ21lbnQoKSB7XG4gIHJldHVybiB7XG4gICAgdHlwZTogXCJKU1hPcGVuaW5nRnJhZ21lbnRcIlxuICB9O1xufVxuZnVuY3Rpb24ganN4Q2xvc2luZ0ZyYWdtZW50KCkge1xuICByZXR1cm4ge1xuICAgIHR5cGU6IFwiSlNYQ2xvc2luZ0ZyYWdtZW50XCJcbiAgfTtcbn1cbmZ1bmN0aW9uIG5vb3AoKSB7XG4gIHJldHVybiB7XG4gICAgdHlwZTogXCJOb29wXCJcbiAgfTtcbn1cbmZ1bmN0aW9uIHBsYWNlaG9sZGVyKGV4cGVjdGVkTm9kZSwgbmFtZSkge1xuICBjb25zdCBub2RlID0ge1xuICAgIHR5cGU6IFwiUGxhY2Vob2xkZXJcIixcbiAgICBleHBlY3RlZE5vZGUsXG4gICAgbmFtZVxuICB9O1xuICBjb25zdCBkZWZzID0gTk9ERV9GSUVMRFMuUGxhY2Vob2xkZXI7XG4gIHZhbGlkYXRlKGRlZnMuZXhwZWN0ZWROb2RlLCBub2RlLCBcImV4cGVjdGVkTm9kZVwiLCBleHBlY3RlZE5vZGUpO1xuICB2YWxpZGF0ZShkZWZzLm5hbWUsIG5vZGUsIFwibmFtZVwiLCBuYW1lLCAxKTtcbiAgcmV0dXJuIG5vZGU7XG59XG5mdW5jdGlvbiB2OEludHJpbnNpY0lkZW50aWZpZXIobmFtZSkge1xuICBjb25zdCBub2RlID0ge1xuICAgIHR5cGU6IFwiVjhJbnRyaW5zaWNJZGVudGlmaWVyXCIsXG4gICAgbmFtZVxuICB9O1xuICBjb25zdCBkZWZzID0gTk9ERV9GSUVMRFMuVjhJbnRyaW5zaWNJZGVudGlmaWVyO1xuICB2YWxpZGF0ZShkZWZzLm5hbWUsIG5vZGUsIFwibmFtZVwiLCBuYW1lKTtcbiAgcmV0dXJuIG5vZGU7XG59XG5mdW5jdGlvbiBhcmd1bWVudFBsYWNlaG9sZGVyKCkge1xuICByZXR1cm4ge1xuICAgIHR5cGU6IFwiQXJndW1lbnRQbGFjZWhvbGRlclwiXG4gIH07XG59XG5mdW5jdGlvbiBiaW5kRXhwcmVzc2lvbihvYmplY3QsIGNhbGxlZSkge1xuICBjb25zdCBub2RlID0ge1xuICAgIHR5cGU6IFwiQmluZEV4cHJlc3Npb25cIixcbiAgICBvYmplY3QsXG4gICAgY2FsbGVlXG4gIH07XG4gIGNvbnN0IGRlZnMgPSBOT0RFX0ZJRUxEUy5CaW5kRXhwcmVzc2lvbjtcbiAgdmFsaWRhdGUoZGVmcy5vYmplY3QsIG5vZGUsIFwib2JqZWN0XCIsIG9iamVjdCwgMSk7XG4gIHZhbGlkYXRlKGRlZnMuY2FsbGVlLCBub2RlLCBcImNhbGxlZVwiLCBjYWxsZWUsIDEpO1xuICByZXR1cm4gbm9kZTtcbn1cbmZ1bmN0aW9uIGRlY29yYXRvcihleHByZXNzaW9uKSB7XG4gIGNvbnN0IG5vZGUgPSB7XG4gICAgdHlwZTogXCJEZWNvcmF0b3JcIixcbiAgICBleHByZXNzaW9uXG4gIH07XG4gIGNvbnN0IGRlZnMgPSBOT0RFX0ZJRUxEUy5EZWNvcmF0b3I7XG4gIHZhbGlkYXRlKGRlZnMuZXhwcmVzc2lvbiwgbm9kZSwgXCJleHByZXNzaW9uXCIsIGV4cHJlc3Npb24sIDEpO1xuICByZXR1cm4gbm9kZTtcbn1cbmZ1bmN0aW9uIGRvRXhwcmVzc2lvbihib2R5LCBhc3luYyA9IGZhbHNlKSB7XG4gIGNvbnN0IG5vZGUgPSB7XG4gICAgdHlwZTogXCJEb0V4cHJlc3Npb25cIixcbiAgICBib2R5LFxuICAgIGFzeW5jXG4gIH07XG4gIGNvbnN0IGRlZnMgPSBOT0RFX0ZJRUxEUy5Eb0V4cHJlc3Npb247XG4gIHZhbGlkYXRlKGRlZnMuYm9keSwgbm9kZSwgXCJib2R5XCIsIGJvZHksIDEpO1xuICB2YWxpZGF0ZShkZWZzLmFzeW5jLCBub2RlLCBcImFzeW5jXCIsIGFzeW5jKTtcbiAgcmV0dXJuIG5vZGU7XG59XG5mdW5jdGlvbiBleHBvcnREZWZhdWx0U3BlY2lmaWVyKGV4cG9ydGVkKSB7XG4gIGNvbnN0IG5vZGUgPSB7XG4gICAgdHlwZTogXCJFeHBvcnREZWZhdWx0U3BlY2lmaWVyXCIsXG4gICAgZXhwb3J0ZWRcbiAgfTtcbiAgY29uc3QgZGVmcyA9IE5PREVfRklFTERTLkV4cG9ydERlZmF1bHRTcGVjaWZpZXI7XG4gIHZhbGlkYXRlKGRlZnMuZXhwb3J0ZWQsIG5vZGUsIFwiZXhwb3J0ZWRcIiwgZXhwb3J0ZWQsIDEpO1xuICByZXR1cm4gbm9kZTtcbn1cbmZ1bmN0aW9uIHJlY29yZEV4cHJlc3Npb24ocHJvcGVydGllcykge1xuICBjb25zdCBub2RlID0ge1xuICAgIHR5cGU6IFwiUmVjb3JkRXhwcmVzc2lvblwiLFxuICAgIHByb3BlcnRpZXNcbiAgfTtcbiAgY29uc3QgZGVmcyA9IE5PREVfRklFTERTLlJlY29yZEV4cHJlc3Npb247XG4gIHZhbGlkYXRlKGRlZnMucHJvcGVydGllcywgbm9kZSwgXCJwcm9wZXJ0aWVzXCIsIHByb3BlcnRpZXMsIDEpO1xuICByZXR1cm4gbm9kZTtcbn1cbmZ1bmN0aW9uIHR1cGxlRXhwcmVzc2lvbihlbGVtZW50cyA9IFtdKSB7XG4gIGNvbnN0IG5vZGUgPSB7XG4gICAgdHlwZTogXCJUdXBsZUV4cHJlc3Npb25cIixcbiAgICBlbGVtZW50c1xuICB9O1xuICBjb25zdCBkZWZzID0gTk9ERV9GSUVMRFMuVHVwbGVFeHByZXNzaW9uO1xuICB2YWxpZGF0ZShkZWZzLmVsZW1lbnRzLCBub2RlLCBcImVsZW1lbnRzXCIsIGVsZW1lbnRzLCAxKTtcbiAgcmV0dXJuIG5vZGU7XG59XG5mdW5jdGlvbiBkZWNpbWFsTGl0ZXJhbCh2YWx1ZSkge1xuICBjb25zdCBub2RlID0ge1xuICAgIHR5cGU6IFwiRGVjaW1hbExpdGVyYWxcIixcbiAgICB2YWx1ZVxuICB9O1xuICBjb25zdCBkZWZzID0gTk9ERV9GSUVMRFMuRGVjaW1hbExpdGVyYWw7XG4gIHZhbGlkYXRlKGRlZnMudmFsdWUsIG5vZGUsIFwidmFsdWVcIiwgdmFsdWUpO1xuICByZXR1cm4gbm9kZTtcbn1cbmZ1bmN0aW9uIG1vZHVsZUV4cHJlc3Npb24oYm9keSkge1xuICBjb25zdCBub2RlID0ge1xuICAgIHR5cGU6IFwiTW9kdWxlRXhwcmVzc2lvblwiLFxuICAgIGJvZHlcbiAgfTtcbiAgY29uc3QgZGVmcyA9IE5PREVfRklFTERTLk1vZHVsZUV4cHJlc3Npb247XG4gIHZhbGlkYXRlKGRlZnMuYm9keSwgbm9kZSwgXCJib2R5XCIsIGJvZHksIDEpO1xuICByZXR1cm4gbm9kZTtcbn1cbmZ1bmN0aW9uIHRvcGljUmVmZXJlbmNlKCkge1xuICByZXR1cm4ge1xuICAgIHR5cGU6IFwiVG9waWNSZWZlcmVuY2VcIlxuICB9O1xufVxuZnVuY3Rpb24gcGlwZWxpbmVUb3BpY0V4cHJlc3Npb24oZXhwcmVzc2lvbikge1xuICBjb25zdCBub2RlID0ge1xuICAgIHR5cGU6IFwiUGlwZWxpbmVUb3BpY0V4cHJlc3Npb25cIixcbiAgICBleHByZXNzaW9uXG4gIH07XG4gIGNvbnN0IGRlZnMgPSBOT0RFX0ZJRUxEUy5QaXBlbGluZVRvcGljRXhwcmVzc2lvbjtcbiAgdmFsaWRhdGUoZGVmcy5leHByZXNzaW9uLCBub2RlLCBcImV4cHJlc3Npb25cIiwgZXhwcmVzc2lvbiwgMSk7XG4gIHJldHVybiBub2RlO1xufVxuZnVuY3Rpb24gcGlwZWxpbmVCYXJlRnVuY3Rpb24oY2FsbGVlKSB7XG4gIGNvbnN0IG5vZGUgPSB7XG4gICAgdHlwZTogXCJQaXBlbGluZUJhcmVGdW5jdGlvblwiLFxuICAgIGNhbGxlZVxuICB9O1xuICBjb25zdCBkZWZzID0gTk9ERV9GSUVMRFMuUGlwZWxpbmVCYXJlRnVuY3Rpb247XG4gIHZhbGlkYXRlKGRlZnMuY2FsbGVlLCBub2RlLCBcImNhbGxlZVwiLCBjYWxsZWUsIDEpO1xuICByZXR1cm4gbm9kZTtcbn1cbmZ1bmN0aW9uIHBpcGVsaW5lUHJpbWFyeVRvcGljUmVmZXJlbmNlKCkge1xuICByZXR1cm4ge1xuICAgIHR5cGU6IFwiUGlwZWxpbmVQcmltYXJ5VG9waWNSZWZlcmVuY2VcIlxuICB9O1xufVxuZnVuY3Rpb24gdm9pZFBhdHRlcm4oKSB7XG4gIHJldHVybiB7XG4gICAgdHlwZTogXCJWb2lkUGF0dGVyblwiXG4gIH07XG59XG5mdW5jdGlvbiB0c1BhcmFtZXRlclByb3BlcnR5KHBhcmFtZXRlcikge1xuICBjb25zdCBub2RlID0ge1xuICAgIHR5cGU6IFwiVFNQYXJhbWV0ZXJQcm9wZXJ0eVwiLFxuICAgIHBhcmFtZXRlclxuICB9O1xuICBjb25zdCBkZWZzID0gTk9ERV9GSUVMRFMuVFNQYXJhbWV0ZXJQcm9wZXJ0eTtcbiAgdmFsaWRhdGUoZGVmcy5wYXJhbWV0ZXIsIG5vZGUsIFwicGFyYW1ldGVyXCIsIHBhcmFtZXRlciwgMSk7XG4gIHJldHVybiBub2RlO1xufVxuZnVuY3Rpb24gdHNEZWNsYXJlRnVuY3Rpb24oaWQgPSBudWxsLCB0eXBlUGFyYW1ldGVycyA9IG51bGwsIHBhcmFtcywgcmV0dXJuVHlwZSA9IG51bGwpIHtcbiAgY29uc3Qgbm9kZSA9IHtcbiAgICB0eXBlOiBcIlRTRGVjbGFyZUZ1bmN0aW9uXCIsXG4gICAgaWQsXG4gICAgdHlwZVBhcmFtZXRlcnMsXG4gICAgcGFyYW1zLFxuICAgIHJldHVyblR5cGVcbiAgfTtcbiAgY29uc3QgZGVmcyA9IE5PREVfRklFTERTLlRTRGVjbGFyZUZ1bmN0aW9uO1xuICB2YWxpZGF0ZShkZWZzLmlkLCBub2RlLCBcImlkXCIsIGlkLCAxKTtcbiAgdmFsaWRhdGUoZGVmcy50eXBlUGFyYW1ldGVycywgbm9kZSwgXCJ0eXBlUGFyYW1ldGVyc1wiLCB0eXBlUGFyYW1ldGVycywgMSk7XG4gIHZhbGlkYXRlKGRlZnMucGFyYW1zLCBub2RlLCBcInBhcmFtc1wiLCBwYXJhbXMsIDEpO1xuICB2YWxpZGF0ZShkZWZzLnJldHVyblR5cGUsIG5vZGUsIFwicmV0dXJuVHlwZVwiLCByZXR1cm5UeXBlLCAxKTtcbiAgcmV0dXJuIG5vZGU7XG59XG5mdW5jdGlvbiB0c0RlY2xhcmVNZXRob2QoZGVjb3JhdG9ycyA9IG51bGwsIGtleSwgdHlwZVBhcmFtZXRlcnMgPSBudWxsLCBwYXJhbXMsIHJldHVyblR5cGUgPSBudWxsKSB7XG4gIGNvbnN0IG5vZGUgPSB7XG4gICAgdHlwZTogXCJUU0RlY2xhcmVNZXRob2RcIixcbiAgICBkZWNvcmF0b3JzLFxuICAgIGtleSxcbiAgICB0eXBlUGFyYW1ldGVycyxcbiAgICBwYXJhbXMsXG4gICAgcmV0dXJuVHlwZVxuICB9O1xuICBjb25zdCBkZWZzID0gTk9ERV9GSUVMRFMuVFNEZWNsYXJlTWV0aG9kO1xuICB2YWxpZGF0ZShkZWZzLmRlY29yYXRvcnMsIG5vZGUsIFwiZGVjb3JhdG9yc1wiLCBkZWNvcmF0b3JzLCAxKTtcbiAgdmFsaWRhdGUoZGVmcy5rZXksIG5vZGUsIFwia2V5XCIsIGtleSwgMSk7XG4gIHZhbGlkYXRlKGRlZnMudHlwZVBhcmFtZXRlcnMsIG5vZGUsIFwidHlwZVBhcmFtZXRlcnNcIiwgdHlwZVBhcmFtZXRlcnMsIDEpO1xuICB2YWxpZGF0ZShkZWZzLnBhcmFtcywgbm9kZSwgXCJwYXJhbXNcIiwgcGFyYW1zLCAxKTtcbiAgdmFsaWRhdGUoZGVmcy5yZXR1cm5UeXBlLCBub2RlLCBcInJldHVyblR5cGVcIiwgcmV0dXJuVHlwZSwgMSk7XG4gIHJldHVybiBub2RlO1xufVxuZnVuY3Rpb24gdHNRdWFsaWZpZWROYW1lKGxlZnQsIHJpZ2h0KSB7XG4gIGNvbnN0IG5vZGUgPSB7XG4gICAgdHlwZTogXCJUU1F1YWxpZmllZE5hbWVcIixcbiAgICBsZWZ0LFxuICAgIHJpZ2h0XG4gIH07XG4gIGNvbnN0IGRlZnMgPSBOT0RFX0ZJRUxEUy5UU1F1YWxpZmllZE5hbWU7XG4gIHZhbGlkYXRlKGRlZnMubGVmdCwgbm9kZSwgXCJsZWZ0XCIsIGxlZnQsIDEpO1xuICB2YWxpZGF0ZShkZWZzLnJpZ2h0LCBub2RlLCBcInJpZ2h0XCIsIHJpZ2h0LCAxKTtcbiAgcmV0dXJuIG5vZGU7XG59XG5mdW5jdGlvbiB0c0NhbGxTaWduYXR1cmVEZWNsYXJhdGlvbih0eXBlUGFyYW1ldGVycyA9IG51bGwsIHBhcmFtZXRlcnMsIHR5cGVBbm5vdGF0aW9uID0gbnVsbCkge1xuICBjb25zdCBub2RlID0ge1xuICAgIHR5cGU6IFwiVFNDYWxsU2lnbmF0dXJlRGVjbGFyYXRpb25cIixcbiAgICB0eXBlUGFyYW1ldGVycyxcbiAgICBwYXJhbWV0ZXJzLFxuICAgIHR5cGVBbm5vdGF0aW9uXG4gIH07XG4gIGNvbnN0IGRlZnMgPSBOT0RFX0ZJRUxEUy5UU0NhbGxTaWduYXR1cmVEZWNsYXJhdGlvbjtcbiAgdmFsaWRhdGUoZGVmcy50eXBlUGFyYW1ldGVycywgbm9kZSwgXCJ0eXBlUGFyYW1ldGVyc1wiLCB0eXBlUGFyYW1ldGVycywgMSk7XG4gIHZhbGlkYXRlKGRlZnMucGFyYW1ldGVycywgbm9kZSwgXCJwYXJhbWV0ZXJzXCIsIHBhcmFtZXRlcnMsIDEpO1xuICB2YWxpZGF0ZShkZWZzLnR5cGVBbm5vdGF0aW9uLCBub2RlLCBcInR5cGVBbm5vdGF0aW9uXCIsIHR5cGVBbm5vdGF0aW9uLCAxKTtcbiAgcmV0dXJuIG5vZGU7XG59XG5mdW5jdGlvbiB0c0NvbnN0cnVjdFNpZ25hdHVyZURlY2xhcmF0aW9uKHR5cGVQYXJhbWV0ZXJzID0gbnVsbCwgcGFyYW1ldGVycywgdHlwZUFubm90YXRpb24gPSBudWxsKSB7XG4gIGNvbnN0IG5vZGUgPSB7XG4gICAgdHlwZTogXCJUU0NvbnN0cnVjdFNpZ25hdHVyZURlY2xhcmF0aW9uXCIsXG4gICAgdHlwZVBhcmFtZXRlcnMsXG4gICAgcGFyYW1ldGVycyxcbiAgICB0eXBlQW5ub3RhdGlvblxuICB9O1xuICBjb25zdCBkZWZzID0gTk9ERV9GSUVMRFMuVFNDb25zdHJ1Y3RTaWduYXR1cmVEZWNsYXJhdGlvbjtcbiAgdmFsaWRhdGUoZGVmcy50eXBlUGFyYW1ldGVycywgbm9kZSwgXCJ0eXBlUGFyYW1ldGVyc1wiLCB0eXBlUGFyYW1ldGVycywgMSk7XG4gIHZhbGlkYXRlKGRlZnMucGFyYW1ldGVycywgbm9kZSwgXCJwYXJhbWV0ZXJzXCIsIHBhcmFtZXRlcnMsIDEpO1xuICB2YWxpZGF0ZShkZWZzLnR5cGVBbm5vdGF0aW9uLCBub2RlLCBcInR5cGVBbm5vdGF0aW9uXCIsIHR5cGVBbm5vdGF0aW9uLCAxKTtcbiAgcmV0dXJuIG5vZGU7XG59XG5mdW5jdGlvbiB0c1Byb3BlcnR5U2lnbmF0dXJlKGtleSwgdHlwZUFubm90YXRpb24gPSBudWxsKSB7XG4gIGNvbnN0IG5vZGUgPSB7XG4gICAgdHlwZTogXCJUU1Byb3BlcnR5U2lnbmF0dXJlXCIsXG4gICAga2V5LFxuICAgIHR5cGVBbm5vdGF0aW9uXG4gIH07XG4gIGNvbnN0IGRlZnMgPSBOT0RFX0ZJRUxEUy5UU1Byb3BlcnR5U2lnbmF0dXJlO1xuICB2YWxpZGF0ZShkZWZzLmtleSwgbm9kZSwgXCJrZXlcIiwga2V5LCAxKTtcbiAgdmFsaWRhdGUoZGVmcy50eXBlQW5ub3RhdGlvbiwgbm9kZSwgXCJ0eXBlQW5ub3RhdGlvblwiLCB0eXBlQW5ub3RhdGlvbiwgMSk7XG4gIHJldHVybiBub2RlO1xufVxuZnVuY3Rpb24gdHNNZXRob2RTaWduYXR1cmUoa2V5LCB0eXBlUGFyYW1ldGVycyA9IG51bGwsIHBhcmFtZXRlcnMsIHR5cGVBbm5vdGF0aW9uID0gbnVsbCkge1xuICBjb25zdCBub2RlID0ge1xuICAgIHR5cGU6IFwiVFNNZXRob2RTaWduYXR1cmVcIixcbiAgICBrZXksXG4gICAgdHlwZVBhcmFtZXRlcnMsXG4gICAgcGFyYW1ldGVycyxcbiAgICB0eXBlQW5ub3RhdGlvbixcbiAgICBraW5kOiBudWxsXG4gIH07XG4gIGNvbnN0IGRlZnMgPSBOT0RFX0ZJRUxEUy5UU01ldGhvZFNpZ25hdHVyZTtcbiAgdmFsaWRhdGUoZGVmcy5rZXksIG5vZGUsIFwia2V5XCIsIGtleSwgMSk7XG4gIHZhbGlkYXRlKGRlZnMudHlwZVBhcmFtZXRlcnMsIG5vZGUsIFwidHlwZVBhcmFtZXRlcnNcIiwgdHlwZVBhcmFtZXRlcnMsIDEpO1xuICB2YWxpZGF0ZShkZWZzLnBhcmFtZXRlcnMsIG5vZGUsIFwicGFyYW1ldGVyc1wiLCBwYXJhbWV0ZXJzLCAxKTtcbiAgdmFsaWRhdGUoZGVmcy50eXBlQW5ub3RhdGlvbiwgbm9kZSwgXCJ0eXBlQW5ub3RhdGlvblwiLCB0eXBlQW5ub3RhdGlvbiwgMSk7XG4gIHJldHVybiBub2RlO1xufVxuZnVuY3Rpb24gdHNJbmRleFNpZ25hdHVyZShwYXJhbWV0ZXJzLCB0eXBlQW5ub3RhdGlvbiA9IG51bGwpIHtcbiAgY29uc3Qgbm9kZSA9IHtcbiAgICB0eXBlOiBcIlRTSW5kZXhTaWduYXR1cmVcIixcbiAgICBwYXJhbWV0ZXJzLFxuICAgIHR5cGVBbm5vdGF0aW9uXG4gIH07XG4gIGNvbnN0IGRlZnMgPSBOT0RFX0ZJRUxEUy5UU0luZGV4U2lnbmF0dXJlO1xuICB2YWxpZGF0ZShkZWZzLnBhcmFtZXRlcnMsIG5vZGUsIFwicGFyYW1ldGVyc1wiLCBwYXJhbWV0ZXJzLCAxKTtcbiAgdmFsaWRhdGUoZGVmcy50eXBlQW5ub3RhdGlvbiwgbm9kZSwgXCJ0eXBlQW5ub3RhdGlvblwiLCB0eXBlQW5ub3RhdGlvbiwgMSk7XG4gIHJldHVybiBub2RlO1xufVxuZnVuY3Rpb24gdHNBbnlLZXl3b3JkKCkge1xuICByZXR1cm4ge1xuICAgIHR5cGU6IFwiVFNBbnlLZXl3b3JkXCJcbiAgfTtcbn1cbmZ1bmN0aW9uIHRzQm9vbGVhbktleXdvcmQoKSB7XG4gIHJldHVybiB7XG4gICAgdHlwZTogXCJUU0Jvb2xlYW5LZXl3b3JkXCJcbiAgfTtcbn1cbmZ1bmN0aW9uIHRzQmlnSW50S2V5d29yZCgpIHtcbiAgcmV0dXJuIHtcbiAgICB0eXBlOiBcIlRTQmlnSW50S2V5d29yZFwiXG4gIH07XG59XG5mdW5jdGlvbiB0c0ludHJpbnNpY0tleXdvcmQoKSB7XG4gIHJldHVybiB7XG4gICAgdHlwZTogXCJUU0ludHJpbnNpY0tleXdvcmRcIlxuICB9O1xufVxuZnVuY3Rpb24gdHNOZXZlcktleXdvcmQoKSB7XG4gIHJldHVybiB7XG4gICAgdHlwZTogXCJUU05ldmVyS2V5d29yZFwiXG4gIH07XG59XG5mdW5jdGlvbiB0c051bGxLZXl3b3JkKCkge1xuICByZXR1cm4ge1xuICAgIHR5cGU6IFwiVFNOdWxsS2V5d29yZFwiXG4gIH07XG59XG5mdW5jdGlvbiB0c051bWJlcktleXdvcmQoKSB7XG4gIHJldHVybiB7XG4gICAgdHlwZTogXCJUU051bWJlcktleXdvcmRcIlxuICB9O1xufVxuZnVuY3Rpb24gdHNPYmplY3RLZXl3b3JkKCkge1xuICByZXR1cm4ge1xuICAgIHR5cGU6IFwiVFNPYmplY3RLZXl3b3JkXCJcbiAgfTtcbn1cbmZ1bmN0aW9uIHRzU3RyaW5nS2V5d29yZCgpIHtcbiAgcmV0dXJuIHtcbiAgICB0eXBlOiBcIlRTU3RyaW5nS2V5d29yZFwiXG4gIH07XG59XG5mdW5jdGlvbiB0c1N5bWJvbEtleXdvcmQoKSB7XG4gIHJldHVybiB7XG4gICAgdHlwZTogXCJUU1N5bWJvbEtleXdvcmRcIlxuICB9O1xufVxuZnVuY3Rpb24gdHNVbmRlZmluZWRLZXl3b3JkKCkge1xuICByZXR1cm4ge1xuICAgIHR5cGU6IFwiVFNVbmRlZmluZWRLZXl3b3JkXCJcbiAgfTtcbn1cbmZ1bmN0aW9uIHRzVW5rbm93bktleXdvcmQoKSB7XG4gIHJldHVybiB7XG4gICAgdHlwZTogXCJUU1Vua25vd25LZXl3b3JkXCJcbiAgfTtcbn1cbmZ1bmN0aW9uIHRzVm9pZEtleXdvcmQoKSB7XG4gIHJldHVybiB7XG4gICAgdHlwZTogXCJUU1ZvaWRLZXl3b3JkXCJcbiAgfTtcbn1cbmZ1bmN0aW9uIHRzVGhpc1R5cGUoKSB7XG4gIHJldHVybiB7XG4gICAgdHlwZTogXCJUU1RoaXNUeXBlXCJcbiAgfTtcbn1cbmZ1bmN0aW9uIHRzRnVuY3Rpb25UeXBlKHR5cGVQYXJhbWV0ZXJzID0gbnVsbCwgcGFyYW1ldGVycywgdHlwZUFubm90YXRpb24gPSBudWxsKSB7XG4gIGNvbnN0IG5vZGUgPSB7XG4gICAgdHlwZTogXCJUU0Z1bmN0aW9uVHlwZVwiLFxuICAgIHR5cGVQYXJhbWV0ZXJzLFxuICAgIHBhcmFtZXRlcnMsXG4gICAgdHlwZUFubm90YXRpb25cbiAgfTtcbiAgY29uc3QgZGVmcyA9IE5PREVfRklFTERTLlRTRnVuY3Rpb25UeXBlO1xuICB2YWxpZGF0ZShkZWZzLnR5cGVQYXJhbWV0ZXJzLCBub2RlLCBcInR5cGVQYXJhbWV0ZXJzXCIsIHR5cGVQYXJhbWV0ZXJzLCAxKTtcbiAgdmFsaWRhdGUoZGVmcy5wYXJhbWV0ZXJzLCBub2RlLCBcInBhcmFtZXRlcnNcIiwgcGFyYW1ldGVycywgMSk7XG4gIHZhbGlkYXRlKGRlZnMudHlwZUFubm90YXRpb24sIG5vZGUsIFwidHlwZUFubm90YXRpb25cIiwgdHlwZUFubm90YXRpb24sIDEpO1xuICByZXR1cm4gbm9kZTtcbn1cbmZ1bmN0aW9uIHRzQ29uc3RydWN0b3JUeXBlKHR5cGVQYXJhbWV0ZXJzID0gbnVsbCwgcGFyYW1ldGVycywgdHlwZUFubm90YXRpb24gPSBudWxsKSB7XG4gIGNvbnN0IG5vZGUgPSB7XG4gICAgdHlwZTogXCJUU0NvbnN0cnVjdG9yVHlwZVwiLFxuICAgIHR5cGVQYXJhbWV0ZXJzLFxuICAgIHBhcmFtZXRlcnMsXG4gICAgdHlwZUFubm90YXRpb25cbiAgfTtcbiAgY29uc3QgZGVmcyA9IE5PREVfRklFTERTLlRTQ29uc3RydWN0b3JUeXBlO1xuICB2YWxpZGF0ZShkZWZzLnR5cGVQYXJhbWV0ZXJzLCBub2RlLCBcInR5cGVQYXJhbWV0ZXJzXCIsIHR5cGVQYXJhbWV0ZXJzLCAxKTtcbiAgdmFsaWRhdGUoZGVmcy5wYXJhbWV0ZXJzLCBub2RlLCBcInBhcmFtZXRlcnNcIiwgcGFyYW1ldGVycywgMSk7XG4gIHZhbGlkYXRlKGRlZnMudHlwZUFubm90YXRpb24sIG5vZGUsIFwidHlwZUFubm90YXRpb25cIiwgdHlwZUFubm90YXRpb24sIDEpO1xuICByZXR1cm4gbm9kZTtcbn1cbmZ1bmN0aW9uIHRzVHlwZVJlZmVyZW5jZSh0eXBlTmFtZSwgdHlwZVBhcmFtZXRlcnMgPSBudWxsKSB7XG4gIGNvbnN0IG5vZGUgPSB7XG4gICAgdHlwZTogXCJUU1R5cGVSZWZlcmVuY2VcIixcbiAgICB0eXBlTmFtZSxcbiAgICB0eXBlUGFyYW1ldGVyc1xuICB9O1xuICBjb25zdCBkZWZzID0gTk9ERV9GSUVMRFMuVFNUeXBlUmVmZXJlbmNlO1xuICB2YWxpZGF0ZShkZWZzLnR5cGVOYW1lLCBub2RlLCBcInR5cGVOYW1lXCIsIHR5cGVOYW1lLCAxKTtcbiAgdmFsaWRhdGUoZGVmcy50eXBlUGFyYW1ldGVycywgbm9kZSwgXCJ0eXBlUGFyYW1ldGVyc1wiLCB0eXBlUGFyYW1ldGVycywgMSk7XG4gIHJldHVybiBub2RlO1xufVxuZnVuY3Rpb24gdHNUeXBlUHJlZGljYXRlKHBhcmFtZXRlck5hbWUsIHR5cGVBbm5vdGF0aW9uID0gbnVsbCwgYXNzZXJ0cyA9IG51bGwpIHtcbiAgY29uc3Qgbm9kZSA9IHtcbiAgICB0eXBlOiBcIlRTVHlwZVByZWRpY2F0ZVwiLFxuICAgIHBhcmFtZXRlck5hbWUsXG4gICAgdHlwZUFubm90YXRpb24sXG4gICAgYXNzZXJ0c1xuICB9O1xuICBjb25zdCBkZWZzID0gTk9ERV9GSUVMRFMuVFNUeXBlUHJlZGljYXRlO1xuICB2YWxpZGF0ZShkZWZzLnBhcmFtZXRlck5hbWUsIG5vZGUsIFwicGFyYW1ldGVyTmFtZVwiLCBwYXJhbWV0ZXJOYW1lLCAxKTtcbiAgdmFsaWRhdGUoZGVmcy50eXBlQW5ub3RhdGlvbiwgbm9kZSwgXCJ0eXBlQW5ub3RhdGlvblwiLCB0eXBlQW5ub3RhdGlvbiwgMSk7XG4gIHZhbGlkYXRlKGRlZnMuYXNzZXJ0cywgbm9kZSwgXCJhc3NlcnRzXCIsIGFzc2VydHMpO1xuICByZXR1cm4gbm9kZTtcbn1cbmZ1bmN0aW9uIHRzVHlwZVF1ZXJ5KGV4cHJOYW1lLCB0eXBlUGFyYW1ldGVycyA9IG51bGwpIHtcbiAgY29uc3Qgbm9kZSA9IHtcbiAgICB0eXBlOiBcIlRTVHlwZVF1ZXJ5XCIsXG4gICAgZXhwck5hbWUsXG4gICAgdHlwZVBhcmFtZXRlcnNcbiAgfTtcbiAgY29uc3QgZGVmcyA9IE5PREVfRklFTERTLlRTVHlwZVF1ZXJ5O1xuICB2YWxpZGF0ZShkZWZzLmV4cHJOYW1lLCBub2RlLCBcImV4cHJOYW1lXCIsIGV4cHJOYW1lLCAxKTtcbiAgdmFsaWRhdGUoZGVmcy50eXBlUGFyYW1ldGVycywgbm9kZSwgXCJ0eXBlUGFyYW1ldGVyc1wiLCB0eXBlUGFyYW1ldGVycywgMSk7XG4gIHJldHVybiBub2RlO1xufVxuZnVuY3Rpb24gdHNUeXBlTGl0ZXJhbChtZW1iZXJzKSB7XG4gIGNvbnN0IG5vZGUgPSB7XG4gICAgdHlwZTogXCJUU1R5cGVMaXRlcmFsXCIsXG4gICAgbWVtYmVyc1xuICB9O1xuICBjb25zdCBkZWZzID0gTk9ERV9GSUVMRFMuVFNUeXBlTGl0ZXJhbDtcbiAgdmFsaWRhdGUoZGVmcy5tZW1iZXJzLCBub2RlLCBcIm1lbWJlcnNcIiwgbWVtYmVycywgMSk7XG4gIHJldHVybiBub2RlO1xufVxuZnVuY3Rpb24gdHNBcnJheVR5cGUoZWxlbWVudFR5cGUpIHtcbiAgY29uc3Qgbm9kZSA9IHtcbiAgICB0eXBlOiBcIlRTQXJyYXlUeXBlXCIsXG4gICAgZWxlbWVudFR5cGVcbiAgfTtcbiAgY29uc3QgZGVmcyA9IE5PREVfRklFTERTLlRTQXJyYXlUeXBlO1xuICB2YWxpZGF0ZShkZWZzLmVsZW1lbnRUeXBlLCBub2RlLCBcImVsZW1lbnRUeXBlXCIsIGVsZW1lbnRUeXBlLCAxKTtcbiAgcmV0dXJuIG5vZGU7XG59XG5mdW5jdGlvbiB0c1R1cGxlVHlwZShlbGVtZW50VHlwZXMpIHtcbiAgY29uc3Qgbm9kZSA9IHtcbiAgICB0eXBlOiBcIlRTVHVwbGVUeXBlXCIsXG4gICAgZWxlbWVudFR5cGVzXG4gIH07XG4gIGNvbnN0IGRlZnMgPSBOT0RFX0ZJRUxEUy5UU1R1cGxlVHlwZTtcbiAgdmFsaWRhdGUoZGVmcy5lbGVtZW50VHlwZXMsIG5vZGUsIFwiZWxlbWVudFR5cGVzXCIsIGVsZW1lbnRUeXBlcywgMSk7XG4gIHJldHVybiBub2RlO1xufVxuZnVuY3Rpb24gdHNPcHRpb25hbFR5cGUodHlwZUFubm90YXRpb24pIHtcbiAgY29uc3Qgbm9kZSA9IHtcbiAgICB0eXBlOiBcIlRTT3B0aW9uYWxUeXBlXCIsXG4gICAgdHlwZUFubm90YXRpb25cbiAgfTtcbiAgY29uc3QgZGVmcyA9IE5PREVfRklFTERTLlRTT3B0aW9uYWxUeXBlO1xuICB2YWxpZGF0ZShkZWZzLnR5cGVBbm5vdGF0aW9uLCBub2RlLCBcInR5cGVBbm5vdGF0aW9uXCIsIHR5cGVBbm5vdGF0aW9uLCAxKTtcbiAgcmV0dXJuIG5vZGU7XG59XG5mdW5jdGlvbiB0c1Jlc3RUeXBlKHR5cGVBbm5vdGF0aW9uKSB7XG4gIGNvbnN0IG5vZGUgPSB7XG4gICAgdHlwZTogXCJUU1Jlc3RUeXBlXCIsXG4gICAgdHlwZUFubm90YXRpb25cbiAgfTtcbiAgY29uc3QgZGVmcyA9IE5PREVfRklFTERTLlRTUmVzdFR5cGU7XG4gIHZhbGlkYXRlKGRlZnMudHlwZUFubm90YXRpb24sIG5vZGUsIFwidHlwZUFubm90YXRpb25cIiwgdHlwZUFubm90YXRpb24sIDEpO1xuICByZXR1cm4gbm9kZTtcbn1cbmZ1bmN0aW9uIHRzTmFtZWRUdXBsZU1lbWJlcihsYWJlbCwgZWxlbWVudFR5cGUsIG9wdGlvbmFsID0gZmFsc2UpIHtcbiAgY29uc3Qgbm9kZSA9IHtcbiAgICB0eXBlOiBcIlRTTmFtZWRUdXBsZU1lbWJlclwiLFxuICAgIGxhYmVsLFxuICAgIGVsZW1lbnRUeXBlLFxuICAgIG9wdGlvbmFsXG4gIH07XG4gIGNvbnN0IGRlZnMgPSBOT0RFX0ZJRUxEUy5UU05hbWVkVHVwbGVNZW1iZXI7XG4gIHZhbGlkYXRlKGRlZnMubGFiZWwsIG5vZGUsIFwibGFiZWxcIiwgbGFiZWwsIDEpO1xuICB2YWxpZGF0ZShkZWZzLmVsZW1lbnRUeXBlLCBub2RlLCBcImVsZW1lbnRUeXBlXCIsIGVsZW1lbnRUeXBlLCAxKTtcbiAgdmFsaWRhdGUoZGVmcy5vcHRpb25hbCwgbm9kZSwgXCJvcHRpb25hbFwiLCBvcHRpb25hbCk7XG4gIHJldHVybiBub2RlO1xufVxuZnVuY3Rpb24gdHNVbmlvblR5cGUodHlwZXMpIHtcbiAgY29uc3Qgbm9kZSA9IHtcbiAgICB0eXBlOiBcIlRTVW5pb25UeXBlXCIsXG4gICAgdHlwZXNcbiAgfTtcbiAgY29uc3QgZGVmcyA9IE5PREVfRklFTERTLlRTVW5pb25UeXBlO1xuICB2YWxpZGF0ZShkZWZzLnR5cGVzLCBub2RlLCBcInR5cGVzXCIsIHR5cGVzLCAxKTtcbiAgcmV0dXJuIG5vZGU7XG59XG5mdW5jdGlvbiB0c0ludGVyc2VjdGlvblR5cGUodHlwZXMpIHtcbiAgY29uc3Qgbm9kZSA9IHtcbiAgICB0eXBlOiBcIlRTSW50ZXJzZWN0aW9uVHlwZVwiLFxuICAgIHR5cGVzXG4gIH07XG4gIGNvbnN0IGRlZnMgPSBOT0RFX0ZJRUxEUy5UU0ludGVyc2VjdGlvblR5cGU7XG4gIHZhbGlkYXRlKGRlZnMudHlwZXMsIG5vZGUsIFwidHlwZXNcIiwgdHlwZXMsIDEpO1xuICByZXR1cm4gbm9kZTtcbn1cbmZ1bmN0aW9uIHRzQ29uZGl0aW9uYWxUeXBlKGNoZWNrVHlwZSwgZXh0ZW5kc1R5cGUsIHRydWVUeXBlLCBmYWxzZVR5cGUpIHtcbiAgY29uc3Qgbm9kZSA9IHtcbiAgICB0eXBlOiBcIlRTQ29uZGl0aW9uYWxUeXBlXCIsXG4gICAgY2hlY2tUeXBlLFxuICAgIGV4dGVuZHNUeXBlLFxuICAgIHRydWVUeXBlLFxuICAgIGZhbHNlVHlwZVxuICB9O1xuICBjb25zdCBkZWZzID0gTk9ERV9GSUVMRFMuVFNDb25kaXRpb25hbFR5cGU7XG4gIHZhbGlkYXRlKGRlZnMuY2hlY2tUeXBlLCBub2RlLCBcImNoZWNrVHlwZVwiLCBjaGVja1R5cGUsIDEpO1xuICB2YWxpZGF0ZShkZWZzLmV4dGVuZHNUeXBlLCBub2RlLCBcImV4dGVuZHNUeXBlXCIsIGV4dGVuZHNUeXBlLCAxKTtcbiAgdmFsaWRhdGUoZGVmcy50cnVlVHlwZSwgbm9kZSwgXCJ0cnVlVHlwZVwiLCB0cnVlVHlwZSwgMSk7XG4gIHZhbGlkYXRlKGRlZnMuZmFsc2VUeXBlLCBub2RlLCBcImZhbHNlVHlwZVwiLCBmYWxzZVR5cGUsIDEpO1xuICByZXR1cm4gbm9kZTtcbn1cbmZ1bmN0aW9uIHRzSW5mZXJUeXBlKHR5cGVQYXJhbWV0ZXIpIHtcbiAgY29uc3Qgbm9kZSA9IHtcbiAgICB0eXBlOiBcIlRTSW5mZXJUeXBlXCIsXG4gICAgdHlwZVBhcmFtZXRlclxuICB9O1xuICBjb25zdCBkZWZzID0gTk9ERV9GSUVMRFMuVFNJbmZlclR5cGU7XG4gIHZhbGlkYXRlKGRlZnMudHlwZVBhcmFtZXRlciwgbm9kZSwgXCJ0eXBlUGFyYW1ldGVyXCIsIHR5cGVQYXJhbWV0ZXIsIDEpO1xuICByZXR1cm4gbm9kZTtcbn1cbmZ1bmN0aW9uIHRzUGFyZW50aGVzaXplZFR5cGUodHlwZUFubm90YXRpb24pIHtcbiAgY29uc3Qgbm9kZSA9IHtcbiAgICB0eXBlOiBcIlRTUGFyZW50aGVzaXplZFR5cGVcIixcbiAgICB0eXBlQW5ub3RhdGlvblxuICB9O1xuICBjb25zdCBkZWZzID0gTk9ERV9GSUVMRFMuVFNQYXJlbnRoZXNpemVkVHlwZTtcbiAgdmFsaWRhdGUoZGVmcy50eXBlQW5ub3RhdGlvbiwgbm9kZSwgXCJ0eXBlQW5ub3RhdGlvblwiLCB0eXBlQW5ub3RhdGlvbiwgMSk7XG4gIHJldHVybiBub2RlO1xufVxuZnVuY3Rpb24gdHNUeXBlT3BlcmF0b3IodHlwZUFubm90YXRpb24sIG9wZXJhdG9yID0gXCJrZXlvZlwiKSB7XG4gIGNvbnN0IG5vZGUgPSB7XG4gICAgdHlwZTogXCJUU1R5cGVPcGVyYXRvclwiLFxuICAgIHR5cGVBbm5vdGF0aW9uLFxuICAgIG9wZXJhdG9yXG4gIH07XG4gIGNvbnN0IGRlZnMgPSBOT0RFX0ZJRUxEUy5UU1R5cGVPcGVyYXRvcjtcbiAgdmFsaWRhdGUoZGVmcy50eXBlQW5ub3RhdGlvbiwgbm9kZSwgXCJ0eXBlQW5ub3RhdGlvblwiLCB0eXBlQW5ub3RhdGlvbiwgMSk7XG4gIHZhbGlkYXRlKGRlZnMub3BlcmF0b3IsIG5vZGUsIFwib3BlcmF0b3JcIiwgb3BlcmF0b3IpO1xuICByZXR1cm4gbm9kZTtcbn1cbmZ1bmN0aW9uIHRzSW5kZXhlZEFjY2Vzc1R5cGUob2JqZWN0VHlwZSwgaW5kZXhUeXBlKSB7XG4gIGNvbnN0IG5vZGUgPSB7XG4gICAgdHlwZTogXCJUU0luZGV4ZWRBY2Nlc3NUeXBlXCIsXG4gICAgb2JqZWN0VHlwZSxcbiAgICBpbmRleFR5cGVcbiAgfTtcbiAgY29uc3QgZGVmcyA9IE5PREVfRklFTERTLlRTSW5kZXhlZEFjY2Vzc1R5cGU7XG4gIHZhbGlkYXRlKGRlZnMub2JqZWN0VHlwZSwgbm9kZSwgXCJvYmplY3RUeXBlXCIsIG9iamVjdFR5cGUsIDEpO1xuICB2YWxpZGF0ZShkZWZzLmluZGV4VHlwZSwgbm9kZSwgXCJpbmRleFR5cGVcIiwgaW5kZXhUeXBlLCAxKTtcbiAgcmV0dXJuIG5vZGU7XG59XG5mdW5jdGlvbiB0c01hcHBlZFR5cGUodHlwZVBhcmFtZXRlciwgdHlwZUFubm90YXRpb24gPSBudWxsLCBuYW1lVHlwZSA9IG51bGwpIHtcbiAgY29uc3Qgbm9kZSA9IHtcbiAgICB0eXBlOiBcIlRTTWFwcGVkVHlwZVwiLFxuICAgIHR5cGVQYXJhbWV0ZXIsXG4gICAgdHlwZUFubm90YXRpb24sXG4gICAgbmFtZVR5cGVcbiAgfTtcbiAgY29uc3QgZGVmcyA9IE5PREVfRklFTERTLlRTTWFwcGVkVHlwZTtcbiAgdmFsaWRhdGUoZGVmcy50eXBlUGFyYW1ldGVyLCBub2RlLCBcInR5cGVQYXJhbWV0ZXJcIiwgdHlwZVBhcmFtZXRlciwgMSk7XG4gIHZhbGlkYXRlKGRlZnMudHlwZUFubm90YXRpb24sIG5vZGUsIFwidHlwZUFubm90YXRpb25cIiwgdHlwZUFubm90YXRpb24sIDEpO1xuICB2YWxpZGF0ZShkZWZzLm5hbWVUeXBlLCBub2RlLCBcIm5hbWVUeXBlXCIsIG5hbWVUeXBlLCAxKTtcbiAgcmV0dXJuIG5vZGU7XG59XG5mdW5jdGlvbiB0c1RlbXBsYXRlTGl0ZXJhbFR5cGUocXVhc2lzLCB0eXBlcykge1xuICBjb25zdCBub2RlID0ge1xuICAgIHR5cGU6IFwiVFNUZW1wbGF0ZUxpdGVyYWxUeXBlXCIsXG4gICAgcXVhc2lzLFxuICAgIHR5cGVzXG4gIH07XG4gIGNvbnN0IGRlZnMgPSBOT0RFX0ZJRUxEUy5UU1RlbXBsYXRlTGl0ZXJhbFR5cGU7XG4gIHZhbGlkYXRlKGRlZnMucXVhc2lzLCBub2RlLCBcInF1YXNpc1wiLCBxdWFzaXMsIDEpO1xuICB2YWxpZGF0ZShkZWZzLnR5cGVzLCBub2RlLCBcInR5cGVzXCIsIHR5cGVzLCAxKTtcbiAgcmV0dXJuIG5vZGU7XG59XG5mdW5jdGlvbiB0c0xpdGVyYWxUeXBlKGxpdGVyYWwpIHtcbiAgY29uc3Qgbm9kZSA9IHtcbiAgICB0eXBlOiBcIlRTTGl0ZXJhbFR5cGVcIixcbiAgICBsaXRlcmFsXG4gIH07XG4gIGNvbnN0IGRlZnMgPSBOT0RFX0ZJRUxEUy5UU0xpdGVyYWxUeXBlO1xuICB2YWxpZGF0ZShkZWZzLmxpdGVyYWwsIG5vZGUsIFwibGl0ZXJhbFwiLCBsaXRlcmFsLCAxKTtcbiAgcmV0dXJuIG5vZGU7XG59XG5mdW5jdGlvbiB0c0V4cHJlc3Npb25XaXRoVHlwZUFyZ3VtZW50cyhleHByZXNzaW9uLCB0eXBlUGFyYW1ldGVycyA9IG51bGwpIHtcbiAgY29uc3Qgbm9kZSA9IHtcbiAgICB0eXBlOiBcIlRTRXhwcmVzc2lvbldpdGhUeXBlQXJndW1lbnRzXCIsXG4gICAgZXhwcmVzc2lvbixcbiAgICB0eXBlUGFyYW1ldGVyc1xuICB9O1xuICBjb25zdCBkZWZzID0gTk9ERV9GSUVMRFMuVFNFeHByZXNzaW9uV2l0aFR5cGVBcmd1bWVudHM7XG4gIHZhbGlkYXRlKGRlZnMuZXhwcmVzc2lvbiwgbm9kZSwgXCJleHByZXNzaW9uXCIsIGV4cHJlc3Npb24sIDEpO1xuICB2YWxpZGF0ZShkZWZzLnR5cGVQYXJhbWV0ZXJzLCBub2RlLCBcInR5cGVQYXJhbWV0ZXJzXCIsIHR5cGVQYXJhbWV0ZXJzLCAxKTtcbiAgcmV0dXJuIG5vZGU7XG59XG5mdW5jdGlvbiB0c0ludGVyZmFjZURlY2xhcmF0aW9uKGlkLCB0eXBlUGFyYW1ldGVycyA9IG51bGwsIF9leHRlbmRzID0gbnVsbCwgYm9keSkge1xuICBjb25zdCBub2RlID0ge1xuICAgIHR5cGU6IFwiVFNJbnRlcmZhY2VEZWNsYXJhdGlvblwiLFxuICAgIGlkLFxuICAgIHR5cGVQYXJhbWV0ZXJzLFxuICAgIGV4dGVuZHM6IF9leHRlbmRzLFxuICAgIGJvZHlcbiAgfTtcbiAgY29uc3QgZGVmcyA9IE5PREVfRklFTERTLlRTSW50ZXJmYWNlRGVjbGFyYXRpb247XG4gIHZhbGlkYXRlKGRlZnMuaWQsIG5vZGUsIFwiaWRcIiwgaWQsIDEpO1xuICB2YWxpZGF0ZShkZWZzLnR5cGVQYXJhbWV0ZXJzLCBub2RlLCBcInR5cGVQYXJhbWV0ZXJzXCIsIHR5cGVQYXJhbWV0ZXJzLCAxKTtcbiAgdmFsaWRhdGUoZGVmcy5leHRlbmRzLCBub2RlLCBcImV4dGVuZHNcIiwgX2V4dGVuZHMsIDEpO1xuICB2YWxpZGF0ZShkZWZzLmJvZHksIG5vZGUsIFwiYm9keVwiLCBib2R5LCAxKTtcbiAgcmV0dXJuIG5vZGU7XG59XG5mdW5jdGlvbiB0c0ludGVyZmFjZUJvZHkoYm9keSkge1xuICBjb25zdCBub2RlID0ge1xuICAgIHR5cGU6IFwiVFNJbnRlcmZhY2VCb2R5XCIsXG4gICAgYm9keVxuICB9O1xuICBjb25zdCBkZWZzID0gTk9ERV9GSUVMRFMuVFNJbnRlcmZhY2VCb2R5O1xuICB2YWxpZGF0ZShkZWZzLmJvZHksIG5vZGUsIFwiYm9keVwiLCBib2R5LCAxKTtcbiAgcmV0dXJuIG5vZGU7XG59XG5mdW5jdGlvbiB0c1R5cGVBbGlhc0RlY2xhcmF0aW9uKGlkLCB0eXBlUGFyYW1ldGVycyA9IG51bGwsIHR5cGVBbm5vdGF0aW9uKSB7XG4gIGNvbnN0IG5vZGUgPSB7XG4gICAgdHlwZTogXCJUU1R5cGVBbGlhc0RlY2xhcmF0aW9uXCIsXG4gICAgaWQsXG4gICAgdHlwZVBhcmFtZXRlcnMsXG4gICAgdHlwZUFubm90YXRpb25cbiAgfTtcbiAgY29uc3QgZGVmcyA9IE5PREVfRklFTERTLlRTVHlwZUFsaWFzRGVjbGFyYXRpb247XG4gIHZhbGlkYXRlKGRlZnMuaWQsIG5vZGUsIFwiaWRcIiwgaWQsIDEpO1xuICB2YWxpZGF0ZShkZWZzLnR5cGVQYXJhbWV0ZXJzLCBub2RlLCBcInR5cGVQYXJhbWV0ZXJzXCIsIHR5cGVQYXJhbWV0ZXJzLCAxKTtcbiAgdmFsaWRhdGUoZGVmcy50eXBlQW5ub3RhdGlvbiwgbm9kZSwgXCJ0eXBlQW5ub3RhdGlvblwiLCB0eXBlQW5ub3RhdGlvbiwgMSk7XG4gIHJldHVybiBub2RlO1xufVxuZnVuY3Rpb24gdHNJbnN0YW50aWF0aW9uRXhwcmVzc2lvbihleHByZXNzaW9uLCB0eXBlUGFyYW1ldGVycyA9IG51bGwpIHtcbiAgY29uc3Qgbm9kZSA9IHtcbiAgICB0eXBlOiBcIlRTSW5zdGFudGlhdGlvbkV4cHJlc3Npb25cIixcbiAgICBleHByZXNzaW9uLFxuICAgIHR5cGVQYXJhbWV0ZXJzXG4gIH07XG4gIGNvbnN0IGRlZnMgPSBOT0RFX0ZJRUxEUy5UU0luc3RhbnRpYXRpb25FeHByZXNzaW9uO1xuICB2YWxpZGF0ZShkZWZzLmV4cHJlc3Npb24sIG5vZGUsIFwiZXhwcmVzc2lvblwiLCBleHByZXNzaW9uLCAxKTtcbiAgdmFsaWRhdGUoZGVmcy50eXBlUGFyYW1ldGVycywgbm9kZSwgXCJ0eXBlUGFyYW1ldGVyc1wiLCB0eXBlUGFyYW1ldGVycywgMSk7XG4gIHJldHVybiBub2RlO1xufVxuZnVuY3Rpb24gdHNBc0V4cHJlc3Npb24oZXhwcmVzc2lvbiwgdHlwZUFubm90YXRpb24pIHtcbiAgY29uc3Qgbm9kZSA9IHtcbiAgICB0eXBlOiBcIlRTQXNFeHByZXNzaW9uXCIsXG4gICAgZXhwcmVzc2lvbixcbiAgICB0eXBlQW5ub3RhdGlvblxuICB9O1xuICBjb25zdCBkZWZzID0gTk9ERV9GSUVMRFMuVFNBc0V4cHJlc3Npb247XG4gIHZhbGlkYXRlKGRlZnMuZXhwcmVzc2lvbiwgbm9kZSwgXCJleHByZXNzaW9uXCIsIGV4cHJlc3Npb24sIDEpO1xuICB2YWxpZGF0ZShkZWZzLnR5cGVBbm5vdGF0aW9uLCBub2RlLCBcInR5cGVBbm5vdGF0aW9uXCIsIHR5cGVBbm5vdGF0aW9uLCAxKTtcbiAgcmV0dXJuIG5vZGU7XG59XG5mdW5jdGlvbiB0c1NhdGlzZmllc0V4cHJlc3Npb24oZXhwcmVzc2lvbiwgdHlwZUFubm90YXRpb24pIHtcbiAgY29uc3Qgbm9kZSA9IHtcbiAgICB0eXBlOiBcIlRTU2F0aXNmaWVzRXhwcmVzc2lvblwiLFxuICAgIGV4cHJlc3Npb24sXG4gICAgdHlwZUFubm90YXRpb25cbiAgfTtcbiAgY29uc3QgZGVmcyA9IE5PREVfRklFTERTLlRTU2F0aXNmaWVzRXhwcmVzc2lvbjtcbiAgdmFsaWRhdGUoZGVmcy5leHByZXNzaW9uLCBub2RlLCBcImV4cHJlc3Npb25cIiwgZXhwcmVzc2lvbiwgMSk7XG4gIHZhbGlkYXRlKGRlZnMudHlwZUFubm90YXRpb24sIG5vZGUsIFwidHlwZUFubm90YXRpb25cIiwgdHlwZUFubm90YXRpb24sIDEpO1xuICByZXR1cm4gbm9kZTtcbn1cbmZ1bmN0aW9uIHRzVHlwZUFzc2VydGlvbih0eXBlQW5ub3RhdGlvbiwgZXhwcmVzc2lvbikge1xuICBjb25zdCBub2RlID0ge1xuICAgIHR5cGU6IFwiVFNUeXBlQXNzZXJ0aW9uXCIsXG4gICAgdHlwZUFubm90YXRpb24sXG4gICAgZXhwcmVzc2lvblxuICB9O1xuICBjb25zdCBkZWZzID0gTk9ERV9GSUVMRFMuVFNUeXBlQXNzZXJ0aW9uO1xuICB2YWxpZGF0ZShkZWZzLnR5cGVBbm5vdGF0aW9uLCBub2RlLCBcInR5cGVBbm5vdGF0aW9uXCIsIHR5cGVBbm5vdGF0aW9uLCAxKTtcbiAgdmFsaWRhdGUoZGVmcy5leHByZXNzaW9uLCBub2RlLCBcImV4cHJlc3Npb25cIiwgZXhwcmVzc2lvbiwgMSk7XG4gIHJldHVybiBub2RlO1xufVxuZnVuY3Rpb24gdHNFbnVtQm9keShtZW1iZXJzKSB7XG4gIGNvbnN0IG5vZGUgPSB7XG4gICAgdHlwZTogXCJUU0VudW1Cb2R5XCIsXG4gICAgbWVtYmVyc1xuICB9O1xuICBjb25zdCBkZWZzID0gTk9ERV9GSUVMRFMuVFNFbnVtQm9keTtcbiAgdmFsaWRhdGUoZGVmcy5tZW1iZXJzLCBub2RlLCBcIm1lbWJlcnNcIiwgbWVtYmVycywgMSk7XG4gIHJldHVybiBub2RlO1xufVxuZnVuY3Rpb24gdHNFbnVtRGVjbGFyYXRpb24oaWQsIG1lbWJlcnMpIHtcbiAgY29uc3Qgbm9kZSA9IHtcbiAgICB0eXBlOiBcIlRTRW51bURlY2xhcmF0aW9uXCIsXG4gICAgaWQsXG4gICAgbWVtYmVyc1xuICB9O1xuICBjb25zdCBkZWZzID0gTk9ERV9GSUVMRFMuVFNFbnVtRGVjbGFyYXRpb247XG4gIHZhbGlkYXRlKGRlZnMuaWQsIG5vZGUsIFwiaWRcIiwgaWQsIDEpO1xuICB2YWxpZGF0ZShkZWZzLm1lbWJlcnMsIG5vZGUsIFwibWVtYmVyc1wiLCBtZW1iZXJzLCAxKTtcbiAgcmV0dXJuIG5vZGU7XG59XG5mdW5jdGlvbiB0c0VudW1NZW1iZXIoaWQsIGluaXRpYWxpemVyID0gbnVsbCkge1xuICBjb25zdCBub2RlID0ge1xuICAgIHR5cGU6IFwiVFNFbnVtTWVtYmVyXCIsXG4gICAgaWQsXG4gICAgaW5pdGlhbGl6ZXJcbiAgfTtcbiAgY29uc3QgZGVmcyA9IE5PREVfRklFTERTLlRTRW51bU1lbWJlcjtcbiAgdmFsaWRhdGUoZGVmcy5pZCwgbm9kZSwgXCJpZFwiLCBpZCwgMSk7XG4gIHZhbGlkYXRlKGRlZnMuaW5pdGlhbGl6ZXIsIG5vZGUsIFwiaW5pdGlhbGl6ZXJcIiwgaW5pdGlhbGl6ZXIsIDEpO1xuICByZXR1cm4gbm9kZTtcbn1cbmZ1bmN0aW9uIHRzTW9kdWxlRGVjbGFyYXRpb24oaWQsIGJvZHkpIHtcbiAgY29uc3Qgbm9kZSA9IHtcbiAgICB0eXBlOiBcIlRTTW9kdWxlRGVjbGFyYXRpb25cIixcbiAgICBpZCxcbiAgICBib2R5LFxuICAgIGtpbmQ6IG51bGxcbiAgfTtcbiAgY29uc3QgZGVmcyA9IE5PREVfRklFTERTLlRTTW9kdWxlRGVjbGFyYXRpb247XG4gIHZhbGlkYXRlKGRlZnMuaWQsIG5vZGUsIFwiaWRcIiwgaWQsIDEpO1xuICB2YWxpZGF0ZShkZWZzLmJvZHksIG5vZGUsIFwiYm9keVwiLCBib2R5LCAxKTtcbiAgcmV0dXJuIG5vZGU7XG59XG5mdW5jdGlvbiB0c01vZHVsZUJsb2NrKGJvZHkpIHtcbiAgY29uc3Qgbm9kZSA9IHtcbiAgICB0eXBlOiBcIlRTTW9kdWxlQmxvY2tcIixcbiAgICBib2R5XG4gIH07XG4gIGNvbnN0IGRlZnMgPSBOT0RFX0ZJRUxEUy5UU01vZHVsZUJsb2NrO1xuICB2YWxpZGF0ZShkZWZzLmJvZHksIG5vZGUsIFwiYm9keVwiLCBib2R5LCAxKTtcbiAgcmV0dXJuIG5vZGU7XG59XG5mdW5jdGlvbiB0c0ltcG9ydFR5cGUoYXJndW1lbnQsIHF1YWxpZmllciA9IG51bGwsIHR5cGVQYXJhbWV0ZXJzID0gbnVsbCkge1xuICBjb25zdCBub2RlID0ge1xuICAgIHR5cGU6IFwiVFNJbXBvcnRUeXBlXCIsXG4gICAgYXJndW1lbnQsXG4gICAgcXVhbGlmaWVyLFxuICAgIHR5cGVQYXJhbWV0ZXJzXG4gIH07XG4gIGNvbnN0IGRlZnMgPSBOT0RFX0ZJRUxEUy5UU0ltcG9ydFR5cGU7XG4gIHZhbGlkYXRlKGRlZnMuYXJndW1lbnQsIG5vZGUsIFwiYXJndW1lbnRcIiwgYXJndW1lbnQsIDEpO1xuICB2YWxpZGF0ZShkZWZzLnF1YWxpZmllciwgbm9kZSwgXCJxdWFsaWZpZXJcIiwgcXVhbGlmaWVyLCAxKTtcbiAgdmFsaWRhdGUoZGVmcy50eXBlUGFyYW1ldGVycywgbm9kZSwgXCJ0eXBlUGFyYW1ldGVyc1wiLCB0eXBlUGFyYW1ldGVycywgMSk7XG4gIHJldHVybiBub2RlO1xufVxuZnVuY3Rpb24gdHNJbXBvcnRFcXVhbHNEZWNsYXJhdGlvbihpZCwgbW9kdWxlUmVmZXJlbmNlKSB7XG4gIGNvbnN0IG5vZGUgPSB7XG4gICAgdHlwZTogXCJUU0ltcG9ydEVxdWFsc0RlY2xhcmF0aW9uXCIsXG4gICAgaWQsXG4gICAgbW9kdWxlUmVmZXJlbmNlLFxuICAgIGlzRXhwb3J0OiBudWxsXG4gIH07XG4gIGNvbnN0IGRlZnMgPSBOT0RFX0ZJRUxEUy5UU0ltcG9ydEVxdWFsc0RlY2xhcmF0aW9uO1xuICB2YWxpZGF0ZShkZWZzLmlkLCBub2RlLCBcImlkXCIsIGlkLCAxKTtcbiAgdmFsaWRhdGUoZGVmcy5tb2R1bGVSZWZlcmVuY2UsIG5vZGUsIFwibW9kdWxlUmVmZXJlbmNlXCIsIG1vZHVsZVJlZmVyZW5jZSwgMSk7XG4gIHJldHVybiBub2RlO1xufVxuZnVuY3Rpb24gdHNFeHRlcm5hbE1vZHVsZVJlZmVyZW5jZShleHByZXNzaW9uKSB7XG4gIGNvbnN0IG5vZGUgPSB7XG4gICAgdHlwZTogXCJUU0V4dGVybmFsTW9kdWxlUmVmZXJlbmNlXCIsXG4gICAgZXhwcmVzc2lvblxuICB9O1xuICBjb25zdCBkZWZzID0gTk9ERV9GSUVMRFMuVFNFeHRlcm5hbE1vZHVsZVJlZmVyZW5jZTtcbiAgdmFsaWRhdGUoZGVmcy5leHByZXNzaW9uLCBub2RlLCBcImV4cHJlc3Npb25cIiwgZXhwcmVzc2lvbiwgMSk7XG4gIHJldHVybiBub2RlO1xufVxuZnVuY3Rpb24gdHNOb25OdWxsRXhwcmVzc2lvbihleHByZXNzaW9uKSB7XG4gIGNvbnN0IG5vZGUgPSB7XG4gICAgdHlwZTogXCJUU05vbk51bGxFeHByZXNzaW9uXCIsXG4gICAgZXhwcmVzc2lvblxuICB9O1xuICBjb25zdCBkZWZzID0gTk9ERV9GSUVMRFMuVFNOb25OdWxsRXhwcmVzc2lvbjtcbiAgdmFsaWRhdGUoZGVmcy5leHByZXNzaW9uLCBub2RlLCBcImV4cHJlc3Npb25cIiwgZXhwcmVzc2lvbiwgMSk7XG4gIHJldHVybiBub2RlO1xufVxuZnVuY3Rpb24gdHNFeHBvcnRBc3NpZ25tZW50KGV4cHJlc3Npb24pIHtcbiAgY29uc3Qgbm9kZSA9IHtcbiAgICB0eXBlOiBcIlRTRXhwb3J0QXNzaWdubWVudFwiLFxuICAgIGV4cHJlc3Npb25cbiAgfTtcbiAgY29uc3QgZGVmcyA9IE5PREVfRklFTERTLlRTRXhwb3J0QXNzaWdubWVudDtcbiAgdmFsaWRhdGUoZGVmcy5leHByZXNzaW9uLCBub2RlLCBcImV4cHJlc3Npb25cIiwgZXhwcmVzc2lvbiwgMSk7XG4gIHJldHVybiBub2RlO1xufVxuZnVuY3Rpb24gdHNOYW1lc3BhY2VFeHBvcnREZWNsYXJhdGlvbihpZCkge1xuICBjb25zdCBub2RlID0ge1xuICAgIHR5cGU6IFwiVFNOYW1lc3BhY2VFeHBvcnREZWNsYXJhdGlvblwiLFxuICAgIGlkXG4gIH07XG4gIGNvbnN0IGRlZnMgPSBOT0RFX0ZJRUxEUy5UU05hbWVzcGFjZUV4cG9ydERlY2xhcmF0aW9uO1xuICB2YWxpZGF0ZShkZWZzLmlkLCBub2RlLCBcImlkXCIsIGlkLCAxKTtcbiAgcmV0dXJuIG5vZGU7XG59XG5mdW5jdGlvbiB0c1R5cGVBbm5vdGF0aW9uKHR5cGVBbm5vdGF0aW9uKSB7XG4gIGNvbnN0IG5vZGUgPSB7XG4gICAgdHlwZTogXCJUU1R5cGVBbm5vdGF0aW9uXCIsXG4gICAgdHlwZUFubm90YXRpb25cbiAgfTtcbiAgY29uc3QgZGVmcyA9IE5PREVfRklFTERTLlRTVHlwZUFubm90YXRpb247XG4gIHZhbGlkYXRlKGRlZnMudHlwZUFubm90YXRpb24sIG5vZGUsIFwidHlwZUFubm90YXRpb25cIiwgdHlwZUFubm90YXRpb24sIDEpO1xuICByZXR1cm4gbm9kZTtcbn1cbmZ1bmN0aW9uIHRzVHlwZVBhcmFtZXRlckluc3RhbnRpYXRpb24ocGFyYW1zKSB7XG4gIGNvbnN0IG5vZGUgPSB7XG4gICAgdHlwZTogXCJUU1R5cGVQYXJhbWV0ZXJJbnN0YW50aWF0aW9uXCIsXG4gICAgcGFyYW1zXG4gIH07XG4gIGNvbnN0IGRlZnMgPSBOT0RFX0ZJRUxEUy5UU1R5cGVQYXJhbWV0ZXJJbnN0YW50aWF0aW9uO1xuICB2YWxpZGF0ZShkZWZzLnBhcmFtcywgbm9kZSwgXCJwYXJhbXNcIiwgcGFyYW1zLCAxKTtcbiAgcmV0dXJuIG5vZGU7XG59XG5mdW5jdGlvbiB0c1R5cGVQYXJhbWV0ZXJEZWNsYXJhdGlvbihwYXJhbXMpIHtcbiAgY29uc3Qgbm9kZSA9IHtcbiAgICB0eXBlOiBcIlRTVHlwZVBhcmFtZXRlckRlY2xhcmF0aW9uXCIsXG4gICAgcGFyYW1zXG4gIH07XG4gIGNvbnN0IGRlZnMgPSBOT0RFX0ZJRUxEUy5UU1R5cGVQYXJhbWV0ZXJEZWNsYXJhdGlvbjtcbiAgdmFsaWRhdGUoZGVmcy5wYXJhbXMsIG5vZGUsIFwicGFyYW1zXCIsIHBhcmFtcywgMSk7XG4gIHJldHVybiBub2RlO1xufVxuZnVuY3Rpb24gdHNUeXBlUGFyYW1ldGVyKGNvbnN0cmFpbnQgPSBudWxsLCBfZGVmYXVsdCA9IG51bGwsIG5hbWUpIHtcbiAgY29uc3Qgbm9kZSA9IHtcbiAgICB0eXBlOiBcIlRTVHlwZVBhcmFtZXRlclwiLFxuICAgIGNvbnN0cmFpbnQsXG4gICAgZGVmYXVsdDogX2RlZmF1bHQsXG4gICAgbmFtZVxuICB9O1xuICBjb25zdCBkZWZzID0gTk9ERV9GSUVMRFMuVFNUeXBlUGFyYW1ldGVyO1xuICB2YWxpZGF0ZShkZWZzLmNvbnN0cmFpbnQsIG5vZGUsIFwiY29uc3RyYWludFwiLCBjb25zdHJhaW50LCAxKTtcbiAgdmFsaWRhdGUoZGVmcy5kZWZhdWx0LCBub2RlLCBcImRlZmF1bHRcIiwgX2RlZmF1bHQsIDEpO1xuICB2YWxpZGF0ZShkZWZzLm5hbWUsIG5vZGUsIFwibmFtZVwiLCBuYW1lKTtcbiAgcmV0dXJuIG5vZGU7XG59XG5mdW5jdGlvbiBOdW1iZXJMaXRlcmFsKHZhbHVlKSB7XG4gICgwLCBfZGVwcmVjYXRpb25XYXJuaW5nLmRlZmF1bHQpKFwiTnVtYmVyTGl0ZXJhbFwiLCBcIk51bWVyaWNMaXRlcmFsXCIsIFwiVGhlIG5vZGUgdHlwZSBcIik7XG4gIHJldHVybiBudW1lcmljTGl0ZXJhbCh2YWx1ZSk7XG59XG5mdW5jdGlvbiBSZWdleExpdGVyYWwocGF0dGVybiwgZmxhZ3MgPSBcIlwiKSB7XG4gICgwLCBfZGVwcmVjYXRpb25XYXJuaW5nLmRlZmF1bHQpKFwiUmVnZXhMaXRlcmFsXCIsIFwiUmVnRXhwTGl0ZXJhbFwiLCBcIlRoZSBub2RlIHR5cGUgXCIpO1xuICByZXR1cm4gcmVnRXhwTGl0ZXJhbChwYXR0ZXJuLCBmbGFncyk7XG59XG5mdW5jdGlvbiBSZXN0UHJvcGVydHkoYXJndW1lbnQpIHtcbiAgKDAsIF9kZXByZWNhdGlvbldhcm5pbmcuZGVmYXVsdCkoXCJSZXN0UHJvcGVydHlcIiwgXCJSZXN0RWxlbWVudFwiLCBcIlRoZSBub2RlIHR5cGUgXCIpO1xuICByZXR1cm4gcmVzdEVsZW1lbnQoYXJndW1lbnQpO1xufVxuZnVuY3Rpb24gU3ByZWFkUHJvcGVydHkoYXJndW1lbnQpIHtcbiAgKDAsIF9kZXByZWNhdGlvbldhcm5pbmcuZGVmYXVsdCkoXCJTcHJlYWRQcm9wZXJ0eVwiLCBcIlNwcmVhZEVsZW1lbnRcIiwgXCJUaGUgbm9kZSB0eXBlIFwiKTtcbiAgcmV0dXJuIHNwcmVhZEVsZW1lbnQoYXJndW1lbnQpO1xufVxuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1sb3dlcmNhc2UuanMubWFwXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@babel/types/lib/builders/generated/lowercase.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@babel/types/lib/builders/generated/uppercase.js":
/*!***********************************************************************!*\
  !*** ./node_modules/@babel/types/lib/builders/generated/uppercase.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports.JSXIdentifier = exports.JSXFragment = exports.JSXExpressionContainer = exports.JSXEmptyExpression = exports.JSXElement = exports.JSXClosingFragment = exports.JSXClosingElement = exports.JSXAttribute = exports.IntersectionTypeAnnotation = exports.InterpreterDirective = exports.InterfaceTypeAnnotation = exports.InterfaceExtends = exports.InterfaceDeclaration = exports.InferredPredicate = exports.IndexedAccessType = exports.ImportSpecifier = exports.ImportNamespaceSpecifier = exports.ImportExpression = exports.ImportDefaultSpecifier = exports.ImportDeclaration = exports.ImportAttribute = exports.Import = exports.IfStatement = exports.Identifier = exports.GenericTypeAnnotation = exports.FunctionTypeParam = exports.FunctionTypeAnnotation = exports.FunctionExpression = exports.FunctionDeclaration = exports.ForStatement = exports.ForOfStatement = exports.ForInStatement = exports.File = exports.ExpressionStatement = exports.ExportSpecifier = exports.ExportNamespaceSpecifier = exports.ExportNamedDeclaration = exports.ExportDefaultSpecifier = exports.ExportDefaultDeclaration = exports.ExportAllDeclaration = exports.ExistsTypeAnnotation = exports.EnumSymbolBody = exports.EnumStringMember = exports.EnumStringBody = exports.EnumNumberMember = exports.EnumNumberBody = exports.EnumDefaultedMember = exports.EnumDeclaration = exports.EnumBooleanMember = exports.EnumBooleanBody = exports.EmptyTypeAnnotation = exports.EmptyStatement = exports.DoWhileStatement = exports.DoExpression = exports.DirectiveLiteral = exports.Directive = exports.Decorator = exports.DeclaredPredicate = exports.DeclareVariable = exports.DeclareTypeAlias = exports.DeclareOpaqueType = exports.DeclareModuleExports = exports.DeclareModule = exports.DeclareInterface = exports.DeclareFunction = exports.DeclareExportDeclaration = exports.DeclareExportAllDeclaration = exports.DeclareClass = exports.DecimalLiteral = exports.DebuggerStatement = exports.ContinueStatement = exports.ConditionalExpression = exports.ClassProperty = exports.ClassPrivateProperty = exports.ClassPrivateMethod = exports.ClassMethod = exports.ClassImplements = exports.ClassExpression = exports.ClassDeclaration = exports.ClassBody = exports.ClassAccessorProperty = exports.CatchClause = exports.CallExpression = exports.BreakStatement = exports.BooleanTypeAnnotation = exports.BooleanLiteralTypeAnnotation = exports.BooleanLiteral = exports.BlockStatement = exports.BindExpression = exports.BinaryExpression = exports.BigIntLiteral = exports.AwaitExpression = exports.AssignmentPattern = exports.AssignmentExpression = exports.ArrowFunctionExpression = exports.ArrayTypeAnnotation = exports.ArrayPattern = exports.ArrayExpression = exports.ArgumentPlaceholder = exports.AnyTypeAnnotation = void 0;\nexports.TSNumberKeyword = exports.TSNullKeyword = exports.TSNonNullExpression = exports.TSNeverKeyword = exports.TSNamespaceExportDeclaration = exports.TSNamedTupleMember = exports.TSModuleDeclaration = exports.TSModuleBlock = exports.TSMethodSignature = exports.TSMappedType = exports.TSLiteralType = exports.TSIntrinsicKeyword = exports.TSIntersectionType = exports.TSInterfaceDeclaration = exports.TSInterfaceBody = exports.TSInstantiationExpression = exports.TSInferType = exports.TSIndexedAccessType = exports.TSIndexSignature = exports.TSImportType = exports.TSImportEqualsDeclaration = exports.TSFunctionType = exports.TSExternalModuleReference = exports.TSExpressionWithTypeArguments = exports.TSExportAssignment = exports.TSEnumMember = exports.TSEnumDeclaration = exports.TSEnumBody = exports.TSDeclareMethod = exports.TSDeclareFunction = exports.TSConstructorType = exports.TSConstructSignatureDeclaration = exports.TSConditionalType = exports.TSCallSignatureDeclaration = exports.TSBooleanKeyword = exports.TSBigIntKeyword = exports.TSAsExpression = exports.TSArrayType = exports.TSAnyKeyword = exports.SymbolTypeAnnotation = exports.SwitchStatement = exports.SwitchCase = exports.Super = exports.StringTypeAnnotation = exports.StringLiteralTypeAnnotation = exports.StringLiteral = exports.StaticBlock = exports.SpreadProperty = exports.SpreadElement = exports.SequenceExpression = exports.ReturnStatement = exports.RestProperty = exports.RestElement = exports.RegexLiteral = exports.RegExpLiteral = exports.RecordExpression = exports.QualifiedTypeIdentifier = exports.Program = exports.PrivateName = exports.Placeholder = exports.PipelineTopicExpression = exports.PipelinePrimaryTopicReference = exports.PipelineBareFunction = exports.ParenthesizedExpression = exports.OptionalMemberExpression = exports.OptionalIndexedAccessType = exports.OptionalCallExpression = exports.OpaqueType = exports.ObjectTypeSpreadProperty = exports.ObjectTypeProperty = exports.ObjectTypeInternalSlot = exports.ObjectTypeIndexer = exports.ObjectTypeCallProperty = exports.ObjectTypeAnnotation = exports.ObjectProperty = exports.ObjectPattern = exports.ObjectMethod = exports.ObjectExpression = exports.NumericLiteral = exports.NumberTypeAnnotation = exports.NumberLiteralTypeAnnotation = exports.NumberLiteral = exports.NullableTypeAnnotation = exports.NullLiteralTypeAnnotation = exports.NullLiteral = exports.Noop = exports.NewExpression = exports.ModuleExpression = exports.MixedTypeAnnotation = exports.MetaProperty = exports.MemberExpression = exports.LogicalExpression = exports.LabeledStatement = exports.JSXText = exports.JSXSpreadChild = exports.JSXSpreadAttribute = exports.JSXOpeningFragment = exports.JSXOpeningElement = exports.JSXNamespacedName = exports.JSXMemberExpression = void 0;\nexports.YieldExpression = exports.WithStatement = exports.WhileStatement = exports.VoidTypeAnnotation = exports.VoidPattern = exports.Variance = exports.VariableDeclarator = exports.VariableDeclaration = exports.V8IntrinsicIdentifier = exports.UpdateExpression = exports.UnionTypeAnnotation = exports.UnaryExpression = exports.TypeofTypeAnnotation = exports.TypeParameterInstantiation = exports.TypeParameterDeclaration = exports.TypeParameter = exports.TypeCastExpression = exports.TypeAnnotation = exports.TypeAlias = exports.TupleTypeAnnotation = exports.TupleExpression = exports.TryStatement = exports.TopicReference = exports.ThrowStatement = exports.ThisTypeAnnotation = exports.ThisExpression = exports.TemplateLiteral = exports.TemplateElement = exports.TaggedTemplateExpression = exports.TSVoidKeyword = exports.TSUnknownKeyword = exports.TSUnionType = exports.TSUndefinedKeyword = exports.TSTypeReference = exports.TSTypeQuery = exports.TSTypePredicate = exports.TSTypeParameterInstantiation = exports.TSTypeParameterDeclaration = exports.TSTypeParameter = exports.TSTypeOperator = exports.TSTypeLiteral = exports.TSTypeAssertion = exports.TSTypeAnnotation = exports.TSTypeAliasDeclaration = exports.TSTupleType = exports.TSThisType = exports.TSTemplateLiteralType = exports.TSSymbolKeyword = exports.TSStringKeyword = exports.TSSatisfiesExpression = exports.TSRestType = exports.TSQualifiedName = exports.TSPropertySignature = exports.TSParenthesizedType = exports.TSParameterProperty = exports.TSOptionalType = exports.TSObjectKeyword = void 0;\nvar b = __webpack_require__(/*! ./lowercase.js */ \"(ssr)/./node_modules/@babel/types/lib/builders/generated/lowercase.js\");\nvar _deprecationWarning = __webpack_require__(/*! ../../utils/deprecationWarning.js */ \"(ssr)/./node_modules/@babel/types/lib/utils/deprecationWarning.js\");\nfunction alias(lowercase) {\n  return b[lowercase];\n}\nconst ArrayExpression = exports.ArrayExpression = alias(\"arrayExpression\"),\n  AssignmentExpression = exports.AssignmentExpression = alias(\"assignmentExpression\"),\n  BinaryExpression = exports.BinaryExpression = alias(\"binaryExpression\"),\n  InterpreterDirective = exports.InterpreterDirective = alias(\"interpreterDirective\"),\n  Directive = exports.Directive = alias(\"directive\"),\n  DirectiveLiteral = exports.DirectiveLiteral = alias(\"directiveLiteral\"),\n  BlockStatement = exports.BlockStatement = alias(\"blockStatement\"),\n  BreakStatement = exports.BreakStatement = alias(\"breakStatement\"),\n  CallExpression = exports.CallExpression = alias(\"callExpression\"),\n  CatchClause = exports.CatchClause = alias(\"catchClause\"),\n  ConditionalExpression = exports.ConditionalExpression = alias(\"conditionalExpression\"),\n  ContinueStatement = exports.ContinueStatement = alias(\"continueStatement\"),\n  DebuggerStatement = exports.DebuggerStatement = alias(\"debuggerStatement\"),\n  DoWhileStatement = exports.DoWhileStatement = alias(\"doWhileStatement\"),\n  EmptyStatement = exports.EmptyStatement = alias(\"emptyStatement\"),\n  ExpressionStatement = exports.ExpressionStatement = alias(\"expressionStatement\"),\n  File = exports.File = alias(\"file\"),\n  ForInStatement = exports.ForInStatement = alias(\"forInStatement\"),\n  ForStatement = exports.ForStatement = alias(\"forStatement\"),\n  FunctionDeclaration = exports.FunctionDeclaration = alias(\"functionDeclaration\"),\n  FunctionExpression = exports.FunctionExpression = alias(\"functionExpression\"),\n  Identifier = exports.Identifier = alias(\"identifier\"),\n  IfStatement = exports.IfStatement = alias(\"ifStatement\"),\n  LabeledStatement = exports.LabeledStatement = alias(\"labeledStatement\"),\n  StringLiteral = exports.StringLiteral = alias(\"stringLiteral\"),\n  NumericLiteral = exports.NumericLiteral = alias(\"numericLiteral\"),\n  NullLiteral = exports.NullLiteral = alias(\"nullLiteral\"),\n  BooleanLiteral = exports.BooleanLiteral = alias(\"booleanLiteral\"),\n  RegExpLiteral = exports.RegExpLiteral = alias(\"regExpLiteral\"),\n  LogicalExpression = exports.LogicalExpression = alias(\"logicalExpression\"),\n  MemberExpression = exports.MemberExpression = alias(\"memberExpression\"),\n  NewExpression = exports.NewExpression = alias(\"newExpression\"),\n  Program = exports.Program = alias(\"program\"),\n  ObjectExpression = exports.ObjectExpression = alias(\"objectExpression\"),\n  ObjectMethod = exports.ObjectMethod = alias(\"objectMethod\"),\n  ObjectProperty = exports.ObjectProperty = alias(\"objectProperty\"),\n  RestElement = exports.RestElement = alias(\"restElement\"),\n  ReturnStatement = exports.ReturnStatement = alias(\"returnStatement\"),\n  SequenceExpression = exports.SequenceExpression = alias(\"sequenceExpression\"),\n  ParenthesizedExpression = exports.ParenthesizedExpression = alias(\"parenthesizedExpression\"),\n  SwitchCase = exports.SwitchCase = alias(\"switchCase\"),\n  SwitchStatement = exports.SwitchStatement = alias(\"switchStatement\"),\n  ThisExpression = exports.ThisExpression = alias(\"thisExpression\"),\n  ThrowStatement = exports.ThrowStatement = alias(\"throwStatement\"),\n  TryStatement = exports.TryStatement = alias(\"tryStatement\"),\n  UnaryExpression = exports.UnaryExpression = alias(\"unaryExpression\"),\n  UpdateExpression = exports.UpdateExpression = alias(\"updateExpression\"),\n  VariableDeclaration = exports.VariableDeclaration = alias(\"variableDeclaration\"),\n  VariableDeclarator = exports.VariableDeclarator = alias(\"variableDeclarator\"),\n  WhileStatement = exports.WhileStatement = alias(\"whileStatement\"),\n  WithStatement = exports.WithStatement = alias(\"withStatement\"),\n  AssignmentPattern = exports.AssignmentPattern = alias(\"assignmentPattern\"),\n  ArrayPattern = exports.ArrayPattern = alias(\"arrayPattern\"),\n  ArrowFunctionExpression = exports.ArrowFunctionExpression = alias(\"arrowFunctionExpression\"),\n  ClassBody = exports.ClassBody = alias(\"classBody\"),\n  ClassExpression = exports.ClassExpression = alias(\"classExpression\"),\n  ClassDeclaration = exports.ClassDeclaration = alias(\"classDeclaration\"),\n  ExportAllDeclaration = exports.ExportAllDeclaration = alias(\"exportAllDeclaration\"),\n  ExportDefaultDeclaration = exports.ExportDefaultDeclaration = alias(\"exportDefaultDeclaration\"),\n  ExportNamedDeclaration = exports.ExportNamedDeclaration = alias(\"exportNamedDeclaration\"),\n  ExportSpecifier = exports.ExportSpecifier = alias(\"exportSpecifier\"),\n  ForOfStatement = exports.ForOfStatement = alias(\"forOfStatement\"),\n  ImportDeclaration = exports.ImportDeclaration = alias(\"importDeclaration\"),\n  ImportDefaultSpecifier = exports.ImportDefaultSpecifier = alias(\"importDefaultSpecifier\"),\n  ImportNamespaceSpecifier = exports.ImportNamespaceSpecifier = alias(\"importNamespaceSpecifier\"),\n  ImportSpecifier = exports.ImportSpecifier = alias(\"importSpecifier\"),\n  ImportExpression = exports.ImportExpression = alias(\"importExpression\"),\n  MetaProperty = exports.MetaProperty = alias(\"metaProperty\"),\n  ClassMethod = exports.ClassMethod = alias(\"classMethod\"),\n  ObjectPattern = exports.ObjectPattern = alias(\"objectPattern\"),\n  SpreadElement = exports.SpreadElement = alias(\"spreadElement\"),\n  Super = exports.Super = alias(\"super\"),\n  TaggedTemplateExpression = exports.TaggedTemplateExpression = alias(\"taggedTemplateExpression\"),\n  TemplateElement = exports.TemplateElement = alias(\"templateElement\"),\n  TemplateLiteral = exports.TemplateLiteral = alias(\"templateLiteral\"),\n  YieldExpression = exports.YieldExpression = alias(\"yieldExpression\"),\n  AwaitExpression = exports.AwaitExpression = alias(\"awaitExpression\"),\n  Import = exports.Import = alias(\"import\"),\n  BigIntLiteral = exports.BigIntLiteral = alias(\"bigIntLiteral\"),\n  ExportNamespaceSpecifier = exports.ExportNamespaceSpecifier = alias(\"exportNamespaceSpecifier\"),\n  OptionalMemberExpression = exports.OptionalMemberExpression = alias(\"optionalMemberExpression\"),\n  OptionalCallExpression = exports.OptionalCallExpression = alias(\"optionalCallExpression\"),\n  ClassProperty = exports.ClassProperty = alias(\"classProperty\"),\n  ClassAccessorProperty = exports.ClassAccessorProperty = alias(\"classAccessorProperty\"),\n  ClassPrivateProperty = exports.ClassPrivateProperty = alias(\"classPrivateProperty\"),\n  ClassPrivateMethod = exports.ClassPrivateMethod = alias(\"classPrivateMethod\"),\n  PrivateName = exports.PrivateName = alias(\"privateName\"),\n  StaticBlock = exports.StaticBlock = alias(\"staticBlock\"),\n  ImportAttribute = exports.ImportAttribute = alias(\"importAttribute\"),\n  AnyTypeAnnotation = exports.AnyTypeAnnotation = alias(\"anyTypeAnnotation\"),\n  ArrayTypeAnnotation = exports.ArrayTypeAnnotation = alias(\"arrayTypeAnnotation\"),\n  BooleanTypeAnnotation = exports.BooleanTypeAnnotation = alias(\"booleanTypeAnnotation\"),\n  BooleanLiteralTypeAnnotation = exports.BooleanLiteralTypeAnnotation = alias(\"booleanLiteralTypeAnnotation\"),\n  NullLiteralTypeAnnotation = exports.NullLiteralTypeAnnotation = alias(\"nullLiteralTypeAnnotation\"),\n  ClassImplements = exports.ClassImplements = alias(\"classImplements\"),\n  DeclareClass = exports.DeclareClass = alias(\"declareClass\"),\n  DeclareFunction = exports.DeclareFunction = alias(\"declareFunction\"),\n  DeclareInterface = exports.DeclareInterface = alias(\"declareInterface\"),\n  DeclareModule = exports.DeclareModule = alias(\"declareModule\"),\n  DeclareModuleExports = exports.DeclareModuleExports = alias(\"declareModuleExports\"),\n  DeclareTypeAlias = exports.DeclareTypeAlias = alias(\"declareTypeAlias\"),\n  DeclareOpaqueType = exports.DeclareOpaqueType = alias(\"declareOpaqueType\"),\n  DeclareVariable = exports.DeclareVariable = alias(\"declareVariable\"),\n  DeclareExportDeclaration = exports.DeclareExportDeclaration = alias(\"declareExportDeclaration\"),\n  DeclareExportAllDeclaration = exports.DeclareExportAllDeclaration = alias(\"declareExportAllDeclaration\"),\n  DeclaredPredicate = exports.DeclaredPredicate = alias(\"declaredPredicate\"),\n  ExistsTypeAnnotation = exports.ExistsTypeAnnotation = alias(\"existsTypeAnnotation\"),\n  FunctionTypeAnnotation = exports.FunctionTypeAnnotation = alias(\"functionTypeAnnotation\"),\n  FunctionTypeParam = exports.FunctionTypeParam = alias(\"functionTypeParam\"),\n  GenericTypeAnnotation = exports.GenericTypeAnnotation = alias(\"genericTypeAnnotation\"),\n  InferredPredicate = exports.InferredPredicate = alias(\"inferredPredicate\"),\n  InterfaceExtends = exports.InterfaceExtends = alias(\"interfaceExtends\"),\n  InterfaceDeclaration = exports.InterfaceDeclaration = alias(\"interfaceDeclaration\"),\n  InterfaceTypeAnnotation = exports.InterfaceTypeAnnotation = alias(\"interfaceTypeAnnotation\"),\n  IntersectionTypeAnnotation = exports.IntersectionTypeAnnotation = alias(\"intersectionTypeAnnotation\"),\n  MixedTypeAnnotation = exports.MixedTypeAnnotation = alias(\"mixedTypeAnnotation\"),\n  EmptyTypeAnnotation = exports.EmptyTypeAnnotation = alias(\"emptyTypeAnnotation\"),\n  NullableTypeAnnotation = exports.NullableTypeAnnotation = alias(\"nullableTypeAnnotation\"),\n  NumberLiteralTypeAnnotation = exports.NumberLiteralTypeAnnotation = alias(\"numberLiteralTypeAnnotation\"),\n  NumberTypeAnnotation = exports.NumberTypeAnnotation = alias(\"numberTypeAnnotation\"),\n  ObjectTypeAnnotation = exports.ObjectTypeAnnotation = alias(\"objectTypeAnnotation\"),\n  ObjectTypeInternalSlot = exports.ObjectTypeInternalSlot = alias(\"objectTypeInternalSlot\"),\n  ObjectTypeCallProperty = exports.ObjectTypeCallProperty = alias(\"objectTypeCallProperty\"),\n  ObjectTypeIndexer = exports.ObjectTypeIndexer = alias(\"objectTypeIndexer\"),\n  ObjectTypeProperty = exports.ObjectTypeProperty = alias(\"objectTypeProperty\"),\n  ObjectTypeSpreadProperty = exports.ObjectTypeSpreadProperty = alias(\"objectTypeSpreadProperty\"),\n  OpaqueType = exports.OpaqueType = alias(\"opaqueType\"),\n  QualifiedTypeIdentifier = exports.QualifiedTypeIdentifier = alias(\"qualifiedTypeIdentifier\"),\n  StringLiteralTypeAnnotation = exports.StringLiteralTypeAnnotation = alias(\"stringLiteralTypeAnnotation\"),\n  StringTypeAnnotation = exports.StringTypeAnnotation = alias(\"stringTypeAnnotation\"),\n  SymbolTypeAnnotation = exports.SymbolTypeAnnotation = alias(\"symbolTypeAnnotation\"),\n  ThisTypeAnnotation = exports.ThisTypeAnnotation = alias(\"thisTypeAnnotation\"),\n  TupleTypeAnnotation = exports.TupleTypeAnnotation = alias(\"tupleTypeAnnotation\"),\n  TypeofTypeAnnotation = exports.TypeofTypeAnnotation = alias(\"typeofTypeAnnotation\"),\n  TypeAlias = exports.TypeAlias = alias(\"typeAlias\"),\n  TypeAnnotation = exports.TypeAnnotation = alias(\"typeAnnotation\"),\n  TypeCastExpression = exports.TypeCastExpression = alias(\"typeCastExpression\"),\n  TypeParameter = exports.TypeParameter = alias(\"typeParameter\"),\n  TypeParameterDeclaration = exports.TypeParameterDeclaration = alias(\"typeParameterDeclaration\"),\n  TypeParameterInstantiation = exports.TypeParameterInstantiation = alias(\"typeParameterInstantiation\"),\n  UnionTypeAnnotation = exports.UnionTypeAnnotation = alias(\"unionTypeAnnotation\"),\n  Variance = exports.Variance = alias(\"variance\"),\n  VoidTypeAnnotation = exports.VoidTypeAnnotation = alias(\"voidTypeAnnotation\"),\n  EnumDeclaration = exports.EnumDeclaration = alias(\"enumDeclaration\"),\n  EnumBooleanBody = exports.EnumBooleanBody = alias(\"enumBooleanBody\"),\n  EnumNumberBody = exports.EnumNumberBody = alias(\"enumNumberBody\"),\n  EnumStringBody = exports.EnumStringBody = alias(\"enumStringBody\"),\n  EnumSymbolBody = exports.EnumSymbolBody = alias(\"enumSymbolBody\"),\n  EnumBooleanMember = exports.EnumBooleanMember = alias(\"enumBooleanMember\"),\n  EnumNumberMember = exports.EnumNumberMember = alias(\"enumNumberMember\"),\n  EnumStringMember = exports.EnumStringMember = alias(\"enumStringMember\"),\n  EnumDefaultedMember = exports.EnumDefaultedMember = alias(\"enumDefaultedMember\"),\n  IndexedAccessType = exports.IndexedAccessType = alias(\"indexedAccessType\"),\n  OptionalIndexedAccessType = exports.OptionalIndexedAccessType = alias(\"optionalIndexedAccessType\"),\n  JSXAttribute = exports.JSXAttribute = alias(\"jsxAttribute\"),\n  JSXClosingElement = exports.JSXClosingElement = alias(\"jsxClosingElement\"),\n  JSXElement = exports.JSXElement = alias(\"jsxElement\"),\n  JSXEmptyExpression = exports.JSXEmptyExpression = alias(\"jsxEmptyExpression\"),\n  JSXExpressionContainer = exports.JSXExpressionContainer = alias(\"jsxExpressionContainer\"),\n  JSXSpreadChild = exports.JSXSpreadChild = alias(\"jsxSpreadChild\"),\n  JSXIdentifier = exports.JSXIdentifier = alias(\"jsxIdentifier\"),\n  JSXMemberExpression = exports.JSXMemberExpression = alias(\"jsxMemberExpression\"),\n  JSXNamespacedName = exports.JSXNamespacedName = alias(\"jsxNamespacedName\"),\n  JSXOpeningElement = exports.JSXOpeningElement = alias(\"jsxOpeningElement\"),\n  JSXSpreadAttribute = exports.JSXSpreadAttribute = alias(\"jsxSpreadAttribute\"),\n  JSXText = exports.JSXText = alias(\"jsxText\"),\n  JSXFragment = exports.JSXFragment = alias(\"jsxFragment\"),\n  JSXOpeningFragment = exports.JSXOpeningFragment = alias(\"jsxOpeningFragment\"),\n  JSXClosingFragment = exports.JSXClosingFragment = alias(\"jsxClosingFragment\"),\n  Noop = exports.Noop = alias(\"noop\"),\n  Placeholder = exports.Placeholder = alias(\"placeholder\"),\n  V8IntrinsicIdentifier = exports.V8IntrinsicIdentifier = alias(\"v8IntrinsicIdentifier\"),\n  ArgumentPlaceholder = exports.ArgumentPlaceholder = alias(\"argumentPlaceholder\"),\n  BindExpression = exports.BindExpression = alias(\"bindExpression\"),\n  Decorator = exports.Decorator = alias(\"decorator\"),\n  DoExpression = exports.DoExpression = alias(\"doExpression\"),\n  ExportDefaultSpecifier = exports.ExportDefaultSpecifier = alias(\"exportDefaultSpecifier\"),\n  RecordExpression = exports.RecordExpression = alias(\"recordExpression\"),\n  TupleExpression = exports.TupleExpression = alias(\"tupleExpression\"),\n  DecimalLiteral = exports.DecimalLiteral = alias(\"decimalLiteral\"),\n  ModuleExpression = exports.ModuleExpression = alias(\"moduleExpression\"),\n  TopicReference = exports.TopicReference = alias(\"topicReference\"),\n  PipelineTopicExpression = exports.PipelineTopicExpression = alias(\"pipelineTopicExpression\"),\n  PipelineBareFunction = exports.PipelineBareFunction = alias(\"pipelineBareFunction\"),\n  PipelinePrimaryTopicReference = exports.PipelinePrimaryTopicReference = alias(\"pipelinePrimaryTopicReference\"),\n  VoidPattern = exports.VoidPattern = alias(\"voidPattern\"),\n  TSParameterProperty = exports.TSParameterProperty = alias(\"tsParameterProperty\"),\n  TSDeclareFunction = exports.TSDeclareFunction = alias(\"tsDeclareFunction\"),\n  TSDeclareMethod = exports.TSDeclareMethod = alias(\"tsDeclareMethod\"),\n  TSQualifiedName = exports.TSQualifiedName = alias(\"tsQualifiedName\"),\n  TSCallSignatureDeclaration = exports.TSCallSignatureDeclaration = alias(\"tsCallSignatureDeclaration\"),\n  TSConstructSignatureDeclaration = exports.TSConstructSignatureDeclaration = alias(\"tsConstructSignatureDeclaration\"),\n  TSPropertySignature = exports.TSPropertySignature = alias(\"tsPropertySignature\"),\n  TSMethodSignature = exports.TSMethodSignature = alias(\"tsMethodSignature\"),\n  TSIndexSignature = exports.TSIndexSignature = alias(\"tsIndexSignature\"),\n  TSAnyKeyword = exports.TSAnyKeyword = alias(\"tsAnyKeyword\"),\n  TSBooleanKeyword = exports.TSBooleanKeyword = alias(\"tsBooleanKeyword\"),\n  TSBigIntKeyword = exports.TSBigIntKeyword = alias(\"tsBigIntKeyword\"),\n  TSIntrinsicKeyword = exports.TSIntrinsicKeyword = alias(\"tsIntrinsicKeyword\"),\n  TSNeverKeyword = exports.TSNeverKeyword = alias(\"tsNeverKeyword\"),\n  TSNullKeyword = exports.TSNullKeyword = alias(\"tsNullKeyword\"),\n  TSNumberKeyword = exports.TSNumberKeyword = alias(\"tsNumberKeyword\"),\n  TSObjectKeyword = exports.TSObjectKeyword = alias(\"tsObjectKeyword\"),\n  TSStringKeyword = exports.TSStringKeyword = alias(\"tsStringKeyword\"),\n  TSSymbolKeyword = exports.TSSymbolKeyword = alias(\"tsSymbolKeyword\"),\n  TSUndefinedKeyword = exports.TSUndefinedKeyword = alias(\"tsUndefinedKeyword\"),\n  TSUnknownKeyword = exports.TSUnknownKeyword = alias(\"tsUnknownKeyword\"),\n  TSVoidKeyword = exports.TSVoidKeyword = alias(\"tsVoidKeyword\"),\n  TSThisType = exports.TSThisType = alias(\"tsThisType\"),\n  TSFunctionType = exports.TSFunctionType = alias(\"tsFunctionType\"),\n  TSConstructorType = exports.TSConstructorType = alias(\"tsConstructorType\"),\n  TSTypeReference = exports.TSTypeReference = alias(\"tsTypeReference\"),\n  TSTypePredicate = exports.TSTypePredicate = alias(\"tsTypePredicate\"),\n  TSTypeQuery = exports.TSTypeQuery = alias(\"tsTypeQuery\"),\n  TSTypeLiteral = exports.TSTypeLiteral = alias(\"tsTypeLiteral\"),\n  TSArrayType = exports.TSArrayType = alias(\"tsArrayType\"),\n  TSTupleType = exports.TSTupleType = alias(\"tsTupleType\"),\n  TSOptionalType = exports.TSOptionalType = alias(\"tsOptionalType\"),\n  TSRestType = exports.TSRestType = alias(\"tsRestType\"),\n  TSNamedTupleMember = exports.TSNamedTupleMember = alias(\"tsNamedTupleMember\"),\n  TSUnionType = exports.TSUnionType = alias(\"tsUnionType\"),\n  TSIntersectionType = exports.TSIntersectionType = alias(\"tsIntersectionType\"),\n  TSConditionalType = exports.TSConditionalType = alias(\"tsConditionalType\"),\n  TSInferType = exports.TSInferType = alias(\"tsInferType\"),\n  TSParenthesizedType = exports.TSParenthesizedType = alias(\"tsParenthesizedType\"),\n  TSTypeOperator = exports.TSTypeOperator = alias(\"tsTypeOperator\"),\n  TSIndexedAccessType = exports.TSIndexedAccessType = alias(\"tsIndexedAccessType\"),\n  TSMappedType = exports.TSMappedType = alias(\"tsMappedType\"),\n  TSTemplateLiteralType = exports.TSTemplateLiteralType = alias(\"tsTemplateLiteralType\"),\n  TSLiteralType = exports.TSLiteralType = alias(\"tsLiteralType\"),\n  TSExpressionWithTypeArguments = exports.TSExpressionWithTypeArguments = alias(\"tsExpressionWithTypeArguments\"),\n  TSInterfaceDeclaration = exports.TSInterfaceDeclaration = alias(\"tsInterfaceDeclaration\"),\n  TSInterfaceBody = exports.TSInterfaceBody = alias(\"tsInterfaceBody\"),\n  TSTypeAliasDeclaration = exports.TSTypeAliasDeclaration = alias(\"tsTypeAliasDeclaration\"),\n  TSInstantiationExpression = exports.TSInstantiationExpression = alias(\"tsInstantiationExpression\"),\n  TSAsExpression = exports.TSAsExpression = alias(\"tsAsExpression\"),\n  TSSatisfiesExpression = exports.TSSatisfiesExpression = alias(\"tsSatisfiesExpression\"),\n  TSTypeAssertion = exports.TSTypeAssertion = alias(\"tsTypeAssertion\"),\n  TSEnumBody = exports.TSEnumBody = alias(\"tsEnumBody\"),\n  TSEnumDeclaration = exports.TSEnumDeclaration = alias(\"tsEnumDeclaration\"),\n  TSEnumMember = exports.TSEnumMember = alias(\"tsEnumMember\"),\n  TSModuleDeclaration = exports.TSModuleDeclaration = alias(\"tsModuleDeclaration\"),\n  TSModuleBlock = exports.TSModuleBlock = alias(\"tsModuleBlock\"),\n  TSImportType = exports.TSImportType = alias(\"tsImportType\"),\n  TSImportEqualsDeclaration = exports.TSImportEqualsDeclaration = alias(\"tsImportEqualsDeclaration\"),\n  TSExternalModuleReference = exports.TSExternalModuleReference = alias(\"tsExternalModuleReference\"),\n  TSNonNullExpression = exports.TSNonNullExpression = alias(\"tsNonNullExpression\"),\n  TSExportAssignment = exports.TSExportAssignment = alias(\"tsExportAssignment\"),\n  TSNamespaceExportDeclaration = exports.TSNamespaceExportDeclaration = alias(\"tsNamespaceExportDeclaration\"),\n  TSTypeAnnotation = exports.TSTypeAnnotation = alias(\"tsTypeAnnotation\"),\n  TSTypeParameterInstantiation = exports.TSTypeParameterInstantiation = alias(\"tsTypeParameterInstantiation\"),\n  TSTypeParameterDeclaration = exports.TSTypeParameterDeclaration = alias(\"tsTypeParameterDeclaration\"),\n  TSTypeParameter = exports.TSTypeParameter = alias(\"tsTypeParameter\");\nconst NumberLiteral = exports.NumberLiteral = b.numberLiteral,\n  RegexLiteral = exports.RegexLiteral = b.regexLiteral,\n  RestProperty = exports.RestProperty = b.restProperty,\n  SpreadProperty = exports.SpreadProperty = b.spreadProperty;\n\n//# sourceMappingURL=uppercase.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGJhYmVsL3R5cGVzL2xpYi9idWlsZGVycy9nZW5lcmF0ZWQvdXBwZXJjYXNlLmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViLDhDQUE2QztBQUM3QztBQUNBLENBQUMsRUFBQztBQUNGLHFCQUFxQixHQUFHLG1CQUFtQixHQUFHLDhCQUE4QixHQUFHLDBCQUEwQixHQUFHLGtCQUFrQixHQUFHLDBCQUEwQixHQUFHLHlCQUF5QixHQUFHLG9CQUFvQixHQUFHLGtDQUFrQyxHQUFHLDRCQUE0QixHQUFHLCtCQUErQixHQUFHLHdCQUF3QixHQUFHLDRCQUE0QixHQUFHLHlCQUF5QixHQUFHLHlCQUF5QixHQUFHLHVCQUF1QixHQUFHLGdDQUFnQyxHQUFHLHdCQUF3QixHQUFHLDhCQUE4QixHQUFHLHlCQUF5QixHQUFHLHVCQUF1QixHQUFHLGNBQWMsR0FBRyxtQkFBbUIsR0FBRyxrQkFBa0IsR0FBRyw2QkFBNkIsR0FBRyx5QkFBeUIsR0FBRyw4QkFBOEIsR0FBRywwQkFBMEIsR0FBRywyQkFBMkIsR0FBRyxvQkFBb0IsR0FBRyxzQkFBc0IsR0FBRyxzQkFBc0IsR0FBRyxZQUFZLEdBQUcsMkJBQTJCLEdBQUcsdUJBQXVCLEdBQUcsZ0NBQWdDLEdBQUcsOEJBQThCLEdBQUcsOEJBQThCLEdBQUcsZ0NBQWdDLEdBQUcsNEJBQTRCLEdBQUcsNEJBQTRCLEdBQUcsc0JBQXNCLEdBQUcsd0JBQXdCLEdBQUcsc0JBQXNCLEdBQUcsd0JBQXdCLEdBQUcsc0JBQXNCLEdBQUcsMkJBQTJCLEdBQUcsdUJBQXVCLEdBQUcseUJBQXlCLEdBQUcsdUJBQXVCLEdBQUcsMkJBQTJCLEdBQUcsc0JBQXNCLEdBQUcsd0JBQXdCLEdBQUcsb0JBQW9CLEdBQUcsd0JBQXdCLEdBQUcsaUJBQWlCLEdBQUcsaUJBQWlCLEdBQUcseUJBQXlCLEdBQUcsdUJBQXVCLEdBQUcsd0JBQXdCLEdBQUcseUJBQXlCLEdBQUcsNEJBQTRCLEdBQUcscUJBQXFCLEdBQUcsd0JBQXdCLEdBQUcsdUJBQXVCLEdBQUcsZ0NBQWdDLEdBQUcsbUNBQW1DLEdBQUcsb0JBQW9CLEdBQUcsc0JBQXNCLEdBQUcseUJBQXlCLEdBQUcseUJBQXlCLEdBQUcsNkJBQTZCLEdBQUcscUJBQXFCLEdBQUcsNEJBQTRCLEdBQUcsMEJBQTBCLEdBQUcsbUJBQW1CLEdBQUcsdUJBQXVCLEdBQUcsdUJBQXVCLEdBQUcsd0JBQXdCLEdBQUcsaUJBQWlCLEdBQUcsNkJBQTZCLEdBQUcsbUJBQW1CLEdBQUcsc0JBQXNCLEdBQUcsc0JBQXNCLEdBQUcsNkJBQTZCLEdBQUcsb0NBQW9DLEdBQUcsc0JBQXNCLEdBQUcsc0JBQXNCLEdBQUcsc0JBQXNCLEdBQUcsd0JBQXdCLEdBQUcscUJBQXFCLEdBQUcsdUJBQXVCLEdBQUcseUJBQXlCLEdBQUcsNEJBQTRCLEdBQUcsK0JBQStCLEdBQUcsMkJBQTJCLEdBQUcsb0JBQW9CLEdBQUcsdUJBQXVCLEdBQUcsMkJBQTJCLEdBQUcseUJBQXlCO0FBQzlyRix1QkFBdUIsR0FBRyxxQkFBcUIsR0FBRywyQkFBMkIsR0FBRyxzQkFBc0IsR0FBRyxvQ0FBb0MsR0FBRywwQkFBMEIsR0FBRywyQkFBMkIsR0FBRyxxQkFBcUIsR0FBRyx5QkFBeUIsR0FBRyxvQkFBb0IsR0FBRyxxQkFBcUIsR0FBRywwQkFBMEIsR0FBRywwQkFBMEIsR0FBRyw4QkFBOEIsR0FBRyx1QkFBdUIsR0FBRyxpQ0FBaUMsR0FBRyxtQkFBbUIsR0FBRywyQkFBMkIsR0FBRyx3QkFBd0IsR0FBRyxvQkFBb0IsR0FBRyxpQ0FBaUMsR0FBRyxzQkFBc0IsR0FBRyxpQ0FBaUMsR0FBRyxxQ0FBcUMsR0FBRywwQkFBMEIsR0FBRyxvQkFBb0IsR0FBRyx5QkFBeUIsR0FBRyxrQkFBa0IsR0FBRyx1QkFBdUIsR0FBRyx5QkFBeUIsR0FBRyx5QkFBeUIsR0FBRyx1Q0FBdUMsR0FBRyx5QkFBeUIsR0FBRyxrQ0FBa0MsR0FBRyx3QkFBd0IsR0FBRyx1QkFBdUIsR0FBRyxzQkFBc0IsR0FBRyxtQkFBbUIsR0FBRyxvQkFBb0IsR0FBRyw0QkFBNEIsR0FBRyx1QkFBdUIsR0FBRyxrQkFBa0IsR0FBRyxhQUFhLEdBQUcsNEJBQTRCLEdBQUcsbUNBQW1DLEdBQUcscUJBQXFCLEdBQUcsbUJBQW1CLEdBQUcsc0JBQXNCLEdBQUcscUJBQXFCLEdBQUcsMEJBQTBCLEdBQUcsdUJBQXVCLEdBQUcsb0JBQW9CLEdBQUcsbUJBQW1CLEdBQUcsb0JBQW9CLEdBQUcscUJBQXFCLEdBQUcsd0JBQXdCLEdBQUcsK0JBQStCLEdBQUcsZUFBZSxHQUFHLG1CQUFtQixHQUFHLG1CQUFtQixHQUFHLCtCQUErQixHQUFHLHFDQUFxQyxHQUFHLDRCQUE0QixHQUFHLCtCQUErQixHQUFHLGdDQUFnQyxHQUFHLGlDQUFpQyxHQUFHLDhCQUE4QixHQUFHLGtCQUFrQixHQUFHLGdDQUFnQyxHQUFHLDBCQUEwQixHQUFHLDhCQUE4QixHQUFHLHlCQUF5QixHQUFHLDhCQUE4QixHQUFHLDRCQUE0QixHQUFHLHNCQUFzQixHQUFHLHFCQUFxQixHQUFHLG9CQUFvQixHQUFHLHdCQUF3QixHQUFHLHNCQUFzQixHQUFHLDRCQUE0QixHQUFHLG1DQUFtQyxHQUFHLHFCQUFxQixHQUFHLDhCQUE4QixHQUFHLGlDQUFpQyxHQUFHLG1CQUFtQixHQUFHLFlBQVksR0FBRyxxQkFBcUIsR0FBRyx3QkFBd0IsR0FBRywyQkFBMkIsR0FBRyxvQkFBb0IsR0FBRyx3QkFBd0IsR0FBRyx5QkFBeUIsR0FBRyx3QkFBd0IsR0FBRyxlQUFlLEdBQUcsc0JBQXNCLEdBQUcsMEJBQTBCLEdBQUcsMEJBQTBCLEdBQUcseUJBQXlCLEdBQUcseUJBQXlCLEdBQUcsMkJBQTJCO0FBQzd0Rix1QkFBdUIsR0FBRyxxQkFBcUIsR0FBRyxzQkFBc0IsR0FBRywwQkFBMEIsR0FBRyxtQkFBbUIsR0FBRyxnQkFBZ0IsR0FBRywwQkFBMEIsR0FBRywyQkFBMkIsR0FBRyw2QkFBNkIsR0FBRyx3QkFBd0IsR0FBRywyQkFBMkIsR0FBRyx1QkFBdUIsR0FBRyw0QkFBNEIsR0FBRyxrQ0FBa0MsR0FBRyxnQ0FBZ0MsR0FBRyxxQkFBcUIsR0FBRywwQkFBMEIsR0FBRyxzQkFBc0IsR0FBRyxpQkFBaUIsR0FBRywyQkFBMkIsR0FBRyx1QkFBdUIsR0FBRyxvQkFBb0IsR0FBRyxzQkFBc0IsR0FBRyxzQkFBc0IsR0FBRywwQkFBMEIsR0FBRyxzQkFBc0IsR0FBRyx1QkFBdUIsR0FBRyx1QkFBdUIsR0FBRyxnQ0FBZ0MsR0FBRyxxQkFBcUIsR0FBRyx3QkFBd0IsR0FBRyxtQkFBbUIsR0FBRywwQkFBMEIsR0FBRyx1QkFBdUIsR0FBRyxtQkFBbUIsR0FBRyx1QkFBdUIsR0FBRyxvQ0FBb0MsR0FBRyxrQ0FBa0MsR0FBRyx1QkFBdUIsR0FBRyxzQkFBc0IsR0FBRyxxQkFBcUIsR0FBRyx1QkFBdUIsR0FBRyx3QkFBd0IsR0FBRyw4QkFBOEIsR0FBRyxtQkFBbUIsR0FBRyxrQkFBa0IsR0FBRyw2QkFBNkIsR0FBRyx1QkFBdUIsR0FBRyx1QkFBdUIsR0FBRyw2QkFBNkIsR0FBRyxrQkFBa0IsR0FBRyx1QkFBdUIsR0FBRywyQkFBMkIsR0FBRywyQkFBMkIsR0FBRywyQkFBMkIsR0FBRyxzQkFBc0IsR0FBRyx1QkFBdUI7QUFDM2dELFFBQVEsbUJBQU8sQ0FBQyw2RkFBZ0I7QUFDaEMsMEJBQTBCLG1CQUFPLENBQUMsNEdBQW1DO0FBQ3JFO0FBQ0E7QUFDQTtBQUNBLHdCQUF3Qix1QkFBdUI7QUFDL0MseUJBQXlCLDRCQUE0QjtBQUNyRCxxQkFBcUIsd0JBQXdCO0FBQzdDLHlCQUF5Qiw0QkFBNEI7QUFDckQsY0FBYyxpQkFBaUI7QUFDL0IscUJBQXFCLHdCQUF3QjtBQUM3QyxtQkFBbUIsc0JBQXNCO0FBQ3pDLG1CQUFtQixzQkFBc0I7QUFDekMsbUJBQW1CLHNCQUFzQjtBQUN6QyxnQkFBZ0IsbUJBQW1CO0FBQ25DLDBCQUEwQiw2QkFBNkI7QUFDdkQsc0JBQXNCLHlCQUF5QjtBQUMvQyxzQkFBc0IseUJBQXlCO0FBQy9DLHFCQUFxQix3QkFBd0I7QUFDN0MsbUJBQW1CLHNCQUFzQjtBQUN6Qyx3QkFBd0IsMkJBQTJCO0FBQ25ELFNBQVMsWUFBWTtBQUNyQixtQkFBbUIsc0JBQXNCO0FBQ3pDLGlCQUFpQixvQkFBb0I7QUFDckMsd0JBQXdCLDJCQUEyQjtBQUNuRCx1QkFBdUIsMEJBQTBCO0FBQ2pELGVBQWUsa0JBQWtCO0FBQ2pDLGdCQUFnQixtQkFBbUI7QUFDbkMscUJBQXFCLHdCQUF3QjtBQUM3QyxrQkFBa0IscUJBQXFCO0FBQ3ZDLG1CQUFtQixzQkFBc0I7QUFDekMsZ0JBQWdCLG1CQUFtQjtBQUNuQyxtQkFBbUIsc0JBQXNCO0FBQ3pDLGtCQUFrQixxQkFBcUI7QUFDdkMsc0JBQXNCLHlCQUF5QjtBQUMvQyxxQkFBcUIsd0JBQXdCO0FBQzdDLGtCQUFrQixxQkFBcUI7QUFDdkMsWUFBWSxlQUFlO0FBQzNCLHFCQUFxQix3QkFBd0I7QUFDN0MsaUJBQWlCLG9CQUFvQjtBQUNyQyxtQkFBbUIsc0JBQXNCO0FBQ3pDLGdCQUFnQixtQkFBbUI7QUFDbkMsb0JBQW9CLHVCQUF1QjtBQUMzQyx1QkFBdUIsMEJBQTBCO0FBQ2pELDRCQUE0QiwrQkFBK0I7QUFDM0QsZUFBZSxrQkFBa0I7QUFDakMsb0JBQW9CLHVCQUF1QjtBQUMzQyxtQkFBbUIsc0JBQXNCO0FBQ3pDLG1CQUFtQixzQkFBc0I7QUFDekMsaUJBQWlCLG9CQUFvQjtBQUNyQyxvQkFBb0IsdUJBQXVCO0FBQzNDLHFCQUFxQix3QkFBd0I7QUFDN0Msd0JBQXdCLDJCQUEyQjtBQUNuRCx1QkFBdUIsMEJBQTBCO0FBQ2pELG1CQUFtQixzQkFBc0I7QUFDekMsa0JBQWtCLHFCQUFxQjtBQUN2QyxzQkFBc0IseUJBQXlCO0FBQy9DLGlCQUFpQixvQkFBb0I7QUFDckMsNEJBQTRCLCtCQUErQjtBQUMzRCxjQUFjLGlCQUFpQjtBQUMvQixvQkFBb0IsdUJBQXVCO0FBQzNDLHFCQUFxQix3QkFBd0I7QUFDN0MseUJBQXlCLDRCQUE0QjtBQUNyRCw2QkFBNkIsZ0NBQWdDO0FBQzdELDJCQUEyQiw4QkFBOEI7QUFDekQsb0JBQW9CLHVCQUF1QjtBQUMzQyxtQkFBbUIsc0JBQXNCO0FBQ3pDLHNCQUFzQix5QkFBeUI7QUFDL0MsMkJBQTJCLDhCQUE4QjtBQUN6RCw2QkFBNkIsZ0NBQWdDO0FBQzdELG9CQUFvQix1QkFBdUI7QUFDM0MscUJBQXFCLHdCQUF3QjtBQUM3QyxpQkFBaUIsb0JBQW9CO0FBQ3JDLGdCQUFnQixtQkFBbUI7QUFDbkMsa0JBQWtCLHFCQUFxQjtBQUN2QyxrQkFBa0IscUJBQXFCO0FBQ3ZDLFVBQVUsYUFBYTtBQUN2Qiw2QkFBNkIsZ0NBQWdDO0FBQzdELG9CQUFvQix1QkFBdUI7QUFDM0Msb0JBQW9CLHVCQUF1QjtBQUMzQyxvQkFBb0IsdUJBQXVCO0FBQzNDLG9CQUFvQix1QkFBdUI7QUFDM0MsV0FBVyxjQUFjO0FBQ3pCLGtCQUFrQixxQkFBcUI7QUFDdkMsNkJBQTZCLGdDQUFnQztBQUM3RCw2QkFBNkIsZ0NBQWdDO0FBQzdELDJCQUEyQiw4QkFBOEI7QUFDekQsa0JBQWtCLHFCQUFxQjtBQUN2QywwQkFBMEIsNkJBQTZCO0FBQ3ZELHlCQUF5Qiw0QkFBNEI7QUFDckQsdUJBQXVCLDBCQUEwQjtBQUNqRCxnQkFBZ0IsbUJBQW1CO0FBQ25DLGdCQUFnQixtQkFBbUI7QUFDbkMsb0JBQW9CLHVCQUF1QjtBQUMzQyxzQkFBc0IseUJBQXlCO0FBQy9DLHdCQUF3QiwyQkFBMkI7QUFDbkQsMEJBQTBCLDZCQUE2QjtBQUN2RCxpQ0FBaUMsb0NBQW9DO0FBQ3JFLDhCQUE4QixpQ0FBaUM7QUFDL0Qsb0JBQW9CLHVCQUF1QjtBQUMzQyxpQkFBaUIsb0JBQW9CO0FBQ3JDLG9CQUFvQix1QkFBdUI7QUFDM0MscUJBQXFCLHdCQUF3QjtBQUM3QyxrQkFBa0IscUJBQXFCO0FBQ3ZDLHlCQUF5Qiw0QkFBNEI7QUFDckQscUJBQXFCLHdCQUF3QjtBQUM3QyxzQkFBc0IseUJBQXlCO0FBQy9DLG9CQUFvQix1QkFBdUI7QUFDM0MsNkJBQTZCLGdDQUFnQztBQUM3RCxnQ0FBZ0MsbUNBQW1DO0FBQ25FLHNCQUFzQix5QkFBeUI7QUFDL0MseUJBQXlCLDRCQUE0QjtBQUNyRCwyQkFBMkIsOEJBQThCO0FBQ3pELHNCQUFzQix5QkFBeUI7QUFDL0MsMEJBQTBCLDZCQUE2QjtBQUN2RCxzQkFBc0IseUJBQXlCO0FBQy9DLHFCQUFxQix3QkFBd0I7QUFDN0MseUJBQXlCLDRCQUE0QjtBQUNyRCw0QkFBNEIsK0JBQStCO0FBQzNELCtCQUErQixrQ0FBa0M7QUFDakUsd0JBQXdCLDJCQUEyQjtBQUNuRCx3QkFBd0IsMkJBQTJCO0FBQ25ELDJCQUEyQiw4QkFBOEI7QUFDekQsZ0NBQWdDLG1DQUFtQztBQUNuRSx5QkFBeUIsNEJBQTRCO0FBQ3JELHlCQUF5Qiw0QkFBNEI7QUFDckQsMkJBQTJCLDhCQUE4QjtBQUN6RCwyQkFBMkIsOEJBQThCO0FBQ3pELHNCQUFzQix5QkFBeUI7QUFDL0MsdUJBQXVCLDBCQUEwQjtBQUNqRCw2QkFBNkIsZ0NBQWdDO0FBQzdELGVBQWUsa0JBQWtCO0FBQ2pDLDRCQUE0QiwrQkFBK0I7QUFDM0QsZ0NBQWdDLG1DQUFtQztBQUNuRSx5QkFBeUIsNEJBQTRCO0FBQ3JELHlCQUF5Qiw0QkFBNEI7QUFDckQsdUJBQXVCLDBCQUEwQjtBQUNqRCx3QkFBd0IsMkJBQTJCO0FBQ25ELHlCQUF5Qiw0QkFBNEI7QUFDckQsY0FBYyxpQkFBaUI7QUFDL0IsbUJBQW1CLHNCQUFzQjtBQUN6Qyx1QkFBdUIsMEJBQTBCO0FBQ2pELGtCQUFrQixxQkFBcUI7QUFDdkMsNkJBQTZCLGdDQUFnQztBQUM3RCwrQkFBK0Isa0NBQWtDO0FBQ2pFLHdCQUF3QiwyQkFBMkI7QUFDbkQsYUFBYSxnQkFBZ0I7QUFDN0IsdUJBQXVCLDBCQUEwQjtBQUNqRCxvQkFBb0IsdUJBQXVCO0FBQzNDLG9CQUFvQix1QkFBdUI7QUFDM0MsbUJBQW1CLHNCQUFzQjtBQUN6QyxtQkFBbUIsc0JBQXNCO0FBQ3pDLG1CQUFtQixzQkFBc0I7QUFDekMsc0JBQXNCLHlCQUF5QjtBQUMvQyxxQkFBcUIsd0JBQXdCO0FBQzdDLHFCQUFxQix3QkFBd0I7QUFDN0Msd0JBQXdCLDJCQUEyQjtBQUNuRCxzQkFBc0IseUJBQXlCO0FBQy9DLDhCQUE4QixpQ0FBaUM7QUFDL0QsaUJBQWlCLG9CQUFvQjtBQUNyQyxzQkFBc0IseUJBQXlCO0FBQy9DLGVBQWUsa0JBQWtCO0FBQ2pDLHVCQUF1QiwwQkFBMEI7QUFDakQsMkJBQTJCLDhCQUE4QjtBQUN6RCxtQkFBbUIsc0JBQXNCO0FBQ3pDLGtCQUFrQixxQkFBcUI7QUFDdkMsd0JBQXdCLDJCQUEyQjtBQUNuRCxzQkFBc0IseUJBQXlCO0FBQy9DLHNCQUFzQix5QkFBeUI7QUFDL0MsdUJBQXVCLDBCQUEwQjtBQUNqRCxZQUFZLGVBQWU7QUFDM0IsZ0JBQWdCLG1CQUFtQjtBQUNuQyx1QkFBdUIsMEJBQTBCO0FBQ2pELHVCQUF1QiwwQkFBMEI7QUFDakQsU0FBUyxZQUFZO0FBQ3JCLGdCQUFnQixtQkFBbUI7QUFDbkMsMEJBQTBCLDZCQUE2QjtBQUN2RCx3QkFBd0IsMkJBQTJCO0FBQ25ELG1CQUFtQixzQkFBc0I7QUFDekMsY0FBYyxpQkFBaUI7QUFDL0IsaUJBQWlCLG9CQUFvQjtBQUNyQywyQkFBMkIsOEJBQThCO0FBQ3pELHFCQUFxQix3QkFBd0I7QUFDN0Msb0JBQW9CLHVCQUF1QjtBQUMzQyxtQkFBbUIsc0JBQXNCO0FBQ3pDLHFCQUFxQix3QkFBd0I7QUFDN0MsbUJBQW1CLHNCQUFzQjtBQUN6Qyw0QkFBNEIsK0JBQStCO0FBQzNELHlCQUF5Qiw0QkFBNEI7QUFDckQsa0NBQWtDLHFDQUFxQztBQUN2RSxnQkFBZ0IsbUJBQW1CO0FBQ25DLHdCQUF3QiwyQkFBMkI7QUFDbkQsc0JBQXNCLHlCQUF5QjtBQUMvQyxvQkFBb0IsdUJBQXVCO0FBQzNDLG9CQUFvQix1QkFBdUI7QUFDM0MsK0JBQStCLGtDQUFrQztBQUNqRSxvQ0FBb0MsdUNBQXVDO0FBQzNFLHdCQUF3QiwyQkFBMkI7QUFDbkQsc0JBQXNCLHlCQUF5QjtBQUMvQyxxQkFBcUIsd0JBQXdCO0FBQzdDLGlCQUFpQixvQkFBb0I7QUFDckMscUJBQXFCLHdCQUF3QjtBQUM3QyxvQkFBb0IsdUJBQXVCO0FBQzNDLHVCQUF1QiwwQkFBMEI7QUFDakQsbUJBQW1CLHNCQUFzQjtBQUN6QyxrQkFBa0IscUJBQXFCO0FBQ3ZDLG9CQUFvQix1QkFBdUI7QUFDM0Msb0JBQW9CLHVCQUF1QjtBQUMzQyxvQkFBb0IsdUJBQXVCO0FBQzNDLG9CQUFvQix1QkFBdUI7QUFDM0MsdUJBQXVCLDBCQUEwQjtBQUNqRCxxQkFBcUIsd0JBQXdCO0FBQzdDLGtCQUFrQixxQkFBcUI7QUFDdkMsZUFBZSxrQkFBa0I7QUFDakMsbUJBQW1CLHNCQUFzQjtBQUN6QyxzQkFBc0IseUJBQXlCO0FBQy9DLG9CQUFvQix1QkFBdUI7QUFDM0Msb0JBQW9CLHVCQUF1QjtBQUMzQyxnQkFBZ0IsbUJBQW1CO0FBQ25DLGtCQUFrQixxQkFBcUI7QUFDdkMsZ0JBQWdCLG1CQUFtQjtBQUNuQyxnQkFBZ0IsbUJBQW1CO0FBQ25DLG1CQUFtQixzQkFBc0I7QUFDekMsZUFBZSxrQkFBa0I7QUFDakMsdUJBQXVCLDBCQUEwQjtBQUNqRCxnQkFBZ0IsbUJBQW1CO0FBQ25DLHVCQUF1QiwwQkFBMEI7QUFDakQsc0JBQXNCLHlCQUF5QjtBQUMvQyxnQkFBZ0IsbUJBQW1CO0FBQ25DLHdCQUF3QiwyQkFBMkI7QUFDbkQsbUJBQW1CLHNCQUFzQjtBQUN6Qyx3QkFBd0IsMkJBQTJCO0FBQ25ELGlCQUFpQixvQkFBb0I7QUFDckMsMEJBQTBCLDZCQUE2QjtBQUN2RCxrQkFBa0IscUJBQXFCO0FBQ3ZDLGtDQUFrQyxxQ0FBcUM7QUFDdkUsMkJBQTJCLDhCQUE4QjtBQUN6RCxvQkFBb0IsdUJBQXVCO0FBQzNDLDJCQUEyQiw4QkFBOEI7QUFDekQsOEJBQThCLGlDQUFpQztBQUMvRCxtQkFBbUIsc0JBQXNCO0FBQ3pDLDBCQUEwQiw2QkFBNkI7QUFDdkQsb0JBQW9CLHVCQUF1QjtBQUMzQyxlQUFlLGtCQUFrQjtBQUNqQyxzQkFBc0IseUJBQXlCO0FBQy9DLGlCQUFpQixvQkFBb0I7QUFDckMsd0JBQXdCLDJCQUEyQjtBQUNuRCxrQkFBa0IscUJBQXFCO0FBQ3ZDLGlCQUFpQixvQkFBb0I7QUFDckMsOEJBQThCLGlDQUFpQztBQUMvRCw4QkFBOEIsaUNBQWlDO0FBQy9ELHdCQUF3QiwyQkFBMkI7QUFDbkQsdUJBQXVCLDBCQUEwQjtBQUNqRCxpQ0FBaUMsb0NBQW9DO0FBQ3JFLHFCQUFxQix3QkFBd0I7QUFDN0MsaUNBQWlDLG9DQUFvQztBQUNyRSwrQkFBK0Isa0NBQWtDO0FBQ2pFLG9CQUFvQix1QkFBdUI7QUFDM0Msc0JBQXNCLHFCQUFxQjtBQUMzQyxpQkFBaUIsb0JBQW9CO0FBQ3JDLGlCQUFpQixvQkFBb0I7QUFDckMsbUJBQW1CLHNCQUFzQjs7QUFFekMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9yZXBvLXZpc3VhbGl6ZXIvLi9ub2RlX21vZHVsZXMvQGJhYmVsL3R5cGVzL2xpYi9idWlsZGVycy9nZW5lcmF0ZWQvdXBwZXJjYXNlLmpzPzQwNTYiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLkpTWElkZW50aWZpZXIgPSBleHBvcnRzLkpTWEZyYWdtZW50ID0gZXhwb3J0cy5KU1hFeHByZXNzaW9uQ29udGFpbmVyID0gZXhwb3J0cy5KU1hFbXB0eUV4cHJlc3Npb24gPSBleHBvcnRzLkpTWEVsZW1lbnQgPSBleHBvcnRzLkpTWENsb3NpbmdGcmFnbWVudCA9IGV4cG9ydHMuSlNYQ2xvc2luZ0VsZW1lbnQgPSBleHBvcnRzLkpTWEF0dHJpYnV0ZSA9IGV4cG9ydHMuSW50ZXJzZWN0aW9uVHlwZUFubm90YXRpb24gPSBleHBvcnRzLkludGVycHJldGVyRGlyZWN0aXZlID0gZXhwb3J0cy5JbnRlcmZhY2VUeXBlQW5ub3RhdGlvbiA9IGV4cG9ydHMuSW50ZXJmYWNlRXh0ZW5kcyA9IGV4cG9ydHMuSW50ZXJmYWNlRGVjbGFyYXRpb24gPSBleHBvcnRzLkluZmVycmVkUHJlZGljYXRlID0gZXhwb3J0cy5JbmRleGVkQWNjZXNzVHlwZSA9IGV4cG9ydHMuSW1wb3J0U3BlY2lmaWVyID0gZXhwb3J0cy5JbXBvcnROYW1lc3BhY2VTcGVjaWZpZXIgPSBleHBvcnRzLkltcG9ydEV4cHJlc3Npb24gPSBleHBvcnRzLkltcG9ydERlZmF1bHRTcGVjaWZpZXIgPSBleHBvcnRzLkltcG9ydERlY2xhcmF0aW9uID0gZXhwb3J0cy5JbXBvcnRBdHRyaWJ1dGUgPSBleHBvcnRzLkltcG9ydCA9IGV4cG9ydHMuSWZTdGF0ZW1lbnQgPSBleHBvcnRzLklkZW50aWZpZXIgPSBleHBvcnRzLkdlbmVyaWNUeXBlQW5ub3RhdGlvbiA9IGV4cG9ydHMuRnVuY3Rpb25UeXBlUGFyYW0gPSBleHBvcnRzLkZ1bmN0aW9uVHlwZUFubm90YXRpb24gPSBleHBvcnRzLkZ1bmN0aW9uRXhwcmVzc2lvbiA9IGV4cG9ydHMuRnVuY3Rpb25EZWNsYXJhdGlvbiA9IGV4cG9ydHMuRm9yU3RhdGVtZW50ID0gZXhwb3J0cy5Gb3JPZlN0YXRlbWVudCA9IGV4cG9ydHMuRm9ySW5TdGF0ZW1lbnQgPSBleHBvcnRzLkZpbGUgPSBleHBvcnRzLkV4cHJlc3Npb25TdGF0ZW1lbnQgPSBleHBvcnRzLkV4cG9ydFNwZWNpZmllciA9IGV4cG9ydHMuRXhwb3J0TmFtZXNwYWNlU3BlY2lmaWVyID0gZXhwb3J0cy5FeHBvcnROYW1lZERlY2xhcmF0aW9uID0gZXhwb3J0cy5FeHBvcnREZWZhdWx0U3BlY2lmaWVyID0gZXhwb3J0cy5FeHBvcnREZWZhdWx0RGVjbGFyYXRpb24gPSBleHBvcnRzLkV4cG9ydEFsbERlY2xhcmF0aW9uID0gZXhwb3J0cy5FeGlzdHNUeXBlQW5ub3RhdGlvbiA9IGV4cG9ydHMuRW51bVN5bWJvbEJvZHkgPSBleHBvcnRzLkVudW1TdHJpbmdNZW1iZXIgPSBleHBvcnRzLkVudW1TdHJpbmdCb2R5ID0gZXhwb3J0cy5FbnVtTnVtYmVyTWVtYmVyID0gZXhwb3J0cy5FbnVtTnVtYmVyQm9keSA9IGV4cG9ydHMuRW51bURlZmF1bHRlZE1lbWJlciA9IGV4cG9ydHMuRW51bURlY2xhcmF0aW9uID0gZXhwb3J0cy5FbnVtQm9vbGVhbk1lbWJlciA9IGV4cG9ydHMuRW51bUJvb2xlYW5Cb2R5ID0gZXhwb3J0cy5FbXB0eVR5cGVBbm5vdGF0aW9uID0gZXhwb3J0cy5FbXB0eVN0YXRlbWVudCA9IGV4cG9ydHMuRG9XaGlsZVN0YXRlbWVudCA9IGV4cG9ydHMuRG9FeHByZXNzaW9uID0gZXhwb3J0cy5EaXJlY3RpdmVMaXRlcmFsID0gZXhwb3J0cy5EaXJlY3RpdmUgPSBleHBvcnRzLkRlY29yYXRvciA9IGV4cG9ydHMuRGVjbGFyZWRQcmVkaWNhdGUgPSBleHBvcnRzLkRlY2xhcmVWYXJpYWJsZSA9IGV4cG9ydHMuRGVjbGFyZVR5cGVBbGlhcyA9IGV4cG9ydHMuRGVjbGFyZU9wYXF1ZVR5cGUgPSBleHBvcnRzLkRlY2xhcmVNb2R1bGVFeHBvcnRzID0gZXhwb3J0cy5EZWNsYXJlTW9kdWxlID0gZXhwb3J0cy5EZWNsYXJlSW50ZXJmYWNlID0gZXhwb3J0cy5EZWNsYXJlRnVuY3Rpb24gPSBleHBvcnRzLkRlY2xhcmVFeHBvcnREZWNsYXJhdGlvbiA9IGV4cG9ydHMuRGVjbGFyZUV4cG9ydEFsbERlY2xhcmF0aW9uID0gZXhwb3J0cy5EZWNsYXJlQ2xhc3MgPSBleHBvcnRzLkRlY2ltYWxMaXRlcmFsID0gZXhwb3J0cy5EZWJ1Z2dlclN0YXRlbWVudCA9IGV4cG9ydHMuQ29udGludWVTdGF0ZW1lbnQgPSBleHBvcnRzLkNvbmRpdGlvbmFsRXhwcmVzc2lvbiA9IGV4cG9ydHMuQ2xhc3NQcm9wZXJ0eSA9IGV4cG9ydHMuQ2xhc3NQcml2YXRlUHJvcGVydHkgPSBleHBvcnRzLkNsYXNzUHJpdmF0ZU1ldGhvZCA9IGV4cG9ydHMuQ2xhc3NNZXRob2QgPSBleHBvcnRzLkNsYXNzSW1wbGVtZW50cyA9IGV4cG9ydHMuQ2xhc3NFeHByZXNzaW9uID0gZXhwb3J0cy5DbGFzc0RlY2xhcmF0aW9uID0gZXhwb3J0cy5DbGFzc0JvZHkgPSBleHBvcnRzLkNsYXNzQWNjZXNzb3JQcm9wZXJ0eSA9IGV4cG9ydHMuQ2F0Y2hDbGF1c2UgPSBleHBvcnRzLkNhbGxFeHByZXNzaW9uID0gZXhwb3J0cy5CcmVha1N0YXRlbWVudCA9IGV4cG9ydHMuQm9vbGVhblR5cGVBbm5vdGF0aW9uID0gZXhwb3J0cy5Cb29sZWFuTGl0ZXJhbFR5cGVBbm5vdGF0aW9uID0gZXhwb3J0cy5Cb29sZWFuTGl0ZXJhbCA9IGV4cG9ydHMuQmxvY2tTdGF0ZW1lbnQgPSBleHBvcnRzLkJpbmRFeHByZXNzaW9uID0gZXhwb3J0cy5CaW5hcnlFeHByZXNzaW9uID0gZXhwb3J0cy5CaWdJbnRMaXRlcmFsID0gZXhwb3J0cy5Bd2FpdEV4cHJlc3Npb24gPSBleHBvcnRzLkFzc2lnbm1lbnRQYXR0ZXJuID0gZXhwb3J0cy5Bc3NpZ25tZW50RXhwcmVzc2lvbiA9IGV4cG9ydHMuQXJyb3dGdW5jdGlvbkV4cHJlc3Npb24gPSBleHBvcnRzLkFycmF5VHlwZUFubm90YXRpb24gPSBleHBvcnRzLkFycmF5UGF0dGVybiA9IGV4cG9ydHMuQXJyYXlFeHByZXNzaW9uID0gZXhwb3J0cy5Bcmd1bWVudFBsYWNlaG9sZGVyID0gZXhwb3J0cy5BbnlUeXBlQW5ub3RhdGlvbiA9IHZvaWQgMDtcbmV4cG9ydHMuVFNOdW1iZXJLZXl3b3JkID0gZXhwb3J0cy5UU051bGxLZXl3b3JkID0gZXhwb3J0cy5UU05vbk51bGxFeHByZXNzaW9uID0gZXhwb3J0cy5UU05ldmVyS2V5d29yZCA9IGV4cG9ydHMuVFNOYW1lc3BhY2VFeHBvcnREZWNsYXJhdGlvbiA9IGV4cG9ydHMuVFNOYW1lZFR1cGxlTWVtYmVyID0gZXhwb3J0cy5UU01vZHVsZURlY2xhcmF0aW9uID0gZXhwb3J0cy5UU01vZHVsZUJsb2NrID0gZXhwb3J0cy5UU01ldGhvZFNpZ25hdHVyZSA9IGV4cG9ydHMuVFNNYXBwZWRUeXBlID0gZXhwb3J0cy5UU0xpdGVyYWxUeXBlID0gZXhwb3J0cy5UU0ludHJpbnNpY0tleXdvcmQgPSBleHBvcnRzLlRTSW50ZXJzZWN0aW9uVHlwZSA9IGV4cG9ydHMuVFNJbnRlcmZhY2VEZWNsYXJhdGlvbiA9IGV4cG9ydHMuVFNJbnRlcmZhY2VCb2R5ID0gZXhwb3J0cy5UU0luc3RhbnRpYXRpb25FeHByZXNzaW9uID0gZXhwb3J0cy5UU0luZmVyVHlwZSA9IGV4cG9ydHMuVFNJbmRleGVkQWNjZXNzVHlwZSA9IGV4cG9ydHMuVFNJbmRleFNpZ25hdHVyZSA9IGV4cG9ydHMuVFNJbXBvcnRUeXBlID0gZXhwb3J0cy5UU0ltcG9ydEVxdWFsc0RlY2xhcmF0aW9uID0gZXhwb3J0cy5UU0Z1bmN0aW9uVHlwZSA9IGV4cG9ydHMuVFNFeHRlcm5hbE1vZHVsZVJlZmVyZW5jZSA9IGV4cG9ydHMuVFNFeHByZXNzaW9uV2l0aFR5cGVBcmd1bWVudHMgPSBleHBvcnRzLlRTRXhwb3J0QXNzaWdubWVudCA9IGV4cG9ydHMuVFNFbnVtTWVtYmVyID0gZXhwb3J0cy5UU0VudW1EZWNsYXJhdGlvbiA9IGV4cG9ydHMuVFNFbnVtQm9keSA9IGV4cG9ydHMuVFNEZWNsYXJlTWV0aG9kID0gZXhwb3J0cy5UU0RlY2xhcmVGdW5jdGlvbiA9IGV4cG9ydHMuVFNDb25zdHJ1Y3RvclR5cGUgPSBleHBvcnRzLlRTQ29uc3RydWN0U2lnbmF0dXJlRGVjbGFyYXRpb24gPSBleHBvcnRzLlRTQ29uZGl0aW9uYWxUeXBlID0gZXhwb3J0cy5UU0NhbGxTaWduYXR1cmVEZWNsYXJhdGlvbiA9IGV4cG9ydHMuVFNCb29sZWFuS2V5d29yZCA9IGV4cG9ydHMuVFNCaWdJbnRLZXl3b3JkID0gZXhwb3J0cy5UU0FzRXhwcmVzc2lvbiA9IGV4cG9ydHMuVFNBcnJheVR5cGUgPSBleHBvcnRzLlRTQW55S2V5d29yZCA9IGV4cG9ydHMuU3ltYm9sVHlwZUFubm90YXRpb24gPSBleHBvcnRzLlN3aXRjaFN0YXRlbWVudCA9IGV4cG9ydHMuU3dpdGNoQ2FzZSA9IGV4cG9ydHMuU3VwZXIgPSBleHBvcnRzLlN0cmluZ1R5cGVBbm5vdGF0aW9uID0gZXhwb3J0cy5TdHJpbmdMaXRlcmFsVHlwZUFubm90YXRpb24gPSBleHBvcnRzLlN0cmluZ0xpdGVyYWwgPSBleHBvcnRzLlN0YXRpY0Jsb2NrID0gZXhwb3J0cy5TcHJlYWRQcm9wZXJ0eSA9IGV4cG9ydHMuU3ByZWFkRWxlbWVudCA9IGV4cG9ydHMuU2VxdWVuY2VFeHByZXNzaW9uID0gZXhwb3J0cy5SZXR1cm5TdGF0ZW1lbnQgPSBleHBvcnRzLlJlc3RQcm9wZXJ0eSA9IGV4cG9ydHMuUmVzdEVsZW1lbnQgPSBleHBvcnRzLlJlZ2V4TGl0ZXJhbCA9IGV4cG9ydHMuUmVnRXhwTGl0ZXJhbCA9IGV4cG9ydHMuUmVjb3JkRXhwcmVzc2lvbiA9IGV4cG9ydHMuUXVhbGlmaWVkVHlwZUlkZW50aWZpZXIgPSBleHBvcnRzLlByb2dyYW0gPSBleHBvcnRzLlByaXZhdGVOYW1lID0gZXhwb3J0cy5QbGFjZWhvbGRlciA9IGV4cG9ydHMuUGlwZWxpbmVUb3BpY0V4cHJlc3Npb24gPSBleHBvcnRzLlBpcGVsaW5lUHJpbWFyeVRvcGljUmVmZXJlbmNlID0gZXhwb3J0cy5QaXBlbGluZUJhcmVGdW5jdGlvbiA9IGV4cG9ydHMuUGFyZW50aGVzaXplZEV4cHJlc3Npb24gPSBleHBvcnRzLk9wdGlvbmFsTWVtYmVyRXhwcmVzc2lvbiA9IGV4cG9ydHMuT3B0aW9uYWxJbmRleGVkQWNjZXNzVHlwZSA9IGV4cG9ydHMuT3B0aW9uYWxDYWxsRXhwcmVzc2lvbiA9IGV4cG9ydHMuT3BhcXVlVHlwZSA9IGV4cG9ydHMuT2JqZWN0VHlwZVNwcmVhZFByb3BlcnR5ID0gZXhwb3J0cy5PYmplY3RUeXBlUHJvcGVydHkgPSBleHBvcnRzLk9iamVjdFR5cGVJbnRlcm5hbFNsb3QgPSBleHBvcnRzLk9iamVjdFR5cGVJbmRleGVyID0gZXhwb3J0cy5PYmplY3RUeXBlQ2FsbFByb3BlcnR5ID0gZXhwb3J0cy5PYmplY3RUeXBlQW5ub3RhdGlvbiA9IGV4cG9ydHMuT2JqZWN0UHJvcGVydHkgPSBleHBvcnRzLk9iamVjdFBhdHRlcm4gPSBleHBvcnRzLk9iamVjdE1ldGhvZCA9IGV4cG9ydHMuT2JqZWN0RXhwcmVzc2lvbiA9IGV4cG9ydHMuTnVtZXJpY0xpdGVyYWwgPSBleHBvcnRzLk51bWJlclR5cGVBbm5vdGF0aW9uID0gZXhwb3J0cy5OdW1iZXJMaXRlcmFsVHlwZUFubm90YXRpb24gPSBleHBvcnRzLk51bWJlckxpdGVyYWwgPSBleHBvcnRzLk51bGxhYmxlVHlwZUFubm90YXRpb24gPSBleHBvcnRzLk51bGxMaXRlcmFsVHlwZUFubm90YXRpb24gPSBleHBvcnRzLk51bGxMaXRlcmFsID0gZXhwb3J0cy5Ob29wID0gZXhwb3J0cy5OZXdFeHByZXNzaW9uID0gZXhwb3J0cy5Nb2R1bGVFeHByZXNzaW9uID0gZXhwb3J0cy5NaXhlZFR5cGVBbm5vdGF0aW9uID0gZXhwb3J0cy5NZXRhUHJvcGVydHkgPSBleHBvcnRzLk1lbWJlckV4cHJlc3Npb24gPSBleHBvcnRzLkxvZ2ljYWxFeHByZXNzaW9uID0gZXhwb3J0cy5MYWJlbGVkU3RhdGVtZW50ID0gZXhwb3J0cy5KU1hUZXh0ID0gZXhwb3J0cy5KU1hTcHJlYWRDaGlsZCA9IGV4cG9ydHMuSlNYU3ByZWFkQXR0cmlidXRlID0gZXhwb3J0cy5KU1hPcGVuaW5nRnJhZ21lbnQgPSBleHBvcnRzLkpTWE9wZW5pbmdFbGVtZW50ID0gZXhwb3J0cy5KU1hOYW1lc3BhY2VkTmFtZSA9IGV4cG9ydHMuSlNYTWVtYmVyRXhwcmVzc2lvbiA9IHZvaWQgMDtcbmV4cG9ydHMuWWllbGRFeHByZXNzaW9uID0gZXhwb3J0cy5XaXRoU3RhdGVtZW50ID0gZXhwb3J0cy5XaGlsZVN0YXRlbWVudCA9IGV4cG9ydHMuVm9pZFR5cGVBbm5vdGF0aW9uID0gZXhwb3J0cy5Wb2lkUGF0dGVybiA9IGV4cG9ydHMuVmFyaWFuY2UgPSBleHBvcnRzLlZhcmlhYmxlRGVjbGFyYXRvciA9IGV4cG9ydHMuVmFyaWFibGVEZWNsYXJhdGlvbiA9IGV4cG9ydHMuVjhJbnRyaW5zaWNJZGVudGlmaWVyID0gZXhwb3J0cy5VcGRhdGVFeHByZXNzaW9uID0gZXhwb3J0cy5VbmlvblR5cGVBbm5vdGF0aW9uID0gZXhwb3J0cy5VbmFyeUV4cHJlc3Npb24gPSBleHBvcnRzLlR5cGVvZlR5cGVBbm5vdGF0aW9uID0gZXhwb3J0cy5UeXBlUGFyYW1ldGVySW5zdGFudGlhdGlvbiA9IGV4cG9ydHMuVHlwZVBhcmFtZXRlckRlY2xhcmF0aW9uID0gZXhwb3J0cy5UeXBlUGFyYW1ldGVyID0gZXhwb3J0cy5UeXBlQ2FzdEV4cHJlc3Npb24gPSBleHBvcnRzLlR5cGVBbm5vdGF0aW9uID0gZXhwb3J0cy5UeXBlQWxpYXMgPSBleHBvcnRzLlR1cGxlVHlwZUFubm90YXRpb24gPSBleHBvcnRzLlR1cGxlRXhwcmVzc2lvbiA9IGV4cG9ydHMuVHJ5U3RhdGVtZW50ID0gZXhwb3J0cy5Ub3BpY1JlZmVyZW5jZSA9IGV4cG9ydHMuVGhyb3dTdGF0ZW1lbnQgPSBleHBvcnRzLlRoaXNUeXBlQW5ub3RhdGlvbiA9IGV4cG9ydHMuVGhpc0V4cHJlc3Npb24gPSBleHBvcnRzLlRlbXBsYXRlTGl0ZXJhbCA9IGV4cG9ydHMuVGVtcGxhdGVFbGVtZW50ID0gZXhwb3J0cy5UYWdnZWRUZW1wbGF0ZUV4cHJlc3Npb24gPSBleHBvcnRzLlRTVm9pZEtleXdvcmQgPSBleHBvcnRzLlRTVW5rbm93bktleXdvcmQgPSBleHBvcnRzLlRTVW5pb25UeXBlID0gZXhwb3J0cy5UU1VuZGVmaW5lZEtleXdvcmQgPSBleHBvcnRzLlRTVHlwZVJlZmVyZW5jZSA9IGV4cG9ydHMuVFNUeXBlUXVlcnkgPSBleHBvcnRzLlRTVHlwZVByZWRpY2F0ZSA9IGV4cG9ydHMuVFNUeXBlUGFyYW1ldGVySW5zdGFudGlhdGlvbiA9IGV4cG9ydHMuVFNUeXBlUGFyYW1ldGVyRGVjbGFyYXRpb24gPSBleHBvcnRzLlRTVHlwZVBhcmFtZXRlciA9IGV4cG9ydHMuVFNUeXBlT3BlcmF0b3IgPSBleHBvcnRzLlRTVHlwZUxpdGVyYWwgPSBleHBvcnRzLlRTVHlwZUFzc2VydGlvbiA9IGV4cG9ydHMuVFNUeXBlQW5ub3RhdGlvbiA9IGV4cG9ydHMuVFNUeXBlQWxpYXNEZWNsYXJhdGlvbiA9IGV4cG9ydHMuVFNUdXBsZVR5cGUgPSBleHBvcnRzLlRTVGhpc1R5cGUgPSBleHBvcnRzLlRTVGVtcGxhdGVMaXRlcmFsVHlwZSA9IGV4cG9ydHMuVFNTeW1ib2xLZXl3b3JkID0gZXhwb3J0cy5UU1N0cmluZ0tleXdvcmQgPSBleHBvcnRzLlRTU2F0aXNmaWVzRXhwcmVzc2lvbiA9IGV4cG9ydHMuVFNSZXN0VHlwZSA9IGV4cG9ydHMuVFNRdWFsaWZpZWROYW1lID0gZXhwb3J0cy5UU1Byb3BlcnR5U2lnbmF0dXJlID0gZXhwb3J0cy5UU1BhcmVudGhlc2l6ZWRUeXBlID0gZXhwb3J0cy5UU1BhcmFtZXRlclByb3BlcnR5ID0gZXhwb3J0cy5UU09wdGlvbmFsVHlwZSA9IGV4cG9ydHMuVFNPYmplY3RLZXl3b3JkID0gdm9pZCAwO1xudmFyIGIgPSByZXF1aXJlKFwiLi9sb3dlcmNhc2UuanNcIik7XG52YXIgX2RlcHJlY2F0aW9uV2FybmluZyA9IHJlcXVpcmUoXCIuLi8uLi91dGlscy9kZXByZWNhdGlvbldhcm5pbmcuanNcIik7XG5mdW5jdGlvbiBhbGlhcyhsb3dlcmNhc2UpIHtcbiAgcmV0dXJuIGJbbG93ZXJjYXNlXTtcbn1cbmNvbnN0IEFycmF5RXhwcmVzc2lvbiA9IGV4cG9ydHMuQXJyYXlFeHByZXNzaW9uID0gYWxpYXMoXCJhcnJheUV4cHJlc3Npb25cIiksXG4gIEFzc2lnbm1lbnRFeHByZXNzaW9uID0gZXhwb3J0cy5Bc3NpZ25tZW50RXhwcmVzc2lvbiA9IGFsaWFzKFwiYXNzaWdubWVudEV4cHJlc3Npb25cIiksXG4gIEJpbmFyeUV4cHJlc3Npb24gPSBleHBvcnRzLkJpbmFyeUV4cHJlc3Npb24gPSBhbGlhcyhcImJpbmFyeUV4cHJlc3Npb25cIiksXG4gIEludGVycHJldGVyRGlyZWN0aXZlID0gZXhwb3J0cy5JbnRlcnByZXRlckRpcmVjdGl2ZSA9IGFsaWFzKFwiaW50ZXJwcmV0ZXJEaXJlY3RpdmVcIiksXG4gIERpcmVjdGl2ZSA9IGV4cG9ydHMuRGlyZWN0aXZlID0gYWxpYXMoXCJkaXJlY3RpdmVcIiksXG4gIERpcmVjdGl2ZUxpdGVyYWwgPSBleHBvcnRzLkRpcmVjdGl2ZUxpdGVyYWwgPSBhbGlhcyhcImRpcmVjdGl2ZUxpdGVyYWxcIiksXG4gIEJsb2NrU3RhdGVtZW50ID0gZXhwb3J0cy5CbG9ja1N0YXRlbWVudCA9IGFsaWFzKFwiYmxvY2tTdGF0ZW1lbnRcIiksXG4gIEJyZWFrU3RhdGVtZW50ID0gZXhwb3J0cy5CcmVha1N0YXRlbWVudCA9IGFsaWFzKFwiYnJlYWtTdGF0ZW1lbnRcIiksXG4gIENhbGxFeHByZXNzaW9uID0gZXhwb3J0cy5DYWxsRXhwcmVzc2lvbiA9IGFsaWFzKFwiY2FsbEV4cHJlc3Npb25cIiksXG4gIENhdGNoQ2xhdXNlID0gZXhwb3J0cy5DYXRjaENsYXVzZSA9IGFsaWFzKFwiY2F0Y2hDbGF1c2VcIiksXG4gIENvbmRpdGlvbmFsRXhwcmVzc2lvbiA9IGV4cG9ydHMuQ29uZGl0aW9uYWxFeHByZXNzaW9uID0gYWxpYXMoXCJjb25kaXRpb25hbEV4cHJlc3Npb25cIiksXG4gIENvbnRpbnVlU3RhdGVtZW50ID0gZXhwb3J0cy5Db250aW51ZVN0YXRlbWVudCA9IGFsaWFzKFwiY29udGludWVTdGF0ZW1lbnRcIiksXG4gIERlYnVnZ2VyU3RhdGVtZW50ID0gZXhwb3J0cy5EZWJ1Z2dlclN0YXRlbWVudCA9IGFsaWFzKFwiZGVidWdnZXJTdGF0ZW1lbnRcIiksXG4gIERvV2hpbGVTdGF0ZW1lbnQgPSBleHBvcnRzLkRvV2hpbGVTdGF0ZW1lbnQgPSBhbGlhcyhcImRvV2hpbGVTdGF0ZW1lbnRcIiksXG4gIEVtcHR5U3RhdGVtZW50ID0gZXhwb3J0cy5FbXB0eVN0YXRlbWVudCA9IGFsaWFzKFwiZW1wdHlTdGF0ZW1lbnRcIiksXG4gIEV4cHJlc3Npb25TdGF0ZW1lbnQgPSBleHBvcnRzLkV4cHJlc3Npb25TdGF0ZW1lbnQgPSBhbGlhcyhcImV4cHJlc3Npb25TdGF0ZW1lbnRcIiksXG4gIEZpbGUgPSBleHBvcnRzLkZpbGUgPSBhbGlhcyhcImZpbGVcIiksXG4gIEZvckluU3RhdGVtZW50ID0gZXhwb3J0cy5Gb3JJblN0YXRlbWVudCA9IGFsaWFzKFwiZm9ySW5TdGF0ZW1lbnRcIiksXG4gIEZvclN0YXRlbWVudCA9IGV4cG9ydHMuRm9yU3RhdGVtZW50ID0gYWxpYXMoXCJmb3JTdGF0ZW1lbnRcIiksXG4gIEZ1bmN0aW9uRGVjbGFyYXRpb24gPSBleHBvcnRzLkZ1bmN0aW9uRGVjbGFyYXRpb24gPSBhbGlhcyhcImZ1bmN0aW9uRGVjbGFyYXRpb25cIiksXG4gIEZ1bmN0aW9uRXhwcmVzc2lvbiA9IGV4cG9ydHMuRnVuY3Rpb25FeHByZXNzaW9uID0gYWxpYXMoXCJmdW5jdGlvbkV4cHJlc3Npb25cIiksXG4gIElkZW50aWZpZXIgPSBleHBvcnRzLklkZW50aWZpZXIgPSBhbGlhcyhcImlkZW50aWZpZXJcIiksXG4gIElmU3RhdGVtZW50ID0gZXhwb3J0cy5JZlN0YXRlbWVudCA9IGFsaWFzKFwiaWZTdGF0ZW1lbnRcIiksXG4gIExhYmVsZWRTdGF0ZW1lbnQgPSBleHBvcnRzLkxhYmVsZWRTdGF0ZW1lbnQgPSBhbGlhcyhcImxhYmVsZWRTdGF0ZW1lbnRcIiksXG4gIFN0cmluZ0xpdGVyYWwgPSBleHBvcnRzLlN0cmluZ0xpdGVyYWwgPSBhbGlhcyhcInN0cmluZ0xpdGVyYWxcIiksXG4gIE51bWVyaWNMaXRlcmFsID0gZXhwb3J0cy5OdW1lcmljTGl0ZXJhbCA9IGFsaWFzKFwibnVtZXJpY0xpdGVyYWxcIiksXG4gIE51bGxMaXRlcmFsID0gZXhwb3J0cy5OdWxsTGl0ZXJhbCA9IGFsaWFzKFwibnVsbExpdGVyYWxcIiksXG4gIEJvb2xlYW5MaXRlcmFsID0gZXhwb3J0cy5Cb29sZWFuTGl0ZXJhbCA9IGFsaWFzKFwiYm9vbGVhbkxpdGVyYWxcIiksXG4gIFJlZ0V4cExpdGVyYWwgPSBleHBvcnRzLlJlZ0V4cExpdGVyYWwgPSBhbGlhcyhcInJlZ0V4cExpdGVyYWxcIiksXG4gIExvZ2ljYWxFeHByZXNzaW9uID0gZXhwb3J0cy5Mb2dpY2FsRXhwcmVzc2lvbiA9IGFsaWFzKFwibG9naWNhbEV4cHJlc3Npb25cIiksXG4gIE1lbWJlckV4cHJlc3Npb24gPSBleHBvcnRzLk1lbWJlckV4cHJlc3Npb24gPSBhbGlhcyhcIm1lbWJlckV4cHJlc3Npb25cIiksXG4gIE5ld0V4cHJlc3Npb24gPSBleHBvcnRzLk5ld0V4cHJlc3Npb24gPSBhbGlhcyhcIm5ld0V4cHJlc3Npb25cIiksXG4gIFByb2dyYW0gPSBleHBvcnRzLlByb2dyYW0gPSBhbGlhcyhcInByb2dyYW1cIiksXG4gIE9iamVjdEV4cHJlc3Npb24gPSBleHBvcnRzLk9iamVjdEV4cHJlc3Npb24gPSBhbGlhcyhcIm9iamVjdEV4cHJlc3Npb25cIiksXG4gIE9iamVjdE1ldGhvZCA9IGV4cG9ydHMuT2JqZWN0TWV0aG9kID0gYWxpYXMoXCJvYmplY3RNZXRob2RcIiksXG4gIE9iamVjdFByb3BlcnR5ID0gZXhwb3J0cy5PYmplY3RQcm9wZXJ0eSA9IGFsaWFzKFwib2JqZWN0UHJvcGVydHlcIiksXG4gIFJlc3RFbGVtZW50ID0gZXhwb3J0cy5SZXN0RWxlbWVudCA9IGFsaWFzKFwicmVzdEVsZW1lbnRcIiksXG4gIFJldHVyblN0YXRlbWVudCA9IGV4cG9ydHMuUmV0dXJuU3RhdGVtZW50ID0gYWxpYXMoXCJyZXR1cm5TdGF0ZW1lbnRcIiksXG4gIFNlcXVlbmNlRXhwcmVzc2lvbiA9IGV4cG9ydHMuU2VxdWVuY2VFeHByZXNzaW9uID0gYWxpYXMoXCJzZXF1ZW5jZUV4cHJlc3Npb25cIiksXG4gIFBhcmVudGhlc2l6ZWRFeHByZXNzaW9uID0gZXhwb3J0cy5QYXJlbnRoZXNpemVkRXhwcmVzc2lvbiA9IGFsaWFzKFwicGFyZW50aGVzaXplZEV4cHJlc3Npb25cIiksXG4gIFN3aXRjaENhc2UgPSBleHBvcnRzLlN3aXRjaENhc2UgPSBhbGlhcyhcInN3aXRjaENhc2VcIiksXG4gIFN3aXRjaFN0YXRlbWVudCA9IGV4cG9ydHMuU3dpdGNoU3RhdGVtZW50ID0gYWxpYXMoXCJzd2l0Y2hTdGF0ZW1lbnRcIiksXG4gIFRoaXNFeHByZXNzaW9uID0gZXhwb3J0cy5UaGlzRXhwcmVzc2lvbiA9IGFsaWFzKFwidGhpc0V4cHJlc3Npb25cIiksXG4gIFRocm93U3RhdGVtZW50ID0gZXhwb3J0cy5UaHJvd1N0YXRlbWVudCA9IGFsaWFzKFwidGhyb3dTdGF0ZW1lbnRcIiksXG4gIFRyeVN0YXRlbWVudCA9IGV4cG9ydHMuVHJ5U3RhdGVtZW50ID0gYWxpYXMoXCJ0cnlTdGF0ZW1lbnRcIiksXG4gIFVuYXJ5RXhwcmVzc2lvbiA9IGV4cG9ydHMuVW5hcnlFeHByZXNzaW9uID0gYWxpYXMoXCJ1bmFyeUV4cHJlc3Npb25cIiksXG4gIFVwZGF0ZUV4cHJlc3Npb24gPSBleHBvcnRzLlVwZGF0ZUV4cHJlc3Npb24gPSBhbGlhcyhcInVwZGF0ZUV4cHJlc3Npb25cIiksXG4gIFZhcmlhYmxlRGVjbGFyYXRpb24gPSBleHBvcnRzLlZhcmlhYmxlRGVjbGFyYXRpb24gPSBhbGlhcyhcInZhcmlhYmxlRGVjbGFyYXRpb25cIiksXG4gIFZhcmlhYmxlRGVjbGFyYXRvciA9IGV4cG9ydHMuVmFyaWFibGVEZWNsYXJhdG9yID0gYWxpYXMoXCJ2YXJpYWJsZURlY2xhcmF0b3JcIiksXG4gIFdoaWxlU3RhdGVtZW50ID0gZXhwb3J0cy5XaGlsZVN0YXRlbWVudCA9IGFsaWFzKFwid2hpbGVTdGF0ZW1lbnRcIiksXG4gIFdpdGhTdGF0ZW1lbnQgPSBleHBvcnRzLldpdGhTdGF0ZW1lbnQgPSBhbGlhcyhcIndpdGhTdGF0ZW1lbnRcIiksXG4gIEFzc2lnbm1lbnRQYXR0ZXJuID0gZXhwb3J0cy5Bc3NpZ25tZW50UGF0dGVybiA9IGFsaWFzKFwiYXNzaWdubWVudFBhdHRlcm5cIiksXG4gIEFycmF5UGF0dGVybiA9IGV4cG9ydHMuQXJyYXlQYXR0ZXJuID0gYWxpYXMoXCJhcnJheVBhdHRlcm5cIiksXG4gIEFycm93RnVuY3Rpb25FeHByZXNzaW9uID0gZXhwb3J0cy5BcnJvd0Z1bmN0aW9uRXhwcmVzc2lvbiA9IGFsaWFzKFwiYXJyb3dGdW5jdGlvbkV4cHJlc3Npb25cIiksXG4gIENsYXNzQm9keSA9IGV4cG9ydHMuQ2xhc3NCb2R5ID0gYWxpYXMoXCJjbGFzc0JvZHlcIiksXG4gIENsYXNzRXhwcmVzc2lvbiA9IGV4cG9ydHMuQ2xhc3NFeHByZXNzaW9uID0gYWxpYXMoXCJjbGFzc0V4cHJlc3Npb25cIiksXG4gIENsYXNzRGVjbGFyYXRpb24gPSBleHBvcnRzLkNsYXNzRGVjbGFyYXRpb24gPSBhbGlhcyhcImNsYXNzRGVjbGFyYXRpb25cIiksXG4gIEV4cG9ydEFsbERlY2xhcmF0aW9uID0gZXhwb3J0cy5FeHBvcnRBbGxEZWNsYXJhdGlvbiA9IGFsaWFzKFwiZXhwb3J0QWxsRGVjbGFyYXRpb25cIiksXG4gIEV4cG9ydERlZmF1bHREZWNsYXJhdGlvbiA9IGV4cG9ydHMuRXhwb3J0RGVmYXVsdERlY2xhcmF0aW9uID0gYWxpYXMoXCJleHBvcnREZWZhdWx0RGVjbGFyYXRpb25cIiksXG4gIEV4cG9ydE5hbWVkRGVjbGFyYXRpb24gPSBleHBvcnRzLkV4cG9ydE5hbWVkRGVjbGFyYXRpb24gPSBhbGlhcyhcImV4cG9ydE5hbWVkRGVjbGFyYXRpb25cIiksXG4gIEV4cG9ydFNwZWNpZmllciA9IGV4cG9ydHMuRXhwb3J0U3BlY2lmaWVyID0gYWxpYXMoXCJleHBvcnRTcGVjaWZpZXJcIiksXG4gIEZvck9mU3RhdGVtZW50ID0gZXhwb3J0cy5Gb3JPZlN0YXRlbWVudCA9IGFsaWFzKFwiZm9yT2ZTdGF0ZW1lbnRcIiksXG4gIEltcG9ydERlY2xhcmF0aW9uID0gZXhwb3J0cy5JbXBvcnREZWNsYXJhdGlvbiA9IGFsaWFzKFwiaW1wb3J0RGVjbGFyYXRpb25cIiksXG4gIEltcG9ydERlZmF1bHRTcGVjaWZpZXIgPSBleHBvcnRzLkltcG9ydERlZmF1bHRTcGVjaWZpZXIgPSBhbGlhcyhcImltcG9ydERlZmF1bHRTcGVjaWZpZXJcIiksXG4gIEltcG9ydE5hbWVzcGFjZVNwZWNpZmllciA9IGV4cG9ydHMuSW1wb3J0TmFtZXNwYWNlU3BlY2lmaWVyID0gYWxpYXMoXCJpbXBvcnROYW1lc3BhY2VTcGVjaWZpZXJcIiksXG4gIEltcG9ydFNwZWNpZmllciA9IGV4cG9ydHMuSW1wb3J0U3BlY2lmaWVyID0gYWxpYXMoXCJpbXBvcnRTcGVjaWZpZXJcIiksXG4gIEltcG9ydEV4cHJlc3Npb24gPSBleHBvcnRzLkltcG9ydEV4cHJlc3Npb24gPSBhbGlhcyhcImltcG9ydEV4cHJlc3Npb25cIiksXG4gIE1ldGFQcm9wZXJ0eSA9IGV4cG9ydHMuTWV0YVByb3BlcnR5ID0gYWxpYXMoXCJtZXRhUHJvcGVydHlcIiksXG4gIENsYXNzTWV0aG9kID0gZXhwb3J0cy5DbGFzc01ldGhvZCA9IGFsaWFzKFwiY2xhc3NNZXRob2RcIiksXG4gIE9iamVjdFBhdHRlcm4gPSBleHBvcnRzLk9iamVjdFBhdHRlcm4gPSBhbGlhcyhcIm9iamVjdFBhdHRlcm5cIiksXG4gIFNwcmVhZEVsZW1lbnQgPSBleHBvcnRzLlNwcmVhZEVsZW1lbnQgPSBhbGlhcyhcInNwcmVhZEVsZW1lbnRcIiksXG4gIFN1cGVyID0gZXhwb3J0cy5TdXBlciA9IGFsaWFzKFwic3VwZXJcIiksXG4gIFRhZ2dlZFRlbXBsYXRlRXhwcmVzc2lvbiA9IGV4cG9ydHMuVGFnZ2VkVGVtcGxhdGVFeHByZXNzaW9uID0gYWxpYXMoXCJ0YWdnZWRUZW1wbGF0ZUV4cHJlc3Npb25cIiksXG4gIFRlbXBsYXRlRWxlbWVudCA9IGV4cG9ydHMuVGVtcGxhdGVFbGVtZW50ID0gYWxpYXMoXCJ0ZW1wbGF0ZUVsZW1lbnRcIiksXG4gIFRlbXBsYXRlTGl0ZXJhbCA9IGV4cG9ydHMuVGVtcGxhdGVMaXRlcmFsID0gYWxpYXMoXCJ0ZW1wbGF0ZUxpdGVyYWxcIiksXG4gIFlpZWxkRXhwcmVzc2lvbiA9IGV4cG9ydHMuWWllbGRFeHByZXNzaW9uID0gYWxpYXMoXCJ5aWVsZEV4cHJlc3Npb25cIiksXG4gIEF3YWl0RXhwcmVzc2lvbiA9IGV4cG9ydHMuQXdhaXRFeHByZXNzaW9uID0gYWxpYXMoXCJhd2FpdEV4cHJlc3Npb25cIiksXG4gIEltcG9ydCA9IGV4cG9ydHMuSW1wb3J0ID0gYWxpYXMoXCJpbXBvcnRcIiksXG4gIEJpZ0ludExpdGVyYWwgPSBleHBvcnRzLkJpZ0ludExpdGVyYWwgPSBhbGlhcyhcImJpZ0ludExpdGVyYWxcIiksXG4gIEV4cG9ydE5hbWVzcGFjZVNwZWNpZmllciA9IGV4cG9ydHMuRXhwb3J0TmFtZXNwYWNlU3BlY2lmaWVyID0gYWxpYXMoXCJleHBvcnROYW1lc3BhY2VTcGVjaWZpZXJcIiksXG4gIE9wdGlvbmFsTWVtYmVyRXhwcmVzc2lvbiA9IGV4cG9ydHMuT3B0aW9uYWxNZW1iZXJFeHByZXNzaW9uID0gYWxpYXMoXCJvcHRpb25hbE1lbWJlckV4cHJlc3Npb25cIiksXG4gIE9wdGlvbmFsQ2FsbEV4cHJlc3Npb24gPSBleHBvcnRzLk9wdGlvbmFsQ2FsbEV4cHJlc3Npb24gPSBhbGlhcyhcIm9wdGlvbmFsQ2FsbEV4cHJlc3Npb25cIiksXG4gIENsYXNzUHJvcGVydHkgPSBleHBvcnRzLkNsYXNzUHJvcGVydHkgPSBhbGlhcyhcImNsYXNzUHJvcGVydHlcIiksXG4gIENsYXNzQWNjZXNzb3JQcm9wZXJ0eSA9IGV4cG9ydHMuQ2xhc3NBY2Nlc3NvclByb3BlcnR5ID0gYWxpYXMoXCJjbGFzc0FjY2Vzc29yUHJvcGVydHlcIiksXG4gIENsYXNzUHJpdmF0ZVByb3BlcnR5ID0gZXhwb3J0cy5DbGFzc1ByaXZhdGVQcm9wZXJ0eSA9IGFsaWFzKFwiY2xhc3NQcml2YXRlUHJvcGVydHlcIiksXG4gIENsYXNzUHJpdmF0ZU1ldGhvZCA9IGV4cG9ydHMuQ2xhc3NQcml2YXRlTWV0aG9kID0gYWxpYXMoXCJjbGFzc1ByaXZhdGVNZXRob2RcIiksXG4gIFByaXZhdGVOYW1lID0gZXhwb3J0cy5Qcml2YXRlTmFtZSA9IGFsaWFzKFwicHJpdmF0ZU5hbWVcIiksXG4gIFN0YXRpY0Jsb2NrID0gZXhwb3J0cy5TdGF0aWNCbG9jayA9IGFsaWFzKFwic3RhdGljQmxvY2tcIiksXG4gIEltcG9ydEF0dHJpYnV0ZSA9IGV4cG9ydHMuSW1wb3J0QXR0cmlidXRlID0gYWxpYXMoXCJpbXBvcnRBdHRyaWJ1dGVcIiksXG4gIEFueVR5cGVBbm5vdGF0aW9uID0gZXhwb3J0cy5BbnlUeXBlQW5ub3RhdGlvbiA9IGFsaWFzKFwiYW55VHlwZUFubm90YXRpb25cIiksXG4gIEFycmF5VHlwZUFubm90YXRpb24gPSBleHBvcnRzLkFycmF5VHlwZUFubm90YXRpb24gPSBhbGlhcyhcImFycmF5VHlwZUFubm90YXRpb25cIiksXG4gIEJvb2xlYW5UeXBlQW5ub3RhdGlvbiA9IGV4cG9ydHMuQm9vbGVhblR5cGVBbm5vdGF0aW9uID0gYWxpYXMoXCJib29sZWFuVHlwZUFubm90YXRpb25cIiksXG4gIEJvb2xlYW5MaXRlcmFsVHlwZUFubm90YXRpb24gPSBleHBvcnRzLkJvb2xlYW5MaXRlcmFsVHlwZUFubm90YXRpb24gPSBhbGlhcyhcImJvb2xlYW5MaXRlcmFsVHlwZUFubm90YXRpb25cIiksXG4gIE51bGxMaXRlcmFsVHlwZUFubm90YXRpb24gPSBleHBvcnRzLk51bGxMaXRlcmFsVHlwZUFubm90YXRpb24gPSBhbGlhcyhcIm51bGxMaXRlcmFsVHlwZUFubm90YXRpb25cIiksXG4gIENsYXNzSW1wbGVtZW50cyA9IGV4cG9ydHMuQ2xhc3NJbXBsZW1lbnRzID0gYWxpYXMoXCJjbGFzc0ltcGxlbWVudHNcIiksXG4gIERlY2xhcmVDbGFzcyA9IGV4cG9ydHMuRGVjbGFyZUNsYXNzID0gYWxpYXMoXCJkZWNsYXJlQ2xhc3NcIiksXG4gIERlY2xhcmVGdW5jdGlvbiA9IGV4cG9ydHMuRGVjbGFyZUZ1bmN0aW9uID0gYWxpYXMoXCJkZWNsYXJlRnVuY3Rpb25cIiksXG4gIERlY2xhcmVJbnRlcmZhY2UgPSBleHBvcnRzLkRlY2xhcmVJbnRlcmZhY2UgPSBhbGlhcyhcImRlY2xhcmVJbnRlcmZhY2VcIiksXG4gIERlY2xhcmVNb2R1bGUgPSBleHBvcnRzLkRlY2xhcmVNb2R1bGUgPSBhbGlhcyhcImRlY2xhcmVNb2R1bGVcIiksXG4gIERlY2xhcmVNb2R1bGVFeHBvcnRzID0gZXhwb3J0cy5EZWNsYXJlTW9kdWxlRXhwb3J0cyA9IGFsaWFzKFwiZGVjbGFyZU1vZHVsZUV4cG9ydHNcIiksXG4gIERlY2xhcmVUeXBlQWxpYXMgPSBleHBvcnRzLkRlY2xhcmVUeXBlQWxpYXMgPSBhbGlhcyhcImRlY2xhcmVUeXBlQWxpYXNcIiksXG4gIERlY2xhcmVPcGFxdWVUeXBlID0gZXhwb3J0cy5EZWNsYXJlT3BhcXVlVHlwZSA9IGFsaWFzKFwiZGVjbGFyZU9wYXF1ZVR5cGVcIiksXG4gIERlY2xhcmVWYXJpYWJsZSA9IGV4cG9ydHMuRGVjbGFyZVZhcmlhYmxlID0gYWxpYXMoXCJkZWNsYXJlVmFyaWFibGVcIiksXG4gIERlY2xhcmVFeHBvcnREZWNsYXJhdGlvbiA9IGV4cG9ydHMuRGVjbGFyZUV4cG9ydERlY2xhcmF0aW9uID0gYWxpYXMoXCJkZWNsYXJlRXhwb3J0RGVjbGFyYXRpb25cIiksXG4gIERlY2xhcmVFeHBvcnRBbGxEZWNsYXJhdGlvbiA9IGV4cG9ydHMuRGVjbGFyZUV4cG9ydEFsbERlY2xhcmF0aW9uID0gYWxpYXMoXCJkZWNsYXJlRXhwb3J0QWxsRGVjbGFyYXRpb25cIiksXG4gIERlY2xhcmVkUHJlZGljYXRlID0gZXhwb3J0cy5EZWNsYXJlZFByZWRpY2F0ZSA9IGFsaWFzKFwiZGVjbGFyZWRQcmVkaWNhdGVcIiksXG4gIEV4aXN0c1R5cGVBbm5vdGF0aW9uID0gZXhwb3J0cy5FeGlzdHNUeXBlQW5ub3RhdGlvbiA9IGFsaWFzKFwiZXhpc3RzVHlwZUFubm90YXRpb25cIiksXG4gIEZ1bmN0aW9uVHlwZUFubm90YXRpb24gPSBleHBvcnRzLkZ1bmN0aW9uVHlwZUFubm90YXRpb24gPSBhbGlhcyhcImZ1bmN0aW9uVHlwZUFubm90YXRpb25cIiksXG4gIEZ1bmN0aW9uVHlwZVBhcmFtID0gZXhwb3J0cy5GdW5jdGlvblR5cGVQYXJhbSA9IGFsaWFzKFwiZnVuY3Rpb25UeXBlUGFyYW1cIiksXG4gIEdlbmVyaWNUeXBlQW5ub3RhdGlvbiA9IGV4cG9ydHMuR2VuZXJpY1R5cGVBbm5vdGF0aW9uID0gYWxpYXMoXCJnZW5lcmljVHlwZUFubm90YXRpb25cIiksXG4gIEluZmVycmVkUHJlZGljYXRlID0gZXhwb3J0cy5JbmZlcnJlZFByZWRpY2F0ZSA9IGFsaWFzKFwiaW5mZXJyZWRQcmVkaWNhdGVcIiksXG4gIEludGVyZmFjZUV4dGVuZHMgPSBleHBvcnRzLkludGVyZmFjZUV4dGVuZHMgPSBhbGlhcyhcImludGVyZmFjZUV4dGVuZHNcIiksXG4gIEludGVyZmFjZURlY2xhcmF0aW9uID0gZXhwb3J0cy5JbnRlcmZhY2VEZWNsYXJhdGlvbiA9IGFsaWFzKFwiaW50ZXJmYWNlRGVjbGFyYXRpb25cIiksXG4gIEludGVyZmFjZVR5cGVBbm5vdGF0aW9uID0gZXhwb3J0cy5JbnRlcmZhY2VUeXBlQW5ub3RhdGlvbiA9IGFsaWFzKFwiaW50ZXJmYWNlVHlwZUFubm90YXRpb25cIiksXG4gIEludGVyc2VjdGlvblR5cGVBbm5vdGF0aW9uID0gZXhwb3J0cy5JbnRlcnNlY3Rpb25UeXBlQW5ub3RhdGlvbiA9IGFsaWFzKFwiaW50ZXJzZWN0aW9uVHlwZUFubm90YXRpb25cIiksXG4gIE1peGVkVHlwZUFubm90YXRpb24gPSBleHBvcnRzLk1peGVkVHlwZUFubm90YXRpb24gPSBhbGlhcyhcIm1peGVkVHlwZUFubm90YXRpb25cIiksXG4gIEVtcHR5VHlwZUFubm90YXRpb24gPSBleHBvcnRzLkVtcHR5VHlwZUFubm90YXRpb24gPSBhbGlhcyhcImVtcHR5VHlwZUFubm90YXRpb25cIiksXG4gIE51bGxhYmxlVHlwZUFubm90YXRpb24gPSBleHBvcnRzLk51bGxhYmxlVHlwZUFubm90YXRpb24gPSBhbGlhcyhcIm51bGxhYmxlVHlwZUFubm90YXRpb25cIiksXG4gIE51bWJlckxpdGVyYWxUeXBlQW5ub3RhdGlvbiA9IGV4cG9ydHMuTnVtYmVyTGl0ZXJhbFR5cGVBbm5vdGF0aW9uID0gYWxpYXMoXCJudW1iZXJMaXRlcmFsVHlwZUFubm90YXRpb25cIiksXG4gIE51bWJlclR5cGVBbm5vdGF0aW9uID0gZXhwb3J0cy5OdW1iZXJUeXBlQW5ub3RhdGlvbiA9IGFsaWFzKFwibnVtYmVyVHlwZUFubm90YXRpb25cIiksXG4gIE9iamVjdFR5cGVBbm5vdGF0aW9uID0gZXhwb3J0cy5PYmplY3RUeXBlQW5ub3RhdGlvbiA9IGFsaWFzKFwib2JqZWN0VHlwZUFubm90YXRpb25cIiksXG4gIE9iamVjdFR5cGVJbnRlcm5hbFNsb3QgPSBleHBvcnRzLk9iamVjdFR5cGVJbnRlcm5hbFNsb3QgPSBhbGlhcyhcIm9iamVjdFR5cGVJbnRlcm5hbFNsb3RcIiksXG4gIE9iamVjdFR5cGVDYWxsUHJvcGVydHkgPSBleHBvcnRzLk9iamVjdFR5cGVDYWxsUHJvcGVydHkgPSBhbGlhcyhcIm9iamVjdFR5cGVDYWxsUHJvcGVydHlcIiksXG4gIE9iamVjdFR5cGVJbmRleGVyID0gZXhwb3J0cy5PYmplY3RUeXBlSW5kZXhlciA9IGFsaWFzKFwib2JqZWN0VHlwZUluZGV4ZXJcIiksXG4gIE9iamVjdFR5cGVQcm9wZXJ0eSA9IGV4cG9ydHMuT2JqZWN0VHlwZVByb3BlcnR5ID0gYWxpYXMoXCJvYmplY3RUeXBlUHJvcGVydHlcIiksXG4gIE9iamVjdFR5cGVTcHJlYWRQcm9wZXJ0eSA9IGV4cG9ydHMuT2JqZWN0VHlwZVNwcmVhZFByb3BlcnR5ID0gYWxpYXMoXCJvYmplY3RUeXBlU3ByZWFkUHJvcGVydHlcIiksXG4gIE9wYXF1ZVR5cGUgPSBleHBvcnRzLk9wYXF1ZVR5cGUgPSBhbGlhcyhcIm9wYXF1ZVR5cGVcIiksXG4gIFF1YWxpZmllZFR5cGVJZGVudGlmaWVyID0gZXhwb3J0cy5RdWFsaWZpZWRUeXBlSWRlbnRpZmllciA9IGFsaWFzKFwicXVhbGlmaWVkVHlwZUlkZW50aWZpZXJcIiksXG4gIFN0cmluZ0xpdGVyYWxUeXBlQW5ub3RhdGlvbiA9IGV4cG9ydHMuU3RyaW5nTGl0ZXJhbFR5cGVBbm5vdGF0aW9uID0gYWxpYXMoXCJzdHJpbmdMaXRlcmFsVHlwZUFubm90YXRpb25cIiksXG4gIFN0cmluZ1R5cGVBbm5vdGF0aW9uID0gZXhwb3J0cy5TdHJpbmdUeXBlQW5ub3RhdGlvbiA9IGFsaWFzKFwic3RyaW5nVHlwZUFubm90YXRpb25cIiksXG4gIFN5bWJvbFR5cGVBbm5vdGF0aW9uID0gZXhwb3J0cy5TeW1ib2xUeXBlQW5ub3RhdGlvbiA9IGFsaWFzKFwic3ltYm9sVHlwZUFubm90YXRpb25cIiksXG4gIFRoaXNUeXBlQW5ub3RhdGlvbiA9IGV4cG9ydHMuVGhpc1R5cGVBbm5vdGF0aW9uID0gYWxpYXMoXCJ0aGlzVHlwZUFubm90YXRpb25cIiksXG4gIFR1cGxlVHlwZUFubm90YXRpb24gPSBleHBvcnRzLlR1cGxlVHlwZUFubm90YXRpb24gPSBhbGlhcyhcInR1cGxlVHlwZUFubm90YXRpb25cIiksXG4gIFR5cGVvZlR5cGVBbm5vdGF0aW9uID0gZXhwb3J0cy5UeXBlb2ZUeXBlQW5ub3RhdGlvbiA9IGFsaWFzKFwidHlwZW9mVHlwZUFubm90YXRpb25cIiksXG4gIFR5cGVBbGlhcyA9IGV4cG9ydHMuVHlwZUFsaWFzID0gYWxpYXMoXCJ0eXBlQWxpYXNcIiksXG4gIFR5cGVBbm5vdGF0aW9uID0gZXhwb3J0cy5UeXBlQW5ub3RhdGlvbiA9IGFsaWFzKFwidHlwZUFubm90YXRpb25cIiksXG4gIFR5cGVDYXN0RXhwcmVzc2lvbiA9IGV4cG9ydHMuVHlwZUNhc3RFeHByZXNzaW9uID0gYWxpYXMoXCJ0eXBlQ2FzdEV4cHJlc3Npb25cIiksXG4gIFR5cGVQYXJhbWV0ZXIgPSBleHBvcnRzLlR5cGVQYXJhbWV0ZXIgPSBhbGlhcyhcInR5cGVQYXJhbWV0ZXJcIiksXG4gIFR5cGVQYXJhbWV0ZXJEZWNsYXJhdGlvbiA9IGV4cG9ydHMuVHlwZVBhcmFtZXRlckRlY2xhcmF0aW9uID0gYWxpYXMoXCJ0eXBlUGFyYW1ldGVyRGVjbGFyYXRpb25cIiksXG4gIFR5cGVQYXJhbWV0ZXJJbnN0YW50aWF0aW9uID0gZXhwb3J0cy5UeXBlUGFyYW1ldGVySW5zdGFudGlhdGlvbiA9IGFsaWFzKFwidHlwZVBhcmFtZXRlckluc3RhbnRpYXRpb25cIiksXG4gIFVuaW9uVHlwZUFubm90YXRpb24gPSBleHBvcnRzLlVuaW9uVHlwZUFubm90YXRpb24gPSBhbGlhcyhcInVuaW9uVHlwZUFubm90YXRpb25cIiksXG4gIFZhcmlhbmNlID0gZXhwb3J0cy5WYXJpYW5jZSA9IGFsaWFzKFwidmFyaWFuY2VcIiksXG4gIFZvaWRUeXBlQW5ub3RhdGlvbiA9IGV4cG9ydHMuVm9pZFR5cGVBbm5vdGF0aW9uID0gYWxpYXMoXCJ2b2lkVHlwZUFubm90YXRpb25cIiksXG4gIEVudW1EZWNsYXJhdGlvbiA9IGV4cG9ydHMuRW51bURlY2xhcmF0aW9uID0gYWxpYXMoXCJlbnVtRGVjbGFyYXRpb25cIiksXG4gIEVudW1Cb29sZWFuQm9keSA9IGV4cG9ydHMuRW51bUJvb2xlYW5Cb2R5ID0gYWxpYXMoXCJlbnVtQm9vbGVhbkJvZHlcIiksXG4gIEVudW1OdW1iZXJCb2R5ID0gZXhwb3J0cy5FbnVtTnVtYmVyQm9keSA9IGFsaWFzKFwiZW51bU51bWJlckJvZHlcIiksXG4gIEVudW1TdHJpbmdCb2R5ID0gZXhwb3J0cy5FbnVtU3RyaW5nQm9keSA9IGFsaWFzKFwiZW51bVN0cmluZ0JvZHlcIiksXG4gIEVudW1TeW1ib2xCb2R5ID0gZXhwb3J0cy5FbnVtU3ltYm9sQm9keSA9IGFsaWFzKFwiZW51bVN5bWJvbEJvZHlcIiksXG4gIEVudW1Cb29sZWFuTWVtYmVyID0gZXhwb3J0cy5FbnVtQm9vbGVhbk1lbWJlciA9IGFsaWFzKFwiZW51bUJvb2xlYW5NZW1iZXJcIiksXG4gIEVudW1OdW1iZXJNZW1iZXIgPSBleHBvcnRzLkVudW1OdW1iZXJNZW1iZXIgPSBhbGlhcyhcImVudW1OdW1iZXJNZW1iZXJcIiksXG4gIEVudW1TdHJpbmdNZW1iZXIgPSBleHBvcnRzLkVudW1TdHJpbmdNZW1iZXIgPSBhbGlhcyhcImVudW1TdHJpbmdNZW1iZXJcIiksXG4gIEVudW1EZWZhdWx0ZWRNZW1iZXIgPSBleHBvcnRzLkVudW1EZWZhdWx0ZWRNZW1iZXIgPSBhbGlhcyhcImVudW1EZWZhdWx0ZWRNZW1iZXJcIiksXG4gIEluZGV4ZWRBY2Nlc3NUeXBlID0gZXhwb3J0cy5JbmRleGVkQWNjZXNzVHlwZSA9IGFsaWFzKFwiaW5kZXhlZEFjY2Vzc1R5cGVcIiksXG4gIE9wdGlvbmFsSW5kZXhlZEFjY2Vzc1R5cGUgPSBleHBvcnRzLk9wdGlvbmFsSW5kZXhlZEFjY2Vzc1R5cGUgPSBhbGlhcyhcIm9wdGlvbmFsSW5kZXhlZEFjY2Vzc1R5cGVcIiksXG4gIEpTWEF0dHJpYnV0ZSA9IGV4cG9ydHMuSlNYQXR0cmlidXRlID0gYWxpYXMoXCJqc3hBdHRyaWJ1dGVcIiksXG4gIEpTWENsb3NpbmdFbGVtZW50ID0gZXhwb3J0cy5KU1hDbG9zaW5nRWxlbWVudCA9IGFsaWFzKFwianN4Q2xvc2luZ0VsZW1lbnRcIiksXG4gIEpTWEVsZW1lbnQgPSBleHBvcnRzLkpTWEVsZW1lbnQgPSBhbGlhcyhcImpzeEVsZW1lbnRcIiksXG4gIEpTWEVtcHR5RXhwcmVzc2lvbiA9IGV4cG9ydHMuSlNYRW1wdHlFeHByZXNzaW9uID0gYWxpYXMoXCJqc3hFbXB0eUV4cHJlc3Npb25cIiksXG4gIEpTWEV4cHJlc3Npb25Db250YWluZXIgPSBleHBvcnRzLkpTWEV4cHJlc3Npb25Db250YWluZXIgPSBhbGlhcyhcImpzeEV4cHJlc3Npb25Db250YWluZXJcIiksXG4gIEpTWFNwcmVhZENoaWxkID0gZXhwb3J0cy5KU1hTcHJlYWRDaGlsZCA9IGFsaWFzKFwianN4U3ByZWFkQ2hpbGRcIiksXG4gIEpTWElkZW50aWZpZXIgPSBleHBvcnRzLkpTWElkZW50aWZpZXIgPSBhbGlhcyhcImpzeElkZW50aWZpZXJcIiksXG4gIEpTWE1lbWJlckV4cHJlc3Npb24gPSBleHBvcnRzLkpTWE1lbWJlckV4cHJlc3Npb24gPSBhbGlhcyhcImpzeE1lbWJlckV4cHJlc3Npb25cIiksXG4gIEpTWE5hbWVzcGFjZWROYW1lID0gZXhwb3J0cy5KU1hOYW1lc3BhY2VkTmFtZSA9IGFsaWFzKFwianN4TmFtZXNwYWNlZE5hbWVcIiksXG4gIEpTWE9wZW5pbmdFbGVtZW50ID0gZXhwb3J0cy5KU1hPcGVuaW5nRWxlbWVudCA9IGFsaWFzKFwianN4T3BlbmluZ0VsZW1lbnRcIiksXG4gIEpTWFNwcmVhZEF0dHJpYnV0ZSA9IGV4cG9ydHMuSlNYU3ByZWFkQXR0cmlidXRlID0gYWxpYXMoXCJqc3hTcHJlYWRBdHRyaWJ1dGVcIiksXG4gIEpTWFRleHQgPSBleHBvcnRzLkpTWFRleHQgPSBhbGlhcyhcImpzeFRleHRcIiksXG4gIEpTWEZyYWdtZW50ID0gZXhwb3J0cy5KU1hGcmFnbWVudCA9IGFsaWFzKFwianN4RnJhZ21lbnRcIiksXG4gIEpTWE9wZW5pbmdGcmFnbWVudCA9IGV4cG9ydHMuSlNYT3BlbmluZ0ZyYWdtZW50ID0gYWxpYXMoXCJqc3hPcGVuaW5nRnJhZ21lbnRcIiksXG4gIEpTWENsb3NpbmdGcmFnbWVudCA9IGV4cG9ydHMuSlNYQ2xvc2luZ0ZyYWdtZW50ID0gYWxpYXMoXCJqc3hDbG9zaW5nRnJhZ21lbnRcIiksXG4gIE5vb3AgPSBleHBvcnRzLk5vb3AgPSBhbGlhcyhcIm5vb3BcIiksXG4gIFBsYWNlaG9sZGVyID0gZXhwb3J0cy5QbGFjZWhvbGRlciA9IGFsaWFzKFwicGxhY2Vob2xkZXJcIiksXG4gIFY4SW50cmluc2ljSWRlbnRpZmllciA9IGV4cG9ydHMuVjhJbnRyaW5zaWNJZGVudGlmaWVyID0gYWxpYXMoXCJ2OEludHJpbnNpY0lkZW50aWZpZXJcIiksXG4gIEFyZ3VtZW50UGxhY2Vob2xkZXIgPSBleHBvcnRzLkFyZ3VtZW50UGxhY2Vob2xkZXIgPSBhbGlhcyhcImFyZ3VtZW50UGxhY2Vob2xkZXJcIiksXG4gIEJpbmRFeHByZXNzaW9uID0gZXhwb3J0cy5CaW5kRXhwcmVzc2lvbiA9IGFsaWFzKFwiYmluZEV4cHJlc3Npb25cIiksXG4gIERlY29yYXRvciA9IGV4cG9ydHMuRGVjb3JhdG9yID0gYWxpYXMoXCJkZWNvcmF0b3JcIiksXG4gIERvRXhwcmVzc2lvbiA9IGV4cG9ydHMuRG9FeHByZXNzaW9uID0gYWxpYXMoXCJkb0V4cHJlc3Npb25cIiksXG4gIEV4cG9ydERlZmF1bHRTcGVjaWZpZXIgPSBleHBvcnRzLkV4cG9ydERlZmF1bHRTcGVjaWZpZXIgPSBhbGlhcyhcImV4cG9ydERlZmF1bHRTcGVjaWZpZXJcIiksXG4gIFJlY29yZEV4cHJlc3Npb24gPSBleHBvcnRzLlJlY29yZEV4cHJlc3Npb24gPSBhbGlhcyhcInJlY29yZEV4cHJlc3Npb25cIiksXG4gIFR1cGxlRXhwcmVzc2lvbiA9IGV4cG9ydHMuVHVwbGVFeHByZXNzaW9uID0gYWxpYXMoXCJ0dXBsZUV4cHJlc3Npb25cIiksXG4gIERlY2ltYWxMaXRlcmFsID0gZXhwb3J0cy5EZWNpbWFsTGl0ZXJhbCA9IGFsaWFzKFwiZGVjaW1hbExpdGVyYWxcIiksXG4gIE1vZHVsZUV4cHJlc3Npb24gPSBleHBvcnRzLk1vZHVsZUV4cHJlc3Npb24gPSBhbGlhcyhcIm1vZHVsZUV4cHJlc3Npb25cIiksXG4gIFRvcGljUmVmZXJlbmNlID0gZXhwb3J0cy5Ub3BpY1JlZmVyZW5jZSA9IGFsaWFzKFwidG9waWNSZWZlcmVuY2VcIiksXG4gIFBpcGVsaW5lVG9waWNFeHByZXNzaW9uID0gZXhwb3J0cy5QaXBlbGluZVRvcGljRXhwcmVzc2lvbiA9IGFsaWFzKFwicGlwZWxpbmVUb3BpY0V4cHJlc3Npb25cIiksXG4gIFBpcGVsaW5lQmFyZUZ1bmN0aW9uID0gZXhwb3J0cy5QaXBlbGluZUJhcmVGdW5jdGlvbiA9IGFsaWFzKFwicGlwZWxpbmVCYXJlRnVuY3Rpb25cIiksXG4gIFBpcGVsaW5lUHJpbWFyeVRvcGljUmVmZXJlbmNlID0gZXhwb3J0cy5QaXBlbGluZVByaW1hcnlUb3BpY1JlZmVyZW5jZSA9IGFsaWFzKFwicGlwZWxpbmVQcmltYXJ5VG9waWNSZWZlcmVuY2VcIiksXG4gIFZvaWRQYXR0ZXJuID0gZXhwb3J0cy5Wb2lkUGF0dGVybiA9IGFsaWFzKFwidm9pZFBhdHRlcm5cIiksXG4gIFRTUGFyYW1ldGVyUHJvcGVydHkgPSBleHBvcnRzLlRTUGFyYW1ldGVyUHJvcGVydHkgPSBhbGlhcyhcInRzUGFyYW1ldGVyUHJvcGVydHlcIiksXG4gIFRTRGVjbGFyZUZ1bmN0aW9uID0gZXhwb3J0cy5UU0RlY2xhcmVGdW5jdGlvbiA9IGFsaWFzKFwidHNEZWNsYXJlRnVuY3Rpb25cIiksXG4gIFRTRGVjbGFyZU1ldGhvZCA9IGV4cG9ydHMuVFNEZWNsYXJlTWV0aG9kID0gYWxpYXMoXCJ0c0RlY2xhcmVNZXRob2RcIiksXG4gIFRTUXVhbGlmaWVkTmFtZSA9IGV4cG9ydHMuVFNRdWFsaWZpZWROYW1lID0gYWxpYXMoXCJ0c1F1YWxpZmllZE5hbWVcIiksXG4gIFRTQ2FsbFNpZ25hdHVyZURlY2xhcmF0aW9uID0gZXhwb3J0cy5UU0NhbGxTaWduYXR1cmVEZWNsYXJhdGlvbiA9IGFsaWFzKFwidHNDYWxsU2lnbmF0dXJlRGVjbGFyYXRpb25cIiksXG4gIFRTQ29uc3RydWN0U2lnbmF0dXJlRGVjbGFyYXRpb24gPSBleHBvcnRzLlRTQ29uc3RydWN0U2lnbmF0dXJlRGVjbGFyYXRpb24gPSBhbGlhcyhcInRzQ29uc3RydWN0U2lnbmF0dXJlRGVjbGFyYXRpb25cIiksXG4gIFRTUHJvcGVydHlTaWduYXR1cmUgPSBleHBvcnRzLlRTUHJvcGVydHlTaWduYXR1cmUgPSBhbGlhcyhcInRzUHJvcGVydHlTaWduYXR1cmVcIiksXG4gIFRTTWV0aG9kU2lnbmF0dXJlID0gZXhwb3J0cy5UU01ldGhvZFNpZ25hdHVyZSA9IGFsaWFzKFwidHNNZXRob2RTaWduYXR1cmVcIiksXG4gIFRTSW5kZXhTaWduYXR1cmUgPSBleHBvcnRzLlRTSW5kZXhTaWduYXR1cmUgPSBhbGlhcyhcInRzSW5kZXhTaWduYXR1cmVcIiksXG4gIFRTQW55S2V5d29yZCA9IGV4cG9ydHMuVFNBbnlLZXl3b3JkID0gYWxpYXMoXCJ0c0FueUtleXdvcmRcIiksXG4gIFRTQm9vbGVhbktleXdvcmQgPSBleHBvcnRzLlRTQm9vbGVhbktleXdvcmQgPSBhbGlhcyhcInRzQm9vbGVhbktleXdvcmRcIiksXG4gIFRTQmlnSW50S2V5d29yZCA9IGV4cG9ydHMuVFNCaWdJbnRLZXl3b3JkID0gYWxpYXMoXCJ0c0JpZ0ludEtleXdvcmRcIiksXG4gIFRTSW50cmluc2ljS2V5d29yZCA9IGV4cG9ydHMuVFNJbnRyaW5zaWNLZXl3b3JkID0gYWxpYXMoXCJ0c0ludHJpbnNpY0tleXdvcmRcIiksXG4gIFRTTmV2ZXJLZXl3b3JkID0gZXhwb3J0cy5UU05ldmVyS2V5d29yZCA9IGFsaWFzKFwidHNOZXZlcktleXdvcmRcIiksXG4gIFRTTnVsbEtleXdvcmQgPSBleHBvcnRzLlRTTnVsbEtleXdvcmQgPSBhbGlhcyhcInRzTnVsbEtleXdvcmRcIiksXG4gIFRTTnVtYmVyS2V5d29yZCA9IGV4cG9ydHMuVFNOdW1iZXJLZXl3b3JkID0gYWxpYXMoXCJ0c051bWJlcktleXdvcmRcIiksXG4gIFRTT2JqZWN0S2V5d29yZCA9IGV4cG9ydHMuVFNPYmplY3RLZXl3b3JkID0gYWxpYXMoXCJ0c09iamVjdEtleXdvcmRcIiksXG4gIFRTU3RyaW5nS2V5d29yZCA9IGV4cG9ydHMuVFNTdHJpbmdLZXl3b3JkID0gYWxpYXMoXCJ0c1N0cmluZ0tleXdvcmRcIiksXG4gIFRTU3ltYm9sS2V5d29yZCA9IGV4cG9ydHMuVFNTeW1ib2xLZXl3b3JkID0gYWxpYXMoXCJ0c1N5bWJvbEtleXdvcmRcIiksXG4gIFRTVW5kZWZpbmVkS2V5d29yZCA9IGV4cG9ydHMuVFNVbmRlZmluZWRLZXl3b3JkID0gYWxpYXMoXCJ0c1VuZGVmaW5lZEtleXdvcmRcIiksXG4gIFRTVW5rbm93bktleXdvcmQgPSBleHBvcnRzLlRTVW5rbm93bktleXdvcmQgPSBhbGlhcyhcInRzVW5rbm93bktleXdvcmRcIiksXG4gIFRTVm9pZEtleXdvcmQgPSBleHBvcnRzLlRTVm9pZEtleXdvcmQgPSBhbGlhcyhcInRzVm9pZEtleXdvcmRcIiksXG4gIFRTVGhpc1R5cGUgPSBleHBvcnRzLlRTVGhpc1R5cGUgPSBhbGlhcyhcInRzVGhpc1R5cGVcIiksXG4gIFRTRnVuY3Rpb25UeXBlID0gZXhwb3J0cy5UU0Z1bmN0aW9uVHlwZSA9IGFsaWFzKFwidHNGdW5jdGlvblR5cGVcIiksXG4gIFRTQ29uc3RydWN0b3JUeXBlID0gZXhwb3J0cy5UU0NvbnN0cnVjdG9yVHlwZSA9IGFsaWFzKFwidHNDb25zdHJ1Y3RvclR5cGVcIiksXG4gIFRTVHlwZVJlZmVyZW5jZSA9IGV4cG9ydHMuVFNUeXBlUmVmZXJlbmNlID0gYWxpYXMoXCJ0c1R5cGVSZWZlcmVuY2VcIiksXG4gIFRTVHlwZVByZWRpY2F0ZSA9IGV4cG9ydHMuVFNUeXBlUHJlZGljYXRlID0gYWxpYXMoXCJ0c1R5cGVQcmVkaWNhdGVcIiksXG4gIFRTVHlwZVF1ZXJ5ID0gZXhwb3J0cy5UU1R5cGVRdWVyeSA9IGFsaWFzKFwidHNUeXBlUXVlcnlcIiksXG4gIFRTVHlwZUxpdGVyYWwgPSBleHBvcnRzLlRTVHlwZUxpdGVyYWwgPSBhbGlhcyhcInRzVHlwZUxpdGVyYWxcIiksXG4gIFRTQXJyYXlUeXBlID0gZXhwb3J0cy5UU0FycmF5VHlwZSA9IGFsaWFzKFwidHNBcnJheVR5cGVcIiksXG4gIFRTVHVwbGVUeXBlID0gZXhwb3J0cy5UU1R1cGxlVHlwZSA9IGFsaWFzKFwidHNUdXBsZVR5cGVcIiksXG4gIFRTT3B0aW9uYWxUeXBlID0gZXhwb3J0cy5UU09wdGlvbmFsVHlwZSA9IGFsaWFzKFwidHNPcHRpb25hbFR5cGVcIiksXG4gIFRTUmVzdFR5cGUgPSBleHBvcnRzLlRTUmVzdFR5cGUgPSBhbGlhcyhcInRzUmVzdFR5cGVcIiksXG4gIFRTTmFtZWRUdXBsZU1lbWJlciA9IGV4cG9ydHMuVFNOYW1lZFR1cGxlTWVtYmVyID0gYWxpYXMoXCJ0c05hbWVkVHVwbGVNZW1iZXJcIiksXG4gIFRTVW5pb25UeXBlID0gZXhwb3J0cy5UU1VuaW9uVHlwZSA9IGFsaWFzKFwidHNVbmlvblR5cGVcIiksXG4gIFRTSW50ZXJzZWN0aW9uVHlwZSA9IGV4cG9ydHMuVFNJbnRlcnNlY3Rpb25UeXBlID0gYWxpYXMoXCJ0c0ludGVyc2VjdGlvblR5cGVcIiksXG4gIFRTQ29uZGl0aW9uYWxUeXBlID0gZXhwb3J0cy5UU0NvbmRpdGlvbmFsVHlwZSA9IGFsaWFzKFwidHNDb25kaXRpb25hbFR5cGVcIiksXG4gIFRTSW5mZXJUeXBlID0gZXhwb3J0cy5UU0luZmVyVHlwZSA9IGFsaWFzKFwidHNJbmZlclR5cGVcIiksXG4gIFRTUGFyZW50aGVzaXplZFR5cGUgPSBleHBvcnRzLlRTUGFyZW50aGVzaXplZFR5cGUgPSBhbGlhcyhcInRzUGFyZW50aGVzaXplZFR5cGVcIiksXG4gIFRTVHlwZU9wZXJhdG9yID0gZXhwb3J0cy5UU1R5cGVPcGVyYXRvciA9IGFsaWFzKFwidHNUeXBlT3BlcmF0b3JcIiksXG4gIFRTSW5kZXhlZEFjY2Vzc1R5cGUgPSBleHBvcnRzLlRTSW5kZXhlZEFjY2Vzc1R5cGUgPSBhbGlhcyhcInRzSW5kZXhlZEFjY2Vzc1R5cGVcIiksXG4gIFRTTWFwcGVkVHlwZSA9IGV4cG9ydHMuVFNNYXBwZWRUeXBlID0gYWxpYXMoXCJ0c01hcHBlZFR5cGVcIiksXG4gIFRTVGVtcGxhdGVMaXRlcmFsVHlwZSA9IGV4cG9ydHMuVFNUZW1wbGF0ZUxpdGVyYWxUeXBlID0gYWxpYXMoXCJ0c1RlbXBsYXRlTGl0ZXJhbFR5cGVcIiksXG4gIFRTTGl0ZXJhbFR5cGUgPSBleHBvcnRzLlRTTGl0ZXJhbFR5cGUgPSBhbGlhcyhcInRzTGl0ZXJhbFR5cGVcIiksXG4gIFRTRXhwcmVzc2lvbldpdGhUeXBlQXJndW1lbnRzID0gZXhwb3J0cy5UU0V4cHJlc3Npb25XaXRoVHlwZUFyZ3VtZW50cyA9IGFsaWFzKFwidHNFeHByZXNzaW9uV2l0aFR5cGVBcmd1bWVudHNcIiksXG4gIFRTSW50ZXJmYWNlRGVjbGFyYXRpb24gPSBleHBvcnRzLlRTSW50ZXJmYWNlRGVjbGFyYXRpb24gPSBhbGlhcyhcInRzSW50ZXJmYWNlRGVjbGFyYXRpb25cIiksXG4gIFRTSW50ZXJmYWNlQm9keSA9IGV4cG9ydHMuVFNJbnRlcmZhY2VCb2R5ID0gYWxpYXMoXCJ0c0ludGVyZmFjZUJvZHlcIiksXG4gIFRTVHlwZUFsaWFzRGVjbGFyYXRpb24gPSBleHBvcnRzLlRTVHlwZUFsaWFzRGVjbGFyYXRpb24gPSBhbGlhcyhcInRzVHlwZUFsaWFzRGVjbGFyYXRpb25cIiksXG4gIFRTSW5zdGFudGlhdGlvbkV4cHJlc3Npb24gPSBleHBvcnRzLlRTSW5zdGFudGlhdGlvbkV4cHJlc3Npb24gPSBhbGlhcyhcInRzSW5zdGFudGlhdGlvbkV4cHJlc3Npb25cIiksXG4gIFRTQXNFeHByZXNzaW9uID0gZXhwb3J0cy5UU0FzRXhwcmVzc2lvbiA9IGFsaWFzKFwidHNBc0V4cHJlc3Npb25cIiksXG4gIFRTU2F0aXNmaWVzRXhwcmVzc2lvbiA9IGV4cG9ydHMuVFNTYXRpc2ZpZXNFeHByZXNzaW9uID0gYWxpYXMoXCJ0c1NhdGlzZmllc0V4cHJlc3Npb25cIiksXG4gIFRTVHlwZUFzc2VydGlvbiA9IGV4cG9ydHMuVFNUeXBlQXNzZXJ0aW9uID0gYWxpYXMoXCJ0c1R5cGVBc3NlcnRpb25cIiksXG4gIFRTRW51bUJvZHkgPSBleHBvcnRzLlRTRW51bUJvZHkgPSBhbGlhcyhcInRzRW51bUJvZHlcIiksXG4gIFRTRW51bURlY2xhcmF0aW9uID0gZXhwb3J0cy5UU0VudW1EZWNsYXJhdGlvbiA9IGFsaWFzKFwidHNFbnVtRGVjbGFyYXRpb25cIiksXG4gIFRTRW51bU1lbWJlciA9IGV4cG9ydHMuVFNFbnVtTWVtYmVyID0gYWxpYXMoXCJ0c0VudW1NZW1iZXJcIiksXG4gIFRTTW9kdWxlRGVjbGFyYXRpb24gPSBleHBvcnRzLlRTTW9kdWxlRGVjbGFyYXRpb24gPSBhbGlhcyhcInRzTW9kdWxlRGVjbGFyYXRpb25cIiksXG4gIFRTTW9kdWxlQmxvY2sgPSBleHBvcnRzLlRTTW9kdWxlQmxvY2sgPSBhbGlhcyhcInRzTW9kdWxlQmxvY2tcIiksXG4gIFRTSW1wb3J0VHlwZSA9IGV4cG9ydHMuVFNJbXBvcnRUeXBlID0gYWxpYXMoXCJ0c0ltcG9ydFR5cGVcIiksXG4gIFRTSW1wb3J0RXF1YWxzRGVjbGFyYXRpb24gPSBleHBvcnRzLlRTSW1wb3J0RXF1YWxzRGVjbGFyYXRpb24gPSBhbGlhcyhcInRzSW1wb3J0RXF1YWxzRGVjbGFyYXRpb25cIiksXG4gIFRTRXh0ZXJuYWxNb2R1bGVSZWZlcmVuY2UgPSBleHBvcnRzLlRTRXh0ZXJuYWxNb2R1bGVSZWZlcmVuY2UgPSBhbGlhcyhcInRzRXh0ZXJuYWxNb2R1bGVSZWZlcmVuY2VcIiksXG4gIFRTTm9uTnVsbEV4cHJlc3Npb24gPSBleHBvcnRzLlRTTm9uTnVsbEV4cHJlc3Npb24gPSBhbGlhcyhcInRzTm9uTnVsbEV4cHJlc3Npb25cIiksXG4gIFRTRXhwb3J0QXNzaWdubWVudCA9IGV4cG9ydHMuVFNFeHBvcnRBc3NpZ25tZW50ID0gYWxpYXMoXCJ0c0V4cG9ydEFzc2lnbm1lbnRcIiksXG4gIFRTTmFtZXNwYWNlRXhwb3J0RGVjbGFyYXRpb24gPSBleHBvcnRzLlRTTmFtZXNwYWNlRXhwb3J0RGVjbGFyYXRpb24gPSBhbGlhcyhcInRzTmFtZXNwYWNlRXhwb3J0RGVjbGFyYXRpb25cIiksXG4gIFRTVHlwZUFubm90YXRpb24gPSBleHBvcnRzLlRTVHlwZUFubm90YXRpb24gPSBhbGlhcyhcInRzVHlwZUFubm90YXRpb25cIiksXG4gIFRTVHlwZVBhcmFtZXRlckluc3RhbnRpYXRpb24gPSBleHBvcnRzLlRTVHlwZVBhcmFtZXRlckluc3RhbnRpYXRpb24gPSBhbGlhcyhcInRzVHlwZVBhcmFtZXRlckluc3RhbnRpYXRpb25cIiksXG4gIFRTVHlwZVBhcmFtZXRlckRlY2xhcmF0aW9uID0gZXhwb3J0cy5UU1R5cGVQYXJhbWV0ZXJEZWNsYXJhdGlvbiA9IGFsaWFzKFwidHNUeXBlUGFyYW1ldGVyRGVjbGFyYXRpb25cIiksXG4gIFRTVHlwZVBhcmFtZXRlciA9IGV4cG9ydHMuVFNUeXBlUGFyYW1ldGVyID0gYWxpYXMoXCJ0c1R5cGVQYXJhbWV0ZXJcIik7XG5jb25zdCBOdW1iZXJMaXRlcmFsID0gZXhwb3J0cy5OdW1iZXJMaXRlcmFsID0gYi5udW1iZXJMaXRlcmFsLFxuICBSZWdleExpdGVyYWwgPSBleHBvcnRzLlJlZ2V4TGl0ZXJhbCA9IGIucmVnZXhMaXRlcmFsLFxuICBSZXN0UHJvcGVydHkgPSBleHBvcnRzLlJlc3RQcm9wZXJ0eSA9IGIucmVzdFByb3BlcnR5LFxuICBTcHJlYWRQcm9wZXJ0eSA9IGV4cG9ydHMuU3ByZWFkUHJvcGVydHkgPSBiLnNwcmVhZFByb3BlcnR5O1xuXG4vLyMgc291cmNlTWFwcGluZ1VSTD11cHBlcmNhc2UuanMubWFwXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@babel/types/lib/builders/generated/uppercase.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@babel/types/lib/builders/productions.js":
/*!***************************************************************!*\
  !*** ./node_modules/@babel/types/lib/builders/productions.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports.buildUndefinedNode = buildUndefinedNode;\nvar _index = __webpack_require__(/*! ./generated/index.js */ \"(ssr)/./node_modules/@babel/types/lib/builders/generated/index.js\");\nfunction buildUndefinedNode() {\n  return (0, _index.unaryExpression)(\"void\", (0, _index.numericLiteral)(0), true);\n}\n\n//# sourceMappingURL=productions.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGJhYmVsL3R5cGVzL2xpYi9idWlsZGVycy9wcm9kdWN0aW9ucy5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYiw4Q0FBNkM7QUFDN0M7QUFDQSxDQUFDLEVBQUM7QUFDRiwwQkFBMEI7QUFDMUIsYUFBYSxtQkFBTyxDQUFDLCtGQUFzQjtBQUMzQztBQUNBO0FBQ0E7O0FBRUEiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9yZXBvLXZpc3VhbGl6ZXIvLi9ub2RlX21vZHVsZXMvQGJhYmVsL3R5cGVzL2xpYi9idWlsZGVycy9wcm9kdWN0aW9ucy5qcz9jOTY5Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5idWlsZFVuZGVmaW5lZE5vZGUgPSBidWlsZFVuZGVmaW5lZE5vZGU7XG52YXIgX2luZGV4ID0gcmVxdWlyZShcIi4vZ2VuZXJhdGVkL2luZGV4LmpzXCIpO1xuZnVuY3Rpb24gYnVpbGRVbmRlZmluZWROb2RlKCkge1xuICByZXR1cm4gKDAsIF9pbmRleC51bmFyeUV4cHJlc3Npb24pKFwidm9pZFwiLCAoMCwgX2luZGV4Lm51bWVyaWNMaXRlcmFsKSgwKSwgdHJ1ZSk7XG59XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXByb2R1Y3Rpb25zLmpzLm1hcFxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@babel/types/lib/builders/productions.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@babel/types/lib/builders/react/buildChildren.js":
/*!***********************************************************************!*\
  !*** ./node_modules/@babel/types/lib/builders/react/buildChildren.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports[\"default\"] = buildChildren;\nvar _index = __webpack_require__(/*! ../../validators/generated/index.js */ \"(ssr)/./node_modules/@babel/types/lib/validators/generated/index.js\");\nvar _cleanJSXElementLiteralChild = __webpack_require__(/*! ../../utils/react/cleanJSXElementLiteralChild.js */ \"(ssr)/./node_modules/@babel/types/lib/utils/react/cleanJSXElementLiteralChild.js\");\nfunction buildChildren(node) {\n  const elements = [];\n  for (let i = 0; i < node.children.length; i++) {\n    let child = node.children[i];\n    if ((0, _index.isJSXText)(child)) {\n      (0, _cleanJSXElementLiteralChild.default)(child, elements);\n      continue;\n    }\n    if ((0, _index.isJSXExpressionContainer)(child)) child = child.expression;\n    if ((0, _index.isJSXEmptyExpression)(child)) continue;\n    elements.push(child);\n  }\n  return elements;\n}\n\n//# sourceMappingURL=buildChildren.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGJhYmVsL3R5cGVzL2xpYi9idWlsZGVycy9yZWFjdC9idWlsZENoaWxkcmVuLmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViLDhDQUE2QztBQUM3QztBQUNBLENBQUMsRUFBQztBQUNGLGtCQUFlO0FBQ2YsYUFBYSxtQkFBTyxDQUFDLGdIQUFxQztBQUMxRCxtQ0FBbUMsbUJBQU8sQ0FBQywwSUFBa0Q7QUFDN0Y7QUFDQTtBQUNBLGtCQUFrQiwwQkFBMEI7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSIsInNvdXJjZXMiOlsid2VicGFjazovL3JlcG8tdmlzdWFsaXplci8uL25vZGVfbW9kdWxlcy9AYmFiZWwvdHlwZXMvbGliL2J1aWxkZXJzL3JlYWN0L2J1aWxkQ2hpbGRyZW4uanM/ZTNlMSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuZGVmYXVsdCA9IGJ1aWxkQ2hpbGRyZW47XG52YXIgX2luZGV4ID0gcmVxdWlyZShcIi4uLy4uL3ZhbGlkYXRvcnMvZ2VuZXJhdGVkL2luZGV4LmpzXCIpO1xudmFyIF9jbGVhbkpTWEVsZW1lbnRMaXRlcmFsQ2hpbGQgPSByZXF1aXJlKFwiLi4vLi4vdXRpbHMvcmVhY3QvY2xlYW5KU1hFbGVtZW50TGl0ZXJhbENoaWxkLmpzXCIpO1xuZnVuY3Rpb24gYnVpbGRDaGlsZHJlbihub2RlKSB7XG4gIGNvbnN0IGVsZW1lbnRzID0gW107XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgbm9kZS5jaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgIGxldCBjaGlsZCA9IG5vZGUuY2hpbGRyZW5baV07XG4gICAgaWYgKCgwLCBfaW5kZXguaXNKU1hUZXh0KShjaGlsZCkpIHtcbiAgICAgICgwLCBfY2xlYW5KU1hFbGVtZW50TGl0ZXJhbENoaWxkLmRlZmF1bHQpKGNoaWxkLCBlbGVtZW50cyk7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgaWYgKCgwLCBfaW5kZXguaXNKU1hFeHByZXNzaW9uQ29udGFpbmVyKShjaGlsZCkpIGNoaWxkID0gY2hpbGQuZXhwcmVzc2lvbjtcbiAgICBpZiAoKDAsIF9pbmRleC5pc0pTWEVtcHR5RXhwcmVzc2lvbikoY2hpbGQpKSBjb250aW51ZTtcbiAgICBlbGVtZW50cy5wdXNoKGNoaWxkKTtcbiAgfVxuICByZXR1cm4gZWxlbWVudHM7XG59XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWJ1aWxkQ2hpbGRyZW4uanMubWFwXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@babel/types/lib/builders/react/buildChildren.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@babel/types/lib/builders/typescript/createTSUnionType.js":
/*!********************************************************************************!*\
  !*** ./node_modules/@babel/types/lib/builders/typescript/createTSUnionType.js ***!
  \********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports[\"default\"] = createTSUnionType;\nvar _index = __webpack_require__(/*! ../generated/index.js */ \"(ssr)/./node_modules/@babel/types/lib/builders/generated/index.js\");\nvar _removeTypeDuplicates = __webpack_require__(/*! ../../modifications/typescript/removeTypeDuplicates.js */ \"(ssr)/./node_modules/@babel/types/lib/modifications/typescript/removeTypeDuplicates.js\");\nvar _index2 = __webpack_require__(/*! ../../validators/generated/index.js */ \"(ssr)/./node_modules/@babel/types/lib/validators/generated/index.js\");\nfunction createTSUnionType(typeAnnotations) {\n  const types = typeAnnotations.map(type => {\n    return (0, _index2.isTSTypeAnnotation)(type) ? type.typeAnnotation : type;\n  });\n  const flattened = (0, _removeTypeDuplicates.default)(types);\n  if (flattened.length === 1) {\n    return flattened[0];\n  } else {\n    return (0, _index.tsUnionType)(flattened);\n  }\n}\n\n//# sourceMappingURL=createTSUnionType.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGJhYmVsL3R5cGVzL2xpYi9idWlsZGVycy90eXBlc2NyaXB0L2NyZWF0ZVRTVW5pb25UeXBlLmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViLDhDQUE2QztBQUM3QztBQUNBLENBQUMsRUFBQztBQUNGLGtCQUFlO0FBQ2YsYUFBYSxtQkFBTyxDQUFDLGdHQUF1QjtBQUM1Qyw0QkFBNEIsbUJBQU8sQ0FBQyxzSkFBd0Q7QUFDNUYsY0FBYyxtQkFBTyxDQUFDLGdIQUFxQztBQUMzRDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTs7QUFFQSIsInNvdXJjZXMiOlsid2VicGFjazovL3JlcG8tdmlzdWFsaXplci8uL25vZGVfbW9kdWxlcy9AYmFiZWwvdHlwZXMvbGliL2J1aWxkZXJzL3R5cGVzY3JpcHQvY3JlYXRlVFNVbmlvblR5cGUuanM/ZWNhMCJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuZGVmYXVsdCA9IGNyZWF0ZVRTVW5pb25UeXBlO1xudmFyIF9pbmRleCA9IHJlcXVpcmUoXCIuLi9nZW5lcmF0ZWQvaW5kZXguanNcIik7XG52YXIgX3JlbW92ZVR5cGVEdXBsaWNhdGVzID0gcmVxdWlyZShcIi4uLy4uL21vZGlmaWNhdGlvbnMvdHlwZXNjcmlwdC9yZW1vdmVUeXBlRHVwbGljYXRlcy5qc1wiKTtcbnZhciBfaW5kZXgyID0gcmVxdWlyZShcIi4uLy4uL3ZhbGlkYXRvcnMvZ2VuZXJhdGVkL2luZGV4LmpzXCIpO1xuZnVuY3Rpb24gY3JlYXRlVFNVbmlvblR5cGUodHlwZUFubm90YXRpb25zKSB7XG4gIGNvbnN0IHR5cGVzID0gdHlwZUFubm90YXRpb25zLm1hcCh0eXBlID0+IHtcbiAgICByZXR1cm4gKDAsIF9pbmRleDIuaXNUU1R5cGVBbm5vdGF0aW9uKSh0eXBlKSA/IHR5cGUudHlwZUFubm90YXRpb24gOiB0eXBlO1xuICB9KTtcbiAgY29uc3QgZmxhdHRlbmVkID0gKDAsIF9yZW1vdmVUeXBlRHVwbGljYXRlcy5kZWZhdWx0KSh0eXBlcyk7XG4gIGlmIChmbGF0dGVuZWQubGVuZ3RoID09PSAxKSB7XG4gICAgcmV0dXJuIGZsYXR0ZW5lZFswXTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gKDAsIF9pbmRleC50c1VuaW9uVHlwZSkoZmxhdHRlbmVkKTtcbiAgfVxufVxuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1jcmVhdGVUU1VuaW9uVHlwZS5qcy5tYXBcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@babel/types/lib/builders/typescript/createTSUnionType.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@babel/types/lib/clone/clone.js":
/*!******************************************************!*\
  !*** ./node_modules/@babel/types/lib/clone/clone.js ***!
  \******************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports[\"default\"] = clone;\nvar _cloneNode = __webpack_require__(/*! ./cloneNode.js */ \"(ssr)/./node_modules/@babel/types/lib/clone/cloneNode.js\");\nfunction clone(node) {\n  return (0, _cloneNode.default)(node, false);\n}\n\n//# sourceMappingURL=clone.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGJhYmVsL3R5cGVzL2xpYi9jbG9uZS9jbG9uZS5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYiw4Q0FBNkM7QUFDN0M7QUFDQSxDQUFDLEVBQUM7QUFDRixrQkFBZTtBQUNmLGlCQUFpQixtQkFBTyxDQUFDLGdGQUFnQjtBQUN6QztBQUNBO0FBQ0E7O0FBRUEiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9yZXBvLXZpc3VhbGl6ZXIvLi9ub2RlX21vZHVsZXMvQGJhYmVsL3R5cGVzL2xpYi9jbG9uZS9jbG9uZS5qcz9jODhlIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5kZWZhdWx0ID0gY2xvbmU7XG52YXIgX2Nsb25lTm9kZSA9IHJlcXVpcmUoXCIuL2Nsb25lTm9kZS5qc1wiKTtcbmZ1bmN0aW9uIGNsb25lKG5vZGUpIHtcbiAgcmV0dXJuICgwLCBfY2xvbmVOb2RlLmRlZmF1bHQpKG5vZGUsIGZhbHNlKTtcbn1cblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y2xvbmUuanMubWFwXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@babel/types/lib/clone/clone.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@babel/types/lib/clone/cloneDeep.js":
/*!**********************************************************!*\
  !*** ./node_modules/@babel/types/lib/clone/cloneDeep.js ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports[\"default\"] = cloneDeep;\nvar _cloneNode = __webpack_require__(/*! ./cloneNode.js */ \"(ssr)/./node_modules/@babel/types/lib/clone/cloneNode.js\");\nfunction cloneDeep(node) {\n  return (0, _cloneNode.default)(node);\n}\n\n//# sourceMappingURL=cloneDeep.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGJhYmVsL3R5cGVzL2xpYi9jbG9uZS9jbG9uZURlZXAuanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWIsOENBQTZDO0FBQzdDO0FBQ0EsQ0FBQyxFQUFDO0FBQ0Ysa0JBQWU7QUFDZixpQkFBaUIsbUJBQU8sQ0FBQyxnRkFBZ0I7QUFDekM7QUFDQTtBQUNBOztBQUVBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcmVwby12aXN1YWxpemVyLy4vbm9kZV9tb2R1bGVzL0BiYWJlbC90eXBlcy9saWIvY2xvbmUvY2xvbmVEZWVwLmpzP2Y0NDIiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLmRlZmF1bHQgPSBjbG9uZURlZXA7XG52YXIgX2Nsb25lTm9kZSA9IHJlcXVpcmUoXCIuL2Nsb25lTm9kZS5qc1wiKTtcbmZ1bmN0aW9uIGNsb25lRGVlcChub2RlKSB7XG4gIHJldHVybiAoMCwgX2Nsb25lTm9kZS5kZWZhdWx0KShub2RlKTtcbn1cblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y2xvbmVEZWVwLmpzLm1hcFxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@babel/types/lib/clone/cloneDeep.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@babel/types/lib/clone/cloneDeepWithoutLoc.js":
/*!********************************************************************!*\
  !*** ./node_modules/@babel/types/lib/clone/cloneDeepWithoutLoc.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports[\"default\"] = cloneDeepWithoutLoc;\nvar _cloneNode = __webpack_require__(/*! ./cloneNode.js */ \"(ssr)/./node_modules/@babel/types/lib/clone/cloneNode.js\");\nfunction cloneDeepWithoutLoc(node) {\n  return (0, _cloneNode.default)(node, true, true);\n}\n\n//# sourceMappingURL=cloneDeepWithoutLoc.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGJhYmVsL3R5cGVzL2xpYi9jbG9uZS9jbG9uZURlZXBXaXRob3V0TG9jLmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViLDhDQUE2QztBQUM3QztBQUNBLENBQUMsRUFBQztBQUNGLGtCQUFlO0FBQ2YsaUJBQWlCLG1CQUFPLENBQUMsZ0ZBQWdCO0FBQ3pDO0FBQ0E7QUFDQTs7QUFFQSIsInNvdXJjZXMiOlsid2VicGFjazovL3JlcG8tdmlzdWFsaXplci8uL25vZGVfbW9kdWxlcy9AYmFiZWwvdHlwZXMvbGliL2Nsb25lL2Nsb25lRGVlcFdpdGhvdXRMb2MuanM/OTI0MCJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuZGVmYXVsdCA9IGNsb25lRGVlcFdpdGhvdXRMb2M7XG52YXIgX2Nsb25lTm9kZSA9IHJlcXVpcmUoXCIuL2Nsb25lTm9kZS5qc1wiKTtcbmZ1bmN0aW9uIGNsb25lRGVlcFdpdGhvdXRMb2Mobm9kZSkge1xuICByZXR1cm4gKDAsIF9jbG9uZU5vZGUuZGVmYXVsdCkobm9kZSwgdHJ1ZSwgdHJ1ZSk7XG59XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNsb25lRGVlcFdpdGhvdXRMb2MuanMubWFwXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@babel/types/lib/clone/cloneDeepWithoutLoc.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@babel/types/lib/clone/cloneNode.js":
/*!**********************************************************!*\
  !*** ./node_modules/@babel/types/lib/clone/cloneNode.js ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports[\"default\"] = cloneNode;\nvar _index = __webpack_require__(/*! ../definitions/index.js */ \"(ssr)/./node_modules/@babel/types/lib/definitions/index.js\");\nvar _index2 = __webpack_require__(/*! ../validators/generated/index.js */ \"(ssr)/./node_modules/@babel/types/lib/validators/generated/index.js\");\nconst {\n  hasOwn\n} = {\n  hasOwn: Function.call.bind(Object.prototype.hasOwnProperty)\n};\nfunction cloneIfNode(obj, deep, withoutLoc, commentsCache) {\n  if (obj && typeof obj.type === \"string\") {\n    return cloneNodeInternal(obj, deep, withoutLoc, commentsCache);\n  }\n  return obj;\n}\nfunction cloneIfNodeOrArray(obj, deep, withoutLoc, commentsCache) {\n  if (Array.isArray(obj)) {\n    return obj.map(node => cloneIfNode(node, deep, withoutLoc, commentsCache));\n  }\n  return cloneIfNode(obj, deep, withoutLoc, commentsCache);\n}\nfunction cloneNode(node, deep = true, withoutLoc = false) {\n  return cloneNodeInternal(node, deep, withoutLoc, new Map());\n}\nfunction cloneNodeInternal(node, deep = true, withoutLoc = false, commentsCache) {\n  if (!node) return node;\n  const {\n    type\n  } = node;\n  const newNode = {\n    type: node.type\n  };\n  if ((0, _index2.isIdentifier)(node)) {\n    newNode.name = node.name;\n    if (hasOwn(node, \"optional\") && typeof node.optional === \"boolean\") {\n      newNode.optional = node.optional;\n    }\n    if (hasOwn(node, \"typeAnnotation\")) {\n      newNode.typeAnnotation = deep ? cloneIfNodeOrArray(node.typeAnnotation, true, withoutLoc, commentsCache) : node.typeAnnotation;\n    }\n    if (hasOwn(node, \"decorators\")) {\n      newNode.decorators = deep ? cloneIfNodeOrArray(node.decorators, true, withoutLoc, commentsCache) : node.decorators;\n    }\n  } else if (!hasOwn(_index.NODE_FIELDS, type)) {\n    throw new Error(`Unknown node type: \"${type}\"`);\n  } else {\n    for (const field of Object.keys(_index.NODE_FIELDS[type])) {\n      if (hasOwn(node, field)) {\n        if (deep) {\n          newNode[field] = (0, _index2.isFile)(node) && field === \"comments\" ? maybeCloneComments(node.comments, deep, withoutLoc, commentsCache) : cloneIfNodeOrArray(node[field], true, withoutLoc, commentsCache);\n        } else {\n          newNode[field] = node[field];\n        }\n      }\n    }\n  }\n  if (hasOwn(node, \"loc\")) {\n    if (withoutLoc) {\n      newNode.loc = null;\n    } else {\n      newNode.loc = node.loc;\n    }\n  }\n  if (hasOwn(node, \"leadingComments\")) {\n    newNode.leadingComments = maybeCloneComments(node.leadingComments, deep, withoutLoc, commentsCache);\n  }\n  if (hasOwn(node, \"innerComments\")) {\n    newNode.innerComments = maybeCloneComments(node.innerComments, deep, withoutLoc, commentsCache);\n  }\n  if (hasOwn(node, \"trailingComments\")) {\n    newNode.trailingComments = maybeCloneComments(node.trailingComments, deep, withoutLoc, commentsCache);\n  }\n  if (hasOwn(node, \"extra\")) {\n    newNode.extra = Object.assign({}, node.extra);\n  }\n  return newNode;\n}\nfunction maybeCloneComments(comments, deep, withoutLoc, commentsCache) {\n  if (!comments || !deep) {\n    return comments;\n  }\n  return comments.map(comment => {\n    const cache = commentsCache.get(comment);\n    if (cache) return cache;\n    const {\n      type,\n      value,\n      loc\n    } = comment;\n    const ret = {\n      type,\n      value,\n      loc\n    };\n    if (withoutLoc) {\n      ret.loc = null;\n    }\n    commentsCache.set(comment, ret);\n    return ret;\n  });\n}\n\n//# sourceMappingURL=cloneNode.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGJhYmVsL3R5cGVzL2xpYi9jbG9uZS9jbG9uZU5vZGUuanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWIsOENBQTZDO0FBQzdDO0FBQ0EsQ0FBQyxFQUFDO0FBQ0Ysa0JBQWU7QUFDZixhQUFhLG1CQUFPLENBQUMsMkZBQXlCO0FBQzlDLGNBQWMsbUJBQU8sQ0FBQyw2R0FBa0M7QUFDeEQ7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSiwyQ0FBMkMsS0FBSztBQUNoRCxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQztBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcmVwby12aXN1YWxpemVyLy4vbm9kZV9tb2R1bGVzL0BiYWJlbC90eXBlcy9saWIvY2xvbmUvY2xvbmVOb2RlLmpzP2UwODEiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLmRlZmF1bHQgPSBjbG9uZU5vZGU7XG52YXIgX2luZGV4ID0gcmVxdWlyZShcIi4uL2RlZmluaXRpb25zL2luZGV4LmpzXCIpO1xudmFyIF9pbmRleDIgPSByZXF1aXJlKFwiLi4vdmFsaWRhdG9ycy9nZW5lcmF0ZWQvaW5kZXguanNcIik7XG5jb25zdCB7XG4gIGhhc093blxufSA9IHtcbiAgaGFzT3duOiBGdW5jdGlvbi5jYWxsLmJpbmQoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eSlcbn07XG5mdW5jdGlvbiBjbG9uZUlmTm9kZShvYmosIGRlZXAsIHdpdGhvdXRMb2MsIGNvbW1lbnRzQ2FjaGUpIHtcbiAgaWYgKG9iaiAmJiB0eXBlb2Ygb2JqLnR5cGUgPT09IFwic3RyaW5nXCIpIHtcbiAgICByZXR1cm4gY2xvbmVOb2RlSW50ZXJuYWwob2JqLCBkZWVwLCB3aXRob3V0TG9jLCBjb21tZW50c0NhY2hlKTtcbiAgfVxuICByZXR1cm4gb2JqO1xufVxuZnVuY3Rpb24gY2xvbmVJZk5vZGVPckFycmF5KG9iaiwgZGVlcCwgd2l0aG91dExvYywgY29tbWVudHNDYWNoZSkge1xuICBpZiAoQXJyYXkuaXNBcnJheShvYmopKSB7XG4gICAgcmV0dXJuIG9iai5tYXAobm9kZSA9PiBjbG9uZUlmTm9kZShub2RlLCBkZWVwLCB3aXRob3V0TG9jLCBjb21tZW50c0NhY2hlKSk7XG4gIH1cbiAgcmV0dXJuIGNsb25lSWZOb2RlKG9iaiwgZGVlcCwgd2l0aG91dExvYywgY29tbWVudHNDYWNoZSk7XG59XG5mdW5jdGlvbiBjbG9uZU5vZGUobm9kZSwgZGVlcCA9IHRydWUsIHdpdGhvdXRMb2MgPSBmYWxzZSkge1xuICByZXR1cm4gY2xvbmVOb2RlSW50ZXJuYWwobm9kZSwgZGVlcCwgd2l0aG91dExvYywgbmV3IE1hcCgpKTtcbn1cbmZ1bmN0aW9uIGNsb25lTm9kZUludGVybmFsKG5vZGUsIGRlZXAgPSB0cnVlLCB3aXRob3V0TG9jID0gZmFsc2UsIGNvbW1lbnRzQ2FjaGUpIHtcbiAgaWYgKCFub2RlKSByZXR1cm4gbm9kZTtcbiAgY29uc3Qge1xuICAgIHR5cGVcbiAgfSA9IG5vZGU7XG4gIGNvbnN0IG5ld05vZGUgPSB7XG4gICAgdHlwZTogbm9kZS50eXBlXG4gIH07XG4gIGlmICgoMCwgX2luZGV4Mi5pc0lkZW50aWZpZXIpKG5vZGUpKSB7XG4gICAgbmV3Tm9kZS5uYW1lID0gbm9kZS5uYW1lO1xuICAgIGlmIChoYXNPd24obm9kZSwgXCJvcHRpb25hbFwiKSAmJiB0eXBlb2Ygbm9kZS5vcHRpb25hbCA9PT0gXCJib29sZWFuXCIpIHtcbiAgICAgIG5ld05vZGUub3B0aW9uYWwgPSBub2RlLm9wdGlvbmFsO1xuICAgIH1cbiAgICBpZiAoaGFzT3duKG5vZGUsIFwidHlwZUFubm90YXRpb25cIikpIHtcbiAgICAgIG5ld05vZGUudHlwZUFubm90YXRpb24gPSBkZWVwID8gY2xvbmVJZk5vZGVPckFycmF5KG5vZGUudHlwZUFubm90YXRpb24sIHRydWUsIHdpdGhvdXRMb2MsIGNvbW1lbnRzQ2FjaGUpIDogbm9kZS50eXBlQW5ub3RhdGlvbjtcbiAgICB9XG4gICAgaWYgKGhhc093bihub2RlLCBcImRlY29yYXRvcnNcIikpIHtcbiAgICAgIG5ld05vZGUuZGVjb3JhdG9ycyA9IGRlZXAgPyBjbG9uZUlmTm9kZU9yQXJyYXkobm9kZS5kZWNvcmF0b3JzLCB0cnVlLCB3aXRob3V0TG9jLCBjb21tZW50c0NhY2hlKSA6IG5vZGUuZGVjb3JhdG9ycztcbiAgICB9XG4gIH0gZWxzZSBpZiAoIWhhc093bihfaW5kZXguTk9ERV9GSUVMRFMsIHR5cGUpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBVbmtub3duIG5vZGUgdHlwZTogXCIke3R5cGV9XCJgKTtcbiAgfSBlbHNlIHtcbiAgICBmb3IgKGNvbnN0IGZpZWxkIG9mIE9iamVjdC5rZXlzKF9pbmRleC5OT0RFX0ZJRUxEU1t0eXBlXSkpIHtcbiAgICAgIGlmIChoYXNPd24obm9kZSwgZmllbGQpKSB7XG4gICAgICAgIGlmIChkZWVwKSB7XG4gICAgICAgICAgbmV3Tm9kZVtmaWVsZF0gPSAoMCwgX2luZGV4Mi5pc0ZpbGUpKG5vZGUpICYmIGZpZWxkID09PSBcImNvbW1lbnRzXCIgPyBtYXliZUNsb25lQ29tbWVudHMobm9kZS5jb21tZW50cywgZGVlcCwgd2l0aG91dExvYywgY29tbWVudHNDYWNoZSkgOiBjbG9uZUlmTm9kZU9yQXJyYXkobm9kZVtmaWVsZF0sIHRydWUsIHdpdGhvdXRMb2MsIGNvbW1lbnRzQ2FjaGUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG5ld05vZGVbZmllbGRdID0gbm9kZVtmaWVsZF07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgaWYgKGhhc093bihub2RlLCBcImxvY1wiKSkge1xuICAgIGlmICh3aXRob3V0TG9jKSB7XG4gICAgICBuZXdOb2RlLmxvYyA9IG51bGw7XG4gICAgfSBlbHNlIHtcbiAgICAgIG5ld05vZGUubG9jID0gbm9kZS5sb2M7XG4gICAgfVxuICB9XG4gIGlmIChoYXNPd24obm9kZSwgXCJsZWFkaW5nQ29tbWVudHNcIikpIHtcbiAgICBuZXdOb2RlLmxlYWRpbmdDb21tZW50cyA9IG1heWJlQ2xvbmVDb21tZW50cyhub2RlLmxlYWRpbmdDb21tZW50cywgZGVlcCwgd2l0aG91dExvYywgY29tbWVudHNDYWNoZSk7XG4gIH1cbiAgaWYgKGhhc093bihub2RlLCBcImlubmVyQ29tbWVudHNcIikpIHtcbiAgICBuZXdOb2RlLmlubmVyQ29tbWVudHMgPSBtYXliZUNsb25lQ29tbWVudHMobm9kZS5pbm5lckNvbW1lbnRzLCBkZWVwLCB3aXRob3V0TG9jLCBjb21tZW50c0NhY2hlKTtcbiAgfVxuICBpZiAoaGFzT3duKG5vZGUsIFwidHJhaWxpbmdDb21tZW50c1wiKSkge1xuICAgIG5ld05vZGUudHJhaWxpbmdDb21tZW50cyA9IG1heWJlQ2xvbmVDb21tZW50cyhub2RlLnRyYWlsaW5nQ29tbWVudHMsIGRlZXAsIHdpdGhvdXRMb2MsIGNvbW1lbnRzQ2FjaGUpO1xuICB9XG4gIGlmIChoYXNPd24obm9kZSwgXCJleHRyYVwiKSkge1xuICAgIG5ld05vZGUuZXh0cmEgPSBPYmplY3QuYXNzaWduKHt9LCBub2RlLmV4dHJhKTtcbiAgfVxuICByZXR1cm4gbmV3Tm9kZTtcbn1cbmZ1bmN0aW9uIG1heWJlQ2xvbmVDb21tZW50cyhjb21tZW50cywgZGVlcCwgd2l0aG91dExvYywgY29tbWVudHNDYWNoZSkge1xuICBpZiAoIWNvbW1lbnRzIHx8ICFkZWVwKSB7XG4gICAgcmV0dXJuIGNvbW1lbnRzO1xuICB9XG4gIHJldHVybiBjb21tZW50cy5tYXAoY29tbWVudCA9PiB7XG4gICAgY29uc3QgY2FjaGUgPSBjb21tZW50c0NhY2hlLmdldChjb21tZW50KTtcbiAgICBpZiAoY2FjaGUpIHJldHVybiBjYWNoZTtcbiAgICBjb25zdCB7XG4gICAgICB0eXBlLFxuICAgICAgdmFsdWUsXG4gICAgICBsb2NcbiAgICB9ID0gY29tbWVudDtcbiAgICBjb25zdCByZXQgPSB7XG4gICAgICB0eXBlLFxuICAgICAgdmFsdWUsXG4gICAgICBsb2NcbiAgICB9O1xuICAgIGlmICh3aXRob3V0TG9jKSB7XG4gICAgICByZXQubG9jID0gbnVsbDtcbiAgICB9XG4gICAgY29tbWVudHNDYWNoZS5zZXQoY29tbWVudCwgcmV0KTtcbiAgICByZXR1cm4gcmV0O1xuICB9KTtcbn1cblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y2xvbmVOb2RlLmpzLm1hcFxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@babel/types/lib/clone/cloneNode.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@babel/types/lib/clone/cloneWithoutLoc.js":
/*!****************************************************************!*\
  !*** ./node_modules/@babel/types/lib/clone/cloneWithoutLoc.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports[\"default\"] = cloneWithoutLoc;\nvar _cloneNode = __webpack_require__(/*! ./cloneNode.js */ \"(ssr)/./node_modules/@babel/types/lib/clone/cloneNode.js\");\nfunction cloneWithoutLoc(node) {\n  return (0, _cloneNode.default)(node, false, true);\n}\n\n//# sourceMappingURL=cloneWithoutLoc.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGJhYmVsL3R5cGVzL2xpYi9jbG9uZS9jbG9uZVdpdGhvdXRMb2MuanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWIsOENBQTZDO0FBQzdDO0FBQ0EsQ0FBQyxFQUFDO0FBQ0Ysa0JBQWU7QUFDZixpQkFBaUIsbUJBQU8sQ0FBQyxnRkFBZ0I7QUFDekM7QUFDQTtBQUNBOztBQUVBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcmVwby12aXN1YWxpemVyLy4vbm9kZV9tb2R1bGVzL0BiYWJlbC90eXBlcy9saWIvY2xvbmUvY2xvbmVXaXRob3V0TG9jLmpzPzZmMmUiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLmRlZmF1bHQgPSBjbG9uZVdpdGhvdXRMb2M7XG52YXIgX2Nsb25lTm9kZSA9IHJlcXVpcmUoXCIuL2Nsb25lTm9kZS5qc1wiKTtcbmZ1bmN0aW9uIGNsb25lV2l0aG91dExvYyhub2RlKSB7XG4gIHJldHVybiAoMCwgX2Nsb25lTm9kZS5kZWZhdWx0KShub2RlLCBmYWxzZSwgdHJ1ZSk7XG59XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNsb25lV2l0aG91dExvYy5qcy5tYXBcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@babel/types/lib/clone/cloneWithoutLoc.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@babel/types/lib/comments/addComment.js":
/*!**************************************************************!*\
  !*** ./node_modules/@babel/types/lib/comments/addComment.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports[\"default\"] = addComment;\nvar _addComments = __webpack_require__(/*! ./addComments.js */ \"(ssr)/./node_modules/@babel/types/lib/comments/addComments.js\");\nfunction addComment(node, type, content, line) {\n  return (0, _addComments.default)(node, type, [{\n    type: line ? \"CommentLine\" : \"CommentBlock\",\n    value: content\n  }]);\n}\n\n//# sourceMappingURL=addComment.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGJhYmVsL3R5cGVzL2xpYi9jb21tZW50cy9hZGRDb21tZW50LmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViLDhDQUE2QztBQUM3QztBQUNBLENBQUMsRUFBQztBQUNGLGtCQUFlO0FBQ2YsbUJBQW1CLG1CQUFPLENBQUMsdUZBQWtCO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcmVwby12aXN1YWxpemVyLy4vbm9kZV9tb2R1bGVzL0BiYWJlbC90eXBlcy9saWIvY29tbWVudHMvYWRkQ29tbWVudC5qcz8zMjcyIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5kZWZhdWx0ID0gYWRkQ29tbWVudDtcbnZhciBfYWRkQ29tbWVudHMgPSByZXF1aXJlKFwiLi9hZGRDb21tZW50cy5qc1wiKTtcbmZ1bmN0aW9uIGFkZENvbW1lbnQobm9kZSwgdHlwZSwgY29udGVudCwgbGluZSkge1xuICByZXR1cm4gKDAsIF9hZGRDb21tZW50cy5kZWZhdWx0KShub2RlLCB0eXBlLCBbe1xuICAgIHR5cGU6IGxpbmUgPyBcIkNvbW1lbnRMaW5lXCIgOiBcIkNvbW1lbnRCbG9ja1wiLFxuICAgIHZhbHVlOiBjb250ZW50XG4gIH1dKTtcbn1cblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YWRkQ29tbWVudC5qcy5tYXBcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@babel/types/lib/comments/addComment.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@babel/types/lib/comments/addComments.js":
/*!***************************************************************!*\
  !*** ./node_modules/@babel/types/lib/comments/addComments.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports[\"default\"] = addComments;\nfunction addComments(node, type, comments) {\n  if (!comments || !node) return node;\n  const key = `${type}Comments`;\n  if (node[key]) {\n    if (type === \"leading\") {\n      node[key] = comments.concat(node[key]);\n    } else {\n      node[key].push(...comments);\n    }\n  } else {\n    node[key] = comments;\n  }\n  return node;\n}\n\n//# sourceMappingURL=addComments.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGJhYmVsL3R5cGVzL2xpYi9jb21tZW50cy9hZGRDb21tZW50cy5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYiw4Q0FBNkM7QUFDN0M7QUFDQSxDQUFDLEVBQUM7QUFDRixrQkFBZTtBQUNmO0FBQ0E7QUFDQSxpQkFBaUIsS0FBSztBQUN0QjtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTs7QUFFQSIsInNvdXJjZXMiOlsid2VicGFjazovL3JlcG8tdmlzdWFsaXplci8uL25vZGVfbW9kdWxlcy9AYmFiZWwvdHlwZXMvbGliL2NvbW1lbnRzL2FkZENvbW1lbnRzLmpzPzMxMmEiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLmRlZmF1bHQgPSBhZGRDb21tZW50cztcbmZ1bmN0aW9uIGFkZENvbW1lbnRzKG5vZGUsIHR5cGUsIGNvbW1lbnRzKSB7XG4gIGlmICghY29tbWVudHMgfHwgIW5vZGUpIHJldHVybiBub2RlO1xuICBjb25zdCBrZXkgPSBgJHt0eXBlfUNvbW1lbnRzYDtcbiAgaWYgKG5vZGVba2V5XSkge1xuICAgIGlmICh0eXBlID09PSBcImxlYWRpbmdcIikge1xuICAgICAgbm9kZVtrZXldID0gY29tbWVudHMuY29uY2F0KG5vZGVba2V5XSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIG5vZGVba2V5XS5wdXNoKC4uLmNvbW1lbnRzKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgbm9kZVtrZXldID0gY29tbWVudHM7XG4gIH1cbiAgcmV0dXJuIG5vZGU7XG59XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWFkZENvbW1lbnRzLmpzLm1hcFxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@babel/types/lib/comments/addComments.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@babel/types/lib/comments/inheritInnerComments.js":
/*!************************************************************************!*\
  !*** ./node_modules/@babel/types/lib/comments/inheritInnerComments.js ***!
  \************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports[\"default\"] = inheritInnerComments;\nvar _inherit = __webpack_require__(/*! ../utils/inherit.js */ \"(ssr)/./node_modules/@babel/types/lib/utils/inherit.js\");\nfunction inheritInnerComments(child, parent) {\n  (0, _inherit.default)(\"innerComments\", child, parent);\n}\n\n//# sourceMappingURL=inheritInnerComments.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGJhYmVsL3R5cGVzL2xpYi9jb21tZW50cy9pbmhlcml0SW5uZXJDb21tZW50cy5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYiw4Q0FBNkM7QUFDN0M7QUFDQSxDQUFDLEVBQUM7QUFDRixrQkFBZTtBQUNmLGVBQWUsbUJBQU8sQ0FBQyxtRkFBcUI7QUFDNUM7QUFDQTtBQUNBOztBQUVBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcmVwby12aXN1YWxpemVyLy4vbm9kZV9tb2R1bGVzL0BiYWJlbC90eXBlcy9saWIvY29tbWVudHMvaW5oZXJpdElubmVyQ29tbWVudHMuanM/NzRkMCJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuZGVmYXVsdCA9IGluaGVyaXRJbm5lckNvbW1lbnRzO1xudmFyIF9pbmhlcml0ID0gcmVxdWlyZShcIi4uL3V0aWxzL2luaGVyaXQuanNcIik7XG5mdW5jdGlvbiBpbmhlcml0SW5uZXJDb21tZW50cyhjaGlsZCwgcGFyZW50KSB7XG4gICgwLCBfaW5oZXJpdC5kZWZhdWx0KShcImlubmVyQ29tbWVudHNcIiwgY2hpbGQsIHBhcmVudCk7XG59XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluaGVyaXRJbm5lckNvbW1lbnRzLmpzLm1hcFxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@babel/types/lib/comments/inheritInnerComments.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@babel/types/lib/comments/inheritLeadingComments.js":
/*!**************************************************************************!*\
  !*** ./node_modules/@babel/types/lib/comments/inheritLeadingComments.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports[\"default\"] = inheritLeadingComments;\nvar _inherit = __webpack_require__(/*! ../utils/inherit.js */ \"(ssr)/./node_modules/@babel/types/lib/utils/inherit.js\");\nfunction inheritLeadingComments(child, parent) {\n  (0, _inherit.default)(\"leadingComments\", child, parent);\n}\n\n//# sourceMappingURL=inheritLeadingComments.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGJhYmVsL3R5cGVzL2xpYi9jb21tZW50cy9pbmhlcml0TGVhZGluZ0NvbW1lbnRzLmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViLDhDQUE2QztBQUM3QztBQUNBLENBQUMsRUFBQztBQUNGLGtCQUFlO0FBQ2YsZUFBZSxtQkFBTyxDQUFDLG1GQUFxQjtBQUM1QztBQUNBO0FBQ0E7O0FBRUEiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9yZXBvLXZpc3VhbGl6ZXIvLi9ub2RlX21vZHVsZXMvQGJhYmVsL3R5cGVzL2xpYi9jb21tZW50cy9pbmhlcml0TGVhZGluZ0NvbW1lbnRzLmpzP2VlMDIiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLmRlZmF1bHQgPSBpbmhlcml0TGVhZGluZ0NvbW1lbnRzO1xudmFyIF9pbmhlcml0ID0gcmVxdWlyZShcIi4uL3V0aWxzL2luaGVyaXQuanNcIik7XG5mdW5jdGlvbiBpbmhlcml0TGVhZGluZ0NvbW1lbnRzKGNoaWxkLCBwYXJlbnQpIHtcbiAgKDAsIF9pbmhlcml0LmRlZmF1bHQpKFwibGVhZGluZ0NvbW1lbnRzXCIsIGNoaWxkLCBwYXJlbnQpO1xufVxuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmhlcml0TGVhZGluZ0NvbW1lbnRzLmpzLm1hcFxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@babel/types/lib/comments/inheritLeadingComments.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@babel/types/lib/comments/inheritTrailingComments.js":
/*!***************************************************************************!*\
  !*** ./node_modules/@babel/types/lib/comments/inheritTrailingComments.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports[\"default\"] = inheritTrailingComments;\nvar _inherit = __webpack_require__(/*! ../utils/inherit.js */ \"(ssr)/./node_modules/@babel/types/lib/utils/inherit.js\");\nfunction inheritTrailingComments(child, parent) {\n  (0, _inherit.default)(\"trailingComments\", child, parent);\n}\n\n//# sourceMappingURL=inheritTrailingComments.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGJhYmVsL3R5cGVzL2xpYi9jb21tZW50cy9pbmhlcml0VHJhaWxpbmdDb21tZW50cy5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYiw4Q0FBNkM7QUFDN0M7QUFDQSxDQUFDLEVBQUM7QUFDRixrQkFBZTtBQUNmLGVBQWUsbUJBQU8sQ0FBQyxtRkFBcUI7QUFDNUM7QUFDQTtBQUNBOztBQUVBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcmVwby12aXN1YWxpemVyLy4vbm9kZV9tb2R1bGVzL0BiYWJlbC90eXBlcy9saWIvY29tbWVudHMvaW5oZXJpdFRyYWlsaW5nQ29tbWVudHMuanM/YzI5MyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuZGVmYXVsdCA9IGluaGVyaXRUcmFpbGluZ0NvbW1lbnRzO1xudmFyIF9pbmhlcml0ID0gcmVxdWlyZShcIi4uL3V0aWxzL2luaGVyaXQuanNcIik7XG5mdW5jdGlvbiBpbmhlcml0VHJhaWxpbmdDb21tZW50cyhjaGlsZCwgcGFyZW50KSB7XG4gICgwLCBfaW5oZXJpdC5kZWZhdWx0KShcInRyYWlsaW5nQ29tbWVudHNcIiwgY2hpbGQsIHBhcmVudCk7XG59XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluaGVyaXRUcmFpbGluZ0NvbW1lbnRzLmpzLm1hcFxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@babel/types/lib/comments/inheritTrailingComments.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@babel/types/lib/comments/inheritsComments.js":
/*!********************************************************************!*\
  !*** ./node_modules/@babel/types/lib/comments/inheritsComments.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports[\"default\"] = inheritsComments;\nvar _inheritTrailingComments = __webpack_require__(/*! ./inheritTrailingComments.js */ \"(ssr)/./node_modules/@babel/types/lib/comments/inheritTrailingComments.js\");\nvar _inheritLeadingComments = __webpack_require__(/*! ./inheritLeadingComments.js */ \"(ssr)/./node_modules/@babel/types/lib/comments/inheritLeadingComments.js\");\nvar _inheritInnerComments = __webpack_require__(/*! ./inheritInnerComments.js */ \"(ssr)/./node_modules/@babel/types/lib/comments/inheritInnerComments.js\");\nfunction inheritsComments(child, parent) {\n  (0, _inheritTrailingComments.default)(child, parent);\n  (0, _inheritLeadingComments.default)(child, parent);\n  (0, _inheritInnerComments.default)(child, parent);\n  return child;\n}\n\n//# sourceMappingURL=inheritsComments.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGJhYmVsL3R5cGVzL2xpYi9jb21tZW50cy9pbmhlcml0c0NvbW1lbnRzLmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViLDhDQUE2QztBQUM3QztBQUNBLENBQUMsRUFBQztBQUNGLGtCQUFlO0FBQ2YsK0JBQStCLG1CQUFPLENBQUMsK0dBQThCO0FBQ3JFLDhCQUE4QixtQkFBTyxDQUFDLDZHQUE2QjtBQUNuRSw0QkFBNEIsbUJBQU8sQ0FBQyx5R0FBMkI7QUFDL0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcmVwby12aXN1YWxpemVyLy4vbm9kZV9tb2R1bGVzL0BiYWJlbC90eXBlcy9saWIvY29tbWVudHMvaW5oZXJpdHNDb21tZW50cy5qcz8xMGY4Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5kZWZhdWx0ID0gaW5oZXJpdHNDb21tZW50cztcbnZhciBfaW5oZXJpdFRyYWlsaW5nQ29tbWVudHMgPSByZXF1aXJlKFwiLi9pbmhlcml0VHJhaWxpbmdDb21tZW50cy5qc1wiKTtcbnZhciBfaW5oZXJpdExlYWRpbmdDb21tZW50cyA9IHJlcXVpcmUoXCIuL2luaGVyaXRMZWFkaW5nQ29tbWVudHMuanNcIik7XG52YXIgX2luaGVyaXRJbm5lckNvbW1lbnRzID0gcmVxdWlyZShcIi4vaW5oZXJpdElubmVyQ29tbWVudHMuanNcIik7XG5mdW5jdGlvbiBpbmhlcml0c0NvbW1lbnRzKGNoaWxkLCBwYXJlbnQpIHtcbiAgKDAsIF9pbmhlcml0VHJhaWxpbmdDb21tZW50cy5kZWZhdWx0KShjaGlsZCwgcGFyZW50KTtcbiAgKDAsIF9pbmhlcml0TGVhZGluZ0NvbW1lbnRzLmRlZmF1bHQpKGNoaWxkLCBwYXJlbnQpO1xuICAoMCwgX2luaGVyaXRJbm5lckNvbW1lbnRzLmRlZmF1bHQpKGNoaWxkLCBwYXJlbnQpO1xuICByZXR1cm4gY2hpbGQ7XG59XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluaGVyaXRzQ29tbWVudHMuanMubWFwXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@babel/types/lib/comments/inheritsComments.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@babel/types/lib/comments/removeComments.js":
/*!******************************************************************!*\
  !*** ./node_modules/@babel/types/lib/comments/removeComments.js ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports[\"default\"] = removeComments;\nvar _index = __webpack_require__(/*! ../constants/index.js */ \"(ssr)/./node_modules/@babel/types/lib/constants/index.js\");\nfunction removeComments(node) {\n  _index.COMMENT_KEYS.forEach(key => {\n    node[key] = null;\n  });\n  return node;\n}\n\n//# sourceMappingURL=removeComments.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGJhYmVsL3R5cGVzL2xpYi9jb21tZW50cy9yZW1vdmVDb21tZW50cy5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYiw4Q0FBNkM7QUFDN0M7QUFDQSxDQUFDLEVBQUM7QUFDRixrQkFBZTtBQUNmLGFBQWEsbUJBQU8sQ0FBQyx1RkFBdUI7QUFDNUM7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUEiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9yZXBvLXZpc3VhbGl6ZXIvLi9ub2RlX21vZHVsZXMvQGJhYmVsL3R5cGVzL2xpYi9jb21tZW50cy9yZW1vdmVDb21tZW50cy5qcz80ZWUzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5kZWZhdWx0ID0gcmVtb3ZlQ29tbWVudHM7XG52YXIgX2luZGV4ID0gcmVxdWlyZShcIi4uL2NvbnN0YW50cy9pbmRleC5qc1wiKTtcbmZ1bmN0aW9uIHJlbW92ZUNvbW1lbnRzKG5vZGUpIHtcbiAgX2luZGV4LkNPTU1FTlRfS0VZUy5mb3JFYWNoKGtleSA9PiB7XG4gICAgbm9kZVtrZXldID0gbnVsbDtcbiAgfSk7XG4gIHJldHVybiBub2RlO1xufVxuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1yZW1vdmVDb21tZW50cy5qcy5tYXBcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@babel/types/lib/comments/removeComments.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@babel/types/lib/constants/generated/index.js":
/*!********************************************************************!*\
  !*** ./node_modules/@babel/types/lib/constants/generated/index.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports.WHILE_TYPES = exports.USERWHITESPACABLE_TYPES = exports.UNARYLIKE_TYPES = exports.TYPESCRIPT_TYPES = exports.TSTYPE_TYPES = exports.TSTYPEELEMENT_TYPES = exports.TSENTITYNAME_TYPES = exports.TSBASETYPE_TYPES = exports.TERMINATORLESS_TYPES = exports.STATEMENT_TYPES = exports.STANDARDIZED_TYPES = exports.SCOPABLE_TYPES = exports.PUREISH_TYPES = exports.PROPERTY_TYPES = exports.PRIVATE_TYPES = exports.PATTERN_TYPES = exports.PATTERNLIKE_TYPES = exports.OBJECTMEMBER_TYPES = exports.MODULESPECIFIER_TYPES = exports.MODULEDECLARATION_TYPES = exports.MISCELLANEOUS_TYPES = exports.METHOD_TYPES = exports.LVAL_TYPES = exports.LOOP_TYPES = exports.LITERAL_TYPES = exports.JSX_TYPES = exports.IMPORTOREXPORTDECLARATION_TYPES = exports.IMMUTABLE_TYPES = exports.FUNCTION_TYPES = exports.FUNCTIONPARENT_TYPES = exports.FUNCTIONPARAMETER_TYPES = exports.FOR_TYPES = exports.FORXSTATEMENT_TYPES = exports.FLOW_TYPES = exports.FLOWTYPE_TYPES = exports.FLOWPREDICATE_TYPES = exports.FLOWDECLARATION_TYPES = exports.FLOWBASEANNOTATION_TYPES = exports.EXPRESSION_TYPES = exports.EXPRESSIONWRAPPER_TYPES = exports.EXPORTDECLARATION_TYPES = exports.ENUMMEMBER_TYPES = exports.ENUMBODY_TYPES = exports.DECLARATION_TYPES = exports.CONDITIONAL_TYPES = exports.COMPLETIONSTATEMENT_TYPES = exports.CLASS_TYPES = exports.BLOCK_TYPES = exports.BLOCKPARENT_TYPES = exports.BINARY_TYPES = exports.ACCESSOR_TYPES = void 0;\nvar _index = __webpack_require__(/*! ../../definitions/index.js */ \"(ssr)/./node_modules/@babel/types/lib/definitions/index.js\");\nconst STANDARDIZED_TYPES = exports.STANDARDIZED_TYPES = _index.FLIPPED_ALIAS_KEYS[\"Standardized\"];\nconst EXPRESSION_TYPES = exports.EXPRESSION_TYPES = _index.FLIPPED_ALIAS_KEYS[\"Expression\"];\nconst BINARY_TYPES = exports.BINARY_TYPES = _index.FLIPPED_ALIAS_KEYS[\"Binary\"];\nconst SCOPABLE_TYPES = exports.SCOPABLE_TYPES = _index.FLIPPED_ALIAS_KEYS[\"Scopable\"];\nconst BLOCKPARENT_TYPES = exports.BLOCKPARENT_TYPES = _index.FLIPPED_ALIAS_KEYS[\"BlockParent\"];\nconst BLOCK_TYPES = exports.BLOCK_TYPES = _index.FLIPPED_ALIAS_KEYS[\"Block\"];\nconst STATEMENT_TYPES = exports.STATEMENT_TYPES = _index.FLIPPED_ALIAS_KEYS[\"Statement\"];\nconst TERMINATORLESS_TYPES = exports.TERMINATORLESS_TYPES = _index.FLIPPED_ALIAS_KEYS[\"Terminatorless\"];\nconst COMPLETIONSTATEMENT_TYPES = exports.COMPLETIONSTATEMENT_TYPES = _index.FLIPPED_ALIAS_KEYS[\"CompletionStatement\"];\nconst CONDITIONAL_TYPES = exports.CONDITIONAL_TYPES = _index.FLIPPED_ALIAS_KEYS[\"Conditional\"];\nconst LOOP_TYPES = exports.LOOP_TYPES = _index.FLIPPED_ALIAS_KEYS[\"Loop\"];\nconst WHILE_TYPES = exports.WHILE_TYPES = _index.FLIPPED_ALIAS_KEYS[\"While\"];\nconst EXPRESSIONWRAPPER_TYPES = exports.EXPRESSIONWRAPPER_TYPES = _index.FLIPPED_ALIAS_KEYS[\"ExpressionWrapper\"];\nconst FOR_TYPES = exports.FOR_TYPES = _index.FLIPPED_ALIAS_KEYS[\"For\"];\nconst FORXSTATEMENT_TYPES = exports.FORXSTATEMENT_TYPES = _index.FLIPPED_ALIAS_KEYS[\"ForXStatement\"];\nconst FUNCTION_TYPES = exports.FUNCTION_TYPES = _index.FLIPPED_ALIAS_KEYS[\"Function\"];\nconst FUNCTIONPARENT_TYPES = exports.FUNCTIONPARENT_TYPES = _index.FLIPPED_ALIAS_KEYS[\"FunctionParent\"];\nconst PUREISH_TYPES = exports.PUREISH_TYPES = _index.FLIPPED_ALIAS_KEYS[\"Pureish\"];\nconst DECLARATION_TYPES = exports.DECLARATION_TYPES = _index.FLIPPED_ALIAS_KEYS[\"Declaration\"];\nconst FUNCTIONPARAMETER_TYPES = exports.FUNCTIONPARAMETER_TYPES = _index.FLIPPED_ALIAS_KEYS[\"FunctionParameter\"];\nconst PATTERNLIKE_TYPES = exports.PATTERNLIKE_TYPES = _index.FLIPPED_ALIAS_KEYS[\"PatternLike\"];\nconst LVAL_TYPES = exports.LVAL_TYPES = _index.FLIPPED_ALIAS_KEYS[\"LVal\"];\nconst TSENTITYNAME_TYPES = exports.TSENTITYNAME_TYPES = _index.FLIPPED_ALIAS_KEYS[\"TSEntityName\"];\nconst LITERAL_TYPES = exports.LITERAL_TYPES = _index.FLIPPED_ALIAS_KEYS[\"Literal\"];\nconst IMMUTABLE_TYPES = exports.IMMUTABLE_TYPES = _index.FLIPPED_ALIAS_KEYS[\"Immutable\"];\nconst USERWHITESPACABLE_TYPES = exports.USERWHITESPACABLE_TYPES = _index.FLIPPED_ALIAS_KEYS[\"UserWhitespacable\"];\nconst METHOD_TYPES = exports.METHOD_TYPES = _index.FLIPPED_ALIAS_KEYS[\"Method\"];\nconst OBJECTMEMBER_TYPES = exports.OBJECTMEMBER_TYPES = _index.FLIPPED_ALIAS_KEYS[\"ObjectMember\"];\nconst PROPERTY_TYPES = exports.PROPERTY_TYPES = _index.FLIPPED_ALIAS_KEYS[\"Property\"];\nconst UNARYLIKE_TYPES = exports.UNARYLIKE_TYPES = _index.FLIPPED_ALIAS_KEYS[\"UnaryLike\"];\nconst PATTERN_TYPES = exports.PATTERN_TYPES = _index.FLIPPED_ALIAS_KEYS[\"Pattern\"];\nconst CLASS_TYPES = exports.CLASS_TYPES = _index.FLIPPED_ALIAS_KEYS[\"Class\"];\nconst IMPORTOREXPORTDECLARATION_TYPES = exports.IMPORTOREXPORTDECLARATION_TYPES = _index.FLIPPED_ALIAS_KEYS[\"ImportOrExportDeclaration\"];\nconst EXPORTDECLARATION_TYPES = exports.EXPORTDECLARATION_TYPES = _index.FLIPPED_ALIAS_KEYS[\"ExportDeclaration\"];\nconst MODULESPECIFIER_TYPES = exports.MODULESPECIFIER_TYPES = _index.FLIPPED_ALIAS_KEYS[\"ModuleSpecifier\"];\nconst ACCESSOR_TYPES = exports.ACCESSOR_TYPES = _index.FLIPPED_ALIAS_KEYS[\"Accessor\"];\nconst PRIVATE_TYPES = exports.PRIVATE_TYPES = _index.FLIPPED_ALIAS_KEYS[\"Private\"];\nconst FLOW_TYPES = exports.FLOW_TYPES = _index.FLIPPED_ALIAS_KEYS[\"Flow\"];\nconst FLOWTYPE_TYPES = exports.FLOWTYPE_TYPES = _index.FLIPPED_ALIAS_KEYS[\"FlowType\"];\nconst FLOWBASEANNOTATION_TYPES = exports.FLOWBASEANNOTATION_TYPES = _index.FLIPPED_ALIAS_KEYS[\"FlowBaseAnnotation\"];\nconst FLOWDECLARATION_TYPES = exports.FLOWDECLARATION_TYPES = _index.FLIPPED_ALIAS_KEYS[\"FlowDeclaration\"];\nconst FLOWPREDICATE_TYPES = exports.FLOWPREDICATE_TYPES = _index.FLIPPED_ALIAS_KEYS[\"FlowPredicate\"];\nconst ENUMBODY_TYPES = exports.ENUMBODY_TYPES = _index.FLIPPED_ALIAS_KEYS[\"EnumBody\"];\nconst ENUMMEMBER_TYPES = exports.ENUMMEMBER_TYPES = _index.FLIPPED_ALIAS_KEYS[\"EnumMember\"];\nconst JSX_TYPES = exports.JSX_TYPES = _index.FLIPPED_ALIAS_KEYS[\"JSX\"];\nconst MISCELLANEOUS_TYPES = exports.MISCELLANEOUS_TYPES = _index.FLIPPED_ALIAS_KEYS[\"Miscellaneous\"];\nconst TYPESCRIPT_TYPES = exports.TYPESCRIPT_TYPES = _index.FLIPPED_ALIAS_KEYS[\"TypeScript\"];\nconst TSTYPEELEMENT_TYPES = exports.TSTYPEELEMENT_TYPES = _index.FLIPPED_ALIAS_KEYS[\"TSTypeElement\"];\nconst TSTYPE_TYPES = exports.TSTYPE_TYPES = _index.FLIPPED_ALIAS_KEYS[\"TSType\"];\nconst TSBASETYPE_TYPES = exports.TSBASETYPE_TYPES = _index.FLIPPED_ALIAS_KEYS[\"TSBaseType\"];\nconst MODULEDECLARATION_TYPES = exports.MODULEDECLARATION_TYPES = IMPORTOREXPORTDECLARATION_TYPES;\n\n//# sourceMappingURL=index.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGJhYmVsL3R5cGVzL2xpYi9jb25zdGFudHMvZ2VuZXJhdGVkL2luZGV4LmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViLDhDQUE2QztBQUM3QztBQUNBLENBQUMsRUFBQztBQUNGLG1CQUFtQixHQUFHLCtCQUErQixHQUFHLHVCQUF1QixHQUFHLHdCQUF3QixHQUFHLG9CQUFvQixHQUFHLDJCQUEyQixHQUFHLDBCQUEwQixHQUFHLHdCQUF3QixHQUFHLDRCQUE0QixHQUFHLHVCQUF1QixHQUFHLDBCQUEwQixHQUFHLHNCQUFzQixHQUFHLHFCQUFxQixHQUFHLHNCQUFzQixHQUFHLHFCQUFxQixHQUFHLHFCQUFxQixHQUFHLHlCQUF5QixHQUFHLDBCQUEwQixHQUFHLDZCQUE2QixHQUFHLCtCQUErQixHQUFHLDJCQUEyQixHQUFHLG9CQUFvQixHQUFHLGtCQUFrQixHQUFHLGtCQUFrQixHQUFHLHFCQUFxQixHQUFHLGlCQUFpQixHQUFHLHVDQUF1QyxHQUFHLHVCQUF1QixHQUFHLHNCQUFzQixHQUFHLDRCQUE0QixHQUFHLCtCQUErQixHQUFHLGlCQUFpQixHQUFHLDJCQUEyQixHQUFHLGtCQUFrQixHQUFHLHNCQUFzQixHQUFHLDJCQUEyQixHQUFHLDZCQUE2QixHQUFHLGdDQUFnQyxHQUFHLHdCQUF3QixHQUFHLCtCQUErQixHQUFHLCtCQUErQixHQUFHLHdCQUF3QixHQUFHLHNCQUFzQixHQUFHLHlCQUF5QixHQUFHLHlCQUF5QixHQUFHLGlDQUFpQyxHQUFHLG1CQUFtQixHQUFHLG1CQUFtQixHQUFHLHlCQUF5QixHQUFHLG9CQUFvQixHQUFHLHNCQUFzQjtBQUNuM0MsYUFBYSxtQkFBTyxDQUFDLDhGQUE0QjtBQUNqRCwyQkFBMkIsMEJBQTBCO0FBQ3JELHlCQUF5Qix3QkFBd0I7QUFDakQscUJBQXFCLG9CQUFvQjtBQUN6Qyx1QkFBdUIsc0JBQXNCO0FBQzdDLDBCQUEwQix5QkFBeUI7QUFDbkQsb0JBQW9CLG1CQUFtQjtBQUN2Qyx3QkFBd0IsdUJBQXVCO0FBQy9DLDZCQUE2Qiw0QkFBNEI7QUFDekQsa0NBQWtDLGlDQUFpQztBQUNuRSwwQkFBMEIseUJBQXlCO0FBQ25ELG1CQUFtQixrQkFBa0I7QUFDckMsb0JBQW9CLG1CQUFtQjtBQUN2QyxnQ0FBZ0MsK0JBQStCO0FBQy9ELGtCQUFrQixpQkFBaUI7QUFDbkMsNEJBQTRCLDJCQUEyQjtBQUN2RCx1QkFBdUIsc0JBQXNCO0FBQzdDLDZCQUE2Qiw0QkFBNEI7QUFDekQsc0JBQXNCLHFCQUFxQjtBQUMzQywwQkFBMEIseUJBQXlCO0FBQ25ELGdDQUFnQywrQkFBK0I7QUFDL0QsMEJBQTBCLHlCQUF5QjtBQUNuRCxtQkFBbUIsa0JBQWtCO0FBQ3JDLDJCQUEyQiwwQkFBMEI7QUFDckQsc0JBQXNCLHFCQUFxQjtBQUMzQyx3QkFBd0IsdUJBQXVCO0FBQy9DLGdDQUFnQywrQkFBK0I7QUFDL0QscUJBQXFCLG9CQUFvQjtBQUN6QywyQkFBMkIsMEJBQTBCO0FBQ3JELHVCQUF1QixzQkFBc0I7QUFDN0Msd0JBQXdCLHVCQUF1QjtBQUMvQyxzQkFBc0IscUJBQXFCO0FBQzNDLG9CQUFvQixtQkFBbUI7QUFDdkMsd0NBQXdDLHVDQUF1QztBQUMvRSxnQ0FBZ0MsK0JBQStCO0FBQy9ELDhCQUE4Qiw2QkFBNkI7QUFDM0QsdUJBQXVCLHNCQUFzQjtBQUM3QyxzQkFBc0IscUJBQXFCO0FBQzNDLG1CQUFtQixrQkFBa0I7QUFDckMsdUJBQXVCLHNCQUFzQjtBQUM3QyxpQ0FBaUMsZ0NBQWdDO0FBQ2pFLDhCQUE4Qiw2QkFBNkI7QUFDM0QsNEJBQTRCLDJCQUEyQjtBQUN2RCx1QkFBdUIsc0JBQXNCO0FBQzdDLHlCQUF5Qix3QkFBd0I7QUFDakQsa0JBQWtCLGlCQUFpQjtBQUNuQyw0QkFBNEIsMkJBQTJCO0FBQ3ZELHlCQUF5Qix3QkFBd0I7QUFDakQsNEJBQTRCLDJCQUEyQjtBQUN2RCxxQkFBcUIsb0JBQW9CO0FBQ3pDLHlCQUF5Qix3QkFBd0I7QUFDakQsZ0NBQWdDLCtCQUErQjs7QUFFL0QiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9yZXBvLXZpc3VhbGl6ZXIvLi9ub2RlX21vZHVsZXMvQGJhYmVsL3R5cGVzL2xpYi9jb25zdGFudHMvZ2VuZXJhdGVkL2luZGV4LmpzP2ZhMjIiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLldISUxFX1RZUEVTID0gZXhwb3J0cy5VU0VSV0hJVEVTUEFDQUJMRV9UWVBFUyA9IGV4cG9ydHMuVU5BUllMSUtFX1RZUEVTID0gZXhwb3J0cy5UWVBFU0NSSVBUX1RZUEVTID0gZXhwb3J0cy5UU1RZUEVfVFlQRVMgPSBleHBvcnRzLlRTVFlQRUVMRU1FTlRfVFlQRVMgPSBleHBvcnRzLlRTRU5USVRZTkFNRV9UWVBFUyA9IGV4cG9ydHMuVFNCQVNFVFlQRV9UWVBFUyA9IGV4cG9ydHMuVEVSTUlOQVRPUkxFU1NfVFlQRVMgPSBleHBvcnRzLlNUQVRFTUVOVF9UWVBFUyA9IGV4cG9ydHMuU1RBTkRBUkRJWkVEX1RZUEVTID0gZXhwb3J0cy5TQ09QQUJMRV9UWVBFUyA9IGV4cG9ydHMuUFVSRUlTSF9UWVBFUyA9IGV4cG9ydHMuUFJPUEVSVFlfVFlQRVMgPSBleHBvcnRzLlBSSVZBVEVfVFlQRVMgPSBleHBvcnRzLlBBVFRFUk5fVFlQRVMgPSBleHBvcnRzLlBBVFRFUk5MSUtFX1RZUEVTID0gZXhwb3J0cy5PQkpFQ1RNRU1CRVJfVFlQRVMgPSBleHBvcnRzLk1PRFVMRVNQRUNJRklFUl9UWVBFUyA9IGV4cG9ydHMuTU9EVUxFREVDTEFSQVRJT05fVFlQRVMgPSBleHBvcnRzLk1JU0NFTExBTkVPVVNfVFlQRVMgPSBleHBvcnRzLk1FVEhPRF9UWVBFUyA9IGV4cG9ydHMuTFZBTF9UWVBFUyA9IGV4cG9ydHMuTE9PUF9UWVBFUyA9IGV4cG9ydHMuTElURVJBTF9UWVBFUyA9IGV4cG9ydHMuSlNYX1RZUEVTID0gZXhwb3J0cy5JTVBPUlRPUkVYUE9SVERFQ0xBUkFUSU9OX1RZUEVTID0gZXhwb3J0cy5JTU1VVEFCTEVfVFlQRVMgPSBleHBvcnRzLkZVTkNUSU9OX1RZUEVTID0gZXhwb3J0cy5GVU5DVElPTlBBUkVOVF9UWVBFUyA9IGV4cG9ydHMuRlVOQ1RJT05QQVJBTUVURVJfVFlQRVMgPSBleHBvcnRzLkZPUl9UWVBFUyA9IGV4cG9ydHMuRk9SWFNUQVRFTUVOVF9UWVBFUyA9IGV4cG9ydHMuRkxPV19UWVBFUyA9IGV4cG9ydHMuRkxPV1RZUEVfVFlQRVMgPSBleHBvcnRzLkZMT1dQUkVESUNBVEVfVFlQRVMgPSBleHBvcnRzLkZMT1dERUNMQVJBVElPTl9UWVBFUyA9IGV4cG9ydHMuRkxPV0JBU0VBTk5PVEFUSU9OX1RZUEVTID0gZXhwb3J0cy5FWFBSRVNTSU9OX1RZUEVTID0gZXhwb3J0cy5FWFBSRVNTSU9OV1JBUFBFUl9UWVBFUyA9IGV4cG9ydHMuRVhQT1JUREVDTEFSQVRJT05fVFlQRVMgPSBleHBvcnRzLkVOVU1NRU1CRVJfVFlQRVMgPSBleHBvcnRzLkVOVU1CT0RZX1RZUEVTID0gZXhwb3J0cy5ERUNMQVJBVElPTl9UWVBFUyA9IGV4cG9ydHMuQ09ORElUSU9OQUxfVFlQRVMgPSBleHBvcnRzLkNPTVBMRVRJT05TVEFURU1FTlRfVFlQRVMgPSBleHBvcnRzLkNMQVNTX1RZUEVTID0gZXhwb3J0cy5CTE9DS19UWVBFUyA9IGV4cG9ydHMuQkxPQ0tQQVJFTlRfVFlQRVMgPSBleHBvcnRzLkJJTkFSWV9UWVBFUyA9IGV4cG9ydHMuQUNDRVNTT1JfVFlQRVMgPSB2b2lkIDA7XG52YXIgX2luZGV4ID0gcmVxdWlyZShcIi4uLy4uL2RlZmluaXRpb25zL2luZGV4LmpzXCIpO1xuY29uc3QgU1RBTkRBUkRJWkVEX1RZUEVTID0gZXhwb3J0cy5TVEFOREFSRElaRURfVFlQRVMgPSBfaW5kZXguRkxJUFBFRF9BTElBU19LRVlTW1wiU3RhbmRhcmRpemVkXCJdO1xuY29uc3QgRVhQUkVTU0lPTl9UWVBFUyA9IGV4cG9ydHMuRVhQUkVTU0lPTl9UWVBFUyA9IF9pbmRleC5GTElQUEVEX0FMSUFTX0tFWVNbXCJFeHByZXNzaW9uXCJdO1xuY29uc3QgQklOQVJZX1RZUEVTID0gZXhwb3J0cy5CSU5BUllfVFlQRVMgPSBfaW5kZXguRkxJUFBFRF9BTElBU19LRVlTW1wiQmluYXJ5XCJdO1xuY29uc3QgU0NPUEFCTEVfVFlQRVMgPSBleHBvcnRzLlNDT1BBQkxFX1RZUEVTID0gX2luZGV4LkZMSVBQRURfQUxJQVNfS0VZU1tcIlNjb3BhYmxlXCJdO1xuY29uc3QgQkxPQ0tQQVJFTlRfVFlQRVMgPSBleHBvcnRzLkJMT0NLUEFSRU5UX1RZUEVTID0gX2luZGV4LkZMSVBQRURfQUxJQVNfS0VZU1tcIkJsb2NrUGFyZW50XCJdO1xuY29uc3QgQkxPQ0tfVFlQRVMgPSBleHBvcnRzLkJMT0NLX1RZUEVTID0gX2luZGV4LkZMSVBQRURfQUxJQVNfS0VZU1tcIkJsb2NrXCJdO1xuY29uc3QgU1RBVEVNRU5UX1RZUEVTID0gZXhwb3J0cy5TVEFURU1FTlRfVFlQRVMgPSBfaW5kZXguRkxJUFBFRF9BTElBU19LRVlTW1wiU3RhdGVtZW50XCJdO1xuY29uc3QgVEVSTUlOQVRPUkxFU1NfVFlQRVMgPSBleHBvcnRzLlRFUk1JTkFUT1JMRVNTX1RZUEVTID0gX2luZGV4LkZMSVBQRURfQUxJQVNfS0VZU1tcIlRlcm1pbmF0b3JsZXNzXCJdO1xuY29uc3QgQ09NUExFVElPTlNUQVRFTUVOVF9UWVBFUyA9IGV4cG9ydHMuQ09NUExFVElPTlNUQVRFTUVOVF9UWVBFUyA9IF9pbmRleC5GTElQUEVEX0FMSUFTX0tFWVNbXCJDb21wbGV0aW9uU3RhdGVtZW50XCJdO1xuY29uc3QgQ09ORElUSU9OQUxfVFlQRVMgPSBleHBvcnRzLkNPTkRJVElPTkFMX1RZUEVTID0gX2luZGV4LkZMSVBQRURfQUxJQVNfS0VZU1tcIkNvbmRpdGlvbmFsXCJdO1xuY29uc3QgTE9PUF9UWVBFUyA9IGV4cG9ydHMuTE9PUF9UWVBFUyA9IF9pbmRleC5GTElQUEVEX0FMSUFTX0tFWVNbXCJMb29wXCJdO1xuY29uc3QgV0hJTEVfVFlQRVMgPSBleHBvcnRzLldISUxFX1RZUEVTID0gX2luZGV4LkZMSVBQRURfQUxJQVNfS0VZU1tcIldoaWxlXCJdO1xuY29uc3QgRVhQUkVTU0lPTldSQVBQRVJfVFlQRVMgPSBleHBvcnRzLkVYUFJFU1NJT05XUkFQUEVSX1RZUEVTID0gX2luZGV4LkZMSVBQRURfQUxJQVNfS0VZU1tcIkV4cHJlc3Npb25XcmFwcGVyXCJdO1xuY29uc3QgRk9SX1RZUEVTID0gZXhwb3J0cy5GT1JfVFlQRVMgPSBfaW5kZXguRkxJUFBFRF9BTElBU19LRVlTW1wiRm9yXCJdO1xuY29uc3QgRk9SWFNUQVRFTUVOVF9UWVBFUyA9IGV4cG9ydHMuRk9SWFNUQVRFTUVOVF9UWVBFUyA9IF9pbmRleC5GTElQUEVEX0FMSUFTX0tFWVNbXCJGb3JYU3RhdGVtZW50XCJdO1xuY29uc3QgRlVOQ1RJT05fVFlQRVMgPSBleHBvcnRzLkZVTkNUSU9OX1RZUEVTID0gX2luZGV4LkZMSVBQRURfQUxJQVNfS0VZU1tcIkZ1bmN0aW9uXCJdO1xuY29uc3QgRlVOQ1RJT05QQVJFTlRfVFlQRVMgPSBleHBvcnRzLkZVTkNUSU9OUEFSRU5UX1RZUEVTID0gX2luZGV4LkZMSVBQRURfQUxJQVNfS0VZU1tcIkZ1bmN0aW9uUGFyZW50XCJdO1xuY29uc3QgUFVSRUlTSF9UWVBFUyA9IGV4cG9ydHMuUFVSRUlTSF9UWVBFUyA9IF9pbmRleC5GTElQUEVEX0FMSUFTX0tFWVNbXCJQdXJlaXNoXCJdO1xuY29uc3QgREVDTEFSQVRJT05fVFlQRVMgPSBleHBvcnRzLkRFQ0xBUkFUSU9OX1RZUEVTID0gX2luZGV4LkZMSVBQRURfQUxJQVNfS0VZU1tcIkRlY2xhcmF0aW9uXCJdO1xuY29uc3QgRlVOQ1RJT05QQVJBTUVURVJfVFlQRVMgPSBleHBvcnRzLkZVTkNUSU9OUEFSQU1FVEVSX1RZUEVTID0gX2luZGV4LkZMSVBQRURfQUxJQVNfS0VZU1tcIkZ1bmN0aW9uUGFyYW1ldGVyXCJdO1xuY29uc3QgUEFUVEVSTkxJS0VfVFlQRVMgPSBleHBvcnRzLlBBVFRFUk5MSUtFX1RZUEVTID0gX2luZGV4LkZMSVBQRURfQUxJQVNfS0VZU1tcIlBhdHRlcm5MaWtlXCJdO1xuY29uc3QgTFZBTF9UWVBFUyA9IGV4cG9ydHMuTFZBTF9UWVBFUyA9IF9pbmRleC5GTElQUEVEX0FMSUFTX0tFWVNbXCJMVmFsXCJdO1xuY29uc3QgVFNFTlRJVFlOQU1FX1RZUEVTID0gZXhwb3J0cy5UU0VOVElUWU5BTUVfVFlQRVMgPSBfaW5kZXguRkxJUFBFRF9BTElBU19LRVlTW1wiVFNFbnRpdHlOYW1lXCJdO1xuY29uc3QgTElURVJBTF9UWVBFUyA9IGV4cG9ydHMuTElURVJBTF9UWVBFUyA9IF9pbmRleC5GTElQUEVEX0FMSUFTX0tFWVNbXCJMaXRlcmFsXCJdO1xuY29uc3QgSU1NVVRBQkxFX1RZUEVTID0gZXhwb3J0cy5JTU1VVEFCTEVfVFlQRVMgPSBfaW5kZXguRkxJUFBFRF9BTElBU19LRVlTW1wiSW1tdXRhYmxlXCJdO1xuY29uc3QgVVNFUldISVRFU1BBQ0FCTEVfVFlQRVMgPSBleHBvcnRzLlVTRVJXSElURVNQQUNBQkxFX1RZUEVTID0gX2luZGV4LkZMSVBQRURfQUxJQVNfS0VZU1tcIlVzZXJXaGl0ZXNwYWNhYmxlXCJdO1xuY29uc3QgTUVUSE9EX1RZUEVTID0gZXhwb3J0cy5NRVRIT0RfVFlQRVMgPSBfaW5kZXguRkxJUFBFRF9BTElBU19LRVlTW1wiTWV0aG9kXCJdO1xuY29uc3QgT0JKRUNUTUVNQkVSX1RZUEVTID0gZXhwb3J0cy5PQkpFQ1RNRU1CRVJfVFlQRVMgPSBfaW5kZXguRkxJUFBFRF9BTElBU19LRVlTW1wiT2JqZWN0TWVtYmVyXCJdO1xuY29uc3QgUFJPUEVSVFlfVFlQRVMgPSBleHBvcnRzLlBST1BFUlRZX1RZUEVTID0gX2luZGV4LkZMSVBQRURfQUxJQVNfS0VZU1tcIlByb3BlcnR5XCJdO1xuY29uc3QgVU5BUllMSUtFX1RZUEVTID0gZXhwb3J0cy5VTkFSWUxJS0VfVFlQRVMgPSBfaW5kZXguRkxJUFBFRF9BTElBU19LRVlTW1wiVW5hcnlMaWtlXCJdO1xuY29uc3QgUEFUVEVSTl9UWVBFUyA9IGV4cG9ydHMuUEFUVEVSTl9UWVBFUyA9IF9pbmRleC5GTElQUEVEX0FMSUFTX0tFWVNbXCJQYXR0ZXJuXCJdO1xuY29uc3QgQ0xBU1NfVFlQRVMgPSBleHBvcnRzLkNMQVNTX1RZUEVTID0gX2luZGV4LkZMSVBQRURfQUxJQVNfS0VZU1tcIkNsYXNzXCJdO1xuY29uc3QgSU1QT1JUT1JFWFBPUlRERUNMQVJBVElPTl9UWVBFUyA9IGV4cG9ydHMuSU1QT1JUT1JFWFBPUlRERUNMQVJBVElPTl9UWVBFUyA9IF9pbmRleC5GTElQUEVEX0FMSUFTX0tFWVNbXCJJbXBvcnRPckV4cG9ydERlY2xhcmF0aW9uXCJdO1xuY29uc3QgRVhQT1JUREVDTEFSQVRJT05fVFlQRVMgPSBleHBvcnRzLkVYUE9SVERFQ0xBUkFUSU9OX1RZUEVTID0gX2luZGV4LkZMSVBQRURfQUxJQVNfS0VZU1tcIkV4cG9ydERlY2xhcmF0aW9uXCJdO1xuY29uc3QgTU9EVUxFU1BFQ0lGSUVSX1RZUEVTID0gZXhwb3J0cy5NT0RVTEVTUEVDSUZJRVJfVFlQRVMgPSBfaW5kZXguRkxJUFBFRF9BTElBU19LRVlTW1wiTW9kdWxlU3BlY2lmaWVyXCJdO1xuY29uc3QgQUNDRVNTT1JfVFlQRVMgPSBleHBvcnRzLkFDQ0VTU09SX1RZUEVTID0gX2luZGV4LkZMSVBQRURfQUxJQVNfS0VZU1tcIkFjY2Vzc29yXCJdO1xuY29uc3QgUFJJVkFURV9UWVBFUyA9IGV4cG9ydHMuUFJJVkFURV9UWVBFUyA9IF9pbmRleC5GTElQUEVEX0FMSUFTX0tFWVNbXCJQcml2YXRlXCJdO1xuY29uc3QgRkxPV19UWVBFUyA9IGV4cG9ydHMuRkxPV19UWVBFUyA9IF9pbmRleC5GTElQUEVEX0FMSUFTX0tFWVNbXCJGbG93XCJdO1xuY29uc3QgRkxPV1RZUEVfVFlQRVMgPSBleHBvcnRzLkZMT1dUWVBFX1RZUEVTID0gX2luZGV4LkZMSVBQRURfQUxJQVNfS0VZU1tcIkZsb3dUeXBlXCJdO1xuY29uc3QgRkxPV0JBU0VBTk5PVEFUSU9OX1RZUEVTID0gZXhwb3J0cy5GTE9XQkFTRUFOTk9UQVRJT05fVFlQRVMgPSBfaW5kZXguRkxJUFBFRF9BTElBU19LRVlTW1wiRmxvd0Jhc2VBbm5vdGF0aW9uXCJdO1xuY29uc3QgRkxPV0RFQ0xBUkFUSU9OX1RZUEVTID0gZXhwb3J0cy5GTE9XREVDTEFSQVRJT05fVFlQRVMgPSBfaW5kZXguRkxJUFBFRF9BTElBU19LRVlTW1wiRmxvd0RlY2xhcmF0aW9uXCJdO1xuY29uc3QgRkxPV1BSRURJQ0FURV9UWVBFUyA9IGV4cG9ydHMuRkxPV1BSRURJQ0FURV9UWVBFUyA9IF9pbmRleC5GTElQUEVEX0FMSUFTX0tFWVNbXCJGbG93UHJlZGljYXRlXCJdO1xuY29uc3QgRU5VTUJPRFlfVFlQRVMgPSBleHBvcnRzLkVOVU1CT0RZX1RZUEVTID0gX2luZGV4LkZMSVBQRURfQUxJQVNfS0VZU1tcIkVudW1Cb2R5XCJdO1xuY29uc3QgRU5VTU1FTUJFUl9UWVBFUyA9IGV4cG9ydHMuRU5VTU1FTUJFUl9UWVBFUyA9IF9pbmRleC5GTElQUEVEX0FMSUFTX0tFWVNbXCJFbnVtTWVtYmVyXCJdO1xuY29uc3QgSlNYX1RZUEVTID0gZXhwb3J0cy5KU1hfVFlQRVMgPSBfaW5kZXguRkxJUFBFRF9BTElBU19LRVlTW1wiSlNYXCJdO1xuY29uc3QgTUlTQ0VMTEFORU9VU19UWVBFUyA9IGV4cG9ydHMuTUlTQ0VMTEFORU9VU19UWVBFUyA9IF9pbmRleC5GTElQUEVEX0FMSUFTX0tFWVNbXCJNaXNjZWxsYW5lb3VzXCJdO1xuY29uc3QgVFlQRVNDUklQVF9UWVBFUyA9IGV4cG9ydHMuVFlQRVNDUklQVF9UWVBFUyA9IF9pbmRleC5GTElQUEVEX0FMSUFTX0tFWVNbXCJUeXBlU2NyaXB0XCJdO1xuY29uc3QgVFNUWVBFRUxFTUVOVF9UWVBFUyA9IGV4cG9ydHMuVFNUWVBFRUxFTUVOVF9UWVBFUyA9IF9pbmRleC5GTElQUEVEX0FMSUFTX0tFWVNbXCJUU1R5cGVFbGVtZW50XCJdO1xuY29uc3QgVFNUWVBFX1RZUEVTID0gZXhwb3J0cy5UU1RZUEVfVFlQRVMgPSBfaW5kZXguRkxJUFBFRF9BTElBU19LRVlTW1wiVFNUeXBlXCJdO1xuY29uc3QgVFNCQVNFVFlQRV9UWVBFUyA9IGV4cG9ydHMuVFNCQVNFVFlQRV9UWVBFUyA9IF9pbmRleC5GTElQUEVEX0FMSUFTX0tFWVNbXCJUU0Jhc2VUeXBlXCJdO1xuY29uc3QgTU9EVUxFREVDTEFSQVRJT05fVFlQRVMgPSBleHBvcnRzLk1PRFVMRURFQ0xBUkFUSU9OX1RZUEVTID0gSU1QT1JUT1JFWFBPUlRERUNMQVJBVElPTl9UWVBFUztcblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@babel/types/lib/constants/generated/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@babel/types/lib/constants/index.js":
/*!**********************************************************!*\
  !*** ./node_modules/@babel/types/lib/constants/index.js ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports.UPDATE_OPERATORS = exports.UNARY_OPERATORS = exports.STRING_UNARY_OPERATORS = exports.STATEMENT_OR_BLOCK_KEYS = exports.NUMBER_UNARY_OPERATORS = exports.NUMBER_BINARY_OPERATORS = exports.LOGICAL_OPERATORS = exports.INHERIT_KEYS = exports.FOR_INIT_KEYS = exports.FLATTENABLE_KEYS = exports.EQUALITY_BINARY_OPERATORS = exports.COMPARISON_BINARY_OPERATORS = exports.COMMENT_KEYS = exports.BOOLEAN_UNARY_OPERATORS = exports.BOOLEAN_NUMBER_BINARY_OPERATORS = exports.BOOLEAN_BINARY_OPERATORS = exports.BINARY_OPERATORS = exports.ASSIGNMENT_OPERATORS = void 0;\nconst STATEMENT_OR_BLOCK_KEYS = exports.STATEMENT_OR_BLOCK_KEYS = [\"consequent\", \"body\", \"alternate\"];\nconst FLATTENABLE_KEYS = exports.FLATTENABLE_KEYS = [\"body\", \"expressions\"];\nconst FOR_INIT_KEYS = exports.FOR_INIT_KEYS = [\"left\", \"init\"];\nconst COMMENT_KEYS = exports.COMMENT_KEYS = [\"leadingComments\", \"trailingComments\", \"innerComments\"];\nconst LOGICAL_OPERATORS = exports.LOGICAL_OPERATORS = [\"||\", \"&&\", \"??\"];\nconst UPDATE_OPERATORS = exports.UPDATE_OPERATORS = [\"++\", \"--\"];\nconst BOOLEAN_NUMBER_BINARY_OPERATORS = exports.BOOLEAN_NUMBER_BINARY_OPERATORS = [\">\", \"<\", \">=\", \"<=\"];\nconst EQUALITY_BINARY_OPERATORS = exports.EQUALITY_BINARY_OPERATORS = [\"==\", \"===\", \"!=\", \"!==\"];\nconst COMPARISON_BINARY_OPERATORS = exports.COMPARISON_BINARY_OPERATORS = [...EQUALITY_BINARY_OPERATORS, \"in\", \"instanceof\"];\nconst BOOLEAN_BINARY_OPERATORS = exports.BOOLEAN_BINARY_OPERATORS = [...COMPARISON_BINARY_OPERATORS, ...BOOLEAN_NUMBER_BINARY_OPERATORS];\nconst NUMBER_BINARY_OPERATORS = exports.NUMBER_BINARY_OPERATORS = [\"-\", \"/\", \"%\", \"*\", \"**\", \"&\", \"|\", \">>\", \">>>\", \"<<\", \"^\"];\nconst BINARY_OPERATORS = exports.BINARY_OPERATORS = [\"+\", ...NUMBER_BINARY_OPERATORS, ...BOOLEAN_BINARY_OPERATORS, \"|>\"];\nconst ASSIGNMENT_OPERATORS = exports.ASSIGNMENT_OPERATORS = [\"=\", \"+=\", ...NUMBER_BINARY_OPERATORS.map(op => op + \"=\"), ...LOGICAL_OPERATORS.map(op => op + \"=\")];\nconst BOOLEAN_UNARY_OPERATORS = exports.BOOLEAN_UNARY_OPERATORS = [\"delete\", \"!\"];\nconst NUMBER_UNARY_OPERATORS = exports.NUMBER_UNARY_OPERATORS = [\"+\", \"-\", \"~\"];\nconst STRING_UNARY_OPERATORS = exports.STRING_UNARY_OPERATORS = [\"typeof\"];\nconst UNARY_OPERATORS = exports.UNARY_OPERATORS = [\"void\", \"throw\", ...BOOLEAN_UNARY_OPERATORS, ...NUMBER_UNARY_OPERATORS, ...STRING_UNARY_OPERATORS];\nconst INHERIT_KEYS = exports.INHERIT_KEYS = {\n  optional: [\"typeAnnotation\", \"typeParameters\", \"returnType\"],\n  force: [\"start\", \"loc\", \"end\"]\n};\nexports.BLOCK_SCOPED_SYMBOL = Symbol.for(\"var used to be block scoped\");\nexports.NOT_LOCAL_BINDING = Symbol.for(\"should not be considered a local binding\");\n\n//# sourceMappingURL=index.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGJhYmVsL3R5cGVzL2xpYi9jb25zdGFudHMvaW5kZXguanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWIsOENBQTZDO0FBQzdDO0FBQ0EsQ0FBQyxFQUFDO0FBQ0Ysd0JBQXdCLEdBQUcsdUJBQXVCLEdBQUcsOEJBQThCLEdBQUcsK0JBQStCLEdBQUcsOEJBQThCLEdBQUcsK0JBQStCLEdBQUcseUJBQXlCLEdBQUcsb0JBQW9CLEdBQUcscUJBQXFCLEdBQUcsd0JBQXdCLEdBQUcsaUNBQWlDLEdBQUcsbUNBQW1DLEdBQUcsb0JBQW9CLEdBQUcsK0JBQStCLEdBQUcsdUNBQXVDLEdBQUcsZ0NBQWdDLEdBQUcsd0JBQXdCLEdBQUcsNEJBQTRCO0FBQ3hpQixnQ0FBZ0MsK0JBQStCO0FBQy9ELHlCQUF5Qix3QkFBd0I7QUFDakQsc0JBQXNCLHFCQUFxQjtBQUMzQyxxQkFBcUIsb0JBQW9CO0FBQ3pDLDBCQUEwQix5QkFBeUI7QUFDbkQseUJBQXlCLHdCQUF3QjtBQUNqRCx3Q0FBd0MsdUNBQXVDO0FBQy9FLGtDQUFrQyxpQ0FBaUM7QUFDbkUsb0NBQW9DLG1DQUFtQztBQUN2RSxpQ0FBaUMsZ0NBQWdDO0FBQ2pFLGdDQUFnQywrQkFBK0I7QUFDL0QseUJBQXlCLHdCQUF3QjtBQUNqRCw2QkFBNkIsNEJBQTRCO0FBQ3pELGdDQUFnQywrQkFBK0I7QUFDL0QsK0JBQStCLDhCQUE4QjtBQUM3RCwrQkFBK0IsOEJBQThCO0FBQzdELHdCQUF3Qix1QkFBdUI7QUFDL0MscUJBQXFCLG9CQUFvQjtBQUN6QztBQUNBO0FBQ0E7QUFDQSwyQkFBMkI7QUFDM0IseUJBQXlCOztBQUV6QiIsInNvdXJjZXMiOlsid2VicGFjazovL3JlcG8tdmlzdWFsaXplci8uL25vZGVfbW9kdWxlcy9AYmFiZWwvdHlwZXMvbGliL2NvbnN0YW50cy9pbmRleC5qcz9jNjBjIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5VUERBVEVfT1BFUkFUT1JTID0gZXhwb3J0cy5VTkFSWV9PUEVSQVRPUlMgPSBleHBvcnRzLlNUUklOR19VTkFSWV9PUEVSQVRPUlMgPSBleHBvcnRzLlNUQVRFTUVOVF9PUl9CTE9DS19LRVlTID0gZXhwb3J0cy5OVU1CRVJfVU5BUllfT1BFUkFUT1JTID0gZXhwb3J0cy5OVU1CRVJfQklOQVJZX09QRVJBVE9SUyA9IGV4cG9ydHMuTE9HSUNBTF9PUEVSQVRPUlMgPSBleHBvcnRzLklOSEVSSVRfS0VZUyA9IGV4cG9ydHMuRk9SX0lOSVRfS0VZUyA9IGV4cG9ydHMuRkxBVFRFTkFCTEVfS0VZUyA9IGV4cG9ydHMuRVFVQUxJVFlfQklOQVJZX09QRVJBVE9SUyA9IGV4cG9ydHMuQ09NUEFSSVNPTl9CSU5BUllfT1BFUkFUT1JTID0gZXhwb3J0cy5DT01NRU5UX0tFWVMgPSBleHBvcnRzLkJPT0xFQU5fVU5BUllfT1BFUkFUT1JTID0gZXhwb3J0cy5CT09MRUFOX05VTUJFUl9CSU5BUllfT1BFUkFUT1JTID0gZXhwb3J0cy5CT09MRUFOX0JJTkFSWV9PUEVSQVRPUlMgPSBleHBvcnRzLkJJTkFSWV9PUEVSQVRPUlMgPSBleHBvcnRzLkFTU0lHTk1FTlRfT1BFUkFUT1JTID0gdm9pZCAwO1xuY29uc3QgU1RBVEVNRU5UX09SX0JMT0NLX0tFWVMgPSBleHBvcnRzLlNUQVRFTUVOVF9PUl9CTE9DS19LRVlTID0gW1wiY29uc2VxdWVudFwiLCBcImJvZHlcIiwgXCJhbHRlcm5hdGVcIl07XG5jb25zdCBGTEFUVEVOQUJMRV9LRVlTID0gZXhwb3J0cy5GTEFUVEVOQUJMRV9LRVlTID0gW1wiYm9keVwiLCBcImV4cHJlc3Npb25zXCJdO1xuY29uc3QgRk9SX0lOSVRfS0VZUyA9IGV4cG9ydHMuRk9SX0lOSVRfS0VZUyA9IFtcImxlZnRcIiwgXCJpbml0XCJdO1xuY29uc3QgQ09NTUVOVF9LRVlTID0gZXhwb3J0cy5DT01NRU5UX0tFWVMgPSBbXCJsZWFkaW5nQ29tbWVudHNcIiwgXCJ0cmFpbGluZ0NvbW1lbnRzXCIsIFwiaW5uZXJDb21tZW50c1wiXTtcbmNvbnN0IExPR0lDQUxfT1BFUkFUT1JTID0gZXhwb3J0cy5MT0dJQ0FMX09QRVJBVE9SUyA9IFtcInx8XCIsIFwiJiZcIiwgXCI/P1wiXTtcbmNvbnN0IFVQREFURV9PUEVSQVRPUlMgPSBleHBvcnRzLlVQREFURV9PUEVSQVRPUlMgPSBbXCIrK1wiLCBcIi0tXCJdO1xuY29uc3QgQk9PTEVBTl9OVU1CRVJfQklOQVJZX09QRVJBVE9SUyA9IGV4cG9ydHMuQk9PTEVBTl9OVU1CRVJfQklOQVJZX09QRVJBVE9SUyA9IFtcIj5cIiwgXCI8XCIsIFwiPj1cIiwgXCI8PVwiXTtcbmNvbnN0IEVRVUFMSVRZX0JJTkFSWV9PUEVSQVRPUlMgPSBleHBvcnRzLkVRVUFMSVRZX0JJTkFSWV9PUEVSQVRPUlMgPSBbXCI9PVwiLCBcIj09PVwiLCBcIiE9XCIsIFwiIT09XCJdO1xuY29uc3QgQ09NUEFSSVNPTl9CSU5BUllfT1BFUkFUT1JTID0gZXhwb3J0cy5DT01QQVJJU09OX0JJTkFSWV9PUEVSQVRPUlMgPSBbLi4uRVFVQUxJVFlfQklOQVJZX09QRVJBVE9SUywgXCJpblwiLCBcImluc3RhbmNlb2ZcIl07XG5jb25zdCBCT09MRUFOX0JJTkFSWV9PUEVSQVRPUlMgPSBleHBvcnRzLkJPT0xFQU5fQklOQVJZX09QRVJBVE9SUyA9IFsuLi5DT01QQVJJU09OX0JJTkFSWV9PUEVSQVRPUlMsIC4uLkJPT0xFQU5fTlVNQkVSX0JJTkFSWV9PUEVSQVRPUlNdO1xuY29uc3QgTlVNQkVSX0JJTkFSWV9PUEVSQVRPUlMgPSBleHBvcnRzLk5VTUJFUl9CSU5BUllfT1BFUkFUT1JTID0gW1wiLVwiLCBcIi9cIiwgXCIlXCIsIFwiKlwiLCBcIioqXCIsIFwiJlwiLCBcInxcIiwgXCI+PlwiLCBcIj4+PlwiLCBcIjw8XCIsIFwiXlwiXTtcbmNvbnN0IEJJTkFSWV9PUEVSQVRPUlMgPSBleHBvcnRzLkJJTkFSWV9PUEVSQVRPUlMgPSBbXCIrXCIsIC4uLk5VTUJFUl9CSU5BUllfT1BFUkFUT1JTLCAuLi5CT09MRUFOX0JJTkFSWV9PUEVSQVRPUlMsIFwifD5cIl07XG5jb25zdCBBU1NJR05NRU5UX09QRVJBVE9SUyA9IGV4cG9ydHMuQVNTSUdOTUVOVF9PUEVSQVRPUlMgPSBbXCI9XCIsIFwiKz1cIiwgLi4uTlVNQkVSX0JJTkFSWV9PUEVSQVRPUlMubWFwKG9wID0+IG9wICsgXCI9XCIpLCAuLi5MT0dJQ0FMX09QRVJBVE9SUy5tYXAob3AgPT4gb3AgKyBcIj1cIildO1xuY29uc3QgQk9PTEVBTl9VTkFSWV9PUEVSQVRPUlMgPSBleHBvcnRzLkJPT0xFQU5fVU5BUllfT1BFUkFUT1JTID0gW1wiZGVsZXRlXCIsIFwiIVwiXTtcbmNvbnN0IE5VTUJFUl9VTkFSWV9PUEVSQVRPUlMgPSBleHBvcnRzLk5VTUJFUl9VTkFSWV9PUEVSQVRPUlMgPSBbXCIrXCIsIFwiLVwiLCBcIn5cIl07XG5jb25zdCBTVFJJTkdfVU5BUllfT1BFUkFUT1JTID0gZXhwb3J0cy5TVFJJTkdfVU5BUllfT1BFUkFUT1JTID0gW1widHlwZW9mXCJdO1xuY29uc3QgVU5BUllfT1BFUkFUT1JTID0gZXhwb3J0cy5VTkFSWV9PUEVSQVRPUlMgPSBbXCJ2b2lkXCIsIFwidGhyb3dcIiwgLi4uQk9PTEVBTl9VTkFSWV9PUEVSQVRPUlMsIC4uLk5VTUJFUl9VTkFSWV9PUEVSQVRPUlMsIC4uLlNUUklOR19VTkFSWV9PUEVSQVRPUlNdO1xuY29uc3QgSU5IRVJJVF9LRVlTID0gZXhwb3J0cy5JTkhFUklUX0tFWVMgPSB7XG4gIG9wdGlvbmFsOiBbXCJ0eXBlQW5ub3RhdGlvblwiLCBcInR5cGVQYXJhbWV0ZXJzXCIsIFwicmV0dXJuVHlwZVwiXSxcbiAgZm9yY2U6IFtcInN0YXJ0XCIsIFwibG9jXCIsIFwiZW5kXCJdXG59O1xuZXhwb3J0cy5CTE9DS19TQ09QRURfU1lNQk9MID0gU3ltYm9sLmZvcihcInZhciB1c2VkIHRvIGJlIGJsb2NrIHNjb3BlZFwiKTtcbmV4cG9ydHMuTk9UX0xPQ0FMX0JJTkRJTkcgPSBTeW1ib2wuZm9yKFwic2hvdWxkIG5vdCBiZSBjb25zaWRlcmVkIGEgbG9jYWwgYmluZGluZ1wiKTtcblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@babel/types/lib/constants/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@babel/types/lib/converters/ensureBlock.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@babel/types/lib/converters/ensureBlock.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports[\"default\"] = ensureBlock;\nvar _toBlock = __webpack_require__(/*! ./toBlock.js */ \"(ssr)/./node_modules/@babel/types/lib/converters/toBlock.js\");\nfunction ensureBlock(node, key = \"body\") {\n  const result = (0, _toBlock.default)(node[key], node);\n  node[key] = result;\n  return result;\n}\n\n//# sourceMappingURL=ensureBlock.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGJhYmVsL3R5cGVzL2xpYi9jb252ZXJ0ZXJzL2Vuc3VyZUJsb2NrLmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViLDhDQUE2QztBQUM3QztBQUNBLENBQUMsRUFBQztBQUNGLGtCQUFlO0FBQ2YsZUFBZSxtQkFBTyxDQUFDLGlGQUFjO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9yZXBvLXZpc3VhbGl6ZXIvLi9ub2RlX21vZHVsZXMvQGJhYmVsL3R5cGVzL2xpYi9jb252ZXJ0ZXJzL2Vuc3VyZUJsb2NrLmpzP2ZlMzIiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLmRlZmF1bHQgPSBlbnN1cmVCbG9jaztcbnZhciBfdG9CbG9jayA9IHJlcXVpcmUoXCIuL3RvQmxvY2suanNcIik7XG5mdW5jdGlvbiBlbnN1cmVCbG9jayhub2RlLCBrZXkgPSBcImJvZHlcIikge1xuICBjb25zdCByZXN1bHQgPSAoMCwgX3RvQmxvY2suZGVmYXVsdCkobm9kZVtrZXldLCBub2RlKTtcbiAgbm9kZVtrZXldID0gcmVzdWx0O1xuICByZXR1cm4gcmVzdWx0O1xufVxuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1lbnN1cmVCbG9jay5qcy5tYXBcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@babel/types/lib/converters/ensureBlock.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@babel/types/lib/converters/gatherSequenceExpressions.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/@babel/types/lib/converters/gatherSequenceExpressions.js ***!
  \*******************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports[\"default\"] = gatherSequenceExpressions;\nvar _getBindingIdentifiers = __webpack_require__(/*! ../retrievers/getBindingIdentifiers.js */ \"(ssr)/./node_modules/@babel/types/lib/retrievers/getBindingIdentifiers.js\");\nvar _index = __webpack_require__(/*! ../validators/generated/index.js */ \"(ssr)/./node_modules/@babel/types/lib/validators/generated/index.js\");\nvar _index2 = __webpack_require__(/*! ../builders/generated/index.js */ \"(ssr)/./node_modules/@babel/types/lib/builders/generated/index.js\");\nvar _productions = __webpack_require__(/*! ../builders/productions.js */ \"(ssr)/./node_modules/@babel/types/lib/builders/productions.js\");\nvar _cloneNode = __webpack_require__(/*! ../clone/cloneNode.js */ \"(ssr)/./node_modules/@babel/types/lib/clone/cloneNode.js\");\nfunction gatherSequenceExpressions(nodes, declars) {\n  const exprs = [];\n  let ensureLastUndefined = true;\n  for (const node of nodes) {\n    if (!(0, _index.isEmptyStatement)(node)) {\n      ensureLastUndefined = false;\n    }\n    if ((0, _index.isExpression)(node)) {\n      exprs.push(node);\n    } else if ((0, _index.isExpressionStatement)(node)) {\n      exprs.push(node.expression);\n    } else if ((0, _index.isVariableDeclaration)(node)) {\n      if (node.kind !== \"var\") return;\n      for (const declar of node.declarations) {\n        const bindings = (0, _getBindingIdentifiers.default)(declar);\n        for (const key of Object.keys(bindings)) {\n          declars.push({\n            kind: node.kind,\n            id: (0, _cloneNode.default)(bindings[key])\n          });\n        }\n        if (declar.init) {\n          exprs.push((0, _index2.assignmentExpression)(\"=\", declar.id, declar.init));\n        }\n      }\n      ensureLastUndefined = true;\n    } else if ((0, _index.isIfStatement)(node)) {\n      const consequent = node.consequent ? gatherSequenceExpressions([node.consequent], declars) : (0, _productions.buildUndefinedNode)();\n      const alternate = node.alternate ? gatherSequenceExpressions([node.alternate], declars) : (0, _productions.buildUndefinedNode)();\n      if (!consequent || !alternate) return;\n      exprs.push((0, _index2.conditionalExpression)(node.test, consequent, alternate));\n    } else if ((0, _index.isBlockStatement)(node)) {\n      const body = gatherSequenceExpressions(node.body, declars);\n      if (!body) return;\n      exprs.push(body);\n    } else if ((0, _index.isEmptyStatement)(node)) {\n      if (nodes.indexOf(node) === 0) {\n        ensureLastUndefined = true;\n      }\n    } else {\n      return;\n    }\n  }\n  if (ensureLastUndefined) {\n    exprs.push((0, _productions.buildUndefinedNode)());\n  }\n  if (exprs.length === 1) {\n    return exprs[0];\n  } else {\n    return (0, _index2.sequenceExpression)(exprs);\n  }\n}\n\n//# sourceMappingURL=gatherSequenceExpressions.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGJhYmVsL3R5cGVzL2xpYi9jb252ZXJ0ZXJzL2dhdGhlclNlcXVlbmNlRXhwcmVzc2lvbnMuanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWIsOENBQTZDO0FBQzdDO0FBQ0EsQ0FBQyxFQUFDO0FBQ0Ysa0JBQWU7QUFDZiw2QkFBNkIsbUJBQU8sQ0FBQyx5SEFBd0M7QUFDN0UsYUFBYSxtQkFBTyxDQUFDLDZHQUFrQztBQUN2RCxjQUFjLG1CQUFPLENBQUMseUdBQWdDO0FBQ3RELG1CQUFtQixtQkFBTyxDQUFDLGlHQUE0QjtBQUN2RCxpQkFBaUIsbUJBQU8sQ0FBQyx1RkFBdUI7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBOztBQUVBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcmVwby12aXN1YWxpemVyLy4vbm9kZV9tb2R1bGVzL0BiYWJlbC90eXBlcy9saWIvY29udmVydGVycy9nYXRoZXJTZXF1ZW5jZUV4cHJlc3Npb25zLmpzP2ZhYmIiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLmRlZmF1bHQgPSBnYXRoZXJTZXF1ZW5jZUV4cHJlc3Npb25zO1xudmFyIF9nZXRCaW5kaW5nSWRlbnRpZmllcnMgPSByZXF1aXJlKFwiLi4vcmV0cmlldmVycy9nZXRCaW5kaW5nSWRlbnRpZmllcnMuanNcIik7XG52YXIgX2luZGV4ID0gcmVxdWlyZShcIi4uL3ZhbGlkYXRvcnMvZ2VuZXJhdGVkL2luZGV4LmpzXCIpO1xudmFyIF9pbmRleDIgPSByZXF1aXJlKFwiLi4vYnVpbGRlcnMvZ2VuZXJhdGVkL2luZGV4LmpzXCIpO1xudmFyIF9wcm9kdWN0aW9ucyA9IHJlcXVpcmUoXCIuLi9idWlsZGVycy9wcm9kdWN0aW9ucy5qc1wiKTtcbnZhciBfY2xvbmVOb2RlID0gcmVxdWlyZShcIi4uL2Nsb25lL2Nsb25lTm9kZS5qc1wiKTtcbmZ1bmN0aW9uIGdhdGhlclNlcXVlbmNlRXhwcmVzc2lvbnMobm9kZXMsIGRlY2xhcnMpIHtcbiAgY29uc3QgZXhwcnMgPSBbXTtcbiAgbGV0IGVuc3VyZUxhc3RVbmRlZmluZWQgPSB0cnVlO1xuICBmb3IgKGNvbnN0IG5vZGUgb2Ygbm9kZXMpIHtcbiAgICBpZiAoISgwLCBfaW5kZXguaXNFbXB0eVN0YXRlbWVudCkobm9kZSkpIHtcbiAgICAgIGVuc3VyZUxhc3RVbmRlZmluZWQgPSBmYWxzZTtcbiAgICB9XG4gICAgaWYgKCgwLCBfaW5kZXguaXNFeHByZXNzaW9uKShub2RlKSkge1xuICAgICAgZXhwcnMucHVzaChub2RlKTtcbiAgICB9IGVsc2UgaWYgKCgwLCBfaW5kZXguaXNFeHByZXNzaW9uU3RhdGVtZW50KShub2RlKSkge1xuICAgICAgZXhwcnMucHVzaChub2RlLmV4cHJlc3Npb24pO1xuICAgIH0gZWxzZSBpZiAoKDAsIF9pbmRleC5pc1ZhcmlhYmxlRGVjbGFyYXRpb24pKG5vZGUpKSB7XG4gICAgICBpZiAobm9kZS5raW5kICE9PSBcInZhclwiKSByZXR1cm47XG4gICAgICBmb3IgKGNvbnN0IGRlY2xhciBvZiBub2RlLmRlY2xhcmF0aW9ucykge1xuICAgICAgICBjb25zdCBiaW5kaW5ncyA9ICgwLCBfZ2V0QmluZGluZ0lkZW50aWZpZXJzLmRlZmF1bHQpKGRlY2xhcik7XG4gICAgICAgIGZvciAoY29uc3Qga2V5IG9mIE9iamVjdC5rZXlzKGJpbmRpbmdzKSkge1xuICAgICAgICAgIGRlY2xhcnMucHVzaCh7XG4gICAgICAgICAgICBraW5kOiBub2RlLmtpbmQsXG4gICAgICAgICAgICBpZDogKDAsIF9jbG9uZU5vZGUuZGVmYXVsdCkoYmluZGluZ3Nba2V5XSlcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZGVjbGFyLmluaXQpIHtcbiAgICAgICAgICBleHBycy5wdXNoKCgwLCBfaW5kZXgyLmFzc2lnbm1lbnRFeHByZXNzaW9uKShcIj1cIiwgZGVjbGFyLmlkLCBkZWNsYXIuaW5pdCkpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBlbnN1cmVMYXN0VW5kZWZpbmVkID0gdHJ1ZTtcbiAgICB9IGVsc2UgaWYgKCgwLCBfaW5kZXguaXNJZlN0YXRlbWVudCkobm9kZSkpIHtcbiAgICAgIGNvbnN0IGNvbnNlcXVlbnQgPSBub2RlLmNvbnNlcXVlbnQgPyBnYXRoZXJTZXF1ZW5jZUV4cHJlc3Npb25zKFtub2RlLmNvbnNlcXVlbnRdLCBkZWNsYXJzKSA6ICgwLCBfcHJvZHVjdGlvbnMuYnVpbGRVbmRlZmluZWROb2RlKSgpO1xuICAgICAgY29uc3QgYWx0ZXJuYXRlID0gbm9kZS5hbHRlcm5hdGUgPyBnYXRoZXJTZXF1ZW5jZUV4cHJlc3Npb25zKFtub2RlLmFsdGVybmF0ZV0sIGRlY2xhcnMpIDogKDAsIF9wcm9kdWN0aW9ucy5idWlsZFVuZGVmaW5lZE5vZGUpKCk7XG4gICAgICBpZiAoIWNvbnNlcXVlbnQgfHwgIWFsdGVybmF0ZSkgcmV0dXJuO1xuICAgICAgZXhwcnMucHVzaCgoMCwgX2luZGV4Mi5jb25kaXRpb25hbEV4cHJlc3Npb24pKG5vZGUudGVzdCwgY29uc2VxdWVudCwgYWx0ZXJuYXRlKSk7XG4gICAgfSBlbHNlIGlmICgoMCwgX2luZGV4LmlzQmxvY2tTdGF0ZW1lbnQpKG5vZGUpKSB7XG4gICAgICBjb25zdCBib2R5ID0gZ2F0aGVyU2VxdWVuY2VFeHByZXNzaW9ucyhub2RlLmJvZHksIGRlY2xhcnMpO1xuICAgICAgaWYgKCFib2R5KSByZXR1cm47XG4gICAgICBleHBycy5wdXNoKGJvZHkpO1xuICAgIH0gZWxzZSBpZiAoKDAsIF9pbmRleC5pc0VtcHR5U3RhdGVtZW50KShub2RlKSkge1xuICAgICAgaWYgKG5vZGVzLmluZGV4T2Yobm9kZSkgPT09IDApIHtcbiAgICAgICAgZW5zdXJlTGFzdFVuZGVmaW5lZCA9IHRydWU7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gIH1cbiAgaWYgKGVuc3VyZUxhc3RVbmRlZmluZWQpIHtcbiAgICBleHBycy5wdXNoKCgwLCBfcHJvZHVjdGlvbnMuYnVpbGRVbmRlZmluZWROb2RlKSgpKTtcbiAgfVxuICBpZiAoZXhwcnMubGVuZ3RoID09PSAxKSB7XG4gICAgcmV0dXJuIGV4cHJzWzBdO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiAoMCwgX2luZGV4Mi5zZXF1ZW5jZUV4cHJlc3Npb24pKGV4cHJzKTtcbiAgfVxufVxuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1nYXRoZXJTZXF1ZW5jZUV4cHJlc3Npb25zLmpzLm1hcFxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@babel/types/lib/converters/gatherSequenceExpressions.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@babel/types/lib/converters/toBindingIdentifierName.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/@babel/types/lib/converters/toBindingIdentifierName.js ***!
  \*****************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports[\"default\"] = toBindingIdentifierName;\nvar _toIdentifier = __webpack_require__(/*! ./toIdentifier.js */ \"(ssr)/./node_modules/@babel/types/lib/converters/toIdentifier.js\");\nfunction toBindingIdentifierName(name) {\n  name = (0, _toIdentifier.default)(name);\n  if (name === \"eval\" || name === \"arguments\") name = \"_\" + name;\n  return name;\n}\n\n//# sourceMappingURL=toBindingIdentifierName.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGJhYmVsL3R5cGVzL2xpYi9jb252ZXJ0ZXJzL3RvQmluZGluZ0lkZW50aWZpZXJOYW1lLmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViLDhDQUE2QztBQUM3QztBQUNBLENBQUMsRUFBQztBQUNGLGtCQUFlO0FBQ2Ysb0JBQW9CLG1CQUFPLENBQUMsMkZBQW1CO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9yZXBvLXZpc3VhbGl6ZXIvLi9ub2RlX21vZHVsZXMvQGJhYmVsL3R5cGVzL2xpYi9jb252ZXJ0ZXJzL3RvQmluZGluZ0lkZW50aWZpZXJOYW1lLmpzP2JlNzAiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLmRlZmF1bHQgPSB0b0JpbmRpbmdJZGVudGlmaWVyTmFtZTtcbnZhciBfdG9JZGVudGlmaWVyID0gcmVxdWlyZShcIi4vdG9JZGVudGlmaWVyLmpzXCIpO1xuZnVuY3Rpb24gdG9CaW5kaW5nSWRlbnRpZmllck5hbWUobmFtZSkge1xuICBuYW1lID0gKDAsIF90b0lkZW50aWZpZXIuZGVmYXVsdCkobmFtZSk7XG4gIGlmIChuYW1lID09PSBcImV2YWxcIiB8fCBuYW1lID09PSBcImFyZ3VtZW50c1wiKSBuYW1lID0gXCJfXCIgKyBuYW1lO1xuICByZXR1cm4gbmFtZTtcbn1cblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dG9CaW5kaW5nSWRlbnRpZmllck5hbWUuanMubWFwXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@babel/types/lib/converters/toBindingIdentifierName.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@babel/types/lib/converters/toBlock.js":
/*!*************************************************************!*\
  !*** ./node_modules/@babel/types/lib/converters/toBlock.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports[\"default\"] = toBlock;\nvar _index = __webpack_require__(/*! ../validators/generated/index.js */ \"(ssr)/./node_modules/@babel/types/lib/validators/generated/index.js\");\nvar _index2 = __webpack_require__(/*! ../builders/generated/index.js */ \"(ssr)/./node_modules/@babel/types/lib/builders/generated/index.js\");\nfunction toBlock(node, parent) {\n  if ((0, _index.isBlockStatement)(node)) {\n    return node;\n  }\n  let blockNodes = [];\n  if ((0, _index.isEmptyStatement)(node)) {\n    blockNodes = [];\n  } else {\n    if (!(0, _index.isStatement)(node)) {\n      if ((0, _index.isFunction)(parent)) {\n        node = (0, _index2.returnStatement)(node);\n      } else {\n        node = (0, _index2.expressionStatement)(node);\n      }\n    }\n    blockNodes = [node];\n  }\n  return (0, _index2.blockStatement)(blockNodes);\n}\n\n//# sourceMappingURL=toBlock.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGJhYmVsL3R5cGVzL2xpYi9jb252ZXJ0ZXJzL3RvQmxvY2suanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWIsOENBQTZDO0FBQzdDO0FBQ0EsQ0FBQyxFQUFDO0FBQ0Ysa0JBQWU7QUFDZixhQUFhLG1CQUFPLENBQUMsNkdBQWtDO0FBQ3ZELGNBQWMsbUJBQU8sQ0FBQyx5R0FBZ0M7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcmVwby12aXN1YWxpemVyLy4vbm9kZV9tb2R1bGVzL0BiYWJlbC90eXBlcy9saWIvY29udmVydGVycy90b0Jsb2NrLmpzPzY5NzYiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLmRlZmF1bHQgPSB0b0Jsb2NrO1xudmFyIF9pbmRleCA9IHJlcXVpcmUoXCIuLi92YWxpZGF0b3JzL2dlbmVyYXRlZC9pbmRleC5qc1wiKTtcbnZhciBfaW5kZXgyID0gcmVxdWlyZShcIi4uL2J1aWxkZXJzL2dlbmVyYXRlZC9pbmRleC5qc1wiKTtcbmZ1bmN0aW9uIHRvQmxvY2sobm9kZSwgcGFyZW50KSB7XG4gIGlmICgoMCwgX2luZGV4LmlzQmxvY2tTdGF0ZW1lbnQpKG5vZGUpKSB7XG4gICAgcmV0dXJuIG5vZGU7XG4gIH1cbiAgbGV0IGJsb2NrTm9kZXMgPSBbXTtcbiAgaWYgKCgwLCBfaW5kZXguaXNFbXB0eVN0YXRlbWVudCkobm9kZSkpIHtcbiAgICBibG9ja05vZGVzID0gW107XG4gIH0gZWxzZSB7XG4gICAgaWYgKCEoMCwgX2luZGV4LmlzU3RhdGVtZW50KShub2RlKSkge1xuICAgICAgaWYgKCgwLCBfaW5kZXguaXNGdW5jdGlvbikocGFyZW50KSkge1xuICAgICAgICBub2RlID0gKDAsIF9pbmRleDIucmV0dXJuU3RhdGVtZW50KShub2RlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG5vZGUgPSAoMCwgX2luZGV4Mi5leHByZXNzaW9uU3RhdGVtZW50KShub2RlKTtcbiAgICAgIH1cbiAgICB9XG4gICAgYmxvY2tOb2RlcyA9IFtub2RlXTtcbiAgfVxuICByZXR1cm4gKDAsIF9pbmRleDIuYmxvY2tTdGF0ZW1lbnQpKGJsb2NrTm9kZXMpO1xufVxuXG4vLyMgc291cmNlTWFwcGluZ1VSTD10b0Jsb2NrLmpzLm1hcFxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@babel/types/lib/converters/toBlock.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@babel/types/lib/converters/toComputedKey.js":
/*!*******************************************************************!*\
  !*** ./node_modules/@babel/types/lib/converters/toComputedKey.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports[\"default\"] = toComputedKey;\nvar _index = __webpack_require__(/*! ../validators/generated/index.js */ \"(ssr)/./node_modules/@babel/types/lib/validators/generated/index.js\");\nvar _index2 = __webpack_require__(/*! ../builders/generated/index.js */ \"(ssr)/./node_modules/@babel/types/lib/builders/generated/index.js\");\nfunction toComputedKey(node, key = node.key || node.property) {\n  if (!node.computed && (0, _index.isIdentifier)(key)) key = (0, _index2.stringLiteral)(key.name);\n  return key;\n}\n\n//# sourceMappingURL=toComputedKey.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGJhYmVsL3R5cGVzL2xpYi9jb252ZXJ0ZXJzL3RvQ29tcHV0ZWRLZXkuanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWIsOENBQTZDO0FBQzdDO0FBQ0EsQ0FBQyxFQUFDO0FBQ0Ysa0JBQWU7QUFDZixhQUFhLG1CQUFPLENBQUMsNkdBQWtDO0FBQ3ZELGNBQWMsbUJBQU8sQ0FBQyx5R0FBZ0M7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUEiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9yZXBvLXZpc3VhbGl6ZXIvLi9ub2RlX21vZHVsZXMvQGJhYmVsL3R5cGVzL2xpYi9jb252ZXJ0ZXJzL3RvQ29tcHV0ZWRLZXkuanM/ZWJiOCJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuZGVmYXVsdCA9IHRvQ29tcHV0ZWRLZXk7XG52YXIgX2luZGV4ID0gcmVxdWlyZShcIi4uL3ZhbGlkYXRvcnMvZ2VuZXJhdGVkL2luZGV4LmpzXCIpO1xudmFyIF9pbmRleDIgPSByZXF1aXJlKFwiLi4vYnVpbGRlcnMvZ2VuZXJhdGVkL2luZGV4LmpzXCIpO1xuZnVuY3Rpb24gdG9Db21wdXRlZEtleShub2RlLCBrZXkgPSBub2RlLmtleSB8fCBub2RlLnByb3BlcnR5KSB7XG4gIGlmICghbm9kZS5jb21wdXRlZCAmJiAoMCwgX2luZGV4LmlzSWRlbnRpZmllcikoa2V5KSkga2V5ID0gKDAsIF9pbmRleDIuc3RyaW5nTGl0ZXJhbCkoa2V5Lm5hbWUpO1xuICByZXR1cm4ga2V5O1xufVxuXG4vLyMgc291cmNlTWFwcGluZ1VSTD10b0NvbXB1dGVkS2V5LmpzLm1hcFxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@babel/types/lib/converters/toComputedKey.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@babel/types/lib/converters/toExpression.js":
/*!******************************************************************!*\
  !*** ./node_modules/@babel/types/lib/converters/toExpression.js ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports[\"default\"] = void 0;\nvar _index = __webpack_require__(/*! ../validators/generated/index.js */ \"(ssr)/./node_modules/@babel/types/lib/validators/generated/index.js\");\nvar _default = exports[\"default\"] = toExpression;\nfunction toExpression(node) {\n  if ((0, _index.isExpressionStatement)(node)) {\n    node = node.expression;\n  }\n  if ((0, _index.isExpression)(node)) {\n    return node;\n  }\n  if ((0, _index.isClass)(node)) {\n    node.type = \"ClassExpression\";\n    node.abstract = false;\n  } else if ((0, _index.isFunction)(node)) {\n    node.type = \"FunctionExpression\";\n  }\n  if (!(0, _index.isExpression)(node)) {\n    throw new Error(`cannot turn ${node.type} to an expression`);\n  }\n  return node;\n}\n\n//# sourceMappingURL=toExpression.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGJhYmVsL3R5cGVzL2xpYi9jb252ZXJ0ZXJzL3RvRXhwcmVzc2lvbi5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYiw4Q0FBNkM7QUFDN0M7QUFDQSxDQUFDLEVBQUM7QUFDRixrQkFBZTtBQUNmLGFBQWEsbUJBQU8sQ0FBQyw2R0FBa0M7QUFDdkQsZUFBZSxrQkFBZTtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUMsV0FBVztBQUM5QztBQUNBO0FBQ0E7O0FBRUEiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9yZXBvLXZpc3VhbGl6ZXIvLi9ub2RlX21vZHVsZXMvQGJhYmVsL3R5cGVzL2xpYi9jb252ZXJ0ZXJzL3RvRXhwcmVzc2lvbi5qcz8zZmYyIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5kZWZhdWx0ID0gdm9pZCAwO1xudmFyIF9pbmRleCA9IHJlcXVpcmUoXCIuLi92YWxpZGF0b3JzL2dlbmVyYXRlZC9pbmRleC5qc1wiKTtcbnZhciBfZGVmYXVsdCA9IGV4cG9ydHMuZGVmYXVsdCA9IHRvRXhwcmVzc2lvbjtcbmZ1bmN0aW9uIHRvRXhwcmVzc2lvbihub2RlKSB7XG4gIGlmICgoMCwgX2luZGV4LmlzRXhwcmVzc2lvblN0YXRlbWVudCkobm9kZSkpIHtcbiAgICBub2RlID0gbm9kZS5leHByZXNzaW9uO1xuICB9XG4gIGlmICgoMCwgX2luZGV4LmlzRXhwcmVzc2lvbikobm9kZSkpIHtcbiAgICByZXR1cm4gbm9kZTtcbiAgfVxuICBpZiAoKDAsIF9pbmRleC5pc0NsYXNzKShub2RlKSkge1xuICAgIG5vZGUudHlwZSA9IFwiQ2xhc3NFeHByZXNzaW9uXCI7XG4gICAgbm9kZS5hYnN0cmFjdCA9IGZhbHNlO1xuICB9IGVsc2UgaWYgKCgwLCBfaW5kZXguaXNGdW5jdGlvbikobm9kZSkpIHtcbiAgICBub2RlLnR5cGUgPSBcIkZ1bmN0aW9uRXhwcmVzc2lvblwiO1xuICB9XG4gIGlmICghKDAsIF9pbmRleC5pc0V4cHJlc3Npb24pKG5vZGUpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBjYW5ub3QgdHVybiAke25vZGUudHlwZX0gdG8gYW4gZXhwcmVzc2lvbmApO1xuICB9XG4gIHJldHVybiBub2RlO1xufVxuXG4vLyMgc291cmNlTWFwcGluZ1VSTD10b0V4cHJlc3Npb24uanMubWFwXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@babel/types/lib/converters/toExpression.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@babel/types/lib/converters/toIdentifier.js":
/*!******************************************************************!*\
  !*** ./node_modules/@babel/types/lib/converters/toIdentifier.js ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports[\"default\"] = toIdentifier;\nvar _isValidIdentifier = __webpack_require__(/*! ../validators/isValidIdentifier.js */ \"(ssr)/./node_modules/@babel/types/lib/validators/isValidIdentifier.js\");\nvar _helperValidatorIdentifier = __webpack_require__(/*! @babel/helper-validator-identifier */ \"(ssr)/./node_modules/@babel/helper-validator-identifier/lib/index.js\");\nfunction toIdentifier(input) {\n  input = input + \"\";\n  let name = \"\";\n  for (const c of input) {\n    name += (0, _helperValidatorIdentifier.isIdentifierChar)(c.codePointAt(0)) ? c : \"-\";\n  }\n  name = name.replace(/^[-0-9]+/, \"\");\n  name = name.replace(/[-\\s]+(.)?/g, function (match, c) {\n    return c ? c.toUpperCase() : \"\";\n  });\n  if (!(0, _isValidIdentifier.default)(name)) {\n    name = `_${name}`;\n  }\n  return name || \"_\";\n}\n\n//# sourceMappingURL=toIdentifier.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGJhYmVsL3R5cGVzL2xpYi9jb252ZXJ0ZXJzL3RvSWRlbnRpZmllci5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYiw4Q0FBNkM7QUFDN0M7QUFDQSxDQUFDLEVBQUM7QUFDRixrQkFBZTtBQUNmLHlCQUF5QixtQkFBTyxDQUFDLGlIQUFvQztBQUNyRSxpQ0FBaUMsbUJBQU8sQ0FBQyxnSEFBb0M7QUFDN0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsZUFBZSxLQUFLO0FBQ3BCO0FBQ0E7QUFDQTs7QUFFQSIsInNvdXJjZXMiOlsid2VicGFjazovL3JlcG8tdmlzdWFsaXplci8uL25vZGVfbW9kdWxlcy9AYmFiZWwvdHlwZXMvbGliL2NvbnZlcnRlcnMvdG9JZGVudGlmaWVyLmpzPzdjOWQiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLmRlZmF1bHQgPSB0b0lkZW50aWZpZXI7XG52YXIgX2lzVmFsaWRJZGVudGlmaWVyID0gcmVxdWlyZShcIi4uL3ZhbGlkYXRvcnMvaXNWYWxpZElkZW50aWZpZXIuanNcIik7XG52YXIgX2hlbHBlclZhbGlkYXRvcklkZW50aWZpZXIgPSByZXF1aXJlKFwiQGJhYmVsL2hlbHBlci12YWxpZGF0b3ItaWRlbnRpZmllclwiKTtcbmZ1bmN0aW9uIHRvSWRlbnRpZmllcihpbnB1dCkge1xuICBpbnB1dCA9IGlucHV0ICsgXCJcIjtcbiAgbGV0IG5hbWUgPSBcIlwiO1xuICBmb3IgKGNvbnN0IGMgb2YgaW5wdXQpIHtcbiAgICBuYW1lICs9ICgwLCBfaGVscGVyVmFsaWRhdG9ySWRlbnRpZmllci5pc0lkZW50aWZpZXJDaGFyKShjLmNvZGVQb2ludEF0KDApKSA/IGMgOiBcIi1cIjtcbiAgfVxuICBuYW1lID0gbmFtZS5yZXBsYWNlKC9eWy0wLTldKy8sIFwiXCIpO1xuICBuYW1lID0gbmFtZS5yZXBsYWNlKC9bLVxcc10rKC4pPy9nLCBmdW5jdGlvbiAobWF0Y2gsIGMpIHtcbiAgICByZXR1cm4gYyA/IGMudG9VcHBlckNhc2UoKSA6IFwiXCI7XG4gIH0pO1xuICBpZiAoISgwLCBfaXNWYWxpZElkZW50aWZpZXIuZGVmYXVsdCkobmFtZSkpIHtcbiAgICBuYW1lID0gYF8ke25hbWV9YDtcbiAgfVxuICByZXR1cm4gbmFtZSB8fCBcIl9cIjtcbn1cblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dG9JZGVudGlmaWVyLmpzLm1hcFxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@babel/types/lib/converters/toIdentifier.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@babel/types/lib/converters/toKeyAlias.js":
/*!****************************************************************!*\
  !*** ./node_modules/@babel/types/lib/converters/toKeyAlias.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports[\"default\"] = toKeyAlias;\nvar _index = __webpack_require__(/*! ../validators/generated/index.js */ \"(ssr)/./node_modules/@babel/types/lib/validators/generated/index.js\");\nvar _cloneNode = __webpack_require__(/*! ../clone/cloneNode.js */ \"(ssr)/./node_modules/@babel/types/lib/clone/cloneNode.js\");\nvar _removePropertiesDeep = __webpack_require__(/*! ../modifications/removePropertiesDeep.js */ \"(ssr)/./node_modules/@babel/types/lib/modifications/removePropertiesDeep.js\");\nfunction toKeyAlias(node, key = node.key) {\n  let alias;\n  if (node.kind === \"method\") {\n    return toKeyAlias.increment() + \"\";\n  } else if ((0, _index.isIdentifier)(key)) {\n    alias = key.name;\n  } else if ((0, _index.isStringLiteral)(key)) {\n    alias = JSON.stringify(key.value);\n  } else {\n    alias = JSON.stringify((0, _removePropertiesDeep.default)((0, _cloneNode.default)(key)));\n  }\n  if (node.computed) {\n    alias = `[${alias}]`;\n  }\n  if (node.static) {\n    alias = `static:${alias}`;\n  }\n  return alias;\n}\ntoKeyAlias.uid = 0;\ntoKeyAlias.increment = function () {\n  if (toKeyAlias.uid >= Number.MAX_SAFE_INTEGER) {\n    return toKeyAlias.uid = 0;\n  } else {\n    return toKeyAlias.uid++;\n  }\n};\n\n//# sourceMappingURL=toKeyAlias.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGJhYmVsL3R5cGVzL2xpYi9jb252ZXJ0ZXJzL3RvS2V5QWxpYXMuanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWIsOENBQTZDO0FBQzdDO0FBQ0EsQ0FBQyxFQUFDO0FBQ0Ysa0JBQWU7QUFDZixhQUFhLG1CQUFPLENBQUMsNkdBQWtDO0FBQ3ZELGlCQUFpQixtQkFBTyxDQUFDLHVGQUF1QjtBQUNoRCw0QkFBNEIsbUJBQU8sQ0FBQyw2SEFBMEM7QUFDOUU7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQSxJQUFJO0FBQ0o7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLE1BQU07QUFDdEI7QUFDQTtBQUNBLHNCQUFzQixNQUFNO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTs7QUFFQSIsInNvdXJjZXMiOlsid2VicGFjazovL3JlcG8tdmlzdWFsaXplci8uL25vZGVfbW9kdWxlcy9AYmFiZWwvdHlwZXMvbGliL2NvbnZlcnRlcnMvdG9LZXlBbGlhcy5qcz9kZDk4Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5kZWZhdWx0ID0gdG9LZXlBbGlhcztcbnZhciBfaW5kZXggPSByZXF1aXJlKFwiLi4vdmFsaWRhdG9ycy9nZW5lcmF0ZWQvaW5kZXguanNcIik7XG52YXIgX2Nsb25lTm9kZSA9IHJlcXVpcmUoXCIuLi9jbG9uZS9jbG9uZU5vZGUuanNcIik7XG52YXIgX3JlbW92ZVByb3BlcnRpZXNEZWVwID0gcmVxdWlyZShcIi4uL21vZGlmaWNhdGlvbnMvcmVtb3ZlUHJvcGVydGllc0RlZXAuanNcIik7XG5mdW5jdGlvbiB0b0tleUFsaWFzKG5vZGUsIGtleSA9IG5vZGUua2V5KSB7XG4gIGxldCBhbGlhcztcbiAgaWYgKG5vZGUua2luZCA9PT0gXCJtZXRob2RcIikge1xuICAgIHJldHVybiB0b0tleUFsaWFzLmluY3JlbWVudCgpICsgXCJcIjtcbiAgfSBlbHNlIGlmICgoMCwgX2luZGV4LmlzSWRlbnRpZmllcikoa2V5KSkge1xuICAgIGFsaWFzID0ga2V5Lm5hbWU7XG4gIH0gZWxzZSBpZiAoKDAsIF9pbmRleC5pc1N0cmluZ0xpdGVyYWwpKGtleSkpIHtcbiAgICBhbGlhcyA9IEpTT04uc3RyaW5naWZ5KGtleS52YWx1ZSk7XG4gIH0gZWxzZSB7XG4gICAgYWxpYXMgPSBKU09OLnN0cmluZ2lmeSgoMCwgX3JlbW92ZVByb3BlcnRpZXNEZWVwLmRlZmF1bHQpKCgwLCBfY2xvbmVOb2RlLmRlZmF1bHQpKGtleSkpKTtcbiAgfVxuICBpZiAobm9kZS5jb21wdXRlZCkge1xuICAgIGFsaWFzID0gYFske2FsaWFzfV1gO1xuICB9XG4gIGlmIChub2RlLnN0YXRpYykge1xuICAgIGFsaWFzID0gYHN0YXRpYzoke2FsaWFzfWA7XG4gIH1cbiAgcmV0dXJuIGFsaWFzO1xufVxudG9LZXlBbGlhcy51aWQgPSAwO1xudG9LZXlBbGlhcy5pbmNyZW1lbnQgPSBmdW5jdGlvbiAoKSB7XG4gIGlmICh0b0tleUFsaWFzLnVpZCA+PSBOdW1iZXIuTUFYX1NBRkVfSU5URUdFUikge1xuICAgIHJldHVybiB0b0tleUFsaWFzLnVpZCA9IDA7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIHRvS2V5QWxpYXMudWlkKys7XG4gIH1cbn07XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXRvS2V5QWxpYXMuanMubWFwXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@babel/types/lib/converters/toKeyAlias.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@babel/types/lib/converters/toSequenceExpression.js":
/*!**************************************************************************!*\
  !*** ./node_modules/@babel/types/lib/converters/toSequenceExpression.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports[\"default\"] = toSequenceExpression;\nvar _gatherSequenceExpressions = __webpack_require__(/*! ./gatherSequenceExpressions.js */ \"(ssr)/./node_modules/@babel/types/lib/converters/gatherSequenceExpressions.js\");\nfunction toSequenceExpression(nodes, scope) {\n  if (!(nodes != null && nodes.length)) return;\n  const declars = [];\n  const result = (0, _gatherSequenceExpressions.default)(nodes, declars);\n  if (!result) return;\n  for (const declar of declars) {\n    scope.push(declar);\n  }\n  return result;\n}\n\n//# sourceMappingURL=toSequenceExpression.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGJhYmVsL3R5cGVzL2xpYi9jb252ZXJ0ZXJzL3RvU2VxdWVuY2VFeHByZXNzaW9uLmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViLDhDQUE2QztBQUM3QztBQUNBLENBQUMsRUFBQztBQUNGLGtCQUFlO0FBQ2YsaUNBQWlDLG1CQUFPLENBQUMscUhBQWdDO0FBQ3pFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcmVwby12aXN1YWxpemVyLy4vbm9kZV9tb2R1bGVzL0BiYWJlbC90eXBlcy9saWIvY29udmVydGVycy90b1NlcXVlbmNlRXhwcmVzc2lvbi5qcz9kOTc0Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5kZWZhdWx0ID0gdG9TZXF1ZW5jZUV4cHJlc3Npb247XG52YXIgX2dhdGhlclNlcXVlbmNlRXhwcmVzc2lvbnMgPSByZXF1aXJlKFwiLi9nYXRoZXJTZXF1ZW5jZUV4cHJlc3Npb25zLmpzXCIpO1xuZnVuY3Rpb24gdG9TZXF1ZW5jZUV4cHJlc3Npb24obm9kZXMsIHNjb3BlKSB7XG4gIGlmICghKG5vZGVzICE9IG51bGwgJiYgbm9kZXMubGVuZ3RoKSkgcmV0dXJuO1xuICBjb25zdCBkZWNsYXJzID0gW107XG4gIGNvbnN0IHJlc3VsdCA9ICgwLCBfZ2F0aGVyU2VxdWVuY2VFeHByZXNzaW9ucy5kZWZhdWx0KShub2RlcywgZGVjbGFycyk7XG4gIGlmICghcmVzdWx0KSByZXR1cm47XG4gIGZvciAoY29uc3QgZGVjbGFyIG9mIGRlY2xhcnMpIHtcbiAgICBzY29wZS5wdXNoKGRlY2xhcik7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dG9TZXF1ZW5jZUV4cHJlc3Npb24uanMubWFwXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@babel/types/lib/converters/toSequenceExpression.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@babel/types/lib/converters/toStatement.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@babel/types/lib/converters/toStatement.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports[\"default\"] = void 0;\nvar _index = __webpack_require__(/*! ../validators/generated/index.js */ \"(ssr)/./node_modules/@babel/types/lib/validators/generated/index.js\");\nvar _index2 = __webpack_require__(/*! ../builders/generated/index.js */ \"(ssr)/./node_modules/@babel/types/lib/builders/generated/index.js\");\nvar _default = exports[\"default\"] = toStatement;\nfunction toStatement(node, ignore) {\n  if ((0, _index.isStatement)(node)) {\n    return node;\n  }\n  let mustHaveId = false;\n  let newType;\n  if ((0, _index.isClass)(node)) {\n    mustHaveId = true;\n    newType = \"ClassDeclaration\";\n  } else if ((0, _index.isFunction)(node)) {\n    mustHaveId = true;\n    newType = \"FunctionDeclaration\";\n  } else if ((0, _index.isAssignmentExpression)(node)) {\n    return (0, _index2.expressionStatement)(node);\n  }\n  if (mustHaveId && !node.id) {\n    newType = false;\n  }\n  if (!newType) {\n    if (ignore) {\n      return false;\n    } else {\n      throw new Error(`cannot turn ${node.type} to a statement`);\n    }\n  }\n  node.type = newType;\n  return node;\n}\n\n//# sourceMappingURL=toStatement.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGJhYmVsL3R5cGVzL2xpYi9jb252ZXJ0ZXJzL3RvU3RhdGVtZW50LmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViLDhDQUE2QztBQUM3QztBQUNBLENBQUMsRUFBQztBQUNGLGtCQUFlO0FBQ2YsYUFBYSxtQkFBTyxDQUFDLDZHQUFrQztBQUN2RCxjQUFjLG1CQUFPLENBQUMseUdBQWdDO0FBQ3RELGVBQWUsa0JBQWU7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTixxQ0FBcUMsV0FBVztBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcmVwby12aXN1YWxpemVyLy4vbm9kZV9tb2R1bGVzL0BiYWJlbC90eXBlcy9saWIvY29udmVydGVycy90b1N0YXRlbWVudC5qcz9kMDNiIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5kZWZhdWx0ID0gdm9pZCAwO1xudmFyIF9pbmRleCA9IHJlcXVpcmUoXCIuLi92YWxpZGF0b3JzL2dlbmVyYXRlZC9pbmRleC5qc1wiKTtcbnZhciBfaW5kZXgyID0gcmVxdWlyZShcIi4uL2J1aWxkZXJzL2dlbmVyYXRlZC9pbmRleC5qc1wiKTtcbnZhciBfZGVmYXVsdCA9IGV4cG9ydHMuZGVmYXVsdCA9IHRvU3RhdGVtZW50O1xuZnVuY3Rpb24gdG9TdGF0ZW1lbnQobm9kZSwgaWdub3JlKSB7XG4gIGlmICgoMCwgX2luZGV4LmlzU3RhdGVtZW50KShub2RlKSkge1xuICAgIHJldHVybiBub2RlO1xuICB9XG4gIGxldCBtdXN0SGF2ZUlkID0gZmFsc2U7XG4gIGxldCBuZXdUeXBlO1xuICBpZiAoKDAsIF9pbmRleC5pc0NsYXNzKShub2RlKSkge1xuICAgIG11c3RIYXZlSWQgPSB0cnVlO1xuICAgIG5ld1R5cGUgPSBcIkNsYXNzRGVjbGFyYXRpb25cIjtcbiAgfSBlbHNlIGlmICgoMCwgX2luZGV4LmlzRnVuY3Rpb24pKG5vZGUpKSB7XG4gICAgbXVzdEhhdmVJZCA9IHRydWU7XG4gICAgbmV3VHlwZSA9IFwiRnVuY3Rpb25EZWNsYXJhdGlvblwiO1xuICB9IGVsc2UgaWYgKCgwLCBfaW5kZXguaXNBc3NpZ25tZW50RXhwcmVzc2lvbikobm9kZSkpIHtcbiAgICByZXR1cm4gKDAsIF9pbmRleDIuZXhwcmVzc2lvblN0YXRlbWVudCkobm9kZSk7XG4gIH1cbiAgaWYgKG11c3RIYXZlSWQgJiYgIW5vZGUuaWQpIHtcbiAgICBuZXdUeXBlID0gZmFsc2U7XG4gIH1cbiAgaWYgKCFuZXdUeXBlKSB7XG4gICAgaWYgKGlnbm9yZSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYGNhbm5vdCB0dXJuICR7bm9kZS50eXBlfSB0byBhIHN0YXRlbWVudGApO1xuICAgIH1cbiAgfVxuICBub2RlLnR5cGUgPSBuZXdUeXBlO1xuICByZXR1cm4gbm9kZTtcbn1cblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dG9TdGF0ZW1lbnQuanMubWFwXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@babel/types/lib/converters/toStatement.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@babel/types/lib/converters/valueToNode.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@babel/types/lib/converters/valueToNode.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports[\"default\"] = void 0;\nvar _isValidIdentifier = __webpack_require__(/*! ../validators/isValidIdentifier.js */ \"(ssr)/./node_modules/@babel/types/lib/validators/isValidIdentifier.js\");\nvar _index = __webpack_require__(/*! ../builders/generated/index.js */ \"(ssr)/./node_modules/@babel/types/lib/builders/generated/index.js\");\nvar _default = exports[\"default\"] = valueToNode;\nconst objectToString = Function.call.bind(Object.prototype.toString);\nfunction isRegExp(value) {\n  return objectToString(value) === \"[object RegExp]\";\n}\nfunction isPlainObject(value) {\n  if (typeof value !== \"object\" || value === null || Object.prototype.toString.call(value) !== \"[object Object]\") {\n    return false;\n  }\n  const proto = Object.getPrototypeOf(value);\n  return proto === null || Object.getPrototypeOf(proto) === null;\n}\nfunction valueToNode(value) {\n  if (value === undefined) {\n    return (0, _index.identifier)(\"undefined\");\n  }\n  if (value === true || value === false) {\n    return (0, _index.booleanLiteral)(value);\n  }\n  if (value === null) {\n    return (0, _index.nullLiteral)();\n  }\n  if (typeof value === \"string\") {\n    return (0, _index.stringLiteral)(value);\n  }\n  if (typeof value === \"number\") {\n    let result;\n    if (Number.isFinite(value)) {\n      result = (0, _index.numericLiteral)(Math.abs(value));\n    } else {\n      let numerator;\n      if (Number.isNaN(value)) {\n        numerator = (0, _index.numericLiteral)(0);\n      } else {\n        numerator = (0, _index.numericLiteral)(1);\n      }\n      result = (0, _index.binaryExpression)(\"/\", numerator, (0, _index.numericLiteral)(0));\n    }\n    if (value < 0 || Object.is(value, -0)) {\n      result = (0, _index.unaryExpression)(\"-\", result);\n    }\n    return result;\n  }\n  if (typeof value === \"bigint\") {\n    if (value < 0) {\n      return (0, _index.unaryExpression)(\"-\", (0, _index.bigIntLiteral)(-value));\n    } else {\n      return (0, _index.bigIntLiteral)(value);\n    }\n  }\n  if (isRegExp(value)) {\n    const pattern = value.source;\n    const flags = /\\/([a-z]*)$/.exec(value.toString())[1];\n    return (0, _index.regExpLiteral)(pattern, flags);\n  }\n  if (Array.isArray(value)) {\n    return (0, _index.arrayExpression)(value.map(valueToNode));\n  }\n  if (isPlainObject(value)) {\n    const props = [];\n    for (const key of Object.keys(value)) {\n      let nodeKey,\n        computed = false;\n      if ((0, _isValidIdentifier.default)(key)) {\n        if (key === \"__proto__\") {\n          computed = true;\n          nodeKey = (0, _index.stringLiteral)(key);\n        } else {\n          nodeKey = (0, _index.identifier)(key);\n        }\n      } else {\n        nodeKey = (0, _index.stringLiteral)(key);\n      }\n      props.push((0, _index.objectProperty)(nodeKey, valueToNode(value[key]), computed));\n    }\n    return (0, _index.objectExpression)(props);\n  }\n  throw new Error(\"don't know how to turn this value into a node\");\n}\n\n//# sourceMappingURL=valueToNode.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGJhYmVsL3R5cGVzL2xpYi9jb252ZXJ0ZXJzL3ZhbHVlVG9Ob2RlLmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViLDhDQUE2QztBQUM3QztBQUNBLENBQUMsRUFBQztBQUNGLGtCQUFlO0FBQ2YseUJBQXlCLG1CQUFPLENBQUMsaUhBQW9DO0FBQ3JFLGFBQWEsbUJBQU8sQ0FBQyx5R0FBZ0M7QUFDckQsZUFBZSxrQkFBZTtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcmVwby12aXN1YWxpemVyLy4vbm9kZV9tb2R1bGVzL0BiYWJlbC90eXBlcy9saWIvY29udmVydGVycy92YWx1ZVRvTm9kZS5qcz84ZmNjIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5kZWZhdWx0ID0gdm9pZCAwO1xudmFyIF9pc1ZhbGlkSWRlbnRpZmllciA9IHJlcXVpcmUoXCIuLi92YWxpZGF0b3JzL2lzVmFsaWRJZGVudGlmaWVyLmpzXCIpO1xudmFyIF9pbmRleCA9IHJlcXVpcmUoXCIuLi9idWlsZGVycy9nZW5lcmF0ZWQvaW5kZXguanNcIik7XG52YXIgX2RlZmF1bHQgPSBleHBvcnRzLmRlZmF1bHQgPSB2YWx1ZVRvTm9kZTtcbmNvbnN0IG9iamVjdFRvU3RyaW5nID0gRnVuY3Rpb24uY2FsbC5iaW5kKE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcpO1xuZnVuY3Rpb24gaXNSZWdFeHAodmFsdWUpIHtcbiAgcmV0dXJuIG9iamVjdFRvU3RyaW5nKHZhbHVlKSA9PT0gXCJbb2JqZWN0IFJlZ0V4cF1cIjtcbn1cbmZ1bmN0aW9uIGlzUGxhaW5PYmplY3QodmFsdWUpIHtcbiAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gXCJvYmplY3RcIiB8fCB2YWx1ZSA9PT0gbnVsbCB8fCBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodmFsdWUpICE9PSBcIltvYmplY3QgT2JqZWN0XVwiKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGNvbnN0IHByb3RvID0gT2JqZWN0LmdldFByb3RvdHlwZU9mKHZhbHVlKTtcbiAgcmV0dXJuIHByb3RvID09PSBudWxsIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihwcm90bykgPT09IG51bGw7XG59XG5mdW5jdGlvbiB2YWx1ZVRvTm9kZSh2YWx1ZSkge1xuICBpZiAodmFsdWUgPT09IHVuZGVmaW5lZCkge1xuICAgIHJldHVybiAoMCwgX2luZGV4LmlkZW50aWZpZXIpKFwidW5kZWZpbmVkXCIpO1xuICB9XG4gIGlmICh2YWx1ZSA9PT0gdHJ1ZSB8fCB2YWx1ZSA9PT0gZmFsc2UpIHtcbiAgICByZXR1cm4gKDAsIF9pbmRleC5ib29sZWFuTGl0ZXJhbCkodmFsdWUpO1xuICB9XG4gIGlmICh2YWx1ZSA9PT0gbnVsbCkge1xuICAgIHJldHVybiAoMCwgX2luZGV4Lm51bGxMaXRlcmFsKSgpO1xuICB9XG4gIGlmICh0eXBlb2YgdmFsdWUgPT09IFwic3RyaW5nXCIpIHtcbiAgICByZXR1cm4gKDAsIF9pbmRleC5zdHJpbmdMaXRlcmFsKSh2YWx1ZSk7XG4gIH1cbiAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gXCJudW1iZXJcIikge1xuICAgIGxldCByZXN1bHQ7XG4gICAgaWYgKE51bWJlci5pc0Zpbml0ZSh2YWx1ZSkpIHtcbiAgICAgIHJlc3VsdCA9ICgwLCBfaW5kZXgubnVtZXJpY0xpdGVyYWwpKE1hdGguYWJzKHZhbHVlKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGxldCBudW1lcmF0b3I7XG4gICAgICBpZiAoTnVtYmVyLmlzTmFOKHZhbHVlKSkge1xuICAgICAgICBudW1lcmF0b3IgPSAoMCwgX2luZGV4Lm51bWVyaWNMaXRlcmFsKSgwKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG51bWVyYXRvciA9ICgwLCBfaW5kZXgubnVtZXJpY0xpdGVyYWwpKDEpO1xuICAgICAgfVxuICAgICAgcmVzdWx0ID0gKDAsIF9pbmRleC5iaW5hcnlFeHByZXNzaW9uKShcIi9cIiwgbnVtZXJhdG9yLCAoMCwgX2luZGV4Lm51bWVyaWNMaXRlcmFsKSgwKSk7XG4gICAgfVxuICAgIGlmICh2YWx1ZSA8IDAgfHwgT2JqZWN0LmlzKHZhbHVlLCAtMCkpIHtcbiAgICAgIHJlc3VsdCA9ICgwLCBfaW5kZXgudW5hcnlFeHByZXNzaW9uKShcIi1cIiwgcmVzdWx0KTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuICBpZiAodHlwZW9mIHZhbHVlID09PSBcImJpZ2ludFwiKSB7XG4gICAgaWYgKHZhbHVlIDwgMCkge1xuICAgICAgcmV0dXJuICgwLCBfaW5kZXgudW5hcnlFeHByZXNzaW9uKShcIi1cIiwgKDAsIF9pbmRleC5iaWdJbnRMaXRlcmFsKSgtdmFsdWUpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuICgwLCBfaW5kZXguYmlnSW50TGl0ZXJhbCkodmFsdWUpO1xuICAgIH1cbiAgfVxuICBpZiAoaXNSZWdFeHAodmFsdWUpKSB7XG4gICAgY29uc3QgcGF0dGVybiA9IHZhbHVlLnNvdXJjZTtcbiAgICBjb25zdCBmbGFncyA9IC9cXC8oW2Etel0qKSQvLmV4ZWModmFsdWUudG9TdHJpbmcoKSlbMV07XG4gICAgcmV0dXJuICgwLCBfaW5kZXgucmVnRXhwTGl0ZXJhbCkocGF0dGVybiwgZmxhZ3MpO1xuICB9XG4gIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgIHJldHVybiAoMCwgX2luZGV4LmFycmF5RXhwcmVzc2lvbikodmFsdWUubWFwKHZhbHVlVG9Ob2RlKSk7XG4gIH1cbiAgaWYgKGlzUGxhaW5PYmplY3QodmFsdWUpKSB7XG4gICAgY29uc3QgcHJvcHMgPSBbXTtcbiAgICBmb3IgKGNvbnN0IGtleSBvZiBPYmplY3Qua2V5cyh2YWx1ZSkpIHtcbiAgICAgIGxldCBub2RlS2V5LFxuICAgICAgICBjb21wdXRlZCA9IGZhbHNlO1xuICAgICAgaWYgKCgwLCBfaXNWYWxpZElkZW50aWZpZXIuZGVmYXVsdCkoa2V5KSkge1xuICAgICAgICBpZiAoa2V5ID09PSBcIl9fcHJvdG9fX1wiKSB7XG4gICAgICAgICAgY29tcHV0ZWQgPSB0cnVlO1xuICAgICAgICAgIG5vZGVLZXkgPSAoMCwgX2luZGV4LnN0cmluZ0xpdGVyYWwpKGtleSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbm9kZUtleSA9ICgwLCBfaW5kZXguaWRlbnRpZmllcikoa2V5KTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbm9kZUtleSA9ICgwLCBfaW5kZXguc3RyaW5nTGl0ZXJhbCkoa2V5KTtcbiAgICAgIH1cbiAgICAgIHByb3BzLnB1c2goKDAsIF9pbmRleC5vYmplY3RQcm9wZXJ0eSkobm9kZUtleSwgdmFsdWVUb05vZGUodmFsdWVba2V5XSksIGNvbXB1dGVkKSk7XG4gICAgfVxuICAgIHJldHVybiAoMCwgX2luZGV4Lm9iamVjdEV4cHJlc3Npb24pKHByb3BzKTtcbiAgfVxuICB0aHJvdyBuZXcgRXJyb3IoXCJkb24ndCBrbm93IGhvdyB0byB0dXJuIHRoaXMgdmFsdWUgaW50byBhIG5vZGVcIik7XG59XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXZhbHVlVG9Ob2RlLmpzLm1hcFxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@babel/types/lib/converters/valueToNode.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@babel/types/lib/definitions/core.js":
/*!***********************************************************!*\
  !*** ./node_modules/@babel/types/lib/definitions/core.js ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports.patternLikeCommon = exports.importAttributes = exports.functionTypeAnnotationCommon = exports.functionDeclarationCommon = exports.functionCommon = exports.classMethodOrPropertyUnionShapeCommon = exports.classMethodOrPropertyCommon = exports.classMethodOrDeclareMethodCommon = void 0;\nvar _is = __webpack_require__(/*! ../validators/is.js */ \"(ssr)/./node_modules/@babel/types/lib/validators/is.js\");\nvar _isValidIdentifier = __webpack_require__(/*! ../validators/isValidIdentifier.js */ \"(ssr)/./node_modules/@babel/types/lib/validators/isValidIdentifier.js\");\nvar _helperValidatorIdentifier = __webpack_require__(/*! @babel/helper-validator-identifier */ \"(ssr)/./node_modules/@babel/helper-validator-identifier/lib/index.js\");\nvar _helperStringParser = __webpack_require__(/*! @babel/helper-string-parser */ \"(ssr)/./node_modules/@babel/helper-string-parser/lib/index.js\");\nvar _index = __webpack_require__(/*! ../constants/index.js */ \"(ssr)/./node_modules/@babel/types/lib/constants/index.js\");\nvar _utils = __webpack_require__(/*! ./utils.js */ \"(ssr)/./node_modules/@babel/types/lib/definitions/utils.js\");\nconst classMethodOrPropertyUnionShapeCommon = (allowPrivateName = false) => ({\n  unionShape: {\n    discriminator: \"computed\",\n    shapes: [{\n      name: \"computed\",\n      value: [true],\n      properties: {\n        key: {\n          validate: (0, _utils.assertNodeType)(\"Expression\")\n        }\n      }\n    }, {\n      name: \"nonComputed\",\n      value: [false],\n      properties: {\n        key: {\n          validate: allowPrivateName ? (0, _utils.assertNodeType)(\"Identifier\", \"StringLiteral\", \"NumericLiteral\", \"BigIntLiteral\", \"PrivateName\") : (0, _utils.assertNodeType)(\"Identifier\", \"StringLiteral\", \"NumericLiteral\", \"BigIntLiteral\")\n        }\n      }\n    }]\n  }\n});\nexports.classMethodOrPropertyUnionShapeCommon = classMethodOrPropertyUnionShapeCommon;\nconst defineType = (0, _utils.defineAliasedType)(\"Standardized\");\ndefineType(\"ArrayExpression\", {\n  fields: {\n    elements: {\n      validate: (0, _utils.arrayOf)((0, _utils.assertNodeOrValueType)(\"null\", \"Expression\", \"SpreadElement\")),\n      default: !process.env.BABEL_TYPES_8_BREAKING ? [] : undefined\n    }\n  },\n  visitor: [\"elements\"],\n  aliases: [\"Expression\"]\n});\ndefineType(\"AssignmentExpression\", {\n  fields: {\n    operator: {\n      validate: !process.env.BABEL_TYPES_8_BREAKING ? (0, _utils.assertValueType)(\"string\") : Object.assign(function () {\n        const identifier = (0, _utils.assertOneOf)(..._index.ASSIGNMENT_OPERATORS);\n        const pattern = (0, _utils.assertOneOf)(\"=\");\n        return function (node, key, val) {\n          const validator = (0, _is.default)(\"Pattern\", node.left) ? pattern : identifier;\n          validator(node, key, val);\n        };\n      }(), {\n        oneOf: _index.ASSIGNMENT_OPERATORS\n      })\n    },\n    left: {\n      validate: !process.env.BABEL_TYPES_8_BREAKING ? (0, _utils.assertNodeType)(\"LVal\", \"OptionalMemberExpression\") : (0, _utils.assertNodeType)(\"Identifier\", \"MemberExpression\", \"OptionalMemberExpression\", \"ArrayPattern\", \"ObjectPattern\", \"TSAsExpression\", \"TSSatisfiesExpression\", \"TSTypeAssertion\", \"TSNonNullExpression\")\n    },\n    right: {\n      validate: (0, _utils.assertNodeType)(\"Expression\")\n    }\n  },\n  builder: [\"operator\", \"left\", \"right\"],\n  visitor: [\"left\", \"right\"],\n  aliases: [\"Expression\"]\n});\ndefineType(\"BinaryExpression\", {\n  builder: [\"operator\", \"left\", \"right\"],\n  fields: {\n    operator: {\n      validate: (0, _utils.assertOneOf)(..._index.BINARY_OPERATORS)\n    },\n    left: {\n      validate: function () {\n        const expression = (0, _utils.assertNodeType)(\"Expression\");\n        const inOp = (0, _utils.assertNodeType)(\"Expression\", \"PrivateName\");\n        const validator = Object.assign(function (node, key, val) {\n          const validator = node.operator === \"in\" ? inOp : expression;\n          validator(node, key, val);\n        }, {\n          oneOfNodeTypes: [\"Expression\", \"PrivateName\"]\n        });\n        return validator;\n      }()\n    },\n    right: {\n      validate: (0, _utils.assertNodeType)(\"Expression\")\n    }\n  },\n  visitor: [\"left\", \"right\"],\n  aliases: [\"Binary\", \"Expression\"]\n});\ndefineType(\"InterpreterDirective\", {\n  builder: [\"value\"],\n  fields: {\n    value: {\n      validate: (0, _utils.assertValueType)(\"string\")\n    }\n  }\n});\ndefineType(\"Directive\", {\n  visitor: [\"value\"],\n  fields: {\n    value: {\n      validate: (0, _utils.assertNodeType)(\"DirectiveLiteral\")\n    }\n  }\n});\ndefineType(\"DirectiveLiteral\", {\n  builder: [\"value\"],\n  fields: {\n    value: {\n      validate: (0, _utils.assertValueType)(\"string\")\n    }\n  }\n});\ndefineType(\"BlockStatement\", {\n  builder: [\"body\", \"directives\"],\n  visitor: [\"directives\", \"body\"],\n  fields: {\n    directives: {\n      validate: (0, _utils.arrayOfType)(\"Directive\"),\n      default: []\n    },\n    body: (0, _utils.validateArrayOfType)(\"Statement\")\n  },\n  aliases: [\"Scopable\", \"BlockParent\", \"Block\", \"Statement\"]\n});\ndefineType(\"BreakStatement\", {\n  visitor: [\"label\"],\n  fields: {\n    label: {\n      validate: (0, _utils.assertNodeType)(\"Identifier\"),\n      optional: true\n    }\n  },\n  aliases: [\"Statement\", \"Terminatorless\", \"CompletionStatement\"]\n});\ndefineType(\"CallExpression\", {\n  visitor: [\"callee\", \"typeParameters\", \"typeArguments\", \"arguments\"],\n  builder: [\"callee\", \"arguments\"],\n  aliases: [\"Expression\"],\n  fields: Object.assign({\n    callee: {\n      validate: (0, _utils.assertNodeType)(\"Expression\", \"Super\", \"V8IntrinsicIdentifier\")\n    },\n    arguments: (0, _utils.validateArrayOfType)(\"Expression\", \"SpreadElement\", \"ArgumentPlaceholder\"),\n    typeArguments: {\n      validate: (0, _utils.assertNodeType)(\"TypeParameterInstantiation\"),\n      optional: true\n    }\n  }, process.env.BABEL_TYPES_8_BREAKING ? {} : {\n    optional: {\n      validate: (0, _utils.assertValueType)(\"boolean\"),\n      optional: true\n    },\n    typeParameters: {\n      validate: (0, _utils.assertNodeType)(\"TSTypeParameterInstantiation\"),\n      optional: true\n    }\n  })\n});\ndefineType(\"CatchClause\", {\n  visitor: [\"param\", \"body\"],\n  fields: {\n    param: {\n      validate: (0, _utils.assertNodeType)(\"Identifier\", \"ArrayPattern\", \"ObjectPattern\"),\n      optional: true\n    },\n    body: {\n      validate: (0, _utils.assertNodeType)(\"BlockStatement\")\n    }\n  },\n  aliases: [\"Scopable\", \"BlockParent\"]\n});\ndefineType(\"ConditionalExpression\", {\n  visitor: [\"test\", \"consequent\", \"alternate\"],\n  fields: {\n    test: {\n      validate: (0, _utils.assertNodeType)(\"Expression\")\n    },\n    consequent: {\n      validate: (0, _utils.assertNodeType)(\"Expression\")\n    },\n    alternate: {\n      validate: (0, _utils.assertNodeType)(\"Expression\")\n    }\n  },\n  aliases: [\"Expression\", \"Conditional\"]\n});\ndefineType(\"ContinueStatement\", {\n  visitor: [\"label\"],\n  fields: {\n    label: {\n      validate: (0, _utils.assertNodeType)(\"Identifier\"),\n      optional: true\n    }\n  },\n  aliases: [\"Statement\", \"Terminatorless\", \"CompletionStatement\"]\n});\ndefineType(\"DebuggerStatement\", {\n  aliases: [\"Statement\"]\n});\ndefineType(\"DoWhileStatement\", {\n  builder: [\"test\", \"body\"],\n  visitor: [\"body\", \"test\"],\n  fields: {\n    test: {\n      validate: (0, _utils.assertNodeType)(\"Expression\")\n    },\n    body: {\n      validate: (0, _utils.assertNodeType)(\"Statement\")\n    }\n  },\n  aliases: [\"Statement\", \"BlockParent\", \"Loop\", \"While\", \"Scopable\"]\n});\ndefineType(\"EmptyStatement\", {\n  aliases: [\"Statement\"]\n});\ndefineType(\"ExpressionStatement\", {\n  visitor: [\"expression\"],\n  fields: {\n    expression: {\n      validate: (0, _utils.assertNodeType)(\"Expression\")\n    }\n  },\n  aliases: [\"Statement\", \"ExpressionWrapper\"]\n});\ndefineType(\"File\", {\n  builder: [\"program\", \"comments\", \"tokens\"],\n  visitor: [\"program\"],\n  fields: {\n    program: {\n      validate: (0, _utils.assertNodeType)(\"Program\")\n    },\n    comments: {\n      validate: !process.env.BABEL_TYPES_8_BREAKING ? Object.assign(() => {}, {\n        each: {\n          oneOfNodeTypes: [\"CommentBlock\", \"CommentLine\"]\n        }\n      }) : (0, _utils.assertEach)((0, _utils.assertNodeType)(\"CommentBlock\", \"CommentLine\")),\n      optional: true\n    },\n    tokens: {\n      validate: (0, _utils.assertEach)(Object.assign(() => {}, {\n        type: \"any\"\n      })),\n      optional: true\n    }\n  }\n});\ndefineType(\"ForInStatement\", {\n  visitor: [\"left\", \"right\", \"body\"],\n  aliases: [\"Scopable\", \"Statement\", \"For\", \"BlockParent\", \"Loop\", \"ForXStatement\"],\n  fields: {\n    left: {\n      validate: !process.env.BABEL_TYPES_8_BREAKING ? (0, _utils.assertNodeType)(\"VariableDeclaration\", \"LVal\") : (0, _utils.assertNodeType)(\"VariableDeclaration\", \"Identifier\", \"MemberExpression\", \"ArrayPattern\", \"ObjectPattern\", \"TSAsExpression\", \"TSSatisfiesExpression\", \"TSTypeAssertion\", \"TSNonNullExpression\")\n    },\n    right: {\n      validate: (0, _utils.assertNodeType)(\"Expression\")\n    },\n    body: {\n      validate: (0, _utils.assertNodeType)(\"Statement\")\n    }\n  }\n});\ndefineType(\"ForStatement\", {\n  visitor: [\"init\", \"test\", \"update\", \"body\"],\n  aliases: [\"Scopable\", \"Statement\", \"For\", \"BlockParent\", \"Loop\"],\n  fields: {\n    init: {\n      validate: (0, _utils.assertNodeType)(\"VariableDeclaration\", \"Expression\"),\n      optional: true\n    },\n    test: {\n      validate: (0, _utils.assertNodeType)(\"Expression\"),\n      optional: true\n    },\n    update: {\n      validate: (0, _utils.assertNodeType)(\"Expression\"),\n      optional: true\n    },\n    body: {\n      validate: (0, _utils.assertNodeType)(\"Statement\")\n    }\n  }\n});\nconst functionCommon = () => ({\n  params: (0, _utils.validateArrayOfType)(\"FunctionParameter\"),\n  generator: {\n    default: false\n  },\n  async: {\n    default: false\n  }\n});\nexports.functionCommon = functionCommon;\nconst functionTypeAnnotationCommon = () => ({\n  returnType: {\n    validate: (0, _utils.assertNodeType)(\"TypeAnnotation\", \"TSTypeAnnotation\", \"Noop\"),\n    optional: true\n  },\n  typeParameters: {\n    validate: (0, _utils.assertNodeType)(\"TypeParameterDeclaration\", \"TSTypeParameterDeclaration\", \"Noop\"),\n    optional: true\n  }\n});\nexports.functionTypeAnnotationCommon = functionTypeAnnotationCommon;\nconst functionDeclarationCommon = () => Object.assign({}, functionCommon(), {\n  declare: {\n    validate: (0, _utils.assertValueType)(\"boolean\"),\n    optional: true\n  },\n  id: {\n    validate: (0, _utils.assertNodeType)(\"Identifier\"),\n    optional: true\n  }\n});\nexports.functionDeclarationCommon = functionDeclarationCommon;\ndefineType(\"FunctionDeclaration\", {\n  builder: [\"id\", \"params\", \"body\", \"generator\", \"async\"],\n  visitor: [\"id\", \"typeParameters\", \"params\", \"predicate\", \"returnType\", \"body\"],\n  fields: Object.assign({}, functionDeclarationCommon(), functionTypeAnnotationCommon(), {\n    body: {\n      validate: (0, _utils.assertNodeType)(\"BlockStatement\")\n    },\n    predicate: {\n      validate: (0, _utils.assertNodeType)(\"DeclaredPredicate\", \"InferredPredicate\"),\n      optional: true\n    }\n  }),\n  aliases: [\"Scopable\", \"Function\", \"BlockParent\", \"FunctionParent\", \"Statement\", \"Pureish\", \"Declaration\"],\n  validate: !process.env.BABEL_TYPES_8_BREAKING ? undefined : function () {\n    const identifier = (0, _utils.assertNodeType)(\"Identifier\");\n    return function (parent, key, node) {\n      if (!(0, _is.default)(\"ExportDefaultDeclaration\", parent)) {\n        identifier(node, \"id\", node.id);\n      }\n    };\n  }()\n});\ndefineType(\"FunctionExpression\", {\n  inherits: \"FunctionDeclaration\",\n  aliases: [\"Scopable\", \"Function\", \"BlockParent\", \"FunctionParent\", \"Expression\", \"Pureish\"],\n  fields: Object.assign({}, functionCommon(), functionTypeAnnotationCommon(), {\n    id: {\n      validate: (0, _utils.assertNodeType)(\"Identifier\"),\n      optional: true\n    },\n    body: {\n      validate: (0, _utils.assertNodeType)(\"BlockStatement\")\n    },\n    predicate: {\n      validate: (0, _utils.assertNodeType)(\"DeclaredPredicate\", \"InferredPredicate\"),\n      optional: true\n    }\n  })\n});\nconst patternLikeCommon = () => ({\n  typeAnnotation: {\n    validate: (0, _utils.assertNodeType)(\"TypeAnnotation\", \"TSTypeAnnotation\", \"Noop\"),\n    optional: true\n  },\n  optional: {\n    validate: (0, _utils.assertValueType)(\"boolean\"),\n    optional: true\n  },\n  decorators: {\n    validate: (0, _utils.arrayOfType)(\"Decorator\"),\n    optional: true\n  }\n});\nexports.patternLikeCommon = patternLikeCommon;\ndefineType(\"Identifier\", {\n  builder: [\"name\"],\n  visitor: [\"typeAnnotation\", \"decorators\"],\n  aliases: [\"Expression\", \"FunctionParameter\", \"PatternLike\", \"LVal\", \"TSEntityName\"],\n  fields: Object.assign({}, patternLikeCommon(), {\n    name: {\n      validate: process.env.BABEL_TYPES_8_BREAKING ? (0, _utils.chain)((0, _utils.assertValueType)(\"string\"), Object.assign(function (node, key, val) {\n        if (!(0, _isValidIdentifier.default)(val, false)) {\n          throw new TypeError(`\"${val}\" is not a valid identifier name`);\n        }\n      }, {\n        type: \"string\"\n      })) : (0, _utils.assertValueType)(\"string\")\n    }\n  }),\n  validate: process.env.BABEL_TYPES_8_BREAKING ? function (parent, key, node) {\n    const match = /\\.(\\w+)$/.exec(key.toString());\n    if (!match) return;\n    const [, parentKey] = match;\n    const nonComp = {\n      computed: false\n    };\n    if (parentKey === \"property\") {\n      if ((0, _is.default)(\"MemberExpression\", parent, nonComp)) return;\n      if ((0, _is.default)(\"OptionalMemberExpression\", parent, nonComp)) return;\n    } else if (parentKey === \"key\") {\n      if ((0, _is.default)(\"Property\", parent, nonComp)) return;\n      if ((0, _is.default)(\"Method\", parent, nonComp)) return;\n    } else if (parentKey === \"exported\") {\n      if ((0, _is.default)(\"ExportSpecifier\", parent)) return;\n    } else if (parentKey === \"imported\") {\n      if ((0, _is.default)(\"ImportSpecifier\", parent, {\n        imported: node\n      })) return;\n    } else if (parentKey === \"meta\") {\n      if ((0, _is.default)(\"MetaProperty\", parent, {\n        meta: node\n      })) return;\n    }\n    if (((0, _helperValidatorIdentifier.isKeyword)(node.name) || (0, _helperValidatorIdentifier.isReservedWord)(node.name, false)) && node.name !== \"this\") {\n      throw new TypeError(`\"${node.name}\" is not a valid identifier`);\n    }\n  } : undefined\n});\ndefineType(\"IfStatement\", {\n  visitor: [\"test\", \"consequent\", \"alternate\"],\n  aliases: [\"Statement\", \"Conditional\"],\n  fields: {\n    test: {\n      validate: (0, _utils.assertNodeType)(\"Expression\")\n    },\n    consequent: {\n      validate: (0, _utils.assertNodeType)(\"Statement\")\n    },\n    alternate: {\n      optional: true,\n      validate: (0, _utils.assertNodeType)(\"Statement\")\n    }\n  }\n});\ndefineType(\"LabeledStatement\", {\n  visitor: [\"label\", \"body\"],\n  aliases: [\"Statement\"],\n  fields: {\n    label: {\n      validate: (0, _utils.assertNodeType)(\"Identifier\")\n    },\n    body: {\n      validate: (0, _utils.assertNodeType)(\"Statement\")\n    }\n  }\n});\ndefineType(\"StringLiteral\", {\n  builder: [\"value\"],\n  fields: {\n    value: {\n      validate: (0, _utils.assertValueType)(\"string\")\n    }\n  },\n  aliases: [\"Expression\", \"Pureish\", \"Literal\", \"Immutable\"]\n});\ndefineType(\"NumericLiteral\", {\n  builder: [\"value\"],\n  deprecatedAlias: \"NumberLiteral\",\n  fields: {\n    value: {\n      validate: (0, _utils.chain)((0, _utils.assertValueType)(\"number\"), Object.assign(function (node, key, val) {\n        if (1 / val < 0 || !Number.isFinite(val)) {\n          const error = new Error(\"NumericLiterals must be non-negative finite numbers. \" + `You can use t.valueToNode(${val}) instead.`);\n        }\n      }, {\n        type: \"number\"\n      }))\n    }\n  },\n  aliases: [\"Expression\", \"Pureish\", \"Literal\", \"Immutable\"]\n});\ndefineType(\"NullLiteral\", {\n  aliases: [\"Expression\", \"Pureish\", \"Literal\", \"Immutable\"]\n});\ndefineType(\"BooleanLiteral\", {\n  builder: [\"value\"],\n  fields: {\n    value: {\n      validate: (0, _utils.assertValueType)(\"boolean\")\n    }\n  },\n  aliases: [\"Expression\", \"Pureish\", \"Literal\", \"Immutable\"]\n});\ndefineType(\"RegExpLiteral\", {\n  builder: [\"pattern\", \"flags\"],\n  deprecatedAlias: \"RegexLiteral\",\n  aliases: [\"Expression\", \"Pureish\", \"Literal\"],\n  fields: {\n    pattern: {\n      validate: (0, _utils.assertValueType)(\"string\")\n    },\n    flags: {\n      validate: process.env.BABEL_TYPES_8_BREAKING ? (0, _utils.chain)((0, _utils.assertValueType)(\"string\"), Object.assign(function (node, key, val) {\n        const invalid = /[^dgimsuvy]/.exec(val);\n        if (invalid) {\n          throw new TypeError(`\"${invalid[0]}\" is not a valid RegExp flag`);\n        }\n      }, {\n        type: \"string\"\n      })) : (0, _utils.assertValueType)(\"string\"),\n      default: \"\"\n    }\n  }\n});\ndefineType(\"LogicalExpression\", {\n  builder: [\"operator\", \"left\", \"right\"],\n  visitor: [\"left\", \"right\"],\n  aliases: [\"Binary\", \"Expression\"],\n  fields: {\n    operator: {\n      validate: (0, _utils.assertOneOf)(..._index.LOGICAL_OPERATORS)\n    },\n    left: {\n      validate: (0, _utils.assertNodeType)(\"Expression\")\n    },\n    right: {\n      validate: (0, _utils.assertNodeType)(\"Expression\")\n    }\n  }\n});\ndefineType(\"MemberExpression\", {\n  builder: [\"object\", \"property\", \"computed\", ...(!process.env.BABEL_TYPES_8_BREAKING ? [\"optional\"] : [])],\n  visitor: [\"object\", \"property\"],\n  aliases: [\"Expression\", \"LVal\", \"PatternLike\"],\n  unionShape: {\n    discriminator: \"computed\",\n    shapes: [{\n      name: \"computed\",\n      value: [true],\n      properties: {\n        property: {\n          validate: (0, _utils.assertNodeType)(\"Expression\")\n        }\n      }\n    }, {\n      name: \"nonComputed\",\n      value: [false],\n      properties: {\n        property: {\n          validate: (0, _utils.assertNodeType)(\"Identifier\", \"PrivateName\")\n        }\n      }\n    }]\n  },\n  fields: Object.assign({\n    object: {\n      validate: (0, _utils.assertNodeType)(\"Expression\", \"Super\")\n    },\n    property: {\n      validate: function () {\n        const normal = (0, _utils.assertNodeType)(\"Identifier\", \"PrivateName\");\n        const computed = (0, _utils.assertNodeType)(\"Expression\");\n        const validator = function (node, key, val) {\n          const validator = node.computed ? computed : normal;\n          validator(node, key, val);\n        };\n        validator.oneOfNodeTypes = [\"Expression\", \"Identifier\", \"PrivateName\"];\n        return validator;\n      }()\n    },\n    computed: {\n      default: false\n    }\n  }, !process.env.BABEL_TYPES_8_BREAKING ? {\n    optional: {\n      validate: (0, _utils.assertValueType)(\"boolean\"),\n      optional: true\n    }\n  } : {})\n});\ndefineType(\"NewExpression\", {\n  inherits: \"CallExpression\"\n});\ndefineType(\"Program\", {\n  visitor: [\"directives\", \"body\"],\n  builder: [\"body\", \"directives\", \"sourceType\", \"interpreter\"],\n  fields: {\n    sourceType: {\n      validate: (0, _utils.assertOneOf)(\"script\", \"module\"),\n      default: \"script\"\n    },\n    interpreter: {\n      validate: (0, _utils.assertNodeType)(\"InterpreterDirective\"),\n      default: null,\n      optional: true\n    },\n    directives: {\n      validate: (0, _utils.arrayOfType)(\"Directive\"),\n      default: []\n    },\n    body: (0, _utils.validateArrayOfType)(\"Statement\")\n  },\n  aliases: [\"Scopable\", \"BlockParent\", \"Block\"]\n});\ndefineType(\"ObjectExpression\", {\n  visitor: [\"properties\"],\n  aliases: [\"Expression\"],\n  fields: {\n    properties: (0, _utils.validateArrayOfType)(\"ObjectMethod\", \"ObjectProperty\", \"SpreadElement\")\n  }\n});\ndefineType(\"ObjectMethod\", Object.assign({\n  builder: [\"kind\", \"key\", \"params\", \"body\", \"computed\", \"generator\", \"async\"],\n  visitor: [\"decorators\", \"key\", \"typeParameters\", \"params\", \"returnType\", \"body\"]\n}, classMethodOrPropertyUnionShapeCommon(), {\n  fields: Object.assign({}, functionCommon(), functionTypeAnnotationCommon(), {\n    kind: Object.assign({\n      validate: (0, _utils.assertOneOf)(\"method\", \"get\", \"set\")\n    }, !process.env.BABEL_TYPES_8_BREAKING ? {\n      default: \"method\"\n    } : {}),\n    computed: {\n      default: false\n    },\n    key: {\n      validate: function () {\n        const normal = (0, _utils.assertNodeType)(\"Identifier\", \"StringLiteral\", \"NumericLiteral\", \"BigIntLiteral\");\n        const computed = (0, _utils.assertNodeType)(\"Expression\");\n        const validator = function (node, key, val) {\n          const validator = node.computed ? computed : normal;\n          validator(node, key, val);\n        };\n        validator.oneOfNodeTypes = [\"Expression\", \"Identifier\", \"StringLiteral\", \"NumericLiteral\", \"BigIntLiteral\"];\n        return validator;\n      }()\n    },\n    decorators: {\n      validate: (0, _utils.arrayOfType)(\"Decorator\"),\n      optional: true\n    },\n    body: {\n      validate: (0, _utils.assertNodeType)(\"BlockStatement\")\n    }\n  }),\n  aliases: [\"UserWhitespacable\", \"Function\", \"Scopable\", \"BlockParent\", \"FunctionParent\", \"Method\", \"ObjectMember\"]\n}));\ndefineType(\"ObjectProperty\", {\n  builder: [\"key\", \"value\", \"computed\", \"shorthand\", ...(!process.env.BABEL_TYPES_8_BREAKING ? [\"decorators\"] : [])],\n  unionShape: {\n    discriminator: \"computed\",\n    shapes: [{\n      name: \"computed\",\n      value: [true],\n      properties: {\n        key: {\n          validate: (0, _utils.assertNodeType)(\"Expression\")\n        }\n      }\n    }, {\n      name: \"nonComputed\",\n      value: [false],\n      properties: {\n        key: {\n          validate: (0, _utils.assertNodeType)(\"Identifier\", \"StringLiteral\", \"NumericLiteral\", \"BigIntLiteral\", \"DecimalLiteral\", \"PrivateName\")\n        }\n      }\n    }]\n  },\n  fields: {\n    computed: {\n      default: false\n    },\n    key: {\n      validate: function () {\n        const normal = (0, _utils.assertNodeType)(\"Identifier\", \"StringLiteral\", \"NumericLiteral\", \"BigIntLiteral\", \"DecimalLiteral\", \"PrivateName\");\n        const computed = (0, _utils.assertNodeType)(\"Expression\");\n        const validator = Object.assign(function (node, key, val) {\n          const validator = node.computed ? computed : normal;\n          validator(node, key, val);\n        }, {\n          oneOfNodeTypes: [\"Expression\", \"Identifier\", \"StringLiteral\", \"NumericLiteral\", \"BigIntLiteral\", \"DecimalLiteral\", \"PrivateName\"]\n        });\n        return validator;\n      }()\n    },\n    value: {\n      validate: (0, _utils.assertNodeType)(\"Expression\", \"PatternLike\")\n    },\n    shorthand: {\n      validate: process.env.BABEL_TYPES_8_BREAKING ? (0, _utils.chain)((0, _utils.assertValueType)(\"boolean\"), Object.assign(function (node, key, shorthand) {\n        if (!shorthand) return;\n        if (node.computed) {\n          throw new TypeError(\"Property shorthand of ObjectProperty cannot be true if computed is true\");\n        }\n        if (!(0, _is.default)(\"Identifier\", node.key)) {\n          throw new TypeError(\"Property shorthand of ObjectProperty cannot be true if key is not an Identifier\");\n        }\n      }, {\n        type: \"boolean\"\n      })) : (0, _utils.assertValueType)(\"boolean\"),\n      default: false\n    },\n    decorators: {\n      validate: (0, _utils.arrayOfType)(\"Decorator\"),\n      optional: true\n    }\n  },\n  visitor: [\"decorators\", \"key\", \"value\"],\n  aliases: [\"UserWhitespacable\", \"Property\", \"ObjectMember\"],\n  validate: !process.env.BABEL_TYPES_8_BREAKING ? undefined : function () {\n    const pattern = (0, _utils.assertNodeType)(\"Identifier\", \"Pattern\", \"TSAsExpression\", \"TSSatisfiesExpression\", \"TSNonNullExpression\", \"TSTypeAssertion\");\n    const expression = (0, _utils.assertNodeType)(\"Expression\");\n    return function (parent, key, node) {\n      const validator = (0, _is.default)(\"ObjectPattern\", parent) ? pattern : expression;\n      validator(node, \"value\", node.value);\n    };\n  }()\n});\ndefineType(\"RestElement\", {\n  visitor: [\"argument\", \"typeAnnotation\"],\n  builder: [\"argument\"],\n  aliases: [\"FunctionParameter\", \"PatternLike\", \"LVal\"],\n  deprecatedAlias: \"RestProperty\",\n  fields: Object.assign({}, patternLikeCommon(), {\n    argument: {\n      validate: !process.env.BABEL_TYPES_8_BREAKING ? (0, _utils.assertNodeType)(\"Identifier\", \"ArrayPattern\", \"ObjectPattern\", \"MemberExpression\", \"TSAsExpression\", \"TSSatisfiesExpression\", \"TSTypeAssertion\", \"TSNonNullExpression\", \"RestElement\", \"AssignmentPattern\") : (0, _utils.assertNodeType)(\"Identifier\", \"ArrayPattern\", \"ObjectPattern\", \"MemberExpression\", \"TSAsExpression\", \"TSSatisfiesExpression\", \"TSTypeAssertion\", \"TSNonNullExpression\")\n    }\n  }),\n  validate: process.env.BABEL_TYPES_8_BREAKING ? function (parent, key) {\n    const match = /(\\w+)\\[(\\d+)\\]/.exec(key.toString());\n    if (!match) throw new Error(\"Internal Babel error: malformed key.\");\n    const [, listKey, index] = match;\n    if (parent[listKey].length > +index + 1) {\n      throw new TypeError(`RestElement must be last element of ${listKey}`);\n    }\n  } : undefined\n});\ndefineType(\"ReturnStatement\", {\n  visitor: [\"argument\"],\n  aliases: [\"Statement\", \"Terminatorless\", \"CompletionStatement\"],\n  fields: {\n    argument: {\n      validate: (0, _utils.assertNodeType)(\"Expression\"),\n      optional: true\n    }\n  }\n});\ndefineType(\"SequenceExpression\", {\n  visitor: [\"expressions\"],\n  fields: {\n    expressions: (0, _utils.validateArrayOfType)(\"Expression\")\n  },\n  aliases: [\"Expression\"]\n});\ndefineType(\"ParenthesizedExpression\", {\n  visitor: [\"expression\"],\n  aliases: [\"Expression\", \"ExpressionWrapper\"],\n  fields: {\n    expression: {\n      validate: (0, _utils.assertNodeType)(\"Expression\")\n    }\n  }\n});\ndefineType(\"SwitchCase\", {\n  visitor: [\"test\", \"consequent\"],\n  fields: {\n    test: {\n      validate: (0, _utils.assertNodeType)(\"Expression\"),\n      optional: true\n    },\n    consequent: (0, _utils.validateArrayOfType)(\"Statement\")\n  }\n});\ndefineType(\"SwitchStatement\", {\n  visitor: [\"discriminant\", \"cases\"],\n  aliases: [\"Statement\", \"BlockParent\", \"Scopable\"],\n  fields: {\n    discriminant: {\n      validate: (0, _utils.assertNodeType)(\"Expression\")\n    },\n    cases: (0, _utils.validateArrayOfType)(\"SwitchCase\")\n  }\n});\ndefineType(\"ThisExpression\", {\n  aliases: [\"Expression\"]\n});\ndefineType(\"ThrowStatement\", {\n  visitor: [\"argument\"],\n  aliases: [\"Statement\", \"Terminatorless\", \"CompletionStatement\"],\n  fields: {\n    argument: {\n      validate: (0, _utils.assertNodeType)(\"Expression\")\n    }\n  }\n});\ndefineType(\"TryStatement\", {\n  visitor: [\"block\", \"handler\", \"finalizer\"],\n  aliases: [\"Statement\"],\n  fields: {\n    block: {\n      validate: process.env.BABEL_TYPES_8_BREAKING ? (0, _utils.chain)((0, _utils.assertNodeType)(\"BlockStatement\"), Object.assign(function (node) {\n        if (!node.handler && !node.finalizer) {\n          throw new TypeError(\"TryStatement expects either a handler or finalizer, or both\");\n        }\n      }, {\n        oneOfNodeTypes: [\"BlockStatement\"]\n      })) : (0, _utils.assertNodeType)(\"BlockStatement\")\n    },\n    handler: {\n      optional: true,\n      validate: (0, _utils.assertNodeType)(\"CatchClause\")\n    },\n    finalizer: {\n      optional: true,\n      validate: (0, _utils.assertNodeType)(\"BlockStatement\")\n    }\n  }\n});\ndefineType(\"UnaryExpression\", {\n  builder: [\"operator\", \"argument\", \"prefix\"],\n  fields: {\n    prefix: {\n      default: true\n    },\n    argument: {\n      validate: (0, _utils.assertNodeType)(\"Expression\")\n    },\n    operator: {\n      validate: (0, _utils.assertOneOf)(..._index.UNARY_OPERATORS)\n    }\n  },\n  visitor: [\"argument\"],\n  aliases: [\"UnaryLike\", \"Expression\"]\n});\ndefineType(\"UpdateExpression\", {\n  builder: [\"operator\", \"argument\", \"prefix\"],\n  fields: {\n    prefix: {\n      default: false\n    },\n    argument: {\n      validate: !process.env.BABEL_TYPES_8_BREAKING ? (0, _utils.assertNodeType)(\"Expression\") : (0, _utils.assertNodeType)(\"Identifier\", \"MemberExpression\")\n    },\n    operator: {\n      validate: (0, _utils.assertOneOf)(..._index.UPDATE_OPERATORS)\n    }\n  },\n  visitor: [\"argument\"],\n  aliases: [\"Expression\"]\n});\ndefineType(\"VariableDeclaration\", {\n  builder: [\"kind\", \"declarations\"],\n  visitor: [\"declarations\"],\n  aliases: [\"Statement\", \"Declaration\"],\n  fields: {\n    declare: {\n      validate: (0, _utils.assertValueType)(\"boolean\"),\n      optional: true\n    },\n    kind: {\n      validate: (0, _utils.assertOneOf)(\"var\", \"let\", \"const\", \"using\", \"await using\")\n    },\n    declarations: (0, _utils.validateArrayOfType)(\"VariableDeclarator\")\n  },\n  validate: process.env.BABEL_TYPES_8_BREAKING ? (() => {\n    const withoutInit = (0, _utils.assertNodeType)(\"Identifier\", \"Placeholder\");\n    const constOrLetOrVar = (0, _utils.assertNodeType)(\"Identifier\", \"ArrayPattern\", \"ObjectPattern\", \"Placeholder\");\n    const usingOrAwaitUsing = (0, _utils.assertNodeType)(\"Identifier\", \"VoidPattern\", \"Placeholder\");\n    return function (parent, key, node) {\n      const {\n        kind,\n        declarations\n      } = node;\n      const parentIsForX = (0, _is.default)(\"ForXStatement\", parent, {\n        left: node\n      });\n      if (parentIsForX) {\n        if (declarations.length !== 1) {\n          throw new TypeError(`Exactly one VariableDeclarator is required in the VariableDeclaration of a ${parent.type}`);\n        }\n      }\n      for (const decl of declarations) {\n        if (kind === \"const\" || kind === \"let\" || kind === \"var\") {\n          if (!parentIsForX && !decl.init) {\n            withoutInit(decl, \"id\", decl.id);\n          } else {\n            constOrLetOrVar(decl, \"id\", decl.id);\n          }\n        } else {\n          usingOrAwaitUsing(decl, \"id\", decl.id);\n        }\n      }\n    };\n  })() : undefined\n});\ndefineType(\"VariableDeclarator\", {\n  visitor: [\"id\", \"init\"],\n  fields: {\n    id: {\n      validate: !process.env.BABEL_TYPES_8_BREAKING ? (0, _utils.assertNodeType)(\"LVal\", \"VoidPattern\") : (0, _utils.assertNodeType)(\"Identifier\", \"ArrayPattern\", \"ObjectPattern\", \"VoidPattern\")\n    },\n    definite: {\n      optional: true,\n      validate: (0, _utils.assertValueType)(\"boolean\")\n    },\n    init: {\n      optional: true,\n      validate: (0, _utils.assertNodeType)(\"Expression\")\n    }\n  }\n});\ndefineType(\"WhileStatement\", {\n  visitor: [\"test\", \"body\"],\n  aliases: [\"Statement\", \"BlockParent\", \"Loop\", \"While\", \"Scopable\"],\n  fields: {\n    test: {\n      validate: (0, _utils.assertNodeType)(\"Expression\")\n    },\n    body: {\n      validate: (0, _utils.assertNodeType)(\"Statement\")\n    }\n  }\n});\ndefineType(\"WithStatement\", {\n  visitor: [\"object\", \"body\"],\n  aliases: [\"Statement\"],\n  fields: {\n    object: {\n      validate: (0, _utils.assertNodeType)(\"Expression\")\n    },\n    body: {\n      validate: (0, _utils.assertNodeType)(\"Statement\")\n    }\n  }\n});\ndefineType(\"AssignmentPattern\", {\n  visitor: [\"left\", \"right\", \"decorators\"],\n  builder: [\"left\", \"right\"],\n  aliases: [\"FunctionParameter\", \"Pattern\", \"PatternLike\", \"LVal\"],\n  fields: Object.assign({}, patternLikeCommon(), {\n    left: {\n      validate: (0, _utils.assertNodeType)(\"Identifier\", \"ObjectPattern\", \"ArrayPattern\", \"MemberExpression\", \"TSAsExpression\", \"TSSatisfiesExpression\", \"TSTypeAssertion\", \"TSNonNullExpression\")\n    },\n    right: {\n      validate: (0, _utils.assertNodeType)(\"Expression\")\n    },\n    decorators: {\n      validate: (0, _utils.arrayOfType)(\"Decorator\"),\n      optional: true\n    }\n  })\n});\ndefineType(\"ArrayPattern\", {\n  visitor: [\"elements\", \"typeAnnotation\"],\n  builder: [\"elements\"],\n  aliases: [\"FunctionParameter\", \"Pattern\", \"PatternLike\", \"LVal\"],\n  fields: Object.assign({}, patternLikeCommon(), {\n    elements: {\n      validate: (0, _utils.chain)((0, _utils.assertValueType)(\"array\"), (0, _utils.assertEach)((0, _utils.assertNodeOrValueType)(\"null\", \"PatternLike\")))\n    }\n  })\n});\ndefineType(\"ArrowFunctionExpression\", {\n  builder: [\"params\", \"body\", \"async\"],\n  visitor: [\"typeParameters\", \"params\", \"predicate\", \"returnType\", \"body\"],\n  aliases: [\"Scopable\", \"Function\", \"BlockParent\", \"FunctionParent\", \"Expression\", \"Pureish\"],\n  fields: Object.assign({}, functionCommon(), functionTypeAnnotationCommon(), {\n    expression: {\n      validate: (0, _utils.assertValueType)(\"boolean\")\n    },\n    body: {\n      validate: (0, _utils.assertNodeType)(\"BlockStatement\", \"Expression\")\n    },\n    predicate: {\n      validate: (0, _utils.assertNodeType)(\"DeclaredPredicate\", \"InferredPredicate\"),\n      optional: true\n    }\n  })\n});\ndefineType(\"ClassBody\", {\n  visitor: [\"body\"],\n  fields: {\n    body: (0, _utils.validateArrayOfType)(\"ClassMethod\", \"ClassPrivateMethod\", \"ClassProperty\", \"ClassPrivateProperty\", \"ClassAccessorProperty\", \"TSDeclareMethod\", \"TSIndexSignature\", \"StaticBlock\")\n  }\n});\ndefineType(\"ClassExpression\", {\n  builder: [\"id\", \"superClass\", \"body\", \"decorators\"],\n  visitor: [\"decorators\", \"id\", \"typeParameters\", \"superClass\", \"superTypeParameters\", \"mixins\", \"implements\", \"body\"],\n  aliases: [\"Scopable\", \"Class\", \"Expression\"],\n  fields: {\n    id: {\n      validate: (0, _utils.assertNodeType)(\"Identifier\"),\n      optional: true\n    },\n    typeParameters: {\n      validate: (0, _utils.assertNodeType)(\"TypeParameterDeclaration\", \"TSTypeParameterDeclaration\", \"Noop\"),\n      optional: true\n    },\n    body: {\n      validate: (0, _utils.assertNodeType)(\"ClassBody\")\n    },\n    superClass: {\n      optional: true,\n      validate: (0, _utils.assertNodeType)(\"Expression\")\n    },\n    [\"superTypeParameters\"]: {\n      validate: (0, _utils.assertNodeType)(\"TypeParameterInstantiation\", \"TSTypeParameterInstantiation\"),\n      optional: true\n    },\n    implements: {\n      validate: (0, _utils.arrayOfType)(\"TSExpressionWithTypeArguments\", \"ClassImplements\"),\n      optional: true\n    },\n    decorators: {\n      validate: (0, _utils.arrayOfType)(\"Decorator\"),\n      optional: true\n    },\n    mixins: {\n      validate: (0, _utils.assertNodeType)(\"InterfaceExtends\"),\n      optional: true\n    }\n  }\n});\ndefineType(\"ClassDeclaration\", {\n  inherits: \"ClassExpression\",\n  aliases: [\"Scopable\", \"Class\", \"Statement\", \"Declaration\"],\n  fields: {\n    id: {\n      validate: (0, _utils.assertNodeType)(\"Identifier\"),\n      optional: true\n    },\n    typeParameters: {\n      validate: (0, _utils.assertNodeType)(\"TypeParameterDeclaration\", \"TSTypeParameterDeclaration\", \"Noop\"),\n      optional: true\n    },\n    body: {\n      validate: (0, _utils.assertNodeType)(\"ClassBody\")\n    },\n    superClass: {\n      optional: true,\n      validate: (0, _utils.assertNodeType)(\"Expression\")\n    },\n    [\"superTypeParameters\"]: {\n      validate: (0, _utils.assertNodeType)(\"TypeParameterInstantiation\", \"TSTypeParameterInstantiation\"),\n      optional: true\n    },\n    implements: {\n      validate: (0, _utils.arrayOfType)(\"TSExpressionWithTypeArguments\", \"ClassImplements\"),\n      optional: true\n    },\n    decorators: {\n      validate: (0, _utils.arrayOfType)(\"Decorator\"),\n      optional: true\n    },\n    mixins: {\n      validate: (0, _utils.assertNodeType)(\"InterfaceExtends\"),\n      optional: true\n    },\n    declare: {\n      validate: (0, _utils.assertValueType)(\"boolean\"),\n      optional: true\n    },\n    abstract: {\n      validate: (0, _utils.assertValueType)(\"boolean\"),\n      optional: true\n    }\n  },\n  validate: !process.env.BABEL_TYPES_8_BREAKING ? undefined : function () {\n    const identifier = (0, _utils.assertNodeType)(\"Identifier\");\n    return function (parent, key, node) {\n      if (!(0, _is.default)(\"ExportDefaultDeclaration\", parent)) {\n        identifier(node, \"id\", node.id);\n      }\n    };\n  }()\n});\nconst importAttributes = exports.importAttributes = {\n  attributes: {\n    optional: true,\n    validate: (0, _utils.arrayOfType)(\"ImportAttribute\")\n  }\n};\nimportAttributes.assertions = {\n  deprecated: true,\n  optional: true,\n  validate: (0, _utils.arrayOfType)(\"ImportAttribute\")\n};\ndefineType(\"ExportAllDeclaration\", {\n  builder: [\"source\"],\n  visitor: [\"source\", \"attributes\", \"assertions\"],\n  aliases: [\"Statement\", \"Declaration\", \"ImportOrExportDeclaration\", \"ExportDeclaration\"],\n  fields: Object.assign({\n    source: {\n      validate: (0, _utils.assertNodeType)(\"StringLiteral\")\n    },\n    exportKind: (0, _utils.validateOptional)((0, _utils.assertOneOf)(\"type\", \"value\"))\n  }, importAttributes)\n});\ndefineType(\"ExportDefaultDeclaration\", {\n  visitor: [\"declaration\"],\n  aliases: [\"Statement\", \"Declaration\", \"ImportOrExportDeclaration\", \"ExportDeclaration\"],\n  fields: {\n    declaration: (0, _utils.validateType)(\"TSDeclareFunction\", \"FunctionDeclaration\", \"ClassDeclaration\", \"Expression\"),\n    exportKind: (0, _utils.validateOptional)((0, _utils.assertOneOf)(\"value\"))\n  }\n});\ndefineType(\"ExportNamedDeclaration\", {\n  builder: [\"declaration\", \"specifiers\", \"source\"],\n  visitor: [\"declaration\", \"specifiers\", \"source\", \"attributes\", \"assertions\"],\n  aliases: [\"Statement\", \"Declaration\", \"ImportOrExportDeclaration\", \"ExportDeclaration\"],\n  fields: Object.assign({\n    declaration: {\n      optional: true,\n      validate: process.env.BABEL_TYPES_8_BREAKING ? (0, _utils.chain)((0, _utils.assertNodeType)(\"Declaration\"), Object.assign(function (node, key, val) {\n        if (val && node.specifiers.length) {\n          throw new TypeError(\"Only declaration or specifiers is allowed on ExportNamedDeclaration\");\n        }\n        if (val && node.source) {\n          throw new TypeError(\"Cannot export a declaration from a source\");\n        }\n      }, {\n        oneOfNodeTypes: [\"Declaration\"]\n      })) : (0, _utils.assertNodeType)(\"Declaration\")\n    }\n  }, importAttributes, {\n    specifiers: {\n      default: [],\n      validate: (0, _utils.arrayOf)(function () {\n        const sourced = (0, _utils.assertNodeType)(\"ExportSpecifier\", \"ExportDefaultSpecifier\", \"ExportNamespaceSpecifier\");\n        const sourceless = (0, _utils.assertNodeType)(\"ExportSpecifier\");\n        if (!process.env.BABEL_TYPES_8_BREAKING) return sourced;\n        return Object.assign(function (node, key, val) {\n          const validator = node.source ? sourced : sourceless;\n          validator(node, key, val);\n        }, {\n          oneOfNodeTypes: [\"ExportSpecifier\", \"ExportDefaultSpecifier\", \"ExportNamespaceSpecifier\"]\n        });\n      }())\n    },\n    source: {\n      validate: (0, _utils.assertNodeType)(\"StringLiteral\"),\n      optional: true\n    },\n    exportKind: (0, _utils.validateOptional)((0, _utils.assertOneOf)(\"type\", \"value\"))\n  })\n});\ndefineType(\"ExportSpecifier\", {\n  visitor: [\"local\", \"exported\"],\n  aliases: [\"ModuleSpecifier\"],\n  fields: {\n    local: {\n      validate: (0, _utils.assertNodeType)(\"Identifier\")\n    },\n    exported: {\n      validate: (0, _utils.assertNodeType)(\"Identifier\", \"StringLiteral\")\n    },\n    exportKind: {\n      validate: (0, _utils.assertOneOf)(\"type\", \"value\"),\n      optional: true\n    }\n  }\n});\ndefineType(\"ForOfStatement\", {\n  visitor: [\"left\", \"right\", \"body\"],\n  builder: [\"left\", \"right\", \"body\", \"await\"],\n  aliases: [\"Scopable\", \"Statement\", \"For\", \"BlockParent\", \"Loop\", \"ForXStatement\"],\n  fields: {\n    left: {\n      validate: function () {\n        if (!process.env.BABEL_TYPES_8_BREAKING) {\n          return (0, _utils.assertNodeType)(\"VariableDeclaration\", \"LVal\");\n        }\n        const declaration = (0, _utils.assertNodeType)(\"VariableDeclaration\");\n        const lval = (0, _utils.assertNodeType)(\"Identifier\", \"MemberExpression\", \"ArrayPattern\", \"ObjectPattern\", \"TSAsExpression\", \"TSSatisfiesExpression\", \"TSTypeAssertion\", \"TSNonNullExpression\");\n        return Object.assign(function (node, key, val) {\n          if ((0, _is.default)(\"VariableDeclaration\", val)) {\n            declaration(node, key, val);\n          } else {\n            lval(node, key, val);\n          }\n        }, {\n          oneOfNodeTypes: [\"VariableDeclaration\", \"Identifier\", \"MemberExpression\", \"ArrayPattern\", \"ObjectPattern\", \"TSAsExpression\", \"TSSatisfiesExpression\", \"TSTypeAssertion\", \"TSNonNullExpression\"]\n        });\n      }()\n    },\n    right: {\n      validate: (0, _utils.assertNodeType)(\"Expression\")\n    },\n    body: {\n      validate: (0, _utils.assertNodeType)(\"Statement\")\n    },\n    await: {\n      default: false\n    }\n  }\n});\ndefineType(\"ImportDeclaration\", {\n  builder: [\"specifiers\", \"source\"],\n  visitor: [\"specifiers\", \"source\", \"attributes\", \"assertions\"],\n  aliases: [\"Statement\", \"Declaration\", \"ImportOrExportDeclaration\"],\n  fields: Object.assign({}, importAttributes, {\n    module: {\n      optional: true,\n      validate: (0, _utils.assertValueType)(\"boolean\")\n    },\n    phase: {\n      default: null,\n      validate: (0, _utils.assertOneOf)(\"source\", \"defer\")\n    },\n    specifiers: (0, _utils.validateArrayOfType)(\"ImportSpecifier\", \"ImportDefaultSpecifier\", \"ImportNamespaceSpecifier\"),\n    source: {\n      validate: (0, _utils.assertNodeType)(\"StringLiteral\")\n    },\n    importKind: {\n      validate: (0, _utils.assertOneOf)(\"type\", \"typeof\", \"value\"),\n      optional: true\n    }\n  })\n});\ndefineType(\"ImportDefaultSpecifier\", {\n  visitor: [\"local\"],\n  aliases: [\"ModuleSpecifier\"],\n  fields: {\n    local: {\n      validate: (0, _utils.assertNodeType)(\"Identifier\")\n    }\n  }\n});\ndefineType(\"ImportNamespaceSpecifier\", {\n  visitor: [\"local\"],\n  aliases: [\"ModuleSpecifier\"],\n  fields: {\n    local: {\n      validate: (0, _utils.assertNodeType)(\"Identifier\")\n    }\n  }\n});\ndefineType(\"ImportSpecifier\", {\n  visitor: [\"imported\", \"local\"],\n  builder: [\"local\", \"imported\"],\n  aliases: [\"ModuleSpecifier\"],\n  fields: {\n    local: {\n      validate: (0, _utils.assertNodeType)(\"Identifier\")\n    },\n    imported: {\n      validate: (0, _utils.assertNodeType)(\"Identifier\", \"StringLiteral\")\n    },\n    importKind: {\n      validate: (0, _utils.assertOneOf)(\"type\", \"typeof\", \"value\"),\n      optional: true\n    }\n  }\n});\ndefineType(\"ImportExpression\", {\n  visitor: [\"source\", \"options\"],\n  aliases: [\"Expression\"],\n  fields: {\n    phase: {\n      default: null,\n      validate: (0, _utils.assertOneOf)(\"source\", \"defer\")\n    },\n    source: {\n      validate: (0, _utils.assertNodeType)(\"Expression\")\n    },\n    options: {\n      validate: (0, _utils.assertNodeType)(\"Expression\"),\n      optional: true\n    }\n  }\n});\ndefineType(\"MetaProperty\", {\n  visitor: [\"meta\", \"property\"],\n  aliases: [\"Expression\"],\n  fields: {\n    meta: {\n      validate: process.env.BABEL_TYPES_8_BREAKING ? (0, _utils.chain)((0, _utils.assertNodeType)(\"Identifier\"), Object.assign(function (node, key, val) {\n        let property;\n        switch (val.name) {\n          case \"function\":\n            property = \"sent\";\n            break;\n          case \"new\":\n            property = \"target\";\n            break;\n          case \"import\":\n            property = \"meta\";\n            break;\n        }\n        if (!(0, _is.default)(\"Identifier\", node.property, {\n          name: property\n        })) {\n          throw new TypeError(\"Unrecognised MetaProperty\");\n        }\n      }, {\n        oneOfNodeTypes: [\"Identifier\"]\n      })) : (0, _utils.assertNodeType)(\"Identifier\")\n    },\n    property: {\n      validate: (0, _utils.assertNodeType)(\"Identifier\")\n    }\n  }\n});\nconst classMethodOrPropertyCommon = () => ({\n  abstract: {\n    validate: (0, _utils.assertValueType)(\"boolean\"),\n    optional: true\n  },\n  accessibility: {\n    validate: (0, _utils.assertOneOf)(\"public\", \"private\", \"protected\"),\n    optional: true\n  },\n  static: {\n    default: false\n  },\n  override: {\n    default: false\n  },\n  computed: {\n    default: false\n  },\n  optional: {\n    validate: (0, _utils.assertValueType)(\"boolean\"),\n    optional: true\n  },\n  key: {\n    validate: (0, _utils.chain)(function () {\n      const normal = (0, _utils.assertNodeType)(\"Identifier\", \"StringLiteral\", \"NumericLiteral\", \"BigIntLiteral\");\n      const computed = (0, _utils.assertNodeType)(\"Expression\");\n      return function (node, key, val) {\n        const validator = node.computed ? computed : normal;\n        validator(node, key, val);\n      };\n    }(), (0, _utils.assertNodeType)(\"Identifier\", \"StringLiteral\", \"NumericLiteral\", \"BigIntLiteral\", \"Expression\"))\n  }\n});\nexports.classMethodOrPropertyCommon = classMethodOrPropertyCommon;\nconst classMethodOrDeclareMethodCommon = () => Object.assign({}, functionCommon(), classMethodOrPropertyCommon(), {\n  params: (0, _utils.validateArrayOfType)(\"FunctionParameter\", \"TSParameterProperty\"),\n  kind: {\n    validate: (0, _utils.assertOneOf)(\"get\", \"set\", \"method\", \"constructor\"),\n    default: \"method\"\n  },\n  access: {\n    validate: (0, _utils.chain)((0, _utils.assertValueType)(\"string\"), (0, _utils.assertOneOf)(\"public\", \"private\", \"protected\")),\n    optional: true\n  },\n  decorators: {\n    validate: (0, _utils.arrayOfType)(\"Decorator\"),\n    optional: true\n  }\n});\nexports.classMethodOrDeclareMethodCommon = classMethodOrDeclareMethodCommon;\ndefineType(\"ClassMethod\", Object.assign({\n  aliases: [\"Function\", \"Scopable\", \"BlockParent\", \"FunctionParent\", \"Method\"],\n  builder: [\"kind\", \"key\", \"params\", \"body\", \"computed\", \"static\", \"generator\", \"async\"],\n  visitor: [\"decorators\", \"key\", \"typeParameters\", \"params\", \"returnType\", \"body\"]\n}, classMethodOrPropertyUnionShapeCommon(), {\n  fields: Object.assign({}, classMethodOrDeclareMethodCommon(), functionTypeAnnotationCommon(), {\n    body: {\n      validate: (0, _utils.assertNodeType)(\"BlockStatement\")\n    }\n  })\n}));\ndefineType(\"ObjectPattern\", {\n  visitor: [\"decorators\", \"properties\", \"typeAnnotation\"],\n  builder: [\"properties\"],\n  aliases: [\"FunctionParameter\", \"Pattern\", \"PatternLike\", \"LVal\"],\n  fields: Object.assign({}, patternLikeCommon(), {\n    properties: (0, _utils.validateArrayOfType)(\"RestElement\", \"ObjectProperty\")\n  })\n});\ndefineType(\"SpreadElement\", {\n  visitor: [\"argument\"],\n  aliases: [\"UnaryLike\"],\n  deprecatedAlias: \"SpreadProperty\",\n  fields: {\n    argument: {\n      validate: (0, _utils.assertNodeType)(\"Expression\")\n    }\n  }\n});\ndefineType(\"Super\", {\n  aliases: [\"Expression\"]\n});\ndefineType(\"TaggedTemplateExpression\", {\n  visitor: [\"tag\", \"typeParameters\", \"quasi\"],\n  builder: [\"tag\", \"quasi\"],\n  aliases: [\"Expression\"],\n  fields: {\n    tag: {\n      validate: (0, _utils.assertNodeType)(\"Expression\")\n    },\n    quasi: {\n      validate: (0, _utils.assertNodeType)(\"TemplateLiteral\")\n    },\n    [\"typeParameters\"]: {\n      validate: (0, _utils.assertNodeType)(\"TypeParameterInstantiation\", \"TSTypeParameterInstantiation\"),\n      optional: true\n    }\n  }\n});\ndefineType(\"TemplateElement\", {\n  builder: [\"value\", \"tail\"],\n  fields: {\n    value: {\n      validate: (0, _utils.chain)((0, _utils.assertShape)({\n        raw: {\n          validate: (0, _utils.assertValueType)(\"string\")\n        },\n        cooked: {\n          validate: (0, _utils.assertValueType)(\"string\"),\n          optional: true\n        }\n      }), function templateElementCookedValidator(node) {\n        const raw = node.value.raw;\n        let unterminatedCalled = false;\n        const error = () => {\n          throw new Error(\"Internal @babel/types error.\");\n        };\n        const {\n          str,\n          firstInvalidLoc\n        } = (0, _helperStringParser.readStringContents)(\"template\", raw, 0, 0, 0, {\n          unterminated() {\n            unterminatedCalled = true;\n          },\n          strictNumericEscape: error,\n          invalidEscapeSequence: error,\n          numericSeparatorInEscapeSequence: error,\n          unexpectedNumericSeparator: error,\n          invalidDigit: error,\n          invalidCodePoint: error\n        });\n        if (!unterminatedCalled) throw new Error(\"Invalid raw\");\n        node.value.cooked = firstInvalidLoc ? null : str;\n      })\n    },\n    tail: {\n      default: false\n    }\n  }\n});\ndefineType(\"TemplateLiteral\", {\n  visitor: [\"quasis\", \"expressions\"],\n  aliases: [\"Expression\", \"Literal\"],\n  fields: {\n    quasis: (0, _utils.validateArrayOfType)(\"TemplateElement\"),\n    expressions: {\n      validate: (0, _utils.chain)((0, _utils.assertValueType)(\"array\"), (0, _utils.assertEach)((0, _utils.assertNodeType)(\"Expression\", \"TSType\")), function (node, key, val) {\n        if (node.quasis.length !== val.length + 1) {\n          throw new TypeError(`Number of ${node.type} quasis should be exactly one more than the number of expressions.\\nExpected ${val.length + 1} quasis but got ${node.quasis.length}`);\n        }\n      })\n    }\n  }\n});\ndefineType(\"YieldExpression\", {\n  builder: [\"argument\", \"delegate\"],\n  visitor: [\"argument\"],\n  aliases: [\"Expression\", \"Terminatorless\"],\n  fields: {\n    delegate: {\n      validate: process.env.BABEL_TYPES_8_BREAKING ? (0, _utils.chain)((0, _utils.assertValueType)(\"boolean\"), Object.assign(function (node, key, val) {\n        if (val && !node.argument) {\n          throw new TypeError(\"Property delegate of YieldExpression cannot be true if there is no argument\");\n        }\n      }, {\n        type: \"boolean\"\n      })) : (0, _utils.assertValueType)(\"boolean\"),\n      default: false\n    },\n    argument: {\n      optional: true,\n      validate: (0, _utils.assertNodeType)(\"Expression\")\n    }\n  }\n});\ndefineType(\"AwaitExpression\", {\n  builder: [\"argument\"],\n  visitor: [\"argument\"],\n  aliases: [\"Expression\", \"Terminatorless\"],\n  fields: {\n    argument: {\n      validate: (0, _utils.assertNodeType)(\"Expression\")\n    }\n  }\n});\ndefineType(\"Import\", {\n  aliases: [\"Expression\"]\n});\ndefineType(\"BigIntLiteral\", {\n  builder: [\"value\"],\n  fields: {\n    value: {\n      validate: (0, _utils.assertValueType)(\"string\")\n    }\n  },\n  aliases: [\"Expression\", \"Pureish\", \"Literal\", \"Immutable\"]\n});\ndefineType(\"ExportNamespaceSpecifier\", {\n  visitor: [\"exported\"],\n  aliases: [\"ModuleSpecifier\"],\n  fields: {\n    exported: {\n      validate: (0, _utils.assertNodeType)(\"Identifier\")\n    }\n  }\n});\ndefineType(\"OptionalMemberExpression\", {\n  builder: [\"object\", \"property\", \"computed\", \"optional\"],\n  visitor: [\"object\", \"property\"],\n  aliases: [\"Expression\"],\n  fields: {\n    object: {\n      validate: (0, _utils.assertNodeType)(\"Expression\")\n    },\n    property: {\n      validate: function () {\n        const normal = (0, _utils.assertNodeType)(\"Identifier\");\n        const computed = (0, _utils.assertNodeType)(\"Expression\");\n        const validator = Object.assign(function (node, key, val) {\n          const validator = node.computed ? computed : normal;\n          validator(node, key, val);\n        }, {\n          oneOfNodeTypes: [\"Expression\", \"Identifier\"]\n        });\n        return validator;\n      }()\n    },\n    computed: {\n      default: false\n    },\n    optional: {\n      validate: !process.env.BABEL_TYPES_8_BREAKING ? (0, _utils.assertValueType)(\"boolean\") : (0, _utils.chain)((0, _utils.assertValueType)(\"boolean\"), (0, _utils.assertOptionalChainStart)())\n    }\n  }\n});\ndefineType(\"OptionalCallExpression\", {\n  visitor: [\"callee\", \"typeParameters\", \"typeArguments\", \"arguments\"],\n  builder: [\"callee\", \"arguments\", \"optional\"],\n  aliases: [\"Expression\"],\n  fields: Object.assign({\n    callee: {\n      validate: (0, _utils.assertNodeType)(\"Expression\")\n    },\n    arguments: (0, _utils.validateArrayOfType)(\"Expression\", \"SpreadElement\", \"ArgumentPlaceholder\"),\n    optional: {\n      validate: !process.env.BABEL_TYPES_8_BREAKING ? (0, _utils.assertValueType)(\"boolean\") : (0, _utils.chain)((0, _utils.assertValueType)(\"boolean\"), (0, _utils.assertOptionalChainStart)())\n    },\n    typeArguments: {\n      validate: (0, _utils.assertNodeType)(\"TypeParameterInstantiation\"),\n      optional: true\n    }\n  }, {\n    typeParameters: {\n      validate: (0, _utils.assertNodeType)(\"TSTypeParameterInstantiation\"),\n      optional: true\n    }\n  })\n});\ndefineType(\"ClassProperty\", Object.assign({\n  visitor: [\"decorators\", \"variance\", \"key\", \"typeAnnotation\", \"value\"],\n  builder: [\"key\", \"value\", \"typeAnnotation\", \"decorators\", \"computed\", \"static\"],\n  aliases: [\"Property\"]\n}, classMethodOrPropertyUnionShapeCommon(), {\n  fields: Object.assign({}, classMethodOrPropertyCommon(), {\n    value: {\n      validate: (0, _utils.assertNodeType)(\"Expression\"),\n      optional: true\n    },\n    definite: {\n      validate: (0, _utils.assertValueType)(\"boolean\"),\n      optional: true\n    },\n    typeAnnotation: {\n      validate: (0, _utils.assertNodeType)(\"TypeAnnotation\", \"TSTypeAnnotation\", \"Noop\"),\n      optional: true\n    },\n    decorators: {\n      validate: (0, _utils.arrayOfType)(\"Decorator\"),\n      optional: true\n    },\n    readonly: {\n      validate: (0, _utils.assertValueType)(\"boolean\"),\n      optional: true\n    },\n    declare: {\n      validate: (0, _utils.assertValueType)(\"boolean\"),\n      optional: true\n    },\n    variance: {\n      validate: (0, _utils.assertNodeType)(\"Variance\"),\n      optional: true\n    }\n  })\n}));\ndefineType(\"ClassAccessorProperty\", Object.assign({\n  visitor: [\"decorators\", \"key\", \"typeAnnotation\", \"value\"],\n  builder: [\"key\", \"value\", \"typeAnnotation\", \"decorators\", \"computed\", \"static\"],\n  aliases: [\"Property\", \"Accessor\"]\n}, classMethodOrPropertyUnionShapeCommon(true), {\n  fields: Object.assign({}, classMethodOrPropertyCommon(), {\n    key: {\n      validate: (0, _utils.chain)(function () {\n        const normal = (0, _utils.assertNodeType)(\"Identifier\", \"StringLiteral\", \"NumericLiteral\", \"BigIntLiteral\", \"PrivateName\");\n        const computed = (0, _utils.assertNodeType)(\"Expression\");\n        return function (node, key, val) {\n          const validator = node.computed ? computed : normal;\n          validator(node, key, val);\n        };\n      }(), (0, _utils.assertNodeType)(\"Identifier\", \"StringLiteral\", \"NumericLiteral\", \"BigIntLiteral\", \"Expression\", \"PrivateName\"))\n    },\n    value: {\n      validate: (0, _utils.assertNodeType)(\"Expression\"),\n      optional: true\n    },\n    definite: {\n      validate: (0, _utils.assertValueType)(\"boolean\"),\n      optional: true\n    },\n    typeAnnotation: {\n      validate: (0, _utils.assertNodeType)(\"TypeAnnotation\", \"TSTypeAnnotation\", \"Noop\"),\n      optional: true\n    },\n    decorators: {\n      validate: (0, _utils.arrayOfType)(\"Decorator\"),\n      optional: true\n    },\n    readonly: {\n      validate: (0, _utils.assertValueType)(\"boolean\"),\n      optional: true\n    },\n    declare: {\n      validate: (0, _utils.assertValueType)(\"boolean\"),\n      optional: true\n    },\n    variance: {\n      validate: (0, _utils.assertNodeType)(\"Variance\"),\n      optional: true\n    }\n  })\n}));\ndefineType(\"ClassPrivateProperty\", {\n  visitor: [\"decorators\", \"variance\", \"key\", \"typeAnnotation\", \"value\"],\n  builder: [\"key\", \"value\", \"decorators\", \"static\"],\n  aliases: [\"Property\", \"Private\"],\n  fields: {\n    key: {\n      validate: (0, _utils.assertNodeType)(\"PrivateName\")\n    },\n    value: {\n      validate: (0, _utils.assertNodeType)(\"Expression\"),\n      optional: true\n    },\n    typeAnnotation: {\n      validate: (0, _utils.assertNodeType)(\"TypeAnnotation\", \"TSTypeAnnotation\", \"Noop\"),\n      optional: true\n    },\n    decorators: {\n      validate: (0, _utils.arrayOfType)(\"Decorator\"),\n      optional: true\n    },\n    static: {\n      validate: (0, _utils.assertValueType)(\"boolean\"),\n      default: false\n    },\n    readonly: {\n      validate: (0, _utils.assertValueType)(\"boolean\"),\n      optional: true\n    },\n    optional: {\n      validate: (0, _utils.assertValueType)(\"boolean\"),\n      optional: true\n    },\n    definite: {\n      validate: (0, _utils.assertValueType)(\"boolean\"),\n      optional: true\n    },\n    variance: {\n      validate: (0, _utils.assertNodeType)(\"Variance\"),\n      optional: true\n    }\n  }\n});\ndefineType(\"ClassPrivateMethod\", {\n  builder: [\"kind\", \"key\", \"params\", \"body\", \"static\"],\n  visitor: [\"decorators\", \"key\", \"typeParameters\", \"params\", \"returnType\", \"body\"],\n  aliases: [\"Function\", \"Scopable\", \"BlockParent\", \"FunctionParent\", \"Method\", \"Private\"],\n  fields: Object.assign({}, classMethodOrDeclareMethodCommon(), functionTypeAnnotationCommon(), {\n    kind: {\n      validate: (0, _utils.assertOneOf)(\"get\", \"set\", \"method\"),\n      default: \"method\"\n    },\n    key: {\n      validate: (0, _utils.assertNodeType)(\"PrivateName\")\n    },\n    body: {\n      validate: (0, _utils.assertNodeType)(\"BlockStatement\")\n    }\n  })\n});\ndefineType(\"PrivateName\", {\n  visitor: [\"id\"],\n  aliases: [\"Private\"],\n  fields: {\n    id: {\n      validate: (0, _utils.assertNodeType)(\"Identifier\")\n    }\n  }\n});\ndefineType(\"StaticBlock\", {\n  visitor: [\"body\"],\n  fields: {\n    body: (0, _utils.validateArrayOfType)(\"Statement\")\n  },\n  aliases: [\"Scopable\", \"BlockParent\", \"FunctionParent\"]\n});\ndefineType(\"ImportAttribute\", {\n  visitor: [\"key\", \"value\"],\n  fields: {\n    key: {\n      validate: (0, _utils.assertNodeType)(\"Identifier\", \"StringLiteral\")\n    },\n    value: {\n      validate: (0, _utils.assertNodeType)(\"StringLiteral\")\n    }\n  }\n});\n\n//# sourceMappingURL=core.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGJhYmVsL3R5cGVzL2xpYi9kZWZpbml0aW9ucy9jb3JlLmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViLDhDQUE2QztBQUM3QztBQUNBLENBQUMsRUFBQztBQUNGLHlCQUF5QixHQUFHLHdCQUF3QixHQUFHLG9DQUFvQyxHQUFHLGlDQUFpQyxHQUFHLHNCQUFzQixHQUFHLDZDQUE2QyxHQUFHLG1DQUFtQyxHQUFHLHdDQUF3QztBQUN6UixVQUFVLG1CQUFPLENBQUMsbUZBQXFCO0FBQ3ZDLHlCQUF5QixtQkFBTyxDQUFDLGlIQUFvQztBQUNyRSxpQ0FBaUMsbUJBQU8sQ0FBQyxnSEFBb0M7QUFDN0UsMEJBQTBCLG1CQUFPLENBQUMsa0dBQTZCO0FBQy9ELGFBQWEsbUJBQU8sQ0FBQyx1RkFBdUI7QUFDNUMsYUFBYSxtQkFBTyxDQUFDLDhFQUFZO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxDQUFDO0FBQ0QsNkNBQTZDO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsU0FBUztBQUNUO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEdBQUc7QUFDSDtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRywwQ0FBMEM7QUFDN0M7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLDRFQUE0RTtBQUM1RTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxLQUFLO0FBQ0w7QUFDQSw2REFBNkQ7QUFDN0Q7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNELHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRCxvQ0FBb0M7QUFDcEMsd0RBQXdEO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRCxpQ0FBaUM7QUFDakM7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0QseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQyxJQUFJO0FBQ3RDO0FBQ0EsT0FBTztBQUNQO0FBQ0EsT0FBTztBQUNQO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLE9BQU87QUFDUCxNQUFNO0FBQ047QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsOEJBQThCLFVBQVU7QUFDeEM7QUFDQSxJQUFJO0FBQ0osQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlIQUF5SCxJQUFJO0FBQzdIO0FBQ0EsT0FBTztBQUNQO0FBQ0EsT0FBTztBQUNQO0FBQ0EsR0FBRztBQUNIO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDLFdBQVc7QUFDN0M7QUFDQSxPQUFPO0FBQ1A7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJLElBQUk7QUFDUixDQUFDO0FBQ0Q7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxHQUFHO0FBQ0g7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRCwwQkFBMEI7QUFDMUI7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLE1BQU0sSUFBSTtBQUNWO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsT0FBTztBQUNQO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlFQUFpRSxRQUFRO0FBQ3pFO0FBQ0EsSUFBSTtBQUNKLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLDRHQUE0RyxZQUFZO0FBQ3hIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEI7QUFDMUI7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILENBQUM7QUFDRCx5QkFBeUIsd0JBQXdCO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxHQUFHO0FBQ0gsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxPQUFPO0FBQ1A7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsU0FBUztBQUNULE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsR0FBRztBQUNILENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsU0FBUztBQUNULE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLENBQUM7QUFDRCxtQ0FBbUM7QUFDbkMsK0RBQStEO0FBQy9EO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRCx3Q0FBd0M7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0QsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEI7QUFDMUI7QUFDQSxHQUFHO0FBQ0gsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQ0FBMkMsV0FBVyw4RUFBOEUsZ0JBQWdCLGlCQUFpQixtQkFBbUI7QUFDeEw7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLE9BQU87QUFDUDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsU0FBUztBQUNUO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0QsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRCwwQkFBMEI7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRCIsInNvdXJjZXMiOlsid2VicGFjazovL3JlcG8tdmlzdWFsaXplci8uL25vZGVfbW9kdWxlcy9AYmFiZWwvdHlwZXMvbGliL2RlZmluaXRpb25zL2NvcmUuanM/MWYzNiJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMucGF0dGVybkxpa2VDb21tb24gPSBleHBvcnRzLmltcG9ydEF0dHJpYnV0ZXMgPSBleHBvcnRzLmZ1bmN0aW9uVHlwZUFubm90YXRpb25Db21tb24gPSBleHBvcnRzLmZ1bmN0aW9uRGVjbGFyYXRpb25Db21tb24gPSBleHBvcnRzLmZ1bmN0aW9uQ29tbW9uID0gZXhwb3J0cy5jbGFzc01ldGhvZE9yUHJvcGVydHlVbmlvblNoYXBlQ29tbW9uID0gZXhwb3J0cy5jbGFzc01ldGhvZE9yUHJvcGVydHlDb21tb24gPSBleHBvcnRzLmNsYXNzTWV0aG9kT3JEZWNsYXJlTWV0aG9kQ29tbW9uID0gdm9pZCAwO1xudmFyIF9pcyA9IHJlcXVpcmUoXCIuLi92YWxpZGF0b3JzL2lzLmpzXCIpO1xudmFyIF9pc1ZhbGlkSWRlbnRpZmllciA9IHJlcXVpcmUoXCIuLi92YWxpZGF0b3JzL2lzVmFsaWRJZGVudGlmaWVyLmpzXCIpO1xudmFyIF9oZWxwZXJWYWxpZGF0b3JJZGVudGlmaWVyID0gcmVxdWlyZShcIkBiYWJlbC9oZWxwZXItdmFsaWRhdG9yLWlkZW50aWZpZXJcIik7XG52YXIgX2hlbHBlclN0cmluZ1BhcnNlciA9IHJlcXVpcmUoXCJAYmFiZWwvaGVscGVyLXN0cmluZy1wYXJzZXJcIik7XG52YXIgX2luZGV4ID0gcmVxdWlyZShcIi4uL2NvbnN0YW50cy9pbmRleC5qc1wiKTtcbnZhciBfdXRpbHMgPSByZXF1aXJlKFwiLi91dGlscy5qc1wiKTtcbmNvbnN0IGNsYXNzTWV0aG9kT3JQcm9wZXJ0eVVuaW9uU2hhcGVDb21tb24gPSAoYWxsb3dQcml2YXRlTmFtZSA9IGZhbHNlKSA9PiAoe1xuICB1bmlvblNoYXBlOiB7XG4gICAgZGlzY3JpbWluYXRvcjogXCJjb21wdXRlZFwiLFxuICAgIHNoYXBlczogW3tcbiAgICAgIG5hbWU6IFwiY29tcHV0ZWRcIixcbiAgICAgIHZhbHVlOiBbdHJ1ZV0sXG4gICAgICBwcm9wZXJ0aWVzOiB7XG4gICAgICAgIGtleToge1xuICAgICAgICAgIHZhbGlkYXRlOiAoMCwgX3V0aWxzLmFzc2VydE5vZGVUeXBlKShcIkV4cHJlc3Npb25cIilcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIG5hbWU6IFwibm9uQ29tcHV0ZWRcIixcbiAgICAgIHZhbHVlOiBbZmFsc2VdLFxuICAgICAgcHJvcGVydGllczoge1xuICAgICAgICBrZXk6IHtcbiAgICAgICAgICB2YWxpZGF0ZTogYWxsb3dQcml2YXRlTmFtZSA/ICgwLCBfdXRpbHMuYXNzZXJ0Tm9kZVR5cGUpKFwiSWRlbnRpZmllclwiLCBcIlN0cmluZ0xpdGVyYWxcIiwgXCJOdW1lcmljTGl0ZXJhbFwiLCBcIkJpZ0ludExpdGVyYWxcIiwgXCJQcml2YXRlTmFtZVwiKSA6ICgwLCBfdXRpbHMuYXNzZXJ0Tm9kZVR5cGUpKFwiSWRlbnRpZmllclwiLCBcIlN0cmluZ0xpdGVyYWxcIiwgXCJOdW1lcmljTGl0ZXJhbFwiLCBcIkJpZ0ludExpdGVyYWxcIilcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1dXG4gIH1cbn0pO1xuZXhwb3J0cy5jbGFzc01ldGhvZE9yUHJvcGVydHlVbmlvblNoYXBlQ29tbW9uID0gY2xhc3NNZXRob2RPclByb3BlcnR5VW5pb25TaGFwZUNvbW1vbjtcbmNvbnN0IGRlZmluZVR5cGUgPSAoMCwgX3V0aWxzLmRlZmluZUFsaWFzZWRUeXBlKShcIlN0YW5kYXJkaXplZFwiKTtcbmRlZmluZVR5cGUoXCJBcnJheUV4cHJlc3Npb25cIiwge1xuICBmaWVsZHM6IHtcbiAgICBlbGVtZW50czoge1xuICAgICAgdmFsaWRhdGU6ICgwLCBfdXRpbHMuYXJyYXlPZikoKDAsIF91dGlscy5hc3NlcnROb2RlT3JWYWx1ZVR5cGUpKFwibnVsbFwiLCBcIkV4cHJlc3Npb25cIiwgXCJTcHJlYWRFbGVtZW50XCIpKSxcbiAgICAgIGRlZmF1bHQ6ICFwcm9jZXNzLmVudi5CQUJFTF9UWVBFU184X0JSRUFLSU5HID8gW10gOiB1bmRlZmluZWRcbiAgICB9XG4gIH0sXG4gIHZpc2l0b3I6IFtcImVsZW1lbnRzXCJdLFxuICBhbGlhc2VzOiBbXCJFeHByZXNzaW9uXCJdXG59KTtcbmRlZmluZVR5cGUoXCJBc3NpZ25tZW50RXhwcmVzc2lvblwiLCB7XG4gIGZpZWxkczoge1xuICAgIG9wZXJhdG9yOiB7XG4gICAgICB2YWxpZGF0ZTogIXByb2Nlc3MuZW52LkJBQkVMX1RZUEVTXzhfQlJFQUtJTkcgPyAoMCwgX3V0aWxzLmFzc2VydFZhbHVlVHlwZSkoXCJzdHJpbmdcIikgOiBPYmplY3QuYXNzaWduKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgY29uc3QgaWRlbnRpZmllciA9ICgwLCBfdXRpbHMuYXNzZXJ0T25lT2YpKC4uLl9pbmRleC5BU1NJR05NRU5UX09QRVJBVE9SUyk7XG4gICAgICAgIGNvbnN0IHBhdHRlcm4gPSAoMCwgX3V0aWxzLmFzc2VydE9uZU9mKShcIj1cIik7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAobm9kZSwga2V5LCB2YWwpIHtcbiAgICAgICAgICBjb25zdCB2YWxpZGF0b3IgPSAoMCwgX2lzLmRlZmF1bHQpKFwiUGF0dGVyblwiLCBub2RlLmxlZnQpID8gcGF0dGVybiA6IGlkZW50aWZpZXI7XG4gICAgICAgICAgdmFsaWRhdG9yKG5vZGUsIGtleSwgdmFsKTtcbiAgICAgICAgfTtcbiAgICAgIH0oKSwge1xuICAgICAgICBvbmVPZjogX2luZGV4LkFTU0lHTk1FTlRfT1BFUkFUT1JTXG4gICAgICB9KVxuICAgIH0sXG4gICAgbGVmdDoge1xuICAgICAgdmFsaWRhdGU6ICFwcm9jZXNzLmVudi5CQUJFTF9UWVBFU184X0JSRUFLSU5HID8gKDAsIF91dGlscy5hc3NlcnROb2RlVHlwZSkoXCJMVmFsXCIsIFwiT3B0aW9uYWxNZW1iZXJFeHByZXNzaW9uXCIpIDogKDAsIF91dGlscy5hc3NlcnROb2RlVHlwZSkoXCJJZGVudGlmaWVyXCIsIFwiTWVtYmVyRXhwcmVzc2lvblwiLCBcIk9wdGlvbmFsTWVtYmVyRXhwcmVzc2lvblwiLCBcIkFycmF5UGF0dGVyblwiLCBcIk9iamVjdFBhdHRlcm5cIiwgXCJUU0FzRXhwcmVzc2lvblwiLCBcIlRTU2F0aXNmaWVzRXhwcmVzc2lvblwiLCBcIlRTVHlwZUFzc2VydGlvblwiLCBcIlRTTm9uTnVsbEV4cHJlc3Npb25cIilcbiAgICB9LFxuICAgIHJpZ2h0OiB7XG4gICAgICB2YWxpZGF0ZTogKDAsIF91dGlscy5hc3NlcnROb2RlVHlwZSkoXCJFeHByZXNzaW9uXCIpXG4gICAgfVxuICB9LFxuICBidWlsZGVyOiBbXCJvcGVyYXRvclwiLCBcImxlZnRcIiwgXCJyaWdodFwiXSxcbiAgdmlzaXRvcjogW1wibGVmdFwiLCBcInJpZ2h0XCJdLFxuICBhbGlhc2VzOiBbXCJFeHByZXNzaW9uXCJdXG59KTtcbmRlZmluZVR5cGUoXCJCaW5hcnlFeHByZXNzaW9uXCIsIHtcbiAgYnVpbGRlcjogW1wib3BlcmF0b3JcIiwgXCJsZWZ0XCIsIFwicmlnaHRcIl0sXG4gIGZpZWxkczoge1xuICAgIG9wZXJhdG9yOiB7XG4gICAgICB2YWxpZGF0ZTogKDAsIF91dGlscy5hc3NlcnRPbmVPZikoLi4uX2luZGV4LkJJTkFSWV9PUEVSQVRPUlMpXG4gICAgfSxcbiAgICBsZWZ0OiB7XG4gICAgICB2YWxpZGF0ZTogZnVuY3Rpb24gKCkge1xuICAgICAgICBjb25zdCBleHByZXNzaW9uID0gKDAsIF91dGlscy5hc3NlcnROb2RlVHlwZSkoXCJFeHByZXNzaW9uXCIpO1xuICAgICAgICBjb25zdCBpbk9wID0gKDAsIF91dGlscy5hc3NlcnROb2RlVHlwZSkoXCJFeHByZXNzaW9uXCIsIFwiUHJpdmF0ZU5hbWVcIik7XG4gICAgICAgIGNvbnN0IHZhbGlkYXRvciA9IE9iamVjdC5hc3NpZ24oZnVuY3Rpb24gKG5vZGUsIGtleSwgdmFsKSB7XG4gICAgICAgICAgY29uc3QgdmFsaWRhdG9yID0gbm9kZS5vcGVyYXRvciA9PT0gXCJpblwiID8gaW5PcCA6IGV4cHJlc3Npb247XG4gICAgICAgICAgdmFsaWRhdG9yKG5vZGUsIGtleSwgdmFsKTtcbiAgICAgICAgfSwge1xuICAgICAgICAgIG9uZU9mTm9kZVR5cGVzOiBbXCJFeHByZXNzaW9uXCIsIFwiUHJpdmF0ZU5hbWVcIl1cbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiB2YWxpZGF0b3I7XG4gICAgICB9KClcbiAgICB9LFxuICAgIHJpZ2h0OiB7XG4gICAgICB2YWxpZGF0ZTogKDAsIF91dGlscy5hc3NlcnROb2RlVHlwZSkoXCJFeHByZXNzaW9uXCIpXG4gICAgfVxuICB9LFxuICB2aXNpdG9yOiBbXCJsZWZ0XCIsIFwicmlnaHRcIl0sXG4gIGFsaWFzZXM6IFtcIkJpbmFyeVwiLCBcIkV4cHJlc3Npb25cIl1cbn0pO1xuZGVmaW5lVHlwZShcIkludGVycHJldGVyRGlyZWN0aXZlXCIsIHtcbiAgYnVpbGRlcjogW1widmFsdWVcIl0sXG4gIGZpZWxkczoge1xuICAgIHZhbHVlOiB7XG4gICAgICB2YWxpZGF0ZTogKDAsIF91dGlscy5hc3NlcnRWYWx1ZVR5cGUpKFwic3RyaW5nXCIpXG4gICAgfVxuICB9XG59KTtcbmRlZmluZVR5cGUoXCJEaXJlY3RpdmVcIiwge1xuICB2aXNpdG9yOiBbXCJ2YWx1ZVwiXSxcbiAgZmllbGRzOiB7XG4gICAgdmFsdWU6IHtcbiAgICAgIHZhbGlkYXRlOiAoMCwgX3V0aWxzLmFzc2VydE5vZGVUeXBlKShcIkRpcmVjdGl2ZUxpdGVyYWxcIilcbiAgICB9XG4gIH1cbn0pO1xuZGVmaW5lVHlwZShcIkRpcmVjdGl2ZUxpdGVyYWxcIiwge1xuICBidWlsZGVyOiBbXCJ2YWx1ZVwiXSxcbiAgZmllbGRzOiB7XG4gICAgdmFsdWU6IHtcbiAgICAgIHZhbGlkYXRlOiAoMCwgX3V0aWxzLmFzc2VydFZhbHVlVHlwZSkoXCJzdHJpbmdcIilcbiAgICB9XG4gIH1cbn0pO1xuZGVmaW5lVHlwZShcIkJsb2NrU3RhdGVtZW50XCIsIHtcbiAgYnVpbGRlcjogW1wiYm9keVwiLCBcImRpcmVjdGl2ZXNcIl0sXG4gIHZpc2l0b3I6IFtcImRpcmVjdGl2ZXNcIiwgXCJib2R5XCJdLFxuICBmaWVsZHM6IHtcbiAgICBkaXJlY3RpdmVzOiB7XG4gICAgICB2YWxpZGF0ZTogKDAsIF91dGlscy5hcnJheU9mVHlwZSkoXCJEaXJlY3RpdmVcIiksXG4gICAgICBkZWZhdWx0OiBbXVxuICAgIH0sXG4gICAgYm9keTogKDAsIF91dGlscy52YWxpZGF0ZUFycmF5T2ZUeXBlKShcIlN0YXRlbWVudFwiKVxuICB9LFxuICBhbGlhc2VzOiBbXCJTY29wYWJsZVwiLCBcIkJsb2NrUGFyZW50XCIsIFwiQmxvY2tcIiwgXCJTdGF0ZW1lbnRcIl1cbn0pO1xuZGVmaW5lVHlwZShcIkJyZWFrU3RhdGVtZW50XCIsIHtcbiAgdmlzaXRvcjogW1wibGFiZWxcIl0sXG4gIGZpZWxkczoge1xuICAgIGxhYmVsOiB7XG4gICAgICB2YWxpZGF0ZTogKDAsIF91dGlscy5hc3NlcnROb2RlVHlwZSkoXCJJZGVudGlmaWVyXCIpLFxuICAgICAgb3B0aW9uYWw6IHRydWVcbiAgICB9XG4gIH0sXG4gIGFsaWFzZXM6IFtcIlN0YXRlbWVudFwiLCBcIlRlcm1pbmF0b3JsZXNzXCIsIFwiQ29tcGxldGlvblN0YXRlbWVudFwiXVxufSk7XG5kZWZpbmVUeXBlKFwiQ2FsbEV4cHJlc3Npb25cIiwge1xuICB2aXNpdG9yOiBbXCJjYWxsZWVcIiwgXCJ0eXBlUGFyYW1ldGVyc1wiLCBcInR5cGVBcmd1bWVudHNcIiwgXCJhcmd1bWVudHNcIl0sXG4gIGJ1aWxkZXI6IFtcImNhbGxlZVwiLCBcImFyZ3VtZW50c1wiXSxcbiAgYWxpYXNlczogW1wiRXhwcmVzc2lvblwiXSxcbiAgZmllbGRzOiBPYmplY3QuYXNzaWduKHtcbiAgICBjYWxsZWU6IHtcbiAgICAgIHZhbGlkYXRlOiAoMCwgX3V0aWxzLmFzc2VydE5vZGVUeXBlKShcIkV4cHJlc3Npb25cIiwgXCJTdXBlclwiLCBcIlY4SW50cmluc2ljSWRlbnRpZmllclwiKVxuICAgIH0sXG4gICAgYXJndW1lbnRzOiAoMCwgX3V0aWxzLnZhbGlkYXRlQXJyYXlPZlR5cGUpKFwiRXhwcmVzc2lvblwiLCBcIlNwcmVhZEVsZW1lbnRcIiwgXCJBcmd1bWVudFBsYWNlaG9sZGVyXCIpLFxuICAgIHR5cGVBcmd1bWVudHM6IHtcbiAgICAgIHZhbGlkYXRlOiAoMCwgX3V0aWxzLmFzc2VydE5vZGVUeXBlKShcIlR5cGVQYXJhbWV0ZXJJbnN0YW50aWF0aW9uXCIpLFxuICAgICAgb3B0aW9uYWw6IHRydWVcbiAgICB9XG4gIH0sIHByb2Nlc3MuZW52LkJBQkVMX1RZUEVTXzhfQlJFQUtJTkcgPyB7fSA6IHtcbiAgICBvcHRpb25hbDoge1xuICAgICAgdmFsaWRhdGU6ICgwLCBfdXRpbHMuYXNzZXJ0VmFsdWVUeXBlKShcImJvb2xlYW5cIiksXG4gICAgICBvcHRpb25hbDogdHJ1ZVxuICAgIH0sXG4gICAgdHlwZVBhcmFtZXRlcnM6IHtcbiAgICAgIHZhbGlkYXRlOiAoMCwgX3V0aWxzLmFzc2VydE5vZGVUeXBlKShcIlRTVHlwZVBhcmFtZXRlckluc3RhbnRpYXRpb25cIiksXG4gICAgICBvcHRpb25hbDogdHJ1ZVxuICAgIH1cbiAgfSlcbn0pO1xuZGVmaW5lVHlwZShcIkNhdGNoQ2xhdXNlXCIsIHtcbiAgdmlzaXRvcjogW1wicGFyYW1cIiwgXCJib2R5XCJdLFxuICBmaWVsZHM6IHtcbiAgICBwYXJhbToge1xuICAgICAgdmFsaWRhdGU6ICgwLCBfdXRpbHMuYXNzZXJ0Tm9kZVR5cGUpKFwiSWRlbnRpZmllclwiLCBcIkFycmF5UGF0dGVyblwiLCBcIk9iamVjdFBhdHRlcm5cIiksXG4gICAgICBvcHRpb25hbDogdHJ1ZVxuICAgIH0sXG4gICAgYm9keToge1xuICAgICAgdmFsaWRhdGU6ICgwLCBfdXRpbHMuYXNzZXJ0Tm9kZVR5cGUpKFwiQmxvY2tTdGF0ZW1lbnRcIilcbiAgICB9XG4gIH0sXG4gIGFsaWFzZXM6IFtcIlNjb3BhYmxlXCIsIFwiQmxvY2tQYXJlbnRcIl1cbn0pO1xuZGVmaW5lVHlwZShcIkNvbmRpdGlvbmFsRXhwcmVzc2lvblwiLCB7XG4gIHZpc2l0b3I6IFtcInRlc3RcIiwgXCJjb25zZXF1ZW50XCIsIFwiYWx0ZXJuYXRlXCJdLFxuICBmaWVsZHM6IHtcbiAgICB0ZXN0OiB7XG4gICAgICB2YWxpZGF0ZTogKDAsIF91dGlscy5hc3NlcnROb2RlVHlwZSkoXCJFeHByZXNzaW9uXCIpXG4gICAgfSxcbiAgICBjb25zZXF1ZW50OiB7XG4gICAgICB2YWxpZGF0ZTogKDAsIF91dGlscy5hc3NlcnROb2RlVHlwZSkoXCJFeHByZXNzaW9uXCIpXG4gICAgfSxcbiAgICBhbHRlcm5hdGU6IHtcbiAgICAgIHZhbGlkYXRlOiAoMCwgX3V0aWxzLmFzc2VydE5vZGVUeXBlKShcIkV4cHJlc3Npb25cIilcbiAgICB9XG4gIH0sXG4gIGFsaWFzZXM6IFtcIkV4cHJlc3Npb25cIiwgXCJDb25kaXRpb25hbFwiXVxufSk7XG5kZWZpbmVUeXBlKFwiQ29udGludWVTdGF0ZW1lbnRcIiwge1xuICB2aXNpdG9yOiBbXCJsYWJlbFwiXSxcbiAgZmllbGRzOiB7XG4gICAgbGFiZWw6IHtcbiAgICAgIHZhbGlkYXRlOiAoMCwgX3V0aWxzLmFzc2VydE5vZGVUeXBlKShcIklkZW50aWZpZXJcIiksXG4gICAgICBvcHRpb25hbDogdHJ1ZVxuICAgIH1cbiAgfSxcbiAgYWxpYXNlczogW1wiU3RhdGVtZW50XCIsIFwiVGVybWluYXRvcmxlc3NcIiwgXCJDb21wbGV0aW9uU3RhdGVtZW50XCJdXG59KTtcbmRlZmluZVR5cGUoXCJEZWJ1Z2dlclN0YXRlbWVudFwiLCB7XG4gIGFsaWFzZXM6IFtcIlN0YXRlbWVudFwiXVxufSk7XG5kZWZpbmVUeXBlKFwiRG9XaGlsZVN0YXRlbWVudFwiLCB7XG4gIGJ1aWxkZXI6IFtcInRlc3RcIiwgXCJib2R5XCJdLFxuICB2aXNpdG9yOiBbXCJib2R5XCIsIFwidGVzdFwiXSxcbiAgZmllbGRzOiB7XG4gICAgdGVzdDoge1xuICAgICAgdmFsaWRhdGU6ICgwLCBfdXRpbHMuYXNzZXJ0Tm9kZVR5cGUpKFwiRXhwcmVzc2lvblwiKVxuICAgIH0sXG4gICAgYm9keToge1xuICAgICAgdmFsaWRhdGU6ICgwLCBfdXRpbHMuYXNzZXJ0Tm9kZVR5cGUpKFwiU3RhdGVtZW50XCIpXG4gICAgfVxuICB9LFxuICBhbGlhc2VzOiBbXCJTdGF0ZW1lbnRcIiwgXCJCbG9ja1BhcmVudFwiLCBcIkxvb3BcIiwgXCJXaGlsZVwiLCBcIlNjb3BhYmxlXCJdXG59KTtcbmRlZmluZVR5cGUoXCJFbXB0eVN0YXRlbWVudFwiLCB7XG4gIGFsaWFzZXM6IFtcIlN0YXRlbWVudFwiXVxufSk7XG5kZWZpbmVUeXBlKFwiRXhwcmVzc2lvblN0YXRlbWVudFwiLCB7XG4gIHZpc2l0b3I6IFtcImV4cHJlc3Npb25cIl0sXG4gIGZpZWxkczoge1xuICAgIGV4cHJlc3Npb246IHtcbiAgICAgIHZhbGlkYXRlOiAoMCwgX3V0aWxzLmFzc2VydE5vZGVUeXBlKShcIkV4cHJlc3Npb25cIilcbiAgICB9XG4gIH0sXG4gIGFsaWFzZXM6IFtcIlN0YXRlbWVudFwiLCBcIkV4cHJlc3Npb25XcmFwcGVyXCJdXG59KTtcbmRlZmluZVR5cGUoXCJGaWxlXCIsIHtcbiAgYnVpbGRlcjogW1wicHJvZ3JhbVwiLCBcImNvbW1lbnRzXCIsIFwidG9rZW5zXCJdLFxuICB2aXNpdG9yOiBbXCJwcm9ncmFtXCJdLFxuICBmaWVsZHM6IHtcbiAgICBwcm9ncmFtOiB7XG4gICAgICB2YWxpZGF0ZTogKDAsIF91dGlscy5hc3NlcnROb2RlVHlwZSkoXCJQcm9ncmFtXCIpXG4gICAgfSxcbiAgICBjb21tZW50czoge1xuICAgICAgdmFsaWRhdGU6ICFwcm9jZXNzLmVudi5CQUJFTF9UWVBFU184X0JSRUFLSU5HID8gT2JqZWN0LmFzc2lnbigoKSA9PiB7fSwge1xuICAgICAgICBlYWNoOiB7XG4gICAgICAgICAgb25lT2ZOb2RlVHlwZXM6IFtcIkNvbW1lbnRCbG9ja1wiLCBcIkNvbW1lbnRMaW5lXCJdXG4gICAgICAgIH1cbiAgICAgIH0pIDogKDAsIF91dGlscy5hc3NlcnRFYWNoKSgoMCwgX3V0aWxzLmFzc2VydE5vZGVUeXBlKShcIkNvbW1lbnRCbG9ja1wiLCBcIkNvbW1lbnRMaW5lXCIpKSxcbiAgICAgIG9wdGlvbmFsOiB0cnVlXG4gICAgfSxcbiAgICB0b2tlbnM6IHtcbiAgICAgIHZhbGlkYXRlOiAoMCwgX3V0aWxzLmFzc2VydEVhY2gpKE9iamVjdC5hc3NpZ24oKCkgPT4ge30sIHtcbiAgICAgICAgdHlwZTogXCJhbnlcIlxuICAgICAgfSkpLFxuICAgICAgb3B0aW9uYWw6IHRydWVcbiAgICB9XG4gIH1cbn0pO1xuZGVmaW5lVHlwZShcIkZvckluU3RhdGVtZW50XCIsIHtcbiAgdmlzaXRvcjogW1wibGVmdFwiLCBcInJpZ2h0XCIsIFwiYm9keVwiXSxcbiAgYWxpYXNlczogW1wiU2NvcGFibGVcIiwgXCJTdGF0ZW1lbnRcIiwgXCJGb3JcIiwgXCJCbG9ja1BhcmVudFwiLCBcIkxvb3BcIiwgXCJGb3JYU3RhdGVtZW50XCJdLFxuICBmaWVsZHM6IHtcbiAgICBsZWZ0OiB7XG4gICAgICB2YWxpZGF0ZTogIXByb2Nlc3MuZW52LkJBQkVMX1RZUEVTXzhfQlJFQUtJTkcgPyAoMCwgX3V0aWxzLmFzc2VydE5vZGVUeXBlKShcIlZhcmlhYmxlRGVjbGFyYXRpb25cIiwgXCJMVmFsXCIpIDogKDAsIF91dGlscy5hc3NlcnROb2RlVHlwZSkoXCJWYXJpYWJsZURlY2xhcmF0aW9uXCIsIFwiSWRlbnRpZmllclwiLCBcIk1lbWJlckV4cHJlc3Npb25cIiwgXCJBcnJheVBhdHRlcm5cIiwgXCJPYmplY3RQYXR0ZXJuXCIsIFwiVFNBc0V4cHJlc3Npb25cIiwgXCJUU1NhdGlzZmllc0V4cHJlc3Npb25cIiwgXCJUU1R5cGVBc3NlcnRpb25cIiwgXCJUU05vbk51bGxFeHByZXNzaW9uXCIpXG4gICAgfSxcbiAgICByaWdodDoge1xuICAgICAgdmFsaWRhdGU6ICgwLCBfdXRpbHMuYXNzZXJ0Tm9kZVR5cGUpKFwiRXhwcmVzc2lvblwiKVxuICAgIH0sXG4gICAgYm9keToge1xuICAgICAgdmFsaWRhdGU6ICgwLCBfdXRpbHMuYXNzZXJ0Tm9kZVR5cGUpKFwiU3RhdGVtZW50XCIpXG4gICAgfVxuICB9XG59KTtcbmRlZmluZVR5cGUoXCJGb3JTdGF0ZW1lbnRcIiwge1xuICB2aXNpdG9yOiBbXCJpbml0XCIsIFwidGVzdFwiLCBcInVwZGF0ZVwiLCBcImJvZHlcIl0sXG4gIGFsaWFzZXM6IFtcIlNjb3BhYmxlXCIsIFwiU3RhdGVtZW50XCIsIFwiRm9yXCIsIFwiQmxvY2tQYXJlbnRcIiwgXCJMb29wXCJdLFxuICBmaWVsZHM6IHtcbiAgICBpbml0OiB7XG4gICAgICB2YWxpZGF0ZTogKDAsIF91dGlscy5hc3NlcnROb2RlVHlwZSkoXCJWYXJpYWJsZURlY2xhcmF0aW9uXCIsIFwiRXhwcmVzc2lvblwiKSxcbiAgICAgIG9wdGlvbmFsOiB0cnVlXG4gICAgfSxcbiAgICB0ZXN0OiB7XG4gICAgICB2YWxpZGF0ZTogKDAsIF91dGlscy5hc3NlcnROb2RlVHlwZSkoXCJFeHByZXNzaW9uXCIpLFxuICAgICAgb3B0aW9uYWw6IHRydWVcbiAgICB9LFxuICAgIHVwZGF0ZToge1xuICAgICAgdmFsaWRhdGU6ICgwLCBfdXRpbHMuYXNzZXJ0Tm9kZVR5cGUpKFwiRXhwcmVzc2lvblwiKSxcbiAgICAgIG9wdGlvbmFsOiB0cnVlXG4gICAgfSxcbiAgICBib2R5OiB7XG4gICAgICB2YWxpZGF0ZTogKDAsIF91dGlscy5hc3NlcnROb2RlVHlwZSkoXCJTdGF0ZW1lbnRcIilcbiAgICB9XG4gIH1cbn0pO1xuY29uc3QgZnVuY3Rpb25Db21tb24gPSAoKSA9PiAoe1xuICBwYXJhbXM6ICgwLCBfdXRpbHMudmFsaWRhdGVBcnJheU9mVHlwZSkoXCJGdW5jdGlvblBhcmFtZXRlclwiKSxcbiAgZ2VuZXJhdG9yOiB7XG4gICAgZGVmYXVsdDogZmFsc2VcbiAgfSxcbiAgYXN5bmM6IHtcbiAgICBkZWZhdWx0OiBmYWxzZVxuICB9XG59KTtcbmV4cG9ydHMuZnVuY3Rpb25Db21tb24gPSBmdW5jdGlvbkNvbW1vbjtcbmNvbnN0IGZ1bmN0aW9uVHlwZUFubm90YXRpb25Db21tb24gPSAoKSA9PiAoe1xuICByZXR1cm5UeXBlOiB7XG4gICAgdmFsaWRhdGU6ICgwLCBfdXRpbHMuYXNzZXJ0Tm9kZVR5cGUpKFwiVHlwZUFubm90YXRpb25cIiwgXCJUU1R5cGVBbm5vdGF0aW9uXCIsIFwiTm9vcFwiKSxcbiAgICBvcHRpb25hbDogdHJ1ZVxuICB9LFxuICB0eXBlUGFyYW1ldGVyczoge1xuICAgIHZhbGlkYXRlOiAoMCwgX3V0aWxzLmFzc2VydE5vZGVUeXBlKShcIlR5cGVQYXJhbWV0ZXJEZWNsYXJhdGlvblwiLCBcIlRTVHlwZVBhcmFtZXRlckRlY2xhcmF0aW9uXCIsIFwiTm9vcFwiKSxcbiAgICBvcHRpb25hbDogdHJ1ZVxuICB9XG59KTtcbmV4cG9ydHMuZnVuY3Rpb25UeXBlQW5ub3RhdGlvbkNvbW1vbiA9IGZ1bmN0aW9uVHlwZUFubm90YXRpb25Db21tb247XG5jb25zdCBmdW5jdGlvbkRlY2xhcmF0aW9uQ29tbW9uID0gKCkgPT4gT2JqZWN0LmFzc2lnbih7fSwgZnVuY3Rpb25Db21tb24oKSwge1xuICBkZWNsYXJlOiB7XG4gICAgdmFsaWRhdGU6ICgwLCBfdXRpbHMuYXNzZXJ0VmFsdWVUeXBlKShcImJvb2xlYW5cIiksXG4gICAgb3B0aW9uYWw6IHRydWVcbiAgfSxcbiAgaWQ6IHtcbiAgICB2YWxpZGF0ZTogKDAsIF91dGlscy5hc3NlcnROb2RlVHlwZSkoXCJJZGVudGlmaWVyXCIpLFxuICAgIG9wdGlvbmFsOiB0cnVlXG4gIH1cbn0pO1xuZXhwb3J0cy5mdW5jdGlvbkRlY2xhcmF0aW9uQ29tbW9uID0gZnVuY3Rpb25EZWNsYXJhdGlvbkNvbW1vbjtcbmRlZmluZVR5cGUoXCJGdW5jdGlvbkRlY2xhcmF0aW9uXCIsIHtcbiAgYnVpbGRlcjogW1wiaWRcIiwgXCJwYXJhbXNcIiwgXCJib2R5XCIsIFwiZ2VuZXJhdG9yXCIsIFwiYXN5bmNcIl0sXG4gIHZpc2l0b3I6IFtcImlkXCIsIFwidHlwZVBhcmFtZXRlcnNcIiwgXCJwYXJhbXNcIiwgXCJwcmVkaWNhdGVcIiwgXCJyZXR1cm5UeXBlXCIsIFwiYm9keVwiXSxcbiAgZmllbGRzOiBPYmplY3QuYXNzaWduKHt9LCBmdW5jdGlvbkRlY2xhcmF0aW9uQ29tbW9uKCksIGZ1bmN0aW9uVHlwZUFubm90YXRpb25Db21tb24oKSwge1xuICAgIGJvZHk6IHtcbiAgICAgIHZhbGlkYXRlOiAoMCwgX3V0aWxzLmFzc2VydE5vZGVUeXBlKShcIkJsb2NrU3RhdGVtZW50XCIpXG4gICAgfSxcbiAgICBwcmVkaWNhdGU6IHtcbiAgICAgIHZhbGlkYXRlOiAoMCwgX3V0aWxzLmFzc2VydE5vZGVUeXBlKShcIkRlY2xhcmVkUHJlZGljYXRlXCIsIFwiSW5mZXJyZWRQcmVkaWNhdGVcIiksXG4gICAgICBvcHRpb25hbDogdHJ1ZVxuICAgIH1cbiAgfSksXG4gIGFsaWFzZXM6IFtcIlNjb3BhYmxlXCIsIFwiRnVuY3Rpb25cIiwgXCJCbG9ja1BhcmVudFwiLCBcIkZ1bmN0aW9uUGFyZW50XCIsIFwiU3RhdGVtZW50XCIsIFwiUHVyZWlzaFwiLCBcIkRlY2xhcmF0aW9uXCJdLFxuICB2YWxpZGF0ZTogIXByb2Nlc3MuZW52LkJBQkVMX1RZUEVTXzhfQlJFQUtJTkcgPyB1bmRlZmluZWQgOiBmdW5jdGlvbiAoKSB7XG4gICAgY29uc3QgaWRlbnRpZmllciA9ICgwLCBfdXRpbHMuYXNzZXJ0Tm9kZVR5cGUpKFwiSWRlbnRpZmllclwiKTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKHBhcmVudCwga2V5LCBub2RlKSB7XG4gICAgICBpZiAoISgwLCBfaXMuZGVmYXVsdCkoXCJFeHBvcnREZWZhdWx0RGVjbGFyYXRpb25cIiwgcGFyZW50KSkge1xuICAgICAgICBpZGVudGlmaWVyKG5vZGUsIFwiaWRcIiwgbm9kZS5pZCk7XG4gICAgICB9XG4gICAgfTtcbiAgfSgpXG59KTtcbmRlZmluZVR5cGUoXCJGdW5jdGlvbkV4cHJlc3Npb25cIiwge1xuICBpbmhlcml0czogXCJGdW5jdGlvbkRlY2xhcmF0aW9uXCIsXG4gIGFsaWFzZXM6IFtcIlNjb3BhYmxlXCIsIFwiRnVuY3Rpb25cIiwgXCJCbG9ja1BhcmVudFwiLCBcIkZ1bmN0aW9uUGFyZW50XCIsIFwiRXhwcmVzc2lvblwiLCBcIlB1cmVpc2hcIl0sXG4gIGZpZWxkczogT2JqZWN0LmFzc2lnbih7fSwgZnVuY3Rpb25Db21tb24oKSwgZnVuY3Rpb25UeXBlQW5ub3RhdGlvbkNvbW1vbigpLCB7XG4gICAgaWQ6IHtcbiAgICAgIHZhbGlkYXRlOiAoMCwgX3V0aWxzLmFzc2VydE5vZGVUeXBlKShcIklkZW50aWZpZXJcIiksXG4gICAgICBvcHRpb25hbDogdHJ1ZVxuICAgIH0sXG4gICAgYm9keToge1xuICAgICAgdmFsaWRhdGU6ICgwLCBfdXRpbHMuYXNzZXJ0Tm9kZVR5cGUpKFwiQmxvY2tTdGF0ZW1lbnRcIilcbiAgICB9LFxuICAgIHByZWRpY2F0ZToge1xuICAgICAgdmFsaWRhdGU6ICgwLCBfdXRpbHMuYXNzZXJ0Tm9kZVR5cGUpKFwiRGVjbGFyZWRQcmVkaWNhdGVcIiwgXCJJbmZlcnJlZFByZWRpY2F0ZVwiKSxcbiAgICAgIG9wdGlvbmFsOiB0cnVlXG4gICAgfVxuICB9KVxufSk7XG5jb25zdCBwYXR0ZXJuTGlrZUNvbW1vbiA9ICgpID0+ICh7XG4gIHR5cGVBbm5vdGF0aW9uOiB7XG4gICAgdmFsaWRhdGU6ICgwLCBfdXRpbHMuYXNzZXJ0Tm9kZVR5cGUpKFwiVHlwZUFubm90YXRpb25cIiwgXCJUU1R5cGVBbm5vdGF0aW9uXCIsIFwiTm9vcFwiKSxcbiAgICBvcHRpb25hbDogdHJ1ZVxuICB9LFxuICBvcHRpb25hbDoge1xuICAgIHZhbGlkYXRlOiAoMCwgX3V0aWxzLmFzc2VydFZhbHVlVHlwZSkoXCJib29sZWFuXCIpLFxuICAgIG9wdGlvbmFsOiB0cnVlXG4gIH0sXG4gIGRlY29yYXRvcnM6IHtcbiAgICB2YWxpZGF0ZTogKDAsIF91dGlscy5hcnJheU9mVHlwZSkoXCJEZWNvcmF0b3JcIiksXG4gICAgb3B0aW9uYWw6IHRydWVcbiAgfVxufSk7XG5leHBvcnRzLnBhdHRlcm5MaWtlQ29tbW9uID0gcGF0dGVybkxpa2VDb21tb247XG5kZWZpbmVUeXBlKFwiSWRlbnRpZmllclwiLCB7XG4gIGJ1aWxkZXI6IFtcIm5hbWVcIl0sXG4gIHZpc2l0b3I6IFtcInR5cGVBbm5vdGF0aW9uXCIsIFwiZGVjb3JhdG9yc1wiXSxcbiAgYWxpYXNlczogW1wiRXhwcmVzc2lvblwiLCBcIkZ1bmN0aW9uUGFyYW1ldGVyXCIsIFwiUGF0dGVybkxpa2VcIiwgXCJMVmFsXCIsIFwiVFNFbnRpdHlOYW1lXCJdLFxuICBmaWVsZHM6IE9iamVjdC5hc3NpZ24oe30sIHBhdHRlcm5MaWtlQ29tbW9uKCksIHtcbiAgICBuYW1lOiB7XG4gICAgICB2YWxpZGF0ZTogcHJvY2Vzcy5lbnYuQkFCRUxfVFlQRVNfOF9CUkVBS0lORyA/ICgwLCBfdXRpbHMuY2hhaW4pKCgwLCBfdXRpbHMuYXNzZXJ0VmFsdWVUeXBlKShcInN0cmluZ1wiKSwgT2JqZWN0LmFzc2lnbihmdW5jdGlvbiAobm9kZSwga2V5LCB2YWwpIHtcbiAgICAgICAgaWYgKCEoMCwgX2lzVmFsaWRJZGVudGlmaWVyLmRlZmF1bHQpKHZhbCwgZmFsc2UpKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgXCIke3ZhbH1cIiBpcyBub3QgYSB2YWxpZCBpZGVudGlmaWVyIG5hbWVgKTtcbiAgICAgICAgfVxuICAgICAgfSwge1xuICAgICAgICB0eXBlOiBcInN0cmluZ1wiXG4gICAgICB9KSkgOiAoMCwgX3V0aWxzLmFzc2VydFZhbHVlVHlwZSkoXCJzdHJpbmdcIilcbiAgICB9XG4gIH0pLFxuICB2YWxpZGF0ZTogcHJvY2Vzcy5lbnYuQkFCRUxfVFlQRVNfOF9CUkVBS0lORyA/IGZ1bmN0aW9uIChwYXJlbnQsIGtleSwgbm9kZSkge1xuICAgIGNvbnN0IG1hdGNoID0gL1xcLihcXHcrKSQvLmV4ZWMoa2V5LnRvU3RyaW5nKCkpO1xuICAgIGlmICghbWF0Y2gpIHJldHVybjtcbiAgICBjb25zdCBbLCBwYXJlbnRLZXldID0gbWF0Y2g7XG4gICAgY29uc3Qgbm9uQ29tcCA9IHtcbiAgICAgIGNvbXB1dGVkOiBmYWxzZVxuICAgIH07XG4gICAgaWYgKHBhcmVudEtleSA9PT0gXCJwcm9wZXJ0eVwiKSB7XG4gICAgICBpZiAoKDAsIF9pcy5kZWZhdWx0KShcIk1lbWJlckV4cHJlc3Npb25cIiwgcGFyZW50LCBub25Db21wKSkgcmV0dXJuO1xuICAgICAgaWYgKCgwLCBfaXMuZGVmYXVsdCkoXCJPcHRpb25hbE1lbWJlckV4cHJlc3Npb25cIiwgcGFyZW50LCBub25Db21wKSkgcmV0dXJuO1xuICAgIH0gZWxzZSBpZiAocGFyZW50S2V5ID09PSBcImtleVwiKSB7XG4gICAgICBpZiAoKDAsIF9pcy5kZWZhdWx0KShcIlByb3BlcnR5XCIsIHBhcmVudCwgbm9uQ29tcCkpIHJldHVybjtcbiAgICAgIGlmICgoMCwgX2lzLmRlZmF1bHQpKFwiTWV0aG9kXCIsIHBhcmVudCwgbm9uQ29tcCkpIHJldHVybjtcbiAgICB9IGVsc2UgaWYgKHBhcmVudEtleSA9PT0gXCJleHBvcnRlZFwiKSB7XG4gICAgICBpZiAoKDAsIF9pcy5kZWZhdWx0KShcIkV4cG9ydFNwZWNpZmllclwiLCBwYXJlbnQpKSByZXR1cm47XG4gICAgfSBlbHNlIGlmIChwYXJlbnRLZXkgPT09IFwiaW1wb3J0ZWRcIikge1xuICAgICAgaWYgKCgwLCBfaXMuZGVmYXVsdCkoXCJJbXBvcnRTcGVjaWZpZXJcIiwgcGFyZW50LCB7XG4gICAgICAgIGltcG9ydGVkOiBub2RlXG4gICAgICB9KSkgcmV0dXJuO1xuICAgIH0gZWxzZSBpZiAocGFyZW50S2V5ID09PSBcIm1ldGFcIikge1xuICAgICAgaWYgKCgwLCBfaXMuZGVmYXVsdCkoXCJNZXRhUHJvcGVydHlcIiwgcGFyZW50LCB7XG4gICAgICAgIG1ldGE6IG5vZGVcbiAgICAgIH0pKSByZXR1cm47XG4gICAgfVxuICAgIGlmICgoKDAsIF9oZWxwZXJWYWxpZGF0b3JJZGVudGlmaWVyLmlzS2V5d29yZCkobm9kZS5uYW1lKSB8fCAoMCwgX2hlbHBlclZhbGlkYXRvcklkZW50aWZpZXIuaXNSZXNlcnZlZFdvcmQpKG5vZGUubmFtZSwgZmFsc2UpKSAmJiBub2RlLm5hbWUgIT09IFwidGhpc1wiKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBcIiR7bm9kZS5uYW1lfVwiIGlzIG5vdCBhIHZhbGlkIGlkZW50aWZpZXJgKTtcbiAgICB9XG4gIH0gOiB1bmRlZmluZWRcbn0pO1xuZGVmaW5lVHlwZShcIklmU3RhdGVtZW50XCIsIHtcbiAgdmlzaXRvcjogW1widGVzdFwiLCBcImNvbnNlcXVlbnRcIiwgXCJhbHRlcm5hdGVcIl0sXG4gIGFsaWFzZXM6IFtcIlN0YXRlbWVudFwiLCBcIkNvbmRpdGlvbmFsXCJdLFxuICBmaWVsZHM6IHtcbiAgICB0ZXN0OiB7XG4gICAgICB2YWxpZGF0ZTogKDAsIF91dGlscy5hc3NlcnROb2RlVHlwZSkoXCJFeHByZXNzaW9uXCIpXG4gICAgfSxcbiAgICBjb25zZXF1ZW50OiB7XG4gICAgICB2YWxpZGF0ZTogKDAsIF91dGlscy5hc3NlcnROb2RlVHlwZSkoXCJTdGF0ZW1lbnRcIilcbiAgICB9LFxuICAgIGFsdGVybmF0ZToge1xuICAgICAgb3B0aW9uYWw6IHRydWUsXG4gICAgICB2YWxpZGF0ZTogKDAsIF91dGlscy5hc3NlcnROb2RlVHlwZSkoXCJTdGF0ZW1lbnRcIilcbiAgICB9XG4gIH1cbn0pO1xuZGVmaW5lVHlwZShcIkxhYmVsZWRTdGF0ZW1lbnRcIiwge1xuICB2aXNpdG9yOiBbXCJsYWJlbFwiLCBcImJvZHlcIl0sXG4gIGFsaWFzZXM6IFtcIlN0YXRlbWVudFwiXSxcbiAgZmllbGRzOiB7XG4gICAgbGFiZWw6IHtcbiAgICAgIHZhbGlkYXRlOiAoMCwgX3V0aWxzLmFzc2VydE5vZGVUeXBlKShcIklkZW50aWZpZXJcIilcbiAgICB9LFxuICAgIGJvZHk6IHtcbiAgICAgIHZhbGlkYXRlOiAoMCwgX3V0aWxzLmFzc2VydE5vZGVUeXBlKShcIlN0YXRlbWVudFwiKVxuICAgIH1cbiAgfVxufSk7XG5kZWZpbmVUeXBlKFwiU3RyaW5nTGl0ZXJhbFwiLCB7XG4gIGJ1aWxkZXI6IFtcInZhbHVlXCJdLFxuICBmaWVsZHM6IHtcbiAgICB2YWx1ZToge1xuICAgICAgdmFsaWRhdGU6ICgwLCBfdXRpbHMuYXNzZXJ0VmFsdWVUeXBlKShcInN0cmluZ1wiKVxuICAgIH1cbiAgfSxcbiAgYWxpYXNlczogW1wiRXhwcmVzc2lvblwiLCBcIlB1cmVpc2hcIiwgXCJMaXRlcmFsXCIsIFwiSW1tdXRhYmxlXCJdXG59KTtcbmRlZmluZVR5cGUoXCJOdW1lcmljTGl0ZXJhbFwiLCB7XG4gIGJ1aWxkZXI6IFtcInZhbHVlXCJdLFxuICBkZXByZWNhdGVkQWxpYXM6IFwiTnVtYmVyTGl0ZXJhbFwiLFxuICBmaWVsZHM6IHtcbiAgICB2YWx1ZToge1xuICAgICAgdmFsaWRhdGU6ICgwLCBfdXRpbHMuY2hhaW4pKCgwLCBfdXRpbHMuYXNzZXJ0VmFsdWVUeXBlKShcIm51bWJlclwiKSwgT2JqZWN0LmFzc2lnbihmdW5jdGlvbiAobm9kZSwga2V5LCB2YWwpIHtcbiAgICAgICAgaWYgKDEgLyB2YWwgPCAwIHx8ICFOdW1iZXIuaXNGaW5pdGUodmFsKSkge1xuICAgICAgICAgIGNvbnN0IGVycm9yID0gbmV3IEVycm9yKFwiTnVtZXJpY0xpdGVyYWxzIG11c3QgYmUgbm9uLW5lZ2F0aXZlIGZpbml0ZSBudW1iZXJzLiBcIiArIGBZb3UgY2FuIHVzZSB0LnZhbHVlVG9Ob2RlKCR7dmFsfSkgaW5zdGVhZC5gKTtcbiAgICAgICAgfVxuICAgICAgfSwge1xuICAgICAgICB0eXBlOiBcIm51bWJlclwiXG4gICAgICB9KSlcbiAgICB9XG4gIH0sXG4gIGFsaWFzZXM6IFtcIkV4cHJlc3Npb25cIiwgXCJQdXJlaXNoXCIsIFwiTGl0ZXJhbFwiLCBcIkltbXV0YWJsZVwiXVxufSk7XG5kZWZpbmVUeXBlKFwiTnVsbExpdGVyYWxcIiwge1xuICBhbGlhc2VzOiBbXCJFeHByZXNzaW9uXCIsIFwiUHVyZWlzaFwiLCBcIkxpdGVyYWxcIiwgXCJJbW11dGFibGVcIl1cbn0pO1xuZGVmaW5lVHlwZShcIkJvb2xlYW5MaXRlcmFsXCIsIHtcbiAgYnVpbGRlcjogW1widmFsdWVcIl0sXG4gIGZpZWxkczoge1xuICAgIHZhbHVlOiB7XG4gICAgICB2YWxpZGF0ZTogKDAsIF91dGlscy5hc3NlcnRWYWx1ZVR5cGUpKFwiYm9vbGVhblwiKVxuICAgIH1cbiAgfSxcbiAgYWxpYXNlczogW1wiRXhwcmVzc2lvblwiLCBcIlB1cmVpc2hcIiwgXCJMaXRlcmFsXCIsIFwiSW1tdXRhYmxlXCJdXG59KTtcbmRlZmluZVR5cGUoXCJSZWdFeHBMaXRlcmFsXCIsIHtcbiAgYnVpbGRlcjogW1wicGF0dGVyblwiLCBcImZsYWdzXCJdLFxuICBkZXByZWNhdGVkQWxpYXM6IFwiUmVnZXhMaXRlcmFsXCIsXG4gIGFsaWFzZXM6IFtcIkV4cHJlc3Npb25cIiwgXCJQdXJlaXNoXCIsIFwiTGl0ZXJhbFwiXSxcbiAgZmllbGRzOiB7XG4gICAgcGF0dGVybjoge1xuICAgICAgdmFsaWRhdGU6ICgwLCBfdXRpbHMuYXNzZXJ0VmFsdWVUeXBlKShcInN0cmluZ1wiKVxuICAgIH0sXG4gICAgZmxhZ3M6IHtcbiAgICAgIHZhbGlkYXRlOiBwcm9jZXNzLmVudi5CQUJFTF9UWVBFU184X0JSRUFLSU5HID8gKDAsIF91dGlscy5jaGFpbikoKDAsIF91dGlscy5hc3NlcnRWYWx1ZVR5cGUpKFwic3RyaW5nXCIpLCBPYmplY3QuYXNzaWduKGZ1bmN0aW9uIChub2RlLCBrZXksIHZhbCkge1xuICAgICAgICBjb25zdCBpbnZhbGlkID0gL1teZGdpbXN1dnldLy5leGVjKHZhbCk7XG4gICAgICAgIGlmIChpbnZhbGlkKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgXCIke2ludmFsaWRbMF19XCIgaXMgbm90IGEgdmFsaWQgUmVnRXhwIGZsYWdgKTtcbiAgICAgICAgfVxuICAgICAgfSwge1xuICAgICAgICB0eXBlOiBcInN0cmluZ1wiXG4gICAgICB9KSkgOiAoMCwgX3V0aWxzLmFzc2VydFZhbHVlVHlwZSkoXCJzdHJpbmdcIiksXG4gICAgICBkZWZhdWx0OiBcIlwiXG4gICAgfVxuICB9XG59KTtcbmRlZmluZVR5cGUoXCJMb2dpY2FsRXhwcmVzc2lvblwiLCB7XG4gIGJ1aWxkZXI6IFtcIm9wZXJhdG9yXCIsIFwibGVmdFwiLCBcInJpZ2h0XCJdLFxuICB2aXNpdG9yOiBbXCJsZWZ0XCIsIFwicmlnaHRcIl0sXG4gIGFsaWFzZXM6IFtcIkJpbmFyeVwiLCBcIkV4cHJlc3Npb25cIl0sXG4gIGZpZWxkczoge1xuICAgIG9wZXJhdG9yOiB7XG4gICAgICB2YWxpZGF0ZTogKDAsIF91dGlscy5hc3NlcnRPbmVPZikoLi4uX2luZGV4LkxPR0lDQUxfT1BFUkFUT1JTKVxuICAgIH0sXG4gICAgbGVmdDoge1xuICAgICAgdmFsaWRhdGU6ICgwLCBfdXRpbHMuYXNzZXJ0Tm9kZVR5cGUpKFwiRXhwcmVzc2lvblwiKVxuICAgIH0sXG4gICAgcmlnaHQ6IHtcbiAgICAgIHZhbGlkYXRlOiAoMCwgX3V0aWxzLmFzc2VydE5vZGVUeXBlKShcIkV4cHJlc3Npb25cIilcbiAgICB9XG4gIH1cbn0pO1xuZGVmaW5lVHlwZShcIk1lbWJlckV4cHJlc3Npb25cIiwge1xuICBidWlsZGVyOiBbXCJvYmplY3RcIiwgXCJwcm9wZXJ0eVwiLCBcImNvbXB1dGVkXCIsIC4uLighcHJvY2Vzcy5lbnYuQkFCRUxfVFlQRVNfOF9CUkVBS0lORyA/IFtcIm9wdGlvbmFsXCJdIDogW10pXSxcbiAgdmlzaXRvcjogW1wib2JqZWN0XCIsIFwicHJvcGVydHlcIl0sXG4gIGFsaWFzZXM6IFtcIkV4cHJlc3Npb25cIiwgXCJMVmFsXCIsIFwiUGF0dGVybkxpa2VcIl0sXG4gIHVuaW9uU2hhcGU6IHtcbiAgICBkaXNjcmltaW5hdG9yOiBcImNvbXB1dGVkXCIsXG4gICAgc2hhcGVzOiBbe1xuICAgICAgbmFtZTogXCJjb21wdXRlZFwiLFxuICAgICAgdmFsdWU6IFt0cnVlXSxcbiAgICAgIHByb3BlcnRpZXM6IHtcbiAgICAgICAgcHJvcGVydHk6IHtcbiAgICAgICAgICB2YWxpZGF0ZTogKDAsIF91dGlscy5hc3NlcnROb2RlVHlwZSkoXCJFeHByZXNzaW9uXCIpXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBuYW1lOiBcIm5vbkNvbXB1dGVkXCIsXG4gICAgICB2YWx1ZTogW2ZhbHNlXSxcbiAgICAgIHByb3BlcnRpZXM6IHtcbiAgICAgICAgcHJvcGVydHk6IHtcbiAgICAgICAgICB2YWxpZGF0ZTogKDAsIF91dGlscy5hc3NlcnROb2RlVHlwZSkoXCJJZGVudGlmaWVyXCIsIFwiUHJpdmF0ZU5hbWVcIilcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1dXG4gIH0sXG4gIGZpZWxkczogT2JqZWN0LmFzc2lnbih7XG4gICAgb2JqZWN0OiB7XG4gICAgICB2YWxpZGF0ZTogKDAsIF91dGlscy5hc3NlcnROb2RlVHlwZSkoXCJFeHByZXNzaW9uXCIsIFwiU3VwZXJcIilcbiAgICB9LFxuICAgIHByb3BlcnR5OiB7XG4gICAgICB2YWxpZGF0ZTogZnVuY3Rpb24gKCkge1xuICAgICAgICBjb25zdCBub3JtYWwgPSAoMCwgX3V0aWxzLmFzc2VydE5vZGVUeXBlKShcIklkZW50aWZpZXJcIiwgXCJQcml2YXRlTmFtZVwiKTtcbiAgICAgICAgY29uc3QgY29tcHV0ZWQgPSAoMCwgX3V0aWxzLmFzc2VydE5vZGVUeXBlKShcIkV4cHJlc3Npb25cIik7XG4gICAgICAgIGNvbnN0IHZhbGlkYXRvciA9IGZ1bmN0aW9uIChub2RlLCBrZXksIHZhbCkge1xuICAgICAgICAgIGNvbnN0IHZhbGlkYXRvciA9IG5vZGUuY29tcHV0ZWQgPyBjb21wdXRlZCA6IG5vcm1hbDtcbiAgICAgICAgICB2YWxpZGF0b3Iobm9kZSwga2V5LCB2YWwpO1xuICAgICAgICB9O1xuICAgICAgICB2YWxpZGF0b3Iub25lT2ZOb2RlVHlwZXMgPSBbXCJFeHByZXNzaW9uXCIsIFwiSWRlbnRpZmllclwiLCBcIlByaXZhdGVOYW1lXCJdO1xuICAgICAgICByZXR1cm4gdmFsaWRhdG9yO1xuICAgICAgfSgpXG4gICAgfSxcbiAgICBjb21wdXRlZDoge1xuICAgICAgZGVmYXVsdDogZmFsc2VcbiAgICB9XG4gIH0sICFwcm9jZXNzLmVudi5CQUJFTF9UWVBFU184X0JSRUFLSU5HID8ge1xuICAgIG9wdGlvbmFsOiB7XG4gICAgICB2YWxpZGF0ZTogKDAsIF91dGlscy5hc3NlcnRWYWx1ZVR5cGUpKFwiYm9vbGVhblwiKSxcbiAgICAgIG9wdGlvbmFsOiB0cnVlXG4gICAgfVxuICB9IDoge30pXG59KTtcbmRlZmluZVR5cGUoXCJOZXdFeHByZXNzaW9uXCIsIHtcbiAgaW5oZXJpdHM6IFwiQ2FsbEV4cHJlc3Npb25cIlxufSk7XG5kZWZpbmVUeXBlKFwiUHJvZ3JhbVwiLCB7XG4gIHZpc2l0b3I6IFtcImRpcmVjdGl2ZXNcIiwgXCJib2R5XCJdLFxuICBidWlsZGVyOiBbXCJib2R5XCIsIFwiZGlyZWN0aXZlc1wiLCBcInNvdXJjZVR5cGVcIiwgXCJpbnRlcnByZXRlclwiXSxcbiAgZmllbGRzOiB7XG4gICAgc291cmNlVHlwZToge1xuICAgICAgdmFsaWRhdGU6ICgwLCBfdXRpbHMuYXNzZXJ0T25lT2YpKFwic2NyaXB0XCIsIFwibW9kdWxlXCIpLFxuICAgICAgZGVmYXVsdDogXCJzY3JpcHRcIlxuICAgIH0sXG4gICAgaW50ZXJwcmV0ZXI6IHtcbiAgICAgIHZhbGlkYXRlOiAoMCwgX3V0aWxzLmFzc2VydE5vZGVUeXBlKShcIkludGVycHJldGVyRGlyZWN0aXZlXCIpLFxuICAgICAgZGVmYXVsdDogbnVsbCxcbiAgICAgIG9wdGlvbmFsOiB0cnVlXG4gICAgfSxcbiAgICBkaXJlY3RpdmVzOiB7XG4gICAgICB2YWxpZGF0ZTogKDAsIF91dGlscy5hcnJheU9mVHlwZSkoXCJEaXJlY3RpdmVcIiksXG4gICAgICBkZWZhdWx0OiBbXVxuICAgIH0sXG4gICAgYm9keTogKDAsIF91dGlscy52YWxpZGF0ZUFycmF5T2ZUeXBlKShcIlN0YXRlbWVudFwiKVxuICB9LFxuICBhbGlhc2VzOiBbXCJTY29wYWJsZVwiLCBcIkJsb2NrUGFyZW50XCIsIFwiQmxvY2tcIl1cbn0pO1xuZGVmaW5lVHlwZShcIk9iamVjdEV4cHJlc3Npb25cIiwge1xuICB2aXNpdG9yOiBbXCJwcm9wZXJ0aWVzXCJdLFxuICBhbGlhc2VzOiBbXCJFeHByZXNzaW9uXCJdLFxuICBmaWVsZHM6IHtcbiAgICBwcm9wZXJ0aWVzOiAoMCwgX3V0aWxzLnZhbGlkYXRlQXJyYXlPZlR5cGUpKFwiT2JqZWN0TWV0aG9kXCIsIFwiT2JqZWN0UHJvcGVydHlcIiwgXCJTcHJlYWRFbGVtZW50XCIpXG4gIH1cbn0pO1xuZGVmaW5lVHlwZShcIk9iamVjdE1ldGhvZFwiLCBPYmplY3QuYXNzaWduKHtcbiAgYnVpbGRlcjogW1wia2luZFwiLCBcImtleVwiLCBcInBhcmFtc1wiLCBcImJvZHlcIiwgXCJjb21wdXRlZFwiLCBcImdlbmVyYXRvclwiLCBcImFzeW5jXCJdLFxuICB2aXNpdG9yOiBbXCJkZWNvcmF0b3JzXCIsIFwia2V5XCIsIFwidHlwZVBhcmFtZXRlcnNcIiwgXCJwYXJhbXNcIiwgXCJyZXR1cm5UeXBlXCIsIFwiYm9keVwiXVxufSwgY2xhc3NNZXRob2RPclByb3BlcnR5VW5pb25TaGFwZUNvbW1vbigpLCB7XG4gIGZpZWxkczogT2JqZWN0LmFzc2lnbih7fSwgZnVuY3Rpb25Db21tb24oKSwgZnVuY3Rpb25UeXBlQW5ub3RhdGlvbkNvbW1vbigpLCB7XG4gICAga2luZDogT2JqZWN0LmFzc2lnbih7XG4gICAgICB2YWxpZGF0ZTogKDAsIF91dGlscy5hc3NlcnRPbmVPZikoXCJtZXRob2RcIiwgXCJnZXRcIiwgXCJzZXRcIilcbiAgICB9LCAhcHJvY2Vzcy5lbnYuQkFCRUxfVFlQRVNfOF9CUkVBS0lORyA/IHtcbiAgICAgIGRlZmF1bHQ6IFwibWV0aG9kXCJcbiAgICB9IDoge30pLFxuICAgIGNvbXB1dGVkOiB7XG4gICAgICBkZWZhdWx0OiBmYWxzZVxuICAgIH0sXG4gICAga2V5OiB7XG4gICAgICB2YWxpZGF0ZTogZnVuY3Rpb24gKCkge1xuICAgICAgICBjb25zdCBub3JtYWwgPSAoMCwgX3V0aWxzLmFzc2VydE5vZGVUeXBlKShcIklkZW50aWZpZXJcIiwgXCJTdHJpbmdMaXRlcmFsXCIsIFwiTnVtZXJpY0xpdGVyYWxcIiwgXCJCaWdJbnRMaXRlcmFsXCIpO1xuICAgICAgICBjb25zdCBjb21wdXRlZCA9ICgwLCBfdXRpbHMuYXNzZXJ0Tm9kZVR5cGUpKFwiRXhwcmVzc2lvblwiKTtcbiAgICAgICAgY29uc3QgdmFsaWRhdG9yID0gZnVuY3Rpb24gKG5vZGUsIGtleSwgdmFsKSB7XG4gICAgICAgICAgY29uc3QgdmFsaWRhdG9yID0gbm9kZS5jb21wdXRlZCA/IGNvbXB1dGVkIDogbm9ybWFsO1xuICAgICAgICAgIHZhbGlkYXRvcihub2RlLCBrZXksIHZhbCk7XG4gICAgICAgIH07XG4gICAgICAgIHZhbGlkYXRvci5vbmVPZk5vZGVUeXBlcyA9IFtcIkV4cHJlc3Npb25cIiwgXCJJZGVudGlmaWVyXCIsIFwiU3RyaW5nTGl0ZXJhbFwiLCBcIk51bWVyaWNMaXRlcmFsXCIsIFwiQmlnSW50TGl0ZXJhbFwiXTtcbiAgICAgICAgcmV0dXJuIHZhbGlkYXRvcjtcbiAgICAgIH0oKVxuICAgIH0sXG4gICAgZGVjb3JhdG9yczoge1xuICAgICAgdmFsaWRhdGU6ICgwLCBfdXRpbHMuYXJyYXlPZlR5cGUpKFwiRGVjb3JhdG9yXCIpLFxuICAgICAgb3B0aW9uYWw6IHRydWVcbiAgICB9LFxuICAgIGJvZHk6IHtcbiAgICAgIHZhbGlkYXRlOiAoMCwgX3V0aWxzLmFzc2VydE5vZGVUeXBlKShcIkJsb2NrU3RhdGVtZW50XCIpXG4gICAgfVxuICB9KSxcbiAgYWxpYXNlczogW1wiVXNlcldoaXRlc3BhY2FibGVcIiwgXCJGdW5jdGlvblwiLCBcIlNjb3BhYmxlXCIsIFwiQmxvY2tQYXJlbnRcIiwgXCJGdW5jdGlvblBhcmVudFwiLCBcIk1ldGhvZFwiLCBcIk9iamVjdE1lbWJlclwiXVxufSkpO1xuZGVmaW5lVHlwZShcIk9iamVjdFByb3BlcnR5XCIsIHtcbiAgYnVpbGRlcjogW1wia2V5XCIsIFwidmFsdWVcIiwgXCJjb21wdXRlZFwiLCBcInNob3J0aGFuZFwiLCAuLi4oIXByb2Nlc3MuZW52LkJBQkVMX1RZUEVTXzhfQlJFQUtJTkcgPyBbXCJkZWNvcmF0b3JzXCJdIDogW10pXSxcbiAgdW5pb25TaGFwZToge1xuICAgIGRpc2NyaW1pbmF0b3I6IFwiY29tcHV0ZWRcIixcbiAgICBzaGFwZXM6IFt7XG4gICAgICBuYW1lOiBcImNvbXB1dGVkXCIsXG4gICAgICB2YWx1ZTogW3RydWVdLFxuICAgICAgcHJvcGVydGllczoge1xuICAgICAgICBrZXk6IHtcbiAgICAgICAgICB2YWxpZGF0ZTogKDAsIF91dGlscy5hc3NlcnROb2RlVHlwZSkoXCJFeHByZXNzaW9uXCIpXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBuYW1lOiBcIm5vbkNvbXB1dGVkXCIsXG4gICAgICB2YWx1ZTogW2ZhbHNlXSxcbiAgICAgIHByb3BlcnRpZXM6IHtcbiAgICAgICAga2V5OiB7XG4gICAgICAgICAgdmFsaWRhdGU6ICgwLCBfdXRpbHMuYXNzZXJ0Tm9kZVR5cGUpKFwiSWRlbnRpZmllclwiLCBcIlN0cmluZ0xpdGVyYWxcIiwgXCJOdW1lcmljTGl0ZXJhbFwiLCBcIkJpZ0ludExpdGVyYWxcIiwgXCJEZWNpbWFsTGl0ZXJhbFwiLCBcIlByaXZhdGVOYW1lXCIpXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XVxuICB9LFxuICBmaWVsZHM6IHtcbiAgICBjb21wdXRlZDoge1xuICAgICAgZGVmYXVsdDogZmFsc2VcbiAgICB9LFxuICAgIGtleToge1xuICAgICAgdmFsaWRhdGU6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgY29uc3Qgbm9ybWFsID0gKDAsIF91dGlscy5hc3NlcnROb2RlVHlwZSkoXCJJZGVudGlmaWVyXCIsIFwiU3RyaW5nTGl0ZXJhbFwiLCBcIk51bWVyaWNMaXRlcmFsXCIsIFwiQmlnSW50TGl0ZXJhbFwiLCBcIkRlY2ltYWxMaXRlcmFsXCIsIFwiUHJpdmF0ZU5hbWVcIik7XG4gICAgICAgIGNvbnN0IGNvbXB1dGVkID0gKDAsIF91dGlscy5hc3NlcnROb2RlVHlwZSkoXCJFeHByZXNzaW9uXCIpO1xuICAgICAgICBjb25zdCB2YWxpZGF0b3IgPSBPYmplY3QuYXNzaWduKGZ1bmN0aW9uIChub2RlLCBrZXksIHZhbCkge1xuICAgICAgICAgIGNvbnN0IHZhbGlkYXRvciA9IG5vZGUuY29tcHV0ZWQgPyBjb21wdXRlZCA6IG5vcm1hbDtcbiAgICAgICAgICB2YWxpZGF0b3Iobm9kZSwga2V5LCB2YWwpO1xuICAgICAgICB9LCB7XG4gICAgICAgICAgb25lT2ZOb2RlVHlwZXM6IFtcIkV4cHJlc3Npb25cIiwgXCJJZGVudGlmaWVyXCIsIFwiU3RyaW5nTGl0ZXJhbFwiLCBcIk51bWVyaWNMaXRlcmFsXCIsIFwiQmlnSW50TGl0ZXJhbFwiLCBcIkRlY2ltYWxMaXRlcmFsXCIsIFwiUHJpdmF0ZU5hbWVcIl1cbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiB2YWxpZGF0b3I7XG4gICAgICB9KClcbiAgICB9LFxuICAgIHZhbHVlOiB7XG4gICAgICB2YWxpZGF0ZTogKDAsIF91dGlscy5hc3NlcnROb2RlVHlwZSkoXCJFeHByZXNzaW9uXCIsIFwiUGF0dGVybkxpa2VcIilcbiAgICB9LFxuICAgIHNob3J0aGFuZDoge1xuICAgICAgdmFsaWRhdGU6IHByb2Nlc3MuZW52LkJBQkVMX1RZUEVTXzhfQlJFQUtJTkcgPyAoMCwgX3V0aWxzLmNoYWluKSgoMCwgX3V0aWxzLmFzc2VydFZhbHVlVHlwZSkoXCJib29sZWFuXCIpLCBPYmplY3QuYXNzaWduKGZ1bmN0aW9uIChub2RlLCBrZXksIHNob3J0aGFuZCkge1xuICAgICAgICBpZiAoIXNob3J0aGFuZCkgcmV0dXJuO1xuICAgICAgICBpZiAobm9kZS5jb21wdXRlZCkge1xuICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJQcm9wZXJ0eSBzaG9ydGhhbmQgb2YgT2JqZWN0UHJvcGVydHkgY2Fubm90IGJlIHRydWUgaWYgY29tcHV0ZWQgaXMgdHJ1ZVwiKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoISgwLCBfaXMuZGVmYXVsdCkoXCJJZGVudGlmaWVyXCIsIG5vZGUua2V5KSkge1xuICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJQcm9wZXJ0eSBzaG9ydGhhbmQgb2YgT2JqZWN0UHJvcGVydHkgY2Fubm90IGJlIHRydWUgaWYga2V5IGlzIG5vdCBhbiBJZGVudGlmaWVyXCIpO1xuICAgICAgICB9XG4gICAgICB9LCB7XG4gICAgICAgIHR5cGU6IFwiYm9vbGVhblwiXG4gICAgICB9KSkgOiAoMCwgX3V0aWxzLmFzc2VydFZhbHVlVHlwZSkoXCJib29sZWFuXCIpLFxuICAgICAgZGVmYXVsdDogZmFsc2VcbiAgICB9LFxuICAgIGRlY29yYXRvcnM6IHtcbiAgICAgIHZhbGlkYXRlOiAoMCwgX3V0aWxzLmFycmF5T2ZUeXBlKShcIkRlY29yYXRvclwiKSxcbiAgICAgIG9wdGlvbmFsOiB0cnVlXG4gICAgfVxuICB9LFxuICB2aXNpdG9yOiBbXCJkZWNvcmF0b3JzXCIsIFwia2V5XCIsIFwidmFsdWVcIl0sXG4gIGFsaWFzZXM6IFtcIlVzZXJXaGl0ZXNwYWNhYmxlXCIsIFwiUHJvcGVydHlcIiwgXCJPYmplY3RNZW1iZXJcIl0sXG4gIHZhbGlkYXRlOiAhcHJvY2Vzcy5lbnYuQkFCRUxfVFlQRVNfOF9CUkVBS0lORyA/IHVuZGVmaW5lZCA6IGZ1bmN0aW9uICgpIHtcbiAgICBjb25zdCBwYXR0ZXJuID0gKDAsIF91dGlscy5hc3NlcnROb2RlVHlwZSkoXCJJZGVudGlmaWVyXCIsIFwiUGF0dGVyblwiLCBcIlRTQXNFeHByZXNzaW9uXCIsIFwiVFNTYXRpc2ZpZXNFeHByZXNzaW9uXCIsIFwiVFNOb25OdWxsRXhwcmVzc2lvblwiLCBcIlRTVHlwZUFzc2VydGlvblwiKTtcbiAgICBjb25zdCBleHByZXNzaW9uID0gKDAsIF91dGlscy5hc3NlcnROb2RlVHlwZSkoXCJFeHByZXNzaW9uXCIpO1xuICAgIHJldHVybiBmdW5jdGlvbiAocGFyZW50LCBrZXksIG5vZGUpIHtcbiAgICAgIGNvbnN0IHZhbGlkYXRvciA9ICgwLCBfaXMuZGVmYXVsdCkoXCJPYmplY3RQYXR0ZXJuXCIsIHBhcmVudCkgPyBwYXR0ZXJuIDogZXhwcmVzc2lvbjtcbiAgICAgIHZhbGlkYXRvcihub2RlLCBcInZhbHVlXCIsIG5vZGUudmFsdWUpO1xuICAgIH07XG4gIH0oKVxufSk7XG5kZWZpbmVUeXBlKFwiUmVzdEVsZW1lbnRcIiwge1xuICB2aXNpdG9yOiBbXCJhcmd1bWVudFwiLCBcInR5cGVBbm5vdGF0aW9uXCJdLFxuICBidWlsZGVyOiBbXCJhcmd1bWVudFwiXSxcbiAgYWxpYXNlczogW1wiRnVuY3Rpb25QYXJhbWV0ZXJcIiwgXCJQYXR0ZXJuTGlrZVwiLCBcIkxWYWxcIl0sXG4gIGRlcHJlY2F0ZWRBbGlhczogXCJSZXN0UHJvcGVydHlcIixcbiAgZmllbGRzOiBPYmplY3QuYXNzaWduKHt9LCBwYXR0ZXJuTGlrZUNvbW1vbigpLCB7XG4gICAgYXJndW1lbnQ6IHtcbiAgICAgIHZhbGlkYXRlOiAhcHJvY2Vzcy5lbnYuQkFCRUxfVFlQRVNfOF9CUkVBS0lORyA/ICgwLCBfdXRpbHMuYXNzZXJ0Tm9kZVR5cGUpKFwiSWRlbnRpZmllclwiLCBcIkFycmF5UGF0dGVyblwiLCBcIk9iamVjdFBhdHRlcm5cIiwgXCJNZW1iZXJFeHByZXNzaW9uXCIsIFwiVFNBc0V4cHJlc3Npb25cIiwgXCJUU1NhdGlzZmllc0V4cHJlc3Npb25cIiwgXCJUU1R5cGVBc3NlcnRpb25cIiwgXCJUU05vbk51bGxFeHByZXNzaW9uXCIsIFwiUmVzdEVsZW1lbnRcIiwgXCJBc3NpZ25tZW50UGF0dGVyblwiKSA6ICgwLCBfdXRpbHMuYXNzZXJ0Tm9kZVR5cGUpKFwiSWRlbnRpZmllclwiLCBcIkFycmF5UGF0dGVyblwiLCBcIk9iamVjdFBhdHRlcm5cIiwgXCJNZW1iZXJFeHByZXNzaW9uXCIsIFwiVFNBc0V4cHJlc3Npb25cIiwgXCJUU1NhdGlzZmllc0V4cHJlc3Npb25cIiwgXCJUU1R5cGVBc3NlcnRpb25cIiwgXCJUU05vbk51bGxFeHByZXNzaW9uXCIpXG4gICAgfVxuICB9KSxcbiAgdmFsaWRhdGU6IHByb2Nlc3MuZW52LkJBQkVMX1RZUEVTXzhfQlJFQUtJTkcgPyBmdW5jdGlvbiAocGFyZW50LCBrZXkpIHtcbiAgICBjb25zdCBtYXRjaCA9IC8oXFx3KylcXFsoXFxkKylcXF0vLmV4ZWMoa2V5LnRvU3RyaW5nKCkpO1xuICAgIGlmICghbWF0Y2gpIHRocm93IG5ldyBFcnJvcihcIkludGVybmFsIEJhYmVsIGVycm9yOiBtYWxmb3JtZWQga2V5LlwiKTtcbiAgICBjb25zdCBbLCBsaXN0S2V5LCBpbmRleF0gPSBtYXRjaDtcbiAgICBpZiAocGFyZW50W2xpc3RLZXldLmxlbmd0aCA+ICtpbmRleCArIDEpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYFJlc3RFbGVtZW50IG11c3QgYmUgbGFzdCBlbGVtZW50IG9mICR7bGlzdEtleX1gKTtcbiAgICB9XG4gIH0gOiB1bmRlZmluZWRcbn0pO1xuZGVmaW5lVHlwZShcIlJldHVyblN0YXRlbWVudFwiLCB7XG4gIHZpc2l0b3I6IFtcImFyZ3VtZW50XCJdLFxuICBhbGlhc2VzOiBbXCJTdGF0ZW1lbnRcIiwgXCJUZXJtaW5hdG9ybGVzc1wiLCBcIkNvbXBsZXRpb25TdGF0ZW1lbnRcIl0sXG4gIGZpZWxkczoge1xuICAgIGFyZ3VtZW50OiB7XG4gICAgICB2YWxpZGF0ZTogKDAsIF91dGlscy5hc3NlcnROb2RlVHlwZSkoXCJFeHByZXNzaW9uXCIpLFxuICAgICAgb3B0aW9uYWw6IHRydWVcbiAgICB9XG4gIH1cbn0pO1xuZGVmaW5lVHlwZShcIlNlcXVlbmNlRXhwcmVzc2lvblwiLCB7XG4gIHZpc2l0b3I6IFtcImV4cHJlc3Npb25zXCJdLFxuICBmaWVsZHM6IHtcbiAgICBleHByZXNzaW9uczogKDAsIF91dGlscy52YWxpZGF0ZUFycmF5T2ZUeXBlKShcIkV4cHJlc3Npb25cIilcbiAgfSxcbiAgYWxpYXNlczogW1wiRXhwcmVzc2lvblwiXVxufSk7XG5kZWZpbmVUeXBlKFwiUGFyZW50aGVzaXplZEV4cHJlc3Npb25cIiwge1xuICB2aXNpdG9yOiBbXCJleHByZXNzaW9uXCJdLFxuICBhbGlhc2VzOiBbXCJFeHByZXNzaW9uXCIsIFwiRXhwcmVzc2lvbldyYXBwZXJcIl0sXG4gIGZpZWxkczoge1xuICAgIGV4cHJlc3Npb246IHtcbiAgICAgIHZhbGlkYXRlOiAoMCwgX3V0aWxzLmFzc2VydE5vZGVUeXBlKShcIkV4cHJlc3Npb25cIilcbiAgICB9XG4gIH1cbn0pO1xuZGVmaW5lVHlwZShcIlN3aXRjaENhc2VcIiwge1xuICB2aXNpdG9yOiBbXCJ0ZXN0XCIsIFwiY29uc2VxdWVudFwiXSxcbiAgZmllbGRzOiB7XG4gICAgdGVzdDoge1xuICAgICAgdmFsaWRhdGU6ICgwLCBfdXRpbHMuYXNzZXJ0Tm9kZVR5cGUpKFwiRXhwcmVzc2lvblwiKSxcbiAgICAgIG9wdGlvbmFsOiB0cnVlXG4gICAgfSxcbiAgICBjb25zZXF1ZW50OiAoMCwgX3V0aWxzLnZhbGlkYXRlQXJyYXlPZlR5cGUpKFwiU3RhdGVtZW50XCIpXG4gIH1cbn0pO1xuZGVmaW5lVHlwZShcIlN3aXRjaFN0YXRlbWVudFwiLCB7XG4gIHZpc2l0b3I6IFtcImRpc2NyaW1pbmFudFwiLCBcImNhc2VzXCJdLFxuICBhbGlhc2VzOiBbXCJTdGF0ZW1lbnRcIiwgXCJCbG9ja1BhcmVudFwiLCBcIlNjb3BhYmxlXCJdLFxuICBmaWVsZHM6IHtcbiAgICBkaXNjcmltaW5hbnQ6IHtcbiAgICAgIHZhbGlkYXRlOiAoMCwgX3V0aWxzLmFzc2VydE5vZGVUeXBlKShcIkV4cHJlc3Npb25cIilcbiAgICB9LFxuICAgIGNhc2VzOiAoMCwgX3V0aWxzLnZhbGlkYXRlQXJyYXlPZlR5cGUpKFwiU3dpdGNoQ2FzZVwiKVxuICB9XG59KTtcbmRlZmluZVR5cGUoXCJUaGlzRXhwcmVzc2lvblwiLCB7XG4gIGFsaWFzZXM6IFtcIkV4cHJlc3Npb25cIl1cbn0pO1xuZGVmaW5lVHlwZShcIlRocm93U3RhdGVtZW50XCIsIHtcbiAgdmlzaXRvcjogW1wiYXJndW1lbnRcIl0sXG4gIGFsaWFzZXM6IFtcIlN0YXRlbWVudFwiLCBcIlRlcm1pbmF0b3JsZXNzXCIsIFwiQ29tcGxldGlvblN0YXRlbWVudFwiXSxcbiAgZmllbGRzOiB7XG4gICAgYXJndW1lbnQ6IHtcbiAgICAgIHZhbGlkYXRlOiAoMCwgX3V0aWxzLmFzc2VydE5vZGVUeXBlKShcIkV4cHJlc3Npb25cIilcbiAgICB9XG4gIH1cbn0pO1xuZGVmaW5lVHlwZShcIlRyeVN0YXRlbWVudFwiLCB7XG4gIHZpc2l0b3I6IFtcImJsb2NrXCIsIFwiaGFuZGxlclwiLCBcImZpbmFsaXplclwiXSxcbiAgYWxpYXNlczogW1wiU3RhdGVtZW50XCJdLFxuICBmaWVsZHM6IHtcbiAgICBibG9jazoge1xuICAgICAgdmFsaWRhdGU6IHByb2Nlc3MuZW52LkJBQkVMX1RZUEVTXzhfQlJFQUtJTkcgPyAoMCwgX3V0aWxzLmNoYWluKSgoMCwgX3V0aWxzLmFzc2VydE5vZGVUeXBlKShcIkJsb2NrU3RhdGVtZW50XCIpLCBPYmplY3QuYXNzaWduKGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICAgIGlmICghbm9kZS5oYW5kbGVyICYmICFub2RlLmZpbmFsaXplcikge1xuICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJUcnlTdGF0ZW1lbnQgZXhwZWN0cyBlaXRoZXIgYSBoYW5kbGVyIG9yIGZpbmFsaXplciwgb3IgYm90aFwiKTtcbiAgICAgICAgfVxuICAgICAgfSwge1xuICAgICAgICBvbmVPZk5vZGVUeXBlczogW1wiQmxvY2tTdGF0ZW1lbnRcIl1cbiAgICAgIH0pKSA6ICgwLCBfdXRpbHMuYXNzZXJ0Tm9kZVR5cGUpKFwiQmxvY2tTdGF0ZW1lbnRcIilcbiAgICB9LFxuICAgIGhhbmRsZXI6IHtcbiAgICAgIG9wdGlvbmFsOiB0cnVlLFxuICAgICAgdmFsaWRhdGU6ICgwLCBfdXRpbHMuYXNzZXJ0Tm9kZVR5cGUpKFwiQ2F0Y2hDbGF1c2VcIilcbiAgICB9LFxuICAgIGZpbmFsaXplcjoge1xuICAgICAgb3B0aW9uYWw6IHRydWUsXG4gICAgICB2YWxpZGF0ZTogKDAsIF91dGlscy5hc3NlcnROb2RlVHlwZSkoXCJCbG9ja1N0YXRlbWVudFwiKVxuICAgIH1cbiAgfVxufSk7XG5kZWZpbmVUeXBlKFwiVW5hcnlFeHByZXNzaW9uXCIsIHtcbiAgYnVpbGRlcjogW1wib3BlcmF0b3JcIiwgXCJhcmd1bWVudFwiLCBcInByZWZpeFwiXSxcbiAgZmllbGRzOiB7XG4gICAgcHJlZml4OiB7XG4gICAgICBkZWZhdWx0OiB0cnVlXG4gICAgfSxcbiAgICBhcmd1bWVudDoge1xuICAgICAgdmFsaWRhdGU6ICgwLCBfdXRpbHMuYXNzZXJ0Tm9kZVR5cGUpKFwiRXhwcmVzc2lvblwiKVxuICAgIH0sXG4gICAgb3BlcmF0b3I6IHtcbiAgICAgIHZhbGlkYXRlOiAoMCwgX3V0aWxzLmFzc2VydE9uZU9mKSguLi5faW5kZXguVU5BUllfT1BFUkFUT1JTKVxuICAgIH1cbiAgfSxcbiAgdmlzaXRvcjogW1wiYXJndW1lbnRcIl0sXG4gIGFsaWFzZXM6IFtcIlVuYXJ5TGlrZVwiLCBcIkV4cHJlc3Npb25cIl1cbn0pO1xuZGVmaW5lVHlwZShcIlVwZGF0ZUV4cHJlc3Npb25cIiwge1xuICBidWlsZGVyOiBbXCJvcGVyYXRvclwiLCBcImFyZ3VtZW50XCIsIFwicHJlZml4XCJdLFxuICBmaWVsZHM6IHtcbiAgICBwcmVmaXg6IHtcbiAgICAgIGRlZmF1bHQ6IGZhbHNlXG4gICAgfSxcbiAgICBhcmd1bWVudDoge1xuICAgICAgdmFsaWRhdGU6ICFwcm9jZXNzLmVudi5CQUJFTF9UWVBFU184X0JSRUFLSU5HID8gKDAsIF91dGlscy5hc3NlcnROb2RlVHlwZSkoXCJFeHByZXNzaW9uXCIpIDogKDAsIF91dGlscy5hc3NlcnROb2RlVHlwZSkoXCJJZGVudGlmaWVyXCIsIFwiTWVtYmVyRXhwcmVzc2lvblwiKVxuICAgIH0sXG4gICAgb3BlcmF0b3I6IHtcbiAgICAgIHZhbGlkYXRlOiAoMCwgX3V0aWxzLmFzc2VydE9uZU9mKSguLi5faW5kZXguVVBEQVRFX09QRVJBVE9SUylcbiAgICB9XG4gIH0sXG4gIHZpc2l0b3I6IFtcImFyZ3VtZW50XCJdLFxuICBhbGlhc2VzOiBbXCJFeHByZXNzaW9uXCJdXG59KTtcbmRlZmluZVR5cGUoXCJWYXJpYWJsZURlY2xhcmF0aW9uXCIsIHtcbiAgYnVpbGRlcjogW1wia2luZFwiLCBcImRlY2xhcmF0aW9uc1wiXSxcbiAgdmlzaXRvcjogW1wiZGVjbGFyYXRpb25zXCJdLFxuICBhbGlhc2VzOiBbXCJTdGF0ZW1lbnRcIiwgXCJEZWNsYXJhdGlvblwiXSxcbiAgZmllbGRzOiB7XG4gICAgZGVjbGFyZToge1xuICAgICAgdmFsaWRhdGU6ICgwLCBfdXRpbHMuYXNzZXJ0VmFsdWVUeXBlKShcImJvb2xlYW5cIiksXG4gICAgICBvcHRpb25hbDogdHJ1ZVxuICAgIH0sXG4gICAga2luZDoge1xuICAgICAgdmFsaWRhdGU6ICgwLCBfdXRpbHMuYXNzZXJ0T25lT2YpKFwidmFyXCIsIFwibGV0XCIsIFwiY29uc3RcIiwgXCJ1c2luZ1wiLCBcImF3YWl0IHVzaW5nXCIpXG4gICAgfSxcbiAgICBkZWNsYXJhdGlvbnM6ICgwLCBfdXRpbHMudmFsaWRhdGVBcnJheU9mVHlwZSkoXCJWYXJpYWJsZURlY2xhcmF0b3JcIilcbiAgfSxcbiAgdmFsaWRhdGU6IHByb2Nlc3MuZW52LkJBQkVMX1RZUEVTXzhfQlJFQUtJTkcgPyAoKCkgPT4ge1xuICAgIGNvbnN0IHdpdGhvdXRJbml0ID0gKDAsIF91dGlscy5hc3NlcnROb2RlVHlwZSkoXCJJZGVudGlmaWVyXCIsIFwiUGxhY2Vob2xkZXJcIik7XG4gICAgY29uc3QgY29uc3RPckxldE9yVmFyID0gKDAsIF91dGlscy5hc3NlcnROb2RlVHlwZSkoXCJJZGVudGlmaWVyXCIsIFwiQXJyYXlQYXR0ZXJuXCIsIFwiT2JqZWN0UGF0dGVyblwiLCBcIlBsYWNlaG9sZGVyXCIpO1xuICAgIGNvbnN0IHVzaW5nT3JBd2FpdFVzaW5nID0gKDAsIF91dGlscy5hc3NlcnROb2RlVHlwZSkoXCJJZGVudGlmaWVyXCIsIFwiVm9pZFBhdHRlcm5cIiwgXCJQbGFjZWhvbGRlclwiKTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKHBhcmVudCwga2V5LCBub2RlKSB7XG4gICAgICBjb25zdCB7XG4gICAgICAgIGtpbmQsXG4gICAgICAgIGRlY2xhcmF0aW9uc1xuICAgICAgfSA9IG5vZGU7XG4gICAgICBjb25zdCBwYXJlbnRJc0ZvclggPSAoMCwgX2lzLmRlZmF1bHQpKFwiRm9yWFN0YXRlbWVudFwiLCBwYXJlbnQsIHtcbiAgICAgICAgbGVmdDogbm9kZVxuICAgICAgfSk7XG4gICAgICBpZiAocGFyZW50SXNGb3JYKSB7XG4gICAgICAgIGlmIChkZWNsYXJhdGlvbnMubGVuZ3RoICE9PSAxKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgRXhhY3RseSBvbmUgVmFyaWFibGVEZWNsYXJhdG9yIGlzIHJlcXVpcmVkIGluIHRoZSBWYXJpYWJsZURlY2xhcmF0aW9uIG9mIGEgJHtwYXJlbnQudHlwZX1gKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgZm9yIChjb25zdCBkZWNsIG9mIGRlY2xhcmF0aW9ucykge1xuICAgICAgICBpZiAoa2luZCA9PT0gXCJjb25zdFwiIHx8IGtpbmQgPT09IFwibGV0XCIgfHwga2luZCA9PT0gXCJ2YXJcIikge1xuICAgICAgICAgIGlmICghcGFyZW50SXNGb3JYICYmICFkZWNsLmluaXQpIHtcbiAgICAgICAgICAgIHdpdGhvdXRJbml0KGRlY2wsIFwiaWRcIiwgZGVjbC5pZCk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0T3JMZXRPclZhcihkZWNsLCBcImlkXCIsIGRlY2wuaWQpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB1c2luZ09yQXdhaXRVc2luZyhkZWNsLCBcImlkXCIsIGRlY2wuaWQpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcbiAgfSkoKSA6IHVuZGVmaW5lZFxufSk7XG5kZWZpbmVUeXBlKFwiVmFyaWFibGVEZWNsYXJhdG9yXCIsIHtcbiAgdmlzaXRvcjogW1wiaWRcIiwgXCJpbml0XCJdLFxuICBmaWVsZHM6IHtcbiAgICBpZDoge1xuICAgICAgdmFsaWRhdGU6ICFwcm9jZXNzLmVudi5CQUJFTF9UWVBFU184X0JSRUFLSU5HID8gKDAsIF91dGlscy5hc3NlcnROb2RlVHlwZSkoXCJMVmFsXCIsIFwiVm9pZFBhdHRlcm5cIikgOiAoMCwgX3V0aWxzLmFzc2VydE5vZGVUeXBlKShcIklkZW50aWZpZXJcIiwgXCJBcnJheVBhdHRlcm5cIiwgXCJPYmplY3RQYXR0ZXJuXCIsIFwiVm9pZFBhdHRlcm5cIilcbiAgICB9LFxuICAgIGRlZmluaXRlOiB7XG4gICAgICBvcHRpb25hbDogdHJ1ZSxcbiAgICAgIHZhbGlkYXRlOiAoMCwgX3V0aWxzLmFzc2VydFZhbHVlVHlwZSkoXCJib29sZWFuXCIpXG4gICAgfSxcbiAgICBpbml0OiB7XG4gICAgICBvcHRpb25hbDogdHJ1ZSxcbiAgICAgIHZhbGlkYXRlOiAoMCwgX3V0aWxzLmFzc2VydE5vZGVUeXBlKShcIkV4cHJlc3Npb25cIilcbiAgICB9XG4gIH1cbn0pO1xuZGVmaW5lVHlwZShcIldoaWxlU3RhdGVtZW50XCIsIHtcbiAgdmlzaXRvcjogW1widGVzdFwiLCBcImJvZHlcIl0sXG4gIGFsaWFzZXM6IFtcIlN0YXRlbWVudFwiLCBcIkJsb2NrUGFyZW50XCIsIFwiTG9vcFwiLCBcIldoaWxlXCIsIFwiU2NvcGFibGVcIl0sXG4gIGZpZWxkczoge1xuICAgIHRlc3Q6IHtcbiAgICAgIHZhbGlkYXRlOiAoMCwgX3V0aWxzLmFzc2VydE5vZGVUeXBlKShcIkV4cHJlc3Npb25cIilcbiAgICB9LFxuICAgIGJvZHk6IHtcbiAgICAgIHZhbGlkYXRlOiAoMCwgX3V0aWxzLmFzc2VydE5vZGVUeXBlKShcIlN0YXRlbWVudFwiKVxuICAgIH1cbiAgfVxufSk7XG5kZWZpbmVUeXBlKFwiV2l0aFN0YXRlbWVudFwiLCB7XG4gIHZpc2l0b3I6IFtcIm9iamVjdFwiLCBcImJvZHlcIl0sXG4gIGFsaWFzZXM6IFtcIlN0YXRlbWVudFwiXSxcbiAgZmllbGRzOiB7XG4gICAgb2JqZWN0OiB7XG4gICAgICB2YWxpZGF0ZTogKDAsIF91dGlscy5hc3NlcnROb2RlVHlwZSkoXCJFeHByZXNzaW9uXCIpXG4gICAgfSxcbiAgICBib2R5OiB7XG4gICAgICB2YWxpZGF0ZTogKDAsIF91dGlscy5hc3NlcnROb2RlVHlwZSkoXCJTdGF0ZW1lbnRcIilcbiAgICB9XG4gIH1cbn0pO1xuZGVmaW5lVHlwZShcIkFzc2lnbm1lbnRQYXR0ZXJuXCIsIHtcbiAgdmlzaXRvcjogW1wibGVmdFwiLCBcInJpZ2h0XCIsIFwiZGVjb3JhdG9yc1wiXSxcbiAgYnVpbGRlcjogW1wibGVmdFwiLCBcInJpZ2h0XCJdLFxuICBhbGlhc2VzOiBbXCJGdW5jdGlvblBhcmFtZXRlclwiLCBcIlBhdHRlcm5cIiwgXCJQYXR0ZXJuTGlrZVwiLCBcIkxWYWxcIl0sXG4gIGZpZWxkczogT2JqZWN0LmFzc2lnbih7fSwgcGF0dGVybkxpa2VDb21tb24oKSwge1xuICAgIGxlZnQ6IHtcbiAgICAgIHZhbGlkYXRlOiAoMCwgX3V0aWxzLmFzc2VydE5vZGVUeXBlKShcIklkZW50aWZpZXJcIiwgXCJPYmplY3RQYXR0ZXJuXCIsIFwiQXJyYXlQYXR0ZXJuXCIsIFwiTWVtYmVyRXhwcmVzc2lvblwiLCBcIlRTQXNFeHByZXNzaW9uXCIsIFwiVFNTYXRpc2ZpZXNFeHByZXNzaW9uXCIsIFwiVFNUeXBlQXNzZXJ0aW9uXCIsIFwiVFNOb25OdWxsRXhwcmVzc2lvblwiKVxuICAgIH0sXG4gICAgcmlnaHQ6IHtcbiAgICAgIHZhbGlkYXRlOiAoMCwgX3V0aWxzLmFzc2VydE5vZGVUeXBlKShcIkV4cHJlc3Npb25cIilcbiAgICB9LFxuICAgIGRlY29yYXRvcnM6IHtcbiAgICAgIHZhbGlkYXRlOiAoMCwgX3V0aWxzLmFycmF5T2ZUeXBlKShcIkRlY29yYXRvclwiKSxcbiAgICAgIG9wdGlvbmFsOiB0cnVlXG4gICAgfVxuICB9KVxufSk7XG5kZWZpbmVUeXBlKFwiQXJyYXlQYXR0ZXJuXCIsIHtcbiAgdmlzaXRvcjogW1wiZWxlbWVudHNcIiwgXCJ0eXBlQW5ub3RhdGlvblwiXSxcbiAgYnVpbGRlcjogW1wiZWxlbWVudHNcIl0sXG4gIGFsaWFzZXM6IFtcIkZ1bmN0aW9uUGFyYW1ldGVyXCIsIFwiUGF0dGVyblwiLCBcIlBhdHRlcm5MaWtlXCIsIFwiTFZhbFwiXSxcbiAgZmllbGRzOiBPYmplY3QuYXNzaWduKHt9LCBwYXR0ZXJuTGlrZUNvbW1vbigpLCB7XG4gICAgZWxlbWVudHM6IHtcbiAgICAgIHZhbGlkYXRlOiAoMCwgX3V0aWxzLmNoYWluKSgoMCwgX3V0aWxzLmFzc2VydFZhbHVlVHlwZSkoXCJhcnJheVwiKSwgKDAsIF91dGlscy5hc3NlcnRFYWNoKSgoMCwgX3V0aWxzLmFzc2VydE5vZGVPclZhbHVlVHlwZSkoXCJudWxsXCIsIFwiUGF0dGVybkxpa2VcIikpKVxuICAgIH1cbiAgfSlcbn0pO1xuZGVmaW5lVHlwZShcIkFycm93RnVuY3Rpb25FeHByZXNzaW9uXCIsIHtcbiAgYnVpbGRlcjogW1wicGFyYW1zXCIsIFwiYm9keVwiLCBcImFzeW5jXCJdLFxuICB2aXNpdG9yOiBbXCJ0eXBlUGFyYW1ldGVyc1wiLCBcInBhcmFtc1wiLCBcInByZWRpY2F0ZVwiLCBcInJldHVyblR5cGVcIiwgXCJib2R5XCJdLFxuICBhbGlhc2VzOiBbXCJTY29wYWJsZVwiLCBcIkZ1bmN0aW9uXCIsIFwiQmxvY2tQYXJlbnRcIiwgXCJGdW5jdGlvblBhcmVudFwiLCBcIkV4cHJlc3Npb25cIiwgXCJQdXJlaXNoXCJdLFxuICBmaWVsZHM6IE9iamVjdC5hc3NpZ24oe30sIGZ1bmN0aW9uQ29tbW9uKCksIGZ1bmN0aW9uVHlwZUFubm90YXRpb25Db21tb24oKSwge1xuICAgIGV4cHJlc3Npb246IHtcbiAgICAgIHZhbGlkYXRlOiAoMCwgX3V0aWxzLmFzc2VydFZhbHVlVHlwZSkoXCJib29sZWFuXCIpXG4gICAgfSxcbiAgICBib2R5OiB7XG4gICAgICB2YWxpZGF0ZTogKDAsIF91dGlscy5hc3NlcnROb2RlVHlwZSkoXCJCbG9ja1N0YXRlbWVudFwiLCBcIkV4cHJlc3Npb25cIilcbiAgICB9LFxuICAgIHByZWRpY2F0ZToge1xuICAgICAgdmFsaWRhdGU6ICgwLCBfdXRpbHMuYXNzZXJ0Tm9kZVR5cGUpKFwiRGVjbGFyZWRQcmVkaWNhdGVcIiwgXCJJbmZlcnJlZFByZWRpY2F0ZVwiKSxcbiAgICAgIG9wdGlvbmFsOiB0cnVlXG4gICAgfVxuICB9KVxufSk7XG5kZWZpbmVUeXBlKFwiQ2xhc3NCb2R5XCIsIHtcbiAgdmlzaXRvcjogW1wiYm9keVwiXSxcbiAgZmllbGRzOiB7XG4gICAgYm9keTogKDAsIF91dGlscy52YWxpZGF0ZUFycmF5T2ZUeXBlKShcIkNsYXNzTWV0aG9kXCIsIFwiQ2xhc3NQcml2YXRlTWV0aG9kXCIsIFwiQ2xhc3NQcm9wZXJ0eVwiLCBcIkNsYXNzUHJpdmF0ZVByb3BlcnR5XCIsIFwiQ2xhc3NBY2Nlc3NvclByb3BlcnR5XCIsIFwiVFNEZWNsYXJlTWV0aG9kXCIsIFwiVFNJbmRleFNpZ25hdHVyZVwiLCBcIlN0YXRpY0Jsb2NrXCIpXG4gIH1cbn0pO1xuZGVmaW5lVHlwZShcIkNsYXNzRXhwcmVzc2lvblwiLCB7XG4gIGJ1aWxkZXI6IFtcImlkXCIsIFwic3VwZXJDbGFzc1wiLCBcImJvZHlcIiwgXCJkZWNvcmF0b3JzXCJdLFxuICB2aXNpdG9yOiBbXCJkZWNvcmF0b3JzXCIsIFwiaWRcIiwgXCJ0eXBlUGFyYW1ldGVyc1wiLCBcInN1cGVyQ2xhc3NcIiwgXCJzdXBlclR5cGVQYXJhbWV0ZXJzXCIsIFwibWl4aW5zXCIsIFwiaW1wbGVtZW50c1wiLCBcImJvZHlcIl0sXG4gIGFsaWFzZXM6IFtcIlNjb3BhYmxlXCIsIFwiQ2xhc3NcIiwgXCJFeHByZXNzaW9uXCJdLFxuICBmaWVsZHM6IHtcbiAgICBpZDoge1xuICAgICAgdmFsaWRhdGU6ICgwLCBfdXRpbHMuYXNzZXJ0Tm9kZVR5cGUpKFwiSWRlbnRpZmllclwiKSxcbiAgICAgIG9wdGlvbmFsOiB0cnVlXG4gICAgfSxcbiAgICB0eXBlUGFyYW1ldGVyczoge1xuICAgICAgdmFsaWRhdGU6ICgwLCBfdXRpbHMuYXNzZXJ0Tm9kZVR5cGUpKFwiVHlwZVBhcmFtZXRlckRlY2xhcmF0aW9uXCIsIFwiVFNUeXBlUGFyYW1ldGVyRGVjbGFyYXRpb25cIiwgXCJOb29wXCIpLFxuICAgICAgb3B0aW9uYWw6IHRydWVcbiAgICB9LFxuICAgIGJvZHk6IHtcbiAgICAgIHZhbGlkYXRlOiAoMCwgX3V0aWxzLmFzc2VydE5vZGVUeXBlKShcIkNsYXNzQm9keVwiKVxuICAgIH0sXG4gICAgc3VwZXJDbGFzczoge1xuICAgICAgb3B0aW9uYWw6IHRydWUsXG4gICAgICB2YWxpZGF0ZTogKDAsIF91dGlscy5hc3NlcnROb2RlVHlwZSkoXCJFeHByZXNzaW9uXCIpXG4gICAgfSxcbiAgICBbXCJzdXBlclR5cGVQYXJhbWV0ZXJzXCJdOiB7XG4gICAgICB2YWxpZGF0ZTogKDAsIF91dGlscy5hc3NlcnROb2RlVHlwZSkoXCJUeXBlUGFyYW1ldGVySW5zdGFudGlhdGlvblwiLCBcIlRTVHlwZVBhcmFtZXRlckluc3RhbnRpYXRpb25cIiksXG4gICAgICBvcHRpb25hbDogdHJ1ZVxuICAgIH0sXG4gICAgaW1wbGVtZW50czoge1xuICAgICAgdmFsaWRhdGU6ICgwLCBfdXRpbHMuYXJyYXlPZlR5cGUpKFwiVFNFeHByZXNzaW9uV2l0aFR5cGVBcmd1bWVudHNcIiwgXCJDbGFzc0ltcGxlbWVudHNcIiksXG4gICAgICBvcHRpb25hbDogdHJ1ZVxuICAgIH0sXG4gICAgZGVjb3JhdG9yczoge1xuICAgICAgdmFsaWRhdGU6ICgwLCBfdXRpbHMuYXJyYXlPZlR5cGUpKFwiRGVjb3JhdG9yXCIpLFxuICAgICAgb3B0aW9uYWw6IHRydWVcbiAgICB9LFxuICAgIG1peGluczoge1xuICAgICAgdmFsaWRhdGU6ICgwLCBfdXRpbHMuYXNzZXJ0Tm9kZVR5cGUpKFwiSW50ZXJmYWNlRXh0ZW5kc1wiKSxcbiAgICAgIG9wdGlvbmFsOiB0cnVlXG4gICAgfVxuICB9XG59KTtcbmRlZmluZVR5cGUoXCJDbGFzc0RlY2xhcmF0aW9uXCIsIHtcbiAgaW5oZXJpdHM6IFwiQ2xhc3NFeHByZXNzaW9uXCIsXG4gIGFsaWFzZXM6IFtcIlNjb3BhYmxlXCIsIFwiQ2xhc3NcIiwgXCJTdGF0ZW1lbnRcIiwgXCJEZWNsYXJhdGlvblwiXSxcbiAgZmllbGRzOiB7XG4gICAgaWQ6IHtcbiAgICAgIHZhbGlkYXRlOiAoMCwgX3V0aWxzLmFzc2VydE5vZGVUeXBlKShcIklkZW50aWZpZXJcIiksXG4gICAgICBvcHRpb25hbDogdHJ1ZVxuICAgIH0sXG4gICAgdHlwZVBhcmFtZXRlcnM6IHtcbiAgICAgIHZhbGlkYXRlOiAoMCwgX3V0aWxzLmFzc2VydE5vZGVUeXBlKShcIlR5cGVQYXJhbWV0ZXJEZWNsYXJhdGlvblwiLCBcIlRTVHlwZVBhcmFtZXRlckRlY2xhcmF0aW9uXCIsIFwiTm9vcFwiKSxcbiAgICAgIG9wdGlvbmFsOiB0cnVlXG4gICAgfSxcbiAgICBib2R5OiB7XG4gICAgICB2YWxpZGF0ZTogKDAsIF91dGlscy5hc3NlcnROb2RlVHlwZSkoXCJDbGFzc0JvZHlcIilcbiAgICB9LFxuICAgIHN1cGVyQ2xhc3M6IHtcbiAgICAgIG9wdGlvbmFsOiB0cnVlLFxuICAgICAgdmFsaWRhdGU6ICgwLCBfdXRpbHMuYXNzZXJ0Tm9kZVR5cGUpKFwiRXhwcmVzc2lvblwiKVxuICAgIH0sXG4gICAgW1wic3VwZXJUeXBlUGFyYW1ldGVyc1wiXToge1xuICAgICAgdmFsaWRhdGU6ICgwLCBfdXRpbHMuYXNzZXJ0Tm9kZVR5cGUpKFwiVHlwZVBhcmFtZXRlckluc3RhbnRpYXRpb25cIiwgXCJUU1R5cGVQYXJhbWV0ZXJJbnN0YW50aWF0aW9uXCIpLFxuICAgICAgb3B0aW9uYWw6IHRydWVcbiAgICB9LFxuICAgIGltcGxlbWVudHM6IHtcbiAgICAgIHZhbGlkYXRlOiAoMCwgX3V0aWxzLmFycmF5T2ZUeXBlKShcIlRTRXhwcmVzc2lvbldpdGhUeXBlQXJndW1lbnRzXCIsIFwiQ2xhc3NJbXBsZW1lbnRzXCIpLFxuICAgICAgb3B0aW9uYWw6IHRydWVcbiAgICB9LFxuICAgIGRlY29yYXRvcnM6IHtcbiAgICAgIHZhbGlkYXRlOiAoMCwgX3V0aWxzLmFycmF5T2ZUeXBlKShcIkRlY29yYXRvclwiKSxcbiAgICAgIG9wdGlvbmFsOiB0cnVlXG4gICAgfSxcbiAgICBtaXhpbnM6IHtcbiAgICAgIHZhbGlkYXRlOiAoMCwgX3V0aWxzLmFzc2VydE5vZGVUeXBlKShcIkludGVyZmFjZUV4dGVuZHNcIiksXG4gICAgICBvcHRpb25hbDogdHJ1ZVxuICAgIH0sXG4gICAgZGVjbGFyZToge1xuICAgICAgdmFsaWRhdGU6ICgwLCBfdXRpbHMuYXNzZXJ0VmFsdWVUeXBlKShcImJvb2xlYW5cIiksXG4gICAgICBvcHRpb25hbDogdHJ1ZVxuICAgIH0sXG4gICAgYWJzdHJhY3Q6IHtcbiAgICAgIHZhbGlkYXRlOiAoMCwgX3V0aWxzLmFzc2VydFZhbHVlVHlwZSkoXCJib29sZWFuXCIpLFxuICAgICAgb3B0aW9uYWw6IHRydWVcbiAgICB9XG4gIH0sXG4gIHZhbGlkYXRlOiAhcHJvY2Vzcy5lbnYuQkFCRUxfVFlQRVNfOF9CUkVBS0lORyA/IHVuZGVmaW5lZCA6IGZ1bmN0aW9uICgpIHtcbiAgICBjb25zdCBpZGVudGlmaWVyID0gKDAsIF91dGlscy5hc3NlcnROb2RlVHlwZSkoXCJJZGVudGlmaWVyXCIpO1xuICAgIHJldHVybiBmdW5jdGlvbiAocGFyZW50LCBrZXksIG5vZGUpIHtcbiAgICAgIGlmICghKDAsIF9pcy5kZWZhdWx0KShcIkV4cG9ydERlZmF1bHREZWNsYXJhdGlvblwiLCBwYXJlbnQpKSB7XG4gICAgICAgIGlkZW50aWZpZXIobm9kZSwgXCJpZFwiLCBub2RlLmlkKTtcbiAgICAgIH1cbiAgICB9O1xuICB9KClcbn0pO1xuY29uc3QgaW1wb3J0QXR0cmlidXRlcyA9IGV4cG9ydHMuaW1wb3J0QXR0cmlidXRlcyA9IHtcbiAgYXR0cmlidXRlczoge1xuICAgIG9wdGlvbmFsOiB0cnVlLFxuICAgIHZhbGlkYXRlOiAoMCwgX3V0aWxzLmFycmF5T2ZUeXBlKShcIkltcG9ydEF0dHJpYnV0ZVwiKVxuICB9XG59O1xuaW1wb3J0QXR0cmlidXRlcy5hc3NlcnRpb25zID0ge1xuICBkZXByZWNhdGVkOiB0cnVlLFxuICBvcHRpb25hbDogdHJ1ZSxcbiAgdmFsaWRhdGU6ICgwLCBfdXRpbHMuYXJyYXlPZlR5cGUpKFwiSW1wb3J0QXR0cmlidXRlXCIpXG59O1xuZGVmaW5lVHlwZShcIkV4cG9ydEFsbERlY2xhcmF0aW9uXCIsIHtcbiAgYnVpbGRlcjogW1wic291cmNlXCJdLFxuICB2aXNpdG9yOiBbXCJzb3VyY2VcIiwgXCJhdHRyaWJ1dGVzXCIsIFwiYXNzZXJ0aW9uc1wiXSxcbiAgYWxpYXNlczogW1wiU3RhdGVtZW50XCIsIFwiRGVjbGFyYXRpb25cIiwgXCJJbXBvcnRPckV4cG9ydERlY2xhcmF0aW9uXCIsIFwiRXhwb3J0RGVjbGFyYXRpb25cIl0sXG4gIGZpZWxkczogT2JqZWN0LmFzc2lnbih7XG4gICAgc291cmNlOiB7XG4gICAgICB2YWxpZGF0ZTogKDAsIF91dGlscy5hc3NlcnROb2RlVHlwZSkoXCJTdHJpbmdMaXRlcmFsXCIpXG4gICAgfSxcbiAgICBleHBvcnRLaW5kOiAoMCwgX3V0aWxzLnZhbGlkYXRlT3B0aW9uYWwpKCgwLCBfdXRpbHMuYXNzZXJ0T25lT2YpKFwidHlwZVwiLCBcInZhbHVlXCIpKVxuICB9LCBpbXBvcnRBdHRyaWJ1dGVzKVxufSk7XG5kZWZpbmVUeXBlKFwiRXhwb3J0RGVmYXVsdERlY2xhcmF0aW9uXCIsIHtcbiAgdmlzaXRvcjogW1wiZGVjbGFyYXRpb25cIl0sXG4gIGFsaWFzZXM6IFtcIlN0YXRlbWVudFwiLCBcIkRlY2xhcmF0aW9uXCIsIFwiSW1wb3J0T3JFeHBvcnREZWNsYXJhdGlvblwiLCBcIkV4cG9ydERlY2xhcmF0aW9uXCJdLFxuICBmaWVsZHM6IHtcbiAgICBkZWNsYXJhdGlvbjogKDAsIF91dGlscy52YWxpZGF0ZVR5cGUpKFwiVFNEZWNsYXJlRnVuY3Rpb25cIiwgXCJGdW5jdGlvbkRlY2xhcmF0aW9uXCIsIFwiQ2xhc3NEZWNsYXJhdGlvblwiLCBcIkV4cHJlc3Npb25cIiksXG4gICAgZXhwb3J0S2luZDogKDAsIF91dGlscy52YWxpZGF0ZU9wdGlvbmFsKSgoMCwgX3V0aWxzLmFzc2VydE9uZU9mKShcInZhbHVlXCIpKVxuICB9XG59KTtcbmRlZmluZVR5cGUoXCJFeHBvcnROYW1lZERlY2xhcmF0aW9uXCIsIHtcbiAgYnVpbGRlcjogW1wiZGVjbGFyYXRpb25cIiwgXCJzcGVjaWZpZXJzXCIsIFwic291cmNlXCJdLFxuICB2aXNpdG9yOiBbXCJkZWNsYXJhdGlvblwiLCBcInNwZWNpZmllcnNcIiwgXCJzb3VyY2VcIiwgXCJhdHRyaWJ1dGVzXCIsIFwiYXNzZXJ0aW9uc1wiXSxcbiAgYWxpYXNlczogW1wiU3RhdGVtZW50XCIsIFwiRGVjbGFyYXRpb25cIiwgXCJJbXBvcnRPckV4cG9ydERlY2xhcmF0aW9uXCIsIFwiRXhwb3J0RGVjbGFyYXRpb25cIl0sXG4gIGZpZWxkczogT2JqZWN0LmFzc2lnbih7XG4gICAgZGVjbGFyYXRpb246IHtcbiAgICAgIG9wdGlvbmFsOiB0cnVlLFxuICAgICAgdmFsaWRhdGU6IHByb2Nlc3MuZW52LkJBQkVMX1RZUEVTXzhfQlJFQUtJTkcgPyAoMCwgX3V0aWxzLmNoYWluKSgoMCwgX3V0aWxzLmFzc2VydE5vZGVUeXBlKShcIkRlY2xhcmF0aW9uXCIpLCBPYmplY3QuYXNzaWduKGZ1bmN0aW9uIChub2RlLCBrZXksIHZhbCkge1xuICAgICAgICBpZiAodmFsICYmIG5vZGUuc3BlY2lmaWVycy5sZW5ndGgpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiT25seSBkZWNsYXJhdGlvbiBvciBzcGVjaWZpZXJzIGlzIGFsbG93ZWQgb24gRXhwb3J0TmFtZWREZWNsYXJhdGlvblwiKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodmFsICYmIG5vZGUuc291cmNlKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBleHBvcnQgYSBkZWNsYXJhdGlvbiBmcm9tIGEgc291cmNlXCIpO1xuICAgICAgICB9XG4gICAgICB9LCB7XG4gICAgICAgIG9uZU9mTm9kZVR5cGVzOiBbXCJEZWNsYXJhdGlvblwiXVxuICAgICAgfSkpIDogKDAsIF91dGlscy5hc3NlcnROb2RlVHlwZSkoXCJEZWNsYXJhdGlvblwiKVxuICAgIH1cbiAgfSwgaW1wb3J0QXR0cmlidXRlcywge1xuICAgIHNwZWNpZmllcnM6IHtcbiAgICAgIGRlZmF1bHQ6IFtdLFxuICAgICAgdmFsaWRhdGU6ICgwLCBfdXRpbHMuYXJyYXlPZikoZnVuY3Rpb24gKCkge1xuICAgICAgICBjb25zdCBzb3VyY2VkID0gKDAsIF91dGlscy5hc3NlcnROb2RlVHlwZSkoXCJFeHBvcnRTcGVjaWZpZXJcIiwgXCJFeHBvcnREZWZhdWx0U3BlY2lmaWVyXCIsIFwiRXhwb3J0TmFtZXNwYWNlU3BlY2lmaWVyXCIpO1xuICAgICAgICBjb25zdCBzb3VyY2VsZXNzID0gKDAsIF91dGlscy5hc3NlcnROb2RlVHlwZSkoXCJFeHBvcnRTcGVjaWZpZXJcIik7XG4gICAgICAgIGlmICghcHJvY2Vzcy5lbnYuQkFCRUxfVFlQRVNfOF9CUkVBS0lORykgcmV0dXJuIHNvdXJjZWQ7XG4gICAgICAgIHJldHVybiBPYmplY3QuYXNzaWduKGZ1bmN0aW9uIChub2RlLCBrZXksIHZhbCkge1xuICAgICAgICAgIGNvbnN0IHZhbGlkYXRvciA9IG5vZGUuc291cmNlID8gc291cmNlZCA6IHNvdXJjZWxlc3M7XG4gICAgICAgICAgdmFsaWRhdG9yKG5vZGUsIGtleSwgdmFsKTtcbiAgICAgICAgfSwge1xuICAgICAgICAgIG9uZU9mTm9kZVR5cGVzOiBbXCJFeHBvcnRTcGVjaWZpZXJcIiwgXCJFeHBvcnREZWZhdWx0U3BlY2lmaWVyXCIsIFwiRXhwb3J0TmFtZXNwYWNlU3BlY2lmaWVyXCJdXG4gICAgICAgIH0pO1xuICAgICAgfSgpKVxuICAgIH0sXG4gICAgc291cmNlOiB7XG4gICAgICB2YWxpZGF0ZTogKDAsIF91dGlscy5hc3NlcnROb2RlVHlwZSkoXCJTdHJpbmdMaXRlcmFsXCIpLFxuICAgICAgb3B0aW9uYWw6IHRydWVcbiAgICB9LFxuICAgIGV4cG9ydEtpbmQ6ICgwLCBfdXRpbHMudmFsaWRhdGVPcHRpb25hbCkoKDAsIF91dGlscy5hc3NlcnRPbmVPZikoXCJ0eXBlXCIsIFwidmFsdWVcIikpXG4gIH0pXG59KTtcbmRlZmluZVR5cGUoXCJFeHBvcnRTcGVjaWZpZXJcIiwge1xuICB2aXNpdG9yOiBbXCJsb2NhbFwiLCBcImV4cG9ydGVkXCJdLFxuICBhbGlhc2VzOiBbXCJNb2R1bGVTcGVjaWZpZXJcIl0sXG4gIGZpZWxkczoge1xuICAgIGxvY2FsOiB7XG4gICAgICB2YWxpZGF0ZTogKDAsIF91dGlscy5hc3NlcnROb2RlVHlwZSkoXCJJZGVudGlmaWVyXCIpXG4gICAgfSxcbiAgICBleHBvcnRlZDoge1xuICAgICAgdmFsaWRhdGU6ICgwLCBfdXRpbHMuYXNzZXJ0Tm9kZVR5cGUpKFwiSWRlbnRpZmllclwiLCBcIlN0cmluZ0xpdGVyYWxcIilcbiAgICB9LFxuICAgIGV4cG9ydEtpbmQ6IHtcbiAgICAgIHZhbGlkYXRlOiAoMCwgX3V0aWxzLmFzc2VydE9uZU9mKShcInR5cGVcIiwgXCJ2YWx1ZVwiKSxcbiAgICAgIG9wdGlvbmFsOiB0cnVlXG4gICAgfVxuICB9XG59KTtcbmRlZmluZVR5cGUoXCJGb3JPZlN0YXRlbWVudFwiLCB7XG4gIHZpc2l0b3I6IFtcImxlZnRcIiwgXCJyaWdodFwiLCBcImJvZHlcIl0sXG4gIGJ1aWxkZXI6IFtcImxlZnRcIiwgXCJyaWdodFwiLCBcImJvZHlcIiwgXCJhd2FpdFwiXSxcbiAgYWxpYXNlczogW1wiU2NvcGFibGVcIiwgXCJTdGF0ZW1lbnRcIiwgXCJGb3JcIiwgXCJCbG9ja1BhcmVudFwiLCBcIkxvb3BcIiwgXCJGb3JYU3RhdGVtZW50XCJdLFxuICBmaWVsZHM6IHtcbiAgICBsZWZ0OiB7XG4gICAgICB2YWxpZGF0ZTogZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoIXByb2Nlc3MuZW52LkJBQkVMX1RZUEVTXzhfQlJFQUtJTkcpIHtcbiAgICAgICAgICByZXR1cm4gKDAsIF91dGlscy5hc3NlcnROb2RlVHlwZSkoXCJWYXJpYWJsZURlY2xhcmF0aW9uXCIsIFwiTFZhbFwiKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBkZWNsYXJhdGlvbiA9ICgwLCBfdXRpbHMuYXNzZXJ0Tm9kZVR5cGUpKFwiVmFyaWFibGVEZWNsYXJhdGlvblwiKTtcbiAgICAgICAgY29uc3QgbHZhbCA9ICgwLCBfdXRpbHMuYXNzZXJ0Tm9kZVR5cGUpKFwiSWRlbnRpZmllclwiLCBcIk1lbWJlckV4cHJlc3Npb25cIiwgXCJBcnJheVBhdHRlcm5cIiwgXCJPYmplY3RQYXR0ZXJuXCIsIFwiVFNBc0V4cHJlc3Npb25cIiwgXCJUU1NhdGlzZmllc0V4cHJlc3Npb25cIiwgXCJUU1R5cGVBc3NlcnRpb25cIiwgXCJUU05vbk51bGxFeHByZXNzaW9uXCIpO1xuICAgICAgICByZXR1cm4gT2JqZWN0LmFzc2lnbihmdW5jdGlvbiAobm9kZSwga2V5LCB2YWwpIHtcbiAgICAgICAgICBpZiAoKDAsIF9pcy5kZWZhdWx0KShcIlZhcmlhYmxlRGVjbGFyYXRpb25cIiwgdmFsKSkge1xuICAgICAgICAgICAgZGVjbGFyYXRpb24obm9kZSwga2V5LCB2YWwpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBsdmFsKG5vZGUsIGtleSwgdmFsKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0sIHtcbiAgICAgICAgICBvbmVPZk5vZGVUeXBlczogW1wiVmFyaWFibGVEZWNsYXJhdGlvblwiLCBcIklkZW50aWZpZXJcIiwgXCJNZW1iZXJFeHByZXNzaW9uXCIsIFwiQXJyYXlQYXR0ZXJuXCIsIFwiT2JqZWN0UGF0dGVyblwiLCBcIlRTQXNFeHByZXNzaW9uXCIsIFwiVFNTYXRpc2ZpZXNFeHByZXNzaW9uXCIsIFwiVFNUeXBlQXNzZXJ0aW9uXCIsIFwiVFNOb25OdWxsRXhwcmVzc2lvblwiXVxuICAgICAgICB9KTtcbiAgICAgIH0oKVxuICAgIH0sXG4gICAgcmlnaHQ6IHtcbiAgICAgIHZhbGlkYXRlOiAoMCwgX3V0aWxzLmFzc2VydE5vZGVUeXBlKShcIkV4cHJlc3Npb25cIilcbiAgICB9LFxuICAgIGJvZHk6IHtcbiAgICAgIHZhbGlkYXRlOiAoMCwgX3V0aWxzLmFzc2VydE5vZGVUeXBlKShcIlN0YXRlbWVudFwiKVxuICAgIH0sXG4gICAgYXdhaXQ6IHtcbiAgICAgIGRlZmF1bHQ6IGZhbHNlXG4gICAgfVxuICB9XG59KTtcbmRlZmluZVR5cGUoXCJJbXBvcnREZWNsYXJhdGlvblwiLCB7XG4gIGJ1aWxkZXI6IFtcInNwZWNpZmllcnNcIiwgXCJzb3VyY2VcIl0sXG4gIHZpc2l0b3I6IFtcInNwZWNpZmllcnNcIiwgXCJzb3VyY2VcIiwgXCJhdHRyaWJ1dGVzXCIsIFwiYXNzZXJ0aW9uc1wiXSxcbiAgYWxpYXNlczogW1wiU3RhdGVtZW50XCIsIFwiRGVjbGFyYXRpb25cIiwgXCJJbXBvcnRPckV4cG9ydERlY2xhcmF0aW9uXCJdLFxuICBmaWVsZHM6IE9iamVjdC5hc3NpZ24oe30sIGltcG9ydEF0dHJpYnV0ZXMsIHtcbiAgICBtb2R1bGU6IHtcbiAgICAgIG9wdGlvbmFsOiB0cnVlLFxuICAgICAgdmFsaWRhdGU6ICgwLCBfdXRpbHMuYXNzZXJ0VmFsdWVUeXBlKShcImJvb2xlYW5cIilcbiAgICB9LFxuICAgIHBoYXNlOiB7XG4gICAgICBkZWZhdWx0OiBudWxsLFxuICAgICAgdmFsaWRhdGU6ICgwLCBfdXRpbHMuYXNzZXJ0T25lT2YpKFwic291cmNlXCIsIFwiZGVmZXJcIilcbiAgICB9LFxuICAgIHNwZWNpZmllcnM6ICgwLCBfdXRpbHMudmFsaWRhdGVBcnJheU9mVHlwZSkoXCJJbXBvcnRTcGVjaWZpZXJcIiwgXCJJbXBvcnREZWZhdWx0U3BlY2lmaWVyXCIsIFwiSW1wb3J0TmFtZXNwYWNlU3BlY2lmaWVyXCIpLFxuICAgIHNvdXJjZToge1xuICAgICAgdmFsaWRhdGU6ICgwLCBfdXRpbHMuYXNzZXJ0Tm9kZVR5cGUpKFwiU3RyaW5nTGl0ZXJhbFwiKVxuICAgIH0sXG4gICAgaW1wb3J0S2luZDoge1xuICAgICAgdmFsaWRhdGU6ICgwLCBfdXRpbHMuYXNzZXJ0T25lT2YpKFwidHlwZVwiLCBcInR5cGVvZlwiLCBcInZhbHVlXCIpLFxuICAgICAgb3B0aW9uYWw6IHRydWVcbiAgICB9XG4gIH0pXG59KTtcbmRlZmluZVR5cGUoXCJJbXBvcnREZWZhdWx0U3BlY2lmaWVyXCIsIHtcbiAgdmlzaXRvcjogW1wibG9jYWxcIl0sXG4gIGFsaWFzZXM6IFtcIk1vZHVsZVNwZWNpZmllclwiXSxcbiAgZmllbGRzOiB7XG4gICAgbG9jYWw6IHtcbiAgICAgIHZhbGlkYXRlOiAoMCwgX3V0aWxzLmFzc2VydE5vZGVUeXBlKShcIklkZW50aWZpZXJcIilcbiAgICB9XG4gIH1cbn0pO1xuZGVmaW5lVHlwZShcIkltcG9ydE5hbWVzcGFjZVNwZWNpZmllclwiLCB7XG4gIHZpc2l0b3I6IFtcImxvY2FsXCJdLFxuICBhbGlhc2VzOiBbXCJNb2R1bGVTcGVjaWZpZXJcIl0sXG4gIGZpZWxkczoge1xuICAgIGxvY2FsOiB7XG4gICAgICB2YWxpZGF0ZTogKDAsIF91dGlscy5hc3NlcnROb2RlVHlwZSkoXCJJZGVudGlmaWVyXCIpXG4gICAgfVxuICB9XG59KTtcbmRlZmluZVR5cGUoXCJJbXBvcnRTcGVjaWZpZXJcIiwge1xuICB2aXNpdG9yOiBbXCJpbXBvcnRlZFwiLCBcImxvY2FsXCJdLFxuICBidWlsZGVyOiBbXCJsb2NhbFwiLCBcImltcG9ydGVkXCJdLFxuICBhbGlhc2VzOiBbXCJNb2R1bGVTcGVjaWZpZXJcIl0sXG4gIGZpZWxkczoge1xuICAgIGxvY2FsOiB7XG4gICAgICB2YWxpZGF0ZTogKDAsIF91dGlscy5hc3NlcnROb2RlVHlwZSkoXCJJZGVudGlmaWVyXCIpXG4gICAgfSxcbiAgICBpbXBvcnRlZDoge1xuICAgICAgdmFsaWRhdGU6ICgwLCBfdXRpbHMuYXNzZXJ0Tm9kZVR5cGUpKFwiSWRlbnRpZmllclwiLCBcIlN0cmluZ0xpdGVyYWxcIilcbiAgICB9LFxuICAgIGltcG9ydEtpbmQ6IHtcbiAgICAgIHZhbGlkYXRlOiAoMCwgX3V0aWxzLmFzc2VydE9uZU9mKShcInR5cGVcIiwgXCJ0eXBlb2ZcIiwgXCJ2YWx1ZVwiKSxcbiAgICAgIG9wdGlvbmFsOiB0cnVlXG4gICAgfVxuICB9XG59KTtcbmRlZmluZVR5cGUoXCJJbXBvcnRFeHByZXNzaW9uXCIsIHtcbiAgdmlzaXRvcjogW1wic291cmNlXCIsIFwib3B0aW9uc1wiXSxcbiAgYWxpYXNlczogW1wiRXhwcmVzc2lvblwiXSxcbiAgZmllbGRzOiB7XG4gICAgcGhhc2U6IHtcbiAgICAgIGRlZmF1bHQ6IG51bGwsXG4gICAgICB2YWxpZGF0ZTogKDAsIF91dGlscy5hc3NlcnRPbmVPZikoXCJzb3VyY2VcIiwgXCJkZWZlclwiKVxuICAgIH0sXG4gICAgc291cmNlOiB7XG4gICAgICB2YWxpZGF0ZTogKDAsIF91dGlscy5hc3NlcnROb2RlVHlwZSkoXCJFeHByZXNzaW9uXCIpXG4gICAgfSxcbiAgICBvcHRpb25zOiB7XG4gICAgICB2YWxpZGF0ZTogKDAsIF91dGlscy5hc3NlcnROb2RlVHlwZSkoXCJFeHByZXNzaW9uXCIpLFxuICAgICAgb3B0aW9uYWw6IHRydWVcbiAgICB9XG4gIH1cbn0pO1xuZGVmaW5lVHlwZShcIk1ldGFQcm9wZXJ0eVwiLCB7XG4gIHZpc2l0b3I6IFtcIm1ldGFcIiwgXCJwcm9wZXJ0eVwiXSxcbiAgYWxpYXNlczogW1wiRXhwcmVzc2lvblwiXSxcbiAgZmllbGRzOiB7XG4gICAgbWV0YToge1xuICAgICAgdmFsaWRhdGU6IHByb2Nlc3MuZW52LkJBQkVMX1RZUEVTXzhfQlJFQUtJTkcgPyAoMCwgX3V0aWxzLmNoYWluKSgoMCwgX3V0aWxzLmFzc2VydE5vZGVUeXBlKShcIklkZW50aWZpZXJcIiksIE9iamVjdC5hc3NpZ24oZnVuY3Rpb24gKG5vZGUsIGtleSwgdmFsKSB7XG4gICAgICAgIGxldCBwcm9wZXJ0eTtcbiAgICAgICAgc3dpdGNoICh2YWwubmFtZSkge1xuICAgICAgICAgIGNhc2UgXCJmdW5jdGlvblwiOlxuICAgICAgICAgICAgcHJvcGVydHkgPSBcInNlbnRcIjtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgXCJuZXdcIjpcbiAgICAgICAgICAgIHByb3BlcnR5ID0gXCJ0YXJnZXRcIjtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgXCJpbXBvcnRcIjpcbiAgICAgICAgICAgIHByb3BlcnR5ID0gXCJtZXRhXCI7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBpZiAoISgwLCBfaXMuZGVmYXVsdCkoXCJJZGVudGlmaWVyXCIsIG5vZGUucHJvcGVydHksIHtcbiAgICAgICAgICBuYW1lOiBwcm9wZXJ0eVxuICAgICAgICB9KSkge1xuICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJVbnJlY29nbmlzZWQgTWV0YVByb3BlcnR5XCIpO1xuICAgICAgICB9XG4gICAgICB9LCB7XG4gICAgICAgIG9uZU9mTm9kZVR5cGVzOiBbXCJJZGVudGlmaWVyXCJdXG4gICAgICB9KSkgOiAoMCwgX3V0aWxzLmFzc2VydE5vZGVUeXBlKShcIklkZW50aWZpZXJcIilcbiAgICB9LFxuICAgIHByb3BlcnR5OiB7XG4gICAgICB2YWxpZGF0ZTogKDAsIF91dGlscy5hc3NlcnROb2RlVHlwZSkoXCJJZGVudGlmaWVyXCIpXG4gICAgfVxuICB9XG59KTtcbmNvbnN0IGNsYXNzTWV0aG9kT3JQcm9wZXJ0eUNvbW1vbiA9ICgpID0+ICh7XG4gIGFic3RyYWN0OiB7XG4gICAgdmFsaWRhdGU6ICgwLCBfdXRpbHMuYXNzZXJ0VmFsdWVUeXBlKShcImJvb2xlYW5cIiksXG4gICAgb3B0aW9uYWw6IHRydWVcbiAgfSxcbiAgYWNjZXNzaWJpbGl0eToge1xuICAgIHZhbGlkYXRlOiAoMCwgX3V0aWxzLmFzc2VydE9uZU9mKShcInB1YmxpY1wiLCBcInByaXZhdGVcIiwgXCJwcm90ZWN0ZWRcIiksXG4gICAgb3B0aW9uYWw6IHRydWVcbiAgfSxcbiAgc3RhdGljOiB7XG4gICAgZGVmYXVsdDogZmFsc2VcbiAgfSxcbiAgb3ZlcnJpZGU6IHtcbiAgICBkZWZhdWx0OiBmYWxzZVxuICB9LFxuICBjb21wdXRlZDoge1xuICAgIGRlZmF1bHQ6IGZhbHNlXG4gIH0sXG4gIG9wdGlvbmFsOiB7XG4gICAgdmFsaWRhdGU6ICgwLCBfdXRpbHMuYXNzZXJ0VmFsdWVUeXBlKShcImJvb2xlYW5cIiksXG4gICAgb3B0aW9uYWw6IHRydWVcbiAgfSxcbiAga2V5OiB7XG4gICAgdmFsaWRhdGU6ICgwLCBfdXRpbHMuY2hhaW4pKGZ1bmN0aW9uICgpIHtcbiAgICAgIGNvbnN0IG5vcm1hbCA9ICgwLCBfdXRpbHMuYXNzZXJ0Tm9kZVR5cGUpKFwiSWRlbnRpZmllclwiLCBcIlN0cmluZ0xpdGVyYWxcIiwgXCJOdW1lcmljTGl0ZXJhbFwiLCBcIkJpZ0ludExpdGVyYWxcIik7XG4gICAgICBjb25zdCBjb21wdXRlZCA9ICgwLCBfdXRpbHMuYXNzZXJ0Tm9kZVR5cGUpKFwiRXhwcmVzc2lvblwiKTtcbiAgICAgIHJldHVybiBmdW5jdGlvbiAobm9kZSwga2V5LCB2YWwpIHtcbiAgICAgICAgY29uc3QgdmFsaWRhdG9yID0gbm9kZS5jb21wdXRlZCA/IGNvbXB1dGVkIDogbm9ybWFsO1xuICAgICAgICB2YWxpZGF0b3Iobm9kZSwga2V5LCB2YWwpO1xuICAgICAgfTtcbiAgICB9KCksICgwLCBfdXRpbHMuYXNzZXJ0Tm9kZVR5cGUpKFwiSWRlbnRpZmllclwiLCBcIlN0cmluZ0xpdGVyYWxcIiwgXCJOdW1lcmljTGl0ZXJhbFwiLCBcIkJpZ0ludExpdGVyYWxcIiwgXCJFeHByZXNzaW9uXCIpKVxuICB9XG59KTtcbmV4cG9ydHMuY2xhc3NNZXRob2RPclByb3BlcnR5Q29tbW9uID0gY2xhc3NNZXRob2RPclByb3BlcnR5Q29tbW9uO1xuY29uc3QgY2xhc3NNZXRob2RPckRlY2xhcmVNZXRob2RDb21tb24gPSAoKSA9PiBPYmplY3QuYXNzaWduKHt9LCBmdW5jdGlvbkNvbW1vbigpLCBjbGFzc01ldGhvZE9yUHJvcGVydHlDb21tb24oKSwge1xuICBwYXJhbXM6ICgwLCBfdXRpbHMudmFsaWRhdGVBcnJheU9mVHlwZSkoXCJGdW5jdGlvblBhcmFtZXRlclwiLCBcIlRTUGFyYW1ldGVyUHJvcGVydHlcIiksXG4gIGtpbmQ6IHtcbiAgICB2YWxpZGF0ZTogKDAsIF91dGlscy5hc3NlcnRPbmVPZikoXCJnZXRcIiwgXCJzZXRcIiwgXCJtZXRob2RcIiwgXCJjb25zdHJ1Y3RvclwiKSxcbiAgICBkZWZhdWx0OiBcIm1ldGhvZFwiXG4gIH0sXG4gIGFjY2Vzczoge1xuICAgIHZhbGlkYXRlOiAoMCwgX3V0aWxzLmNoYWluKSgoMCwgX3V0aWxzLmFzc2VydFZhbHVlVHlwZSkoXCJzdHJpbmdcIiksICgwLCBfdXRpbHMuYXNzZXJ0T25lT2YpKFwicHVibGljXCIsIFwicHJpdmF0ZVwiLCBcInByb3RlY3RlZFwiKSksXG4gICAgb3B0aW9uYWw6IHRydWVcbiAgfSxcbiAgZGVjb3JhdG9yczoge1xuICAgIHZhbGlkYXRlOiAoMCwgX3V0aWxzLmFycmF5T2ZUeXBlKShcIkRlY29yYXRvclwiKSxcbiAgICBvcHRpb25hbDogdHJ1ZVxuICB9XG59KTtcbmV4cG9ydHMuY2xhc3NNZXRob2RPckRlY2xhcmVNZXRob2RDb21tb24gPSBjbGFzc01ldGhvZE9yRGVjbGFyZU1ldGhvZENvbW1vbjtcbmRlZmluZVR5cGUoXCJDbGFzc01ldGhvZFwiLCBPYmplY3QuYXNzaWduKHtcbiAgYWxpYXNlczogW1wiRnVuY3Rpb25cIiwgXCJTY29wYWJsZVwiLCBcIkJsb2NrUGFyZW50XCIsIFwiRnVuY3Rpb25QYXJlbnRcIiwgXCJNZXRob2RcIl0sXG4gIGJ1aWxkZXI6IFtcImtpbmRcIiwgXCJrZXlcIiwgXCJwYXJhbXNcIiwgXCJib2R5XCIsIFwiY29tcHV0ZWRcIiwgXCJzdGF0aWNcIiwgXCJnZW5lcmF0b3JcIiwgXCJhc3luY1wiXSxcbiAgdmlzaXRvcjogW1wiZGVjb3JhdG9yc1wiLCBcImtleVwiLCBcInR5cGVQYXJhbWV0ZXJzXCIsIFwicGFyYW1zXCIsIFwicmV0dXJuVHlwZVwiLCBcImJvZHlcIl1cbn0sIGNsYXNzTWV0aG9kT3JQcm9wZXJ0eVVuaW9uU2hhcGVDb21tb24oKSwge1xuICBmaWVsZHM6IE9iamVjdC5hc3NpZ24oe30sIGNsYXNzTWV0aG9kT3JEZWNsYXJlTWV0aG9kQ29tbW9uKCksIGZ1bmN0aW9uVHlwZUFubm90YXRpb25Db21tb24oKSwge1xuICAgIGJvZHk6IHtcbiAgICAgIHZhbGlkYXRlOiAoMCwgX3V0aWxzLmFzc2VydE5vZGVUeXBlKShcIkJsb2NrU3RhdGVtZW50XCIpXG4gICAgfVxuICB9KVxufSkpO1xuZGVmaW5lVHlwZShcIk9iamVjdFBhdHRlcm5cIiwge1xuICB2aXNpdG9yOiBbXCJkZWNvcmF0b3JzXCIsIFwicHJvcGVydGllc1wiLCBcInR5cGVBbm5vdGF0aW9uXCJdLFxuICBidWlsZGVyOiBbXCJwcm9wZXJ0aWVzXCJdLFxuICBhbGlhc2VzOiBbXCJGdW5jdGlvblBhcmFtZXRlclwiLCBcIlBhdHRlcm5cIiwgXCJQYXR0ZXJuTGlrZVwiLCBcIkxWYWxcIl0sXG4gIGZpZWxkczogT2JqZWN0LmFzc2lnbih7fSwgcGF0dGVybkxpa2VDb21tb24oKSwge1xuICAgIHByb3BlcnRpZXM6ICgwLCBfdXRpbHMudmFsaWRhdGVBcnJheU9mVHlwZSkoXCJSZXN0RWxlbWVudFwiLCBcIk9iamVjdFByb3BlcnR5XCIpXG4gIH0pXG59KTtcbmRlZmluZVR5cGUoXCJTcHJlYWRFbGVtZW50XCIsIHtcbiAgdmlzaXRvcjogW1wiYXJndW1lbnRcIl0sXG4gIGFsaWFzZXM6IFtcIlVuYXJ5TGlrZVwiXSxcbiAgZGVwcmVjYXRlZEFsaWFzOiBcIlNwcmVhZFByb3BlcnR5XCIsXG4gIGZpZWxkczoge1xuICAgIGFyZ3VtZW50OiB7XG4gICAgICB2YWxpZGF0ZTogKDAsIF91dGlscy5hc3NlcnROb2RlVHlwZSkoXCJFeHByZXNzaW9uXCIpXG4gICAgfVxuICB9XG59KTtcbmRlZmluZVR5cGUoXCJTdXBlclwiLCB7XG4gIGFsaWFzZXM6IFtcIkV4cHJlc3Npb25cIl1cbn0pO1xuZGVmaW5lVHlwZShcIlRhZ2dlZFRlbXBsYXRlRXhwcmVzc2lvblwiLCB7XG4gIHZpc2l0b3I6IFtcInRhZ1wiLCBcInR5cGVQYXJhbWV0ZXJzXCIsIFwicXVhc2lcIl0sXG4gIGJ1aWxkZXI6IFtcInRhZ1wiLCBcInF1YXNpXCJdLFxuICBhbGlhc2VzOiBbXCJFeHByZXNzaW9uXCJdLFxuICBmaWVsZHM6IHtcbiAgICB0YWc6IHtcbiAgICAgIHZhbGlkYXRlOiAoMCwgX3V0aWxzLmFzc2VydE5vZGVUeXBlKShcIkV4cHJlc3Npb25cIilcbiAgICB9LFxuICAgIHF1YXNpOiB7XG4gICAgICB2YWxpZGF0ZTogKDAsIF91dGlscy5hc3NlcnROb2RlVHlwZSkoXCJUZW1wbGF0ZUxpdGVyYWxcIilcbiAgICB9LFxuICAgIFtcInR5cGVQYXJhbWV0ZXJzXCJdOiB7XG4gICAgICB2YWxpZGF0ZTogKDAsIF91dGlscy5hc3NlcnROb2RlVHlwZSkoXCJUeXBlUGFyYW1ldGVySW5zdGFudGlhdGlvblwiLCBcIlRTVHlwZVBhcmFtZXRlckluc3RhbnRpYXRpb25cIiksXG4gICAgICBvcHRpb25hbDogdHJ1ZVxuICAgIH1cbiAgfVxufSk7XG5kZWZpbmVUeXBlKFwiVGVtcGxhdGVFbGVtZW50XCIsIHtcbiAgYnVpbGRlcjogW1widmFsdWVcIiwgXCJ0YWlsXCJdLFxuICBmaWVsZHM6IHtcbiAgICB2YWx1ZToge1xuICAgICAgdmFsaWRhdGU6ICgwLCBfdXRpbHMuY2hhaW4pKCgwLCBfdXRpbHMuYXNzZXJ0U2hhcGUpKHtcbiAgICAgICAgcmF3OiB7XG4gICAgICAgICAgdmFsaWRhdGU6ICgwLCBfdXRpbHMuYXNzZXJ0VmFsdWVUeXBlKShcInN0cmluZ1wiKVxuICAgICAgICB9LFxuICAgICAgICBjb29rZWQ6IHtcbiAgICAgICAgICB2YWxpZGF0ZTogKDAsIF91dGlscy5hc3NlcnRWYWx1ZVR5cGUpKFwic3RyaW5nXCIpLFxuICAgICAgICAgIG9wdGlvbmFsOiB0cnVlXG4gICAgICAgIH1cbiAgICAgIH0pLCBmdW5jdGlvbiB0ZW1wbGF0ZUVsZW1lbnRDb29rZWRWYWxpZGF0b3Iobm9kZSkge1xuICAgICAgICBjb25zdCByYXcgPSBub2RlLnZhbHVlLnJhdztcbiAgICAgICAgbGV0IHVudGVybWluYXRlZENhbGxlZCA9IGZhbHNlO1xuICAgICAgICBjb25zdCBlcnJvciA9ICgpID0+IHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnRlcm5hbCBAYmFiZWwvdHlwZXMgZXJyb3IuXCIpO1xuICAgICAgICB9O1xuICAgICAgICBjb25zdCB7XG4gICAgICAgICAgc3RyLFxuICAgICAgICAgIGZpcnN0SW52YWxpZExvY1xuICAgICAgICB9ID0gKDAsIF9oZWxwZXJTdHJpbmdQYXJzZXIucmVhZFN0cmluZ0NvbnRlbnRzKShcInRlbXBsYXRlXCIsIHJhdywgMCwgMCwgMCwge1xuICAgICAgICAgIHVudGVybWluYXRlZCgpIHtcbiAgICAgICAgICAgIHVudGVybWluYXRlZENhbGxlZCA9IHRydWU7XG4gICAgICAgICAgfSxcbiAgICAgICAgICBzdHJpY3ROdW1lcmljRXNjYXBlOiBlcnJvcixcbiAgICAgICAgICBpbnZhbGlkRXNjYXBlU2VxdWVuY2U6IGVycm9yLFxuICAgICAgICAgIG51bWVyaWNTZXBhcmF0b3JJbkVzY2FwZVNlcXVlbmNlOiBlcnJvcixcbiAgICAgICAgICB1bmV4cGVjdGVkTnVtZXJpY1NlcGFyYXRvcjogZXJyb3IsXG4gICAgICAgICAgaW52YWxpZERpZ2l0OiBlcnJvcixcbiAgICAgICAgICBpbnZhbGlkQ29kZVBvaW50OiBlcnJvclxuICAgICAgICB9KTtcbiAgICAgICAgaWYgKCF1bnRlcm1pbmF0ZWRDYWxsZWQpIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgcmF3XCIpO1xuICAgICAgICBub2RlLnZhbHVlLmNvb2tlZCA9IGZpcnN0SW52YWxpZExvYyA/IG51bGwgOiBzdHI7XG4gICAgICB9KVxuICAgIH0sXG4gICAgdGFpbDoge1xuICAgICAgZGVmYXVsdDogZmFsc2VcbiAgICB9XG4gIH1cbn0pO1xuZGVmaW5lVHlwZShcIlRlbXBsYXRlTGl0ZXJhbFwiLCB7XG4gIHZpc2l0b3I6IFtcInF1YXNpc1wiLCBcImV4cHJlc3Npb25zXCJdLFxuICBhbGlhc2VzOiBbXCJFeHByZXNzaW9uXCIsIFwiTGl0ZXJhbFwiXSxcbiAgZmllbGRzOiB7XG4gICAgcXVhc2lzOiAoMCwgX3V0aWxzLnZhbGlkYXRlQXJyYXlPZlR5cGUpKFwiVGVtcGxhdGVFbGVtZW50XCIpLFxuICAgIGV4cHJlc3Npb25zOiB7XG4gICAgICB2YWxpZGF0ZTogKDAsIF91dGlscy5jaGFpbikoKDAsIF91dGlscy5hc3NlcnRWYWx1ZVR5cGUpKFwiYXJyYXlcIiksICgwLCBfdXRpbHMuYXNzZXJ0RWFjaCkoKDAsIF91dGlscy5hc3NlcnROb2RlVHlwZSkoXCJFeHByZXNzaW9uXCIsIFwiVFNUeXBlXCIpKSwgZnVuY3Rpb24gKG5vZGUsIGtleSwgdmFsKSB7XG4gICAgICAgIGlmIChub2RlLnF1YXNpcy5sZW5ndGggIT09IHZhbC5sZW5ndGggKyAxKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgTnVtYmVyIG9mICR7bm9kZS50eXBlfSBxdWFzaXMgc2hvdWxkIGJlIGV4YWN0bHkgb25lIG1vcmUgdGhhbiB0aGUgbnVtYmVyIG9mIGV4cHJlc3Npb25zLlxcbkV4cGVjdGVkICR7dmFsLmxlbmd0aCArIDF9IHF1YXNpcyBidXQgZ290ICR7bm9kZS5xdWFzaXMubGVuZ3RofWApO1xuICAgICAgICB9XG4gICAgICB9KVxuICAgIH1cbiAgfVxufSk7XG5kZWZpbmVUeXBlKFwiWWllbGRFeHByZXNzaW9uXCIsIHtcbiAgYnVpbGRlcjogW1wiYXJndW1lbnRcIiwgXCJkZWxlZ2F0ZVwiXSxcbiAgdmlzaXRvcjogW1wiYXJndW1lbnRcIl0sXG4gIGFsaWFzZXM6IFtcIkV4cHJlc3Npb25cIiwgXCJUZXJtaW5hdG9ybGVzc1wiXSxcbiAgZmllbGRzOiB7XG4gICAgZGVsZWdhdGU6IHtcbiAgICAgIHZhbGlkYXRlOiBwcm9jZXNzLmVudi5CQUJFTF9UWVBFU184X0JSRUFLSU5HID8gKDAsIF91dGlscy5jaGFpbikoKDAsIF91dGlscy5hc3NlcnRWYWx1ZVR5cGUpKFwiYm9vbGVhblwiKSwgT2JqZWN0LmFzc2lnbihmdW5jdGlvbiAobm9kZSwga2V5LCB2YWwpIHtcbiAgICAgICAgaWYgKHZhbCAmJiAhbm9kZS5hcmd1bWVudCkge1xuICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJQcm9wZXJ0eSBkZWxlZ2F0ZSBvZiBZaWVsZEV4cHJlc3Npb24gY2Fubm90IGJlIHRydWUgaWYgdGhlcmUgaXMgbm8gYXJndW1lbnRcIik7XG4gICAgICAgIH1cbiAgICAgIH0sIHtcbiAgICAgICAgdHlwZTogXCJib29sZWFuXCJcbiAgICAgIH0pKSA6ICgwLCBfdXRpbHMuYXNzZXJ0VmFsdWVUeXBlKShcImJvb2xlYW5cIiksXG4gICAgICBkZWZhdWx0OiBmYWxzZVxuICAgIH0sXG4gICAgYXJndW1lbnQ6IHtcbiAgICAgIG9wdGlvbmFsOiB0cnVlLFxuICAgICAgdmFsaWRhdGU6ICgwLCBfdXRpbHMuYXNzZXJ0Tm9kZVR5cGUpKFwiRXhwcmVzc2lvblwiKVxuICAgIH1cbiAgfVxufSk7XG5kZWZpbmVUeXBlKFwiQXdhaXRFeHByZXNzaW9uXCIsIHtcbiAgYnVpbGRlcjogW1wiYXJndW1lbnRcIl0sXG4gIHZpc2l0b3I6IFtcImFyZ3VtZW50XCJdLFxuICBhbGlhc2VzOiBbXCJFeHByZXNzaW9uXCIsIFwiVGVybWluYXRvcmxlc3NcIl0sXG4gIGZpZWxkczoge1xuICAgIGFyZ3VtZW50OiB7XG4gICAgICB2YWxpZGF0ZTogKDAsIF91dGlscy5hc3NlcnROb2RlVHlwZSkoXCJFeHByZXNzaW9uXCIpXG4gICAgfVxuICB9XG59KTtcbmRlZmluZVR5cGUoXCJJbXBvcnRcIiwge1xuICBhbGlhc2VzOiBbXCJFeHByZXNzaW9uXCJdXG59KTtcbmRlZmluZVR5cGUoXCJCaWdJbnRMaXRlcmFsXCIsIHtcbiAgYnVpbGRlcjogW1widmFsdWVcIl0sXG4gIGZpZWxkczoge1xuICAgIHZhbHVlOiB7XG4gICAgICB2YWxpZGF0ZTogKDAsIF91dGlscy5hc3NlcnRWYWx1ZVR5cGUpKFwic3RyaW5nXCIpXG4gICAgfVxuICB9LFxuICBhbGlhc2VzOiBbXCJFeHByZXNzaW9uXCIsIFwiUHVyZWlzaFwiLCBcIkxpdGVyYWxcIiwgXCJJbW11dGFibGVcIl1cbn0pO1xuZGVmaW5lVHlwZShcIkV4cG9ydE5hbWVzcGFjZVNwZWNpZmllclwiLCB7XG4gIHZpc2l0b3I6IFtcImV4cG9ydGVkXCJdLFxuICBhbGlhc2VzOiBbXCJNb2R1bGVTcGVjaWZpZXJcIl0sXG4gIGZpZWxkczoge1xuICAgIGV4cG9ydGVkOiB7XG4gICAgICB2YWxpZGF0ZTogKDAsIF91dGlscy5hc3NlcnROb2RlVHlwZSkoXCJJZGVudGlmaWVyXCIpXG4gICAgfVxuICB9XG59KTtcbmRlZmluZVR5cGUoXCJPcHRpb25hbE1lbWJlckV4cHJlc3Npb25cIiwge1xuICBidWlsZGVyOiBbXCJvYmplY3RcIiwgXCJwcm9wZXJ0eVwiLCBcImNvbXB1dGVkXCIsIFwib3B0aW9uYWxcIl0sXG4gIHZpc2l0b3I6IFtcIm9iamVjdFwiLCBcInByb3BlcnR5XCJdLFxuICBhbGlhc2VzOiBbXCJFeHByZXNzaW9uXCJdLFxuICBmaWVsZHM6IHtcbiAgICBvYmplY3Q6IHtcbiAgICAgIHZhbGlkYXRlOiAoMCwgX3V0aWxzLmFzc2VydE5vZGVUeXBlKShcIkV4cHJlc3Npb25cIilcbiAgICB9LFxuICAgIHByb3BlcnR5OiB7XG4gICAgICB2YWxpZGF0ZTogZnVuY3Rpb24gKCkge1xuICAgICAgICBjb25zdCBub3JtYWwgPSAoMCwgX3V0aWxzLmFzc2VydE5vZGVUeXBlKShcIklkZW50aWZpZXJcIik7XG4gICAgICAgIGNvbnN0IGNvbXB1dGVkID0gKDAsIF91dGlscy5hc3NlcnROb2RlVHlwZSkoXCJFeHByZXNzaW9uXCIpO1xuICAgICAgICBjb25zdCB2YWxpZGF0b3IgPSBPYmplY3QuYXNzaWduKGZ1bmN0aW9uIChub2RlLCBrZXksIHZhbCkge1xuICAgICAgICAgIGNvbnN0IHZhbGlkYXRvciA9IG5vZGUuY29tcHV0ZWQgPyBjb21wdXRlZCA6IG5vcm1hbDtcbiAgICAgICAgICB2YWxpZGF0b3Iobm9kZSwga2V5LCB2YWwpO1xuICAgICAgICB9LCB7XG4gICAgICAgICAgb25lT2ZOb2RlVHlwZXM6IFtcIkV4cHJlc3Npb25cIiwgXCJJZGVudGlmaWVyXCJdXG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gdmFsaWRhdG9yO1xuICAgICAgfSgpXG4gICAgfSxcbiAgICBjb21wdXRlZDoge1xuICAgICAgZGVmYXVsdDogZmFsc2VcbiAgICB9LFxuICAgIG9wdGlvbmFsOiB7XG4gICAgICB2YWxpZGF0ZTogIXByb2Nlc3MuZW52LkJBQkVMX1RZUEVTXzhfQlJFQUtJTkcgPyAoMCwgX3V0aWxzLmFzc2VydFZhbHVlVHlwZSkoXCJib29sZWFuXCIpIDogKDAsIF91dGlscy5jaGFpbikoKDAsIF91dGlscy5hc3NlcnRWYWx1ZVR5cGUpKFwiYm9vbGVhblwiKSwgKDAsIF91dGlscy5hc3NlcnRPcHRpb25hbENoYWluU3RhcnQpKCkpXG4gICAgfVxuICB9XG59KTtcbmRlZmluZVR5cGUoXCJPcHRpb25hbENhbGxFeHByZXNzaW9uXCIsIHtcbiAgdmlzaXRvcjogW1wiY2FsbGVlXCIsIFwidHlwZVBhcmFtZXRlcnNcIiwgXCJ0eXBlQXJndW1lbnRzXCIsIFwiYXJndW1lbnRzXCJdLFxuICBidWlsZGVyOiBbXCJjYWxsZWVcIiwgXCJhcmd1bWVudHNcIiwgXCJvcHRpb25hbFwiXSxcbiAgYWxpYXNlczogW1wiRXhwcmVzc2lvblwiXSxcbiAgZmllbGRzOiBPYmplY3QuYXNzaWduKHtcbiAgICBjYWxsZWU6IHtcbiAgICAgIHZhbGlkYXRlOiAoMCwgX3V0aWxzLmFzc2VydE5vZGVUeXBlKShcIkV4cHJlc3Npb25cIilcbiAgICB9LFxuICAgIGFyZ3VtZW50czogKDAsIF91dGlscy52YWxpZGF0ZUFycmF5T2ZUeXBlKShcIkV4cHJlc3Npb25cIiwgXCJTcHJlYWRFbGVtZW50XCIsIFwiQXJndW1lbnRQbGFjZWhvbGRlclwiKSxcbiAgICBvcHRpb25hbDoge1xuICAgICAgdmFsaWRhdGU6ICFwcm9jZXNzLmVudi5CQUJFTF9UWVBFU184X0JSRUFLSU5HID8gKDAsIF91dGlscy5hc3NlcnRWYWx1ZVR5cGUpKFwiYm9vbGVhblwiKSA6ICgwLCBfdXRpbHMuY2hhaW4pKCgwLCBfdXRpbHMuYXNzZXJ0VmFsdWVUeXBlKShcImJvb2xlYW5cIiksICgwLCBfdXRpbHMuYXNzZXJ0T3B0aW9uYWxDaGFpblN0YXJ0KSgpKVxuICAgIH0sXG4gICAgdHlwZUFyZ3VtZW50czoge1xuICAgICAgdmFsaWRhdGU6ICgwLCBfdXRpbHMuYXNzZXJ0Tm9kZVR5cGUpKFwiVHlwZVBhcmFtZXRlckluc3RhbnRpYXRpb25cIiksXG4gICAgICBvcHRpb25hbDogdHJ1ZVxuICAgIH1cbiAgfSwge1xuICAgIHR5cGVQYXJhbWV0ZXJzOiB7XG4gICAgICB2YWxpZGF0ZTogKDAsIF91dGlscy5hc3NlcnROb2RlVHlwZSkoXCJUU1R5cGVQYXJhbWV0ZXJJbnN0YW50aWF0aW9uXCIpLFxuICAgICAgb3B0aW9uYWw6IHRydWVcbiAgICB9XG4gIH0pXG59KTtcbmRlZmluZVR5cGUoXCJDbGFzc1Byb3BlcnR5XCIsIE9iamVjdC5hc3NpZ24oe1xuICB2aXNpdG9yOiBbXCJkZWNvcmF0b3JzXCIsIFwidmFyaWFuY2VcIiwgXCJrZXlcIiwgXCJ0eXBlQW5ub3RhdGlvblwiLCBcInZhbHVlXCJdLFxuICBidWlsZGVyOiBbXCJrZXlcIiwgXCJ2YWx1ZVwiLCBcInR5cGVBbm5vdGF0aW9uXCIsIFwiZGVjb3JhdG9yc1wiLCBcImNvbXB1dGVkXCIsIFwic3RhdGljXCJdLFxuICBhbGlhc2VzOiBbXCJQcm9wZXJ0eVwiXVxufSwgY2xhc3NNZXRob2RPclByb3BlcnR5VW5pb25TaGFwZUNvbW1vbigpLCB7XG4gIGZpZWxkczogT2JqZWN0LmFzc2lnbih7fSwgY2xhc3NNZXRob2RPclByb3BlcnR5Q29tbW9uKCksIHtcbiAgICB2YWx1ZToge1xuICAgICAgdmFsaWRhdGU6ICgwLCBfdXRpbHMuYXNzZXJ0Tm9kZVR5cGUpKFwiRXhwcmVzc2lvblwiKSxcbiAgICAgIG9wdGlvbmFsOiB0cnVlXG4gICAgfSxcbiAgICBkZWZpbml0ZToge1xuICAgICAgdmFsaWRhdGU6ICgwLCBfdXRpbHMuYXNzZXJ0VmFsdWVUeXBlKShcImJvb2xlYW5cIiksXG4gICAgICBvcHRpb25hbDogdHJ1ZVxuICAgIH0sXG4gICAgdHlwZUFubm90YXRpb246IHtcbiAgICAgIHZhbGlkYXRlOiAoMCwgX3V0aWxzLmFzc2VydE5vZGVUeXBlKShcIlR5cGVBbm5vdGF0aW9uXCIsIFwiVFNUeXBlQW5ub3RhdGlvblwiLCBcIk5vb3BcIiksXG4gICAgICBvcHRpb25hbDogdHJ1ZVxuICAgIH0sXG4gICAgZGVjb3JhdG9yczoge1xuICAgICAgdmFsaWRhdGU6ICgwLCBfdXRpbHMuYXJyYXlPZlR5cGUpKFwiRGVjb3JhdG9yXCIpLFxuICAgICAgb3B0aW9uYWw6IHRydWVcbiAgICB9LFxuICAgIHJlYWRvbmx5OiB7XG4gICAgICB2YWxpZGF0ZTogKDAsIF91dGlscy5hc3NlcnRWYWx1ZVR5cGUpKFwiYm9vbGVhblwiKSxcbiAgICAgIG9wdGlvbmFsOiB0cnVlXG4gICAgfSxcbiAgICBkZWNsYXJlOiB7XG4gICAgICB2YWxpZGF0ZTogKDAsIF91dGlscy5hc3NlcnRWYWx1ZVR5cGUpKFwiYm9vbGVhblwiKSxcbiAgICAgIG9wdGlvbmFsOiB0cnVlXG4gICAgfSxcbiAgICB2YXJpYW5jZToge1xuICAgICAgdmFsaWRhdGU6ICgwLCBfdXRpbHMuYXNzZXJ0Tm9kZVR5cGUpKFwiVmFyaWFuY2VcIiksXG4gICAgICBvcHRpb25hbDogdHJ1ZVxuICAgIH1cbiAgfSlcbn0pKTtcbmRlZmluZVR5cGUoXCJDbGFzc0FjY2Vzc29yUHJvcGVydHlcIiwgT2JqZWN0LmFzc2lnbih7XG4gIHZpc2l0b3I6IFtcImRlY29yYXRvcnNcIiwgXCJrZXlcIiwgXCJ0eXBlQW5ub3RhdGlvblwiLCBcInZhbHVlXCJdLFxuICBidWlsZGVyOiBbXCJrZXlcIiwgXCJ2YWx1ZVwiLCBcInR5cGVBbm5vdGF0aW9uXCIsIFwiZGVjb3JhdG9yc1wiLCBcImNvbXB1dGVkXCIsIFwic3RhdGljXCJdLFxuICBhbGlhc2VzOiBbXCJQcm9wZXJ0eVwiLCBcIkFjY2Vzc29yXCJdXG59LCBjbGFzc01ldGhvZE9yUHJvcGVydHlVbmlvblNoYXBlQ29tbW9uKHRydWUpLCB7XG4gIGZpZWxkczogT2JqZWN0LmFzc2lnbih7fSwgY2xhc3NNZXRob2RPclByb3BlcnR5Q29tbW9uKCksIHtcbiAgICBrZXk6IHtcbiAgICAgIHZhbGlkYXRlOiAoMCwgX3V0aWxzLmNoYWluKShmdW5jdGlvbiAoKSB7XG4gICAgICAgIGNvbnN0IG5vcm1hbCA9ICgwLCBfdXRpbHMuYXNzZXJ0Tm9kZVR5cGUpKFwiSWRlbnRpZmllclwiLCBcIlN0cmluZ0xpdGVyYWxcIiwgXCJOdW1lcmljTGl0ZXJhbFwiLCBcIkJpZ0ludExpdGVyYWxcIiwgXCJQcml2YXRlTmFtZVwiKTtcbiAgICAgICAgY29uc3QgY29tcHV0ZWQgPSAoMCwgX3V0aWxzLmFzc2VydE5vZGVUeXBlKShcIkV4cHJlc3Npb25cIik7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAobm9kZSwga2V5LCB2YWwpIHtcbiAgICAgICAgICBjb25zdCB2YWxpZGF0b3IgPSBub2RlLmNvbXB1dGVkID8gY29tcHV0ZWQgOiBub3JtYWw7XG4gICAgICAgICAgdmFsaWRhdG9yKG5vZGUsIGtleSwgdmFsKTtcbiAgICAgICAgfTtcbiAgICAgIH0oKSwgKDAsIF91dGlscy5hc3NlcnROb2RlVHlwZSkoXCJJZGVudGlmaWVyXCIsIFwiU3RyaW5nTGl0ZXJhbFwiLCBcIk51bWVyaWNMaXRlcmFsXCIsIFwiQmlnSW50TGl0ZXJhbFwiLCBcIkV4cHJlc3Npb25cIiwgXCJQcml2YXRlTmFtZVwiKSlcbiAgICB9LFxuICAgIHZhbHVlOiB7XG4gICAgICB2YWxpZGF0ZTogKDAsIF91dGlscy5hc3NlcnROb2RlVHlwZSkoXCJFeHByZXNzaW9uXCIpLFxuICAgICAgb3B0aW9uYWw6IHRydWVcbiAgICB9LFxuICAgIGRlZmluaXRlOiB7XG4gICAgICB2YWxpZGF0ZTogKDAsIF91dGlscy5hc3NlcnRWYWx1ZVR5cGUpKFwiYm9vbGVhblwiKSxcbiAgICAgIG9wdGlvbmFsOiB0cnVlXG4gICAgfSxcbiAgICB0eXBlQW5ub3RhdGlvbjoge1xuICAgICAgdmFsaWRhdGU6ICgwLCBfdXRpbHMuYXNzZXJ0Tm9kZVR5cGUpKFwiVHlwZUFubm90YXRpb25cIiwgXCJUU1R5cGVBbm5vdGF0aW9uXCIsIFwiTm9vcFwiKSxcbiAgICAgIG9wdGlvbmFsOiB0cnVlXG4gICAgfSxcbiAgICBkZWNvcmF0b3JzOiB7XG4gICAgICB2YWxpZGF0ZTogKDAsIF91dGlscy5hcnJheU9mVHlwZSkoXCJEZWNvcmF0b3JcIiksXG4gICAgICBvcHRpb25hbDogdHJ1ZVxuICAgIH0sXG4gICAgcmVhZG9ubHk6IHtcbiAgICAgIHZhbGlkYXRlOiAoMCwgX3V0aWxzLmFzc2VydFZhbHVlVHlwZSkoXCJib29sZWFuXCIpLFxuICAgICAgb3B0aW9uYWw6IHRydWVcbiAgICB9LFxuICAgIGRlY2xhcmU6IHtcbiAgICAgIHZhbGlkYXRlOiAoMCwgX3V0aWxzLmFzc2VydFZhbHVlVHlwZSkoXCJib29sZWFuXCIpLFxuICAgICAgb3B0aW9uYWw6IHRydWVcbiAgICB9LFxuICAgIHZhcmlhbmNlOiB7XG4gICAgICB2YWxpZGF0ZTogKDAsIF91dGlscy5hc3NlcnROb2RlVHlwZSkoXCJWYXJpYW5jZVwiKSxcbiAgICAgIG9wdGlvbmFsOiB0cnVlXG4gICAgfVxuICB9KVxufSkpO1xuZGVmaW5lVHlwZShcIkNsYXNzUHJpdmF0ZVByb3BlcnR5XCIsIHtcbiAgdmlzaXRvcjogW1wiZGVjb3JhdG9yc1wiLCBcInZhcmlhbmNlXCIsIFwia2V5XCIsIFwidHlwZUFubm90YXRpb25cIiwgXCJ2YWx1ZVwiXSxcbiAgYnVpbGRlcjogW1wia2V5XCIsIFwidmFsdWVcIiwgXCJkZWNvcmF0b3JzXCIsIFwic3RhdGljXCJdLFxuICBhbGlhc2VzOiBbXCJQcm9wZXJ0eVwiLCBcIlByaXZhdGVcIl0sXG4gIGZpZWxkczoge1xuICAgIGtleToge1xuICAgICAgdmFsaWRhdGU6ICgwLCBfdXRpbHMuYXNzZXJ0Tm9kZVR5cGUpKFwiUHJpdmF0ZU5hbWVcIilcbiAgICB9LFxuICAgIHZhbHVlOiB7XG4gICAgICB2YWxpZGF0ZTogKDAsIF91dGlscy5hc3NlcnROb2RlVHlwZSkoXCJFeHByZXNzaW9uXCIpLFxuICAgICAgb3B0aW9uYWw6IHRydWVcbiAgICB9LFxuICAgIHR5cGVBbm5vdGF0aW9uOiB7XG4gICAgICB2YWxpZGF0ZTogKDAsIF91dGlscy5hc3NlcnROb2RlVHlwZSkoXCJUeXBlQW5ub3RhdGlvblwiLCBcIlRTVHlwZUFubm90YXRpb25cIiwgXCJOb29wXCIpLFxuICAgICAgb3B0aW9uYWw6IHRydWVcbiAgICB9LFxuICAgIGRlY29yYXRvcnM6IHtcbiAgICAgIHZhbGlkYXRlOiAoMCwgX3V0aWxzLmFycmF5T2ZUeXBlKShcIkRlY29yYXRvclwiKSxcbiAgICAgIG9wdGlvbmFsOiB0cnVlXG4gICAgfSxcbiAgICBzdGF0aWM6IHtcbiAgICAgIHZhbGlkYXRlOiAoMCwgX3V0aWxzLmFzc2VydFZhbHVlVHlwZSkoXCJib29sZWFuXCIpLFxuICAgICAgZGVmYXVsdDogZmFsc2VcbiAgICB9LFxuICAgIHJlYWRvbmx5OiB7XG4gICAgICB2YWxpZGF0ZTogKDAsIF91dGlscy5hc3NlcnRWYWx1ZVR5cGUpKFwiYm9vbGVhblwiKSxcbiAgICAgIG9wdGlvbmFsOiB0cnVlXG4gICAgfSxcbiAgICBvcHRpb25hbDoge1xuICAgICAgdmFsaWRhdGU6ICgwLCBfdXRpbHMuYXNzZXJ0VmFsdWVUeXBlKShcImJvb2xlYW5cIiksXG4gICAgICBvcHRpb25hbDogdHJ1ZVxuICAgIH0sXG4gICAgZGVmaW5pdGU6IHtcbiAgICAgIHZhbGlkYXRlOiAoMCwgX3V0aWxzLmFzc2VydFZhbHVlVHlwZSkoXCJib29sZWFuXCIpLFxuICAgICAgb3B0aW9uYWw6IHRydWVcbiAgICB9LFxuICAgIHZhcmlhbmNlOiB7XG4gICAgICB2YWxpZGF0ZTogKDAsIF91dGlscy5hc3NlcnROb2RlVHlwZSkoXCJWYXJpYW5jZVwiKSxcbiAgICAgIG9wdGlvbmFsOiB0cnVlXG4gICAgfVxuICB9XG59KTtcbmRlZmluZVR5cGUoXCJDbGFzc1ByaXZhdGVNZXRob2RcIiwge1xuICBidWlsZGVyOiBbXCJraW5kXCIsIFwia2V5XCIsIFwicGFyYW1zXCIsIFwiYm9keVwiLCBcInN0YXRpY1wiXSxcbiAgdmlzaXRvcjogW1wiZGVjb3JhdG9yc1wiLCBcImtleVwiLCBcInR5cGVQYXJhbWV0ZXJzXCIsIFwicGFyYW1zXCIsIFwicmV0dXJuVHlwZVwiLCBcImJvZHlcIl0sXG4gIGFsaWFzZXM6IFtcIkZ1bmN0aW9uXCIsIFwiU2NvcGFibGVcIiwgXCJCbG9ja1BhcmVudFwiLCBcIkZ1bmN0aW9uUGFyZW50XCIsIFwiTWV0aG9kXCIsIFwiUHJpdmF0ZVwiXSxcbiAgZmllbGRzOiBPYmplY3QuYXNzaWduKHt9LCBjbGFzc01ldGhvZE9yRGVjbGFyZU1ldGhvZENvbW1vbigpLCBmdW5jdGlvblR5cGVBbm5vdGF0aW9uQ29tbW9uKCksIHtcbiAgICBraW5kOiB7XG4gICAgICB2YWxpZGF0ZTogKDAsIF91dGlscy5hc3NlcnRPbmVPZikoXCJnZXRcIiwgXCJzZXRcIiwgXCJtZXRob2RcIiksXG4gICAgICBkZWZhdWx0OiBcIm1ldGhvZFwiXG4gICAgfSxcbiAgICBrZXk6IHtcbiAgICAgIHZhbGlkYXRlOiAoMCwgX3V0aWxzLmFzc2VydE5vZGVUeXBlKShcIlByaXZhdGVOYW1lXCIpXG4gICAgfSxcbiAgICBib2R5OiB7XG4gICAgICB2YWxpZGF0ZTogKDAsIF91dGlscy5hc3NlcnROb2RlVHlwZSkoXCJCbG9ja1N0YXRlbWVudFwiKVxuICAgIH1cbiAgfSlcbn0pO1xuZGVmaW5lVHlwZShcIlByaXZhdGVOYW1lXCIsIHtcbiAgdmlzaXRvcjogW1wiaWRcIl0sXG4gIGFsaWFzZXM6IFtcIlByaXZhdGVcIl0sXG4gIGZpZWxkczoge1xuICAgIGlkOiB7XG4gICAgICB2YWxpZGF0ZTogKDAsIF91dGlscy5hc3NlcnROb2RlVHlwZSkoXCJJZGVudGlmaWVyXCIpXG4gICAgfVxuICB9XG59KTtcbmRlZmluZVR5cGUoXCJTdGF0aWNCbG9ja1wiLCB7XG4gIHZpc2l0b3I6IFtcImJvZHlcIl0sXG4gIGZpZWxkczoge1xuICAgIGJvZHk6ICgwLCBfdXRpbHMudmFsaWRhdGVBcnJheU9mVHlwZSkoXCJTdGF0ZW1lbnRcIilcbiAgfSxcbiAgYWxpYXNlczogW1wiU2NvcGFibGVcIiwgXCJCbG9ja1BhcmVudFwiLCBcIkZ1bmN0aW9uUGFyZW50XCJdXG59KTtcbmRlZmluZVR5cGUoXCJJbXBvcnRBdHRyaWJ1dGVcIiwge1xuICB2aXNpdG9yOiBbXCJrZXlcIiwgXCJ2YWx1ZVwiXSxcbiAgZmllbGRzOiB7XG4gICAga2V5OiB7XG4gICAgICB2YWxpZGF0ZTogKDAsIF91dGlscy5hc3NlcnROb2RlVHlwZSkoXCJJZGVudGlmaWVyXCIsIFwiU3RyaW5nTGl0ZXJhbFwiKVxuICAgIH0sXG4gICAgdmFsdWU6IHtcbiAgICAgIHZhbGlkYXRlOiAoMCwgX3V0aWxzLmFzc2VydE5vZGVUeXBlKShcIlN0cmluZ0xpdGVyYWxcIilcbiAgICB9XG4gIH1cbn0pO1xuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1jb3JlLmpzLm1hcFxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@babel/types/lib/definitions/core.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@babel/types/lib/definitions/deprecated-aliases.js":
/*!*************************************************************************!*\
  !*** ./node_modules/@babel/types/lib/definitions/deprecated-aliases.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports.DEPRECATED_ALIASES = void 0;\nconst DEPRECATED_ALIASES = exports.DEPRECATED_ALIASES = {\n  ModuleDeclaration: \"ImportOrExportDeclaration\"\n};\n\n//# sourceMappingURL=deprecated-aliases.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGJhYmVsL3R5cGVzL2xpYi9kZWZpbml0aW9ucy9kZXByZWNhdGVkLWFsaWFzZXMuanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWIsOENBQTZDO0FBQzdDO0FBQ0EsQ0FBQyxFQUFDO0FBQ0YsMEJBQTBCO0FBQzFCLDJCQUEyQiwwQkFBMEI7QUFDckQ7QUFDQTs7QUFFQSIsInNvdXJjZXMiOlsid2VicGFjazovL3JlcG8tdmlzdWFsaXplci8uL25vZGVfbW9kdWxlcy9AYmFiZWwvdHlwZXMvbGliL2RlZmluaXRpb25zL2RlcHJlY2F0ZWQtYWxpYXNlcy5qcz81MGI4Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5ERVBSRUNBVEVEX0FMSUFTRVMgPSB2b2lkIDA7XG5jb25zdCBERVBSRUNBVEVEX0FMSUFTRVMgPSBleHBvcnRzLkRFUFJFQ0FURURfQUxJQVNFUyA9IHtcbiAgTW9kdWxlRGVjbGFyYXRpb246IFwiSW1wb3J0T3JFeHBvcnREZWNsYXJhdGlvblwiXG59O1xuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1kZXByZWNhdGVkLWFsaWFzZXMuanMubWFwXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@babel/types/lib/definitions/deprecated-aliases.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@babel/types/lib/definitions/experimental.js":
/*!*******************************************************************!*\
  !*** ./node_modules/@babel/types/lib/definitions/experimental.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

eval("\n\nvar _utils = __webpack_require__(/*! ./utils.js */ \"(ssr)/./node_modules/@babel/types/lib/definitions/utils.js\");\n(0, _utils.default)(\"ArgumentPlaceholder\", {});\n(0, _utils.default)(\"BindExpression\", {\n  visitor: [\"object\", \"callee\"],\n  aliases: [\"Expression\"],\n  fields: !process.env.BABEL_TYPES_8_BREAKING ? {\n    object: {\n      validate: Object.assign(() => {}, {\n        oneOfNodeTypes: [\"Expression\"]\n      })\n    },\n    callee: {\n      validate: Object.assign(() => {}, {\n        oneOfNodeTypes: [\"Expression\"]\n      })\n    }\n  } : {\n    object: {\n      validate: (0, _utils.assertNodeType)(\"Expression\")\n    },\n    callee: {\n      validate: (0, _utils.assertNodeType)(\"Expression\")\n    }\n  }\n});\n(0, _utils.default)(\"Decorator\", {\n  visitor: [\"expression\"],\n  fields: {\n    expression: {\n      validate: (0, _utils.assertNodeType)(\"Expression\")\n    }\n  }\n});\n(0, _utils.default)(\"DoExpression\", {\n  visitor: [\"body\"],\n  builder: [\"body\", \"async\"],\n  aliases: [\"Expression\"],\n  fields: {\n    body: {\n      validate: (0, _utils.assertNodeType)(\"BlockStatement\")\n    },\n    async: {\n      validate: (0, _utils.assertValueType)(\"boolean\"),\n      default: false\n    }\n  }\n});\n(0, _utils.default)(\"ExportDefaultSpecifier\", {\n  visitor: [\"exported\"],\n  aliases: [\"ModuleSpecifier\"],\n  fields: {\n    exported: {\n      validate: (0, _utils.assertNodeType)(\"Identifier\")\n    }\n  }\n});\n(0, _utils.default)(\"RecordExpression\", {\n  visitor: [\"properties\"],\n  aliases: [\"Expression\"],\n  fields: {\n    properties: (0, _utils.validateArrayOfType)(\"ObjectProperty\", \"SpreadElement\")\n  }\n});\n(0, _utils.default)(\"TupleExpression\", {\n  fields: {\n    elements: {\n      validate: (0, _utils.arrayOfType)(\"Expression\", \"SpreadElement\"),\n      default: []\n    }\n  },\n  visitor: [\"elements\"],\n  aliases: [\"Expression\"]\n});\n(0, _utils.default)(\"DecimalLiteral\", {\n  builder: [\"value\"],\n  fields: {\n    value: {\n      validate: (0, _utils.assertValueType)(\"string\")\n    }\n  },\n  aliases: [\"Expression\", \"Pureish\", \"Literal\", \"Immutable\"]\n});\n(0, _utils.default)(\"ModuleExpression\", {\n  visitor: [\"body\"],\n  fields: {\n    body: {\n      validate: (0, _utils.assertNodeType)(\"Program\")\n    }\n  },\n  aliases: [\"Expression\"]\n});\n(0, _utils.default)(\"TopicReference\", {\n  aliases: [\"Expression\"]\n});\n(0, _utils.default)(\"PipelineTopicExpression\", {\n  builder: [\"expression\"],\n  visitor: [\"expression\"],\n  fields: {\n    expression: {\n      validate: (0, _utils.assertNodeType)(\"Expression\")\n    }\n  },\n  aliases: [\"Expression\"]\n});\n(0, _utils.default)(\"PipelineBareFunction\", {\n  builder: [\"callee\"],\n  visitor: [\"callee\"],\n  fields: {\n    callee: {\n      validate: (0, _utils.assertNodeType)(\"Expression\")\n    }\n  },\n  aliases: [\"Expression\"]\n});\n(0, _utils.default)(\"PipelinePrimaryTopicReference\", {\n  aliases: [\"Expression\"]\n});\n(0, _utils.default)(\"VoidPattern\", {\n  aliases: [\"Pattern\", \"PatternLike\", \"FunctionParameter\"]\n});\n\n//# sourceMappingURL=experimental.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGJhYmVsL3R5cGVzL2xpYi9kZWZpbml0aW9ucy9leHBlcmltZW50YWwuanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWIsYUFBYSxtQkFBTyxDQUFDLDhFQUFZO0FBQ2pDLDZDQUE2QztBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDO0FBQ3RDO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBLHNDQUFzQztBQUN0QztBQUNBLE9BQU87QUFDUDtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLENBQUM7O0FBRUQiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9yZXBvLXZpc3VhbGl6ZXIvLi9ub2RlX21vZHVsZXMvQGJhYmVsL3R5cGVzL2xpYi9kZWZpbml0aW9ucy9leHBlcmltZW50YWwuanM/ZjE4NyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcblxudmFyIF91dGlscyA9IHJlcXVpcmUoXCIuL3V0aWxzLmpzXCIpO1xuKDAsIF91dGlscy5kZWZhdWx0KShcIkFyZ3VtZW50UGxhY2Vob2xkZXJcIiwge30pO1xuKDAsIF91dGlscy5kZWZhdWx0KShcIkJpbmRFeHByZXNzaW9uXCIsIHtcbiAgdmlzaXRvcjogW1wib2JqZWN0XCIsIFwiY2FsbGVlXCJdLFxuICBhbGlhc2VzOiBbXCJFeHByZXNzaW9uXCJdLFxuICBmaWVsZHM6ICFwcm9jZXNzLmVudi5CQUJFTF9UWVBFU184X0JSRUFLSU5HID8ge1xuICAgIG9iamVjdDoge1xuICAgICAgdmFsaWRhdGU6IE9iamVjdC5hc3NpZ24oKCkgPT4ge30sIHtcbiAgICAgICAgb25lT2ZOb2RlVHlwZXM6IFtcIkV4cHJlc3Npb25cIl1cbiAgICAgIH0pXG4gICAgfSxcbiAgICBjYWxsZWU6IHtcbiAgICAgIHZhbGlkYXRlOiBPYmplY3QuYXNzaWduKCgpID0+IHt9LCB7XG4gICAgICAgIG9uZU9mTm9kZVR5cGVzOiBbXCJFeHByZXNzaW9uXCJdXG4gICAgICB9KVxuICAgIH1cbiAgfSA6IHtcbiAgICBvYmplY3Q6IHtcbiAgICAgIHZhbGlkYXRlOiAoMCwgX3V0aWxzLmFzc2VydE5vZGVUeXBlKShcIkV4cHJlc3Npb25cIilcbiAgICB9LFxuICAgIGNhbGxlZToge1xuICAgICAgdmFsaWRhdGU6ICgwLCBfdXRpbHMuYXNzZXJ0Tm9kZVR5cGUpKFwiRXhwcmVzc2lvblwiKVxuICAgIH1cbiAgfVxufSk7XG4oMCwgX3V0aWxzLmRlZmF1bHQpKFwiRGVjb3JhdG9yXCIsIHtcbiAgdmlzaXRvcjogW1wiZXhwcmVzc2lvblwiXSxcbiAgZmllbGRzOiB7XG4gICAgZXhwcmVzc2lvbjoge1xuICAgICAgdmFsaWRhdGU6ICgwLCBfdXRpbHMuYXNzZXJ0Tm9kZVR5cGUpKFwiRXhwcmVzc2lvblwiKVxuICAgIH1cbiAgfVxufSk7XG4oMCwgX3V0aWxzLmRlZmF1bHQpKFwiRG9FeHByZXNzaW9uXCIsIHtcbiAgdmlzaXRvcjogW1wiYm9keVwiXSxcbiAgYnVpbGRlcjogW1wiYm9keVwiLCBcImFzeW5jXCJdLFxuICBhbGlhc2VzOiBbXCJFeHByZXNzaW9uXCJdLFxuICBmaWVsZHM6IHtcbiAgICBib2R5OiB7XG4gICAgICB2YWxpZGF0ZTogKDAsIF91dGlscy5hc3NlcnROb2RlVHlwZSkoXCJCbG9ja1N0YXRlbWVudFwiKVxuICAgIH0sXG4gICAgYXN5bmM6IHtcbiAgICAgIHZhbGlkYXRlOiAoMCwgX3V0aWxzLmFzc2VydFZhbHVlVHlwZSkoXCJib29sZWFuXCIpLFxuICAgICAgZGVmYXVsdDogZmFsc2VcbiAgICB9XG4gIH1cbn0pO1xuKDAsIF91dGlscy5kZWZhdWx0KShcIkV4cG9ydERlZmF1bHRTcGVjaWZpZXJcIiwge1xuICB2aXNpdG9yOiBbXCJleHBvcnRlZFwiXSxcbiAgYWxpYXNlczogW1wiTW9kdWxlU3BlY2lmaWVyXCJdLFxuICBmaWVsZHM6IHtcbiAgICBleHBvcnRlZDoge1xuICAgICAgdmFsaWRhdGU6ICgwLCBfdXRpbHMuYXNzZXJ0Tm9kZVR5cGUpKFwiSWRlbnRpZmllclwiKVxuICAgIH1cbiAgfVxufSk7XG4oMCwgX3V0aWxzLmRlZmF1bHQpKFwiUmVjb3JkRXhwcmVzc2lvblwiLCB7XG4gIHZpc2l0b3I6IFtcInByb3BlcnRpZXNcIl0sXG4gIGFsaWFzZXM6IFtcIkV4cHJlc3Npb25cIl0sXG4gIGZpZWxkczoge1xuICAgIHByb3BlcnRpZXM6ICgwLCBfdXRpbHMudmFsaWRhdGVBcnJheU9mVHlwZSkoXCJPYmplY3RQcm9wZXJ0eVwiLCBcIlNwcmVhZEVsZW1lbnRcIilcbiAgfVxufSk7XG4oMCwgX3V0aWxzLmRlZmF1bHQpKFwiVHVwbGVFeHByZXNzaW9uXCIsIHtcbiAgZmllbGRzOiB7XG4gICAgZWxlbWVudHM6IHtcbiAgICAgIHZhbGlkYXRlOiAoMCwgX3V0aWxzLmFycmF5T2ZUeXBlKShcIkV4cHJlc3Npb25cIiwgXCJTcHJlYWRFbGVtZW50XCIpLFxuICAgICAgZGVmYXVsdDogW11cbiAgICB9XG4gIH0sXG4gIHZpc2l0b3I6IFtcImVsZW1lbnRzXCJdLFxuICBhbGlhc2VzOiBbXCJFeHByZXNzaW9uXCJdXG59KTtcbigwLCBfdXRpbHMuZGVmYXVsdCkoXCJEZWNpbWFsTGl0ZXJhbFwiLCB7XG4gIGJ1aWxkZXI6IFtcInZhbHVlXCJdLFxuICBmaWVsZHM6IHtcbiAgICB2YWx1ZToge1xuICAgICAgdmFsaWRhdGU6ICgwLCBfdXRpbHMuYXNzZXJ0VmFsdWVUeXBlKShcInN0cmluZ1wiKVxuICAgIH1cbiAgfSxcbiAgYWxpYXNlczogW1wiRXhwcmVzc2lvblwiLCBcIlB1cmVpc2hcIiwgXCJMaXRlcmFsXCIsIFwiSW1tdXRhYmxlXCJdXG59KTtcbigwLCBfdXRpbHMuZGVmYXVsdCkoXCJNb2R1bGVFeHByZXNzaW9uXCIsIHtcbiAgdmlzaXRvcjogW1wiYm9keVwiXSxcbiAgZmllbGRzOiB7XG4gICAgYm9keToge1xuICAgICAgdmFsaWRhdGU6ICgwLCBfdXRpbHMuYXNzZXJ0Tm9kZVR5cGUpKFwiUHJvZ3JhbVwiKVxuICAgIH1cbiAgfSxcbiAgYWxpYXNlczogW1wiRXhwcmVzc2lvblwiXVxufSk7XG4oMCwgX3V0aWxzLmRlZmF1bHQpKFwiVG9waWNSZWZlcmVuY2VcIiwge1xuICBhbGlhc2VzOiBbXCJFeHByZXNzaW9uXCJdXG59KTtcbigwLCBfdXRpbHMuZGVmYXVsdCkoXCJQaXBlbGluZVRvcGljRXhwcmVzc2lvblwiLCB7XG4gIGJ1aWxkZXI6IFtcImV4cHJlc3Npb25cIl0sXG4gIHZpc2l0b3I6IFtcImV4cHJlc3Npb25cIl0sXG4gIGZpZWxkczoge1xuICAgIGV4cHJlc3Npb246IHtcbiAgICAgIHZhbGlkYXRlOiAoMCwgX3V0aWxzLmFzc2VydE5vZGVUeXBlKShcIkV4cHJlc3Npb25cIilcbiAgICB9XG4gIH0sXG4gIGFsaWFzZXM6IFtcIkV4cHJlc3Npb25cIl1cbn0pO1xuKDAsIF91dGlscy5kZWZhdWx0KShcIlBpcGVsaW5lQmFyZUZ1bmN0aW9uXCIsIHtcbiAgYnVpbGRlcjogW1wiY2FsbGVlXCJdLFxuICB2aXNpdG9yOiBbXCJjYWxsZWVcIl0sXG4gIGZpZWxkczoge1xuICAgIGNhbGxlZToge1xuICAgICAgdmFsaWRhdGU6ICgwLCBfdXRpbHMuYXNzZXJ0Tm9kZVR5cGUpKFwiRXhwcmVzc2lvblwiKVxuICAgIH1cbiAgfSxcbiAgYWxpYXNlczogW1wiRXhwcmVzc2lvblwiXVxufSk7XG4oMCwgX3V0aWxzLmRlZmF1bHQpKFwiUGlwZWxpbmVQcmltYXJ5VG9waWNSZWZlcmVuY2VcIiwge1xuICBhbGlhc2VzOiBbXCJFeHByZXNzaW9uXCJdXG59KTtcbigwLCBfdXRpbHMuZGVmYXVsdCkoXCJWb2lkUGF0dGVyblwiLCB7XG4gIGFsaWFzZXM6IFtcIlBhdHRlcm5cIiwgXCJQYXR0ZXJuTGlrZVwiLCBcIkZ1bmN0aW9uUGFyYW1ldGVyXCJdXG59KTtcblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZXhwZXJpbWVudGFsLmpzLm1hcFxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@babel/types/lib/definitions/experimental.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@babel/types/lib/definitions/flow.js":
/*!***********************************************************!*\
  !*** ./node_modules/@babel/types/lib/definitions/flow.js ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

eval("\n\nvar _core = __webpack_require__(/*! ./core.js */ \"(ssr)/./node_modules/@babel/types/lib/definitions/core.js\");\nvar _utils = __webpack_require__(/*! ./utils.js */ \"(ssr)/./node_modules/@babel/types/lib/definitions/utils.js\");\nconst defineType = (0, _utils.defineAliasedType)(\"Flow\");\nconst defineInterfaceishType = name => {\n  const isDeclareClass = name === \"DeclareClass\";\n  defineType(name, {\n    builder: [\"id\", \"typeParameters\", \"extends\", \"body\"],\n    visitor: [\"id\", \"typeParameters\", \"extends\", ...(isDeclareClass ? [\"mixins\", \"implements\"] : []), \"body\"],\n    aliases: [\"FlowDeclaration\", \"Statement\", \"Declaration\"],\n    fields: Object.assign({\n      id: (0, _utils.validateType)(\"Identifier\"),\n      typeParameters: (0, _utils.validateOptionalType)(\"TypeParameterDeclaration\"),\n      extends: (0, _utils.validateOptional)((0, _utils.arrayOfType)(\"InterfaceExtends\"))\n    }, isDeclareClass ? {\n      mixins: (0, _utils.validateOptional)((0, _utils.arrayOfType)(\"InterfaceExtends\")),\n      implements: (0, _utils.validateOptional)((0, _utils.arrayOfType)(\"ClassImplements\"))\n    } : {}, {\n      body: (0, _utils.validateType)(\"ObjectTypeAnnotation\")\n    })\n  });\n};\ndefineType(\"AnyTypeAnnotation\", {\n  aliases: [\"FlowType\", \"FlowBaseAnnotation\"]\n});\ndefineType(\"ArrayTypeAnnotation\", {\n  visitor: [\"elementType\"],\n  aliases: [\"FlowType\"],\n  fields: {\n    elementType: (0, _utils.validateType)(\"FlowType\")\n  }\n});\ndefineType(\"BooleanTypeAnnotation\", {\n  aliases: [\"FlowType\", \"FlowBaseAnnotation\"]\n});\ndefineType(\"BooleanLiteralTypeAnnotation\", {\n  builder: [\"value\"],\n  aliases: [\"FlowType\"],\n  fields: {\n    value: (0, _utils.validate)((0, _utils.assertValueType)(\"boolean\"))\n  }\n});\ndefineType(\"NullLiteralTypeAnnotation\", {\n  aliases: [\"FlowType\", \"FlowBaseAnnotation\"]\n});\ndefineType(\"ClassImplements\", {\n  visitor: [\"id\", \"typeParameters\"],\n  fields: {\n    id: (0, _utils.validateType)(\"Identifier\"),\n    typeParameters: (0, _utils.validateOptionalType)(\"TypeParameterInstantiation\")\n  }\n});\ndefineInterfaceishType(\"DeclareClass\");\ndefineType(\"DeclareFunction\", {\n  builder: [\"id\"],\n  visitor: [\"id\", \"predicate\"],\n  aliases: [\"FlowDeclaration\", \"Statement\", \"Declaration\"],\n  fields: {\n    id: (0, _utils.validateType)(\"Identifier\"),\n    predicate: (0, _utils.validateOptionalType)(\"DeclaredPredicate\")\n  }\n});\ndefineInterfaceishType(\"DeclareInterface\");\ndefineType(\"DeclareModule\", {\n  builder: [\"id\", \"body\", \"kind\"],\n  visitor: [\"id\", \"body\"],\n  aliases: [\"FlowDeclaration\", \"Statement\", \"Declaration\"],\n  fields: {\n    id: (0, _utils.validateType)(\"Identifier\", \"StringLiteral\"),\n    body: (0, _utils.validateType)(\"BlockStatement\"),\n    kind: (0, _utils.validateOptional)((0, _utils.assertOneOf)(\"CommonJS\", \"ES\"))\n  }\n});\ndefineType(\"DeclareModuleExports\", {\n  visitor: [\"typeAnnotation\"],\n  aliases: [\"FlowDeclaration\", \"Statement\", \"Declaration\"],\n  fields: {\n    typeAnnotation: (0, _utils.validateType)(\"TypeAnnotation\")\n  }\n});\ndefineType(\"DeclareTypeAlias\", {\n  visitor: [\"id\", \"typeParameters\", \"right\"],\n  aliases: [\"FlowDeclaration\", \"Statement\", \"Declaration\"],\n  fields: {\n    id: (0, _utils.validateType)(\"Identifier\"),\n    typeParameters: (0, _utils.validateOptionalType)(\"TypeParameterDeclaration\"),\n    right: (0, _utils.validateType)(\"FlowType\")\n  }\n});\ndefineType(\"DeclareOpaqueType\", {\n  visitor: [\"id\", \"typeParameters\", \"supertype\"],\n  aliases: [\"FlowDeclaration\", \"Statement\", \"Declaration\"],\n  fields: {\n    id: (0, _utils.validateType)(\"Identifier\"),\n    typeParameters: (0, _utils.validateOptionalType)(\"TypeParameterDeclaration\"),\n    supertype: (0, _utils.validateOptionalType)(\"FlowType\"),\n    impltype: (0, _utils.validateOptionalType)(\"FlowType\")\n  }\n});\ndefineType(\"DeclareVariable\", {\n  visitor: [\"id\"],\n  aliases: [\"FlowDeclaration\", \"Statement\", \"Declaration\"],\n  fields: {\n    id: (0, _utils.validateType)(\"Identifier\")\n  }\n});\ndefineType(\"DeclareExportDeclaration\", {\n  visitor: [\"declaration\", \"specifiers\", \"source\", \"attributes\"],\n  aliases: [\"FlowDeclaration\", \"Statement\", \"Declaration\"],\n  fields: Object.assign({\n    declaration: (0, _utils.validateOptionalType)(\"Flow\"),\n    specifiers: (0, _utils.validateOptional)((0, _utils.arrayOfType)(\"ExportSpecifier\", \"ExportNamespaceSpecifier\")),\n    source: (0, _utils.validateOptionalType)(\"StringLiteral\"),\n    default: (0, _utils.validateOptional)((0, _utils.assertValueType)(\"boolean\"))\n  }, _core.importAttributes)\n});\ndefineType(\"DeclareExportAllDeclaration\", {\n  visitor: [\"source\", \"attributes\"],\n  aliases: [\"FlowDeclaration\", \"Statement\", \"Declaration\"],\n  fields: Object.assign({\n    source: (0, _utils.validateType)(\"StringLiteral\"),\n    exportKind: (0, _utils.validateOptional)((0, _utils.assertOneOf)(\"type\", \"value\"))\n  }, _core.importAttributes)\n});\ndefineType(\"DeclaredPredicate\", {\n  visitor: [\"value\"],\n  aliases: [\"FlowPredicate\"],\n  fields: {\n    value: (0, _utils.validateType)(\"Flow\")\n  }\n});\ndefineType(\"ExistsTypeAnnotation\", {\n  aliases: [\"FlowType\"]\n});\ndefineType(\"FunctionTypeAnnotation\", {\n  builder: [\"typeParameters\", \"params\", \"rest\", \"returnType\"],\n  visitor: [\"typeParameters\", \"this\", \"params\", \"rest\", \"returnType\"],\n  aliases: [\"FlowType\"],\n  fields: {\n    typeParameters: (0, _utils.validateOptionalType)(\"TypeParameterDeclaration\"),\n    params: (0, _utils.validateArrayOfType)(\"FunctionTypeParam\"),\n    rest: (0, _utils.validateOptionalType)(\"FunctionTypeParam\"),\n    this: (0, _utils.validateOptionalType)(\"FunctionTypeParam\"),\n    returnType: (0, _utils.validateType)(\"FlowType\")\n  }\n});\ndefineType(\"FunctionTypeParam\", {\n  visitor: [\"name\", \"typeAnnotation\"],\n  fields: {\n    name: (0, _utils.validateOptionalType)(\"Identifier\"),\n    typeAnnotation: (0, _utils.validateType)(\"FlowType\"),\n    optional: (0, _utils.validateOptional)((0, _utils.assertValueType)(\"boolean\"))\n  }\n});\ndefineType(\"GenericTypeAnnotation\", {\n  visitor: [\"id\", \"typeParameters\"],\n  aliases: [\"FlowType\"],\n  fields: {\n    id: (0, _utils.validateType)(\"Identifier\", \"QualifiedTypeIdentifier\"),\n    typeParameters: (0, _utils.validateOptionalType)(\"TypeParameterInstantiation\")\n  }\n});\ndefineType(\"InferredPredicate\", {\n  aliases: [\"FlowPredicate\"]\n});\ndefineType(\"InterfaceExtends\", {\n  visitor: [\"id\", \"typeParameters\"],\n  fields: {\n    id: (0, _utils.validateType)(\"Identifier\", \"QualifiedTypeIdentifier\"),\n    typeParameters: (0, _utils.validateOptionalType)(\"TypeParameterInstantiation\")\n  }\n});\ndefineInterfaceishType(\"InterfaceDeclaration\");\ndefineType(\"InterfaceTypeAnnotation\", {\n  visitor: [\"extends\", \"body\"],\n  aliases: [\"FlowType\"],\n  fields: {\n    extends: (0, _utils.validateOptional)((0, _utils.arrayOfType)(\"InterfaceExtends\")),\n    body: (0, _utils.validateType)(\"ObjectTypeAnnotation\")\n  }\n});\ndefineType(\"IntersectionTypeAnnotation\", {\n  visitor: [\"types\"],\n  aliases: [\"FlowType\"],\n  fields: {\n    types: (0, _utils.validate)((0, _utils.arrayOfType)(\"FlowType\"))\n  }\n});\ndefineType(\"MixedTypeAnnotation\", {\n  aliases: [\"FlowType\", \"FlowBaseAnnotation\"]\n});\ndefineType(\"EmptyTypeAnnotation\", {\n  aliases: [\"FlowType\", \"FlowBaseAnnotation\"]\n});\ndefineType(\"NullableTypeAnnotation\", {\n  visitor: [\"typeAnnotation\"],\n  aliases: [\"FlowType\"],\n  fields: {\n    typeAnnotation: (0, _utils.validateType)(\"FlowType\")\n  }\n});\ndefineType(\"NumberLiteralTypeAnnotation\", {\n  builder: [\"value\"],\n  aliases: [\"FlowType\"],\n  fields: {\n    value: (0, _utils.validate)((0, _utils.assertValueType)(\"number\"))\n  }\n});\ndefineType(\"NumberTypeAnnotation\", {\n  aliases: [\"FlowType\", \"FlowBaseAnnotation\"]\n});\ndefineType(\"ObjectTypeAnnotation\", {\n  visitor: [\"properties\", \"indexers\", \"callProperties\", \"internalSlots\"],\n  aliases: [\"FlowType\"],\n  builder: [\"properties\", \"indexers\", \"callProperties\", \"internalSlots\", \"exact\"],\n  fields: {\n    properties: (0, _utils.validate)((0, _utils.arrayOfType)(\"ObjectTypeProperty\", \"ObjectTypeSpreadProperty\")),\n    indexers: {\n      validate: (0, _utils.arrayOfType)(\"ObjectTypeIndexer\"),\n      optional: true,\n      default: []\n    },\n    callProperties: {\n      validate: (0, _utils.arrayOfType)(\"ObjectTypeCallProperty\"),\n      optional: true,\n      default: []\n    },\n    internalSlots: {\n      validate: (0, _utils.arrayOfType)(\"ObjectTypeInternalSlot\"),\n      optional: true,\n      default: []\n    },\n    exact: {\n      validate: (0, _utils.assertValueType)(\"boolean\"),\n      default: false\n    },\n    inexact: (0, _utils.validateOptional)((0, _utils.assertValueType)(\"boolean\"))\n  }\n});\ndefineType(\"ObjectTypeInternalSlot\", {\n  visitor: [\"id\", \"value\"],\n  builder: [\"id\", \"value\", \"optional\", \"static\", \"method\"],\n  aliases: [\"UserWhitespacable\"],\n  fields: {\n    id: (0, _utils.validateType)(\"Identifier\"),\n    value: (0, _utils.validateType)(\"FlowType\"),\n    optional: (0, _utils.validate)((0, _utils.assertValueType)(\"boolean\")),\n    static: (0, _utils.validate)((0, _utils.assertValueType)(\"boolean\")),\n    method: (0, _utils.validate)((0, _utils.assertValueType)(\"boolean\"))\n  }\n});\ndefineType(\"ObjectTypeCallProperty\", {\n  visitor: [\"value\"],\n  aliases: [\"UserWhitespacable\"],\n  fields: {\n    value: (0, _utils.validateType)(\"FlowType\"),\n    static: (0, _utils.validate)((0, _utils.assertValueType)(\"boolean\"))\n  }\n});\ndefineType(\"ObjectTypeIndexer\", {\n  visitor: [\"variance\", \"id\", \"key\", \"value\"],\n  builder: [\"id\", \"key\", \"value\", \"variance\"],\n  aliases: [\"UserWhitespacable\"],\n  fields: {\n    id: (0, _utils.validateOptionalType)(\"Identifier\"),\n    key: (0, _utils.validateType)(\"FlowType\"),\n    value: (0, _utils.validateType)(\"FlowType\"),\n    static: (0, _utils.validate)((0, _utils.assertValueType)(\"boolean\")),\n    variance: (0, _utils.validateOptionalType)(\"Variance\")\n  }\n});\ndefineType(\"ObjectTypeProperty\", {\n  visitor: [\"key\", \"value\", \"variance\"],\n  aliases: [\"UserWhitespacable\"],\n  fields: {\n    key: (0, _utils.validateType)(\"Identifier\", \"StringLiteral\"),\n    value: (0, _utils.validateType)(\"FlowType\"),\n    kind: (0, _utils.validate)((0, _utils.assertOneOf)(\"init\", \"get\", \"set\")),\n    static: (0, _utils.validate)((0, _utils.assertValueType)(\"boolean\")),\n    proto: (0, _utils.validate)((0, _utils.assertValueType)(\"boolean\")),\n    optional: (0, _utils.validate)((0, _utils.assertValueType)(\"boolean\")),\n    variance: (0, _utils.validateOptionalType)(\"Variance\"),\n    method: (0, _utils.validate)((0, _utils.assertValueType)(\"boolean\"))\n  }\n});\ndefineType(\"ObjectTypeSpreadProperty\", {\n  visitor: [\"argument\"],\n  aliases: [\"UserWhitespacable\"],\n  fields: {\n    argument: (0, _utils.validateType)(\"FlowType\")\n  }\n});\ndefineType(\"OpaqueType\", {\n  visitor: [\"id\", \"typeParameters\", \"supertype\", \"impltype\"],\n  aliases: [\"FlowDeclaration\", \"Statement\", \"Declaration\"],\n  fields: {\n    id: (0, _utils.validateType)(\"Identifier\"),\n    typeParameters: (0, _utils.validateOptionalType)(\"TypeParameterDeclaration\"),\n    supertype: (0, _utils.validateOptionalType)(\"FlowType\"),\n    impltype: (0, _utils.validateType)(\"FlowType\")\n  }\n});\ndefineType(\"QualifiedTypeIdentifier\", {\n  visitor: [\"qualification\", \"id\"],\n  builder: [\"id\", \"qualification\"],\n  fields: {\n    id: (0, _utils.validateType)(\"Identifier\"),\n    qualification: (0, _utils.validateType)(\"Identifier\", \"QualifiedTypeIdentifier\")\n  }\n});\ndefineType(\"StringLiteralTypeAnnotation\", {\n  builder: [\"value\"],\n  aliases: [\"FlowType\"],\n  fields: {\n    value: (0, _utils.validate)((0, _utils.assertValueType)(\"string\"))\n  }\n});\ndefineType(\"StringTypeAnnotation\", {\n  aliases: [\"FlowType\", \"FlowBaseAnnotation\"]\n});\ndefineType(\"SymbolTypeAnnotation\", {\n  aliases: [\"FlowType\", \"FlowBaseAnnotation\"]\n});\ndefineType(\"ThisTypeAnnotation\", {\n  aliases: [\"FlowType\", \"FlowBaseAnnotation\"]\n});\ndefineType(\"TupleTypeAnnotation\", {\n  visitor: [\"types\"],\n  aliases: [\"FlowType\"],\n  fields: {\n    types: (0, _utils.validate)((0, _utils.arrayOfType)(\"FlowType\"))\n  }\n});\ndefineType(\"TypeofTypeAnnotation\", {\n  visitor: [\"argument\"],\n  aliases: [\"FlowType\"],\n  fields: {\n    argument: (0, _utils.validateType)(\"FlowType\")\n  }\n});\ndefineType(\"TypeAlias\", {\n  visitor: [\"id\", \"typeParameters\", \"right\"],\n  aliases: [\"FlowDeclaration\", \"Statement\", \"Declaration\"],\n  fields: {\n    id: (0, _utils.validateType)(\"Identifier\"),\n    typeParameters: (0, _utils.validateOptionalType)(\"TypeParameterDeclaration\"),\n    right: (0, _utils.validateType)(\"FlowType\")\n  }\n});\ndefineType(\"TypeAnnotation\", {\n  visitor: [\"typeAnnotation\"],\n  fields: {\n    typeAnnotation: (0, _utils.validateType)(\"FlowType\")\n  }\n});\ndefineType(\"TypeCastExpression\", {\n  visitor: [\"expression\", \"typeAnnotation\"],\n  aliases: [\"ExpressionWrapper\", \"Expression\"],\n  fields: {\n    expression: (0, _utils.validateType)(\"Expression\"),\n    typeAnnotation: (0, _utils.validateType)(\"TypeAnnotation\")\n  }\n});\ndefineType(\"TypeParameter\", {\n  visitor: [\"bound\", \"default\", \"variance\"],\n  fields: {\n    name: (0, _utils.validate)((0, _utils.assertValueType)(\"string\")),\n    bound: (0, _utils.validateOptionalType)(\"TypeAnnotation\"),\n    default: (0, _utils.validateOptionalType)(\"FlowType\"),\n    variance: (0, _utils.validateOptionalType)(\"Variance\")\n  }\n});\ndefineType(\"TypeParameterDeclaration\", {\n  visitor: [\"params\"],\n  fields: {\n    params: (0, _utils.validate)((0, _utils.arrayOfType)(\"TypeParameter\"))\n  }\n});\ndefineType(\"TypeParameterInstantiation\", {\n  visitor: [\"params\"],\n  fields: {\n    params: (0, _utils.validate)((0, _utils.arrayOfType)(\"FlowType\"))\n  }\n});\ndefineType(\"UnionTypeAnnotation\", {\n  visitor: [\"types\"],\n  aliases: [\"FlowType\"],\n  fields: {\n    types: (0, _utils.validate)((0, _utils.arrayOfType)(\"FlowType\"))\n  }\n});\ndefineType(\"Variance\", {\n  builder: [\"kind\"],\n  fields: {\n    kind: (0, _utils.validate)((0, _utils.assertOneOf)(\"minus\", \"plus\"))\n  }\n});\ndefineType(\"VoidTypeAnnotation\", {\n  aliases: [\"FlowType\", \"FlowBaseAnnotation\"]\n});\ndefineType(\"EnumDeclaration\", {\n  aliases: [\"Statement\", \"Declaration\"],\n  visitor: [\"id\", \"body\"],\n  fields: {\n    id: (0, _utils.validateType)(\"Identifier\"),\n    body: (0, _utils.validateType)(\"EnumBooleanBody\", \"EnumNumberBody\", \"EnumStringBody\", \"EnumSymbolBody\")\n  }\n});\ndefineType(\"EnumBooleanBody\", {\n  aliases: [\"EnumBody\"],\n  visitor: [\"members\"],\n  fields: {\n    explicitType: (0, _utils.validate)((0, _utils.assertValueType)(\"boolean\")),\n    members: (0, _utils.validateArrayOfType)(\"EnumBooleanMember\"),\n    hasUnknownMembers: (0, _utils.validate)((0, _utils.assertValueType)(\"boolean\"))\n  }\n});\ndefineType(\"EnumNumberBody\", {\n  aliases: [\"EnumBody\"],\n  visitor: [\"members\"],\n  fields: {\n    explicitType: (0, _utils.validate)((0, _utils.assertValueType)(\"boolean\")),\n    members: (0, _utils.validateArrayOfType)(\"EnumNumberMember\"),\n    hasUnknownMembers: (0, _utils.validate)((0, _utils.assertValueType)(\"boolean\"))\n  }\n});\ndefineType(\"EnumStringBody\", {\n  aliases: [\"EnumBody\"],\n  visitor: [\"members\"],\n  fields: {\n    explicitType: (0, _utils.validate)((0, _utils.assertValueType)(\"boolean\")),\n    members: (0, _utils.validateArrayOfType)(\"EnumStringMember\", \"EnumDefaultedMember\"),\n    hasUnknownMembers: (0, _utils.validate)((0, _utils.assertValueType)(\"boolean\"))\n  }\n});\ndefineType(\"EnumSymbolBody\", {\n  aliases: [\"EnumBody\"],\n  visitor: [\"members\"],\n  fields: {\n    members: (0, _utils.validateArrayOfType)(\"EnumDefaultedMember\"),\n    hasUnknownMembers: (0, _utils.validate)((0, _utils.assertValueType)(\"boolean\"))\n  }\n});\ndefineType(\"EnumBooleanMember\", {\n  aliases: [\"EnumMember\"],\n  builder: [\"id\"],\n  visitor: [\"id\", \"init\"],\n  fields: {\n    id: (0, _utils.validateType)(\"Identifier\"),\n    init: (0, _utils.validateType)(\"BooleanLiteral\")\n  }\n});\ndefineType(\"EnumNumberMember\", {\n  aliases: [\"EnumMember\"],\n  visitor: [\"id\", \"init\"],\n  fields: {\n    id: (0, _utils.validateType)(\"Identifier\"),\n    init: (0, _utils.validateType)(\"NumericLiteral\")\n  }\n});\ndefineType(\"EnumStringMember\", {\n  aliases: [\"EnumMember\"],\n  visitor: [\"id\", \"init\"],\n  fields: {\n    id: (0, _utils.validateType)(\"Identifier\"),\n    init: (0, _utils.validateType)(\"StringLiteral\")\n  }\n});\ndefineType(\"EnumDefaultedMember\", {\n  aliases: [\"EnumMember\"],\n  visitor: [\"id\"],\n  fields: {\n    id: (0, _utils.validateType)(\"Identifier\")\n  }\n});\ndefineType(\"IndexedAccessType\", {\n  visitor: [\"objectType\", \"indexType\"],\n  aliases: [\"FlowType\"],\n  fields: {\n    objectType: (0, _utils.validateType)(\"FlowType\"),\n    indexType: (0, _utils.validateType)(\"FlowType\")\n  }\n});\ndefineType(\"OptionalIndexedAccessType\", {\n  visitor: [\"objectType\", \"indexType\"],\n  aliases: [\"FlowType\"],\n  fields: {\n    objectType: (0, _utils.validateType)(\"FlowType\"),\n    indexType: (0, _utils.validateType)(\"FlowType\"),\n    optional: (0, _utils.validate)((0, _utils.assertValueType)(\"boolean\"))\n  }\n});\n\n//# sourceMappingURL=flow.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGJhYmVsL3R5cGVzL2xpYi9kZWZpbml0aW9ucy9mbG93LmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViLFlBQVksbUJBQU8sQ0FBQyw0RUFBVztBQUMvQixhQUFhLG1CQUFPLENBQUMsOEVBQVk7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsTUFBTSxJQUFJO0FBQ1Y7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9yZXBvLXZpc3VhbGl6ZXIvLi9ub2RlX21vZHVsZXMvQGJhYmVsL3R5cGVzL2xpYi9kZWZpbml0aW9ucy9mbG93LmpzPzFmNWUiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBfY29yZSA9IHJlcXVpcmUoXCIuL2NvcmUuanNcIik7XG52YXIgX3V0aWxzID0gcmVxdWlyZShcIi4vdXRpbHMuanNcIik7XG5jb25zdCBkZWZpbmVUeXBlID0gKDAsIF91dGlscy5kZWZpbmVBbGlhc2VkVHlwZSkoXCJGbG93XCIpO1xuY29uc3QgZGVmaW5lSW50ZXJmYWNlaXNoVHlwZSA9IG5hbWUgPT4ge1xuICBjb25zdCBpc0RlY2xhcmVDbGFzcyA9IG5hbWUgPT09IFwiRGVjbGFyZUNsYXNzXCI7XG4gIGRlZmluZVR5cGUobmFtZSwge1xuICAgIGJ1aWxkZXI6IFtcImlkXCIsIFwidHlwZVBhcmFtZXRlcnNcIiwgXCJleHRlbmRzXCIsIFwiYm9keVwiXSxcbiAgICB2aXNpdG9yOiBbXCJpZFwiLCBcInR5cGVQYXJhbWV0ZXJzXCIsIFwiZXh0ZW5kc1wiLCAuLi4oaXNEZWNsYXJlQ2xhc3MgPyBbXCJtaXhpbnNcIiwgXCJpbXBsZW1lbnRzXCJdIDogW10pLCBcImJvZHlcIl0sXG4gICAgYWxpYXNlczogW1wiRmxvd0RlY2xhcmF0aW9uXCIsIFwiU3RhdGVtZW50XCIsIFwiRGVjbGFyYXRpb25cIl0sXG4gICAgZmllbGRzOiBPYmplY3QuYXNzaWduKHtcbiAgICAgIGlkOiAoMCwgX3V0aWxzLnZhbGlkYXRlVHlwZSkoXCJJZGVudGlmaWVyXCIpLFxuICAgICAgdHlwZVBhcmFtZXRlcnM6ICgwLCBfdXRpbHMudmFsaWRhdGVPcHRpb25hbFR5cGUpKFwiVHlwZVBhcmFtZXRlckRlY2xhcmF0aW9uXCIpLFxuICAgICAgZXh0ZW5kczogKDAsIF91dGlscy52YWxpZGF0ZU9wdGlvbmFsKSgoMCwgX3V0aWxzLmFycmF5T2ZUeXBlKShcIkludGVyZmFjZUV4dGVuZHNcIikpXG4gICAgfSwgaXNEZWNsYXJlQ2xhc3MgPyB7XG4gICAgICBtaXhpbnM6ICgwLCBfdXRpbHMudmFsaWRhdGVPcHRpb25hbCkoKDAsIF91dGlscy5hcnJheU9mVHlwZSkoXCJJbnRlcmZhY2VFeHRlbmRzXCIpKSxcbiAgICAgIGltcGxlbWVudHM6ICgwLCBfdXRpbHMudmFsaWRhdGVPcHRpb25hbCkoKDAsIF91dGlscy5hcnJheU9mVHlwZSkoXCJDbGFzc0ltcGxlbWVudHNcIikpXG4gICAgfSA6IHt9LCB7XG4gICAgICBib2R5OiAoMCwgX3V0aWxzLnZhbGlkYXRlVHlwZSkoXCJPYmplY3RUeXBlQW5ub3RhdGlvblwiKVxuICAgIH0pXG4gIH0pO1xufTtcbmRlZmluZVR5cGUoXCJBbnlUeXBlQW5ub3RhdGlvblwiLCB7XG4gIGFsaWFzZXM6IFtcIkZsb3dUeXBlXCIsIFwiRmxvd0Jhc2VBbm5vdGF0aW9uXCJdXG59KTtcbmRlZmluZVR5cGUoXCJBcnJheVR5cGVBbm5vdGF0aW9uXCIsIHtcbiAgdmlzaXRvcjogW1wiZWxlbWVudFR5cGVcIl0sXG4gIGFsaWFzZXM6IFtcIkZsb3dUeXBlXCJdLFxuICBmaWVsZHM6IHtcbiAgICBlbGVtZW50VHlwZTogKDAsIF91dGlscy52YWxpZGF0ZVR5cGUpKFwiRmxvd1R5cGVcIilcbiAgfVxufSk7XG5kZWZpbmVUeXBlKFwiQm9vbGVhblR5cGVBbm5vdGF0aW9uXCIsIHtcbiAgYWxpYXNlczogW1wiRmxvd1R5cGVcIiwgXCJGbG93QmFzZUFubm90YXRpb25cIl1cbn0pO1xuZGVmaW5lVHlwZShcIkJvb2xlYW5MaXRlcmFsVHlwZUFubm90YXRpb25cIiwge1xuICBidWlsZGVyOiBbXCJ2YWx1ZVwiXSxcbiAgYWxpYXNlczogW1wiRmxvd1R5cGVcIl0sXG4gIGZpZWxkczoge1xuICAgIHZhbHVlOiAoMCwgX3V0aWxzLnZhbGlkYXRlKSgoMCwgX3V0aWxzLmFzc2VydFZhbHVlVHlwZSkoXCJib29sZWFuXCIpKVxuICB9XG59KTtcbmRlZmluZVR5cGUoXCJOdWxsTGl0ZXJhbFR5cGVBbm5vdGF0aW9uXCIsIHtcbiAgYWxpYXNlczogW1wiRmxvd1R5cGVcIiwgXCJGbG93QmFzZUFubm90YXRpb25cIl1cbn0pO1xuZGVmaW5lVHlwZShcIkNsYXNzSW1wbGVtZW50c1wiLCB7XG4gIHZpc2l0b3I6IFtcImlkXCIsIFwidHlwZVBhcmFtZXRlcnNcIl0sXG4gIGZpZWxkczoge1xuICAgIGlkOiAoMCwgX3V0aWxzLnZhbGlkYXRlVHlwZSkoXCJJZGVudGlmaWVyXCIpLFxuICAgIHR5cGVQYXJhbWV0ZXJzOiAoMCwgX3V0aWxzLnZhbGlkYXRlT3B0aW9uYWxUeXBlKShcIlR5cGVQYXJhbWV0ZXJJbnN0YW50aWF0aW9uXCIpXG4gIH1cbn0pO1xuZGVmaW5lSW50ZXJmYWNlaXNoVHlwZShcIkRlY2xhcmVDbGFzc1wiKTtcbmRlZmluZVR5cGUoXCJEZWNsYXJlRnVuY3Rpb25cIiwge1xuICBidWlsZGVyOiBbXCJpZFwiXSxcbiAgdmlzaXRvcjogW1wiaWRcIiwgXCJwcmVkaWNhdGVcIl0sXG4gIGFsaWFzZXM6IFtcIkZsb3dEZWNsYXJhdGlvblwiLCBcIlN0YXRlbWVudFwiLCBcIkRlY2xhcmF0aW9uXCJdLFxuICBmaWVsZHM6IHtcbiAgICBpZDogKDAsIF91dGlscy52YWxpZGF0ZVR5cGUpKFwiSWRlbnRpZmllclwiKSxcbiAgICBwcmVkaWNhdGU6ICgwLCBfdXRpbHMudmFsaWRhdGVPcHRpb25hbFR5cGUpKFwiRGVjbGFyZWRQcmVkaWNhdGVcIilcbiAgfVxufSk7XG5kZWZpbmVJbnRlcmZhY2Vpc2hUeXBlKFwiRGVjbGFyZUludGVyZmFjZVwiKTtcbmRlZmluZVR5cGUoXCJEZWNsYXJlTW9kdWxlXCIsIHtcbiAgYnVpbGRlcjogW1wiaWRcIiwgXCJib2R5XCIsIFwia2luZFwiXSxcbiAgdmlzaXRvcjogW1wiaWRcIiwgXCJib2R5XCJdLFxuICBhbGlhc2VzOiBbXCJGbG93RGVjbGFyYXRpb25cIiwgXCJTdGF0ZW1lbnRcIiwgXCJEZWNsYXJhdGlvblwiXSxcbiAgZmllbGRzOiB7XG4gICAgaWQ6ICgwLCBfdXRpbHMudmFsaWRhdGVUeXBlKShcIklkZW50aWZpZXJcIiwgXCJTdHJpbmdMaXRlcmFsXCIpLFxuICAgIGJvZHk6ICgwLCBfdXRpbHMudmFsaWRhdGVUeXBlKShcIkJsb2NrU3RhdGVtZW50XCIpLFxuICAgIGtpbmQ6ICgwLCBfdXRpbHMudmFsaWRhdGVPcHRpb25hbCkoKDAsIF91dGlscy5hc3NlcnRPbmVPZikoXCJDb21tb25KU1wiLCBcIkVTXCIpKVxuICB9XG59KTtcbmRlZmluZVR5cGUoXCJEZWNsYXJlTW9kdWxlRXhwb3J0c1wiLCB7XG4gIHZpc2l0b3I6IFtcInR5cGVBbm5vdGF0aW9uXCJdLFxuICBhbGlhc2VzOiBbXCJGbG93RGVjbGFyYXRpb25cIiwgXCJTdGF0ZW1lbnRcIiwgXCJEZWNsYXJhdGlvblwiXSxcbiAgZmllbGRzOiB7XG4gICAgdHlwZUFubm90YXRpb246ICgwLCBfdXRpbHMudmFsaWRhdGVUeXBlKShcIlR5cGVBbm5vdGF0aW9uXCIpXG4gIH1cbn0pO1xuZGVmaW5lVHlwZShcIkRlY2xhcmVUeXBlQWxpYXNcIiwge1xuICB2aXNpdG9yOiBbXCJpZFwiLCBcInR5cGVQYXJhbWV0ZXJzXCIsIFwicmlnaHRcIl0sXG4gIGFsaWFzZXM6IFtcIkZsb3dEZWNsYXJhdGlvblwiLCBcIlN0YXRlbWVudFwiLCBcIkRlY2xhcmF0aW9uXCJdLFxuICBmaWVsZHM6IHtcbiAgICBpZDogKDAsIF91dGlscy52YWxpZGF0ZVR5cGUpKFwiSWRlbnRpZmllclwiKSxcbiAgICB0eXBlUGFyYW1ldGVyczogKDAsIF91dGlscy52YWxpZGF0ZU9wdGlvbmFsVHlwZSkoXCJUeXBlUGFyYW1ldGVyRGVjbGFyYXRpb25cIiksXG4gICAgcmlnaHQ6ICgwLCBfdXRpbHMudmFsaWRhdGVUeXBlKShcIkZsb3dUeXBlXCIpXG4gIH1cbn0pO1xuZGVmaW5lVHlwZShcIkRlY2xhcmVPcGFxdWVUeXBlXCIsIHtcbiAgdmlzaXRvcjogW1wiaWRcIiwgXCJ0eXBlUGFyYW1ldGVyc1wiLCBcInN1cGVydHlwZVwiXSxcbiAgYWxpYXNlczogW1wiRmxvd0RlY2xhcmF0aW9uXCIsIFwiU3RhdGVtZW50XCIsIFwiRGVjbGFyYXRpb25cIl0sXG4gIGZpZWxkczoge1xuICAgIGlkOiAoMCwgX3V0aWxzLnZhbGlkYXRlVHlwZSkoXCJJZGVudGlmaWVyXCIpLFxuICAgIHR5cGVQYXJhbWV0ZXJzOiAoMCwgX3V0aWxzLnZhbGlkYXRlT3B0aW9uYWxUeXBlKShcIlR5cGVQYXJhbWV0ZXJEZWNsYXJhdGlvblwiKSxcbiAgICBzdXBlcnR5cGU6ICgwLCBfdXRpbHMudmFsaWRhdGVPcHRpb25hbFR5cGUpKFwiRmxvd1R5cGVcIiksXG4gICAgaW1wbHR5cGU6ICgwLCBfdXRpbHMudmFsaWRhdGVPcHRpb25hbFR5cGUpKFwiRmxvd1R5cGVcIilcbiAgfVxufSk7XG5kZWZpbmVUeXBlKFwiRGVjbGFyZVZhcmlhYmxlXCIsIHtcbiAgdmlzaXRvcjogW1wiaWRcIl0sXG4gIGFsaWFzZXM6IFtcIkZsb3dEZWNsYXJhdGlvblwiLCBcIlN0YXRlbWVudFwiLCBcIkRlY2xhcmF0aW9uXCJdLFxuICBmaWVsZHM6IHtcbiAgICBpZDogKDAsIF91dGlscy52YWxpZGF0ZVR5cGUpKFwiSWRlbnRpZmllclwiKVxuICB9XG59KTtcbmRlZmluZVR5cGUoXCJEZWNsYXJlRXhwb3J0RGVjbGFyYXRpb25cIiwge1xuICB2aXNpdG9yOiBbXCJkZWNsYXJhdGlvblwiLCBcInNwZWNpZmllcnNcIiwgXCJzb3VyY2VcIiwgXCJhdHRyaWJ1dGVzXCJdLFxuICBhbGlhc2VzOiBbXCJGbG93RGVjbGFyYXRpb25cIiwgXCJTdGF0ZW1lbnRcIiwgXCJEZWNsYXJhdGlvblwiXSxcbiAgZmllbGRzOiBPYmplY3QuYXNzaWduKHtcbiAgICBkZWNsYXJhdGlvbjogKDAsIF91dGlscy52YWxpZGF0ZU9wdGlvbmFsVHlwZSkoXCJGbG93XCIpLFxuICAgIHNwZWNpZmllcnM6ICgwLCBfdXRpbHMudmFsaWRhdGVPcHRpb25hbCkoKDAsIF91dGlscy5hcnJheU9mVHlwZSkoXCJFeHBvcnRTcGVjaWZpZXJcIiwgXCJFeHBvcnROYW1lc3BhY2VTcGVjaWZpZXJcIikpLFxuICAgIHNvdXJjZTogKDAsIF91dGlscy52YWxpZGF0ZU9wdGlvbmFsVHlwZSkoXCJTdHJpbmdMaXRlcmFsXCIpLFxuICAgIGRlZmF1bHQ6ICgwLCBfdXRpbHMudmFsaWRhdGVPcHRpb25hbCkoKDAsIF91dGlscy5hc3NlcnRWYWx1ZVR5cGUpKFwiYm9vbGVhblwiKSlcbiAgfSwgX2NvcmUuaW1wb3J0QXR0cmlidXRlcylcbn0pO1xuZGVmaW5lVHlwZShcIkRlY2xhcmVFeHBvcnRBbGxEZWNsYXJhdGlvblwiLCB7XG4gIHZpc2l0b3I6IFtcInNvdXJjZVwiLCBcImF0dHJpYnV0ZXNcIl0sXG4gIGFsaWFzZXM6IFtcIkZsb3dEZWNsYXJhdGlvblwiLCBcIlN0YXRlbWVudFwiLCBcIkRlY2xhcmF0aW9uXCJdLFxuICBmaWVsZHM6IE9iamVjdC5hc3NpZ24oe1xuICAgIHNvdXJjZTogKDAsIF91dGlscy52YWxpZGF0ZVR5cGUpKFwiU3RyaW5nTGl0ZXJhbFwiKSxcbiAgICBleHBvcnRLaW5kOiAoMCwgX3V0aWxzLnZhbGlkYXRlT3B0aW9uYWwpKCgwLCBfdXRpbHMuYXNzZXJ0T25lT2YpKFwidHlwZVwiLCBcInZhbHVlXCIpKVxuICB9LCBfY29yZS5pbXBvcnRBdHRyaWJ1dGVzKVxufSk7XG5kZWZpbmVUeXBlKFwiRGVjbGFyZWRQcmVkaWNhdGVcIiwge1xuICB2aXNpdG9yOiBbXCJ2YWx1ZVwiXSxcbiAgYWxpYXNlczogW1wiRmxvd1ByZWRpY2F0ZVwiXSxcbiAgZmllbGRzOiB7XG4gICAgdmFsdWU6ICgwLCBfdXRpbHMudmFsaWRhdGVUeXBlKShcIkZsb3dcIilcbiAgfVxufSk7XG5kZWZpbmVUeXBlKFwiRXhpc3RzVHlwZUFubm90YXRpb25cIiwge1xuICBhbGlhc2VzOiBbXCJGbG93VHlwZVwiXVxufSk7XG5kZWZpbmVUeXBlKFwiRnVuY3Rpb25UeXBlQW5ub3RhdGlvblwiLCB7XG4gIGJ1aWxkZXI6IFtcInR5cGVQYXJhbWV0ZXJzXCIsIFwicGFyYW1zXCIsIFwicmVzdFwiLCBcInJldHVyblR5cGVcIl0sXG4gIHZpc2l0b3I6IFtcInR5cGVQYXJhbWV0ZXJzXCIsIFwidGhpc1wiLCBcInBhcmFtc1wiLCBcInJlc3RcIiwgXCJyZXR1cm5UeXBlXCJdLFxuICBhbGlhc2VzOiBbXCJGbG93VHlwZVwiXSxcbiAgZmllbGRzOiB7XG4gICAgdHlwZVBhcmFtZXRlcnM6ICgwLCBfdXRpbHMudmFsaWRhdGVPcHRpb25hbFR5cGUpKFwiVHlwZVBhcmFtZXRlckRlY2xhcmF0aW9uXCIpLFxuICAgIHBhcmFtczogKDAsIF91dGlscy52YWxpZGF0ZUFycmF5T2ZUeXBlKShcIkZ1bmN0aW9uVHlwZVBhcmFtXCIpLFxuICAgIHJlc3Q6ICgwLCBfdXRpbHMudmFsaWRhdGVPcHRpb25hbFR5cGUpKFwiRnVuY3Rpb25UeXBlUGFyYW1cIiksXG4gICAgdGhpczogKDAsIF91dGlscy52YWxpZGF0ZU9wdGlvbmFsVHlwZSkoXCJGdW5jdGlvblR5cGVQYXJhbVwiKSxcbiAgICByZXR1cm5UeXBlOiAoMCwgX3V0aWxzLnZhbGlkYXRlVHlwZSkoXCJGbG93VHlwZVwiKVxuICB9XG59KTtcbmRlZmluZVR5cGUoXCJGdW5jdGlvblR5cGVQYXJhbVwiLCB7XG4gIHZpc2l0b3I6IFtcIm5hbWVcIiwgXCJ0eXBlQW5ub3RhdGlvblwiXSxcbiAgZmllbGRzOiB7XG4gICAgbmFtZTogKDAsIF91dGlscy52YWxpZGF0ZU9wdGlvbmFsVHlwZSkoXCJJZGVudGlmaWVyXCIpLFxuICAgIHR5cGVBbm5vdGF0aW9uOiAoMCwgX3V0aWxzLnZhbGlkYXRlVHlwZSkoXCJGbG93VHlwZVwiKSxcbiAgICBvcHRpb25hbDogKDAsIF91dGlscy52YWxpZGF0ZU9wdGlvbmFsKSgoMCwgX3V0aWxzLmFzc2VydFZhbHVlVHlwZSkoXCJib29sZWFuXCIpKVxuICB9XG59KTtcbmRlZmluZVR5cGUoXCJHZW5lcmljVHlwZUFubm90YXRpb25cIiwge1xuICB2aXNpdG9yOiBbXCJpZFwiLCBcInR5cGVQYXJhbWV0ZXJzXCJdLFxuICBhbGlhc2VzOiBbXCJGbG93VHlwZVwiXSxcbiAgZmllbGRzOiB7XG4gICAgaWQ6ICgwLCBfdXRpbHMudmFsaWRhdGVUeXBlKShcIklkZW50aWZpZXJcIiwgXCJRdWFsaWZpZWRUeXBlSWRlbnRpZmllclwiKSxcbiAgICB0eXBlUGFyYW1ldGVyczogKDAsIF91dGlscy52YWxpZGF0ZU9wdGlvbmFsVHlwZSkoXCJUeXBlUGFyYW1ldGVySW5zdGFudGlhdGlvblwiKVxuICB9XG59KTtcbmRlZmluZVR5cGUoXCJJbmZlcnJlZFByZWRpY2F0ZVwiLCB7XG4gIGFsaWFzZXM6IFtcIkZsb3dQcmVkaWNhdGVcIl1cbn0pO1xuZGVmaW5lVHlwZShcIkludGVyZmFjZUV4dGVuZHNcIiwge1xuICB2aXNpdG9yOiBbXCJpZFwiLCBcInR5cGVQYXJhbWV0ZXJzXCJdLFxuICBmaWVsZHM6IHtcbiAgICBpZDogKDAsIF91dGlscy52YWxpZGF0ZVR5cGUpKFwiSWRlbnRpZmllclwiLCBcIlF1YWxpZmllZFR5cGVJZGVudGlmaWVyXCIpLFxuICAgIHR5cGVQYXJhbWV0ZXJzOiAoMCwgX3V0aWxzLnZhbGlkYXRlT3B0aW9uYWxUeXBlKShcIlR5cGVQYXJhbWV0ZXJJbnN0YW50aWF0aW9uXCIpXG4gIH1cbn0pO1xuZGVmaW5lSW50ZXJmYWNlaXNoVHlwZShcIkludGVyZmFjZURlY2xhcmF0aW9uXCIpO1xuZGVmaW5lVHlwZShcIkludGVyZmFjZVR5cGVBbm5vdGF0aW9uXCIsIHtcbiAgdmlzaXRvcjogW1wiZXh0ZW5kc1wiLCBcImJvZHlcIl0sXG4gIGFsaWFzZXM6IFtcIkZsb3dUeXBlXCJdLFxuICBmaWVsZHM6IHtcbiAgICBleHRlbmRzOiAoMCwgX3V0aWxzLnZhbGlkYXRlT3B0aW9uYWwpKCgwLCBfdXRpbHMuYXJyYXlPZlR5cGUpKFwiSW50ZXJmYWNlRXh0ZW5kc1wiKSksXG4gICAgYm9keTogKDAsIF91dGlscy52YWxpZGF0ZVR5cGUpKFwiT2JqZWN0VHlwZUFubm90YXRpb25cIilcbiAgfVxufSk7XG5kZWZpbmVUeXBlKFwiSW50ZXJzZWN0aW9uVHlwZUFubm90YXRpb25cIiwge1xuICB2aXNpdG9yOiBbXCJ0eXBlc1wiXSxcbiAgYWxpYXNlczogW1wiRmxvd1R5cGVcIl0sXG4gIGZpZWxkczoge1xuICAgIHR5cGVzOiAoMCwgX3V0aWxzLnZhbGlkYXRlKSgoMCwgX3V0aWxzLmFycmF5T2ZUeXBlKShcIkZsb3dUeXBlXCIpKVxuICB9XG59KTtcbmRlZmluZVR5cGUoXCJNaXhlZFR5cGVBbm5vdGF0aW9uXCIsIHtcbiAgYWxpYXNlczogW1wiRmxvd1R5cGVcIiwgXCJGbG93QmFzZUFubm90YXRpb25cIl1cbn0pO1xuZGVmaW5lVHlwZShcIkVtcHR5VHlwZUFubm90YXRpb25cIiwge1xuICBhbGlhc2VzOiBbXCJGbG93VHlwZVwiLCBcIkZsb3dCYXNlQW5ub3RhdGlvblwiXVxufSk7XG5kZWZpbmVUeXBlKFwiTnVsbGFibGVUeXBlQW5ub3RhdGlvblwiLCB7XG4gIHZpc2l0b3I6IFtcInR5cGVBbm5vdGF0aW9uXCJdLFxuICBhbGlhc2VzOiBbXCJGbG93VHlwZVwiXSxcbiAgZmllbGRzOiB7XG4gICAgdHlwZUFubm90YXRpb246ICgwLCBfdXRpbHMudmFsaWRhdGVUeXBlKShcIkZsb3dUeXBlXCIpXG4gIH1cbn0pO1xuZGVmaW5lVHlwZShcIk51bWJlckxpdGVyYWxUeXBlQW5ub3RhdGlvblwiLCB7XG4gIGJ1aWxkZXI6IFtcInZhbHVlXCJdLFxuICBhbGlhc2VzOiBbXCJGbG93VHlwZVwiXSxcbiAgZmllbGRzOiB7XG4gICAgdmFsdWU6ICgwLCBfdXRpbHMudmFsaWRhdGUpKCgwLCBfdXRpbHMuYXNzZXJ0VmFsdWVUeXBlKShcIm51bWJlclwiKSlcbiAgfVxufSk7XG5kZWZpbmVUeXBlKFwiTnVtYmVyVHlwZUFubm90YXRpb25cIiwge1xuICBhbGlhc2VzOiBbXCJGbG93VHlwZVwiLCBcIkZsb3dCYXNlQW5ub3RhdGlvblwiXVxufSk7XG5kZWZpbmVUeXBlKFwiT2JqZWN0VHlwZUFubm90YXRpb25cIiwge1xuICB2aXNpdG9yOiBbXCJwcm9wZXJ0aWVzXCIsIFwiaW5kZXhlcnNcIiwgXCJjYWxsUHJvcGVydGllc1wiLCBcImludGVybmFsU2xvdHNcIl0sXG4gIGFsaWFzZXM6IFtcIkZsb3dUeXBlXCJdLFxuICBidWlsZGVyOiBbXCJwcm9wZXJ0aWVzXCIsIFwiaW5kZXhlcnNcIiwgXCJjYWxsUHJvcGVydGllc1wiLCBcImludGVybmFsU2xvdHNcIiwgXCJleGFjdFwiXSxcbiAgZmllbGRzOiB7XG4gICAgcHJvcGVydGllczogKDAsIF91dGlscy52YWxpZGF0ZSkoKDAsIF91dGlscy5hcnJheU9mVHlwZSkoXCJPYmplY3RUeXBlUHJvcGVydHlcIiwgXCJPYmplY3RUeXBlU3ByZWFkUHJvcGVydHlcIikpLFxuICAgIGluZGV4ZXJzOiB7XG4gICAgICB2YWxpZGF0ZTogKDAsIF91dGlscy5hcnJheU9mVHlwZSkoXCJPYmplY3RUeXBlSW5kZXhlclwiKSxcbiAgICAgIG9wdGlvbmFsOiB0cnVlLFxuICAgICAgZGVmYXVsdDogW11cbiAgICB9LFxuICAgIGNhbGxQcm9wZXJ0aWVzOiB7XG4gICAgICB2YWxpZGF0ZTogKDAsIF91dGlscy5hcnJheU9mVHlwZSkoXCJPYmplY3RUeXBlQ2FsbFByb3BlcnR5XCIpLFxuICAgICAgb3B0aW9uYWw6IHRydWUsXG4gICAgICBkZWZhdWx0OiBbXVxuICAgIH0sXG4gICAgaW50ZXJuYWxTbG90czoge1xuICAgICAgdmFsaWRhdGU6ICgwLCBfdXRpbHMuYXJyYXlPZlR5cGUpKFwiT2JqZWN0VHlwZUludGVybmFsU2xvdFwiKSxcbiAgICAgIG9wdGlvbmFsOiB0cnVlLFxuICAgICAgZGVmYXVsdDogW11cbiAgICB9LFxuICAgIGV4YWN0OiB7XG4gICAgICB2YWxpZGF0ZTogKDAsIF91dGlscy5hc3NlcnRWYWx1ZVR5cGUpKFwiYm9vbGVhblwiKSxcbiAgICAgIGRlZmF1bHQ6IGZhbHNlXG4gICAgfSxcbiAgICBpbmV4YWN0OiAoMCwgX3V0aWxzLnZhbGlkYXRlT3B0aW9uYWwpKCgwLCBfdXRpbHMuYXNzZXJ0VmFsdWVUeXBlKShcImJvb2xlYW5cIikpXG4gIH1cbn0pO1xuZGVmaW5lVHlwZShcIk9iamVjdFR5cGVJbnRlcm5hbFNsb3RcIiwge1xuICB2aXNpdG9yOiBbXCJpZFwiLCBcInZhbHVlXCJdLFxuICBidWlsZGVyOiBbXCJpZFwiLCBcInZhbHVlXCIsIFwib3B0aW9uYWxcIiwgXCJzdGF0aWNcIiwgXCJtZXRob2RcIl0sXG4gIGFsaWFzZXM6IFtcIlVzZXJXaGl0ZXNwYWNhYmxlXCJdLFxuICBmaWVsZHM6IHtcbiAgICBpZDogKDAsIF91dGlscy52YWxpZGF0ZVR5cGUpKFwiSWRlbnRpZmllclwiKSxcbiAgICB2YWx1ZTogKDAsIF91dGlscy52YWxpZGF0ZVR5cGUpKFwiRmxvd1R5cGVcIiksXG4gICAgb3B0aW9uYWw6ICgwLCBfdXRpbHMudmFsaWRhdGUpKCgwLCBfdXRpbHMuYXNzZXJ0VmFsdWVUeXBlKShcImJvb2xlYW5cIikpLFxuICAgIHN0YXRpYzogKDAsIF91dGlscy52YWxpZGF0ZSkoKDAsIF91dGlscy5hc3NlcnRWYWx1ZVR5cGUpKFwiYm9vbGVhblwiKSksXG4gICAgbWV0aG9kOiAoMCwgX3V0aWxzLnZhbGlkYXRlKSgoMCwgX3V0aWxzLmFzc2VydFZhbHVlVHlwZSkoXCJib29sZWFuXCIpKVxuICB9XG59KTtcbmRlZmluZVR5cGUoXCJPYmplY3RUeXBlQ2FsbFByb3BlcnR5XCIsIHtcbiAgdmlzaXRvcjogW1widmFsdWVcIl0sXG4gIGFsaWFzZXM6IFtcIlVzZXJXaGl0ZXNwYWNhYmxlXCJdLFxuICBmaWVsZHM6IHtcbiAgICB2YWx1ZTogKDAsIF91dGlscy52YWxpZGF0ZVR5cGUpKFwiRmxvd1R5cGVcIiksXG4gICAgc3RhdGljOiAoMCwgX3V0aWxzLnZhbGlkYXRlKSgoMCwgX3V0aWxzLmFzc2VydFZhbHVlVHlwZSkoXCJib29sZWFuXCIpKVxuICB9XG59KTtcbmRlZmluZVR5cGUoXCJPYmplY3RUeXBlSW5kZXhlclwiLCB7XG4gIHZpc2l0b3I6IFtcInZhcmlhbmNlXCIsIFwiaWRcIiwgXCJrZXlcIiwgXCJ2YWx1ZVwiXSxcbiAgYnVpbGRlcjogW1wiaWRcIiwgXCJrZXlcIiwgXCJ2YWx1ZVwiLCBcInZhcmlhbmNlXCJdLFxuICBhbGlhc2VzOiBbXCJVc2VyV2hpdGVzcGFjYWJsZVwiXSxcbiAgZmllbGRzOiB7XG4gICAgaWQ6ICgwLCBfdXRpbHMudmFsaWRhdGVPcHRpb25hbFR5cGUpKFwiSWRlbnRpZmllclwiKSxcbiAgICBrZXk6ICgwLCBfdXRpbHMudmFsaWRhdGVUeXBlKShcIkZsb3dUeXBlXCIpLFxuICAgIHZhbHVlOiAoMCwgX3V0aWxzLnZhbGlkYXRlVHlwZSkoXCJGbG93VHlwZVwiKSxcbiAgICBzdGF0aWM6ICgwLCBfdXRpbHMudmFsaWRhdGUpKCgwLCBfdXRpbHMuYXNzZXJ0VmFsdWVUeXBlKShcImJvb2xlYW5cIikpLFxuICAgIHZhcmlhbmNlOiAoMCwgX3V0aWxzLnZhbGlkYXRlT3B0aW9uYWxUeXBlKShcIlZhcmlhbmNlXCIpXG4gIH1cbn0pO1xuZGVmaW5lVHlwZShcIk9iamVjdFR5cGVQcm9wZXJ0eVwiLCB7XG4gIHZpc2l0b3I6IFtcImtleVwiLCBcInZhbHVlXCIsIFwidmFyaWFuY2VcIl0sXG4gIGFsaWFzZXM6IFtcIlVzZXJXaGl0ZXNwYWNhYmxlXCJdLFxuICBmaWVsZHM6IHtcbiAgICBrZXk6ICgwLCBfdXRpbHMudmFsaWRhdGVUeXBlKShcIklkZW50aWZpZXJcIiwgXCJTdHJpbmdMaXRlcmFsXCIpLFxuICAgIHZhbHVlOiAoMCwgX3V0aWxzLnZhbGlkYXRlVHlwZSkoXCJGbG93VHlwZVwiKSxcbiAgICBraW5kOiAoMCwgX3V0aWxzLnZhbGlkYXRlKSgoMCwgX3V0aWxzLmFzc2VydE9uZU9mKShcImluaXRcIiwgXCJnZXRcIiwgXCJzZXRcIikpLFxuICAgIHN0YXRpYzogKDAsIF91dGlscy52YWxpZGF0ZSkoKDAsIF91dGlscy5hc3NlcnRWYWx1ZVR5cGUpKFwiYm9vbGVhblwiKSksXG4gICAgcHJvdG86ICgwLCBfdXRpbHMudmFsaWRhdGUpKCgwLCBfdXRpbHMuYXNzZXJ0VmFsdWVUeXBlKShcImJvb2xlYW5cIikpLFxuICAgIG9wdGlvbmFsOiAoMCwgX3V0aWxzLnZhbGlkYXRlKSgoMCwgX3V0aWxzLmFzc2VydFZhbHVlVHlwZSkoXCJib29sZWFuXCIpKSxcbiAgICB2YXJpYW5jZTogKDAsIF91dGlscy52YWxpZGF0ZU9wdGlvbmFsVHlwZSkoXCJWYXJpYW5jZVwiKSxcbiAgICBtZXRob2Q6ICgwLCBfdXRpbHMudmFsaWRhdGUpKCgwLCBfdXRpbHMuYXNzZXJ0VmFsdWVUeXBlKShcImJvb2xlYW5cIikpXG4gIH1cbn0pO1xuZGVmaW5lVHlwZShcIk9iamVjdFR5cGVTcHJlYWRQcm9wZXJ0eVwiLCB7XG4gIHZpc2l0b3I6IFtcImFyZ3VtZW50XCJdLFxuICBhbGlhc2VzOiBbXCJVc2VyV2hpdGVzcGFjYWJsZVwiXSxcbiAgZmllbGRzOiB7XG4gICAgYXJndW1lbnQ6ICgwLCBfdXRpbHMudmFsaWRhdGVUeXBlKShcIkZsb3dUeXBlXCIpXG4gIH1cbn0pO1xuZGVmaW5lVHlwZShcIk9wYXF1ZVR5cGVcIiwge1xuICB2aXNpdG9yOiBbXCJpZFwiLCBcInR5cGVQYXJhbWV0ZXJzXCIsIFwic3VwZXJ0eXBlXCIsIFwiaW1wbHR5cGVcIl0sXG4gIGFsaWFzZXM6IFtcIkZsb3dEZWNsYXJhdGlvblwiLCBcIlN0YXRlbWVudFwiLCBcIkRlY2xhcmF0aW9uXCJdLFxuICBmaWVsZHM6IHtcbiAgICBpZDogKDAsIF91dGlscy52YWxpZGF0ZVR5cGUpKFwiSWRlbnRpZmllclwiKSxcbiAgICB0eXBlUGFyYW1ldGVyczogKDAsIF91dGlscy52YWxpZGF0ZU9wdGlvbmFsVHlwZSkoXCJUeXBlUGFyYW1ldGVyRGVjbGFyYXRpb25cIiksXG4gICAgc3VwZXJ0eXBlOiAoMCwgX3V0aWxzLnZhbGlkYXRlT3B0aW9uYWxUeXBlKShcIkZsb3dUeXBlXCIpLFxuICAgIGltcGx0eXBlOiAoMCwgX3V0aWxzLnZhbGlkYXRlVHlwZSkoXCJGbG93VHlwZVwiKVxuICB9XG59KTtcbmRlZmluZVR5cGUoXCJRdWFsaWZpZWRUeXBlSWRlbnRpZmllclwiLCB7XG4gIHZpc2l0b3I6IFtcInF1YWxpZmljYXRpb25cIiwgXCJpZFwiXSxcbiAgYnVpbGRlcjogW1wiaWRcIiwgXCJxdWFsaWZpY2F0aW9uXCJdLFxuICBmaWVsZHM6IHtcbiAgICBpZDogKDAsIF91dGlscy52YWxpZGF0ZVR5cGUpKFwiSWRlbnRpZmllclwiKSxcbiAgICBxdWFsaWZpY2F0aW9uOiAoMCwgX3V0aWxzLnZhbGlkYXRlVHlwZSkoXCJJZGVudGlmaWVyXCIsIFwiUXVhbGlmaWVkVHlwZUlkZW50aWZpZXJcIilcbiAgfVxufSk7XG5kZWZpbmVUeXBlKFwiU3RyaW5nTGl0ZXJhbFR5cGVBbm5vdGF0aW9uXCIsIHtcbiAgYnVpbGRlcjogW1widmFsdWVcIl0sXG4gIGFsaWFzZXM6IFtcIkZsb3dUeXBlXCJdLFxuICBmaWVsZHM6IHtcbiAgICB2YWx1ZTogKDAsIF91dGlscy52YWxpZGF0ZSkoKDAsIF91dGlscy5hc3NlcnRWYWx1ZVR5cGUpKFwic3RyaW5nXCIpKVxuICB9XG59KTtcbmRlZmluZVR5cGUoXCJTdHJpbmdUeXBlQW5ub3RhdGlvblwiLCB7XG4gIGFsaWFzZXM6IFtcIkZsb3dUeXBlXCIsIFwiRmxvd0Jhc2VBbm5vdGF0aW9uXCJdXG59KTtcbmRlZmluZVR5cGUoXCJTeW1ib2xUeXBlQW5ub3RhdGlvblwiLCB7XG4gIGFsaWFzZXM6IFtcIkZsb3dUeXBlXCIsIFwiRmxvd0Jhc2VBbm5vdGF0aW9uXCJdXG59KTtcbmRlZmluZVR5cGUoXCJUaGlzVHlwZUFubm90YXRpb25cIiwge1xuICBhbGlhc2VzOiBbXCJGbG93VHlwZVwiLCBcIkZsb3dCYXNlQW5ub3RhdGlvblwiXVxufSk7XG5kZWZpbmVUeXBlKFwiVHVwbGVUeXBlQW5ub3RhdGlvblwiLCB7XG4gIHZpc2l0b3I6IFtcInR5cGVzXCJdLFxuICBhbGlhc2VzOiBbXCJGbG93VHlwZVwiXSxcbiAgZmllbGRzOiB7XG4gICAgdHlwZXM6ICgwLCBfdXRpbHMudmFsaWRhdGUpKCgwLCBfdXRpbHMuYXJyYXlPZlR5cGUpKFwiRmxvd1R5cGVcIikpXG4gIH1cbn0pO1xuZGVmaW5lVHlwZShcIlR5cGVvZlR5cGVBbm5vdGF0aW9uXCIsIHtcbiAgdmlzaXRvcjogW1wiYXJndW1lbnRcIl0sXG4gIGFsaWFzZXM6IFtcIkZsb3dUeXBlXCJdLFxuICBmaWVsZHM6IHtcbiAgICBhcmd1bWVudDogKDAsIF91dGlscy52YWxpZGF0ZVR5cGUpKFwiRmxvd1R5cGVcIilcbiAgfVxufSk7XG5kZWZpbmVUeXBlKFwiVHlwZUFsaWFzXCIsIHtcbiAgdmlzaXRvcjogW1wiaWRcIiwgXCJ0eXBlUGFyYW1ldGVyc1wiLCBcInJpZ2h0XCJdLFxuICBhbGlhc2VzOiBbXCJGbG93RGVjbGFyYXRpb25cIiwgXCJTdGF0ZW1lbnRcIiwgXCJEZWNsYXJhdGlvblwiXSxcbiAgZmllbGRzOiB7XG4gICAgaWQ6ICgwLCBfdXRpbHMudmFsaWRhdGVUeXBlKShcIklkZW50aWZpZXJcIiksXG4gICAgdHlwZVBhcmFtZXRlcnM6ICgwLCBfdXRpbHMudmFsaWRhdGVPcHRpb25hbFR5cGUpKFwiVHlwZVBhcmFtZXRlckRlY2xhcmF0aW9uXCIpLFxuICAgIHJpZ2h0OiAoMCwgX3V0aWxzLnZhbGlkYXRlVHlwZSkoXCJGbG93VHlwZVwiKVxuICB9XG59KTtcbmRlZmluZVR5cGUoXCJUeXBlQW5ub3RhdGlvblwiLCB7XG4gIHZpc2l0b3I6IFtcInR5cGVBbm5vdGF0aW9uXCJdLFxuICBmaWVsZHM6IHtcbiAgICB0eXBlQW5ub3RhdGlvbjogKDAsIF91dGlscy52YWxpZGF0ZVR5cGUpKFwiRmxvd1R5cGVcIilcbiAgfVxufSk7XG5kZWZpbmVUeXBlKFwiVHlwZUNhc3RFeHByZXNzaW9uXCIsIHtcbiAgdmlzaXRvcjogW1wiZXhwcmVzc2lvblwiLCBcInR5cGVBbm5vdGF0aW9uXCJdLFxuICBhbGlhc2VzOiBbXCJFeHByZXNzaW9uV3JhcHBlclwiLCBcIkV4cHJlc3Npb25cIl0sXG4gIGZpZWxkczoge1xuICAgIGV4cHJlc3Npb246ICgwLCBfdXRpbHMudmFsaWRhdGVUeXBlKShcIkV4cHJlc3Npb25cIiksXG4gICAgdHlwZUFubm90YXRpb246ICgwLCBfdXRpbHMudmFsaWRhdGVUeXBlKShcIlR5cGVBbm5vdGF0aW9uXCIpXG4gIH1cbn0pO1xuZGVmaW5lVHlwZShcIlR5cGVQYXJhbWV0ZXJcIiwge1xuICB2aXNpdG9yOiBbXCJib3VuZFwiLCBcImRlZmF1bHRcIiwgXCJ2YXJpYW5jZVwiXSxcbiAgZmllbGRzOiB7XG4gICAgbmFtZTogKDAsIF91dGlscy52YWxpZGF0ZSkoKDAsIF91dGlscy5hc3NlcnRWYWx1ZVR5cGUpKFwic3RyaW5nXCIpKSxcbiAgICBib3VuZDogKDAsIF91dGlscy52YWxpZGF0ZU9wdGlvbmFsVHlwZSkoXCJUeXBlQW5ub3RhdGlvblwiKSxcbiAgICBkZWZhdWx0OiAoMCwgX3V0aWxzLnZhbGlkYXRlT3B0aW9uYWxUeXBlKShcIkZsb3dUeXBlXCIpLFxuICAgIHZhcmlhbmNlOiAoMCwgX3V0aWxzLnZhbGlkYXRlT3B0aW9uYWxUeXBlKShcIlZhcmlhbmNlXCIpXG4gIH1cbn0pO1xuZGVmaW5lVHlwZShcIlR5cGVQYXJhbWV0ZXJEZWNsYXJhdGlvblwiLCB7XG4gIHZpc2l0b3I6IFtcInBhcmFtc1wiXSxcbiAgZmllbGRzOiB7XG4gICAgcGFyYW1zOiAoMCwgX3V0aWxzLnZhbGlkYXRlKSgoMCwgX3V0aWxzLmFycmF5T2ZUeXBlKShcIlR5cGVQYXJhbWV0ZXJcIikpXG4gIH1cbn0pO1xuZGVmaW5lVHlwZShcIlR5cGVQYXJhbWV0ZXJJbnN0YW50aWF0aW9uXCIsIHtcbiAgdmlzaXRvcjogW1wicGFyYW1zXCJdLFxuICBmaWVsZHM6IHtcbiAgICBwYXJhbXM6ICgwLCBfdXRpbHMudmFsaWRhdGUpKCgwLCBfdXRpbHMuYXJyYXlPZlR5cGUpKFwiRmxvd1R5cGVcIikpXG4gIH1cbn0pO1xuZGVmaW5lVHlwZShcIlVuaW9uVHlwZUFubm90YXRpb25cIiwge1xuICB2aXNpdG9yOiBbXCJ0eXBlc1wiXSxcbiAgYWxpYXNlczogW1wiRmxvd1R5cGVcIl0sXG4gIGZpZWxkczoge1xuICAgIHR5cGVzOiAoMCwgX3V0aWxzLnZhbGlkYXRlKSgoMCwgX3V0aWxzLmFycmF5T2ZUeXBlKShcIkZsb3dUeXBlXCIpKVxuICB9XG59KTtcbmRlZmluZVR5cGUoXCJWYXJpYW5jZVwiLCB7XG4gIGJ1aWxkZXI6IFtcImtpbmRcIl0sXG4gIGZpZWxkczoge1xuICAgIGtpbmQ6ICgwLCBfdXRpbHMudmFsaWRhdGUpKCgwLCBfdXRpbHMuYXNzZXJ0T25lT2YpKFwibWludXNcIiwgXCJwbHVzXCIpKVxuICB9XG59KTtcbmRlZmluZVR5cGUoXCJWb2lkVHlwZUFubm90YXRpb25cIiwge1xuICBhbGlhc2VzOiBbXCJGbG93VHlwZVwiLCBcIkZsb3dCYXNlQW5ub3RhdGlvblwiXVxufSk7XG5kZWZpbmVUeXBlKFwiRW51bURlY2xhcmF0aW9uXCIsIHtcbiAgYWxpYXNlczogW1wiU3RhdGVtZW50XCIsIFwiRGVjbGFyYXRpb25cIl0sXG4gIHZpc2l0b3I6IFtcImlkXCIsIFwiYm9keVwiXSxcbiAgZmllbGRzOiB7XG4gICAgaWQ6ICgwLCBfdXRpbHMudmFsaWRhdGVUeXBlKShcIklkZW50aWZpZXJcIiksXG4gICAgYm9keTogKDAsIF91dGlscy52YWxpZGF0ZVR5cGUpKFwiRW51bUJvb2xlYW5Cb2R5XCIsIFwiRW51bU51bWJlckJvZHlcIiwgXCJFbnVtU3RyaW5nQm9keVwiLCBcIkVudW1TeW1ib2xCb2R5XCIpXG4gIH1cbn0pO1xuZGVmaW5lVHlwZShcIkVudW1Cb29sZWFuQm9keVwiLCB7XG4gIGFsaWFzZXM6IFtcIkVudW1Cb2R5XCJdLFxuICB2aXNpdG9yOiBbXCJtZW1iZXJzXCJdLFxuICBmaWVsZHM6IHtcbiAgICBleHBsaWNpdFR5cGU6ICgwLCBfdXRpbHMudmFsaWRhdGUpKCgwLCBfdXRpbHMuYXNzZXJ0VmFsdWVUeXBlKShcImJvb2xlYW5cIikpLFxuICAgIG1lbWJlcnM6ICgwLCBfdXRpbHMudmFsaWRhdGVBcnJheU9mVHlwZSkoXCJFbnVtQm9vbGVhbk1lbWJlclwiKSxcbiAgICBoYXNVbmtub3duTWVtYmVyczogKDAsIF91dGlscy52YWxpZGF0ZSkoKDAsIF91dGlscy5hc3NlcnRWYWx1ZVR5cGUpKFwiYm9vbGVhblwiKSlcbiAgfVxufSk7XG5kZWZpbmVUeXBlKFwiRW51bU51bWJlckJvZHlcIiwge1xuICBhbGlhc2VzOiBbXCJFbnVtQm9keVwiXSxcbiAgdmlzaXRvcjogW1wibWVtYmVyc1wiXSxcbiAgZmllbGRzOiB7XG4gICAgZXhwbGljaXRUeXBlOiAoMCwgX3V0aWxzLnZhbGlkYXRlKSgoMCwgX3V0aWxzLmFzc2VydFZhbHVlVHlwZSkoXCJib29sZWFuXCIpKSxcbiAgICBtZW1iZXJzOiAoMCwgX3V0aWxzLnZhbGlkYXRlQXJyYXlPZlR5cGUpKFwiRW51bU51bWJlck1lbWJlclwiKSxcbiAgICBoYXNVbmtub3duTWVtYmVyczogKDAsIF91dGlscy52YWxpZGF0ZSkoKDAsIF91dGlscy5hc3NlcnRWYWx1ZVR5cGUpKFwiYm9vbGVhblwiKSlcbiAgfVxufSk7XG5kZWZpbmVUeXBlKFwiRW51bVN0cmluZ0JvZHlcIiwge1xuICBhbGlhc2VzOiBbXCJFbnVtQm9keVwiXSxcbiAgdmlzaXRvcjogW1wibWVtYmVyc1wiXSxcbiAgZmllbGRzOiB7XG4gICAgZXhwbGljaXRUeXBlOiAoMCwgX3V0aWxzLnZhbGlkYXRlKSgoMCwgX3V0aWxzLmFzc2VydFZhbHVlVHlwZSkoXCJib29sZWFuXCIpKSxcbiAgICBtZW1iZXJzOiAoMCwgX3V0aWxzLnZhbGlkYXRlQXJyYXlPZlR5cGUpKFwiRW51bVN0cmluZ01lbWJlclwiLCBcIkVudW1EZWZhdWx0ZWRNZW1iZXJcIiksXG4gICAgaGFzVW5rbm93bk1lbWJlcnM6ICgwLCBfdXRpbHMudmFsaWRhdGUpKCgwLCBfdXRpbHMuYXNzZXJ0VmFsdWVUeXBlKShcImJvb2xlYW5cIikpXG4gIH1cbn0pO1xuZGVmaW5lVHlwZShcIkVudW1TeW1ib2xCb2R5XCIsIHtcbiAgYWxpYXNlczogW1wiRW51bUJvZHlcIl0sXG4gIHZpc2l0b3I6IFtcIm1lbWJlcnNcIl0sXG4gIGZpZWxkczoge1xuICAgIG1lbWJlcnM6ICgwLCBfdXRpbHMudmFsaWRhdGVBcnJheU9mVHlwZSkoXCJFbnVtRGVmYXVsdGVkTWVtYmVyXCIpLFxuICAgIGhhc1Vua25vd25NZW1iZXJzOiAoMCwgX3V0aWxzLnZhbGlkYXRlKSgoMCwgX3V0aWxzLmFzc2VydFZhbHVlVHlwZSkoXCJib29sZWFuXCIpKVxuICB9XG59KTtcbmRlZmluZVR5cGUoXCJFbnVtQm9vbGVhbk1lbWJlclwiLCB7XG4gIGFsaWFzZXM6IFtcIkVudW1NZW1iZXJcIl0sXG4gIGJ1aWxkZXI6IFtcImlkXCJdLFxuICB2aXNpdG9yOiBbXCJpZFwiLCBcImluaXRcIl0sXG4gIGZpZWxkczoge1xuICAgIGlkOiAoMCwgX3V0aWxzLnZhbGlkYXRlVHlwZSkoXCJJZGVudGlmaWVyXCIpLFxuICAgIGluaXQ6ICgwLCBfdXRpbHMudmFsaWRhdGVUeXBlKShcIkJvb2xlYW5MaXRlcmFsXCIpXG4gIH1cbn0pO1xuZGVmaW5lVHlwZShcIkVudW1OdW1iZXJNZW1iZXJcIiwge1xuICBhbGlhc2VzOiBbXCJFbnVtTWVtYmVyXCJdLFxuICB2aXNpdG9yOiBbXCJpZFwiLCBcImluaXRcIl0sXG4gIGZpZWxkczoge1xuICAgIGlkOiAoMCwgX3V0aWxzLnZhbGlkYXRlVHlwZSkoXCJJZGVudGlmaWVyXCIpLFxuICAgIGluaXQ6ICgwLCBfdXRpbHMudmFsaWRhdGVUeXBlKShcIk51bWVyaWNMaXRlcmFsXCIpXG4gIH1cbn0pO1xuZGVmaW5lVHlwZShcIkVudW1TdHJpbmdNZW1iZXJcIiwge1xuICBhbGlhc2VzOiBbXCJFbnVtTWVtYmVyXCJdLFxuICB2aXNpdG9yOiBbXCJpZFwiLCBcImluaXRcIl0sXG4gIGZpZWxkczoge1xuICAgIGlkOiAoMCwgX3V0aWxzLnZhbGlkYXRlVHlwZSkoXCJJZGVudGlmaWVyXCIpLFxuICAgIGluaXQ6ICgwLCBfdXRpbHMudmFsaWRhdGVUeXBlKShcIlN0cmluZ0xpdGVyYWxcIilcbiAgfVxufSk7XG5kZWZpbmVUeXBlKFwiRW51bURlZmF1bHRlZE1lbWJlclwiLCB7XG4gIGFsaWFzZXM6IFtcIkVudW1NZW1iZXJcIl0sXG4gIHZpc2l0b3I6IFtcImlkXCJdLFxuICBmaWVsZHM6IHtcbiAgICBpZDogKDAsIF91dGlscy52YWxpZGF0ZVR5cGUpKFwiSWRlbnRpZmllclwiKVxuICB9XG59KTtcbmRlZmluZVR5cGUoXCJJbmRleGVkQWNjZXNzVHlwZVwiLCB7XG4gIHZpc2l0b3I6IFtcIm9iamVjdFR5cGVcIiwgXCJpbmRleFR5cGVcIl0sXG4gIGFsaWFzZXM6IFtcIkZsb3dUeXBlXCJdLFxuICBmaWVsZHM6IHtcbiAgICBvYmplY3RUeXBlOiAoMCwgX3V0aWxzLnZhbGlkYXRlVHlwZSkoXCJGbG93VHlwZVwiKSxcbiAgICBpbmRleFR5cGU6ICgwLCBfdXRpbHMudmFsaWRhdGVUeXBlKShcIkZsb3dUeXBlXCIpXG4gIH1cbn0pO1xuZGVmaW5lVHlwZShcIk9wdGlvbmFsSW5kZXhlZEFjY2Vzc1R5cGVcIiwge1xuICB2aXNpdG9yOiBbXCJvYmplY3RUeXBlXCIsIFwiaW5kZXhUeXBlXCJdLFxuICBhbGlhc2VzOiBbXCJGbG93VHlwZVwiXSxcbiAgZmllbGRzOiB7XG4gICAgb2JqZWN0VHlwZTogKDAsIF91dGlscy52YWxpZGF0ZVR5cGUpKFwiRmxvd1R5cGVcIiksXG4gICAgaW5kZXhUeXBlOiAoMCwgX3V0aWxzLnZhbGlkYXRlVHlwZSkoXCJGbG93VHlwZVwiKSxcbiAgICBvcHRpb25hbDogKDAsIF91dGlscy52YWxpZGF0ZSkoKDAsIF91dGlscy5hc3NlcnRWYWx1ZVR5cGUpKFwiYm9vbGVhblwiKSlcbiAgfVxufSk7XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWZsb3cuanMubWFwXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@babel/types/lib/definitions/flow.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@babel/types/lib/definitions/index.js":
/*!************************************************************!*\
  !*** ./node_modules/@babel/types/lib/definitions/index.js ***!
  \************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nObject.defineProperty(exports, \"ALIAS_KEYS\", ({\n  enumerable: true,\n  get: function () {\n    return _utils.ALIAS_KEYS;\n  }\n}));\nObject.defineProperty(exports, \"BUILDER_KEYS\", ({\n  enumerable: true,\n  get: function () {\n    return _utils.BUILDER_KEYS;\n  }\n}));\nObject.defineProperty(exports, \"DEPRECATED_ALIASES\", ({\n  enumerable: true,\n  get: function () {\n    return _deprecatedAliases.DEPRECATED_ALIASES;\n  }\n}));\nObject.defineProperty(exports, \"DEPRECATED_KEYS\", ({\n  enumerable: true,\n  get: function () {\n    return _utils.DEPRECATED_KEYS;\n  }\n}));\nObject.defineProperty(exports, \"FLIPPED_ALIAS_KEYS\", ({\n  enumerable: true,\n  get: function () {\n    return _utils.FLIPPED_ALIAS_KEYS;\n  }\n}));\nObject.defineProperty(exports, \"NODE_FIELDS\", ({\n  enumerable: true,\n  get: function () {\n    return _utils.NODE_FIELDS;\n  }\n}));\nObject.defineProperty(exports, \"NODE_PARENT_VALIDATIONS\", ({\n  enumerable: true,\n  get: function () {\n    return _utils.NODE_PARENT_VALIDATIONS;\n  }\n}));\nObject.defineProperty(exports, \"NODE_UNION_SHAPES__PRIVATE\", ({\n  enumerable: true,\n  get: function () {\n    return _utils.NODE_UNION_SHAPES__PRIVATE;\n  }\n}));\nObject.defineProperty(exports, \"PLACEHOLDERS\", ({\n  enumerable: true,\n  get: function () {\n    return _placeholders.PLACEHOLDERS;\n  }\n}));\nObject.defineProperty(exports, \"PLACEHOLDERS_ALIAS\", ({\n  enumerable: true,\n  get: function () {\n    return _placeholders.PLACEHOLDERS_ALIAS;\n  }\n}));\nObject.defineProperty(exports, \"PLACEHOLDERS_FLIPPED_ALIAS\", ({\n  enumerable: true,\n  get: function () {\n    return _placeholders.PLACEHOLDERS_FLIPPED_ALIAS;\n  }\n}));\nexports.TYPES = void 0;\nObject.defineProperty(exports, \"VISITOR_KEYS\", ({\n  enumerable: true,\n  get: function () {\n    return _utils.VISITOR_KEYS;\n  }\n}));\n__webpack_require__(/*! ./core.js */ \"(ssr)/./node_modules/@babel/types/lib/definitions/core.js\");\n__webpack_require__(/*! ./flow.js */ \"(ssr)/./node_modules/@babel/types/lib/definitions/flow.js\");\n__webpack_require__(/*! ./jsx.js */ \"(ssr)/./node_modules/@babel/types/lib/definitions/jsx.js\");\n__webpack_require__(/*! ./misc.js */ \"(ssr)/./node_modules/@babel/types/lib/definitions/misc.js\");\n__webpack_require__(/*! ./experimental.js */ \"(ssr)/./node_modules/@babel/types/lib/definitions/experimental.js\");\n__webpack_require__(/*! ./typescript.js */ \"(ssr)/./node_modules/@babel/types/lib/definitions/typescript.js\");\nvar _utils = __webpack_require__(/*! ./utils.js */ \"(ssr)/./node_modules/@babel/types/lib/definitions/utils.js\");\nvar _placeholders = __webpack_require__(/*! ./placeholders.js */ \"(ssr)/./node_modules/@babel/types/lib/definitions/placeholders.js\");\nvar _deprecatedAliases = __webpack_require__(/*! ./deprecated-aliases.js */ \"(ssr)/./node_modules/@babel/types/lib/definitions/deprecated-aliases.js\");\nObject.keys(_deprecatedAliases.DEPRECATED_ALIASES).forEach(deprecatedAlias => {\n  _utils.FLIPPED_ALIAS_KEYS[deprecatedAlias] = _utils.FLIPPED_ALIAS_KEYS[_deprecatedAliases.DEPRECATED_ALIASES[deprecatedAlias]];\n});\nfor (const {\n  types,\n  set\n} of _utils.allExpandedTypes) {\n  for (const type of types) {\n    const aliases = _utils.FLIPPED_ALIAS_KEYS[type];\n    if (aliases) {\n      aliases.forEach(set.add, set);\n    } else {\n      set.add(type);\n    }\n  }\n}\nconst TYPES = exports.TYPES = [].concat(Object.keys(_utils.VISITOR_KEYS), Object.keys(_utils.FLIPPED_ALIAS_KEYS), Object.keys(_utils.DEPRECATED_KEYS));\n\n//# sourceMappingURL=index.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGJhYmVsL3R5cGVzL2xpYi9kZWZpbml0aW9ucy9pbmRleC5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYiw4Q0FBNkM7QUFDN0M7QUFDQSxDQUFDLEVBQUM7QUFDRiw4Q0FBNkM7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLEVBQUM7QUFDRixnREFBK0M7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLEVBQUM7QUFDRixzREFBcUQ7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLEVBQUM7QUFDRixtREFBa0Q7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLEVBQUM7QUFDRixzREFBcUQ7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLEVBQUM7QUFDRiwrQ0FBOEM7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLEVBQUM7QUFDRiwyREFBMEQ7QUFDMUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLEVBQUM7QUFDRiw4REFBNkQ7QUFDN0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLEVBQUM7QUFDRixnREFBK0M7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLEVBQUM7QUFDRixzREFBcUQ7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLEVBQUM7QUFDRiw4REFBNkQ7QUFDN0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLEVBQUM7QUFDRixhQUFhO0FBQ2IsZ0RBQStDO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxFQUFDO0FBQ0YsbUJBQU8sQ0FBQyw0RUFBVztBQUNuQixtQkFBTyxDQUFDLDRFQUFXO0FBQ25CLG1CQUFPLENBQUMsMEVBQVU7QUFDbEIsbUJBQU8sQ0FBQyw0RUFBVztBQUNuQixtQkFBTyxDQUFDLDRGQUFtQjtBQUMzQixtQkFBTyxDQUFDLHdGQUFpQjtBQUN6QixhQUFhLG1CQUFPLENBQUMsOEVBQVk7QUFDakMsb0JBQW9CLG1CQUFPLENBQUMsNEZBQW1CO0FBQy9DLHlCQUF5QixtQkFBTyxDQUFDLHdHQUF5QjtBQUMxRDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsYUFBYTs7QUFFM0IiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9yZXBvLXZpc3VhbGl6ZXIvLi9ub2RlX21vZHVsZXMvQGJhYmVsL3R5cGVzL2xpYi9kZWZpbml0aW9ucy9pbmRleC5qcz9mNDRhIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiQUxJQVNfS0VZU1wiLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBfdXRpbHMuQUxJQVNfS0VZUztcbiAgfVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJCVUlMREVSX0tFWVNcIiwge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gX3V0aWxzLkJVSUxERVJfS0VZUztcbiAgfVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJERVBSRUNBVEVEX0FMSUFTRVNcIiwge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gX2RlcHJlY2F0ZWRBbGlhc2VzLkRFUFJFQ0FURURfQUxJQVNFUztcbiAgfVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJERVBSRUNBVEVEX0tFWVNcIiwge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gX3V0aWxzLkRFUFJFQ0FURURfS0VZUztcbiAgfVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJGTElQUEVEX0FMSUFTX0tFWVNcIiwge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gX3V0aWxzLkZMSVBQRURfQUxJQVNfS0VZUztcbiAgfVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJOT0RFX0ZJRUxEU1wiLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBfdXRpbHMuTk9ERV9GSUVMRFM7XG4gIH1cbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiTk9ERV9QQVJFTlRfVkFMSURBVElPTlNcIiwge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gX3V0aWxzLk5PREVfUEFSRU5UX1ZBTElEQVRJT05TO1xuICB9XG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIk5PREVfVU5JT05fU0hBUEVTX19QUklWQVRFXCIsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIF91dGlscy5OT0RFX1VOSU9OX1NIQVBFU19fUFJJVkFURTtcbiAgfVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJQTEFDRUhPTERFUlNcIiwge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gX3BsYWNlaG9sZGVycy5QTEFDRUhPTERFUlM7XG4gIH1cbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiUExBQ0VIT0xERVJTX0FMSUFTXCIsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIF9wbGFjZWhvbGRlcnMuUExBQ0VIT0xERVJTX0FMSUFTO1xuICB9XG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIlBMQUNFSE9MREVSU19GTElQUEVEX0FMSUFTXCIsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIF9wbGFjZWhvbGRlcnMuUExBQ0VIT0xERVJTX0ZMSVBQRURfQUxJQVM7XG4gIH1cbn0pO1xuZXhwb3J0cy5UWVBFUyA9IHZvaWQgMDtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIlZJU0lUT1JfS0VZU1wiLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBfdXRpbHMuVklTSVRPUl9LRVlTO1xuICB9XG59KTtcbnJlcXVpcmUoXCIuL2NvcmUuanNcIik7XG5yZXF1aXJlKFwiLi9mbG93LmpzXCIpO1xucmVxdWlyZShcIi4vanN4LmpzXCIpO1xucmVxdWlyZShcIi4vbWlzYy5qc1wiKTtcbnJlcXVpcmUoXCIuL2V4cGVyaW1lbnRhbC5qc1wiKTtcbnJlcXVpcmUoXCIuL3R5cGVzY3JpcHQuanNcIik7XG52YXIgX3V0aWxzID0gcmVxdWlyZShcIi4vdXRpbHMuanNcIik7XG52YXIgX3BsYWNlaG9sZGVycyA9IHJlcXVpcmUoXCIuL3BsYWNlaG9sZGVycy5qc1wiKTtcbnZhciBfZGVwcmVjYXRlZEFsaWFzZXMgPSByZXF1aXJlKFwiLi9kZXByZWNhdGVkLWFsaWFzZXMuanNcIik7XG5PYmplY3Qua2V5cyhfZGVwcmVjYXRlZEFsaWFzZXMuREVQUkVDQVRFRF9BTElBU0VTKS5mb3JFYWNoKGRlcHJlY2F0ZWRBbGlhcyA9PiB7XG4gIF91dGlscy5GTElQUEVEX0FMSUFTX0tFWVNbZGVwcmVjYXRlZEFsaWFzXSA9IF91dGlscy5GTElQUEVEX0FMSUFTX0tFWVNbX2RlcHJlY2F0ZWRBbGlhc2VzLkRFUFJFQ0FURURfQUxJQVNFU1tkZXByZWNhdGVkQWxpYXNdXTtcbn0pO1xuZm9yIChjb25zdCB7XG4gIHR5cGVzLFxuICBzZXRcbn0gb2YgX3V0aWxzLmFsbEV4cGFuZGVkVHlwZXMpIHtcbiAgZm9yIChjb25zdCB0eXBlIG9mIHR5cGVzKSB7XG4gICAgY29uc3QgYWxpYXNlcyA9IF91dGlscy5GTElQUEVEX0FMSUFTX0tFWVNbdHlwZV07XG4gICAgaWYgKGFsaWFzZXMpIHtcbiAgICAgIGFsaWFzZXMuZm9yRWFjaChzZXQuYWRkLCBzZXQpO1xuICAgIH0gZWxzZSB7XG4gICAgICBzZXQuYWRkKHR5cGUpO1xuICAgIH1cbiAgfVxufVxuY29uc3QgVFlQRVMgPSBleHBvcnRzLlRZUEVTID0gW10uY29uY2F0KE9iamVjdC5rZXlzKF91dGlscy5WSVNJVE9SX0tFWVMpLCBPYmplY3Qua2V5cyhfdXRpbHMuRkxJUFBFRF9BTElBU19LRVlTKSwgT2JqZWN0LmtleXMoX3V0aWxzLkRFUFJFQ0FURURfS0VZUykpO1xuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXBcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@babel/types/lib/definitions/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@babel/types/lib/definitions/jsx.js":
/*!**********************************************************!*\
  !*** ./node_modules/@babel/types/lib/definitions/jsx.js ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

eval("\n\nvar _utils = __webpack_require__(/*! ./utils.js */ \"(ssr)/./node_modules/@babel/types/lib/definitions/utils.js\");\nconst defineType = (0, _utils.defineAliasedType)(\"JSX\");\ndefineType(\"JSXAttribute\", {\n  visitor: [\"name\", \"value\"],\n  aliases: [\"Immutable\"],\n  fields: {\n    name: {\n      validate: (0, _utils.assertNodeType)(\"JSXIdentifier\", \"JSXNamespacedName\")\n    },\n    value: {\n      optional: true,\n      validate: (0, _utils.assertNodeType)(\"JSXElement\", \"JSXFragment\", \"StringLiteral\", \"JSXExpressionContainer\")\n    }\n  }\n});\ndefineType(\"JSXClosingElement\", {\n  visitor: [\"name\"],\n  aliases: [\"Immutable\"],\n  fields: {\n    name: {\n      validate: (0, _utils.assertNodeType)(\"JSXIdentifier\", \"JSXMemberExpression\", \"JSXNamespacedName\")\n    }\n  }\n});\ndefineType(\"JSXElement\", {\n  builder: [\"openingElement\", \"closingElement\", \"children\", \"selfClosing\"],\n  visitor: [\"openingElement\", \"children\", \"closingElement\"],\n  aliases: [\"Immutable\", \"Expression\"],\n  fields: Object.assign({\n    openingElement: {\n      validate: (0, _utils.assertNodeType)(\"JSXOpeningElement\")\n    },\n    closingElement: {\n      optional: true,\n      validate: (0, _utils.assertNodeType)(\"JSXClosingElement\")\n    },\n    children: (0, _utils.validateArrayOfType)(\"JSXText\", \"JSXExpressionContainer\", \"JSXSpreadChild\", \"JSXElement\", \"JSXFragment\")\n  }, {\n    selfClosing: {\n      validate: (0, _utils.assertValueType)(\"boolean\"),\n      optional: true\n    }\n  })\n});\ndefineType(\"JSXEmptyExpression\", {});\ndefineType(\"JSXExpressionContainer\", {\n  visitor: [\"expression\"],\n  aliases: [\"Immutable\"],\n  fields: {\n    expression: {\n      validate: (0, _utils.assertNodeType)(\"Expression\", \"JSXEmptyExpression\")\n    }\n  }\n});\ndefineType(\"JSXSpreadChild\", {\n  visitor: [\"expression\"],\n  aliases: [\"Immutable\"],\n  fields: {\n    expression: {\n      validate: (0, _utils.assertNodeType)(\"Expression\")\n    }\n  }\n});\ndefineType(\"JSXIdentifier\", {\n  builder: [\"name\"],\n  fields: {\n    name: {\n      validate: (0, _utils.assertValueType)(\"string\")\n    }\n  }\n});\ndefineType(\"JSXMemberExpression\", {\n  visitor: [\"object\", \"property\"],\n  fields: {\n    object: {\n      validate: (0, _utils.assertNodeType)(\"JSXMemberExpression\", \"JSXIdentifier\")\n    },\n    property: {\n      validate: (0, _utils.assertNodeType)(\"JSXIdentifier\")\n    }\n  }\n});\ndefineType(\"JSXNamespacedName\", {\n  visitor: [\"namespace\", \"name\"],\n  fields: {\n    namespace: {\n      validate: (0, _utils.assertNodeType)(\"JSXIdentifier\")\n    },\n    name: {\n      validate: (0, _utils.assertNodeType)(\"JSXIdentifier\")\n    }\n  }\n});\ndefineType(\"JSXOpeningElement\", {\n  builder: [\"name\", \"attributes\", \"selfClosing\"],\n  visitor: [\"name\", \"typeParameters\", \"typeArguments\", \"attributes\"],\n  aliases: [\"Immutable\"],\n  fields: Object.assign({\n    name: {\n      validate: (0, _utils.assertNodeType)(\"JSXIdentifier\", \"JSXMemberExpression\", \"JSXNamespacedName\")\n    },\n    selfClosing: {\n      default: false\n    },\n    attributes: (0, _utils.validateArrayOfType)(\"JSXAttribute\", \"JSXSpreadAttribute\"),\n    typeArguments: {\n      validate: (0, _utils.assertNodeType)(\"TypeParameterInstantiation\"),\n      optional: true\n    }\n  }, {\n    typeParameters: {\n      validate: (0, _utils.assertNodeType)(\"TSTypeParameterInstantiation\"),\n      optional: true\n    }\n  })\n});\ndefineType(\"JSXSpreadAttribute\", {\n  visitor: [\"argument\"],\n  fields: {\n    argument: {\n      validate: (0, _utils.assertNodeType)(\"Expression\")\n    }\n  }\n});\ndefineType(\"JSXText\", {\n  aliases: [\"Immutable\"],\n  builder: [\"value\"],\n  fields: {\n    value: {\n      validate: (0, _utils.assertValueType)(\"string\")\n    }\n  }\n});\ndefineType(\"JSXFragment\", {\n  builder: [\"openingFragment\", \"closingFragment\", \"children\"],\n  visitor: [\"openingFragment\", \"children\", \"closingFragment\"],\n  aliases: [\"Immutable\", \"Expression\"],\n  fields: {\n    openingFragment: {\n      validate: (0, _utils.assertNodeType)(\"JSXOpeningFragment\")\n    },\n    closingFragment: {\n      validate: (0, _utils.assertNodeType)(\"JSXClosingFragment\")\n    },\n    children: (0, _utils.validateArrayOfType)(\"JSXText\", \"JSXExpressionContainer\", \"JSXSpreadChild\", \"JSXElement\", \"JSXFragment\")\n  }\n});\ndefineType(\"JSXOpeningFragment\", {\n  aliases: [\"Immutable\"]\n});\ndefineType(\"JSXClosingFragment\", {\n  aliases: [\"Immutable\"]\n});\n\n//# sourceMappingURL=jsx.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGJhYmVsL3R5cGVzL2xpYi9kZWZpbml0aW9ucy9qc3guanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWIsYUFBYSxtQkFBTyxDQUFDLDhFQUFZO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsQ0FBQztBQUNELG1DQUFtQztBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0EsQ0FBQzs7QUFFRCIsInNvdXJjZXMiOlsid2VicGFjazovL3JlcG8tdmlzdWFsaXplci8uL25vZGVfbW9kdWxlcy9AYmFiZWwvdHlwZXMvbGliL2RlZmluaXRpb25zL2pzeC5qcz81NjFkIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuXG52YXIgX3V0aWxzID0gcmVxdWlyZShcIi4vdXRpbHMuanNcIik7XG5jb25zdCBkZWZpbmVUeXBlID0gKDAsIF91dGlscy5kZWZpbmVBbGlhc2VkVHlwZSkoXCJKU1hcIik7XG5kZWZpbmVUeXBlKFwiSlNYQXR0cmlidXRlXCIsIHtcbiAgdmlzaXRvcjogW1wibmFtZVwiLCBcInZhbHVlXCJdLFxuICBhbGlhc2VzOiBbXCJJbW11dGFibGVcIl0sXG4gIGZpZWxkczoge1xuICAgIG5hbWU6IHtcbiAgICAgIHZhbGlkYXRlOiAoMCwgX3V0aWxzLmFzc2VydE5vZGVUeXBlKShcIkpTWElkZW50aWZpZXJcIiwgXCJKU1hOYW1lc3BhY2VkTmFtZVwiKVxuICAgIH0sXG4gICAgdmFsdWU6IHtcbiAgICAgIG9wdGlvbmFsOiB0cnVlLFxuICAgICAgdmFsaWRhdGU6ICgwLCBfdXRpbHMuYXNzZXJ0Tm9kZVR5cGUpKFwiSlNYRWxlbWVudFwiLCBcIkpTWEZyYWdtZW50XCIsIFwiU3RyaW5nTGl0ZXJhbFwiLCBcIkpTWEV4cHJlc3Npb25Db250YWluZXJcIilcbiAgICB9XG4gIH1cbn0pO1xuZGVmaW5lVHlwZShcIkpTWENsb3NpbmdFbGVtZW50XCIsIHtcbiAgdmlzaXRvcjogW1wibmFtZVwiXSxcbiAgYWxpYXNlczogW1wiSW1tdXRhYmxlXCJdLFxuICBmaWVsZHM6IHtcbiAgICBuYW1lOiB7XG4gICAgICB2YWxpZGF0ZTogKDAsIF91dGlscy5hc3NlcnROb2RlVHlwZSkoXCJKU1hJZGVudGlmaWVyXCIsIFwiSlNYTWVtYmVyRXhwcmVzc2lvblwiLCBcIkpTWE5hbWVzcGFjZWROYW1lXCIpXG4gICAgfVxuICB9XG59KTtcbmRlZmluZVR5cGUoXCJKU1hFbGVtZW50XCIsIHtcbiAgYnVpbGRlcjogW1wib3BlbmluZ0VsZW1lbnRcIiwgXCJjbG9zaW5nRWxlbWVudFwiLCBcImNoaWxkcmVuXCIsIFwic2VsZkNsb3NpbmdcIl0sXG4gIHZpc2l0b3I6IFtcIm9wZW5pbmdFbGVtZW50XCIsIFwiY2hpbGRyZW5cIiwgXCJjbG9zaW5nRWxlbWVudFwiXSxcbiAgYWxpYXNlczogW1wiSW1tdXRhYmxlXCIsIFwiRXhwcmVzc2lvblwiXSxcbiAgZmllbGRzOiBPYmplY3QuYXNzaWduKHtcbiAgICBvcGVuaW5nRWxlbWVudDoge1xuICAgICAgdmFsaWRhdGU6ICgwLCBfdXRpbHMuYXNzZXJ0Tm9kZVR5cGUpKFwiSlNYT3BlbmluZ0VsZW1lbnRcIilcbiAgICB9LFxuICAgIGNsb3NpbmdFbGVtZW50OiB7XG4gICAgICBvcHRpb25hbDogdHJ1ZSxcbiAgICAgIHZhbGlkYXRlOiAoMCwgX3V0aWxzLmFzc2VydE5vZGVUeXBlKShcIkpTWENsb3NpbmdFbGVtZW50XCIpXG4gICAgfSxcbiAgICBjaGlsZHJlbjogKDAsIF91dGlscy52YWxpZGF0ZUFycmF5T2ZUeXBlKShcIkpTWFRleHRcIiwgXCJKU1hFeHByZXNzaW9uQ29udGFpbmVyXCIsIFwiSlNYU3ByZWFkQ2hpbGRcIiwgXCJKU1hFbGVtZW50XCIsIFwiSlNYRnJhZ21lbnRcIilcbiAgfSwge1xuICAgIHNlbGZDbG9zaW5nOiB7XG4gICAgICB2YWxpZGF0ZTogKDAsIF91dGlscy5hc3NlcnRWYWx1ZVR5cGUpKFwiYm9vbGVhblwiKSxcbiAgICAgIG9wdGlvbmFsOiB0cnVlXG4gICAgfVxuICB9KVxufSk7XG5kZWZpbmVUeXBlKFwiSlNYRW1wdHlFeHByZXNzaW9uXCIsIHt9KTtcbmRlZmluZVR5cGUoXCJKU1hFeHByZXNzaW9uQ29udGFpbmVyXCIsIHtcbiAgdmlzaXRvcjogW1wiZXhwcmVzc2lvblwiXSxcbiAgYWxpYXNlczogW1wiSW1tdXRhYmxlXCJdLFxuICBmaWVsZHM6IHtcbiAgICBleHByZXNzaW9uOiB7XG4gICAgICB2YWxpZGF0ZTogKDAsIF91dGlscy5hc3NlcnROb2RlVHlwZSkoXCJFeHByZXNzaW9uXCIsIFwiSlNYRW1wdHlFeHByZXNzaW9uXCIpXG4gICAgfVxuICB9XG59KTtcbmRlZmluZVR5cGUoXCJKU1hTcHJlYWRDaGlsZFwiLCB7XG4gIHZpc2l0b3I6IFtcImV4cHJlc3Npb25cIl0sXG4gIGFsaWFzZXM6IFtcIkltbXV0YWJsZVwiXSxcbiAgZmllbGRzOiB7XG4gICAgZXhwcmVzc2lvbjoge1xuICAgICAgdmFsaWRhdGU6ICgwLCBfdXRpbHMuYXNzZXJ0Tm9kZVR5cGUpKFwiRXhwcmVzc2lvblwiKVxuICAgIH1cbiAgfVxufSk7XG5kZWZpbmVUeXBlKFwiSlNYSWRlbnRpZmllclwiLCB7XG4gIGJ1aWxkZXI6IFtcIm5hbWVcIl0sXG4gIGZpZWxkczoge1xuICAgIG5hbWU6IHtcbiAgICAgIHZhbGlkYXRlOiAoMCwgX3V0aWxzLmFzc2VydFZhbHVlVHlwZSkoXCJzdHJpbmdcIilcbiAgICB9XG4gIH1cbn0pO1xuZGVmaW5lVHlwZShcIkpTWE1lbWJlckV4cHJlc3Npb25cIiwge1xuICB2aXNpdG9yOiBbXCJvYmplY3RcIiwgXCJwcm9wZXJ0eVwiXSxcbiAgZmllbGRzOiB7XG4gICAgb2JqZWN0OiB7XG4gICAgICB2YWxpZGF0ZTogKDAsIF91dGlscy5hc3NlcnROb2RlVHlwZSkoXCJKU1hNZW1iZXJFeHByZXNzaW9uXCIsIFwiSlNYSWRlbnRpZmllclwiKVxuICAgIH0sXG4gICAgcHJvcGVydHk6IHtcbiAgICAgIHZhbGlkYXRlOiAoMCwgX3V0aWxzLmFzc2VydE5vZGVUeXBlKShcIkpTWElkZW50aWZpZXJcIilcbiAgICB9XG4gIH1cbn0pO1xuZGVmaW5lVHlwZShcIkpTWE5hbWVzcGFjZWROYW1lXCIsIHtcbiAgdmlzaXRvcjogW1wibmFtZXNwYWNlXCIsIFwibmFtZVwiXSxcbiAgZmllbGRzOiB7XG4gICAgbmFtZXNwYWNlOiB7XG4gICAgICB2YWxpZGF0ZTogKDAsIF91dGlscy5hc3NlcnROb2RlVHlwZSkoXCJKU1hJZGVudGlmaWVyXCIpXG4gICAgfSxcbiAgICBuYW1lOiB7XG4gICAgICB2YWxpZGF0ZTogKDAsIF91dGlscy5hc3NlcnROb2RlVHlwZSkoXCJKU1hJZGVudGlmaWVyXCIpXG4gICAgfVxuICB9XG59KTtcbmRlZmluZVR5cGUoXCJKU1hPcGVuaW5nRWxlbWVudFwiLCB7XG4gIGJ1aWxkZXI6IFtcIm5hbWVcIiwgXCJhdHRyaWJ1dGVzXCIsIFwic2VsZkNsb3NpbmdcIl0sXG4gIHZpc2l0b3I6IFtcIm5hbWVcIiwgXCJ0eXBlUGFyYW1ldGVyc1wiLCBcInR5cGVBcmd1bWVudHNcIiwgXCJhdHRyaWJ1dGVzXCJdLFxuICBhbGlhc2VzOiBbXCJJbW11dGFibGVcIl0sXG4gIGZpZWxkczogT2JqZWN0LmFzc2lnbih7XG4gICAgbmFtZToge1xuICAgICAgdmFsaWRhdGU6ICgwLCBfdXRpbHMuYXNzZXJ0Tm9kZVR5cGUpKFwiSlNYSWRlbnRpZmllclwiLCBcIkpTWE1lbWJlckV4cHJlc3Npb25cIiwgXCJKU1hOYW1lc3BhY2VkTmFtZVwiKVxuICAgIH0sXG4gICAgc2VsZkNsb3Npbmc6IHtcbiAgICAgIGRlZmF1bHQ6IGZhbHNlXG4gICAgfSxcbiAgICBhdHRyaWJ1dGVzOiAoMCwgX3V0aWxzLnZhbGlkYXRlQXJyYXlPZlR5cGUpKFwiSlNYQXR0cmlidXRlXCIsIFwiSlNYU3ByZWFkQXR0cmlidXRlXCIpLFxuICAgIHR5cGVBcmd1bWVudHM6IHtcbiAgICAgIHZhbGlkYXRlOiAoMCwgX3V0aWxzLmFzc2VydE5vZGVUeXBlKShcIlR5cGVQYXJhbWV0ZXJJbnN0YW50aWF0aW9uXCIpLFxuICAgICAgb3B0aW9uYWw6IHRydWVcbiAgICB9XG4gIH0sIHtcbiAgICB0eXBlUGFyYW1ldGVyczoge1xuICAgICAgdmFsaWRhdGU6ICgwLCBfdXRpbHMuYXNzZXJ0Tm9kZVR5cGUpKFwiVFNUeXBlUGFyYW1ldGVySW5zdGFudGlhdGlvblwiKSxcbiAgICAgIG9wdGlvbmFsOiB0cnVlXG4gICAgfVxuICB9KVxufSk7XG5kZWZpbmVUeXBlKFwiSlNYU3ByZWFkQXR0cmlidXRlXCIsIHtcbiAgdmlzaXRvcjogW1wiYXJndW1lbnRcIl0sXG4gIGZpZWxkczoge1xuICAgIGFyZ3VtZW50OiB7XG4gICAgICB2YWxpZGF0ZTogKDAsIF91dGlscy5hc3NlcnROb2RlVHlwZSkoXCJFeHByZXNzaW9uXCIpXG4gICAgfVxuICB9XG59KTtcbmRlZmluZVR5cGUoXCJKU1hUZXh0XCIsIHtcbiAgYWxpYXNlczogW1wiSW1tdXRhYmxlXCJdLFxuICBidWlsZGVyOiBbXCJ2YWx1ZVwiXSxcbiAgZmllbGRzOiB7XG4gICAgdmFsdWU6IHtcbiAgICAgIHZhbGlkYXRlOiAoMCwgX3V0aWxzLmFzc2VydFZhbHVlVHlwZSkoXCJzdHJpbmdcIilcbiAgICB9XG4gIH1cbn0pO1xuZGVmaW5lVHlwZShcIkpTWEZyYWdtZW50XCIsIHtcbiAgYnVpbGRlcjogW1wib3BlbmluZ0ZyYWdtZW50XCIsIFwiY2xvc2luZ0ZyYWdtZW50XCIsIFwiY2hpbGRyZW5cIl0sXG4gIHZpc2l0b3I6IFtcIm9wZW5pbmdGcmFnbWVudFwiLCBcImNoaWxkcmVuXCIsIFwiY2xvc2luZ0ZyYWdtZW50XCJdLFxuICBhbGlhc2VzOiBbXCJJbW11dGFibGVcIiwgXCJFeHByZXNzaW9uXCJdLFxuICBmaWVsZHM6IHtcbiAgICBvcGVuaW5nRnJhZ21lbnQ6IHtcbiAgICAgIHZhbGlkYXRlOiAoMCwgX3V0aWxzLmFzc2VydE5vZGVUeXBlKShcIkpTWE9wZW5pbmdGcmFnbWVudFwiKVxuICAgIH0sXG4gICAgY2xvc2luZ0ZyYWdtZW50OiB7XG4gICAgICB2YWxpZGF0ZTogKDAsIF91dGlscy5hc3NlcnROb2RlVHlwZSkoXCJKU1hDbG9zaW5nRnJhZ21lbnRcIilcbiAgICB9LFxuICAgIGNoaWxkcmVuOiAoMCwgX3V0aWxzLnZhbGlkYXRlQXJyYXlPZlR5cGUpKFwiSlNYVGV4dFwiLCBcIkpTWEV4cHJlc3Npb25Db250YWluZXJcIiwgXCJKU1hTcHJlYWRDaGlsZFwiLCBcIkpTWEVsZW1lbnRcIiwgXCJKU1hGcmFnbWVudFwiKVxuICB9XG59KTtcbmRlZmluZVR5cGUoXCJKU1hPcGVuaW5nRnJhZ21lbnRcIiwge1xuICBhbGlhc2VzOiBbXCJJbW11dGFibGVcIl1cbn0pO1xuZGVmaW5lVHlwZShcIkpTWENsb3NpbmdGcmFnbWVudFwiLCB7XG4gIGFsaWFzZXM6IFtcIkltbXV0YWJsZVwiXVxufSk7XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWpzeC5qcy5tYXBcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@babel/types/lib/definitions/jsx.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@babel/types/lib/definitions/misc.js":
/*!***********************************************************!*\
  !*** ./node_modules/@babel/types/lib/definitions/misc.js ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

eval("\n\nvar _utils = __webpack_require__(/*! ./utils.js */ \"(ssr)/./node_modules/@babel/types/lib/definitions/utils.js\");\nvar _placeholders = __webpack_require__(/*! ./placeholders.js */ \"(ssr)/./node_modules/@babel/types/lib/definitions/placeholders.js\");\nvar _core = __webpack_require__(/*! ./core.js */ \"(ssr)/./node_modules/@babel/types/lib/definitions/core.js\");\nconst defineType = (0, _utils.defineAliasedType)(\"Miscellaneous\");\ndefineType(\"Noop\", {\n  visitor: []\n});\ndefineType(\"Placeholder\", {\n  visitor: [],\n  builder: [\"expectedNode\", \"name\"],\n  fields: Object.assign({\n    name: {\n      validate: (0, _utils.assertNodeType)(\"Identifier\")\n    },\n    expectedNode: {\n      validate: (0, _utils.assertOneOf)(..._placeholders.PLACEHOLDERS)\n    }\n  }, (0, _core.patternLikeCommon)())\n});\ndefineType(\"V8IntrinsicIdentifier\", {\n  builder: [\"name\"],\n  fields: {\n    name: {\n      validate: (0, _utils.assertValueType)(\"string\")\n    }\n  }\n});\n\n//# sourceMappingURL=misc.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGJhYmVsL3R5cGVzL2xpYi9kZWZpbml0aW9ucy9taXNjLmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViLGFBQWEsbUJBQU8sQ0FBQyw4RUFBWTtBQUNqQyxvQkFBb0IsbUJBQU8sQ0FBQyw0RkFBbUI7QUFDL0MsWUFBWSxtQkFBTyxDQUFDLDRFQUFXO0FBQy9CO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9yZXBvLXZpc3VhbGl6ZXIvLi9ub2RlX21vZHVsZXMvQGJhYmVsL3R5cGVzL2xpYi9kZWZpbml0aW9ucy9taXNjLmpzP2M2ZjIiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBfdXRpbHMgPSByZXF1aXJlKFwiLi91dGlscy5qc1wiKTtcbnZhciBfcGxhY2Vob2xkZXJzID0gcmVxdWlyZShcIi4vcGxhY2Vob2xkZXJzLmpzXCIpO1xudmFyIF9jb3JlID0gcmVxdWlyZShcIi4vY29yZS5qc1wiKTtcbmNvbnN0IGRlZmluZVR5cGUgPSAoMCwgX3V0aWxzLmRlZmluZUFsaWFzZWRUeXBlKShcIk1pc2NlbGxhbmVvdXNcIik7XG5kZWZpbmVUeXBlKFwiTm9vcFwiLCB7XG4gIHZpc2l0b3I6IFtdXG59KTtcbmRlZmluZVR5cGUoXCJQbGFjZWhvbGRlclwiLCB7XG4gIHZpc2l0b3I6IFtdLFxuICBidWlsZGVyOiBbXCJleHBlY3RlZE5vZGVcIiwgXCJuYW1lXCJdLFxuICBmaWVsZHM6IE9iamVjdC5hc3NpZ24oe1xuICAgIG5hbWU6IHtcbiAgICAgIHZhbGlkYXRlOiAoMCwgX3V0aWxzLmFzc2VydE5vZGVUeXBlKShcIklkZW50aWZpZXJcIilcbiAgICB9LFxuICAgIGV4cGVjdGVkTm9kZToge1xuICAgICAgdmFsaWRhdGU6ICgwLCBfdXRpbHMuYXNzZXJ0T25lT2YpKC4uLl9wbGFjZWhvbGRlcnMuUExBQ0VIT0xERVJTKVxuICAgIH1cbiAgfSwgKDAsIF9jb3JlLnBhdHRlcm5MaWtlQ29tbW9uKSgpKVxufSk7XG5kZWZpbmVUeXBlKFwiVjhJbnRyaW5zaWNJZGVudGlmaWVyXCIsIHtcbiAgYnVpbGRlcjogW1wibmFtZVwiXSxcbiAgZmllbGRzOiB7XG4gICAgbmFtZToge1xuICAgICAgdmFsaWRhdGU6ICgwLCBfdXRpbHMuYXNzZXJ0VmFsdWVUeXBlKShcInN0cmluZ1wiKVxuICAgIH1cbiAgfVxufSk7XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW1pc2MuanMubWFwXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@babel/types/lib/definitions/misc.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@babel/types/lib/definitions/placeholders.js":
/*!*******************************************************************!*\
  !*** ./node_modules/@babel/types/lib/definitions/placeholders.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports.PLACEHOLDERS_FLIPPED_ALIAS = exports.PLACEHOLDERS_ALIAS = exports.PLACEHOLDERS = void 0;\nvar _utils = __webpack_require__(/*! ./utils.js */ \"(ssr)/./node_modules/@babel/types/lib/definitions/utils.js\");\nconst PLACEHOLDERS = exports.PLACEHOLDERS = [\"Identifier\", \"StringLiteral\", \"Expression\", \"Statement\", \"Declaration\", \"BlockStatement\", \"ClassBody\", \"Pattern\"];\nconst PLACEHOLDERS_ALIAS = exports.PLACEHOLDERS_ALIAS = {\n  Declaration: [\"Statement\"],\n  Pattern: [\"PatternLike\", \"LVal\"]\n};\nfor (const type of PLACEHOLDERS) {\n  const alias = _utils.ALIAS_KEYS[type];\n  if (alias != null && alias.length) PLACEHOLDERS_ALIAS[type] = alias;\n}\nconst PLACEHOLDERS_FLIPPED_ALIAS = exports.PLACEHOLDERS_FLIPPED_ALIAS = {};\nObject.keys(PLACEHOLDERS_ALIAS).forEach(type => {\n  PLACEHOLDERS_ALIAS[type].forEach(alias => {\n    if (!hasOwnProperty.call(PLACEHOLDERS_FLIPPED_ALIAS, alias)) {\n      PLACEHOLDERS_FLIPPED_ALIAS[alias] = [];\n    }\n    PLACEHOLDERS_FLIPPED_ALIAS[alias].push(type);\n  });\n});\n\n//# sourceMappingURL=placeholders.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGJhYmVsL3R5cGVzL2xpYi9kZWZpbml0aW9ucy9wbGFjZWhvbGRlcnMuanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWIsOENBQTZDO0FBQzdDO0FBQ0EsQ0FBQyxFQUFDO0FBQ0Ysa0NBQWtDLEdBQUcsMEJBQTBCLEdBQUcsb0JBQW9CO0FBQ3RGLGFBQWEsbUJBQU8sQ0FBQyw4RUFBWTtBQUNqQyxxQkFBcUIsb0JBQW9CO0FBQ3pDLDJCQUEyQiwwQkFBMEI7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUMsa0NBQWtDO0FBQ3JFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxDQUFDOztBQUVEIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcmVwby12aXN1YWxpemVyLy4vbm9kZV9tb2R1bGVzL0BiYWJlbC90eXBlcy9saWIvZGVmaW5pdGlvbnMvcGxhY2Vob2xkZXJzLmpzP2ZkODkiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLlBMQUNFSE9MREVSU19GTElQUEVEX0FMSUFTID0gZXhwb3J0cy5QTEFDRUhPTERFUlNfQUxJQVMgPSBleHBvcnRzLlBMQUNFSE9MREVSUyA9IHZvaWQgMDtcbnZhciBfdXRpbHMgPSByZXF1aXJlKFwiLi91dGlscy5qc1wiKTtcbmNvbnN0IFBMQUNFSE9MREVSUyA9IGV4cG9ydHMuUExBQ0VIT0xERVJTID0gW1wiSWRlbnRpZmllclwiLCBcIlN0cmluZ0xpdGVyYWxcIiwgXCJFeHByZXNzaW9uXCIsIFwiU3RhdGVtZW50XCIsIFwiRGVjbGFyYXRpb25cIiwgXCJCbG9ja1N0YXRlbWVudFwiLCBcIkNsYXNzQm9keVwiLCBcIlBhdHRlcm5cIl07XG5jb25zdCBQTEFDRUhPTERFUlNfQUxJQVMgPSBleHBvcnRzLlBMQUNFSE9MREVSU19BTElBUyA9IHtcbiAgRGVjbGFyYXRpb246IFtcIlN0YXRlbWVudFwiXSxcbiAgUGF0dGVybjogW1wiUGF0dGVybkxpa2VcIiwgXCJMVmFsXCJdXG59O1xuZm9yIChjb25zdCB0eXBlIG9mIFBMQUNFSE9MREVSUykge1xuICBjb25zdCBhbGlhcyA9IF91dGlscy5BTElBU19LRVlTW3R5cGVdO1xuICBpZiAoYWxpYXMgIT0gbnVsbCAmJiBhbGlhcy5sZW5ndGgpIFBMQUNFSE9MREVSU19BTElBU1t0eXBlXSA9IGFsaWFzO1xufVxuY29uc3QgUExBQ0VIT0xERVJTX0ZMSVBQRURfQUxJQVMgPSBleHBvcnRzLlBMQUNFSE9MREVSU19GTElQUEVEX0FMSUFTID0ge307XG5PYmplY3Qua2V5cyhQTEFDRUhPTERFUlNfQUxJQVMpLmZvckVhY2godHlwZSA9PiB7XG4gIFBMQUNFSE9MREVSU19BTElBU1t0eXBlXS5mb3JFYWNoKGFsaWFzID0+IHtcbiAgICBpZiAoIWhhc093blByb3BlcnR5LmNhbGwoUExBQ0VIT0xERVJTX0ZMSVBQRURfQUxJQVMsIGFsaWFzKSkge1xuICAgICAgUExBQ0VIT0xERVJTX0ZMSVBQRURfQUxJQVNbYWxpYXNdID0gW107XG4gICAgfVxuICAgIFBMQUNFSE9MREVSU19GTElQUEVEX0FMSUFTW2FsaWFzXS5wdXNoKHR5cGUpO1xuICB9KTtcbn0pO1xuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1wbGFjZWhvbGRlcnMuanMubWFwXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@babel/types/lib/definitions/placeholders.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@babel/types/lib/definitions/typescript.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@babel/types/lib/definitions/typescript.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

eval("\n\nvar _utils = __webpack_require__(/*! ./utils.js */ \"(ssr)/./node_modules/@babel/types/lib/definitions/utils.js\");\nvar _core = __webpack_require__(/*! ./core.js */ \"(ssr)/./node_modules/@babel/types/lib/definitions/core.js\");\nvar _is = __webpack_require__(/*! ../validators/is.js */ \"(ssr)/./node_modules/@babel/types/lib/validators/is.js\");\nconst defineType = (0, _utils.defineAliasedType)(\"TypeScript\");\nconst bool = (0, _utils.assertValueType)(\"boolean\");\nconst tSFunctionTypeAnnotationCommon = () => ({\n  returnType: {\n    validate: (0, _utils.assertNodeType)(\"TSTypeAnnotation\", \"Noop\"),\n    optional: true\n  },\n  typeParameters: {\n    validate: (0, _utils.assertNodeType)(\"TSTypeParameterDeclaration\", \"Noop\"),\n    optional: true\n  }\n});\ndefineType(\"TSParameterProperty\", {\n  aliases: [\"LVal\"],\n  visitor: [\"parameter\"],\n  fields: {\n    accessibility: {\n      validate: (0, _utils.assertOneOf)(\"public\", \"private\", \"protected\"),\n      optional: true\n    },\n    readonly: {\n      validate: (0, _utils.assertValueType)(\"boolean\"),\n      optional: true\n    },\n    parameter: {\n      validate: (0, _utils.assertNodeType)(\"Identifier\", \"AssignmentPattern\")\n    },\n    override: {\n      validate: (0, _utils.assertValueType)(\"boolean\"),\n      optional: true\n    },\n    decorators: {\n      validate: (0, _utils.arrayOfType)(\"Decorator\"),\n      optional: true\n    }\n  }\n});\ndefineType(\"TSDeclareFunction\", {\n  aliases: [\"Statement\", \"Declaration\"],\n  visitor: [\"id\", \"typeParameters\", \"params\", \"returnType\"],\n  fields: Object.assign({}, (0, _core.functionDeclarationCommon)(), tSFunctionTypeAnnotationCommon())\n});\ndefineType(\"TSDeclareMethod\", Object.assign({\n  visitor: [\"decorators\", \"key\", \"typeParameters\", \"params\", \"returnType\"]\n}, (0, _core.classMethodOrPropertyUnionShapeCommon)(), {\n  fields: Object.assign({}, (0, _core.classMethodOrDeclareMethodCommon)(), tSFunctionTypeAnnotationCommon())\n}));\ndefineType(\"TSQualifiedName\", {\n  aliases: [\"TSEntityName\"],\n  visitor: [\"left\", \"right\"],\n  fields: {\n    left: (0, _utils.validateType)(\"TSEntityName\"),\n    right: (0, _utils.validateType)(\"Identifier\")\n  }\n});\nconst signatureDeclarationCommon = () => ({\n  typeParameters: (0, _utils.validateOptionalType)(\"TSTypeParameterDeclaration\"),\n  [\"parameters\"]: (0, _utils.validateArrayOfType)(\"ArrayPattern\", \"Identifier\", \"ObjectPattern\", \"RestElement\"),\n  [\"typeAnnotation\"]: (0, _utils.validateOptionalType)(\"TSTypeAnnotation\")\n});\nconst callConstructSignatureDeclaration = {\n  aliases: [\"TSTypeElement\"],\n  visitor: [\"typeParameters\", \"parameters\", \"typeAnnotation\"],\n  fields: signatureDeclarationCommon()\n};\ndefineType(\"TSCallSignatureDeclaration\", callConstructSignatureDeclaration);\ndefineType(\"TSConstructSignatureDeclaration\", callConstructSignatureDeclaration);\nconst namedTypeElementCommon = () => ({\n  key: (0, _utils.validateType)(\"Expression\"),\n  computed: {\n    default: false\n  },\n  optional: (0, _utils.validateOptional)(bool)\n});\ndefineType(\"TSPropertySignature\", {\n  aliases: [\"TSTypeElement\"],\n  visitor: [\"key\", \"typeAnnotation\"],\n  fields: Object.assign({}, namedTypeElementCommon(), {\n    readonly: (0, _utils.validateOptional)(bool),\n    typeAnnotation: (0, _utils.validateOptionalType)(\"TSTypeAnnotation\"),\n    kind: {\n      optional: true,\n      validate: (0, _utils.assertOneOf)(\"get\", \"set\")\n    }\n  })\n});\ndefineType(\"TSMethodSignature\", {\n  aliases: [\"TSTypeElement\"],\n  visitor: [\"key\", \"typeParameters\", \"parameters\", \"typeAnnotation\"],\n  fields: Object.assign({}, signatureDeclarationCommon(), namedTypeElementCommon(), {\n    kind: {\n      validate: (0, _utils.assertOneOf)(\"method\", \"get\", \"set\")\n    }\n  })\n});\ndefineType(\"TSIndexSignature\", {\n  aliases: [\"TSTypeElement\"],\n  visitor: [\"parameters\", \"typeAnnotation\"],\n  fields: {\n    readonly: (0, _utils.validateOptional)(bool),\n    static: (0, _utils.validateOptional)(bool),\n    parameters: (0, _utils.validateArrayOfType)(\"Identifier\"),\n    typeAnnotation: (0, _utils.validateOptionalType)(\"TSTypeAnnotation\")\n  }\n});\nconst tsKeywordTypes = [\"TSAnyKeyword\", \"TSBooleanKeyword\", \"TSBigIntKeyword\", \"TSIntrinsicKeyword\", \"TSNeverKeyword\", \"TSNullKeyword\", \"TSNumberKeyword\", \"TSObjectKeyword\", \"TSStringKeyword\", \"TSSymbolKeyword\", \"TSUndefinedKeyword\", \"TSUnknownKeyword\", \"TSVoidKeyword\"];\nfor (const type of tsKeywordTypes) {\n  defineType(type, {\n    aliases: [\"TSType\", \"TSBaseType\"],\n    visitor: [],\n    fields: {}\n  });\n}\ndefineType(\"TSThisType\", {\n  aliases: [\"TSType\", \"TSBaseType\"],\n  visitor: [],\n  fields: {}\n});\nconst fnOrCtrBase = {\n  aliases: [\"TSType\"],\n  visitor: [\"typeParameters\", \"parameters\", \"typeAnnotation\"]\n};\ndefineType(\"TSFunctionType\", Object.assign({}, fnOrCtrBase, {\n  fields: signatureDeclarationCommon()\n}));\ndefineType(\"TSConstructorType\", Object.assign({}, fnOrCtrBase, {\n  fields: Object.assign({}, signatureDeclarationCommon(), {\n    abstract: (0, _utils.validateOptional)(bool)\n  })\n}));\ndefineType(\"TSTypeReference\", {\n  aliases: [\"TSType\"],\n  visitor: [\"typeName\", \"typeParameters\"],\n  fields: {\n    typeName: (0, _utils.validateType)(\"TSEntityName\"),\n    [\"typeParameters\"]: (0, _utils.validateOptionalType)(\"TSTypeParameterInstantiation\")\n  }\n});\ndefineType(\"TSTypePredicate\", {\n  aliases: [\"TSType\"],\n  visitor: [\"parameterName\", \"typeAnnotation\"],\n  builder: [\"parameterName\", \"typeAnnotation\", \"asserts\"],\n  fields: {\n    parameterName: (0, _utils.validateType)(\"Identifier\", \"TSThisType\"),\n    typeAnnotation: (0, _utils.validateOptionalType)(\"TSTypeAnnotation\"),\n    asserts: (0, _utils.validateOptional)(bool)\n  }\n});\ndefineType(\"TSTypeQuery\", {\n  aliases: [\"TSType\"],\n  visitor: [\"exprName\", \"typeParameters\"],\n  fields: {\n    exprName: (0, _utils.validateType)(\"TSEntityName\", \"TSImportType\"),\n    [\"typeParameters\"]: (0, _utils.validateOptionalType)(\"TSTypeParameterInstantiation\")\n  }\n});\ndefineType(\"TSTypeLiteral\", {\n  aliases: [\"TSType\"],\n  visitor: [\"members\"],\n  fields: {\n    members: (0, _utils.validateArrayOfType)(\"TSTypeElement\")\n  }\n});\ndefineType(\"TSArrayType\", {\n  aliases: [\"TSType\"],\n  visitor: [\"elementType\"],\n  fields: {\n    elementType: (0, _utils.validateType)(\"TSType\")\n  }\n});\ndefineType(\"TSTupleType\", {\n  aliases: [\"TSType\"],\n  visitor: [\"elementTypes\"],\n  fields: {\n    elementTypes: (0, _utils.validateArrayOfType)(\"TSType\", \"TSNamedTupleMember\")\n  }\n});\ndefineType(\"TSOptionalType\", {\n  aliases: [\"TSType\"],\n  visitor: [\"typeAnnotation\"],\n  fields: {\n    typeAnnotation: (0, _utils.validateType)(\"TSType\")\n  }\n});\ndefineType(\"TSRestType\", {\n  aliases: [\"TSType\"],\n  visitor: [\"typeAnnotation\"],\n  fields: {\n    typeAnnotation: (0, _utils.validateType)(\"TSType\")\n  }\n});\ndefineType(\"TSNamedTupleMember\", {\n  visitor: [\"label\", \"elementType\"],\n  builder: [\"label\", \"elementType\", \"optional\"],\n  fields: {\n    label: (0, _utils.validateType)(\"Identifier\"),\n    optional: {\n      validate: bool,\n      default: false\n    },\n    elementType: (0, _utils.validateType)(\"TSType\")\n  }\n});\nconst unionOrIntersection = {\n  aliases: [\"TSType\"],\n  visitor: [\"types\"],\n  fields: {\n    types: (0, _utils.validateArrayOfType)(\"TSType\")\n  }\n};\ndefineType(\"TSUnionType\", unionOrIntersection);\ndefineType(\"TSIntersectionType\", unionOrIntersection);\ndefineType(\"TSConditionalType\", {\n  aliases: [\"TSType\"],\n  visitor: [\"checkType\", \"extendsType\", \"trueType\", \"falseType\"],\n  fields: {\n    checkType: (0, _utils.validateType)(\"TSType\"),\n    extendsType: (0, _utils.validateType)(\"TSType\"),\n    trueType: (0, _utils.validateType)(\"TSType\"),\n    falseType: (0, _utils.validateType)(\"TSType\")\n  }\n});\ndefineType(\"TSInferType\", {\n  aliases: [\"TSType\"],\n  visitor: [\"typeParameter\"],\n  fields: {\n    typeParameter: (0, _utils.validateType)(\"TSTypeParameter\")\n  }\n});\ndefineType(\"TSParenthesizedType\", {\n  aliases: [\"TSType\"],\n  visitor: [\"typeAnnotation\"],\n  fields: {\n    typeAnnotation: (0, _utils.validateType)(\"TSType\")\n  }\n});\ndefineType(\"TSTypeOperator\", {\n  aliases: [\"TSType\"],\n  visitor: [\"typeAnnotation\"],\n  builder: [\"typeAnnotation\", \"operator\"],\n  fields: {\n    operator: {\n      validate: (0, _utils.assertValueType)(\"string\"),\n      default: \"keyof\"\n    },\n    typeAnnotation: (0, _utils.validateType)(\"TSType\")\n  }\n});\ndefineType(\"TSIndexedAccessType\", {\n  aliases: [\"TSType\"],\n  visitor: [\"objectType\", \"indexType\"],\n  fields: {\n    objectType: (0, _utils.validateType)(\"TSType\"),\n    indexType: (0, _utils.validateType)(\"TSType\")\n  }\n});\ndefineType(\"TSMappedType\", {\n  aliases: [\"TSType\"],\n  visitor: [\"typeParameter\", \"nameType\", \"typeAnnotation\"],\n  builder: [\"typeParameter\", \"typeAnnotation\", \"nameType\"],\n  fields: Object.assign({}, {\n    typeParameter: (0, _utils.validateType)(\"TSTypeParameter\")\n  }, {\n    readonly: (0, _utils.validateOptional)((0, _utils.assertOneOf)(true, false, \"+\", \"-\")),\n    optional: (0, _utils.validateOptional)((0, _utils.assertOneOf)(true, false, \"+\", \"-\")),\n    typeAnnotation: (0, _utils.validateOptionalType)(\"TSType\"),\n    nameType: (0, _utils.validateOptionalType)(\"TSType\")\n  })\n});\ndefineType(\"TSTemplateLiteralType\", {\n  aliases: [\"TSType\", \"TSBaseType\"],\n  visitor: [\"quasis\", \"types\"],\n  fields: {\n    quasis: (0, _utils.validateArrayOfType)(\"TemplateElement\"),\n    types: {\n      validate: (0, _utils.chain)((0, _utils.assertValueType)(\"array\"), (0, _utils.assertEach)((0, _utils.assertNodeType)(\"TSType\")), function (node, key, val) {\n        if (node.quasis.length !== val.length + 1) {\n          throw new TypeError(`Number of ${node.type} quasis should be exactly one more than the number of types.\\nExpected ${val.length + 1} quasis but got ${node.quasis.length}`);\n        }\n      })\n    }\n  }\n});\ndefineType(\"TSLiteralType\", {\n  aliases: [\"TSType\", \"TSBaseType\"],\n  visitor: [\"literal\"],\n  fields: {\n    literal: {\n      validate: function () {\n        const unaryExpression = (0, _utils.assertNodeType)(\"NumericLiteral\", \"BigIntLiteral\");\n        const unaryOperator = (0, _utils.assertOneOf)(\"-\");\n        const literal = (0, _utils.assertNodeType)(\"NumericLiteral\", \"StringLiteral\", \"BooleanLiteral\", \"BigIntLiteral\", \"TemplateLiteral\");\n        const validator = function validator(parent, key, node) {\n          if ((0, _is.default)(\"UnaryExpression\", node)) {\n            unaryOperator(node, \"operator\", node.operator);\n            unaryExpression(node, \"argument\", node.argument);\n          } else {\n            literal(parent, key, node);\n          }\n        };\n        validator.oneOfNodeTypes = [\"NumericLiteral\", \"StringLiteral\", \"BooleanLiteral\", \"BigIntLiteral\", \"TemplateLiteral\", \"UnaryExpression\"];\n        return validator;\n      }()\n    }\n  }\n});\ndefineType(\"TSExpressionWithTypeArguments\", {\n  aliases: [\"TSType\"],\n  visitor: [\"expression\", \"typeParameters\"],\n  fields: {\n    expression: (0, _utils.validateType)(\"TSEntityName\"),\n    typeParameters: (0, _utils.validateOptionalType)(\"TSTypeParameterInstantiation\")\n  }\n});\ndefineType(\"TSInterfaceDeclaration\", {\n  aliases: [\"Statement\", \"Declaration\"],\n  visitor: [\"id\", \"typeParameters\", \"extends\", \"body\"],\n  fields: {\n    declare: (0, _utils.validateOptional)(bool),\n    id: (0, _utils.validateType)(\"Identifier\"),\n    typeParameters: (0, _utils.validateOptionalType)(\"TSTypeParameterDeclaration\"),\n    extends: (0, _utils.validateOptional)((0, _utils.arrayOfType)(\"TSExpressionWithTypeArguments\")),\n    body: (0, _utils.validateType)(\"TSInterfaceBody\")\n  }\n});\ndefineType(\"TSInterfaceBody\", {\n  visitor: [\"body\"],\n  fields: {\n    body: (0, _utils.validateArrayOfType)(\"TSTypeElement\")\n  }\n});\ndefineType(\"TSTypeAliasDeclaration\", {\n  aliases: [\"Statement\", \"Declaration\"],\n  visitor: [\"id\", \"typeParameters\", \"typeAnnotation\"],\n  fields: {\n    declare: (0, _utils.validateOptional)(bool),\n    id: (0, _utils.validateType)(\"Identifier\"),\n    typeParameters: (0, _utils.validateOptionalType)(\"TSTypeParameterDeclaration\"),\n    typeAnnotation: (0, _utils.validateType)(\"TSType\")\n  }\n});\ndefineType(\"TSInstantiationExpression\", {\n  aliases: [\"Expression\"],\n  visitor: [\"expression\", \"typeParameters\"],\n  fields: {\n    expression: (0, _utils.validateType)(\"Expression\"),\n    [\"typeParameters\"]: (0, _utils.validateOptionalType)(\"TSTypeParameterInstantiation\")\n  }\n});\nconst TSTypeExpression = {\n  aliases: [\"Expression\", \"LVal\", \"PatternLike\"],\n  visitor: [\"expression\", \"typeAnnotation\"],\n  fields: {\n    expression: (0, _utils.validateType)(\"Expression\"),\n    typeAnnotation: (0, _utils.validateType)(\"TSType\")\n  }\n};\ndefineType(\"TSAsExpression\", TSTypeExpression);\ndefineType(\"TSSatisfiesExpression\", TSTypeExpression);\ndefineType(\"TSTypeAssertion\", {\n  aliases: [\"Expression\", \"LVal\", \"PatternLike\"],\n  visitor: [\"typeAnnotation\", \"expression\"],\n  fields: {\n    typeAnnotation: (0, _utils.validateType)(\"TSType\"),\n    expression: (0, _utils.validateType)(\"Expression\")\n  }\n});\ndefineType(\"TSEnumBody\", {\n  visitor: [\"members\"],\n  fields: {\n    members: (0, _utils.validateArrayOfType)(\"TSEnumMember\")\n  }\n});\ndefineType(\"TSEnumDeclaration\", {\n  aliases: [\"Statement\", \"Declaration\"],\n  visitor: [\"id\", \"members\"],\n  fields: {\n    declare: (0, _utils.validateOptional)(bool),\n    const: (0, _utils.validateOptional)(bool),\n    id: (0, _utils.validateType)(\"Identifier\"),\n    members: (0, _utils.validateArrayOfType)(\"TSEnumMember\"),\n    initializer: (0, _utils.validateOptionalType)(\"Expression\"),\n    body: (0, _utils.validateOptionalType)(\"TSEnumBody\")\n  }\n});\ndefineType(\"TSEnumMember\", {\n  visitor: [\"id\", \"initializer\"],\n  fields: {\n    id: (0, _utils.validateType)(\"Identifier\", \"StringLiteral\"),\n    initializer: (0, _utils.validateOptionalType)(\"Expression\")\n  }\n});\ndefineType(\"TSModuleDeclaration\", {\n  aliases: [\"Statement\", \"Declaration\"],\n  visitor: [\"id\", \"body\"],\n  fields: Object.assign({\n    kind: {\n      validate: (0, _utils.assertOneOf)(\"global\", \"module\", \"namespace\")\n    },\n    declare: (0, _utils.validateOptional)(bool)\n  }, {\n    global: (0, _utils.validateOptional)(bool)\n  }, {\n    id: (0, _utils.validateType)(\"Identifier\", \"StringLiteral\"),\n    body: (0, _utils.validateType)(\"TSModuleBlock\", \"TSModuleDeclaration\")\n  })\n});\ndefineType(\"TSModuleBlock\", {\n  aliases: [\"Scopable\", \"Block\", \"BlockParent\", \"FunctionParent\"],\n  visitor: [\"body\"],\n  fields: {\n    body: (0, _utils.validateArrayOfType)(\"Statement\")\n  }\n});\ndefineType(\"TSImportType\", {\n  aliases: [\"TSType\"],\n  builder: [\"argument\", \"qualifier\", \"typeParameters\"],\n  visitor: [\"argument\", \"options\", \"qualifier\", \"typeParameters\"],\n  fields: Object.assign({}, {\n    argument: (0, _utils.validateType)(\"StringLiteral\")\n  }, {\n    qualifier: (0, _utils.validateOptionalType)(\"TSEntityName\")\n  }, {\n    typeParameters: (0, _utils.validateOptionalType)(\"TSTypeParameterInstantiation\")\n  }, {\n    options: {\n      validate: (0, _utils.assertNodeType)(\"ObjectExpression\"),\n      optional: true\n    }\n  })\n});\ndefineType(\"TSImportEqualsDeclaration\", {\n  aliases: [\"Statement\", \"Declaration\"],\n  visitor: [\"id\", \"moduleReference\"],\n  fields: Object.assign({}, {\n    isExport: (0, _utils.validate)(bool)\n  }, {\n    id: (0, _utils.validateType)(\"Identifier\"),\n    moduleReference: (0, _utils.validateType)(\"TSEntityName\", \"TSExternalModuleReference\"),\n    importKind: {\n      validate: (0, _utils.assertOneOf)(\"type\", \"value\"),\n      optional: true\n    }\n  })\n});\ndefineType(\"TSExternalModuleReference\", {\n  visitor: [\"expression\"],\n  fields: {\n    expression: (0, _utils.validateType)(\"StringLiteral\")\n  }\n});\ndefineType(\"TSNonNullExpression\", {\n  aliases: [\"Expression\", \"LVal\", \"PatternLike\"],\n  visitor: [\"expression\"],\n  fields: {\n    expression: (0, _utils.validateType)(\"Expression\")\n  }\n});\ndefineType(\"TSExportAssignment\", {\n  aliases: [\"Statement\"],\n  visitor: [\"expression\"],\n  fields: {\n    expression: (0, _utils.validateType)(\"Expression\")\n  }\n});\ndefineType(\"TSNamespaceExportDeclaration\", {\n  aliases: [\"Statement\"],\n  visitor: [\"id\"],\n  fields: {\n    id: (0, _utils.validateType)(\"Identifier\")\n  }\n});\ndefineType(\"TSTypeAnnotation\", {\n  visitor: [\"typeAnnotation\"],\n  fields: {\n    typeAnnotation: {\n      validate: (0, _utils.assertNodeType)(\"TSType\")\n    }\n  }\n});\ndefineType(\"TSTypeParameterInstantiation\", {\n  visitor: [\"params\"],\n  fields: {\n    params: (0, _utils.validateArrayOfType)(\"TSType\")\n  }\n});\ndefineType(\"TSTypeParameterDeclaration\", {\n  visitor: [\"params\"],\n  fields: {\n    params: (0, _utils.validateArrayOfType)(\"TSTypeParameter\")\n  }\n});\ndefineType(\"TSTypeParameter\", {\n  builder: [\"constraint\", \"default\", \"name\"],\n  visitor: [\"constraint\", \"default\"],\n  fields: {\n    name: {\n      validate: (0, _utils.assertValueType)(\"string\")\n    },\n    in: {\n      validate: (0, _utils.assertValueType)(\"boolean\"),\n      optional: true\n    },\n    out: {\n      validate: (0, _utils.assertValueType)(\"boolean\"),\n      optional: true\n    },\n    const: {\n      validate: (0, _utils.assertValueType)(\"boolean\"),\n      optional: true\n    },\n    constraint: {\n      validate: (0, _utils.assertNodeType)(\"TSType\"),\n      optional: true\n    },\n    default: {\n      validate: (0, _utils.assertNodeType)(\"TSType\"),\n      optional: true\n    }\n  }\n});\n\n//# sourceMappingURL=typescript.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGJhYmVsL3R5cGVzL2xpYi9kZWZpbml0aW9ucy90eXBlc2NyaXB0LmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViLGFBQWEsbUJBQU8sQ0FBQyw4RUFBWTtBQUNqQyxZQUFZLG1CQUFPLENBQUMsNEVBQVc7QUFDL0IsVUFBVSxtQkFBTyxDQUFDLG1GQUFxQjtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCO0FBQzFCLENBQUM7QUFDRDtBQUNBO0FBQ0EsQ0FBQztBQUNELDBCQUEwQjtBQUMxQixDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQSwwQkFBMEI7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQSwwQkFBMEI7QUFDMUI7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkM7QUFDN0M7QUFDQSxDQUFDO0FBQ0QsZ0RBQWdEO0FBQ2hELDBCQUEwQjtBQUMxQjtBQUNBLEdBQUc7QUFDSCxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQjtBQUMxQjtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQyxXQUFXLHdFQUF3RSxnQkFBZ0IsaUJBQWlCLG1CQUFtQjtBQUNsTDtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQjtBQUMxQjtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCO0FBQzFCO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRCIsInNvdXJjZXMiOlsid2VicGFjazovL3JlcG8tdmlzdWFsaXplci8uL25vZGVfbW9kdWxlcy9AYmFiZWwvdHlwZXMvbGliL2RlZmluaXRpb25zL3R5cGVzY3JpcHQuanM/NTNkZiJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcblxudmFyIF91dGlscyA9IHJlcXVpcmUoXCIuL3V0aWxzLmpzXCIpO1xudmFyIF9jb3JlID0gcmVxdWlyZShcIi4vY29yZS5qc1wiKTtcbnZhciBfaXMgPSByZXF1aXJlKFwiLi4vdmFsaWRhdG9ycy9pcy5qc1wiKTtcbmNvbnN0IGRlZmluZVR5cGUgPSAoMCwgX3V0aWxzLmRlZmluZUFsaWFzZWRUeXBlKShcIlR5cGVTY3JpcHRcIik7XG5jb25zdCBib29sID0gKDAsIF91dGlscy5hc3NlcnRWYWx1ZVR5cGUpKFwiYm9vbGVhblwiKTtcbmNvbnN0IHRTRnVuY3Rpb25UeXBlQW5ub3RhdGlvbkNvbW1vbiA9ICgpID0+ICh7XG4gIHJldHVyblR5cGU6IHtcbiAgICB2YWxpZGF0ZTogKDAsIF91dGlscy5hc3NlcnROb2RlVHlwZSkoXCJUU1R5cGVBbm5vdGF0aW9uXCIsIFwiTm9vcFwiKSxcbiAgICBvcHRpb25hbDogdHJ1ZVxuICB9LFxuICB0eXBlUGFyYW1ldGVyczoge1xuICAgIHZhbGlkYXRlOiAoMCwgX3V0aWxzLmFzc2VydE5vZGVUeXBlKShcIlRTVHlwZVBhcmFtZXRlckRlY2xhcmF0aW9uXCIsIFwiTm9vcFwiKSxcbiAgICBvcHRpb25hbDogdHJ1ZVxuICB9XG59KTtcbmRlZmluZVR5cGUoXCJUU1BhcmFtZXRlclByb3BlcnR5XCIsIHtcbiAgYWxpYXNlczogW1wiTFZhbFwiXSxcbiAgdmlzaXRvcjogW1wicGFyYW1ldGVyXCJdLFxuICBmaWVsZHM6IHtcbiAgICBhY2Nlc3NpYmlsaXR5OiB7XG4gICAgICB2YWxpZGF0ZTogKDAsIF91dGlscy5hc3NlcnRPbmVPZikoXCJwdWJsaWNcIiwgXCJwcml2YXRlXCIsIFwicHJvdGVjdGVkXCIpLFxuICAgICAgb3B0aW9uYWw6IHRydWVcbiAgICB9LFxuICAgIHJlYWRvbmx5OiB7XG4gICAgICB2YWxpZGF0ZTogKDAsIF91dGlscy5hc3NlcnRWYWx1ZVR5cGUpKFwiYm9vbGVhblwiKSxcbiAgICAgIG9wdGlvbmFsOiB0cnVlXG4gICAgfSxcbiAgICBwYXJhbWV0ZXI6IHtcbiAgICAgIHZhbGlkYXRlOiAoMCwgX3V0aWxzLmFzc2VydE5vZGVUeXBlKShcIklkZW50aWZpZXJcIiwgXCJBc3NpZ25tZW50UGF0dGVyblwiKVxuICAgIH0sXG4gICAgb3ZlcnJpZGU6IHtcbiAgICAgIHZhbGlkYXRlOiAoMCwgX3V0aWxzLmFzc2VydFZhbHVlVHlwZSkoXCJib29sZWFuXCIpLFxuICAgICAgb3B0aW9uYWw6IHRydWVcbiAgICB9LFxuICAgIGRlY29yYXRvcnM6IHtcbiAgICAgIHZhbGlkYXRlOiAoMCwgX3V0aWxzLmFycmF5T2ZUeXBlKShcIkRlY29yYXRvclwiKSxcbiAgICAgIG9wdGlvbmFsOiB0cnVlXG4gICAgfVxuICB9XG59KTtcbmRlZmluZVR5cGUoXCJUU0RlY2xhcmVGdW5jdGlvblwiLCB7XG4gIGFsaWFzZXM6IFtcIlN0YXRlbWVudFwiLCBcIkRlY2xhcmF0aW9uXCJdLFxuICB2aXNpdG9yOiBbXCJpZFwiLCBcInR5cGVQYXJhbWV0ZXJzXCIsIFwicGFyYW1zXCIsIFwicmV0dXJuVHlwZVwiXSxcbiAgZmllbGRzOiBPYmplY3QuYXNzaWduKHt9LCAoMCwgX2NvcmUuZnVuY3Rpb25EZWNsYXJhdGlvbkNvbW1vbikoKSwgdFNGdW5jdGlvblR5cGVBbm5vdGF0aW9uQ29tbW9uKCkpXG59KTtcbmRlZmluZVR5cGUoXCJUU0RlY2xhcmVNZXRob2RcIiwgT2JqZWN0LmFzc2lnbih7XG4gIHZpc2l0b3I6IFtcImRlY29yYXRvcnNcIiwgXCJrZXlcIiwgXCJ0eXBlUGFyYW1ldGVyc1wiLCBcInBhcmFtc1wiLCBcInJldHVyblR5cGVcIl1cbn0sICgwLCBfY29yZS5jbGFzc01ldGhvZE9yUHJvcGVydHlVbmlvblNoYXBlQ29tbW9uKSgpLCB7XG4gIGZpZWxkczogT2JqZWN0LmFzc2lnbih7fSwgKDAsIF9jb3JlLmNsYXNzTWV0aG9kT3JEZWNsYXJlTWV0aG9kQ29tbW9uKSgpLCB0U0Z1bmN0aW9uVHlwZUFubm90YXRpb25Db21tb24oKSlcbn0pKTtcbmRlZmluZVR5cGUoXCJUU1F1YWxpZmllZE5hbWVcIiwge1xuICBhbGlhc2VzOiBbXCJUU0VudGl0eU5hbWVcIl0sXG4gIHZpc2l0b3I6IFtcImxlZnRcIiwgXCJyaWdodFwiXSxcbiAgZmllbGRzOiB7XG4gICAgbGVmdDogKDAsIF91dGlscy52YWxpZGF0ZVR5cGUpKFwiVFNFbnRpdHlOYW1lXCIpLFxuICAgIHJpZ2h0OiAoMCwgX3V0aWxzLnZhbGlkYXRlVHlwZSkoXCJJZGVudGlmaWVyXCIpXG4gIH1cbn0pO1xuY29uc3Qgc2lnbmF0dXJlRGVjbGFyYXRpb25Db21tb24gPSAoKSA9PiAoe1xuICB0eXBlUGFyYW1ldGVyczogKDAsIF91dGlscy52YWxpZGF0ZU9wdGlvbmFsVHlwZSkoXCJUU1R5cGVQYXJhbWV0ZXJEZWNsYXJhdGlvblwiKSxcbiAgW1wicGFyYW1ldGVyc1wiXTogKDAsIF91dGlscy52YWxpZGF0ZUFycmF5T2ZUeXBlKShcIkFycmF5UGF0dGVyblwiLCBcIklkZW50aWZpZXJcIiwgXCJPYmplY3RQYXR0ZXJuXCIsIFwiUmVzdEVsZW1lbnRcIiksXG4gIFtcInR5cGVBbm5vdGF0aW9uXCJdOiAoMCwgX3V0aWxzLnZhbGlkYXRlT3B0aW9uYWxUeXBlKShcIlRTVHlwZUFubm90YXRpb25cIilcbn0pO1xuY29uc3QgY2FsbENvbnN0cnVjdFNpZ25hdHVyZURlY2xhcmF0aW9uID0ge1xuICBhbGlhc2VzOiBbXCJUU1R5cGVFbGVtZW50XCJdLFxuICB2aXNpdG9yOiBbXCJ0eXBlUGFyYW1ldGVyc1wiLCBcInBhcmFtZXRlcnNcIiwgXCJ0eXBlQW5ub3RhdGlvblwiXSxcbiAgZmllbGRzOiBzaWduYXR1cmVEZWNsYXJhdGlvbkNvbW1vbigpXG59O1xuZGVmaW5lVHlwZShcIlRTQ2FsbFNpZ25hdHVyZURlY2xhcmF0aW9uXCIsIGNhbGxDb25zdHJ1Y3RTaWduYXR1cmVEZWNsYXJhdGlvbik7XG5kZWZpbmVUeXBlKFwiVFNDb25zdHJ1Y3RTaWduYXR1cmVEZWNsYXJhdGlvblwiLCBjYWxsQ29uc3RydWN0U2lnbmF0dXJlRGVjbGFyYXRpb24pO1xuY29uc3QgbmFtZWRUeXBlRWxlbWVudENvbW1vbiA9ICgpID0+ICh7XG4gIGtleTogKDAsIF91dGlscy52YWxpZGF0ZVR5cGUpKFwiRXhwcmVzc2lvblwiKSxcbiAgY29tcHV0ZWQ6IHtcbiAgICBkZWZhdWx0OiBmYWxzZVxuICB9LFxuICBvcHRpb25hbDogKDAsIF91dGlscy52YWxpZGF0ZU9wdGlvbmFsKShib29sKVxufSk7XG5kZWZpbmVUeXBlKFwiVFNQcm9wZXJ0eVNpZ25hdHVyZVwiLCB7XG4gIGFsaWFzZXM6IFtcIlRTVHlwZUVsZW1lbnRcIl0sXG4gIHZpc2l0b3I6IFtcImtleVwiLCBcInR5cGVBbm5vdGF0aW9uXCJdLFxuICBmaWVsZHM6IE9iamVjdC5hc3NpZ24oe30sIG5hbWVkVHlwZUVsZW1lbnRDb21tb24oKSwge1xuICAgIHJlYWRvbmx5OiAoMCwgX3V0aWxzLnZhbGlkYXRlT3B0aW9uYWwpKGJvb2wpLFxuICAgIHR5cGVBbm5vdGF0aW9uOiAoMCwgX3V0aWxzLnZhbGlkYXRlT3B0aW9uYWxUeXBlKShcIlRTVHlwZUFubm90YXRpb25cIiksXG4gICAga2luZDoge1xuICAgICAgb3B0aW9uYWw6IHRydWUsXG4gICAgICB2YWxpZGF0ZTogKDAsIF91dGlscy5hc3NlcnRPbmVPZikoXCJnZXRcIiwgXCJzZXRcIilcbiAgICB9XG4gIH0pXG59KTtcbmRlZmluZVR5cGUoXCJUU01ldGhvZFNpZ25hdHVyZVwiLCB7XG4gIGFsaWFzZXM6IFtcIlRTVHlwZUVsZW1lbnRcIl0sXG4gIHZpc2l0b3I6IFtcImtleVwiLCBcInR5cGVQYXJhbWV0ZXJzXCIsIFwicGFyYW1ldGVyc1wiLCBcInR5cGVBbm5vdGF0aW9uXCJdLFxuICBmaWVsZHM6IE9iamVjdC5hc3NpZ24oe30sIHNpZ25hdHVyZURlY2xhcmF0aW9uQ29tbW9uKCksIG5hbWVkVHlwZUVsZW1lbnRDb21tb24oKSwge1xuICAgIGtpbmQ6IHtcbiAgICAgIHZhbGlkYXRlOiAoMCwgX3V0aWxzLmFzc2VydE9uZU9mKShcIm1ldGhvZFwiLCBcImdldFwiLCBcInNldFwiKVxuICAgIH1cbiAgfSlcbn0pO1xuZGVmaW5lVHlwZShcIlRTSW5kZXhTaWduYXR1cmVcIiwge1xuICBhbGlhc2VzOiBbXCJUU1R5cGVFbGVtZW50XCJdLFxuICB2aXNpdG9yOiBbXCJwYXJhbWV0ZXJzXCIsIFwidHlwZUFubm90YXRpb25cIl0sXG4gIGZpZWxkczoge1xuICAgIHJlYWRvbmx5OiAoMCwgX3V0aWxzLnZhbGlkYXRlT3B0aW9uYWwpKGJvb2wpLFxuICAgIHN0YXRpYzogKDAsIF91dGlscy52YWxpZGF0ZU9wdGlvbmFsKShib29sKSxcbiAgICBwYXJhbWV0ZXJzOiAoMCwgX3V0aWxzLnZhbGlkYXRlQXJyYXlPZlR5cGUpKFwiSWRlbnRpZmllclwiKSxcbiAgICB0eXBlQW5ub3RhdGlvbjogKDAsIF91dGlscy52YWxpZGF0ZU9wdGlvbmFsVHlwZSkoXCJUU1R5cGVBbm5vdGF0aW9uXCIpXG4gIH1cbn0pO1xuY29uc3QgdHNLZXl3b3JkVHlwZXMgPSBbXCJUU0FueUtleXdvcmRcIiwgXCJUU0Jvb2xlYW5LZXl3b3JkXCIsIFwiVFNCaWdJbnRLZXl3b3JkXCIsIFwiVFNJbnRyaW5zaWNLZXl3b3JkXCIsIFwiVFNOZXZlcktleXdvcmRcIiwgXCJUU051bGxLZXl3b3JkXCIsIFwiVFNOdW1iZXJLZXl3b3JkXCIsIFwiVFNPYmplY3RLZXl3b3JkXCIsIFwiVFNTdHJpbmdLZXl3b3JkXCIsIFwiVFNTeW1ib2xLZXl3b3JkXCIsIFwiVFNVbmRlZmluZWRLZXl3b3JkXCIsIFwiVFNVbmtub3duS2V5d29yZFwiLCBcIlRTVm9pZEtleXdvcmRcIl07XG5mb3IgKGNvbnN0IHR5cGUgb2YgdHNLZXl3b3JkVHlwZXMpIHtcbiAgZGVmaW5lVHlwZSh0eXBlLCB7XG4gICAgYWxpYXNlczogW1wiVFNUeXBlXCIsIFwiVFNCYXNlVHlwZVwiXSxcbiAgICB2aXNpdG9yOiBbXSxcbiAgICBmaWVsZHM6IHt9XG4gIH0pO1xufVxuZGVmaW5lVHlwZShcIlRTVGhpc1R5cGVcIiwge1xuICBhbGlhc2VzOiBbXCJUU1R5cGVcIiwgXCJUU0Jhc2VUeXBlXCJdLFxuICB2aXNpdG9yOiBbXSxcbiAgZmllbGRzOiB7fVxufSk7XG5jb25zdCBmbk9yQ3RyQmFzZSA9IHtcbiAgYWxpYXNlczogW1wiVFNUeXBlXCJdLFxuICB2aXNpdG9yOiBbXCJ0eXBlUGFyYW1ldGVyc1wiLCBcInBhcmFtZXRlcnNcIiwgXCJ0eXBlQW5ub3RhdGlvblwiXVxufTtcbmRlZmluZVR5cGUoXCJUU0Z1bmN0aW9uVHlwZVwiLCBPYmplY3QuYXNzaWduKHt9LCBmbk9yQ3RyQmFzZSwge1xuICBmaWVsZHM6IHNpZ25hdHVyZURlY2xhcmF0aW9uQ29tbW9uKClcbn0pKTtcbmRlZmluZVR5cGUoXCJUU0NvbnN0cnVjdG9yVHlwZVwiLCBPYmplY3QuYXNzaWduKHt9LCBmbk9yQ3RyQmFzZSwge1xuICBmaWVsZHM6IE9iamVjdC5hc3NpZ24oe30sIHNpZ25hdHVyZURlY2xhcmF0aW9uQ29tbW9uKCksIHtcbiAgICBhYnN0cmFjdDogKDAsIF91dGlscy52YWxpZGF0ZU9wdGlvbmFsKShib29sKVxuICB9KVxufSkpO1xuZGVmaW5lVHlwZShcIlRTVHlwZVJlZmVyZW5jZVwiLCB7XG4gIGFsaWFzZXM6IFtcIlRTVHlwZVwiXSxcbiAgdmlzaXRvcjogW1widHlwZU5hbWVcIiwgXCJ0eXBlUGFyYW1ldGVyc1wiXSxcbiAgZmllbGRzOiB7XG4gICAgdHlwZU5hbWU6ICgwLCBfdXRpbHMudmFsaWRhdGVUeXBlKShcIlRTRW50aXR5TmFtZVwiKSxcbiAgICBbXCJ0eXBlUGFyYW1ldGVyc1wiXTogKDAsIF91dGlscy52YWxpZGF0ZU9wdGlvbmFsVHlwZSkoXCJUU1R5cGVQYXJhbWV0ZXJJbnN0YW50aWF0aW9uXCIpXG4gIH1cbn0pO1xuZGVmaW5lVHlwZShcIlRTVHlwZVByZWRpY2F0ZVwiLCB7XG4gIGFsaWFzZXM6IFtcIlRTVHlwZVwiXSxcbiAgdmlzaXRvcjogW1wicGFyYW1ldGVyTmFtZVwiLCBcInR5cGVBbm5vdGF0aW9uXCJdLFxuICBidWlsZGVyOiBbXCJwYXJhbWV0ZXJOYW1lXCIsIFwidHlwZUFubm90YXRpb25cIiwgXCJhc3NlcnRzXCJdLFxuICBmaWVsZHM6IHtcbiAgICBwYXJhbWV0ZXJOYW1lOiAoMCwgX3V0aWxzLnZhbGlkYXRlVHlwZSkoXCJJZGVudGlmaWVyXCIsIFwiVFNUaGlzVHlwZVwiKSxcbiAgICB0eXBlQW5ub3RhdGlvbjogKDAsIF91dGlscy52YWxpZGF0ZU9wdGlvbmFsVHlwZSkoXCJUU1R5cGVBbm5vdGF0aW9uXCIpLFxuICAgIGFzc2VydHM6ICgwLCBfdXRpbHMudmFsaWRhdGVPcHRpb25hbCkoYm9vbClcbiAgfVxufSk7XG5kZWZpbmVUeXBlKFwiVFNUeXBlUXVlcnlcIiwge1xuICBhbGlhc2VzOiBbXCJUU1R5cGVcIl0sXG4gIHZpc2l0b3I6IFtcImV4cHJOYW1lXCIsIFwidHlwZVBhcmFtZXRlcnNcIl0sXG4gIGZpZWxkczoge1xuICAgIGV4cHJOYW1lOiAoMCwgX3V0aWxzLnZhbGlkYXRlVHlwZSkoXCJUU0VudGl0eU5hbWVcIiwgXCJUU0ltcG9ydFR5cGVcIiksXG4gICAgW1widHlwZVBhcmFtZXRlcnNcIl06ICgwLCBfdXRpbHMudmFsaWRhdGVPcHRpb25hbFR5cGUpKFwiVFNUeXBlUGFyYW1ldGVySW5zdGFudGlhdGlvblwiKVxuICB9XG59KTtcbmRlZmluZVR5cGUoXCJUU1R5cGVMaXRlcmFsXCIsIHtcbiAgYWxpYXNlczogW1wiVFNUeXBlXCJdLFxuICB2aXNpdG9yOiBbXCJtZW1iZXJzXCJdLFxuICBmaWVsZHM6IHtcbiAgICBtZW1iZXJzOiAoMCwgX3V0aWxzLnZhbGlkYXRlQXJyYXlPZlR5cGUpKFwiVFNUeXBlRWxlbWVudFwiKVxuICB9XG59KTtcbmRlZmluZVR5cGUoXCJUU0FycmF5VHlwZVwiLCB7XG4gIGFsaWFzZXM6IFtcIlRTVHlwZVwiXSxcbiAgdmlzaXRvcjogW1wiZWxlbWVudFR5cGVcIl0sXG4gIGZpZWxkczoge1xuICAgIGVsZW1lbnRUeXBlOiAoMCwgX3V0aWxzLnZhbGlkYXRlVHlwZSkoXCJUU1R5cGVcIilcbiAgfVxufSk7XG5kZWZpbmVUeXBlKFwiVFNUdXBsZVR5cGVcIiwge1xuICBhbGlhc2VzOiBbXCJUU1R5cGVcIl0sXG4gIHZpc2l0b3I6IFtcImVsZW1lbnRUeXBlc1wiXSxcbiAgZmllbGRzOiB7XG4gICAgZWxlbWVudFR5cGVzOiAoMCwgX3V0aWxzLnZhbGlkYXRlQXJyYXlPZlR5cGUpKFwiVFNUeXBlXCIsIFwiVFNOYW1lZFR1cGxlTWVtYmVyXCIpXG4gIH1cbn0pO1xuZGVmaW5lVHlwZShcIlRTT3B0aW9uYWxUeXBlXCIsIHtcbiAgYWxpYXNlczogW1wiVFNUeXBlXCJdLFxuICB2aXNpdG9yOiBbXCJ0eXBlQW5ub3RhdGlvblwiXSxcbiAgZmllbGRzOiB7XG4gICAgdHlwZUFubm90YXRpb246ICgwLCBfdXRpbHMudmFsaWRhdGVUeXBlKShcIlRTVHlwZVwiKVxuICB9XG59KTtcbmRlZmluZVR5cGUoXCJUU1Jlc3RUeXBlXCIsIHtcbiAgYWxpYXNlczogW1wiVFNUeXBlXCJdLFxuICB2aXNpdG9yOiBbXCJ0eXBlQW5ub3RhdGlvblwiXSxcbiAgZmllbGRzOiB7XG4gICAgdHlwZUFubm90YXRpb246ICgwLCBfdXRpbHMudmFsaWRhdGVUeXBlKShcIlRTVHlwZVwiKVxuICB9XG59KTtcbmRlZmluZVR5cGUoXCJUU05hbWVkVHVwbGVNZW1iZXJcIiwge1xuICB2aXNpdG9yOiBbXCJsYWJlbFwiLCBcImVsZW1lbnRUeXBlXCJdLFxuICBidWlsZGVyOiBbXCJsYWJlbFwiLCBcImVsZW1lbnRUeXBlXCIsIFwib3B0aW9uYWxcIl0sXG4gIGZpZWxkczoge1xuICAgIGxhYmVsOiAoMCwgX3V0aWxzLnZhbGlkYXRlVHlwZSkoXCJJZGVudGlmaWVyXCIpLFxuICAgIG9wdGlvbmFsOiB7XG4gICAgICB2YWxpZGF0ZTogYm9vbCxcbiAgICAgIGRlZmF1bHQ6IGZhbHNlXG4gICAgfSxcbiAgICBlbGVtZW50VHlwZTogKDAsIF91dGlscy52YWxpZGF0ZVR5cGUpKFwiVFNUeXBlXCIpXG4gIH1cbn0pO1xuY29uc3QgdW5pb25PckludGVyc2VjdGlvbiA9IHtcbiAgYWxpYXNlczogW1wiVFNUeXBlXCJdLFxuICB2aXNpdG9yOiBbXCJ0eXBlc1wiXSxcbiAgZmllbGRzOiB7XG4gICAgdHlwZXM6ICgwLCBfdXRpbHMudmFsaWRhdGVBcnJheU9mVHlwZSkoXCJUU1R5cGVcIilcbiAgfVxufTtcbmRlZmluZVR5cGUoXCJUU1VuaW9uVHlwZVwiLCB1bmlvbk9ySW50ZXJzZWN0aW9uKTtcbmRlZmluZVR5cGUoXCJUU0ludGVyc2VjdGlvblR5cGVcIiwgdW5pb25PckludGVyc2VjdGlvbik7XG5kZWZpbmVUeXBlKFwiVFNDb25kaXRpb25hbFR5cGVcIiwge1xuICBhbGlhc2VzOiBbXCJUU1R5cGVcIl0sXG4gIHZpc2l0b3I6IFtcImNoZWNrVHlwZVwiLCBcImV4dGVuZHNUeXBlXCIsIFwidHJ1ZVR5cGVcIiwgXCJmYWxzZVR5cGVcIl0sXG4gIGZpZWxkczoge1xuICAgIGNoZWNrVHlwZTogKDAsIF91dGlscy52YWxpZGF0ZVR5cGUpKFwiVFNUeXBlXCIpLFxuICAgIGV4dGVuZHNUeXBlOiAoMCwgX3V0aWxzLnZhbGlkYXRlVHlwZSkoXCJUU1R5cGVcIiksXG4gICAgdHJ1ZVR5cGU6ICgwLCBfdXRpbHMudmFsaWRhdGVUeXBlKShcIlRTVHlwZVwiKSxcbiAgICBmYWxzZVR5cGU6ICgwLCBfdXRpbHMudmFsaWRhdGVUeXBlKShcIlRTVHlwZVwiKVxuICB9XG59KTtcbmRlZmluZVR5cGUoXCJUU0luZmVyVHlwZVwiLCB7XG4gIGFsaWFzZXM6IFtcIlRTVHlwZVwiXSxcbiAgdmlzaXRvcjogW1widHlwZVBhcmFtZXRlclwiXSxcbiAgZmllbGRzOiB7XG4gICAgdHlwZVBhcmFtZXRlcjogKDAsIF91dGlscy52YWxpZGF0ZVR5cGUpKFwiVFNUeXBlUGFyYW1ldGVyXCIpXG4gIH1cbn0pO1xuZGVmaW5lVHlwZShcIlRTUGFyZW50aGVzaXplZFR5cGVcIiwge1xuICBhbGlhc2VzOiBbXCJUU1R5cGVcIl0sXG4gIHZpc2l0b3I6IFtcInR5cGVBbm5vdGF0aW9uXCJdLFxuICBmaWVsZHM6IHtcbiAgICB0eXBlQW5ub3RhdGlvbjogKDAsIF91dGlscy52YWxpZGF0ZVR5cGUpKFwiVFNUeXBlXCIpXG4gIH1cbn0pO1xuZGVmaW5lVHlwZShcIlRTVHlwZU9wZXJhdG9yXCIsIHtcbiAgYWxpYXNlczogW1wiVFNUeXBlXCJdLFxuICB2aXNpdG9yOiBbXCJ0eXBlQW5ub3RhdGlvblwiXSxcbiAgYnVpbGRlcjogW1widHlwZUFubm90YXRpb25cIiwgXCJvcGVyYXRvclwiXSxcbiAgZmllbGRzOiB7XG4gICAgb3BlcmF0b3I6IHtcbiAgICAgIHZhbGlkYXRlOiAoMCwgX3V0aWxzLmFzc2VydFZhbHVlVHlwZSkoXCJzdHJpbmdcIiksXG4gICAgICBkZWZhdWx0OiBcImtleW9mXCJcbiAgICB9LFxuICAgIHR5cGVBbm5vdGF0aW9uOiAoMCwgX3V0aWxzLnZhbGlkYXRlVHlwZSkoXCJUU1R5cGVcIilcbiAgfVxufSk7XG5kZWZpbmVUeXBlKFwiVFNJbmRleGVkQWNjZXNzVHlwZVwiLCB7XG4gIGFsaWFzZXM6IFtcIlRTVHlwZVwiXSxcbiAgdmlzaXRvcjogW1wib2JqZWN0VHlwZVwiLCBcImluZGV4VHlwZVwiXSxcbiAgZmllbGRzOiB7XG4gICAgb2JqZWN0VHlwZTogKDAsIF91dGlscy52YWxpZGF0ZVR5cGUpKFwiVFNUeXBlXCIpLFxuICAgIGluZGV4VHlwZTogKDAsIF91dGlscy52YWxpZGF0ZVR5cGUpKFwiVFNUeXBlXCIpXG4gIH1cbn0pO1xuZGVmaW5lVHlwZShcIlRTTWFwcGVkVHlwZVwiLCB7XG4gIGFsaWFzZXM6IFtcIlRTVHlwZVwiXSxcbiAgdmlzaXRvcjogW1widHlwZVBhcmFtZXRlclwiLCBcIm5hbWVUeXBlXCIsIFwidHlwZUFubm90YXRpb25cIl0sXG4gIGJ1aWxkZXI6IFtcInR5cGVQYXJhbWV0ZXJcIiwgXCJ0eXBlQW5ub3RhdGlvblwiLCBcIm5hbWVUeXBlXCJdLFxuICBmaWVsZHM6IE9iamVjdC5hc3NpZ24oe30sIHtcbiAgICB0eXBlUGFyYW1ldGVyOiAoMCwgX3V0aWxzLnZhbGlkYXRlVHlwZSkoXCJUU1R5cGVQYXJhbWV0ZXJcIilcbiAgfSwge1xuICAgIHJlYWRvbmx5OiAoMCwgX3V0aWxzLnZhbGlkYXRlT3B0aW9uYWwpKCgwLCBfdXRpbHMuYXNzZXJ0T25lT2YpKHRydWUsIGZhbHNlLCBcIitcIiwgXCItXCIpKSxcbiAgICBvcHRpb25hbDogKDAsIF91dGlscy52YWxpZGF0ZU9wdGlvbmFsKSgoMCwgX3V0aWxzLmFzc2VydE9uZU9mKSh0cnVlLCBmYWxzZSwgXCIrXCIsIFwiLVwiKSksXG4gICAgdHlwZUFubm90YXRpb246ICgwLCBfdXRpbHMudmFsaWRhdGVPcHRpb25hbFR5cGUpKFwiVFNUeXBlXCIpLFxuICAgIG5hbWVUeXBlOiAoMCwgX3V0aWxzLnZhbGlkYXRlT3B0aW9uYWxUeXBlKShcIlRTVHlwZVwiKVxuICB9KVxufSk7XG5kZWZpbmVUeXBlKFwiVFNUZW1wbGF0ZUxpdGVyYWxUeXBlXCIsIHtcbiAgYWxpYXNlczogW1wiVFNUeXBlXCIsIFwiVFNCYXNlVHlwZVwiXSxcbiAgdmlzaXRvcjogW1wicXVhc2lzXCIsIFwidHlwZXNcIl0sXG4gIGZpZWxkczoge1xuICAgIHF1YXNpczogKDAsIF91dGlscy52YWxpZGF0ZUFycmF5T2ZUeXBlKShcIlRlbXBsYXRlRWxlbWVudFwiKSxcbiAgICB0eXBlczoge1xuICAgICAgdmFsaWRhdGU6ICgwLCBfdXRpbHMuY2hhaW4pKCgwLCBfdXRpbHMuYXNzZXJ0VmFsdWVUeXBlKShcImFycmF5XCIpLCAoMCwgX3V0aWxzLmFzc2VydEVhY2gpKCgwLCBfdXRpbHMuYXNzZXJ0Tm9kZVR5cGUpKFwiVFNUeXBlXCIpKSwgZnVuY3Rpb24gKG5vZGUsIGtleSwgdmFsKSB7XG4gICAgICAgIGlmIChub2RlLnF1YXNpcy5sZW5ndGggIT09IHZhbC5sZW5ndGggKyAxKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgTnVtYmVyIG9mICR7bm9kZS50eXBlfSBxdWFzaXMgc2hvdWxkIGJlIGV4YWN0bHkgb25lIG1vcmUgdGhhbiB0aGUgbnVtYmVyIG9mIHR5cGVzLlxcbkV4cGVjdGVkICR7dmFsLmxlbmd0aCArIDF9IHF1YXNpcyBidXQgZ290ICR7bm9kZS5xdWFzaXMubGVuZ3RofWApO1xuICAgICAgICB9XG4gICAgICB9KVxuICAgIH1cbiAgfVxufSk7XG5kZWZpbmVUeXBlKFwiVFNMaXRlcmFsVHlwZVwiLCB7XG4gIGFsaWFzZXM6IFtcIlRTVHlwZVwiLCBcIlRTQmFzZVR5cGVcIl0sXG4gIHZpc2l0b3I6IFtcImxpdGVyYWxcIl0sXG4gIGZpZWxkczoge1xuICAgIGxpdGVyYWw6IHtcbiAgICAgIHZhbGlkYXRlOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGNvbnN0IHVuYXJ5RXhwcmVzc2lvbiA9ICgwLCBfdXRpbHMuYXNzZXJ0Tm9kZVR5cGUpKFwiTnVtZXJpY0xpdGVyYWxcIiwgXCJCaWdJbnRMaXRlcmFsXCIpO1xuICAgICAgICBjb25zdCB1bmFyeU9wZXJhdG9yID0gKDAsIF91dGlscy5hc3NlcnRPbmVPZikoXCItXCIpO1xuICAgICAgICBjb25zdCBsaXRlcmFsID0gKDAsIF91dGlscy5hc3NlcnROb2RlVHlwZSkoXCJOdW1lcmljTGl0ZXJhbFwiLCBcIlN0cmluZ0xpdGVyYWxcIiwgXCJCb29sZWFuTGl0ZXJhbFwiLCBcIkJpZ0ludExpdGVyYWxcIiwgXCJUZW1wbGF0ZUxpdGVyYWxcIik7XG4gICAgICAgIGNvbnN0IHZhbGlkYXRvciA9IGZ1bmN0aW9uIHZhbGlkYXRvcihwYXJlbnQsIGtleSwgbm9kZSkge1xuICAgICAgICAgIGlmICgoMCwgX2lzLmRlZmF1bHQpKFwiVW5hcnlFeHByZXNzaW9uXCIsIG5vZGUpKSB7XG4gICAgICAgICAgICB1bmFyeU9wZXJhdG9yKG5vZGUsIFwib3BlcmF0b3JcIiwgbm9kZS5vcGVyYXRvcik7XG4gICAgICAgICAgICB1bmFyeUV4cHJlc3Npb24obm9kZSwgXCJhcmd1bWVudFwiLCBub2RlLmFyZ3VtZW50KTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbGl0ZXJhbChwYXJlbnQsIGtleSwgbm9kZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICB2YWxpZGF0b3Iub25lT2ZOb2RlVHlwZXMgPSBbXCJOdW1lcmljTGl0ZXJhbFwiLCBcIlN0cmluZ0xpdGVyYWxcIiwgXCJCb29sZWFuTGl0ZXJhbFwiLCBcIkJpZ0ludExpdGVyYWxcIiwgXCJUZW1wbGF0ZUxpdGVyYWxcIiwgXCJVbmFyeUV4cHJlc3Npb25cIl07XG4gICAgICAgIHJldHVybiB2YWxpZGF0b3I7XG4gICAgICB9KClcbiAgICB9XG4gIH1cbn0pO1xuZGVmaW5lVHlwZShcIlRTRXhwcmVzc2lvbldpdGhUeXBlQXJndW1lbnRzXCIsIHtcbiAgYWxpYXNlczogW1wiVFNUeXBlXCJdLFxuICB2aXNpdG9yOiBbXCJleHByZXNzaW9uXCIsIFwidHlwZVBhcmFtZXRlcnNcIl0sXG4gIGZpZWxkczoge1xuICAgIGV4cHJlc3Npb246ICgwLCBfdXRpbHMudmFsaWRhdGVUeXBlKShcIlRTRW50aXR5TmFtZVwiKSxcbiAgICB0eXBlUGFyYW1ldGVyczogKDAsIF91dGlscy52YWxpZGF0ZU9wdGlvbmFsVHlwZSkoXCJUU1R5cGVQYXJhbWV0ZXJJbnN0YW50aWF0aW9uXCIpXG4gIH1cbn0pO1xuZGVmaW5lVHlwZShcIlRTSW50ZXJmYWNlRGVjbGFyYXRpb25cIiwge1xuICBhbGlhc2VzOiBbXCJTdGF0ZW1lbnRcIiwgXCJEZWNsYXJhdGlvblwiXSxcbiAgdmlzaXRvcjogW1wiaWRcIiwgXCJ0eXBlUGFyYW1ldGVyc1wiLCBcImV4dGVuZHNcIiwgXCJib2R5XCJdLFxuICBmaWVsZHM6IHtcbiAgICBkZWNsYXJlOiAoMCwgX3V0aWxzLnZhbGlkYXRlT3B0aW9uYWwpKGJvb2wpLFxuICAgIGlkOiAoMCwgX3V0aWxzLnZhbGlkYXRlVHlwZSkoXCJJZGVudGlmaWVyXCIpLFxuICAgIHR5cGVQYXJhbWV0ZXJzOiAoMCwgX3V0aWxzLnZhbGlkYXRlT3B0aW9uYWxUeXBlKShcIlRTVHlwZVBhcmFtZXRlckRlY2xhcmF0aW9uXCIpLFxuICAgIGV4dGVuZHM6ICgwLCBfdXRpbHMudmFsaWRhdGVPcHRpb25hbCkoKDAsIF91dGlscy5hcnJheU9mVHlwZSkoXCJUU0V4cHJlc3Npb25XaXRoVHlwZUFyZ3VtZW50c1wiKSksXG4gICAgYm9keTogKDAsIF91dGlscy52YWxpZGF0ZVR5cGUpKFwiVFNJbnRlcmZhY2VCb2R5XCIpXG4gIH1cbn0pO1xuZGVmaW5lVHlwZShcIlRTSW50ZXJmYWNlQm9keVwiLCB7XG4gIHZpc2l0b3I6IFtcImJvZHlcIl0sXG4gIGZpZWxkczoge1xuICAgIGJvZHk6ICgwLCBfdXRpbHMudmFsaWRhdGVBcnJheU9mVHlwZSkoXCJUU1R5cGVFbGVtZW50XCIpXG4gIH1cbn0pO1xuZGVmaW5lVHlwZShcIlRTVHlwZUFsaWFzRGVjbGFyYXRpb25cIiwge1xuICBhbGlhc2VzOiBbXCJTdGF0ZW1lbnRcIiwgXCJEZWNsYXJhdGlvblwiXSxcbiAgdmlzaXRvcjogW1wiaWRcIiwgXCJ0eXBlUGFyYW1ldGVyc1wiLCBcInR5cGVBbm5vdGF0aW9uXCJdLFxuICBmaWVsZHM6IHtcbiAgICBkZWNsYXJlOiAoMCwgX3V0aWxzLnZhbGlkYXRlT3B0aW9uYWwpKGJvb2wpLFxuICAgIGlkOiAoMCwgX3V0aWxzLnZhbGlkYXRlVHlwZSkoXCJJZGVudGlmaWVyXCIpLFxuICAgIHR5cGVQYXJhbWV0ZXJzOiAoMCwgX3V0aWxzLnZhbGlkYXRlT3B0aW9uYWxUeXBlKShcIlRTVHlwZVBhcmFtZXRlckRlY2xhcmF0aW9uXCIpLFxuICAgIHR5cGVBbm5vdGF0aW9uOiAoMCwgX3V0aWxzLnZhbGlkYXRlVHlwZSkoXCJUU1R5cGVcIilcbiAgfVxufSk7XG5kZWZpbmVUeXBlKFwiVFNJbnN0YW50aWF0aW9uRXhwcmVzc2lvblwiLCB7XG4gIGFsaWFzZXM6IFtcIkV4cHJlc3Npb25cIl0sXG4gIHZpc2l0b3I6IFtcImV4cHJlc3Npb25cIiwgXCJ0eXBlUGFyYW1ldGVyc1wiXSxcbiAgZmllbGRzOiB7XG4gICAgZXhwcmVzc2lvbjogKDAsIF91dGlscy52YWxpZGF0ZVR5cGUpKFwiRXhwcmVzc2lvblwiKSxcbiAgICBbXCJ0eXBlUGFyYW1ldGVyc1wiXTogKDAsIF91dGlscy52YWxpZGF0ZU9wdGlvbmFsVHlwZSkoXCJUU1R5cGVQYXJhbWV0ZXJJbnN0YW50aWF0aW9uXCIpXG4gIH1cbn0pO1xuY29uc3QgVFNUeXBlRXhwcmVzc2lvbiA9IHtcbiAgYWxpYXNlczogW1wiRXhwcmVzc2lvblwiLCBcIkxWYWxcIiwgXCJQYXR0ZXJuTGlrZVwiXSxcbiAgdmlzaXRvcjogW1wiZXhwcmVzc2lvblwiLCBcInR5cGVBbm5vdGF0aW9uXCJdLFxuICBmaWVsZHM6IHtcbiAgICBleHByZXNzaW9uOiAoMCwgX3V0aWxzLnZhbGlkYXRlVHlwZSkoXCJFeHByZXNzaW9uXCIpLFxuICAgIHR5cGVBbm5vdGF0aW9uOiAoMCwgX3V0aWxzLnZhbGlkYXRlVHlwZSkoXCJUU1R5cGVcIilcbiAgfVxufTtcbmRlZmluZVR5cGUoXCJUU0FzRXhwcmVzc2lvblwiLCBUU1R5cGVFeHByZXNzaW9uKTtcbmRlZmluZVR5cGUoXCJUU1NhdGlzZmllc0V4cHJlc3Npb25cIiwgVFNUeXBlRXhwcmVzc2lvbik7XG5kZWZpbmVUeXBlKFwiVFNUeXBlQXNzZXJ0aW9uXCIsIHtcbiAgYWxpYXNlczogW1wiRXhwcmVzc2lvblwiLCBcIkxWYWxcIiwgXCJQYXR0ZXJuTGlrZVwiXSxcbiAgdmlzaXRvcjogW1widHlwZUFubm90YXRpb25cIiwgXCJleHByZXNzaW9uXCJdLFxuICBmaWVsZHM6IHtcbiAgICB0eXBlQW5ub3RhdGlvbjogKDAsIF91dGlscy52YWxpZGF0ZVR5cGUpKFwiVFNUeXBlXCIpLFxuICAgIGV4cHJlc3Npb246ICgwLCBfdXRpbHMudmFsaWRhdGVUeXBlKShcIkV4cHJlc3Npb25cIilcbiAgfVxufSk7XG5kZWZpbmVUeXBlKFwiVFNFbnVtQm9keVwiLCB7XG4gIHZpc2l0b3I6IFtcIm1lbWJlcnNcIl0sXG4gIGZpZWxkczoge1xuICAgIG1lbWJlcnM6ICgwLCBfdXRpbHMudmFsaWRhdGVBcnJheU9mVHlwZSkoXCJUU0VudW1NZW1iZXJcIilcbiAgfVxufSk7XG5kZWZpbmVUeXBlKFwiVFNFbnVtRGVjbGFyYXRpb25cIiwge1xuICBhbGlhc2VzOiBbXCJTdGF0ZW1lbnRcIiwgXCJEZWNsYXJhdGlvblwiXSxcbiAgdmlzaXRvcjogW1wiaWRcIiwgXCJtZW1iZXJzXCJdLFxuICBmaWVsZHM6IHtcbiAgICBkZWNsYXJlOiAoMCwgX3V0aWxzLnZhbGlkYXRlT3B0aW9uYWwpKGJvb2wpLFxuICAgIGNvbnN0OiAoMCwgX3V0aWxzLnZhbGlkYXRlT3B0aW9uYWwpKGJvb2wpLFxuICAgIGlkOiAoMCwgX3V0aWxzLnZhbGlkYXRlVHlwZSkoXCJJZGVudGlmaWVyXCIpLFxuICAgIG1lbWJlcnM6ICgwLCBfdXRpbHMudmFsaWRhdGVBcnJheU9mVHlwZSkoXCJUU0VudW1NZW1iZXJcIiksXG4gICAgaW5pdGlhbGl6ZXI6ICgwLCBfdXRpbHMudmFsaWRhdGVPcHRpb25hbFR5cGUpKFwiRXhwcmVzc2lvblwiKSxcbiAgICBib2R5OiAoMCwgX3V0aWxzLnZhbGlkYXRlT3B0aW9uYWxUeXBlKShcIlRTRW51bUJvZHlcIilcbiAgfVxufSk7XG5kZWZpbmVUeXBlKFwiVFNFbnVtTWVtYmVyXCIsIHtcbiAgdmlzaXRvcjogW1wiaWRcIiwgXCJpbml0aWFsaXplclwiXSxcbiAgZmllbGRzOiB7XG4gICAgaWQ6ICgwLCBfdXRpbHMudmFsaWRhdGVUeXBlKShcIklkZW50aWZpZXJcIiwgXCJTdHJpbmdMaXRlcmFsXCIpLFxuICAgIGluaXRpYWxpemVyOiAoMCwgX3V0aWxzLnZhbGlkYXRlT3B0aW9uYWxUeXBlKShcIkV4cHJlc3Npb25cIilcbiAgfVxufSk7XG5kZWZpbmVUeXBlKFwiVFNNb2R1bGVEZWNsYXJhdGlvblwiLCB7XG4gIGFsaWFzZXM6IFtcIlN0YXRlbWVudFwiLCBcIkRlY2xhcmF0aW9uXCJdLFxuICB2aXNpdG9yOiBbXCJpZFwiLCBcImJvZHlcIl0sXG4gIGZpZWxkczogT2JqZWN0LmFzc2lnbih7XG4gICAga2luZDoge1xuICAgICAgdmFsaWRhdGU6ICgwLCBfdXRpbHMuYXNzZXJ0T25lT2YpKFwiZ2xvYmFsXCIsIFwibW9kdWxlXCIsIFwibmFtZXNwYWNlXCIpXG4gICAgfSxcbiAgICBkZWNsYXJlOiAoMCwgX3V0aWxzLnZhbGlkYXRlT3B0aW9uYWwpKGJvb2wpXG4gIH0sIHtcbiAgICBnbG9iYWw6ICgwLCBfdXRpbHMudmFsaWRhdGVPcHRpb25hbCkoYm9vbClcbiAgfSwge1xuICAgIGlkOiAoMCwgX3V0aWxzLnZhbGlkYXRlVHlwZSkoXCJJZGVudGlmaWVyXCIsIFwiU3RyaW5nTGl0ZXJhbFwiKSxcbiAgICBib2R5OiAoMCwgX3V0aWxzLnZhbGlkYXRlVHlwZSkoXCJUU01vZHVsZUJsb2NrXCIsIFwiVFNNb2R1bGVEZWNsYXJhdGlvblwiKVxuICB9KVxufSk7XG5kZWZpbmVUeXBlKFwiVFNNb2R1bGVCbG9ja1wiLCB7XG4gIGFsaWFzZXM6IFtcIlNjb3BhYmxlXCIsIFwiQmxvY2tcIiwgXCJCbG9ja1BhcmVudFwiLCBcIkZ1bmN0aW9uUGFyZW50XCJdLFxuICB2aXNpdG9yOiBbXCJib2R5XCJdLFxuICBmaWVsZHM6IHtcbiAgICBib2R5OiAoMCwgX3V0aWxzLnZhbGlkYXRlQXJyYXlPZlR5cGUpKFwiU3RhdGVtZW50XCIpXG4gIH1cbn0pO1xuZGVmaW5lVHlwZShcIlRTSW1wb3J0VHlwZVwiLCB7XG4gIGFsaWFzZXM6IFtcIlRTVHlwZVwiXSxcbiAgYnVpbGRlcjogW1wiYXJndW1lbnRcIiwgXCJxdWFsaWZpZXJcIiwgXCJ0eXBlUGFyYW1ldGVyc1wiXSxcbiAgdmlzaXRvcjogW1wiYXJndW1lbnRcIiwgXCJvcHRpb25zXCIsIFwicXVhbGlmaWVyXCIsIFwidHlwZVBhcmFtZXRlcnNcIl0sXG4gIGZpZWxkczogT2JqZWN0LmFzc2lnbih7fSwge1xuICAgIGFyZ3VtZW50OiAoMCwgX3V0aWxzLnZhbGlkYXRlVHlwZSkoXCJTdHJpbmdMaXRlcmFsXCIpXG4gIH0sIHtcbiAgICBxdWFsaWZpZXI6ICgwLCBfdXRpbHMudmFsaWRhdGVPcHRpb25hbFR5cGUpKFwiVFNFbnRpdHlOYW1lXCIpXG4gIH0sIHtcbiAgICB0eXBlUGFyYW1ldGVyczogKDAsIF91dGlscy52YWxpZGF0ZU9wdGlvbmFsVHlwZSkoXCJUU1R5cGVQYXJhbWV0ZXJJbnN0YW50aWF0aW9uXCIpXG4gIH0sIHtcbiAgICBvcHRpb25zOiB7XG4gICAgICB2YWxpZGF0ZTogKDAsIF91dGlscy5hc3NlcnROb2RlVHlwZSkoXCJPYmplY3RFeHByZXNzaW9uXCIpLFxuICAgICAgb3B0aW9uYWw6IHRydWVcbiAgICB9XG4gIH0pXG59KTtcbmRlZmluZVR5cGUoXCJUU0ltcG9ydEVxdWFsc0RlY2xhcmF0aW9uXCIsIHtcbiAgYWxpYXNlczogW1wiU3RhdGVtZW50XCIsIFwiRGVjbGFyYXRpb25cIl0sXG4gIHZpc2l0b3I6IFtcImlkXCIsIFwibW9kdWxlUmVmZXJlbmNlXCJdLFxuICBmaWVsZHM6IE9iamVjdC5hc3NpZ24oe30sIHtcbiAgICBpc0V4cG9ydDogKDAsIF91dGlscy52YWxpZGF0ZSkoYm9vbClcbiAgfSwge1xuICAgIGlkOiAoMCwgX3V0aWxzLnZhbGlkYXRlVHlwZSkoXCJJZGVudGlmaWVyXCIpLFxuICAgIG1vZHVsZVJlZmVyZW5jZTogKDAsIF91dGlscy52YWxpZGF0ZVR5cGUpKFwiVFNFbnRpdHlOYW1lXCIsIFwiVFNFeHRlcm5hbE1vZHVsZVJlZmVyZW5jZVwiKSxcbiAgICBpbXBvcnRLaW5kOiB7XG4gICAgICB2YWxpZGF0ZTogKDAsIF91dGlscy5hc3NlcnRPbmVPZikoXCJ0eXBlXCIsIFwidmFsdWVcIiksXG4gICAgICBvcHRpb25hbDogdHJ1ZVxuICAgIH1cbiAgfSlcbn0pO1xuZGVmaW5lVHlwZShcIlRTRXh0ZXJuYWxNb2R1bGVSZWZlcmVuY2VcIiwge1xuICB2aXNpdG9yOiBbXCJleHByZXNzaW9uXCJdLFxuICBmaWVsZHM6IHtcbiAgICBleHByZXNzaW9uOiAoMCwgX3V0aWxzLnZhbGlkYXRlVHlwZSkoXCJTdHJpbmdMaXRlcmFsXCIpXG4gIH1cbn0pO1xuZGVmaW5lVHlwZShcIlRTTm9uTnVsbEV4cHJlc3Npb25cIiwge1xuICBhbGlhc2VzOiBbXCJFeHByZXNzaW9uXCIsIFwiTFZhbFwiLCBcIlBhdHRlcm5MaWtlXCJdLFxuICB2aXNpdG9yOiBbXCJleHByZXNzaW9uXCJdLFxuICBmaWVsZHM6IHtcbiAgICBleHByZXNzaW9uOiAoMCwgX3V0aWxzLnZhbGlkYXRlVHlwZSkoXCJFeHByZXNzaW9uXCIpXG4gIH1cbn0pO1xuZGVmaW5lVHlwZShcIlRTRXhwb3J0QXNzaWdubWVudFwiLCB7XG4gIGFsaWFzZXM6IFtcIlN0YXRlbWVudFwiXSxcbiAgdmlzaXRvcjogW1wiZXhwcmVzc2lvblwiXSxcbiAgZmllbGRzOiB7XG4gICAgZXhwcmVzc2lvbjogKDAsIF91dGlscy52YWxpZGF0ZVR5cGUpKFwiRXhwcmVzc2lvblwiKVxuICB9XG59KTtcbmRlZmluZVR5cGUoXCJUU05hbWVzcGFjZUV4cG9ydERlY2xhcmF0aW9uXCIsIHtcbiAgYWxpYXNlczogW1wiU3RhdGVtZW50XCJdLFxuICB2aXNpdG9yOiBbXCJpZFwiXSxcbiAgZmllbGRzOiB7XG4gICAgaWQ6ICgwLCBfdXRpbHMudmFsaWRhdGVUeXBlKShcIklkZW50aWZpZXJcIilcbiAgfVxufSk7XG5kZWZpbmVUeXBlKFwiVFNUeXBlQW5ub3RhdGlvblwiLCB7XG4gIHZpc2l0b3I6IFtcInR5cGVBbm5vdGF0aW9uXCJdLFxuICBmaWVsZHM6IHtcbiAgICB0eXBlQW5ub3RhdGlvbjoge1xuICAgICAgdmFsaWRhdGU6ICgwLCBfdXRpbHMuYXNzZXJ0Tm9kZVR5cGUpKFwiVFNUeXBlXCIpXG4gICAgfVxuICB9XG59KTtcbmRlZmluZVR5cGUoXCJUU1R5cGVQYXJhbWV0ZXJJbnN0YW50aWF0aW9uXCIsIHtcbiAgdmlzaXRvcjogW1wicGFyYW1zXCJdLFxuICBmaWVsZHM6IHtcbiAgICBwYXJhbXM6ICgwLCBfdXRpbHMudmFsaWRhdGVBcnJheU9mVHlwZSkoXCJUU1R5cGVcIilcbiAgfVxufSk7XG5kZWZpbmVUeXBlKFwiVFNUeXBlUGFyYW1ldGVyRGVjbGFyYXRpb25cIiwge1xuICB2aXNpdG9yOiBbXCJwYXJhbXNcIl0sXG4gIGZpZWxkczoge1xuICAgIHBhcmFtczogKDAsIF91dGlscy52YWxpZGF0ZUFycmF5T2ZUeXBlKShcIlRTVHlwZVBhcmFtZXRlclwiKVxuICB9XG59KTtcbmRlZmluZVR5cGUoXCJUU1R5cGVQYXJhbWV0ZXJcIiwge1xuICBidWlsZGVyOiBbXCJjb25zdHJhaW50XCIsIFwiZGVmYXVsdFwiLCBcIm5hbWVcIl0sXG4gIHZpc2l0b3I6IFtcImNvbnN0cmFpbnRcIiwgXCJkZWZhdWx0XCJdLFxuICBmaWVsZHM6IHtcbiAgICBuYW1lOiB7XG4gICAgICB2YWxpZGF0ZTogKDAsIF91dGlscy5hc3NlcnRWYWx1ZVR5cGUpKFwic3RyaW5nXCIpXG4gICAgfSxcbiAgICBpbjoge1xuICAgICAgdmFsaWRhdGU6ICgwLCBfdXRpbHMuYXNzZXJ0VmFsdWVUeXBlKShcImJvb2xlYW5cIiksXG4gICAgICBvcHRpb25hbDogdHJ1ZVxuICAgIH0sXG4gICAgb3V0OiB7XG4gICAgICB2YWxpZGF0ZTogKDAsIF91dGlscy5hc3NlcnRWYWx1ZVR5cGUpKFwiYm9vbGVhblwiKSxcbiAgICAgIG9wdGlvbmFsOiB0cnVlXG4gICAgfSxcbiAgICBjb25zdDoge1xuICAgICAgdmFsaWRhdGU6ICgwLCBfdXRpbHMuYXNzZXJ0VmFsdWVUeXBlKShcImJvb2xlYW5cIiksXG4gICAgICBvcHRpb25hbDogdHJ1ZVxuICAgIH0sXG4gICAgY29uc3RyYWludDoge1xuICAgICAgdmFsaWRhdGU6ICgwLCBfdXRpbHMuYXNzZXJ0Tm9kZVR5cGUpKFwiVFNUeXBlXCIpLFxuICAgICAgb3B0aW9uYWw6IHRydWVcbiAgICB9LFxuICAgIGRlZmF1bHQ6IHtcbiAgICAgIHZhbGlkYXRlOiAoMCwgX3V0aWxzLmFzc2VydE5vZGVUeXBlKShcIlRTVHlwZVwiKSxcbiAgICAgIG9wdGlvbmFsOiB0cnVlXG4gICAgfVxuICB9XG59KTtcblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dHlwZXNjcmlwdC5qcy5tYXBcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@babel/types/lib/definitions/typescript.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@babel/types/lib/definitions/utils.js":
/*!************************************************************!*\
  !*** ./node_modules/@babel/types/lib/definitions/utils.js ***!
  \************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports.allExpandedTypes = exports.VISITOR_KEYS = exports.NODE_UNION_SHAPES__PRIVATE = exports.NODE_PARENT_VALIDATIONS = exports.NODE_FIELDS = exports.FLIPPED_ALIAS_KEYS = exports.DEPRECATED_KEYS = exports.BUILDER_KEYS = exports.ALIAS_KEYS = void 0;\nexports.arrayOf = arrayOf;\nexports.arrayOfType = arrayOfType;\nexports.assertEach = assertEach;\nexports.assertNodeOrValueType = assertNodeOrValueType;\nexports.assertNodeType = assertNodeType;\nexports.assertOneOf = assertOneOf;\nexports.assertOptionalChainStart = assertOptionalChainStart;\nexports.assertShape = assertShape;\nexports.assertValueType = assertValueType;\nexports.chain = chain;\nexports[\"default\"] = defineType;\nexports.defineAliasedType = defineAliasedType;\nexports.validate = validate;\nexports.validateArrayOfType = validateArrayOfType;\nexports.validateOptional = validateOptional;\nexports.validateOptionalType = validateOptionalType;\nexports.validateType = validateType;\nvar _is = __webpack_require__(/*! ../validators/is.js */ \"(ssr)/./node_modules/@babel/types/lib/validators/is.js\");\nvar _validate = __webpack_require__(/*! ../validators/validate.js */ \"(ssr)/./node_modules/@babel/types/lib/validators/validate.js\");\nconst VISITOR_KEYS = exports.VISITOR_KEYS = {};\nconst ALIAS_KEYS = exports.ALIAS_KEYS = {};\nconst FLIPPED_ALIAS_KEYS = exports.FLIPPED_ALIAS_KEYS = {};\nconst NODE_FIELDS = exports.NODE_FIELDS = {};\nconst BUILDER_KEYS = exports.BUILDER_KEYS = {};\nconst DEPRECATED_KEYS = exports.DEPRECATED_KEYS = {};\nconst NODE_PARENT_VALIDATIONS = exports.NODE_PARENT_VALIDATIONS = {};\nconst NODE_UNION_SHAPES__PRIVATE = exports.NODE_UNION_SHAPES__PRIVATE = {};\nfunction getType(val) {\n  if (Array.isArray(val)) {\n    return \"array\";\n  } else if (val === null) {\n    return \"null\";\n  } else {\n    return typeof val;\n  }\n}\nfunction validate(validate) {\n  return {\n    validate\n  };\n}\nfunction validateType(...typeNames) {\n  return validate(assertNodeType(...typeNames));\n}\nfunction validateOptional(validate) {\n  return {\n    validate,\n    optional: true\n  };\n}\nfunction validateOptionalType(...typeNames) {\n  return {\n    validate: assertNodeType(...typeNames),\n    optional: true\n  };\n}\nfunction arrayOf(elementType) {\n  return chain(assertValueType(\"array\"), assertEach(elementType));\n}\nfunction arrayOfType(...typeNames) {\n  return arrayOf(assertNodeType(...typeNames));\n}\nfunction validateArrayOfType(...typeNames) {\n  return validate(arrayOfType(...typeNames));\n}\nfunction assertEach(callback) {\n  const childValidator = process.env.BABEL_TYPES_8_BREAKING ? _validate.validateChild : () => {};\n  function validator(node, key, val) {\n    if (!Array.isArray(val)) return;\n    let i = 0;\n    const subKey = {\n      toString() {\n        return `${key}[${i}]`;\n      }\n    };\n    for (; i < val.length; i++) {\n      const v = val[i];\n      callback(node, subKey, v);\n      childValidator(node, subKey, v);\n    }\n  }\n  validator.each = callback;\n  return validator;\n}\nfunction assertOneOf(...values) {\n  function validate(node, key, val) {\n    if (!values.includes(val)) {\n      throw new TypeError(`Property ${key} expected value to be one of ${JSON.stringify(values)} but got ${JSON.stringify(val)}`);\n    }\n  }\n  validate.oneOf = values;\n  return validate;\n}\nconst allExpandedTypes = exports.allExpandedTypes = [];\nfunction assertNodeType(...types) {\n  const expandedTypes = new Set();\n  allExpandedTypes.push({\n    types,\n    set: expandedTypes\n  });\n  function validate(node, key, val) {\n    const valType = val == null ? void 0 : val.type;\n    if (valType != null) {\n      if (expandedTypes.has(valType)) {\n        (0, _validate.validateChild)(node, key, val);\n        return;\n      }\n      if (valType === \"Placeholder\") {\n        for (const type of types) {\n          if ((0, _is.default)(type, val)) {\n            (0, _validate.validateChild)(node, key, val);\n            return;\n          }\n        }\n      }\n    }\n    throw new TypeError(`Property ${key} of ${node.type} expected node to be of a type ${JSON.stringify(types)} but instead got ${JSON.stringify(valType)}`);\n  }\n  validate.oneOfNodeTypes = types;\n  return validate;\n}\nfunction assertNodeOrValueType(...types) {\n  function validate(node, key, val) {\n    const primitiveType = getType(val);\n    for (const type of types) {\n      if (primitiveType === type || (0, _is.default)(type, val)) {\n        (0, _validate.validateChild)(node, key, val);\n        return;\n      }\n    }\n    throw new TypeError(`Property ${key} of ${node.type} expected node to be of a type ${JSON.stringify(types)} but instead got ${JSON.stringify(val == null ? void 0 : val.type)}`);\n  }\n  validate.oneOfNodeOrValueTypes = types;\n  return validate;\n}\nfunction assertValueType(type) {\n  function validate(node, key, val) {\n    if (getType(val) === type) {\n      return;\n    }\n    throw new TypeError(`Property ${key} expected type of ${type} but got ${getType(val)}`);\n  }\n  validate.type = type;\n  return validate;\n}\nfunction assertShape(shape) {\n  const keys = Object.keys(shape);\n  function validate(node, key, val) {\n    const errors = [];\n    for (const property of keys) {\n      try {\n        (0, _validate.validateField)(node, property, val[property], shape[property]);\n      } catch (error) {\n        if (error instanceof TypeError) {\n          errors.push(error.message);\n          continue;\n        }\n        throw error;\n      }\n    }\n    if (errors.length) {\n      throw new TypeError(`Property ${key} of ${node.type} expected to have the following:\\n${errors.join(\"\\n\")}`);\n    }\n  }\n  validate.shapeOf = shape;\n  return validate;\n}\nfunction assertOptionalChainStart() {\n  function validate(node) {\n    var _current;\n    let current = node;\n    while (node) {\n      const {\n        type\n      } = current;\n      if (type === \"OptionalCallExpression\") {\n        if (current.optional) return;\n        current = current.callee;\n        continue;\n      }\n      if (type === \"OptionalMemberExpression\") {\n        if (current.optional) return;\n        current = current.object;\n        continue;\n      }\n      break;\n    }\n    throw new TypeError(`Non-optional ${node.type} must chain from an optional OptionalMemberExpression or OptionalCallExpression. Found chain from ${(_current = current) == null ? void 0 : _current.type}`);\n  }\n  return validate;\n}\nfunction chain(...fns) {\n  function validate(...args) {\n    for (const fn of fns) {\n      fn(...args);\n    }\n  }\n  validate.chainOf = fns;\n  if (fns.length >= 2 && \"type\" in fns[0] && fns[0].type === \"array\" && !(\"each\" in fns[1])) {\n    throw new Error(`An assertValueType(\"array\") validator can only be followed by an assertEach(...) validator.`);\n  }\n  return validate;\n}\nconst validTypeOpts = new Set([\"aliases\", \"builder\", \"deprecatedAlias\", \"fields\", \"inherits\", \"visitor\", \"validate\", \"unionShape\"]);\nconst validFieldKeys = new Set([\"default\", \"optional\", \"deprecated\", \"validate\"]);\nconst store = {};\nfunction defineAliasedType(...aliases) {\n  return (type, opts = {}) => {\n    let defined = opts.aliases;\n    if (!defined) {\n      var _store$opts$inherits$;\n      if (opts.inherits) defined = (_store$opts$inherits$ = store[opts.inherits].aliases) == null ? void 0 : _store$opts$inherits$.slice();\n      defined != null ? defined : defined = [];\n      opts.aliases = defined;\n    }\n    const additional = aliases.filter(a => !defined.includes(a));\n    defined.unshift(...additional);\n    defineType(type, opts);\n  };\n}\nfunction defineType(type, opts = {}) {\n  const inherits = opts.inherits && store[opts.inherits] || {};\n  let fields = opts.fields;\n  if (!fields) {\n    fields = {};\n    if (inherits.fields) {\n      const keys = Object.getOwnPropertyNames(inherits.fields);\n      for (const key of keys) {\n        const field = inherits.fields[key];\n        const def = field.default;\n        if (Array.isArray(def) ? def.length > 0 : def && typeof def === \"object\") {\n          throw new Error(\"field defaults can only be primitives or empty arrays currently\");\n        }\n        fields[key] = {\n          default: Array.isArray(def) ? [] : def,\n          optional: field.optional,\n          deprecated: field.deprecated,\n          validate: field.validate\n        };\n      }\n    }\n  }\n  const visitor = opts.visitor || inherits.visitor || [];\n  const aliases = opts.aliases || inherits.aliases || [];\n  const builder = opts.builder || inherits.builder || opts.visitor || [];\n  for (const k of Object.keys(opts)) {\n    if (!validTypeOpts.has(k)) {\n      throw new Error(`Unknown type option \"${k}\" on ${type}`);\n    }\n  }\n  if (opts.deprecatedAlias) {\n    DEPRECATED_KEYS[opts.deprecatedAlias] = type;\n  }\n  for (const key of visitor.concat(builder)) {\n    fields[key] = fields[key] || {};\n  }\n  for (const key of Object.keys(fields)) {\n    const field = fields[key];\n    if (field.default !== undefined && !builder.includes(key)) {\n      field.optional = true;\n    }\n    if (field.default === undefined) {\n      field.default = null;\n    } else if (!field.validate && field.default != null) {\n      field.validate = assertValueType(getType(field.default));\n    }\n    for (const k of Object.keys(field)) {\n      if (!validFieldKeys.has(k)) {\n        throw new Error(`Unknown field key \"${k}\" on ${type}.${key}`);\n      }\n    }\n  }\n  VISITOR_KEYS[type] = opts.visitor = visitor;\n  BUILDER_KEYS[type] = opts.builder = builder;\n  NODE_FIELDS[type] = opts.fields = fields;\n  ALIAS_KEYS[type] = opts.aliases = aliases;\n  aliases.forEach(alias => {\n    FLIPPED_ALIAS_KEYS[alias] = FLIPPED_ALIAS_KEYS[alias] || [];\n    FLIPPED_ALIAS_KEYS[alias].push(type);\n  });\n  if (opts.validate) {\n    NODE_PARENT_VALIDATIONS[type] = opts.validate;\n  }\n  if (opts.unionShape) {\n    NODE_UNION_SHAPES__PRIVATE[type] = opts.unionShape;\n  }\n  store[type] = opts;\n}\n\n//# sourceMappingURL=utils.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGJhYmVsL3R5cGVzL2xpYi9kZWZpbml0aW9ucy91dGlscy5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYiw4Q0FBNkM7QUFDN0M7QUFDQSxDQUFDLEVBQUM7QUFDRix3QkFBd0IsR0FBRyxvQkFBb0IsR0FBRyxrQ0FBa0MsR0FBRywrQkFBK0IsR0FBRyxtQkFBbUIsR0FBRywwQkFBMEIsR0FBRyx1QkFBdUIsR0FBRyxvQkFBb0IsR0FBRyxrQkFBa0I7QUFDL08sZUFBZTtBQUNmLG1CQUFtQjtBQUNuQixrQkFBa0I7QUFDbEIsNkJBQTZCO0FBQzdCLHNCQUFzQjtBQUN0QixtQkFBbUI7QUFDbkIsZ0NBQWdDO0FBQ2hDLG1CQUFtQjtBQUNuQix1QkFBdUI7QUFDdkIsYUFBYTtBQUNiLGtCQUFlO0FBQ2YseUJBQXlCO0FBQ3pCLGdCQUFnQjtBQUNoQiwyQkFBMkI7QUFDM0Isd0JBQXdCO0FBQ3hCLDRCQUE0QjtBQUM1QixvQkFBb0I7QUFDcEIsVUFBVSxtQkFBTyxDQUFDLG1GQUFxQjtBQUN2QyxnQkFBZ0IsbUJBQU8sQ0FBQywrRkFBMkI7QUFDbkQscUJBQXFCLG9CQUFvQjtBQUN6QyxtQkFBbUIsa0JBQWtCO0FBQ3JDLDJCQUEyQiwwQkFBMEI7QUFDckQsb0JBQW9CLG1CQUFtQjtBQUN2QyxxQkFBcUIsb0JBQW9CO0FBQ3pDLHdCQUF3Qix1QkFBdUI7QUFDL0MsZ0NBQWdDLCtCQUErQjtBQUMvRCxtQ0FBbUMsa0NBQWtDO0FBQ3JFO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsSUFBSSxHQUFHLEVBQUU7QUFDM0I7QUFDQTtBQUNBLFdBQVcsZ0JBQWdCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0MsS0FBSyw4QkFBOEIsd0JBQXdCLFVBQVUsb0JBQW9CO0FBQy9IO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsd0JBQXdCO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0MsS0FBSyxLQUFLLFdBQVcsZ0NBQWdDLHVCQUF1QixrQkFBa0Isd0JBQXdCO0FBQzFKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DLEtBQUssS0FBSyxXQUFXLGdDQUFnQyx1QkFBdUIsa0JBQWtCLGdEQUFnRDtBQUNsTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0MsS0FBSyxtQkFBbUIsTUFBTSxVQUFVLGFBQWE7QUFDekY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDLEtBQUssS0FBSyxXQUFXLG1DQUFtQyxrQkFBa0I7QUFDaEg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QyxXQUFXLG1HQUFtRyxzREFBc0Q7QUFDNU07QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEMsRUFBRSxPQUFPLEtBQUs7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDLEVBQUUsT0FBTyxLQUFLLEdBQUcsSUFBSTtBQUNuRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcmVwby12aXN1YWxpemVyLy4vbm9kZV9tb2R1bGVzL0BiYWJlbC90eXBlcy9saWIvZGVmaW5pdGlvbnMvdXRpbHMuanM/YmJlNyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuYWxsRXhwYW5kZWRUeXBlcyA9IGV4cG9ydHMuVklTSVRPUl9LRVlTID0gZXhwb3J0cy5OT0RFX1VOSU9OX1NIQVBFU19fUFJJVkFURSA9IGV4cG9ydHMuTk9ERV9QQVJFTlRfVkFMSURBVElPTlMgPSBleHBvcnRzLk5PREVfRklFTERTID0gZXhwb3J0cy5GTElQUEVEX0FMSUFTX0tFWVMgPSBleHBvcnRzLkRFUFJFQ0FURURfS0VZUyA9IGV4cG9ydHMuQlVJTERFUl9LRVlTID0gZXhwb3J0cy5BTElBU19LRVlTID0gdm9pZCAwO1xuZXhwb3J0cy5hcnJheU9mID0gYXJyYXlPZjtcbmV4cG9ydHMuYXJyYXlPZlR5cGUgPSBhcnJheU9mVHlwZTtcbmV4cG9ydHMuYXNzZXJ0RWFjaCA9IGFzc2VydEVhY2g7XG5leHBvcnRzLmFzc2VydE5vZGVPclZhbHVlVHlwZSA9IGFzc2VydE5vZGVPclZhbHVlVHlwZTtcbmV4cG9ydHMuYXNzZXJ0Tm9kZVR5cGUgPSBhc3NlcnROb2RlVHlwZTtcbmV4cG9ydHMuYXNzZXJ0T25lT2YgPSBhc3NlcnRPbmVPZjtcbmV4cG9ydHMuYXNzZXJ0T3B0aW9uYWxDaGFpblN0YXJ0ID0gYXNzZXJ0T3B0aW9uYWxDaGFpblN0YXJ0O1xuZXhwb3J0cy5hc3NlcnRTaGFwZSA9IGFzc2VydFNoYXBlO1xuZXhwb3J0cy5hc3NlcnRWYWx1ZVR5cGUgPSBhc3NlcnRWYWx1ZVR5cGU7XG5leHBvcnRzLmNoYWluID0gY2hhaW47XG5leHBvcnRzLmRlZmF1bHQgPSBkZWZpbmVUeXBlO1xuZXhwb3J0cy5kZWZpbmVBbGlhc2VkVHlwZSA9IGRlZmluZUFsaWFzZWRUeXBlO1xuZXhwb3J0cy52YWxpZGF0ZSA9IHZhbGlkYXRlO1xuZXhwb3J0cy52YWxpZGF0ZUFycmF5T2ZUeXBlID0gdmFsaWRhdGVBcnJheU9mVHlwZTtcbmV4cG9ydHMudmFsaWRhdGVPcHRpb25hbCA9IHZhbGlkYXRlT3B0aW9uYWw7XG5leHBvcnRzLnZhbGlkYXRlT3B0aW9uYWxUeXBlID0gdmFsaWRhdGVPcHRpb25hbFR5cGU7XG5leHBvcnRzLnZhbGlkYXRlVHlwZSA9IHZhbGlkYXRlVHlwZTtcbnZhciBfaXMgPSByZXF1aXJlKFwiLi4vdmFsaWRhdG9ycy9pcy5qc1wiKTtcbnZhciBfdmFsaWRhdGUgPSByZXF1aXJlKFwiLi4vdmFsaWRhdG9ycy92YWxpZGF0ZS5qc1wiKTtcbmNvbnN0IFZJU0lUT1JfS0VZUyA9IGV4cG9ydHMuVklTSVRPUl9LRVlTID0ge307XG5jb25zdCBBTElBU19LRVlTID0gZXhwb3J0cy5BTElBU19LRVlTID0ge307XG5jb25zdCBGTElQUEVEX0FMSUFTX0tFWVMgPSBleHBvcnRzLkZMSVBQRURfQUxJQVNfS0VZUyA9IHt9O1xuY29uc3QgTk9ERV9GSUVMRFMgPSBleHBvcnRzLk5PREVfRklFTERTID0ge307XG5jb25zdCBCVUlMREVSX0tFWVMgPSBleHBvcnRzLkJVSUxERVJfS0VZUyA9IHt9O1xuY29uc3QgREVQUkVDQVRFRF9LRVlTID0gZXhwb3J0cy5ERVBSRUNBVEVEX0tFWVMgPSB7fTtcbmNvbnN0IE5PREVfUEFSRU5UX1ZBTElEQVRJT05TID0gZXhwb3J0cy5OT0RFX1BBUkVOVF9WQUxJREFUSU9OUyA9IHt9O1xuY29uc3QgTk9ERV9VTklPTl9TSEFQRVNfX1BSSVZBVEUgPSBleHBvcnRzLk5PREVfVU5JT05fU0hBUEVTX19QUklWQVRFID0ge307XG5mdW5jdGlvbiBnZXRUeXBlKHZhbCkge1xuICBpZiAoQXJyYXkuaXNBcnJheSh2YWwpKSB7XG4gICAgcmV0dXJuIFwiYXJyYXlcIjtcbiAgfSBlbHNlIGlmICh2YWwgPT09IG51bGwpIHtcbiAgICByZXR1cm4gXCJudWxsXCI7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIHR5cGVvZiB2YWw7XG4gIH1cbn1cbmZ1bmN0aW9uIHZhbGlkYXRlKHZhbGlkYXRlKSB7XG4gIHJldHVybiB7XG4gICAgdmFsaWRhdGVcbiAgfTtcbn1cbmZ1bmN0aW9uIHZhbGlkYXRlVHlwZSguLi50eXBlTmFtZXMpIHtcbiAgcmV0dXJuIHZhbGlkYXRlKGFzc2VydE5vZGVUeXBlKC4uLnR5cGVOYW1lcykpO1xufVxuZnVuY3Rpb24gdmFsaWRhdGVPcHRpb25hbCh2YWxpZGF0ZSkge1xuICByZXR1cm4ge1xuICAgIHZhbGlkYXRlLFxuICAgIG9wdGlvbmFsOiB0cnVlXG4gIH07XG59XG5mdW5jdGlvbiB2YWxpZGF0ZU9wdGlvbmFsVHlwZSguLi50eXBlTmFtZXMpIHtcbiAgcmV0dXJuIHtcbiAgICB2YWxpZGF0ZTogYXNzZXJ0Tm9kZVR5cGUoLi4udHlwZU5hbWVzKSxcbiAgICBvcHRpb25hbDogdHJ1ZVxuICB9O1xufVxuZnVuY3Rpb24gYXJyYXlPZihlbGVtZW50VHlwZSkge1xuICByZXR1cm4gY2hhaW4oYXNzZXJ0VmFsdWVUeXBlKFwiYXJyYXlcIiksIGFzc2VydEVhY2goZWxlbWVudFR5cGUpKTtcbn1cbmZ1bmN0aW9uIGFycmF5T2ZUeXBlKC4uLnR5cGVOYW1lcykge1xuICByZXR1cm4gYXJyYXlPZihhc3NlcnROb2RlVHlwZSguLi50eXBlTmFtZXMpKTtcbn1cbmZ1bmN0aW9uIHZhbGlkYXRlQXJyYXlPZlR5cGUoLi4udHlwZU5hbWVzKSB7XG4gIHJldHVybiB2YWxpZGF0ZShhcnJheU9mVHlwZSguLi50eXBlTmFtZXMpKTtcbn1cbmZ1bmN0aW9uIGFzc2VydEVhY2goY2FsbGJhY2spIHtcbiAgY29uc3QgY2hpbGRWYWxpZGF0b3IgPSBwcm9jZXNzLmVudi5CQUJFTF9UWVBFU184X0JSRUFLSU5HID8gX3ZhbGlkYXRlLnZhbGlkYXRlQ2hpbGQgOiAoKSA9PiB7fTtcbiAgZnVuY3Rpb24gdmFsaWRhdG9yKG5vZGUsIGtleSwgdmFsKSB7XG4gICAgaWYgKCFBcnJheS5pc0FycmF5KHZhbCkpIHJldHVybjtcbiAgICBsZXQgaSA9IDA7XG4gICAgY29uc3Qgc3ViS2V5ID0ge1xuICAgICAgdG9TdHJpbmcoKSB7XG4gICAgICAgIHJldHVybiBgJHtrZXl9WyR7aX1dYDtcbiAgICAgIH1cbiAgICB9O1xuICAgIGZvciAoOyBpIDwgdmFsLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjb25zdCB2ID0gdmFsW2ldO1xuICAgICAgY2FsbGJhY2sobm9kZSwgc3ViS2V5LCB2KTtcbiAgICAgIGNoaWxkVmFsaWRhdG9yKG5vZGUsIHN1YktleSwgdik7XG4gICAgfVxuICB9XG4gIHZhbGlkYXRvci5lYWNoID0gY2FsbGJhY2s7XG4gIHJldHVybiB2YWxpZGF0b3I7XG59XG5mdW5jdGlvbiBhc3NlcnRPbmVPZiguLi52YWx1ZXMpIHtcbiAgZnVuY3Rpb24gdmFsaWRhdGUobm9kZSwga2V5LCB2YWwpIHtcbiAgICBpZiAoIXZhbHVlcy5pbmNsdWRlcyh2YWwpKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBQcm9wZXJ0eSAke2tleX0gZXhwZWN0ZWQgdmFsdWUgdG8gYmUgb25lIG9mICR7SlNPTi5zdHJpbmdpZnkodmFsdWVzKX0gYnV0IGdvdCAke0pTT04uc3RyaW5naWZ5KHZhbCl9YCk7XG4gICAgfVxuICB9XG4gIHZhbGlkYXRlLm9uZU9mID0gdmFsdWVzO1xuICByZXR1cm4gdmFsaWRhdGU7XG59XG5jb25zdCBhbGxFeHBhbmRlZFR5cGVzID0gZXhwb3J0cy5hbGxFeHBhbmRlZFR5cGVzID0gW107XG5mdW5jdGlvbiBhc3NlcnROb2RlVHlwZSguLi50eXBlcykge1xuICBjb25zdCBleHBhbmRlZFR5cGVzID0gbmV3IFNldCgpO1xuICBhbGxFeHBhbmRlZFR5cGVzLnB1c2goe1xuICAgIHR5cGVzLFxuICAgIHNldDogZXhwYW5kZWRUeXBlc1xuICB9KTtcbiAgZnVuY3Rpb24gdmFsaWRhdGUobm9kZSwga2V5LCB2YWwpIHtcbiAgICBjb25zdCB2YWxUeXBlID0gdmFsID09IG51bGwgPyB2b2lkIDAgOiB2YWwudHlwZTtcbiAgICBpZiAodmFsVHlwZSAhPSBudWxsKSB7XG4gICAgICBpZiAoZXhwYW5kZWRUeXBlcy5oYXModmFsVHlwZSkpIHtcbiAgICAgICAgKDAsIF92YWxpZGF0ZS52YWxpZGF0ZUNoaWxkKShub2RlLCBrZXksIHZhbCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGlmICh2YWxUeXBlID09PSBcIlBsYWNlaG9sZGVyXCIpIHtcbiAgICAgICAgZm9yIChjb25zdCB0eXBlIG9mIHR5cGVzKSB7XG4gICAgICAgICAgaWYgKCgwLCBfaXMuZGVmYXVsdCkodHlwZSwgdmFsKSkge1xuICAgICAgICAgICAgKDAsIF92YWxpZGF0ZS52YWxpZGF0ZUNoaWxkKShub2RlLCBrZXksIHZhbCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYFByb3BlcnR5ICR7a2V5fSBvZiAke25vZGUudHlwZX0gZXhwZWN0ZWQgbm9kZSB0byBiZSBvZiBhIHR5cGUgJHtKU09OLnN0cmluZ2lmeSh0eXBlcyl9IGJ1dCBpbnN0ZWFkIGdvdCAke0pTT04uc3RyaW5naWZ5KHZhbFR5cGUpfWApO1xuICB9XG4gIHZhbGlkYXRlLm9uZU9mTm9kZVR5cGVzID0gdHlwZXM7XG4gIHJldHVybiB2YWxpZGF0ZTtcbn1cbmZ1bmN0aW9uIGFzc2VydE5vZGVPclZhbHVlVHlwZSguLi50eXBlcykge1xuICBmdW5jdGlvbiB2YWxpZGF0ZShub2RlLCBrZXksIHZhbCkge1xuICAgIGNvbnN0IHByaW1pdGl2ZVR5cGUgPSBnZXRUeXBlKHZhbCk7XG4gICAgZm9yIChjb25zdCB0eXBlIG9mIHR5cGVzKSB7XG4gICAgICBpZiAocHJpbWl0aXZlVHlwZSA9PT0gdHlwZSB8fCAoMCwgX2lzLmRlZmF1bHQpKHR5cGUsIHZhbCkpIHtcbiAgICAgICAgKDAsIF92YWxpZGF0ZS52YWxpZGF0ZUNoaWxkKShub2RlLCBrZXksIHZhbCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICB9XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgUHJvcGVydHkgJHtrZXl9IG9mICR7bm9kZS50eXBlfSBleHBlY3RlZCBub2RlIHRvIGJlIG9mIGEgdHlwZSAke0pTT04uc3RyaW5naWZ5KHR5cGVzKX0gYnV0IGluc3RlYWQgZ290ICR7SlNPTi5zdHJpbmdpZnkodmFsID09IG51bGwgPyB2b2lkIDAgOiB2YWwudHlwZSl9YCk7XG4gIH1cbiAgdmFsaWRhdGUub25lT2ZOb2RlT3JWYWx1ZVR5cGVzID0gdHlwZXM7XG4gIHJldHVybiB2YWxpZGF0ZTtcbn1cbmZ1bmN0aW9uIGFzc2VydFZhbHVlVHlwZSh0eXBlKSB7XG4gIGZ1bmN0aW9uIHZhbGlkYXRlKG5vZGUsIGtleSwgdmFsKSB7XG4gICAgaWYgKGdldFR5cGUodmFsKSA9PT0gdHlwZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBQcm9wZXJ0eSAke2tleX0gZXhwZWN0ZWQgdHlwZSBvZiAke3R5cGV9IGJ1dCBnb3QgJHtnZXRUeXBlKHZhbCl9YCk7XG4gIH1cbiAgdmFsaWRhdGUudHlwZSA9IHR5cGU7XG4gIHJldHVybiB2YWxpZGF0ZTtcbn1cbmZ1bmN0aW9uIGFzc2VydFNoYXBlKHNoYXBlKSB7XG4gIGNvbnN0IGtleXMgPSBPYmplY3Qua2V5cyhzaGFwZSk7XG4gIGZ1bmN0aW9uIHZhbGlkYXRlKG5vZGUsIGtleSwgdmFsKSB7XG4gICAgY29uc3QgZXJyb3JzID0gW107XG4gICAgZm9yIChjb25zdCBwcm9wZXJ0eSBvZiBrZXlzKSB7XG4gICAgICB0cnkge1xuICAgICAgICAoMCwgX3ZhbGlkYXRlLnZhbGlkYXRlRmllbGQpKG5vZGUsIHByb3BlcnR5LCB2YWxbcHJvcGVydHldLCBzaGFwZVtwcm9wZXJ0eV0pO1xuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgaWYgKGVycm9yIGluc3RhbmNlb2YgVHlwZUVycm9yKSB7XG4gICAgICAgICAgZXJyb3JzLnB1c2goZXJyb3IubWVzc2FnZSk7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChlcnJvcnMubGVuZ3RoKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBQcm9wZXJ0eSAke2tleX0gb2YgJHtub2RlLnR5cGV9IGV4cGVjdGVkIHRvIGhhdmUgdGhlIGZvbGxvd2luZzpcXG4ke2Vycm9ycy5qb2luKFwiXFxuXCIpfWApO1xuICAgIH1cbiAgfVxuICB2YWxpZGF0ZS5zaGFwZU9mID0gc2hhcGU7XG4gIHJldHVybiB2YWxpZGF0ZTtcbn1cbmZ1bmN0aW9uIGFzc2VydE9wdGlvbmFsQ2hhaW5TdGFydCgpIHtcbiAgZnVuY3Rpb24gdmFsaWRhdGUobm9kZSkge1xuICAgIHZhciBfY3VycmVudDtcbiAgICBsZXQgY3VycmVudCA9IG5vZGU7XG4gICAgd2hpbGUgKG5vZGUpIHtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgdHlwZVxuICAgICAgfSA9IGN1cnJlbnQ7XG4gICAgICBpZiAodHlwZSA9PT0gXCJPcHRpb25hbENhbGxFeHByZXNzaW9uXCIpIHtcbiAgICAgICAgaWYgKGN1cnJlbnQub3B0aW9uYWwpIHJldHVybjtcbiAgICAgICAgY3VycmVudCA9IGN1cnJlbnQuY2FsbGVlO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIGlmICh0eXBlID09PSBcIk9wdGlvbmFsTWVtYmVyRXhwcmVzc2lvblwiKSB7XG4gICAgICAgIGlmIChjdXJyZW50Lm9wdGlvbmFsKSByZXR1cm47XG4gICAgICAgIGN1cnJlbnQgPSBjdXJyZW50Lm9iamVjdDtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgTm9uLW9wdGlvbmFsICR7bm9kZS50eXBlfSBtdXN0IGNoYWluIGZyb20gYW4gb3B0aW9uYWwgT3B0aW9uYWxNZW1iZXJFeHByZXNzaW9uIG9yIE9wdGlvbmFsQ2FsbEV4cHJlc3Npb24uIEZvdW5kIGNoYWluIGZyb20gJHsoX2N1cnJlbnQgPSBjdXJyZW50KSA9PSBudWxsID8gdm9pZCAwIDogX2N1cnJlbnQudHlwZX1gKTtcbiAgfVxuICByZXR1cm4gdmFsaWRhdGU7XG59XG5mdW5jdGlvbiBjaGFpbiguLi5mbnMpIHtcbiAgZnVuY3Rpb24gdmFsaWRhdGUoLi4uYXJncykge1xuICAgIGZvciAoY29uc3QgZm4gb2YgZm5zKSB7XG4gICAgICBmbiguLi5hcmdzKTtcbiAgICB9XG4gIH1cbiAgdmFsaWRhdGUuY2hhaW5PZiA9IGZucztcbiAgaWYgKGZucy5sZW5ndGggPj0gMiAmJiBcInR5cGVcIiBpbiBmbnNbMF0gJiYgZm5zWzBdLnR5cGUgPT09IFwiYXJyYXlcIiAmJiAhKFwiZWFjaFwiIGluIGZuc1sxXSkpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYEFuIGFzc2VydFZhbHVlVHlwZShcImFycmF5XCIpIHZhbGlkYXRvciBjYW4gb25seSBiZSBmb2xsb3dlZCBieSBhbiBhc3NlcnRFYWNoKC4uLikgdmFsaWRhdG9yLmApO1xuICB9XG4gIHJldHVybiB2YWxpZGF0ZTtcbn1cbmNvbnN0IHZhbGlkVHlwZU9wdHMgPSBuZXcgU2V0KFtcImFsaWFzZXNcIiwgXCJidWlsZGVyXCIsIFwiZGVwcmVjYXRlZEFsaWFzXCIsIFwiZmllbGRzXCIsIFwiaW5oZXJpdHNcIiwgXCJ2aXNpdG9yXCIsIFwidmFsaWRhdGVcIiwgXCJ1bmlvblNoYXBlXCJdKTtcbmNvbnN0IHZhbGlkRmllbGRLZXlzID0gbmV3IFNldChbXCJkZWZhdWx0XCIsIFwib3B0aW9uYWxcIiwgXCJkZXByZWNhdGVkXCIsIFwidmFsaWRhdGVcIl0pO1xuY29uc3Qgc3RvcmUgPSB7fTtcbmZ1bmN0aW9uIGRlZmluZUFsaWFzZWRUeXBlKC4uLmFsaWFzZXMpIHtcbiAgcmV0dXJuICh0eXBlLCBvcHRzID0ge30pID0+IHtcbiAgICBsZXQgZGVmaW5lZCA9IG9wdHMuYWxpYXNlcztcbiAgICBpZiAoIWRlZmluZWQpIHtcbiAgICAgIHZhciBfc3RvcmUkb3B0cyRpbmhlcml0cyQ7XG4gICAgICBpZiAob3B0cy5pbmhlcml0cykgZGVmaW5lZCA9IChfc3RvcmUkb3B0cyRpbmhlcml0cyQgPSBzdG9yZVtvcHRzLmluaGVyaXRzXS5hbGlhc2VzKSA9PSBudWxsID8gdm9pZCAwIDogX3N0b3JlJG9wdHMkaW5oZXJpdHMkLnNsaWNlKCk7XG4gICAgICBkZWZpbmVkICE9IG51bGwgPyBkZWZpbmVkIDogZGVmaW5lZCA9IFtdO1xuICAgICAgb3B0cy5hbGlhc2VzID0gZGVmaW5lZDtcbiAgICB9XG4gICAgY29uc3QgYWRkaXRpb25hbCA9IGFsaWFzZXMuZmlsdGVyKGEgPT4gIWRlZmluZWQuaW5jbHVkZXMoYSkpO1xuICAgIGRlZmluZWQudW5zaGlmdCguLi5hZGRpdGlvbmFsKTtcbiAgICBkZWZpbmVUeXBlKHR5cGUsIG9wdHMpO1xuICB9O1xufVxuZnVuY3Rpb24gZGVmaW5lVHlwZSh0eXBlLCBvcHRzID0ge30pIHtcbiAgY29uc3QgaW5oZXJpdHMgPSBvcHRzLmluaGVyaXRzICYmIHN0b3JlW29wdHMuaW5oZXJpdHNdIHx8IHt9O1xuICBsZXQgZmllbGRzID0gb3B0cy5maWVsZHM7XG4gIGlmICghZmllbGRzKSB7XG4gICAgZmllbGRzID0ge307XG4gICAgaWYgKGluaGVyaXRzLmZpZWxkcykge1xuICAgICAgY29uc3Qga2V5cyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKGluaGVyaXRzLmZpZWxkcyk7XG4gICAgICBmb3IgKGNvbnN0IGtleSBvZiBrZXlzKSB7XG4gICAgICAgIGNvbnN0IGZpZWxkID0gaW5oZXJpdHMuZmllbGRzW2tleV07XG4gICAgICAgIGNvbnN0IGRlZiA9IGZpZWxkLmRlZmF1bHQ7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KGRlZikgPyBkZWYubGVuZ3RoID4gMCA6IGRlZiAmJiB0eXBlb2YgZGVmID09PSBcIm9iamVjdFwiKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiZmllbGQgZGVmYXVsdHMgY2FuIG9ubHkgYmUgcHJpbWl0aXZlcyBvciBlbXB0eSBhcnJheXMgY3VycmVudGx5XCIpO1xuICAgICAgICB9XG4gICAgICAgIGZpZWxkc1trZXldID0ge1xuICAgICAgICAgIGRlZmF1bHQ6IEFycmF5LmlzQXJyYXkoZGVmKSA/IFtdIDogZGVmLFxuICAgICAgICAgIG9wdGlvbmFsOiBmaWVsZC5vcHRpb25hbCxcbiAgICAgICAgICBkZXByZWNhdGVkOiBmaWVsZC5kZXByZWNhdGVkLFxuICAgICAgICAgIHZhbGlkYXRlOiBmaWVsZC52YWxpZGF0ZVxuICAgICAgICB9O1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBjb25zdCB2aXNpdG9yID0gb3B0cy52aXNpdG9yIHx8IGluaGVyaXRzLnZpc2l0b3IgfHwgW107XG4gIGNvbnN0IGFsaWFzZXMgPSBvcHRzLmFsaWFzZXMgfHwgaW5oZXJpdHMuYWxpYXNlcyB8fCBbXTtcbiAgY29uc3QgYnVpbGRlciA9IG9wdHMuYnVpbGRlciB8fCBpbmhlcml0cy5idWlsZGVyIHx8IG9wdHMudmlzaXRvciB8fCBbXTtcbiAgZm9yIChjb25zdCBrIG9mIE9iamVjdC5rZXlzKG9wdHMpKSB7XG4gICAgaWYgKCF2YWxpZFR5cGVPcHRzLmhhcyhrKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBVbmtub3duIHR5cGUgb3B0aW9uIFwiJHtrfVwiIG9uICR7dHlwZX1gKTtcbiAgICB9XG4gIH1cbiAgaWYgKG9wdHMuZGVwcmVjYXRlZEFsaWFzKSB7XG4gICAgREVQUkVDQVRFRF9LRVlTW29wdHMuZGVwcmVjYXRlZEFsaWFzXSA9IHR5cGU7XG4gIH1cbiAgZm9yIChjb25zdCBrZXkgb2YgdmlzaXRvci5jb25jYXQoYnVpbGRlcikpIHtcbiAgICBmaWVsZHNba2V5XSA9IGZpZWxkc1trZXldIHx8IHt9O1xuICB9XG4gIGZvciAoY29uc3Qga2V5IG9mIE9iamVjdC5rZXlzKGZpZWxkcykpIHtcbiAgICBjb25zdCBmaWVsZCA9IGZpZWxkc1trZXldO1xuICAgIGlmIChmaWVsZC5kZWZhdWx0ICE9PSB1bmRlZmluZWQgJiYgIWJ1aWxkZXIuaW5jbHVkZXMoa2V5KSkge1xuICAgICAgZmllbGQub3B0aW9uYWwgPSB0cnVlO1xuICAgIH1cbiAgICBpZiAoZmllbGQuZGVmYXVsdCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBmaWVsZC5kZWZhdWx0ID0gbnVsbDtcbiAgICB9IGVsc2UgaWYgKCFmaWVsZC52YWxpZGF0ZSAmJiBmaWVsZC5kZWZhdWx0ICE9IG51bGwpIHtcbiAgICAgIGZpZWxkLnZhbGlkYXRlID0gYXNzZXJ0VmFsdWVUeXBlKGdldFR5cGUoZmllbGQuZGVmYXVsdCkpO1xuICAgIH1cbiAgICBmb3IgKGNvbnN0IGsgb2YgT2JqZWN0LmtleXMoZmllbGQpKSB7XG4gICAgICBpZiAoIXZhbGlkRmllbGRLZXlzLmhhcyhrKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFVua25vd24gZmllbGQga2V5IFwiJHtrfVwiIG9uICR7dHlwZX0uJHtrZXl9YCk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIFZJU0lUT1JfS0VZU1t0eXBlXSA9IG9wdHMudmlzaXRvciA9IHZpc2l0b3I7XG4gIEJVSUxERVJfS0VZU1t0eXBlXSA9IG9wdHMuYnVpbGRlciA9IGJ1aWxkZXI7XG4gIE5PREVfRklFTERTW3R5cGVdID0gb3B0cy5maWVsZHMgPSBmaWVsZHM7XG4gIEFMSUFTX0tFWVNbdHlwZV0gPSBvcHRzLmFsaWFzZXMgPSBhbGlhc2VzO1xuICBhbGlhc2VzLmZvckVhY2goYWxpYXMgPT4ge1xuICAgIEZMSVBQRURfQUxJQVNfS0VZU1thbGlhc10gPSBGTElQUEVEX0FMSUFTX0tFWVNbYWxpYXNdIHx8IFtdO1xuICAgIEZMSVBQRURfQUxJQVNfS0VZU1thbGlhc10ucHVzaCh0eXBlKTtcbiAgfSk7XG4gIGlmIChvcHRzLnZhbGlkYXRlKSB7XG4gICAgTk9ERV9QQVJFTlRfVkFMSURBVElPTlNbdHlwZV0gPSBvcHRzLnZhbGlkYXRlO1xuICB9XG4gIGlmIChvcHRzLnVuaW9uU2hhcGUpIHtcbiAgICBOT0RFX1VOSU9OX1NIQVBFU19fUFJJVkFURVt0eXBlXSA9IG9wdHMudW5pb25TaGFwZTtcbiAgfVxuICBzdG9yZVt0eXBlXSA9IG9wdHM7XG59XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXV0aWxzLmpzLm1hcFxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@babel/types/lib/definitions/utils.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@babel/types/lib/index.js":
/*!************************************************!*\
  !*** ./node_modules/@babel/types/lib/index.js ***!
  \************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nvar _exportNames = {\n  react: true,\n  assertNode: true,\n  createTypeAnnotationBasedOnTypeof: true,\n  createUnionTypeAnnotation: true,\n  createFlowUnionType: true,\n  createTSUnionType: true,\n  cloneNode: true,\n  clone: true,\n  cloneDeep: true,\n  cloneDeepWithoutLoc: true,\n  cloneWithoutLoc: true,\n  addComment: true,\n  addComments: true,\n  inheritInnerComments: true,\n  inheritLeadingComments: true,\n  inheritsComments: true,\n  inheritTrailingComments: true,\n  removeComments: true,\n  ensureBlock: true,\n  toBindingIdentifierName: true,\n  toBlock: true,\n  toComputedKey: true,\n  toExpression: true,\n  toIdentifier: true,\n  toKeyAlias: true,\n  toStatement: true,\n  valueToNode: true,\n  appendToMemberExpression: true,\n  inherits: true,\n  prependToMemberExpression: true,\n  removeProperties: true,\n  removePropertiesDeep: true,\n  removeTypeDuplicates: true,\n  getAssignmentIdentifiers: true,\n  getBindingIdentifiers: true,\n  getOuterBindingIdentifiers: true,\n  getFunctionName: true,\n  traverse: true,\n  traverseFast: true,\n  shallowEqual: true,\n  is: true,\n  isBinding: true,\n  isBlockScoped: true,\n  isImmutable: true,\n  isLet: true,\n  isNode: true,\n  isNodesEquivalent: true,\n  isPlaceholderType: true,\n  isReferenced: true,\n  isScope: true,\n  isSpecifierDefault: true,\n  isType: true,\n  isValidES3Identifier: true,\n  isValidIdentifier: true,\n  isVar: true,\n  matchesPattern: true,\n  validate: true,\n  buildMatchMemberExpression: true,\n  __internal__deprecationWarning: true\n};\nObject.defineProperty(exports, \"__internal__deprecationWarning\", ({\n  enumerable: true,\n  get: function () {\n    return _deprecationWarning.default;\n  }\n}));\nObject.defineProperty(exports, \"addComment\", ({\n  enumerable: true,\n  get: function () {\n    return _addComment.default;\n  }\n}));\nObject.defineProperty(exports, \"addComments\", ({\n  enumerable: true,\n  get: function () {\n    return _addComments.default;\n  }\n}));\nObject.defineProperty(exports, \"appendToMemberExpression\", ({\n  enumerable: true,\n  get: function () {\n    return _appendToMemberExpression.default;\n  }\n}));\nObject.defineProperty(exports, \"assertNode\", ({\n  enumerable: true,\n  get: function () {\n    return _assertNode.default;\n  }\n}));\nObject.defineProperty(exports, \"buildMatchMemberExpression\", ({\n  enumerable: true,\n  get: function () {\n    return _buildMatchMemberExpression.default;\n  }\n}));\nObject.defineProperty(exports, \"clone\", ({\n  enumerable: true,\n  get: function () {\n    return _clone.default;\n  }\n}));\nObject.defineProperty(exports, \"cloneDeep\", ({\n  enumerable: true,\n  get: function () {\n    return _cloneDeep.default;\n  }\n}));\nObject.defineProperty(exports, \"cloneDeepWithoutLoc\", ({\n  enumerable: true,\n  get: function () {\n    return _cloneDeepWithoutLoc.default;\n  }\n}));\nObject.defineProperty(exports, \"cloneNode\", ({\n  enumerable: true,\n  get: function () {\n    return _cloneNode.default;\n  }\n}));\nObject.defineProperty(exports, \"cloneWithoutLoc\", ({\n  enumerable: true,\n  get: function () {\n    return _cloneWithoutLoc.default;\n  }\n}));\nObject.defineProperty(exports, \"createFlowUnionType\", ({\n  enumerable: true,\n  get: function () {\n    return _createFlowUnionType.default;\n  }\n}));\nObject.defineProperty(exports, \"createTSUnionType\", ({\n  enumerable: true,\n  get: function () {\n    return _createTSUnionType.default;\n  }\n}));\nObject.defineProperty(exports, \"createTypeAnnotationBasedOnTypeof\", ({\n  enumerable: true,\n  get: function () {\n    return _createTypeAnnotationBasedOnTypeof.default;\n  }\n}));\nObject.defineProperty(exports, \"createUnionTypeAnnotation\", ({\n  enumerable: true,\n  get: function () {\n    return _createFlowUnionType.default;\n  }\n}));\nObject.defineProperty(exports, \"ensureBlock\", ({\n  enumerable: true,\n  get: function () {\n    return _ensureBlock.default;\n  }\n}));\nObject.defineProperty(exports, \"getAssignmentIdentifiers\", ({\n  enumerable: true,\n  get: function () {\n    return _getAssignmentIdentifiers.default;\n  }\n}));\nObject.defineProperty(exports, \"getBindingIdentifiers\", ({\n  enumerable: true,\n  get: function () {\n    return _getBindingIdentifiers.default;\n  }\n}));\nObject.defineProperty(exports, \"getFunctionName\", ({\n  enumerable: true,\n  get: function () {\n    return _getFunctionName.default;\n  }\n}));\nObject.defineProperty(exports, \"getOuterBindingIdentifiers\", ({\n  enumerable: true,\n  get: function () {\n    return _getOuterBindingIdentifiers.default;\n  }\n}));\nObject.defineProperty(exports, \"inheritInnerComments\", ({\n  enumerable: true,\n  get: function () {\n    return _inheritInnerComments.default;\n  }\n}));\nObject.defineProperty(exports, \"inheritLeadingComments\", ({\n  enumerable: true,\n  get: function () {\n    return _inheritLeadingComments.default;\n  }\n}));\nObject.defineProperty(exports, \"inheritTrailingComments\", ({\n  enumerable: true,\n  get: function () {\n    return _inheritTrailingComments.default;\n  }\n}));\nObject.defineProperty(exports, \"inherits\", ({\n  enumerable: true,\n  get: function () {\n    return _inherits.default;\n  }\n}));\nObject.defineProperty(exports, \"inheritsComments\", ({\n  enumerable: true,\n  get: function () {\n    return _inheritsComments.default;\n  }\n}));\nObject.defineProperty(exports, \"is\", ({\n  enumerable: true,\n  get: function () {\n    return _is.default;\n  }\n}));\nObject.defineProperty(exports, \"isBinding\", ({\n  enumerable: true,\n  get: function () {\n    return _isBinding.default;\n  }\n}));\nObject.defineProperty(exports, \"isBlockScoped\", ({\n  enumerable: true,\n  get: function () {\n    return _isBlockScoped.default;\n  }\n}));\nObject.defineProperty(exports, \"isImmutable\", ({\n  enumerable: true,\n  get: function () {\n    return _isImmutable.default;\n  }\n}));\nObject.defineProperty(exports, \"isLet\", ({\n  enumerable: true,\n  get: function () {\n    return _isLet.default;\n  }\n}));\nObject.defineProperty(exports, \"isNode\", ({\n  enumerable: true,\n  get: function () {\n    return _isNode.default;\n  }\n}));\nObject.defineProperty(exports, \"isNodesEquivalent\", ({\n  enumerable: true,\n  get: function () {\n    return _isNodesEquivalent.default;\n  }\n}));\nObject.defineProperty(exports, \"isPlaceholderType\", ({\n  enumerable: true,\n  get: function () {\n    return _isPlaceholderType.default;\n  }\n}));\nObject.defineProperty(exports, \"isReferenced\", ({\n  enumerable: true,\n  get: function () {\n    return _isReferenced.default;\n  }\n}));\nObject.defineProperty(exports, \"isScope\", ({\n  enumerable: true,\n  get: function () {\n    return _isScope.default;\n  }\n}));\nObject.defineProperty(exports, \"isSpecifierDefault\", ({\n  enumerable: true,\n  get: function () {\n    return _isSpecifierDefault.default;\n  }\n}));\nObject.defineProperty(exports, \"isType\", ({\n  enumerable: true,\n  get: function () {\n    return _isType.default;\n  }\n}));\nObject.defineProperty(exports, \"isValidES3Identifier\", ({\n  enumerable: true,\n  get: function () {\n    return _isValidES3Identifier.default;\n  }\n}));\nObject.defineProperty(exports, \"isValidIdentifier\", ({\n  enumerable: true,\n  get: function () {\n    return _isValidIdentifier.default;\n  }\n}));\nObject.defineProperty(exports, \"isVar\", ({\n  enumerable: true,\n  get: function () {\n    return _isVar.default;\n  }\n}));\nObject.defineProperty(exports, \"matchesPattern\", ({\n  enumerable: true,\n  get: function () {\n    return _matchesPattern.default;\n  }\n}));\nObject.defineProperty(exports, \"prependToMemberExpression\", ({\n  enumerable: true,\n  get: function () {\n    return _prependToMemberExpression.default;\n  }\n}));\nexports.react = void 0;\nObject.defineProperty(exports, \"removeComments\", ({\n  enumerable: true,\n  get: function () {\n    return _removeComments.default;\n  }\n}));\nObject.defineProperty(exports, \"removeProperties\", ({\n  enumerable: true,\n  get: function () {\n    return _removeProperties.default;\n  }\n}));\nObject.defineProperty(exports, \"removePropertiesDeep\", ({\n  enumerable: true,\n  get: function () {\n    return _removePropertiesDeep.default;\n  }\n}));\nObject.defineProperty(exports, \"removeTypeDuplicates\", ({\n  enumerable: true,\n  get: function () {\n    return _removeTypeDuplicates.default;\n  }\n}));\nObject.defineProperty(exports, \"shallowEqual\", ({\n  enumerable: true,\n  get: function () {\n    return _shallowEqual.default;\n  }\n}));\nObject.defineProperty(exports, \"toBindingIdentifierName\", ({\n  enumerable: true,\n  get: function () {\n    return _toBindingIdentifierName.default;\n  }\n}));\nObject.defineProperty(exports, \"toBlock\", ({\n  enumerable: true,\n  get: function () {\n    return _toBlock.default;\n  }\n}));\nObject.defineProperty(exports, \"toComputedKey\", ({\n  enumerable: true,\n  get: function () {\n    return _toComputedKey.default;\n  }\n}));\nObject.defineProperty(exports, \"toExpression\", ({\n  enumerable: true,\n  get: function () {\n    return _toExpression.default;\n  }\n}));\nObject.defineProperty(exports, \"toIdentifier\", ({\n  enumerable: true,\n  get: function () {\n    return _toIdentifier.default;\n  }\n}));\nObject.defineProperty(exports, \"toKeyAlias\", ({\n  enumerable: true,\n  get: function () {\n    return _toKeyAlias.default;\n  }\n}));\nObject.defineProperty(exports, \"toStatement\", ({\n  enumerable: true,\n  get: function () {\n    return _toStatement.default;\n  }\n}));\nObject.defineProperty(exports, \"traverse\", ({\n  enumerable: true,\n  get: function () {\n    return _traverse.default;\n  }\n}));\nObject.defineProperty(exports, \"traverseFast\", ({\n  enumerable: true,\n  get: function () {\n    return _traverseFast.default;\n  }\n}));\nObject.defineProperty(exports, \"validate\", ({\n  enumerable: true,\n  get: function () {\n    return _validate.default;\n  }\n}));\nObject.defineProperty(exports, \"valueToNode\", ({\n  enumerable: true,\n  get: function () {\n    return _valueToNode.default;\n  }\n}));\nvar _isReactComponent = __webpack_require__(/*! ./validators/react/isReactComponent.js */ \"(ssr)/./node_modules/@babel/types/lib/validators/react/isReactComponent.js\");\nvar _isCompatTag = __webpack_require__(/*! ./validators/react/isCompatTag.js */ \"(ssr)/./node_modules/@babel/types/lib/validators/react/isCompatTag.js\");\nvar _buildChildren = __webpack_require__(/*! ./builders/react/buildChildren.js */ \"(ssr)/./node_modules/@babel/types/lib/builders/react/buildChildren.js\");\nvar _assertNode = __webpack_require__(/*! ./asserts/assertNode.js */ \"(ssr)/./node_modules/@babel/types/lib/asserts/assertNode.js\");\nvar _index = __webpack_require__(/*! ./asserts/generated/index.js */ \"(ssr)/./node_modules/@babel/types/lib/asserts/generated/index.js\");\nObject.keys(_index).forEach(function (key) {\n  if (key === \"default\" || key === \"__esModule\") return;\n  if (Object.prototype.hasOwnProperty.call(_exportNames, key)) return;\n  if (key in exports && exports[key] === _index[key]) return;\n  Object.defineProperty(exports, key, {\n    enumerable: true,\n    get: function () {\n      return _index[key];\n    }\n  });\n});\nvar _createTypeAnnotationBasedOnTypeof = __webpack_require__(/*! ./builders/flow/createTypeAnnotationBasedOnTypeof.js */ \"(ssr)/./node_modules/@babel/types/lib/builders/flow/createTypeAnnotationBasedOnTypeof.js\");\nvar _createFlowUnionType = __webpack_require__(/*! ./builders/flow/createFlowUnionType.js */ \"(ssr)/./node_modules/@babel/types/lib/builders/flow/createFlowUnionType.js\");\nvar _createTSUnionType = __webpack_require__(/*! ./builders/typescript/createTSUnionType.js */ \"(ssr)/./node_modules/@babel/types/lib/builders/typescript/createTSUnionType.js\");\nvar _productions = __webpack_require__(/*! ./builders/productions.js */ \"(ssr)/./node_modules/@babel/types/lib/builders/productions.js\");\nObject.keys(_productions).forEach(function (key) {\n  if (key === \"default\" || key === \"__esModule\") return;\n  if (Object.prototype.hasOwnProperty.call(_exportNames, key)) return;\n  if (key in exports && exports[key] === _productions[key]) return;\n  Object.defineProperty(exports, key, {\n    enumerable: true,\n    get: function () {\n      return _productions[key];\n    }\n  });\n});\nvar _index2 = __webpack_require__(/*! ./builders/generated/index.js */ \"(ssr)/./node_modules/@babel/types/lib/builders/generated/index.js\");\nObject.keys(_index2).forEach(function (key) {\n  if (key === \"default\" || key === \"__esModule\") return;\n  if (Object.prototype.hasOwnProperty.call(_exportNames, key)) return;\n  if (key in exports && exports[key] === _index2[key]) return;\n  Object.defineProperty(exports, key, {\n    enumerable: true,\n    get: function () {\n      return _index2[key];\n    }\n  });\n});\nvar _cloneNode = __webpack_require__(/*! ./clone/cloneNode.js */ \"(ssr)/./node_modules/@babel/types/lib/clone/cloneNode.js\");\nvar _clone = __webpack_require__(/*! ./clone/clone.js */ \"(ssr)/./node_modules/@babel/types/lib/clone/clone.js\");\nvar _cloneDeep = __webpack_require__(/*! ./clone/cloneDeep.js */ \"(ssr)/./node_modules/@babel/types/lib/clone/cloneDeep.js\");\nvar _cloneDeepWithoutLoc = __webpack_require__(/*! ./clone/cloneDeepWithoutLoc.js */ \"(ssr)/./node_modules/@babel/types/lib/clone/cloneDeepWithoutLoc.js\");\nvar _cloneWithoutLoc = __webpack_require__(/*! ./clone/cloneWithoutLoc.js */ \"(ssr)/./node_modules/@babel/types/lib/clone/cloneWithoutLoc.js\");\nvar _addComment = __webpack_require__(/*! ./comments/addComment.js */ \"(ssr)/./node_modules/@babel/types/lib/comments/addComment.js\");\nvar _addComments = __webpack_require__(/*! ./comments/addComments.js */ \"(ssr)/./node_modules/@babel/types/lib/comments/addComments.js\");\nvar _inheritInnerComments = __webpack_require__(/*! ./comments/inheritInnerComments.js */ \"(ssr)/./node_modules/@babel/types/lib/comments/inheritInnerComments.js\");\nvar _inheritLeadingComments = __webpack_require__(/*! ./comments/inheritLeadingComments.js */ \"(ssr)/./node_modules/@babel/types/lib/comments/inheritLeadingComments.js\");\nvar _inheritsComments = __webpack_require__(/*! ./comments/inheritsComments.js */ \"(ssr)/./node_modules/@babel/types/lib/comments/inheritsComments.js\");\nvar _inheritTrailingComments = __webpack_require__(/*! ./comments/inheritTrailingComments.js */ \"(ssr)/./node_modules/@babel/types/lib/comments/inheritTrailingComments.js\");\nvar _removeComments = __webpack_require__(/*! ./comments/removeComments.js */ \"(ssr)/./node_modules/@babel/types/lib/comments/removeComments.js\");\nvar _index3 = __webpack_require__(/*! ./constants/generated/index.js */ \"(ssr)/./node_modules/@babel/types/lib/constants/generated/index.js\");\nObject.keys(_index3).forEach(function (key) {\n  if (key === \"default\" || key === \"__esModule\") return;\n  if (Object.prototype.hasOwnProperty.call(_exportNames, key)) return;\n  if (key in exports && exports[key] === _index3[key]) return;\n  Object.defineProperty(exports, key, {\n    enumerable: true,\n    get: function () {\n      return _index3[key];\n    }\n  });\n});\nvar _index4 = __webpack_require__(/*! ./constants/index.js */ \"(ssr)/./node_modules/@babel/types/lib/constants/index.js\");\nObject.keys(_index4).forEach(function (key) {\n  if (key === \"default\" || key === \"__esModule\") return;\n  if (Object.prototype.hasOwnProperty.call(_exportNames, key)) return;\n  if (key in exports && exports[key] === _index4[key]) return;\n  Object.defineProperty(exports, key, {\n    enumerable: true,\n    get: function () {\n      return _index4[key];\n    }\n  });\n});\nvar _ensureBlock = __webpack_require__(/*! ./converters/ensureBlock.js */ \"(ssr)/./node_modules/@babel/types/lib/converters/ensureBlock.js\");\nvar _toBindingIdentifierName = __webpack_require__(/*! ./converters/toBindingIdentifierName.js */ \"(ssr)/./node_modules/@babel/types/lib/converters/toBindingIdentifierName.js\");\nvar _toBlock = __webpack_require__(/*! ./converters/toBlock.js */ \"(ssr)/./node_modules/@babel/types/lib/converters/toBlock.js\");\nvar _toComputedKey = __webpack_require__(/*! ./converters/toComputedKey.js */ \"(ssr)/./node_modules/@babel/types/lib/converters/toComputedKey.js\");\nvar _toExpression = __webpack_require__(/*! ./converters/toExpression.js */ \"(ssr)/./node_modules/@babel/types/lib/converters/toExpression.js\");\nvar _toIdentifier = __webpack_require__(/*! ./converters/toIdentifier.js */ \"(ssr)/./node_modules/@babel/types/lib/converters/toIdentifier.js\");\nvar _toKeyAlias = __webpack_require__(/*! ./converters/toKeyAlias.js */ \"(ssr)/./node_modules/@babel/types/lib/converters/toKeyAlias.js\");\nvar _toStatement = __webpack_require__(/*! ./converters/toStatement.js */ \"(ssr)/./node_modules/@babel/types/lib/converters/toStatement.js\");\nvar _valueToNode = __webpack_require__(/*! ./converters/valueToNode.js */ \"(ssr)/./node_modules/@babel/types/lib/converters/valueToNode.js\");\nvar _index5 = __webpack_require__(/*! ./definitions/index.js */ \"(ssr)/./node_modules/@babel/types/lib/definitions/index.js\");\nObject.keys(_index5).forEach(function (key) {\n  if (key === \"default\" || key === \"__esModule\") return;\n  if (Object.prototype.hasOwnProperty.call(_exportNames, key)) return;\n  if (key in exports && exports[key] === _index5[key]) return;\n  Object.defineProperty(exports, key, {\n    enumerable: true,\n    get: function () {\n      return _index5[key];\n    }\n  });\n});\nvar _appendToMemberExpression = __webpack_require__(/*! ./modifications/appendToMemberExpression.js */ \"(ssr)/./node_modules/@babel/types/lib/modifications/appendToMemberExpression.js\");\nvar _inherits = __webpack_require__(/*! ./modifications/inherits.js */ \"(ssr)/./node_modules/@babel/types/lib/modifications/inherits.js\");\nvar _prependToMemberExpression = __webpack_require__(/*! ./modifications/prependToMemberExpression.js */ \"(ssr)/./node_modules/@babel/types/lib/modifications/prependToMemberExpression.js\");\nvar _removeProperties = __webpack_require__(/*! ./modifications/removeProperties.js */ \"(ssr)/./node_modules/@babel/types/lib/modifications/removeProperties.js\");\nvar _removePropertiesDeep = __webpack_require__(/*! ./modifications/removePropertiesDeep.js */ \"(ssr)/./node_modules/@babel/types/lib/modifications/removePropertiesDeep.js\");\nvar _removeTypeDuplicates = __webpack_require__(/*! ./modifications/flow/removeTypeDuplicates.js */ \"(ssr)/./node_modules/@babel/types/lib/modifications/flow/removeTypeDuplicates.js\");\nvar _getAssignmentIdentifiers = __webpack_require__(/*! ./retrievers/getAssignmentIdentifiers.js */ \"(ssr)/./node_modules/@babel/types/lib/retrievers/getAssignmentIdentifiers.js\");\nvar _getBindingIdentifiers = __webpack_require__(/*! ./retrievers/getBindingIdentifiers.js */ \"(ssr)/./node_modules/@babel/types/lib/retrievers/getBindingIdentifiers.js\");\nvar _getOuterBindingIdentifiers = __webpack_require__(/*! ./retrievers/getOuterBindingIdentifiers.js */ \"(ssr)/./node_modules/@babel/types/lib/retrievers/getOuterBindingIdentifiers.js\");\nvar _getFunctionName = __webpack_require__(/*! ./retrievers/getFunctionName.js */ \"(ssr)/./node_modules/@babel/types/lib/retrievers/getFunctionName.js\");\nvar _traverse = __webpack_require__(/*! ./traverse/traverse.js */ \"(ssr)/./node_modules/@babel/types/lib/traverse/traverse.js\");\nObject.keys(_traverse).forEach(function (key) {\n  if (key === \"default\" || key === \"__esModule\") return;\n  if (Object.prototype.hasOwnProperty.call(_exportNames, key)) return;\n  if (key in exports && exports[key] === _traverse[key]) return;\n  Object.defineProperty(exports, key, {\n    enumerable: true,\n    get: function () {\n      return _traverse[key];\n    }\n  });\n});\nvar _traverseFast = __webpack_require__(/*! ./traverse/traverseFast.js */ \"(ssr)/./node_modules/@babel/types/lib/traverse/traverseFast.js\");\nvar _shallowEqual = __webpack_require__(/*! ./utils/shallowEqual.js */ \"(ssr)/./node_modules/@babel/types/lib/utils/shallowEqual.js\");\nvar _is = __webpack_require__(/*! ./validators/is.js */ \"(ssr)/./node_modules/@babel/types/lib/validators/is.js\");\nvar _isBinding = __webpack_require__(/*! ./validators/isBinding.js */ \"(ssr)/./node_modules/@babel/types/lib/validators/isBinding.js\");\nvar _isBlockScoped = __webpack_require__(/*! ./validators/isBlockScoped.js */ \"(ssr)/./node_modules/@babel/types/lib/validators/isBlockScoped.js\");\nvar _isImmutable = __webpack_require__(/*! ./validators/isImmutable.js */ \"(ssr)/./node_modules/@babel/types/lib/validators/isImmutable.js\");\nvar _isLet = __webpack_require__(/*! ./validators/isLet.js */ \"(ssr)/./node_modules/@babel/types/lib/validators/isLet.js\");\nvar _isNode = __webpack_require__(/*! ./validators/isNode.js */ \"(ssr)/./node_modules/@babel/types/lib/validators/isNode.js\");\nvar _isNodesEquivalent = __webpack_require__(/*! ./validators/isNodesEquivalent.js */ \"(ssr)/./node_modules/@babel/types/lib/validators/isNodesEquivalent.js\");\nvar _isPlaceholderType = __webpack_require__(/*! ./validators/isPlaceholderType.js */ \"(ssr)/./node_modules/@babel/types/lib/validators/isPlaceholderType.js\");\nvar _isReferenced = __webpack_require__(/*! ./validators/isReferenced.js */ \"(ssr)/./node_modules/@babel/types/lib/validators/isReferenced.js\");\nvar _isScope = __webpack_require__(/*! ./validators/isScope.js */ \"(ssr)/./node_modules/@babel/types/lib/validators/isScope.js\");\nvar _isSpecifierDefault = __webpack_require__(/*! ./validators/isSpecifierDefault.js */ \"(ssr)/./node_modules/@babel/types/lib/validators/isSpecifierDefault.js\");\nvar _isType = __webpack_require__(/*! ./validators/isType.js */ \"(ssr)/./node_modules/@babel/types/lib/validators/isType.js\");\nvar _isValidES3Identifier = __webpack_require__(/*! ./validators/isValidES3Identifier.js */ \"(ssr)/./node_modules/@babel/types/lib/validators/isValidES3Identifier.js\");\nvar _isValidIdentifier = __webpack_require__(/*! ./validators/isValidIdentifier.js */ \"(ssr)/./node_modules/@babel/types/lib/validators/isValidIdentifier.js\");\nvar _isVar = __webpack_require__(/*! ./validators/isVar.js */ \"(ssr)/./node_modules/@babel/types/lib/validators/isVar.js\");\nvar _matchesPattern = __webpack_require__(/*! ./validators/matchesPattern.js */ \"(ssr)/./node_modules/@babel/types/lib/validators/matchesPattern.js\");\nvar _validate = __webpack_require__(/*! ./validators/validate.js */ \"(ssr)/./node_modules/@babel/types/lib/validators/validate.js\");\nvar _buildMatchMemberExpression = __webpack_require__(/*! ./validators/buildMatchMemberExpression.js */ \"(ssr)/./node_modules/@babel/types/lib/validators/buildMatchMemberExpression.js\");\nvar _index6 = __webpack_require__(/*! ./validators/generated/index.js */ \"(ssr)/./node_modules/@babel/types/lib/validators/generated/index.js\");\nObject.keys(_index6).forEach(function (key) {\n  if (key === \"default\" || key === \"__esModule\") return;\n  if (Object.prototype.hasOwnProperty.call(_exportNames, key)) return;\n  if (key in exports && exports[key] === _index6[key]) return;\n  Object.defineProperty(exports, key, {\n    enumerable: true,\n    get: function () {\n      return _index6[key];\n    }\n  });\n});\nvar _deprecationWarning = __webpack_require__(/*! ./utils/deprecationWarning.js */ \"(ssr)/./node_modules/@babel/types/lib/utils/deprecationWarning.js\");\nvar _toSequenceExpression = __webpack_require__(/*! ./converters/toSequenceExpression.js */ \"(ssr)/./node_modules/@babel/types/lib/converters/toSequenceExpression.js\");\nconst react = exports.react = {\n  isReactComponent: _isReactComponent.default,\n  isCompatTag: _isCompatTag.default,\n  buildChildren: _buildChildren.default\n};\nexports.toSequenceExpression = _toSequenceExpression.default;\nif (process.env.BABEL_TYPES_8_BREAKING) {\n  console.warn(\"BABEL_TYPES_8_BREAKING is not supported anymore. Use the latest Babel 8.0.0 pre-release instead!\");\n}\n\n//# sourceMappingURL=index.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGJhYmVsL3R5cGVzL2xpYi9pbmRleC5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYiw4Q0FBNkM7QUFDN0M7QUFDQSxDQUFDLEVBQUM7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtFQUFpRTtBQUNqRTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsRUFBQztBQUNGLDhDQUE2QztBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsRUFBQztBQUNGLCtDQUE4QztBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsRUFBQztBQUNGLDREQUEyRDtBQUMzRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsRUFBQztBQUNGLDhDQUE2QztBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsRUFBQztBQUNGLDhEQUE2RDtBQUM3RDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsRUFBQztBQUNGLHlDQUF3QztBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsRUFBQztBQUNGLDZDQUE0QztBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsRUFBQztBQUNGLHVEQUFzRDtBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsRUFBQztBQUNGLDZDQUE0QztBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsRUFBQztBQUNGLG1EQUFrRDtBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsRUFBQztBQUNGLHVEQUFzRDtBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsRUFBQztBQUNGLHFEQUFvRDtBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsRUFBQztBQUNGLHFFQUFvRTtBQUNwRTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsRUFBQztBQUNGLDZEQUE0RDtBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsRUFBQztBQUNGLCtDQUE4QztBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsRUFBQztBQUNGLDREQUEyRDtBQUMzRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsRUFBQztBQUNGLHlEQUF3RDtBQUN4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsRUFBQztBQUNGLG1EQUFrRDtBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsRUFBQztBQUNGLDhEQUE2RDtBQUM3RDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsRUFBQztBQUNGLHdEQUF1RDtBQUN2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsRUFBQztBQUNGLDBEQUF5RDtBQUN6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsRUFBQztBQUNGLDJEQUEwRDtBQUMxRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsRUFBQztBQUNGLDRDQUEyQztBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsRUFBQztBQUNGLG9EQUFtRDtBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsRUFBQztBQUNGLHNDQUFxQztBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsRUFBQztBQUNGLDZDQUE0QztBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsRUFBQztBQUNGLGlEQUFnRDtBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsRUFBQztBQUNGLCtDQUE4QztBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsRUFBQztBQUNGLHlDQUF3QztBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsRUFBQztBQUNGLDBDQUF5QztBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsRUFBQztBQUNGLHFEQUFvRDtBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsRUFBQztBQUNGLHFEQUFvRDtBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsRUFBQztBQUNGLGdEQUErQztBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsRUFBQztBQUNGLDJDQUEwQztBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsRUFBQztBQUNGLHNEQUFxRDtBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsRUFBQztBQUNGLDBDQUF5QztBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsRUFBQztBQUNGLHdEQUF1RDtBQUN2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsRUFBQztBQUNGLHFEQUFvRDtBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsRUFBQztBQUNGLHlDQUF3QztBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsRUFBQztBQUNGLGtEQUFpRDtBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsRUFBQztBQUNGLDZEQUE0RDtBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsRUFBQztBQUNGLGFBQWE7QUFDYixrREFBaUQ7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLEVBQUM7QUFDRixvREFBbUQ7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLEVBQUM7QUFDRix3REFBdUQ7QUFDdkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLEVBQUM7QUFDRix3REFBdUQ7QUFDdkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLEVBQUM7QUFDRixnREFBK0M7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLEVBQUM7QUFDRiwyREFBMEQ7QUFDMUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLEVBQUM7QUFDRiwyQ0FBMEM7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLEVBQUM7QUFDRixpREFBZ0Q7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLEVBQUM7QUFDRixnREFBK0M7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLEVBQUM7QUFDRixnREFBK0M7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLEVBQUM7QUFDRiw4Q0FBNkM7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLEVBQUM7QUFDRiwrQ0FBOEM7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLEVBQUM7QUFDRiw0Q0FBMkM7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLEVBQUM7QUFDRixnREFBK0M7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLEVBQUM7QUFDRiw0Q0FBMkM7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLEVBQUM7QUFDRiwrQ0FBOEM7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLEVBQUM7QUFDRix3QkFBd0IsbUJBQU8sQ0FBQywwSEFBd0M7QUFDeEUsbUJBQW1CLG1CQUFPLENBQUMsZ0hBQW1DO0FBQzlELHFCQUFxQixtQkFBTyxDQUFDLGdIQUFtQztBQUNoRSxrQkFBa0IsbUJBQU8sQ0FBQyw0RkFBeUI7QUFDbkQsYUFBYSxtQkFBTyxDQUFDLHNHQUE4QjtBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsQ0FBQztBQUNELHlDQUF5QyxtQkFBTyxDQUFDLHNKQUFzRDtBQUN2RywyQkFBMkIsbUJBQU8sQ0FBQywwSEFBd0M7QUFDM0UseUJBQXlCLG1CQUFPLENBQUMsa0lBQTRDO0FBQzdFLG1CQUFtQixtQkFBTyxDQUFDLGdHQUEyQjtBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsQ0FBQztBQUNELGNBQWMsbUJBQU8sQ0FBQyx3R0FBK0I7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILENBQUM7QUFDRCxpQkFBaUIsbUJBQU8sQ0FBQyxzRkFBc0I7QUFDL0MsYUFBYSxtQkFBTyxDQUFDLDhFQUFrQjtBQUN2QyxpQkFBaUIsbUJBQU8sQ0FBQyxzRkFBc0I7QUFDL0MsMkJBQTJCLG1CQUFPLENBQUMsMEdBQWdDO0FBQ25FLHVCQUF1QixtQkFBTyxDQUFDLGtHQUE0QjtBQUMzRCxrQkFBa0IsbUJBQU8sQ0FBQyw4RkFBMEI7QUFDcEQsbUJBQW1CLG1CQUFPLENBQUMsZ0dBQTJCO0FBQ3RELDRCQUE0QixtQkFBTyxDQUFDLGtIQUFvQztBQUN4RSw4QkFBOEIsbUJBQU8sQ0FBQyxzSEFBc0M7QUFDNUUsd0JBQXdCLG1CQUFPLENBQUMsMEdBQWdDO0FBQ2hFLCtCQUErQixtQkFBTyxDQUFDLHdIQUF1QztBQUM5RSxzQkFBc0IsbUJBQU8sQ0FBQyxzR0FBOEI7QUFDNUQsY0FBYyxtQkFBTyxDQUFDLDBHQUFnQztBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsQ0FBQztBQUNELGNBQWMsbUJBQU8sQ0FBQyxzRkFBc0I7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILENBQUM7QUFDRCxtQkFBbUIsbUJBQU8sQ0FBQyxvR0FBNkI7QUFDeEQsK0JBQStCLG1CQUFPLENBQUMsNEhBQXlDO0FBQ2hGLGVBQWUsbUJBQU8sQ0FBQyw0RkFBeUI7QUFDaEQscUJBQXFCLG1CQUFPLENBQUMsd0dBQStCO0FBQzVELG9CQUFvQixtQkFBTyxDQUFDLHNHQUE4QjtBQUMxRCxvQkFBb0IsbUJBQU8sQ0FBQyxzR0FBOEI7QUFDMUQsa0JBQWtCLG1CQUFPLENBQUMsa0dBQTRCO0FBQ3RELG1CQUFtQixtQkFBTyxDQUFDLG9HQUE2QjtBQUN4RCxtQkFBbUIsbUJBQU8sQ0FBQyxvR0FBNkI7QUFDeEQsY0FBYyxtQkFBTyxDQUFDLDBGQUF3QjtBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsQ0FBQztBQUNELGdDQUFnQyxtQkFBTyxDQUFDLG9JQUE2QztBQUNyRixnQkFBZ0IsbUJBQU8sQ0FBQyxvR0FBNkI7QUFDckQsaUNBQWlDLG1CQUFPLENBQUMsc0lBQThDO0FBQ3ZGLHdCQUF3QixtQkFBTyxDQUFDLG9IQUFxQztBQUNyRSw0QkFBNEIsbUJBQU8sQ0FBQyw0SEFBeUM7QUFDN0UsNEJBQTRCLG1CQUFPLENBQUMsc0lBQThDO0FBQ2xGLGdDQUFnQyxtQkFBTyxDQUFDLDhIQUEwQztBQUNsRiw2QkFBNkIsbUJBQU8sQ0FBQyx3SEFBdUM7QUFDNUUsa0NBQWtDLG1CQUFPLENBQUMsa0lBQTRDO0FBQ3RGLHVCQUF1QixtQkFBTyxDQUFDLDRHQUFpQztBQUNoRSxnQkFBZ0IsbUJBQU8sQ0FBQywwRkFBd0I7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILENBQUM7QUFDRCxvQkFBb0IsbUJBQU8sQ0FBQyxrR0FBNEI7QUFDeEQsb0JBQW9CLG1CQUFPLENBQUMsNEZBQXlCO0FBQ3JELFVBQVUsbUJBQU8sQ0FBQyxrRkFBb0I7QUFDdEMsaUJBQWlCLG1CQUFPLENBQUMsZ0dBQTJCO0FBQ3BELHFCQUFxQixtQkFBTyxDQUFDLHdHQUErQjtBQUM1RCxtQkFBbUIsbUJBQU8sQ0FBQyxvR0FBNkI7QUFDeEQsYUFBYSxtQkFBTyxDQUFDLHdGQUF1QjtBQUM1QyxjQUFjLG1CQUFPLENBQUMsMEZBQXdCO0FBQzlDLHlCQUF5QixtQkFBTyxDQUFDLGdIQUFtQztBQUNwRSx5QkFBeUIsbUJBQU8sQ0FBQyxnSEFBbUM7QUFDcEUsb0JBQW9CLG1CQUFPLENBQUMsc0dBQThCO0FBQzFELGVBQWUsbUJBQU8sQ0FBQyw0RkFBeUI7QUFDaEQsMEJBQTBCLG1CQUFPLENBQUMsa0hBQW9DO0FBQ3RFLGNBQWMsbUJBQU8sQ0FBQywwRkFBd0I7QUFDOUMsNEJBQTRCLG1CQUFPLENBQUMsc0hBQXNDO0FBQzFFLHlCQUF5QixtQkFBTyxDQUFDLGdIQUFtQztBQUNwRSxhQUFhLG1CQUFPLENBQUMsd0ZBQXVCO0FBQzVDLHNCQUFzQixtQkFBTyxDQUFDLDBHQUFnQztBQUM5RCxnQkFBZ0IsbUJBQU8sQ0FBQyw4RkFBMEI7QUFDbEQsa0NBQWtDLG1CQUFPLENBQUMsa0lBQTRDO0FBQ3RGLGNBQWMsbUJBQU8sQ0FBQyw0R0FBaUM7QUFDdkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILENBQUM7QUFDRCwwQkFBMEIsbUJBQU8sQ0FBQyx3R0FBK0I7QUFDakUsNEJBQTRCLG1CQUFPLENBQUMsc0hBQXNDO0FBQzFFLGNBQWMsYUFBYTtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QjtBQUM1QjtBQUNBO0FBQ0E7O0FBRUEiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9yZXBvLXZpc3VhbGl6ZXIvLi9ub2RlX21vZHVsZXMvQGJhYmVsL3R5cGVzL2xpYi9pbmRleC5qcz9mZTYxIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xudmFyIF9leHBvcnROYW1lcyA9IHtcbiAgcmVhY3Q6IHRydWUsXG4gIGFzc2VydE5vZGU6IHRydWUsXG4gIGNyZWF0ZVR5cGVBbm5vdGF0aW9uQmFzZWRPblR5cGVvZjogdHJ1ZSxcbiAgY3JlYXRlVW5pb25UeXBlQW5ub3RhdGlvbjogdHJ1ZSxcbiAgY3JlYXRlRmxvd1VuaW9uVHlwZTogdHJ1ZSxcbiAgY3JlYXRlVFNVbmlvblR5cGU6IHRydWUsXG4gIGNsb25lTm9kZTogdHJ1ZSxcbiAgY2xvbmU6IHRydWUsXG4gIGNsb25lRGVlcDogdHJ1ZSxcbiAgY2xvbmVEZWVwV2l0aG91dExvYzogdHJ1ZSxcbiAgY2xvbmVXaXRob3V0TG9jOiB0cnVlLFxuICBhZGRDb21tZW50OiB0cnVlLFxuICBhZGRDb21tZW50czogdHJ1ZSxcbiAgaW5oZXJpdElubmVyQ29tbWVudHM6IHRydWUsXG4gIGluaGVyaXRMZWFkaW5nQ29tbWVudHM6IHRydWUsXG4gIGluaGVyaXRzQ29tbWVudHM6IHRydWUsXG4gIGluaGVyaXRUcmFpbGluZ0NvbW1lbnRzOiB0cnVlLFxuICByZW1vdmVDb21tZW50czogdHJ1ZSxcbiAgZW5zdXJlQmxvY2s6IHRydWUsXG4gIHRvQmluZGluZ0lkZW50aWZpZXJOYW1lOiB0cnVlLFxuICB0b0Jsb2NrOiB0cnVlLFxuICB0b0NvbXB1dGVkS2V5OiB0cnVlLFxuICB0b0V4cHJlc3Npb246IHRydWUsXG4gIHRvSWRlbnRpZmllcjogdHJ1ZSxcbiAgdG9LZXlBbGlhczogdHJ1ZSxcbiAgdG9TdGF0ZW1lbnQ6IHRydWUsXG4gIHZhbHVlVG9Ob2RlOiB0cnVlLFxuICBhcHBlbmRUb01lbWJlckV4cHJlc3Npb246IHRydWUsXG4gIGluaGVyaXRzOiB0cnVlLFxuICBwcmVwZW5kVG9NZW1iZXJFeHByZXNzaW9uOiB0cnVlLFxuICByZW1vdmVQcm9wZXJ0aWVzOiB0cnVlLFxuICByZW1vdmVQcm9wZXJ0aWVzRGVlcDogdHJ1ZSxcbiAgcmVtb3ZlVHlwZUR1cGxpY2F0ZXM6IHRydWUsXG4gIGdldEFzc2lnbm1lbnRJZGVudGlmaWVyczogdHJ1ZSxcbiAgZ2V0QmluZGluZ0lkZW50aWZpZXJzOiB0cnVlLFxuICBnZXRPdXRlckJpbmRpbmdJZGVudGlmaWVyczogdHJ1ZSxcbiAgZ2V0RnVuY3Rpb25OYW1lOiB0cnVlLFxuICB0cmF2ZXJzZTogdHJ1ZSxcbiAgdHJhdmVyc2VGYXN0OiB0cnVlLFxuICBzaGFsbG93RXF1YWw6IHRydWUsXG4gIGlzOiB0cnVlLFxuICBpc0JpbmRpbmc6IHRydWUsXG4gIGlzQmxvY2tTY29wZWQ6IHRydWUsXG4gIGlzSW1tdXRhYmxlOiB0cnVlLFxuICBpc0xldDogdHJ1ZSxcbiAgaXNOb2RlOiB0cnVlLFxuICBpc05vZGVzRXF1aXZhbGVudDogdHJ1ZSxcbiAgaXNQbGFjZWhvbGRlclR5cGU6IHRydWUsXG4gIGlzUmVmZXJlbmNlZDogdHJ1ZSxcbiAgaXNTY29wZTogdHJ1ZSxcbiAgaXNTcGVjaWZpZXJEZWZhdWx0OiB0cnVlLFxuICBpc1R5cGU6IHRydWUsXG4gIGlzVmFsaWRFUzNJZGVudGlmaWVyOiB0cnVlLFxuICBpc1ZhbGlkSWRlbnRpZmllcjogdHJ1ZSxcbiAgaXNWYXI6IHRydWUsXG4gIG1hdGNoZXNQYXR0ZXJuOiB0cnVlLFxuICB2YWxpZGF0ZTogdHJ1ZSxcbiAgYnVpbGRNYXRjaE1lbWJlckV4cHJlc3Npb246IHRydWUsXG4gIF9faW50ZXJuYWxfX2RlcHJlY2F0aW9uV2FybmluZzogdHJ1ZVxufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9faW50ZXJuYWxfX2RlcHJlY2F0aW9uV2FybmluZ1wiLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBfZGVwcmVjYXRpb25XYXJuaW5nLmRlZmF1bHQ7XG4gIH1cbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiYWRkQ29tbWVudFwiLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBfYWRkQ29tbWVudC5kZWZhdWx0O1xuICB9XG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImFkZENvbW1lbnRzXCIsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIF9hZGRDb21tZW50cy5kZWZhdWx0O1xuICB9XG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImFwcGVuZFRvTWVtYmVyRXhwcmVzc2lvblwiLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBfYXBwZW5kVG9NZW1iZXJFeHByZXNzaW9uLmRlZmF1bHQ7XG4gIH1cbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiYXNzZXJ0Tm9kZVwiLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBfYXNzZXJ0Tm9kZS5kZWZhdWx0O1xuICB9XG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImJ1aWxkTWF0Y2hNZW1iZXJFeHByZXNzaW9uXCIsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIF9idWlsZE1hdGNoTWVtYmVyRXhwcmVzc2lvbi5kZWZhdWx0O1xuICB9XG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImNsb25lXCIsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIF9jbG9uZS5kZWZhdWx0O1xuICB9XG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImNsb25lRGVlcFwiLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBfY2xvbmVEZWVwLmRlZmF1bHQ7XG4gIH1cbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiY2xvbmVEZWVwV2l0aG91dExvY1wiLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBfY2xvbmVEZWVwV2l0aG91dExvYy5kZWZhdWx0O1xuICB9XG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImNsb25lTm9kZVwiLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBfY2xvbmVOb2RlLmRlZmF1bHQ7XG4gIH1cbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiY2xvbmVXaXRob3V0TG9jXCIsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIF9jbG9uZVdpdGhvdXRMb2MuZGVmYXVsdDtcbiAgfVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJjcmVhdGVGbG93VW5pb25UeXBlXCIsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIF9jcmVhdGVGbG93VW5pb25UeXBlLmRlZmF1bHQ7XG4gIH1cbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiY3JlYXRlVFNVbmlvblR5cGVcIiwge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gX2NyZWF0ZVRTVW5pb25UeXBlLmRlZmF1bHQ7XG4gIH1cbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiY3JlYXRlVHlwZUFubm90YXRpb25CYXNlZE9uVHlwZW9mXCIsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIF9jcmVhdGVUeXBlQW5ub3RhdGlvbkJhc2VkT25UeXBlb2YuZGVmYXVsdDtcbiAgfVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJjcmVhdGVVbmlvblR5cGVBbm5vdGF0aW9uXCIsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIF9jcmVhdGVGbG93VW5pb25UeXBlLmRlZmF1bHQ7XG4gIH1cbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiZW5zdXJlQmxvY2tcIiwge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gX2Vuc3VyZUJsb2NrLmRlZmF1bHQ7XG4gIH1cbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiZ2V0QXNzaWdubWVudElkZW50aWZpZXJzXCIsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIF9nZXRBc3NpZ25tZW50SWRlbnRpZmllcnMuZGVmYXVsdDtcbiAgfVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJnZXRCaW5kaW5nSWRlbnRpZmllcnNcIiwge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gX2dldEJpbmRpbmdJZGVudGlmaWVycy5kZWZhdWx0O1xuICB9XG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImdldEZ1bmN0aW9uTmFtZVwiLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBfZ2V0RnVuY3Rpb25OYW1lLmRlZmF1bHQ7XG4gIH1cbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiZ2V0T3V0ZXJCaW5kaW5nSWRlbnRpZmllcnNcIiwge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gX2dldE91dGVyQmluZGluZ0lkZW50aWZpZXJzLmRlZmF1bHQ7XG4gIH1cbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiaW5oZXJpdElubmVyQ29tbWVudHNcIiwge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gX2luaGVyaXRJbm5lckNvbW1lbnRzLmRlZmF1bHQ7XG4gIH1cbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiaW5oZXJpdExlYWRpbmdDb21tZW50c1wiLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBfaW5oZXJpdExlYWRpbmdDb21tZW50cy5kZWZhdWx0O1xuICB9XG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImluaGVyaXRUcmFpbGluZ0NvbW1lbnRzXCIsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIF9pbmhlcml0VHJhaWxpbmdDb21tZW50cy5kZWZhdWx0O1xuICB9XG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImluaGVyaXRzXCIsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIF9pbmhlcml0cy5kZWZhdWx0O1xuICB9XG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImluaGVyaXRzQ29tbWVudHNcIiwge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gX2luaGVyaXRzQ29tbWVudHMuZGVmYXVsdDtcbiAgfVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJpc1wiLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBfaXMuZGVmYXVsdDtcbiAgfVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJpc0JpbmRpbmdcIiwge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gX2lzQmluZGluZy5kZWZhdWx0O1xuICB9XG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImlzQmxvY2tTY29wZWRcIiwge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gX2lzQmxvY2tTY29wZWQuZGVmYXVsdDtcbiAgfVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJpc0ltbXV0YWJsZVwiLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBfaXNJbW11dGFibGUuZGVmYXVsdDtcbiAgfVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJpc0xldFwiLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBfaXNMZXQuZGVmYXVsdDtcbiAgfVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJpc05vZGVcIiwge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gX2lzTm9kZS5kZWZhdWx0O1xuICB9XG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImlzTm9kZXNFcXVpdmFsZW50XCIsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIF9pc05vZGVzRXF1aXZhbGVudC5kZWZhdWx0O1xuICB9XG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImlzUGxhY2Vob2xkZXJUeXBlXCIsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIF9pc1BsYWNlaG9sZGVyVHlwZS5kZWZhdWx0O1xuICB9XG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImlzUmVmZXJlbmNlZFwiLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBfaXNSZWZlcmVuY2VkLmRlZmF1bHQ7XG4gIH1cbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiaXNTY29wZVwiLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBfaXNTY29wZS5kZWZhdWx0O1xuICB9XG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImlzU3BlY2lmaWVyRGVmYXVsdFwiLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBfaXNTcGVjaWZpZXJEZWZhdWx0LmRlZmF1bHQ7XG4gIH1cbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiaXNUeXBlXCIsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIF9pc1R5cGUuZGVmYXVsdDtcbiAgfVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJpc1ZhbGlkRVMzSWRlbnRpZmllclwiLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBfaXNWYWxpZEVTM0lkZW50aWZpZXIuZGVmYXVsdDtcbiAgfVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJpc1ZhbGlkSWRlbnRpZmllclwiLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBfaXNWYWxpZElkZW50aWZpZXIuZGVmYXVsdDtcbiAgfVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJpc1ZhclwiLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBfaXNWYXIuZGVmYXVsdDtcbiAgfVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJtYXRjaGVzUGF0dGVyblwiLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBfbWF0Y2hlc1BhdHRlcm4uZGVmYXVsdDtcbiAgfVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJwcmVwZW5kVG9NZW1iZXJFeHByZXNzaW9uXCIsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIF9wcmVwZW5kVG9NZW1iZXJFeHByZXNzaW9uLmRlZmF1bHQ7XG4gIH1cbn0pO1xuZXhwb3J0cy5yZWFjdCA9IHZvaWQgMDtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcInJlbW92ZUNvbW1lbnRzXCIsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIF9yZW1vdmVDb21tZW50cy5kZWZhdWx0O1xuICB9XG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcInJlbW92ZVByb3BlcnRpZXNcIiwge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gX3JlbW92ZVByb3BlcnRpZXMuZGVmYXVsdDtcbiAgfVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJyZW1vdmVQcm9wZXJ0aWVzRGVlcFwiLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBfcmVtb3ZlUHJvcGVydGllc0RlZXAuZGVmYXVsdDtcbiAgfVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJyZW1vdmVUeXBlRHVwbGljYXRlc1wiLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBfcmVtb3ZlVHlwZUR1cGxpY2F0ZXMuZGVmYXVsdDtcbiAgfVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJzaGFsbG93RXF1YWxcIiwge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gX3NoYWxsb3dFcXVhbC5kZWZhdWx0O1xuICB9XG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcInRvQmluZGluZ0lkZW50aWZpZXJOYW1lXCIsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIF90b0JpbmRpbmdJZGVudGlmaWVyTmFtZS5kZWZhdWx0O1xuICB9XG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcInRvQmxvY2tcIiwge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gX3RvQmxvY2suZGVmYXVsdDtcbiAgfVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJ0b0NvbXB1dGVkS2V5XCIsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIF90b0NvbXB1dGVkS2V5LmRlZmF1bHQ7XG4gIH1cbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwidG9FeHByZXNzaW9uXCIsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIF90b0V4cHJlc3Npb24uZGVmYXVsdDtcbiAgfVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJ0b0lkZW50aWZpZXJcIiwge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gX3RvSWRlbnRpZmllci5kZWZhdWx0O1xuICB9XG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcInRvS2V5QWxpYXNcIiwge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gX3RvS2V5QWxpYXMuZGVmYXVsdDtcbiAgfVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJ0b1N0YXRlbWVudFwiLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBfdG9TdGF0ZW1lbnQuZGVmYXVsdDtcbiAgfVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJ0cmF2ZXJzZVwiLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBfdHJhdmVyc2UuZGVmYXVsdDtcbiAgfVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJ0cmF2ZXJzZUZhc3RcIiwge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gX3RyYXZlcnNlRmFzdC5kZWZhdWx0O1xuICB9XG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcInZhbGlkYXRlXCIsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIF92YWxpZGF0ZS5kZWZhdWx0O1xuICB9XG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcInZhbHVlVG9Ob2RlXCIsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIF92YWx1ZVRvTm9kZS5kZWZhdWx0O1xuICB9XG59KTtcbnZhciBfaXNSZWFjdENvbXBvbmVudCA9IHJlcXVpcmUoXCIuL3ZhbGlkYXRvcnMvcmVhY3QvaXNSZWFjdENvbXBvbmVudC5qc1wiKTtcbnZhciBfaXNDb21wYXRUYWcgPSByZXF1aXJlKFwiLi92YWxpZGF0b3JzL3JlYWN0L2lzQ29tcGF0VGFnLmpzXCIpO1xudmFyIF9idWlsZENoaWxkcmVuID0gcmVxdWlyZShcIi4vYnVpbGRlcnMvcmVhY3QvYnVpbGRDaGlsZHJlbi5qc1wiKTtcbnZhciBfYXNzZXJ0Tm9kZSA9IHJlcXVpcmUoXCIuL2Fzc2VydHMvYXNzZXJ0Tm9kZS5qc1wiKTtcbnZhciBfaW5kZXggPSByZXF1aXJlKFwiLi9hc3NlcnRzL2dlbmVyYXRlZC9pbmRleC5qc1wiKTtcbk9iamVjdC5rZXlzKF9pbmRleCkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gIGlmIChrZXkgPT09IFwiZGVmYXVsdFwiIHx8IGtleSA9PT0gXCJfX2VzTW9kdWxlXCIpIHJldHVybjtcbiAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChfZXhwb3J0TmFtZXMsIGtleSkpIHJldHVybjtcbiAgaWYgKGtleSBpbiBleHBvcnRzICYmIGV4cG9ydHNba2V5XSA9PT0gX2luZGV4W2tleV0pIHJldHVybjtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIGtleSwge1xuICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gX2luZGV4W2tleV07XG4gICAgfVxuICB9KTtcbn0pO1xudmFyIF9jcmVhdGVUeXBlQW5ub3RhdGlvbkJhc2VkT25UeXBlb2YgPSByZXF1aXJlKFwiLi9idWlsZGVycy9mbG93L2NyZWF0ZVR5cGVBbm5vdGF0aW9uQmFzZWRPblR5cGVvZi5qc1wiKTtcbnZhciBfY3JlYXRlRmxvd1VuaW9uVHlwZSA9IHJlcXVpcmUoXCIuL2J1aWxkZXJzL2Zsb3cvY3JlYXRlRmxvd1VuaW9uVHlwZS5qc1wiKTtcbnZhciBfY3JlYXRlVFNVbmlvblR5cGUgPSByZXF1aXJlKFwiLi9idWlsZGVycy90eXBlc2NyaXB0L2NyZWF0ZVRTVW5pb25UeXBlLmpzXCIpO1xudmFyIF9wcm9kdWN0aW9ucyA9IHJlcXVpcmUoXCIuL2J1aWxkZXJzL3Byb2R1Y3Rpb25zLmpzXCIpO1xuT2JqZWN0LmtleXMoX3Byb2R1Y3Rpb25zKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgaWYgKGtleSA9PT0gXCJkZWZhdWx0XCIgfHwga2V5ID09PSBcIl9fZXNNb2R1bGVcIikgcmV0dXJuO1xuICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKF9leHBvcnROYW1lcywga2V5KSkgcmV0dXJuO1xuICBpZiAoa2V5IGluIGV4cG9ydHMgJiYgZXhwb3J0c1trZXldID09PSBfcHJvZHVjdGlvbnNba2V5XSkgcmV0dXJuO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywga2V5LCB7XG4gICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBfcHJvZHVjdGlvbnNba2V5XTtcbiAgICB9XG4gIH0pO1xufSk7XG52YXIgX2luZGV4MiA9IHJlcXVpcmUoXCIuL2J1aWxkZXJzL2dlbmVyYXRlZC9pbmRleC5qc1wiKTtcbk9iamVjdC5rZXlzKF9pbmRleDIpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICBpZiAoa2V5ID09PSBcImRlZmF1bHRcIiB8fCBrZXkgPT09IFwiX19lc01vZHVsZVwiKSByZXR1cm47XG4gIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoX2V4cG9ydE5hbWVzLCBrZXkpKSByZXR1cm47XG4gIGlmIChrZXkgaW4gZXhwb3J0cyAmJiBleHBvcnRzW2tleV0gPT09IF9pbmRleDJba2V5XSkgcmV0dXJuO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywga2V5LCB7XG4gICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBfaW5kZXgyW2tleV07XG4gICAgfVxuICB9KTtcbn0pO1xudmFyIF9jbG9uZU5vZGUgPSByZXF1aXJlKFwiLi9jbG9uZS9jbG9uZU5vZGUuanNcIik7XG52YXIgX2Nsb25lID0gcmVxdWlyZShcIi4vY2xvbmUvY2xvbmUuanNcIik7XG52YXIgX2Nsb25lRGVlcCA9IHJlcXVpcmUoXCIuL2Nsb25lL2Nsb25lRGVlcC5qc1wiKTtcbnZhciBfY2xvbmVEZWVwV2l0aG91dExvYyA9IHJlcXVpcmUoXCIuL2Nsb25lL2Nsb25lRGVlcFdpdGhvdXRMb2MuanNcIik7XG52YXIgX2Nsb25lV2l0aG91dExvYyA9IHJlcXVpcmUoXCIuL2Nsb25lL2Nsb25lV2l0aG91dExvYy5qc1wiKTtcbnZhciBfYWRkQ29tbWVudCA9IHJlcXVpcmUoXCIuL2NvbW1lbnRzL2FkZENvbW1lbnQuanNcIik7XG52YXIgX2FkZENvbW1lbnRzID0gcmVxdWlyZShcIi4vY29tbWVudHMvYWRkQ29tbWVudHMuanNcIik7XG52YXIgX2luaGVyaXRJbm5lckNvbW1lbnRzID0gcmVxdWlyZShcIi4vY29tbWVudHMvaW5oZXJpdElubmVyQ29tbWVudHMuanNcIik7XG52YXIgX2luaGVyaXRMZWFkaW5nQ29tbWVudHMgPSByZXF1aXJlKFwiLi9jb21tZW50cy9pbmhlcml0TGVhZGluZ0NvbW1lbnRzLmpzXCIpO1xudmFyIF9pbmhlcml0c0NvbW1lbnRzID0gcmVxdWlyZShcIi4vY29tbWVudHMvaW5oZXJpdHNDb21tZW50cy5qc1wiKTtcbnZhciBfaW5oZXJpdFRyYWlsaW5nQ29tbWVudHMgPSByZXF1aXJlKFwiLi9jb21tZW50cy9pbmhlcml0VHJhaWxpbmdDb21tZW50cy5qc1wiKTtcbnZhciBfcmVtb3ZlQ29tbWVudHMgPSByZXF1aXJlKFwiLi9jb21tZW50cy9yZW1vdmVDb21tZW50cy5qc1wiKTtcbnZhciBfaW5kZXgzID0gcmVxdWlyZShcIi4vY29uc3RhbnRzL2dlbmVyYXRlZC9pbmRleC5qc1wiKTtcbk9iamVjdC5rZXlzKF9pbmRleDMpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICBpZiAoa2V5ID09PSBcImRlZmF1bHRcIiB8fCBrZXkgPT09IFwiX19lc01vZHVsZVwiKSByZXR1cm47XG4gIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoX2V4cG9ydE5hbWVzLCBrZXkpKSByZXR1cm47XG4gIGlmIChrZXkgaW4gZXhwb3J0cyAmJiBleHBvcnRzW2tleV0gPT09IF9pbmRleDNba2V5XSkgcmV0dXJuO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywga2V5LCB7XG4gICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBfaW5kZXgzW2tleV07XG4gICAgfVxuICB9KTtcbn0pO1xudmFyIF9pbmRleDQgPSByZXF1aXJlKFwiLi9jb25zdGFudHMvaW5kZXguanNcIik7XG5PYmplY3Qua2V5cyhfaW5kZXg0KS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgaWYgKGtleSA9PT0gXCJkZWZhdWx0XCIgfHwga2V5ID09PSBcIl9fZXNNb2R1bGVcIikgcmV0dXJuO1xuICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKF9leHBvcnROYW1lcywga2V5KSkgcmV0dXJuO1xuICBpZiAoa2V5IGluIGV4cG9ydHMgJiYgZXhwb3J0c1trZXldID09PSBfaW5kZXg0W2tleV0pIHJldHVybjtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIGtleSwge1xuICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gX2luZGV4NFtrZXldO1xuICAgIH1cbiAgfSk7XG59KTtcbnZhciBfZW5zdXJlQmxvY2sgPSByZXF1aXJlKFwiLi9jb252ZXJ0ZXJzL2Vuc3VyZUJsb2NrLmpzXCIpO1xudmFyIF90b0JpbmRpbmdJZGVudGlmaWVyTmFtZSA9IHJlcXVpcmUoXCIuL2NvbnZlcnRlcnMvdG9CaW5kaW5nSWRlbnRpZmllck5hbWUuanNcIik7XG52YXIgX3RvQmxvY2sgPSByZXF1aXJlKFwiLi9jb252ZXJ0ZXJzL3RvQmxvY2suanNcIik7XG52YXIgX3RvQ29tcHV0ZWRLZXkgPSByZXF1aXJlKFwiLi9jb252ZXJ0ZXJzL3RvQ29tcHV0ZWRLZXkuanNcIik7XG52YXIgX3RvRXhwcmVzc2lvbiA9IHJlcXVpcmUoXCIuL2NvbnZlcnRlcnMvdG9FeHByZXNzaW9uLmpzXCIpO1xudmFyIF90b0lkZW50aWZpZXIgPSByZXF1aXJlKFwiLi9jb252ZXJ0ZXJzL3RvSWRlbnRpZmllci5qc1wiKTtcbnZhciBfdG9LZXlBbGlhcyA9IHJlcXVpcmUoXCIuL2NvbnZlcnRlcnMvdG9LZXlBbGlhcy5qc1wiKTtcbnZhciBfdG9TdGF0ZW1lbnQgPSByZXF1aXJlKFwiLi9jb252ZXJ0ZXJzL3RvU3RhdGVtZW50LmpzXCIpO1xudmFyIF92YWx1ZVRvTm9kZSA9IHJlcXVpcmUoXCIuL2NvbnZlcnRlcnMvdmFsdWVUb05vZGUuanNcIik7XG52YXIgX2luZGV4NSA9IHJlcXVpcmUoXCIuL2RlZmluaXRpb25zL2luZGV4LmpzXCIpO1xuT2JqZWN0LmtleXMoX2luZGV4NSkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gIGlmIChrZXkgPT09IFwiZGVmYXVsdFwiIHx8IGtleSA9PT0gXCJfX2VzTW9kdWxlXCIpIHJldHVybjtcbiAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChfZXhwb3J0TmFtZXMsIGtleSkpIHJldHVybjtcbiAgaWYgKGtleSBpbiBleHBvcnRzICYmIGV4cG9ydHNba2V5XSA9PT0gX2luZGV4NVtrZXldKSByZXR1cm47XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBrZXksIHtcbiAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIF9pbmRleDVba2V5XTtcbiAgICB9XG4gIH0pO1xufSk7XG52YXIgX2FwcGVuZFRvTWVtYmVyRXhwcmVzc2lvbiA9IHJlcXVpcmUoXCIuL21vZGlmaWNhdGlvbnMvYXBwZW5kVG9NZW1iZXJFeHByZXNzaW9uLmpzXCIpO1xudmFyIF9pbmhlcml0cyA9IHJlcXVpcmUoXCIuL21vZGlmaWNhdGlvbnMvaW5oZXJpdHMuanNcIik7XG52YXIgX3ByZXBlbmRUb01lbWJlckV4cHJlc3Npb24gPSByZXF1aXJlKFwiLi9tb2RpZmljYXRpb25zL3ByZXBlbmRUb01lbWJlckV4cHJlc3Npb24uanNcIik7XG52YXIgX3JlbW92ZVByb3BlcnRpZXMgPSByZXF1aXJlKFwiLi9tb2RpZmljYXRpb25zL3JlbW92ZVByb3BlcnRpZXMuanNcIik7XG52YXIgX3JlbW92ZVByb3BlcnRpZXNEZWVwID0gcmVxdWlyZShcIi4vbW9kaWZpY2F0aW9ucy9yZW1vdmVQcm9wZXJ0aWVzRGVlcC5qc1wiKTtcbnZhciBfcmVtb3ZlVHlwZUR1cGxpY2F0ZXMgPSByZXF1aXJlKFwiLi9tb2RpZmljYXRpb25zL2Zsb3cvcmVtb3ZlVHlwZUR1cGxpY2F0ZXMuanNcIik7XG52YXIgX2dldEFzc2lnbm1lbnRJZGVudGlmaWVycyA9IHJlcXVpcmUoXCIuL3JldHJpZXZlcnMvZ2V0QXNzaWdubWVudElkZW50aWZpZXJzLmpzXCIpO1xudmFyIF9nZXRCaW5kaW5nSWRlbnRpZmllcnMgPSByZXF1aXJlKFwiLi9yZXRyaWV2ZXJzL2dldEJpbmRpbmdJZGVudGlmaWVycy5qc1wiKTtcbnZhciBfZ2V0T3V0ZXJCaW5kaW5nSWRlbnRpZmllcnMgPSByZXF1aXJlKFwiLi9yZXRyaWV2ZXJzL2dldE91dGVyQmluZGluZ0lkZW50aWZpZXJzLmpzXCIpO1xudmFyIF9nZXRGdW5jdGlvbk5hbWUgPSByZXF1aXJlKFwiLi9yZXRyaWV2ZXJzL2dldEZ1bmN0aW9uTmFtZS5qc1wiKTtcbnZhciBfdHJhdmVyc2UgPSByZXF1aXJlKFwiLi90cmF2ZXJzZS90cmF2ZXJzZS5qc1wiKTtcbk9iamVjdC5rZXlzKF90cmF2ZXJzZSkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gIGlmIChrZXkgPT09IFwiZGVmYXVsdFwiIHx8IGtleSA9PT0gXCJfX2VzTW9kdWxlXCIpIHJldHVybjtcbiAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChfZXhwb3J0TmFtZXMsIGtleSkpIHJldHVybjtcbiAgaWYgKGtleSBpbiBleHBvcnRzICYmIGV4cG9ydHNba2V5XSA9PT0gX3RyYXZlcnNlW2tleV0pIHJldHVybjtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIGtleSwge1xuICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gX3RyYXZlcnNlW2tleV07XG4gICAgfVxuICB9KTtcbn0pO1xudmFyIF90cmF2ZXJzZUZhc3QgPSByZXF1aXJlKFwiLi90cmF2ZXJzZS90cmF2ZXJzZUZhc3QuanNcIik7XG52YXIgX3NoYWxsb3dFcXVhbCA9IHJlcXVpcmUoXCIuL3V0aWxzL3NoYWxsb3dFcXVhbC5qc1wiKTtcbnZhciBfaXMgPSByZXF1aXJlKFwiLi92YWxpZGF0b3JzL2lzLmpzXCIpO1xudmFyIF9pc0JpbmRpbmcgPSByZXF1aXJlKFwiLi92YWxpZGF0b3JzL2lzQmluZGluZy5qc1wiKTtcbnZhciBfaXNCbG9ja1Njb3BlZCA9IHJlcXVpcmUoXCIuL3ZhbGlkYXRvcnMvaXNCbG9ja1Njb3BlZC5qc1wiKTtcbnZhciBfaXNJbW11dGFibGUgPSByZXF1aXJlKFwiLi92YWxpZGF0b3JzL2lzSW1tdXRhYmxlLmpzXCIpO1xudmFyIF9pc0xldCA9IHJlcXVpcmUoXCIuL3ZhbGlkYXRvcnMvaXNMZXQuanNcIik7XG52YXIgX2lzTm9kZSA9IHJlcXVpcmUoXCIuL3ZhbGlkYXRvcnMvaXNOb2RlLmpzXCIpO1xudmFyIF9pc05vZGVzRXF1aXZhbGVudCA9IHJlcXVpcmUoXCIuL3ZhbGlkYXRvcnMvaXNOb2Rlc0VxdWl2YWxlbnQuanNcIik7XG52YXIgX2lzUGxhY2Vob2xkZXJUeXBlID0gcmVxdWlyZShcIi4vdmFsaWRhdG9ycy9pc1BsYWNlaG9sZGVyVHlwZS5qc1wiKTtcbnZhciBfaXNSZWZlcmVuY2VkID0gcmVxdWlyZShcIi4vdmFsaWRhdG9ycy9pc1JlZmVyZW5jZWQuanNcIik7XG52YXIgX2lzU2NvcGUgPSByZXF1aXJlKFwiLi92YWxpZGF0b3JzL2lzU2NvcGUuanNcIik7XG52YXIgX2lzU3BlY2lmaWVyRGVmYXVsdCA9IHJlcXVpcmUoXCIuL3ZhbGlkYXRvcnMvaXNTcGVjaWZpZXJEZWZhdWx0LmpzXCIpO1xudmFyIF9pc1R5cGUgPSByZXF1aXJlKFwiLi92YWxpZGF0b3JzL2lzVHlwZS5qc1wiKTtcbnZhciBfaXNWYWxpZEVTM0lkZW50aWZpZXIgPSByZXF1aXJlKFwiLi92YWxpZGF0b3JzL2lzVmFsaWRFUzNJZGVudGlmaWVyLmpzXCIpO1xudmFyIF9pc1ZhbGlkSWRlbnRpZmllciA9IHJlcXVpcmUoXCIuL3ZhbGlkYXRvcnMvaXNWYWxpZElkZW50aWZpZXIuanNcIik7XG52YXIgX2lzVmFyID0gcmVxdWlyZShcIi4vdmFsaWRhdG9ycy9pc1Zhci5qc1wiKTtcbnZhciBfbWF0Y2hlc1BhdHRlcm4gPSByZXF1aXJlKFwiLi92YWxpZGF0b3JzL21hdGNoZXNQYXR0ZXJuLmpzXCIpO1xudmFyIF92YWxpZGF0ZSA9IHJlcXVpcmUoXCIuL3ZhbGlkYXRvcnMvdmFsaWRhdGUuanNcIik7XG52YXIgX2J1aWxkTWF0Y2hNZW1iZXJFeHByZXNzaW9uID0gcmVxdWlyZShcIi4vdmFsaWRhdG9ycy9idWlsZE1hdGNoTWVtYmVyRXhwcmVzc2lvbi5qc1wiKTtcbnZhciBfaW5kZXg2ID0gcmVxdWlyZShcIi4vdmFsaWRhdG9ycy9nZW5lcmF0ZWQvaW5kZXguanNcIik7XG5PYmplY3Qua2V5cyhfaW5kZXg2KS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgaWYgKGtleSA9PT0gXCJkZWZhdWx0XCIgfHwga2V5ID09PSBcIl9fZXNNb2R1bGVcIikgcmV0dXJuO1xuICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKF9leHBvcnROYW1lcywga2V5KSkgcmV0dXJuO1xuICBpZiAoa2V5IGluIGV4cG9ydHMgJiYgZXhwb3J0c1trZXldID09PSBfaW5kZXg2W2tleV0pIHJldHVybjtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIGtleSwge1xuICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gX2luZGV4NltrZXldO1xuICAgIH1cbiAgfSk7XG59KTtcbnZhciBfZGVwcmVjYXRpb25XYXJuaW5nID0gcmVxdWlyZShcIi4vdXRpbHMvZGVwcmVjYXRpb25XYXJuaW5nLmpzXCIpO1xudmFyIF90b1NlcXVlbmNlRXhwcmVzc2lvbiA9IHJlcXVpcmUoXCIuL2NvbnZlcnRlcnMvdG9TZXF1ZW5jZUV4cHJlc3Npb24uanNcIik7XG5jb25zdCByZWFjdCA9IGV4cG9ydHMucmVhY3QgPSB7XG4gIGlzUmVhY3RDb21wb25lbnQ6IF9pc1JlYWN0Q29tcG9uZW50LmRlZmF1bHQsXG4gIGlzQ29tcGF0VGFnOiBfaXNDb21wYXRUYWcuZGVmYXVsdCxcbiAgYnVpbGRDaGlsZHJlbjogX2J1aWxkQ2hpbGRyZW4uZGVmYXVsdFxufTtcbmV4cG9ydHMudG9TZXF1ZW5jZUV4cHJlc3Npb24gPSBfdG9TZXF1ZW5jZUV4cHJlc3Npb24uZGVmYXVsdDtcbmlmIChwcm9jZXNzLmVudi5CQUJFTF9UWVBFU184X0JSRUFLSU5HKSB7XG4gIGNvbnNvbGUud2FybihcIkJBQkVMX1RZUEVTXzhfQlJFQUtJTkcgaXMgbm90IHN1cHBvcnRlZCBhbnltb3JlLiBVc2UgdGhlIGxhdGVzdCBCYWJlbCA4LjAuMCBwcmUtcmVsZWFzZSBpbnN0ZWFkIVwiKTtcbn1cblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@babel/types/lib/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@babel/types/lib/modifications/appendToMemberExpression.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/@babel/types/lib/modifications/appendToMemberExpression.js ***!
  \*********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports[\"default\"] = appendToMemberExpression;\nvar _index = __webpack_require__(/*! ../builders/generated/index.js */ \"(ssr)/./node_modules/@babel/types/lib/builders/generated/index.js\");\nfunction appendToMemberExpression(member, append, computed = false) {\n  member.object = (0, _index.memberExpression)(member.object, member.property, member.computed);\n  member.property = append;\n  member.computed = !!computed;\n  return member;\n}\n\n//# sourceMappingURL=appendToMemberExpression.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGJhYmVsL3R5cGVzL2xpYi9tb2RpZmljYXRpb25zL2FwcGVuZFRvTWVtYmVyRXhwcmVzc2lvbi5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYiw4Q0FBNkM7QUFDN0M7QUFDQSxDQUFDLEVBQUM7QUFDRixrQkFBZTtBQUNmLGFBQWEsbUJBQU8sQ0FBQyx5R0FBZ0M7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcmVwby12aXN1YWxpemVyLy4vbm9kZV9tb2R1bGVzL0BiYWJlbC90eXBlcy9saWIvbW9kaWZpY2F0aW9ucy9hcHBlbmRUb01lbWJlckV4cHJlc3Npb24uanM/ZDM4MyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuZGVmYXVsdCA9IGFwcGVuZFRvTWVtYmVyRXhwcmVzc2lvbjtcbnZhciBfaW5kZXggPSByZXF1aXJlKFwiLi4vYnVpbGRlcnMvZ2VuZXJhdGVkL2luZGV4LmpzXCIpO1xuZnVuY3Rpb24gYXBwZW5kVG9NZW1iZXJFeHByZXNzaW9uKG1lbWJlciwgYXBwZW5kLCBjb21wdXRlZCA9IGZhbHNlKSB7XG4gIG1lbWJlci5vYmplY3QgPSAoMCwgX2luZGV4Lm1lbWJlckV4cHJlc3Npb24pKG1lbWJlci5vYmplY3QsIG1lbWJlci5wcm9wZXJ0eSwgbWVtYmVyLmNvbXB1dGVkKTtcbiAgbWVtYmVyLnByb3BlcnR5ID0gYXBwZW5kO1xuICBtZW1iZXIuY29tcHV0ZWQgPSAhIWNvbXB1dGVkO1xuICByZXR1cm4gbWVtYmVyO1xufVxuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1hcHBlbmRUb01lbWJlckV4cHJlc3Npb24uanMubWFwXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@babel/types/lib/modifications/appendToMemberExpression.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@babel/types/lib/modifications/flow/removeTypeDuplicates.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/@babel/types/lib/modifications/flow/removeTypeDuplicates.js ***!
  \**********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports[\"default\"] = removeTypeDuplicates;\nvar _index = __webpack_require__(/*! ../../validators/generated/index.js */ \"(ssr)/./node_modules/@babel/types/lib/validators/generated/index.js\");\nfunction getQualifiedName(node) {\n  return (0, _index.isIdentifier)(node) ? node.name : `${node.id.name}.${getQualifiedName(node.qualification)}`;\n}\nfunction removeTypeDuplicates(nodesIn) {\n  const nodes = Array.from(nodesIn);\n  const generics = new Map();\n  const bases = new Map();\n  const typeGroups = new Set();\n  const types = [];\n  for (let i = 0; i < nodes.length; i++) {\n    const node = nodes[i];\n    if (!node) continue;\n    if (types.includes(node)) {\n      continue;\n    }\n    if ((0, _index.isAnyTypeAnnotation)(node)) {\n      return [node];\n    }\n    if ((0, _index.isFlowBaseAnnotation)(node)) {\n      bases.set(node.type, node);\n      continue;\n    }\n    if ((0, _index.isUnionTypeAnnotation)(node)) {\n      if (!typeGroups.has(node.types)) {\n        nodes.push(...node.types);\n        typeGroups.add(node.types);\n      }\n      continue;\n    }\n    if ((0, _index.isGenericTypeAnnotation)(node)) {\n      const name = getQualifiedName(node.id);\n      if (generics.has(name)) {\n        let existing = generics.get(name);\n        if (existing.typeParameters) {\n          if (node.typeParameters) {\n            existing.typeParameters.params.push(...node.typeParameters.params);\n            existing.typeParameters.params = removeTypeDuplicates(existing.typeParameters.params);\n          }\n        } else {\n          existing = node.typeParameters;\n        }\n      } else {\n        generics.set(name, node);\n      }\n      continue;\n    }\n    types.push(node);\n  }\n  for (const [, baseType] of bases) {\n    types.push(baseType);\n  }\n  for (const [, genericName] of generics) {\n    types.push(genericName);\n  }\n  return types;\n}\n\n//# sourceMappingURL=removeTypeDuplicates.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGJhYmVsL3R5cGVzL2xpYi9tb2RpZmljYXRpb25zL2Zsb3cvcmVtb3ZlVHlwZUR1cGxpY2F0ZXMuanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWIsOENBQTZDO0FBQzdDO0FBQ0EsQ0FBQyxFQUFDO0FBQ0Ysa0JBQWU7QUFDZixhQUFhLG1CQUFPLENBQUMsZ0hBQXFDO0FBQzFEO0FBQ0EseURBQXlELGFBQWEsR0FBRyxxQ0FBcUM7QUFDOUc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0Isa0JBQWtCO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSIsInNvdXJjZXMiOlsid2VicGFjazovL3JlcG8tdmlzdWFsaXplci8uL25vZGVfbW9kdWxlcy9AYmFiZWwvdHlwZXMvbGliL21vZGlmaWNhdGlvbnMvZmxvdy9yZW1vdmVUeXBlRHVwbGljYXRlcy5qcz83OTZkIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5kZWZhdWx0ID0gcmVtb3ZlVHlwZUR1cGxpY2F0ZXM7XG52YXIgX2luZGV4ID0gcmVxdWlyZShcIi4uLy4uL3ZhbGlkYXRvcnMvZ2VuZXJhdGVkL2luZGV4LmpzXCIpO1xuZnVuY3Rpb24gZ2V0UXVhbGlmaWVkTmFtZShub2RlKSB7XG4gIHJldHVybiAoMCwgX2luZGV4LmlzSWRlbnRpZmllcikobm9kZSkgPyBub2RlLm5hbWUgOiBgJHtub2RlLmlkLm5hbWV9LiR7Z2V0UXVhbGlmaWVkTmFtZShub2RlLnF1YWxpZmljYXRpb24pfWA7XG59XG5mdW5jdGlvbiByZW1vdmVUeXBlRHVwbGljYXRlcyhub2Rlc0luKSB7XG4gIGNvbnN0IG5vZGVzID0gQXJyYXkuZnJvbShub2Rlc0luKTtcbiAgY29uc3QgZ2VuZXJpY3MgPSBuZXcgTWFwKCk7XG4gIGNvbnN0IGJhc2VzID0gbmV3IE1hcCgpO1xuICBjb25zdCB0eXBlR3JvdXBzID0gbmV3IFNldCgpO1xuICBjb25zdCB0eXBlcyA9IFtdO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IG5vZGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgY29uc3Qgbm9kZSA9IG5vZGVzW2ldO1xuICAgIGlmICghbm9kZSkgY29udGludWU7XG4gICAgaWYgKHR5cGVzLmluY2x1ZGVzKG5vZGUpKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgaWYgKCgwLCBfaW5kZXguaXNBbnlUeXBlQW5ub3RhdGlvbikobm9kZSkpIHtcbiAgICAgIHJldHVybiBbbm9kZV07XG4gICAgfVxuICAgIGlmICgoMCwgX2luZGV4LmlzRmxvd0Jhc2VBbm5vdGF0aW9uKShub2RlKSkge1xuICAgICAgYmFzZXMuc2V0KG5vZGUudHlwZSwgbm9kZSk7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgaWYgKCgwLCBfaW5kZXguaXNVbmlvblR5cGVBbm5vdGF0aW9uKShub2RlKSkge1xuICAgICAgaWYgKCF0eXBlR3JvdXBzLmhhcyhub2RlLnR5cGVzKSkge1xuICAgICAgICBub2Rlcy5wdXNoKC4uLm5vZGUudHlwZXMpO1xuICAgICAgICB0eXBlR3JvdXBzLmFkZChub2RlLnR5cGVzKTtcbiAgICAgIH1cbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICBpZiAoKDAsIF9pbmRleC5pc0dlbmVyaWNUeXBlQW5ub3RhdGlvbikobm9kZSkpIHtcbiAgICAgIGNvbnN0IG5hbWUgPSBnZXRRdWFsaWZpZWROYW1lKG5vZGUuaWQpO1xuICAgICAgaWYgKGdlbmVyaWNzLmhhcyhuYW1lKSkge1xuICAgICAgICBsZXQgZXhpc3RpbmcgPSBnZW5lcmljcy5nZXQobmFtZSk7XG4gICAgICAgIGlmIChleGlzdGluZy50eXBlUGFyYW1ldGVycykge1xuICAgICAgICAgIGlmIChub2RlLnR5cGVQYXJhbWV0ZXJzKSB7XG4gICAgICAgICAgICBleGlzdGluZy50eXBlUGFyYW1ldGVycy5wYXJhbXMucHVzaCguLi5ub2RlLnR5cGVQYXJhbWV0ZXJzLnBhcmFtcyk7XG4gICAgICAgICAgICBleGlzdGluZy50eXBlUGFyYW1ldGVycy5wYXJhbXMgPSByZW1vdmVUeXBlRHVwbGljYXRlcyhleGlzdGluZy50eXBlUGFyYW1ldGVycy5wYXJhbXMpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBleGlzdGluZyA9IG5vZGUudHlwZVBhcmFtZXRlcnM7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGdlbmVyaWNzLnNldChuYW1lLCBub2RlKTtcbiAgICAgIH1cbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICB0eXBlcy5wdXNoKG5vZGUpO1xuICB9XG4gIGZvciAoY29uc3QgWywgYmFzZVR5cGVdIG9mIGJhc2VzKSB7XG4gICAgdHlwZXMucHVzaChiYXNlVHlwZSk7XG4gIH1cbiAgZm9yIChjb25zdCBbLCBnZW5lcmljTmFtZV0gb2YgZ2VuZXJpY3MpIHtcbiAgICB0eXBlcy5wdXNoKGdlbmVyaWNOYW1lKTtcbiAgfVxuICByZXR1cm4gdHlwZXM7XG59XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXJlbW92ZVR5cGVEdXBsaWNhdGVzLmpzLm1hcFxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@babel/types/lib/modifications/flow/removeTypeDuplicates.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@babel/types/lib/modifications/inherits.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@babel/types/lib/modifications/inherits.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports[\"default\"] = inherits;\nvar _index = __webpack_require__(/*! ../constants/index.js */ \"(ssr)/./node_modules/@babel/types/lib/constants/index.js\");\nvar _inheritsComments = __webpack_require__(/*! ../comments/inheritsComments.js */ \"(ssr)/./node_modules/@babel/types/lib/comments/inheritsComments.js\");\nfunction inherits(child, parent) {\n  if (!child || !parent) return child;\n  for (const key of _index.INHERIT_KEYS.optional) {\n    if (child[key] == null) {\n      child[key] = parent[key];\n    }\n  }\n  for (const key of Object.keys(parent)) {\n    if (key.startsWith(\"_\") && key !== \"__clone\") {\n      child[key] = parent[key];\n    }\n  }\n  for (const key of _index.INHERIT_KEYS.force) {\n    child[key] = parent[key];\n  }\n  (0, _inheritsComments.default)(child, parent);\n  return child;\n}\n\n//# sourceMappingURL=inherits.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGJhYmVsL3R5cGVzL2xpYi9tb2RpZmljYXRpb25zL2luaGVyaXRzLmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViLDhDQUE2QztBQUM3QztBQUNBLENBQUMsRUFBQztBQUNGLGtCQUFlO0FBQ2YsYUFBYSxtQkFBTyxDQUFDLHVGQUF1QjtBQUM1Qyx3QkFBd0IsbUJBQU8sQ0FBQywyR0FBaUM7QUFDakU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcmVwby12aXN1YWxpemVyLy4vbm9kZV9tb2R1bGVzL0BiYWJlbC90eXBlcy9saWIvbW9kaWZpY2F0aW9ucy9pbmhlcml0cy5qcz85ZDE1Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5kZWZhdWx0ID0gaW5oZXJpdHM7XG52YXIgX2luZGV4ID0gcmVxdWlyZShcIi4uL2NvbnN0YW50cy9pbmRleC5qc1wiKTtcbnZhciBfaW5oZXJpdHNDb21tZW50cyA9IHJlcXVpcmUoXCIuLi9jb21tZW50cy9pbmhlcml0c0NvbW1lbnRzLmpzXCIpO1xuZnVuY3Rpb24gaW5oZXJpdHMoY2hpbGQsIHBhcmVudCkge1xuICBpZiAoIWNoaWxkIHx8ICFwYXJlbnQpIHJldHVybiBjaGlsZDtcbiAgZm9yIChjb25zdCBrZXkgb2YgX2luZGV4LklOSEVSSVRfS0VZUy5vcHRpb25hbCkge1xuICAgIGlmIChjaGlsZFtrZXldID09IG51bGwpIHtcbiAgICAgIGNoaWxkW2tleV0gPSBwYXJlbnRba2V5XTtcbiAgICB9XG4gIH1cbiAgZm9yIChjb25zdCBrZXkgb2YgT2JqZWN0LmtleXMocGFyZW50KSkge1xuICAgIGlmIChrZXkuc3RhcnRzV2l0aChcIl9cIikgJiYga2V5ICE9PSBcIl9fY2xvbmVcIikge1xuICAgICAgY2hpbGRba2V5XSA9IHBhcmVudFtrZXldO1xuICAgIH1cbiAgfVxuICBmb3IgKGNvbnN0IGtleSBvZiBfaW5kZXguSU5IRVJJVF9LRVlTLmZvcmNlKSB7XG4gICAgY2hpbGRba2V5XSA9IHBhcmVudFtrZXldO1xuICB9XG4gICgwLCBfaW5oZXJpdHNDb21tZW50cy5kZWZhdWx0KShjaGlsZCwgcGFyZW50KTtcbiAgcmV0dXJuIGNoaWxkO1xufVxuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmhlcml0cy5qcy5tYXBcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@babel/types/lib/modifications/inherits.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@babel/types/lib/modifications/prependToMemberExpression.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/@babel/types/lib/modifications/prependToMemberExpression.js ***!
  \**********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports[\"default\"] = prependToMemberExpression;\nvar _index = __webpack_require__(/*! ../builders/generated/index.js */ \"(ssr)/./node_modules/@babel/types/lib/builders/generated/index.js\");\nvar _index2 = __webpack_require__(/*! ../index.js */ \"(ssr)/./node_modules/@babel/types/lib/index.js\");\nfunction prependToMemberExpression(member, prepend) {\n  if ((0, _index2.isSuper)(member.object)) {\n    throw new Error(\"Cannot prepend node to super property access (`super.foo`).\");\n  }\n  member.object = (0, _index.memberExpression)(prepend, member.object);\n  return member;\n}\n\n//# sourceMappingURL=prependToMemberExpression.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGJhYmVsL3R5cGVzL2xpYi9tb2RpZmljYXRpb25zL3ByZXBlbmRUb01lbWJlckV4cHJlc3Npb24uanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWIsOENBQTZDO0FBQzdDO0FBQ0EsQ0FBQyxFQUFDO0FBQ0Ysa0JBQWU7QUFDZixhQUFhLG1CQUFPLENBQUMseUdBQWdDO0FBQ3JELGNBQWMsbUJBQU8sQ0FBQyxtRUFBYTtBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSIsInNvdXJjZXMiOlsid2VicGFjazovL3JlcG8tdmlzdWFsaXplci8uL25vZGVfbW9kdWxlcy9AYmFiZWwvdHlwZXMvbGliL21vZGlmaWNhdGlvbnMvcHJlcGVuZFRvTWVtYmVyRXhwcmVzc2lvbi5qcz8yMzA0Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5kZWZhdWx0ID0gcHJlcGVuZFRvTWVtYmVyRXhwcmVzc2lvbjtcbnZhciBfaW5kZXggPSByZXF1aXJlKFwiLi4vYnVpbGRlcnMvZ2VuZXJhdGVkL2luZGV4LmpzXCIpO1xudmFyIF9pbmRleDIgPSByZXF1aXJlKFwiLi4vaW5kZXguanNcIik7XG5mdW5jdGlvbiBwcmVwZW5kVG9NZW1iZXJFeHByZXNzaW9uKG1lbWJlciwgcHJlcGVuZCkge1xuICBpZiAoKDAsIF9pbmRleDIuaXNTdXBlcikobWVtYmVyLm9iamVjdCkpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3QgcHJlcGVuZCBub2RlIHRvIHN1cGVyIHByb3BlcnR5IGFjY2VzcyAoYHN1cGVyLmZvb2ApLlwiKTtcbiAgfVxuICBtZW1iZXIub2JqZWN0ID0gKDAsIF9pbmRleC5tZW1iZXJFeHByZXNzaW9uKShwcmVwZW5kLCBtZW1iZXIub2JqZWN0KTtcbiAgcmV0dXJuIG1lbWJlcjtcbn1cblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cHJlcGVuZFRvTWVtYmVyRXhwcmVzc2lvbi5qcy5tYXBcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@babel/types/lib/modifications/prependToMemberExpression.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@babel/types/lib/modifications/removeProperties.js":
/*!*************************************************************************!*\
  !*** ./node_modules/@babel/types/lib/modifications/removeProperties.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports[\"default\"] = removeProperties;\nvar _index = __webpack_require__(/*! ../constants/index.js */ \"(ssr)/./node_modules/@babel/types/lib/constants/index.js\");\nconst CLEAR_KEYS = [\"tokens\", \"start\", \"end\", \"loc\", \"raw\", \"rawValue\"];\nconst CLEAR_KEYS_PLUS_COMMENTS = [..._index.COMMENT_KEYS, \"comments\", ...CLEAR_KEYS];\nfunction removeProperties(node, opts = {}) {\n  const map = opts.preserveComments ? CLEAR_KEYS : CLEAR_KEYS_PLUS_COMMENTS;\n  for (const key of map) {\n    if (node[key] != null) node[key] = undefined;\n  }\n  for (const key of Object.keys(node)) {\n    if (key.startsWith(\"_\") && node[key] != null) node[key] = undefined;\n  }\n  const symbols = Object.getOwnPropertySymbols(node);\n  for (const sym of symbols) {\n    node[sym] = null;\n  }\n}\n\n//# sourceMappingURL=removeProperties.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGJhYmVsL3R5cGVzL2xpYi9tb2RpZmljYXRpb25zL3JlbW92ZVByb3BlcnRpZXMuanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWIsOENBQTZDO0FBQzdDO0FBQ0EsQ0FBQyxFQUFDO0FBQ0Ysa0JBQWU7QUFDZixhQUFhLG1CQUFPLENBQUMsdUZBQXVCO0FBQzVDO0FBQ0E7QUFDQSx5Q0FBeUM7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcmVwby12aXN1YWxpemVyLy4vbm9kZV9tb2R1bGVzL0BiYWJlbC90eXBlcy9saWIvbW9kaWZpY2F0aW9ucy9yZW1vdmVQcm9wZXJ0aWVzLmpzPzAwYTQiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLmRlZmF1bHQgPSByZW1vdmVQcm9wZXJ0aWVzO1xudmFyIF9pbmRleCA9IHJlcXVpcmUoXCIuLi9jb25zdGFudHMvaW5kZXguanNcIik7XG5jb25zdCBDTEVBUl9LRVlTID0gW1widG9rZW5zXCIsIFwic3RhcnRcIiwgXCJlbmRcIiwgXCJsb2NcIiwgXCJyYXdcIiwgXCJyYXdWYWx1ZVwiXTtcbmNvbnN0IENMRUFSX0tFWVNfUExVU19DT01NRU5UUyA9IFsuLi5faW5kZXguQ09NTUVOVF9LRVlTLCBcImNvbW1lbnRzXCIsIC4uLkNMRUFSX0tFWVNdO1xuZnVuY3Rpb24gcmVtb3ZlUHJvcGVydGllcyhub2RlLCBvcHRzID0ge30pIHtcbiAgY29uc3QgbWFwID0gb3B0cy5wcmVzZXJ2ZUNvbW1lbnRzID8gQ0xFQVJfS0VZUyA6IENMRUFSX0tFWVNfUExVU19DT01NRU5UUztcbiAgZm9yIChjb25zdCBrZXkgb2YgbWFwKSB7XG4gICAgaWYgKG5vZGVba2V5XSAhPSBudWxsKSBub2RlW2tleV0gPSB1bmRlZmluZWQ7XG4gIH1cbiAgZm9yIChjb25zdCBrZXkgb2YgT2JqZWN0LmtleXMobm9kZSkpIHtcbiAgICBpZiAoa2V5LnN0YXJ0c1dpdGgoXCJfXCIpICYmIG5vZGVba2V5XSAhPSBudWxsKSBub2RlW2tleV0gPSB1bmRlZmluZWQ7XG4gIH1cbiAgY29uc3Qgc3ltYm9scyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMobm9kZSk7XG4gIGZvciAoY29uc3Qgc3ltIG9mIHN5bWJvbHMpIHtcbiAgICBub2RlW3N5bV0gPSBudWxsO1xuICB9XG59XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXJlbW92ZVByb3BlcnRpZXMuanMubWFwXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@babel/types/lib/modifications/removeProperties.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@babel/types/lib/modifications/removePropertiesDeep.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/@babel/types/lib/modifications/removePropertiesDeep.js ***!
  \*****************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports[\"default\"] = removePropertiesDeep;\nvar _traverseFast = __webpack_require__(/*! ../traverse/traverseFast.js */ \"(ssr)/./node_modules/@babel/types/lib/traverse/traverseFast.js\");\nvar _removeProperties = __webpack_require__(/*! ./removeProperties.js */ \"(ssr)/./node_modules/@babel/types/lib/modifications/removeProperties.js\");\nfunction removePropertiesDeep(tree, opts) {\n  (0, _traverseFast.default)(tree, _removeProperties.default, opts);\n  return tree;\n}\n\n//# sourceMappingURL=removePropertiesDeep.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGJhYmVsL3R5cGVzL2xpYi9tb2RpZmljYXRpb25zL3JlbW92ZVByb3BlcnRpZXNEZWVwLmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViLDhDQUE2QztBQUM3QztBQUNBLENBQUMsRUFBQztBQUNGLGtCQUFlO0FBQ2Ysb0JBQW9CLG1CQUFPLENBQUMsbUdBQTZCO0FBQ3pELHdCQUF3QixtQkFBTyxDQUFDLHNHQUF1QjtBQUN2RDtBQUNBO0FBQ0E7QUFDQTs7QUFFQSIsInNvdXJjZXMiOlsid2VicGFjazovL3JlcG8tdmlzdWFsaXplci8uL25vZGVfbW9kdWxlcy9AYmFiZWwvdHlwZXMvbGliL21vZGlmaWNhdGlvbnMvcmVtb3ZlUHJvcGVydGllc0RlZXAuanM/YjNmNSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuZGVmYXVsdCA9IHJlbW92ZVByb3BlcnRpZXNEZWVwO1xudmFyIF90cmF2ZXJzZUZhc3QgPSByZXF1aXJlKFwiLi4vdHJhdmVyc2UvdHJhdmVyc2VGYXN0LmpzXCIpO1xudmFyIF9yZW1vdmVQcm9wZXJ0aWVzID0gcmVxdWlyZShcIi4vcmVtb3ZlUHJvcGVydGllcy5qc1wiKTtcbmZ1bmN0aW9uIHJlbW92ZVByb3BlcnRpZXNEZWVwKHRyZWUsIG9wdHMpIHtcbiAgKDAsIF90cmF2ZXJzZUZhc3QuZGVmYXVsdCkodHJlZSwgX3JlbW92ZVByb3BlcnRpZXMuZGVmYXVsdCwgb3B0cyk7XG4gIHJldHVybiB0cmVlO1xufVxuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1yZW1vdmVQcm9wZXJ0aWVzRGVlcC5qcy5tYXBcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@babel/types/lib/modifications/removePropertiesDeep.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@babel/types/lib/modifications/typescript/removeTypeDuplicates.js":
/*!****************************************************************************************!*\
  !*** ./node_modules/@babel/types/lib/modifications/typescript/removeTypeDuplicates.js ***!
  \****************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports[\"default\"] = removeTypeDuplicates;\nvar _index = __webpack_require__(/*! ../../validators/generated/index.js */ \"(ssr)/./node_modules/@babel/types/lib/validators/generated/index.js\");\nfunction getQualifiedName(node) {\n  return (0, _index.isIdentifier)(node) ? node.name : (0, _index.isThisExpression)(node) ? \"this\" : `${node.right.name}.${getQualifiedName(node.left)}`;\n}\nfunction removeTypeDuplicates(nodesIn) {\n  const nodes = Array.from(nodesIn);\n  const generics = new Map();\n  const bases = new Map();\n  const typeGroups = new Set();\n  const types = [];\n  for (let i = 0; i < nodes.length; i++) {\n    const node = nodes[i];\n    if (!node) continue;\n    if (types.includes(node)) {\n      continue;\n    }\n    if ((0, _index.isTSAnyKeyword)(node)) {\n      return [node];\n    }\n    if ((0, _index.isTSBaseType)(node)) {\n      bases.set(node.type, node);\n      continue;\n    }\n    if ((0, _index.isTSUnionType)(node)) {\n      if (!typeGroups.has(node.types)) {\n        nodes.push(...node.types);\n        typeGroups.add(node.types);\n      }\n      continue;\n    }\n    const typeArgumentsKey = \"typeParameters\";\n    if ((0, _index.isTSTypeReference)(node) && node[typeArgumentsKey]) {\n      const typeArguments = node[typeArgumentsKey];\n      const name = getQualifiedName(node.typeName);\n      if (generics.has(name)) {\n        let existing = generics.get(name);\n        const existingTypeArguments = existing[typeArgumentsKey];\n        if (existingTypeArguments) {\n          existingTypeArguments.params.push(...typeArguments.params);\n          existingTypeArguments.params = removeTypeDuplicates(existingTypeArguments.params);\n        } else {\n          existing = typeArguments;\n        }\n      } else {\n        generics.set(name, node);\n      }\n      continue;\n    }\n    types.push(node);\n  }\n  for (const [, baseType] of bases) {\n    types.push(baseType);\n  }\n  for (const [, genericName] of generics) {\n    types.push(genericName);\n  }\n  return types;\n}\n\n//# sourceMappingURL=removeTypeDuplicates.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGJhYmVsL3R5cGVzL2xpYi9tb2RpZmljYXRpb25zL3R5cGVzY3JpcHQvcmVtb3ZlVHlwZUR1cGxpY2F0ZXMuanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWIsOENBQTZDO0FBQzdDO0FBQ0EsQ0FBQyxFQUFDO0FBQ0Ysa0JBQWU7QUFDZixhQUFhLG1CQUFPLENBQUMsZ0hBQXFDO0FBQzFEO0FBQ0EsdUdBQXVHLGdCQUFnQixHQUFHLDRCQUE0QjtBQUN0SjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixrQkFBa0I7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9yZXBvLXZpc3VhbGl6ZXIvLi9ub2RlX21vZHVsZXMvQGJhYmVsL3R5cGVzL2xpYi9tb2RpZmljYXRpb25zL3R5cGVzY3JpcHQvcmVtb3ZlVHlwZUR1cGxpY2F0ZXMuanM/Nzc1NyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuZGVmYXVsdCA9IHJlbW92ZVR5cGVEdXBsaWNhdGVzO1xudmFyIF9pbmRleCA9IHJlcXVpcmUoXCIuLi8uLi92YWxpZGF0b3JzL2dlbmVyYXRlZC9pbmRleC5qc1wiKTtcbmZ1bmN0aW9uIGdldFF1YWxpZmllZE5hbWUobm9kZSkge1xuICByZXR1cm4gKDAsIF9pbmRleC5pc0lkZW50aWZpZXIpKG5vZGUpID8gbm9kZS5uYW1lIDogKDAsIF9pbmRleC5pc1RoaXNFeHByZXNzaW9uKShub2RlKSA/IFwidGhpc1wiIDogYCR7bm9kZS5yaWdodC5uYW1lfS4ke2dldFF1YWxpZmllZE5hbWUobm9kZS5sZWZ0KX1gO1xufVxuZnVuY3Rpb24gcmVtb3ZlVHlwZUR1cGxpY2F0ZXMobm9kZXNJbikge1xuICBjb25zdCBub2RlcyA9IEFycmF5LmZyb20obm9kZXNJbik7XG4gIGNvbnN0IGdlbmVyaWNzID0gbmV3IE1hcCgpO1xuICBjb25zdCBiYXNlcyA9IG5ldyBNYXAoKTtcbiAgY29uc3QgdHlwZUdyb3VwcyA9IG5ldyBTZXQoKTtcbiAgY29uc3QgdHlwZXMgPSBbXTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBub2Rlcy5sZW5ndGg7IGkrKykge1xuICAgIGNvbnN0IG5vZGUgPSBub2Rlc1tpXTtcbiAgICBpZiAoIW5vZGUpIGNvbnRpbnVlO1xuICAgIGlmICh0eXBlcy5pbmNsdWRlcyhub2RlKSkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIGlmICgoMCwgX2luZGV4LmlzVFNBbnlLZXl3b3JkKShub2RlKSkge1xuICAgICAgcmV0dXJuIFtub2RlXTtcbiAgICB9XG4gICAgaWYgKCgwLCBfaW5kZXguaXNUU0Jhc2VUeXBlKShub2RlKSkge1xuICAgICAgYmFzZXMuc2V0KG5vZGUudHlwZSwgbm9kZSk7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgaWYgKCgwLCBfaW5kZXguaXNUU1VuaW9uVHlwZSkobm9kZSkpIHtcbiAgICAgIGlmICghdHlwZUdyb3Vwcy5oYXMobm9kZS50eXBlcykpIHtcbiAgICAgICAgbm9kZXMucHVzaCguLi5ub2RlLnR5cGVzKTtcbiAgICAgICAgdHlwZUdyb3Vwcy5hZGQobm9kZS50eXBlcyk7XG4gICAgICB9XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgY29uc3QgdHlwZUFyZ3VtZW50c0tleSA9IFwidHlwZVBhcmFtZXRlcnNcIjtcbiAgICBpZiAoKDAsIF9pbmRleC5pc1RTVHlwZVJlZmVyZW5jZSkobm9kZSkgJiYgbm9kZVt0eXBlQXJndW1lbnRzS2V5XSkge1xuICAgICAgY29uc3QgdHlwZUFyZ3VtZW50cyA9IG5vZGVbdHlwZUFyZ3VtZW50c0tleV07XG4gICAgICBjb25zdCBuYW1lID0gZ2V0UXVhbGlmaWVkTmFtZShub2RlLnR5cGVOYW1lKTtcbiAgICAgIGlmIChnZW5lcmljcy5oYXMobmFtZSkpIHtcbiAgICAgICAgbGV0IGV4aXN0aW5nID0gZ2VuZXJpY3MuZ2V0KG5hbWUpO1xuICAgICAgICBjb25zdCBleGlzdGluZ1R5cGVBcmd1bWVudHMgPSBleGlzdGluZ1t0eXBlQXJndW1lbnRzS2V5XTtcbiAgICAgICAgaWYgKGV4aXN0aW5nVHlwZUFyZ3VtZW50cykge1xuICAgICAgICAgIGV4aXN0aW5nVHlwZUFyZ3VtZW50cy5wYXJhbXMucHVzaCguLi50eXBlQXJndW1lbnRzLnBhcmFtcyk7XG4gICAgICAgICAgZXhpc3RpbmdUeXBlQXJndW1lbnRzLnBhcmFtcyA9IHJlbW92ZVR5cGVEdXBsaWNhdGVzKGV4aXN0aW5nVHlwZUFyZ3VtZW50cy5wYXJhbXMpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGV4aXN0aW5nID0gdHlwZUFyZ3VtZW50cztcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZ2VuZXJpY3Muc2V0KG5hbWUsIG5vZGUpO1xuICAgICAgfVxuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIHR5cGVzLnB1c2gobm9kZSk7XG4gIH1cbiAgZm9yIChjb25zdCBbLCBiYXNlVHlwZV0gb2YgYmFzZXMpIHtcbiAgICB0eXBlcy5wdXNoKGJhc2VUeXBlKTtcbiAgfVxuICBmb3IgKGNvbnN0IFssIGdlbmVyaWNOYW1lXSBvZiBnZW5lcmljcykge1xuICAgIHR5cGVzLnB1c2goZ2VuZXJpY05hbWUpO1xuICB9XG4gIHJldHVybiB0eXBlcztcbn1cblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cmVtb3ZlVHlwZUR1cGxpY2F0ZXMuanMubWFwXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@babel/types/lib/modifications/typescript/removeTypeDuplicates.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@babel/types/lib/retrievers/getAssignmentIdentifiers.js":
/*!******************************************************************************!*\
  !*** ./node_modules/@babel/types/lib/retrievers/getAssignmentIdentifiers.js ***!
  \******************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports[\"default\"] = getAssignmentIdentifiers;\nfunction getAssignmentIdentifiers(node) {\n  const search = [].concat(node);\n  const ids = Object.create(null);\n  while (search.length) {\n    const id = search.pop();\n    if (!id) continue;\n    switch (id.type) {\n      case \"ArrayPattern\":\n        search.push(...id.elements);\n        break;\n      case \"AssignmentExpression\":\n      case \"AssignmentPattern\":\n      case \"ForInStatement\":\n      case \"ForOfStatement\":\n        search.push(id.left);\n        break;\n      case \"ObjectPattern\":\n        search.push(...id.properties);\n        break;\n      case \"ObjectProperty\":\n        search.push(id.value);\n        break;\n      case \"RestElement\":\n      case \"UpdateExpression\":\n        search.push(id.argument);\n        break;\n      case \"UnaryExpression\":\n        if (id.operator === \"delete\") {\n          search.push(id.argument);\n        }\n        break;\n      case \"Identifier\":\n        ids[id.name] = id;\n        break;\n      default:\n        break;\n    }\n  }\n  return ids;\n}\n\n//# sourceMappingURL=getAssignmentIdentifiers.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGJhYmVsL3R5cGVzL2xpYi9yZXRyaWV2ZXJzL2dldEFzc2lnbm1lbnRJZGVudGlmaWVycy5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYiw4Q0FBNkM7QUFDN0M7QUFDQSxDQUFDLEVBQUM7QUFDRixrQkFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcmVwby12aXN1YWxpemVyLy4vbm9kZV9tb2R1bGVzL0BiYWJlbC90eXBlcy9saWIvcmV0cmlldmVycy9nZXRBc3NpZ25tZW50SWRlbnRpZmllcnMuanM/NDg3MSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuZGVmYXVsdCA9IGdldEFzc2lnbm1lbnRJZGVudGlmaWVycztcbmZ1bmN0aW9uIGdldEFzc2lnbm1lbnRJZGVudGlmaWVycyhub2RlKSB7XG4gIGNvbnN0IHNlYXJjaCA9IFtdLmNvbmNhdChub2RlKTtcbiAgY29uc3QgaWRzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgd2hpbGUgKHNlYXJjaC5sZW5ndGgpIHtcbiAgICBjb25zdCBpZCA9IHNlYXJjaC5wb3AoKTtcbiAgICBpZiAoIWlkKSBjb250aW51ZTtcbiAgICBzd2l0Y2ggKGlkLnR5cGUpIHtcbiAgICAgIGNhc2UgXCJBcnJheVBhdHRlcm5cIjpcbiAgICAgICAgc2VhcmNoLnB1c2goLi4uaWQuZWxlbWVudHMpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgXCJBc3NpZ25tZW50RXhwcmVzc2lvblwiOlxuICAgICAgY2FzZSBcIkFzc2lnbm1lbnRQYXR0ZXJuXCI6XG4gICAgICBjYXNlIFwiRm9ySW5TdGF0ZW1lbnRcIjpcbiAgICAgIGNhc2UgXCJGb3JPZlN0YXRlbWVudFwiOlxuICAgICAgICBzZWFyY2gucHVzaChpZC5sZWZ0KTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFwiT2JqZWN0UGF0dGVyblwiOlxuICAgICAgICBzZWFyY2gucHVzaCguLi5pZC5wcm9wZXJ0aWVzKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFwiT2JqZWN0UHJvcGVydHlcIjpcbiAgICAgICAgc2VhcmNoLnB1c2goaWQudmFsdWUpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgXCJSZXN0RWxlbWVudFwiOlxuICAgICAgY2FzZSBcIlVwZGF0ZUV4cHJlc3Npb25cIjpcbiAgICAgICAgc2VhcmNoLnB1c2goaWQuYXJndW1lbnQpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgXCJVbmFyeUV4cHJlc3Npb25cIjpcbiAgICAgICAgaWYgKGlkLm9wZXJhdG9yID09PSBcImRlbGV0ZVwiKSB7XG4gICAgICAgICAgc2VhcmNoLnB1c2goaWQuYXJndW1lbnQpO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBcIklkZW50aWZpZXJcIjpcbiAgICAgICAgaWRzW2lkLm5hbWVdID0gaWQ7XG4gICAgICAgIGJyZWFrO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG4gIHJldHVybiBpZHM7XG59XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWdldEFzc2lnbm1lbnRJZGVudGlmaWVycy5qcy5tYXBcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@babel/types/lib/retrievers/getAssignmentIdentifiers.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@babel/types/lib/retrievers/getBindingIdentifiers.js":
/*!***************************************************************************!*\
  !*** ./node_modules/@babel/types/lib/retrievers/getBindingIdentifiers.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports[\"default\"] = getBindingIdentifiers;\nvar _index = __webpack_require__(/*! ../validators/generated/index.js */ \"(ssr)/./node_modules/@babel/types/lib/validators/generated/index.js\");\nfunction getBindingIdentifiers(node, duplicates, outerOnly, newBindingsOnly) {\n  const search = [].concat(node);\n  const ids = Object.create(null);\n  while (search.length) {\n    const id = search.shift();\n    if (!id) continue;\n    if (newBindingsOnly && ((0, _index.isAssignmentExpression)(id) || (0, _index.isUnaryExpression)(id) || (0, _index.isUpdateExpression)(id))) {\n      continue;\n    }\n    if ((0, _index.isIdentifier)(id)) {\n      if (duplicates) {\n        const _ids = ids[id.name] = ids[id.name] || [];\n        _ids.push(id);\n      } else {\n        ids[id.name] = id;\n      }\n      continue;\n    }\n    if ((0, _index.isExportDeclaration)(id) && !(0, _index.isExportAllDeclaration)(id)) {\n      if ((0, _index.isDeclaration)(id.declaration)) {\n        search.push(id.declaration);\n      }\n      continue;\n    }\n    if (outerOnly) {\n      if ((0, _index.isFunctionDeclaration)(id)) {\n        search.push(id.id);\n        continue;\n      }\n      if ((0, _index.isFunctionExpression)(id)) {\n        continue;\n      }\n    }\n    const keys = getBindingIdentifiers.keys[id.type];\n    if (keys) {\n      for (let i = 0; i < keys.length; i++) {\n        const key = keys[i];\n        const nodes = id[key];\n        if (nodes) {\n          if (Array.isArray(nodes)) {\n            search.push(...nodes);\n          } else {\n            search.push(nodes);\n          }\n        }\n      }\n    }\n  }\n  return ids;\n}\nconst keys = {\n  DeclareClass: [\"id\"],\n  DeclareFunction: [\"id\"],\n  DeclareModule: [\"id\"],\n  DeclareVariable: [\"id\"],\n  DeclareInterface: [\"id\"],\n  DeclareTypeAlias: [\"id\"],\n  DeclareOpaqueType: [\"id\"],\n  InterfaceDeclaration: [\"id\"],\n  TypeAlias: [\"id\"],\n  OpaqueType: [\"id\"],\n  CatchClause: [\"param\"],\n  LabeledStatement: [\"label\"],\n  UnaryExpression: [\"argument\"],\n  AssignmentExpression: [\"left\"],\n  ImportSpecifier: [\"local\"],\n  ImportNamespaceSpecifier: [\"local\"],\n  ImportDefaultSpecifier: [\"local\"],\n  ImportDeclaration: [\"specifiers\"],\n  TSImportEqualsDeclaration: [\"id\"],\n  ExportSpecifier: [\"exported\"],\n  ExportNamespaceSpecifier: [\"exported\"],\n  ExportDefaultSpecifier: [\"exported\"],\n  FunctionDeclaration: [\"id\", \"params\"],\n  FunctionExpression: [\"id\", \"params\"],\n  ArrowFunctionExpression: [\"params\"],\n  ObjectMethod: [\"params\"],\n  ClassMethod: [\"params\"],\n  ClassPrivateMethod: [\"params\"],\n  ForInStatement: [\"left\"],\n  ForOfStatement: [\"left\"],\n  ClassDeclaration: [\"id\"],\n  ClassExpression: [\"id\"],\n  RestElement: [\"argument\"],\n  UpdateExpression: [\"argument\"],\n  ObjectProperty: [\"value\"],\n  AssignmentPattern: [\"left\"],\n  ArrayPattern: [\"elements\"],\n  ObjectPattern: [\"properties\"],\n  VariableDeclaration: [\"declarations\"],\n  VariableDeclarator: [\"id\"]\n};\ngetBindingIdentifiers.keys = keys;\n\n//# sourceMappingURL=getBindingIdentifiers.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGJhYmVsL3R5cGVzL2xpYi9yZXRyaWV2ZXJzL2dldEJpbmRpbmdJZGVudGlmaWVycy5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYiw4Q0FBNkM7QUFDN0M7QUFDQSxDQUFDLEVBQUM7QUFDRixrQkFBZTtBQUNmLGFBQWEsbUJBQU8sQ0FBQyw2R0FBa0M7QUFDdkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLGlCQUFpQjtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSIsInNvdXJjZXMiOlsid2VicGFjazovL3JlcG8tdmlzdWFsaXplci8uL25vZGVfbW9kdWxlcy9AYmFiZWwvdHlwZXMvbGliL3JldHJpZXZlcnMvZ2V0QmluZGluZ0lkZW50aWZpZXJzLmpzPzFjODUiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLmRlZmF1bHQgPSBnZXRCaW5kaW5nSWRlbnRpZmllcnM7XG52YXIgX2luZGV4ID0gcmVxdWlyZShcIi4uL3ZhbGlkYXRvcnMvZ2VuZXJhdGVkL2luZGV4LmpzXCIpO1xuZnVuY3Rpb24gZ2V0QmluZGluZ0lkZW50aWZpZXJzKG5vZGUsIGR1cGxpY2F0ZXMsIG91dGVyT25seSwgbmV3QmluZGluZ3NPbmx5KSB7XG4gIGNvbnN0IHNlYXJjaCA9IFtdLmNvbmNhdChub2RlKTtcbiAgY29uc3QgaWRzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgd2hpbGUgKHNlYXJjaC5sZW5ndGgpIHtcbiAgICBjb25zdCBpZCA9IHNlYXJjaC5zaGlmdCgpO1xuICAgIGlmICghaWQpIGNvbnRpbnVlO1xuICAgIGlmIChuZXdCaW5kaW5nc09ubHkgJiYgKCgwLCBfaW5kZXguaXNBc3NpZ25tZW50RXhwcmVzc2lvbikoaWQpIHx8ICgwLCBfaW5kZXguaXNVbmFyeUV4cHJlc3Npb24pKGlkKSB8fCAoMCwgX2luZGV4LmlzVXBkYXRlRXhwcmVzc2lvbikoaWQpKSkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIGlmICgoMCwgX2luZGV4LmlzSWRlbnRpZmllcikoaWQpKSB7XG4gICAgICBpZiAoZHVwbGljYXRlcykge1xuICAgICAgICBjb25zdCBfaWRzID0gaWRzW2lkLm5hbWVdID0gaWRzW2lkLm5hbWVdIHx8IFtdO1xuICAgICAgICBfaWRzLnB1c2goaWQpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWRzW2lkLm5hbWVdID0gaWQ7XG4gICAgICB9XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgaWYgKCgwLCBfaW5kZXguaXNFeHBvcnREZWNsYXJhdGlvbikoaWQpICYmICEoMCwgX2luZGV4LmlzRXhwb3J0QWxsRGVjbGFyYXRpb24pKGlkKSkge1xuICAgICAgaWYgKCgwLCBfaW5kZXguaXNEZWNsYXJhdGlvbikoaWQuZGVjbGFyYXRpb24pKSB7XG4gICAgICAgIHNlYXJjaC5wdXNoKGlkLmRlY2xhcmF0aW9uKTtcbiAgICAgIH1cbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICBpZiAob3V0ZXJPbmx5KSB7XG4gICAgICBpZiAoKDAsIF9pbmRleC5pc0Z1bmN0aW9uRGVjbGFyYXRpb24pKGlkKSkge1xuICAgICAgICBzZWFyY2gucHVzaChpZC5pZCk7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgaWYgKCgwLCBfaW5kZXguaXNGdW5jdGlvbkV4cHJlc3Npb24pKGlkKSkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICB9XG4gICAgY29uc3Qga2V5cyA9IGdldEJpbmRpbmdJZGVudGlmaWVycy5rZXlzW2lkLnR5cGVdO1xuICAgIGlmIChrZXlzKSB7XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY29uc3Qga2V5ID0ga2V5c1tpXTtcbiAgICAgICAgY29uc3Qgbm9kZXMgPSBpZFtrZXldO1xuICAgICAgICBpZiAobm9kZXMpIHtcbiAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShub2RlcykpIHtcbiAgICAgICAgICAgIHNlYXJjaC5wdXNoKC4uLm5vZGVzKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgc2VhcmNoLnB1c2gobm9kZXMpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gaWRzO1xufVxuY29uc3Qga2V5cyA9IHtcbiAgRGVjbGFyZUNsYXNzOiBbXCJpZFwiXSxcbiAgRGVjbGFyZUZ1bmN0aW9uOiBbXCJpZFwiXSxcbiAgRGVjbGFyZU1vZHVsZTogW1wiaWRcIl0sXG4gIERlY2xhcmVWYXJpYWJsZTogW1wiaWRcIl0sXG4gIERlY2xhcmVJbnRlcmZhY2U6IFtcImlkXCJdLFxuICBEZWNsYXJlVHlwZUFsaWFzOiBbXCJpZFwiXSxcbiAgRGVjbGFyZU9wYXF1ZVR5cGU6IFtcImlkXCJdLFxuICBJbnRlcmZhY2VEZWNsYXJhdGlvbjogW1wiaWRcIl0sXG4gIFR5cGVBbGlhczogW1wiaWRcIl0sXG4gIE9wYXF1ZVR5cGU6IFtcImlkXCJdLFxuICBDYXRjaENsYXVzZTogW1wicGFyYW1cIl0sXG4gIExhYmVsZWRTdGF0ZW1lbnQ6IFtcImxhYmVsXCJdLFxuICBVbmFyeUV4cHJlc3Npb246IFtcImFyZ3VtZW50XCJdLFxuICBBc3NpZ25tZW50RXhwcmVzc2lvbjogW1wibGVmdFwiXSxcbiAgSW1wb3J0U3BlY2lmaWVyOiBbXCJsb2NhbFwiXSxcbiAgSW1wb3J0TmFtZXNwYWNlU3BlY2lmaWVyOiBbXCJsb2NhbFwiXSxcbiAgSW1wb3J0RGVmYXVsdFNwZWNpZmllcjogW1wibG9jYWxcIl0sXG4gIEltcG9ydERlY2xhcmF0aW9uOiBbXCJzcGVjaWZpZXJzXCJdLFxuICBUU0ltcG9ydEVxdWFsc0RlY2xhcmF0aW9uOiBbXCJpZFwiXSxcbiAgRXhwb3J0U3BlY2lmaWVyOiBbXCJleHBvcnRlZFwiXSxcbiAgRXhwb3J0TmFtZXNwYWNlU3BlY2lmaWVyOiBbXCJleHBvcnRlZFwiXSxcbiAgRXhwb3J0RGVmYXVsdFNwZWNpZmllcjogW1wiZXhwb3J0ZWRcIl0sXG4gIEZ1bmN0aW9uRGVjbGFyYXRpb246IFtcImlkXCIsIFwicGFyYW1zXCJdLFxuICBGdW5jdGlvbkV4cHJlc3Npb246IFtcImlkXCIsIFwicGFyYW1zXCJdLFxuICBBcnJvd0Z1bmN0aW9uRXhwcmVzc2lvbjogW1wicGFyYW1zXCJdLFxuICBPYmplY3RNZXRob2Q6IFtcInBhcmFtc1wiXSxcbiAgQ2xhc3NNZXRob2Q6IFtcInBhcmFtc1wiXSxcbiAgQ2xhc3NQcml2YXRlTWV0aG9kOiBbXCJwYXJhbXNcIl0sXG4gIEZvckluU3RhdGVtZW50OiBbXCJsZWZ0XCJdLFxuICBGb3JPZlN0YXRlbWVudDogW1wibGVmdFwiXSxcbiAgQ2xhc3NEZWNsYXJhdGlvbjogW1wiaWRcIl0sXG4gIENsYXNzRXhwcmVzc2lvbjogW1wiaWRcIl0sXG4gIFJlc3RFbGVtZW50OiBbXCJhcmd1bWVudFwiXSxcbiAgVXBkYXRlRXhwcmVzc2lvbjogW1wiYXJndW1lbnRcIl0sXG4gIE9iamVjdFByb3BlcnR5OiBbXCJ2YWx1ZVwiXSxcbiAgQXNzaWdubWVudFBhdHRlcm46IFtcImxlZnRcIl0sXG4gIEFycmF5UGF0dGVybjogW1wiZWxlbWVudHNcIl0sXG4gIE9iamVjdFBhdHRlcm46IFtcInByb3BlcnRpZXNcIl0sXG4gIFZhcmlhYmxlRGVjbGFyYXRpb246IFtcImRlY2xhcmF0aW9uc1wiXSxcbiAgVmFyaWFibGVEZWNsYXJhdG9yOiBbXCJpZFwiXVxufTtcbmdldEJpbmRpbmdJZGVudGlmaWVycy5rZXlzID0ga2V5cztcblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Z2V0QmluZGluZ0lkZW50aWZpZXJzLmpzLm1hcFxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@babel/types/lib/retrievers/getBindingIdentifiers.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@babel/types/lib/retrievers/getFunctionName.js":
/*!*********************************************************************!*\
  !*** ./node_modules/@babel/types/lib/retrievers/getFunctionName.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports[\"default\"] = getFunctionName;\nvar _index = __webpack_require__(/*! ../validators/generated/index.js */ \"(ssr)/./node_modules/@babel/types/lib/validators/generated/index.js\");\nfunction getNameFromLiteralId(id) {\n  if ((0, _index.isNullLiteral)(id)) {\n    return \"null\";\n  }\n  if ((0, _index.isRegExpLiteral)(id)) {\n    return `/${id.pattern}/${id.flags}`;\n  }\n  if ((0, _index.isTemplateLiteral)(id)) {\n    return id.quasis.map(quasi => quasi.value.raw).join(\"\");\n  }\n  if (id.value !== undefined) {\n    return String(id.value);\n  }\n  return null;\n}\nfunction getObjectMemberKey(node) {\n  if (!node.computed || (0, _index.isLiteral)(node.key)) {\n    return node.key;\n  }\n}\nfunction getFunctionName(node, parent) {\n  if (\"id\" in node && node.id) {\n    return {\n      name: node.id.name,\n      originalNode: node.id\n    };\n  }\n  let prefix = \"\";\n  let id;\n  if ((0, _index.isObjectProperty)(parent, {\n    value: node\n  })) {\n    id = getObjectMemberKey(parent);\n  } else if ((0, _index.isObjectMethod)(node) || (0, _index.isClassMethod)(node)) {\n    id = getObjectMemberKey(node);\n    if (node.kind === \"get\") prefix = \"get \";else if (node.kind === \"set\") prefix = \"set \";\n  } else if ((0, _index.isVariableDeclarator)(parent, {\n    init: node\n  })) {\n    id = parent.id;\n  } else if ((0, _index.isAssignmentExpression)(parent, {\n    operator: \"=\",\n    right: node\n  })) {\n    id = parent.left;\n  }\n  if (!id) return null;\n  const name = (0, _index.isLiteral)(id) ? getNameFromLiteralId(id) : (0, _index.isIdentifier)(id) ? id.name : (0, _index.isPrivateName)(id) ? id.id.name : null;\n  if (name == null) return null;\n  return {\n    name: prefix + name,\n    originalNode: id\n  };\n}\n\n//# sourceMappingURL=getFunctionName.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGJhYmVsL3R5cGVzL2xpYi9yZXRyaWV2ZXJzL2dldEZ1bmN0aW9uTmFtZS5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYiw4Q0FBNkM7QUFDN0M7QUFDQSxDQUFDLEVBQUM7QUFDRixrQkFBZTtBQUNmLGFBQWEsbUJBQU8sQ0FBQyw2R0FBa0M7QUFDdkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsV0FBVyxHQUFHLFNBQVM7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxJQUFJO0FBQ0o7QUFDQSw2Q0FBNkM7QUFDN0MsSUFBSTtBQUNKO0FBQ0EsR0FBRztBQUNIO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9yZXBvLXZpc3VhbGl6ZXIvLi9ub2RlX21vZHVsZXMvQGJhYmVsL3R5cGVzL2xpYi9yZXRyaWV2ZXJzL2dldEZ1bmN0aW9uTmFtZS5qcz9kZGM5Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5kZWZhdWx0ID0gZ2V0RnVuY3Rpb25OYW1lO1xudmFyIF9pbmRleCA9IHJlcXVpcmUoXCIuLi92YWxpZGF0b3JzL2dlbmVyYXRlZC9pbmRleC5qc1wiKTtcbmZ1bmN0aW9uIGdldE5hbWVGcm9tTGl0ZXJhbElkKGlkKSB7XG4gIGlmICgoMCwgX2luZGV4LmlzTnVsbExpdGVyYWwpKGlkKSkge1xuICAgIHJldHVybiBcIm51bGxcIjtcbiAgfVxuICBpZiAoKDAsIF9pbmRleC5pc1JlZ0V4cExpdGVyYWwpKGlkKSkge1xuICAgIHJldHVybiBgLyR7aWQucGF0dGVybn0vJHtpZC5mbGFnc31gO1xuICB9XG4gIGlmICgoMCwgX2luZGV4LmlzVGVtcGxhdGVMaXRlcmFsKShpZCkpIHtcbiAgICByZXR1cm4gaWQucXVhc2lzLm1hcChxdWFzaSA9PiBxdWFzaS52YWx1ZS5yYXcpLmpvaW4oXCJcIik7XG4gIH1cbiAgaWYgKGlkLnZhbHVlICE9PSB1bmRlZmluZWQpIHtcbiAgICByZXR1cm4gU3RyaW5nKGlkLnZhbHVlKTtcbiAgfVxuICByZXR1cm4gbnVsbDtcbn1cbmZ1bmN0aW9uIGdldE9iamVjdE1lbWJlcktleShub2RlKSB7XG4gIGlmICghbm9kZS5jb21wdXRlZCB8fCAoMCwgX2luZGV4LmlzTGl0ZXJhbCkobm9kZS5rZXkpKSB7XG4gICAgcmV0dXJuIG5vZGUua2V5O1xuICB9XG59XG5mdW5jdGlvbiBnZXRGdW5jdGlvbk5hbWUobm9kZSwgcGFyZW50KSB7XG4gIGlmIChcImlkXCIgaW4gbm9kZSAmJiBub2RlLmlkKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIG5hbWU6IG5vZGUuaWQubmFtZSxcbiAgICAgIG9yaWdpbmFsTm9kZTogbm9kZS5pZFxuICAgIH07XG4gIH1cbiAgbGV0IHByZWZpeCA9IFwiXCI7XG4gIGxldCBpZDtcbiAgaWYgKCgwLCBfaW5kZXguaXNPYmplY3RQcm9wZXJ0eSkocGFyZW50LCB7XG4gICAgdmFsdWU6IG5vZGVcbiAgfSkpIHtcbiAgICBpZCA9IGdldE9iamVjdE1lbWJlcktleShwYXJlbnQpO1xuICB9IGVsc2UgaWYgKCgwLCBfaW5kZXguaXNPYmplY3RNZXRob2QpKG5vZGUpIHx8ICgwLCBfaW5kZXguaXNDbGFzc01ldGhvZCkobm9kZSkpIHtcbiAgICBpZCA9IGdldE9iamVjdE1lbWJlcktleShub2RlKTtcbiAgICBpZiAobm9kZS5raW5kID09PSBcImdldFwiKSBwcmVmaXggPSBcImdldCBcIjtlbHNlIGlmIChub2RlLmtpbmQgPT09IFwic2V0XCIpIHByZWZpeCA9IFwic2V0IFwiO1xuICB9IGVsc2UgaWYgKCgwLCBfaW5kZXguaXNWYXJpYWJsZURlY2xhcmF0b3IpKHBhcmVudCwge1xuICAgIGluaXQ6IG5vZGVcbiAgfSkpIHtcbiAgICBpZCA9IHBhcmVudC5pZDtcbiAgfSBlbHNlIGlmICgoMCwgX2luZGV4LmlzQXNzaWdubWVudEV4cHJlc3Npb24pKHBhcmVudCwge1xuICAgIG9wZXJhdG9yOiBcIj1cIixcbiAgICByaWdodDogbm9kZVxuICB9KSkge1xuICAgIGlkID0gcGFyZW50LmxlZnQ7XG4gIH1cbiAgaWYgKCFpZCkgcmV0dXJuIG51bGw7XG4gIGNvbnN0IG5hbWUgPSAoMCwgX2luZGV4LmlzTGl0ZXJhbCkoaWQpID8gZ2V0TmFtZUZyb21MaXRlcmFsSWQoaWQpIDogKDAsIF9pbmRleC5pc0lkZW50aWZpZXIpKGlkKSA/IGlkLm5hbWUgOiAoMCwgX2luZGV4LmlzUHJpdmF0ZU5hbWUpKGlkKSA/IGlkLmlkLm5hbWUgOiBudWxsO1xuICBpZiAobmFtZSA9PSBudWxsKSByZXR1cm4gbnVsbDtcbiAgcmV0dXJuIHtcbiAgICBuYW1lOiBwcmVmaXggKyBuYW1lLFxuICAgIG9yaWdpbmFsTm9kZTogaWRcbiAgfTtcbn1cblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Z2V0RnVuY3Rpb25OYW1lLmpzLm1hcFxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@babel/types/lib/retrievers/getFunctionName.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@babel/types/lib/retrievers/getOuterBindingIdentifiers.js":
/*!********************************************************************************!*\
  !*** ./node_modules/@babel/types/lib/retrievers/getOuterBindingIdentifiers.js ***!
  \********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports[\"default\"] = void 0;\nvar _getBindingIdentifiers = __webpack_require__(/*! ./getBindingIdentifiers.js */ \"(ssr)/./node_modules/@babel/types/lib/retrievers/getBindingIdentifiers.js\");\nvar _default = exports[\"default\"] = getOuterBindingIdentifiers;\nfunction getOuterBindingIdentifiers(node, duplicates) {\n  return (0, _getBindingIdentifiers.default)(node, duplicates, true);\n}\n\n//# sourceMappingURL=getOuterBindingIdentifiers.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGJhYmVsL3R5cGVzL2xpYi9yZXRyaWV2ZXJzL2dldE91dGVyQmluZGluZ0lkZW50aWZpZXJzLmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViLDhDQUE2QztBQUM3QztBQUNBLENBQUMsRUFBQztBQUNGLGtCQUFlO0FBQ2YsNkJBQTZCLG1CQUFPLENBQUMsNkdBQTRCO0FBQ2pFLGVBQWUsa0JBQWU7QUFDOUI7QUFDQTtBQUNBOztBQUVBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcmVwby12aXN1YWxpemVyLy4vbm9kZV9tb2R1bGVzL0BiYWJlbC90eXBlcy9saWIvcmV0cmlldmVycy9nZXRPdXRlckJpbmRpbmdJZGVudGlmaWVycy5qcz9hMWNlIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5kZWZhdWx0ID0gdm9pZCAwO1xudmFyIF9nZXRCaW5kaW5nSWRlbnRpZmllcnMgPSByZXF1aXJlKFwiLi9nZXRCaW5kaW5nSWRlbnRpZmllcnMuanNcIik7XG52YXIgX2RlZmF1bHQgPSBleHBvcnRzLmRlZmF1bHQgPSBnZXRPdXRlckJpbmRpbmdJZGVudGlmaWVycztcbmZ1bmN0aW9uIGdldE91dGVyQmluZGluZ0lkZW50aWZpZXJzKG5vZGUsIGR1cGxpY2F0ZXMpIHtcbiAgcmV0dXJuICgwLCBfZ2V0QmluZGluZ0lkZW50aWZpZXJzLmRlZmF1bHQpKG5vZGUsIGR1cGxpY2F0ZXMsIHRydWUpO1xufVxuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1nZXRPdXRlckJpbmRpbmdJZGVudGlmaWVycy5qcy5tYXBcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@babel/types/lib/retrievers/getOuterBindingIdentifiers.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@babel/types/lib/traverse/traverse.js":
/*!************************************************************!*\
  !*** ./node_modules/@babel/types/lib/traverse/traverse.js ***!
  \************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports[\"default\"] = traverse;\nvar _index = __webpack_require__(/*! ../definitions/index.js */ \"(ssr)/./node_modules/@babel/types/lib/definitions/index.js\");\nfunction traverse(node, handlers, state) {\n  if (typeof handlers === \"function\") {\n    handlers = {\n      enter: handlers\n    };\n  }\n  const {\n    enter,\n    exit\n  } = handlers;\n  traverseSimpleImpl(node, enter, exit, state, []);\n}\nfunction traverseSimpleImpl(node, enter, exit, state, ancestors) {\n  const keys = _index.VISITOR_KEYS[node.type];\n  if (!keys) return;\n  if (enter) enter(node, ancestors, state);\n  for (const key of keys) {\n    const subNode = node[key];\n    if (Array.isArray(subNode)) {\n      for (let i = 0; i < subNode.length; i++) {\n        const child = subNode[i];\n        if (!child) continue;\n        ancestors.push({\n          node,\n          key,\n          index: i\n        });\n        traverseSimpleImpl(child, enter, exit, state, ancestors);\n        ancestors.pop();\n      }\n    } else if (subNode) {\n      ancestors.push({\n        node,\n        key\n      });\n      traverseSimpleImpl(subNode, enter, exit, state, ancestors);\n      ancestors.pop();\n    }\n  }\n  if (exit) exit(node, ancestors, state);\n}\n\n//# sourceMappingURL=traverse.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGJhYmVsL3R5cGVzL2xpYi90cmF2ZXJzZS90cmF2ZXJzZS5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYiw4Q0FBNkM7QUFDN0M7QUFDQSxDQUFDLEVBQUM7QUFDRixrQkFBZTtBQUNmLGFBQWEsbUJBQU8sQ0FBQywyRkFBeUI7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixvQkFBb0I7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcmVwby12aXN1YWxpemVyLy4vbm9kZV9tb2R1bGVzL0BiYWJlbC90eXBlcy9saWIvdHJhdmVyc2UvdHJhdmVyc2UuanM/NmQ5OCJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuZGVmYXVsdCA9IHRyYXZlcnNlO1xudmFyIF9pbmRleCA9IHJlcXVpcmUoXCIuLi9kZWZpbml0aW9ucy9pbmRleC5qc1wiKTtcbmZ1bmN0aW9uIHRyYXZlcnNlKG5vZGUsIGhhbmRsZXJzLCBzdGF0ZSkge1xuICBpZiAodHlwZW9mIGhhbmRsZXJzID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICBoYW5kbGVycyA9IHtcbiAgICAgIGVudGVyOiBoYW5kbGVyc1xuICAgIH07XG4gIH1cbiAgY29uc3Qge1xuICAgIGVudGVyLFxuICAgIGV4aXRcbiAgfSA9IGhhbmRsZXJzO1xuICB0cmF2ZXJzZVNpbXBsZUltcGwobm9kZSwgZW50ZXIsIGV4aXQsIHN0YXRlLCBbXSk7XG59XG5mdW5jdGlvbiB0cmF2ZXJzZVNpbXBsZUltcGwobm9kZSwgZW50ZXIsIGV4aXQsIHN0YXRlLCBhbmNlc3RvcnMpIHtcbiAgY29uc3Qga2V5cyA9IF9pbmRleC5WSVNJVE9SX0tFWVNbbm9kZS50eXBlXTtcbiAgaWYgKCFrZXlzKSByZXR1cm47XG4gIGlmIChlbnRlcikgZW50ZXIobm9kZSwgYW5jZXN0b3JzLCBzdGF0ZSk7XG4gIGZvciAoY29uc3Qga2V5IG9mIGtleXMpIHtcbiAgICBjb25zdCBzdWJOb2RlID0gbm9kZVtrZXldO1xuICAgIGlmIChBcnJheS5pc0FycmF5KHN1Yk5vZGUpKSB7XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHN1Yk5vZGUubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY29uc3QgY2hpbGQgPSBzdWJOb2RlW2ldO1xuICAgICAgICBpZiAoIWNoaWxkKSBjb250aW51ZTtcbiAgICAgICAgYW5jZXN0b3JzLnB1c2goe1xuICAgICAgICAgIG5vZGUsXG4gICAgICAgICAga2V5LFxuICAgICAgICAgIGluZGV4OiBpXG4gICAgICAgIH0pO1xuICAgICAgICB0cmF2ZXJzZVNpbXBsZUltcGwoY2hpbGQsIGVudGVyLCBleGl0LCBzdGF0ZSwgYW5jZXN0b3JzKTtcbiAgICAgICAgYW5jZXN0b3JzLnBvcCgpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoc3ViTm9kZSkge1xuICAgICAgYW5jZXN0b3JzLnB1c2goe1xuICAgICAgICBub2RlLFxuICAgICAgICBrZXlcbiAgICAgIH0pO1xuICAgICAgdHJhdmVyc2VTaW1wbGVJbXBsKHN1Yk5vZGUsIGVudGVyLCBleGl0LCBzdGF0ZSwgYW5jZXN0b3JzKTtcbiAgICAgIGFuY2VzdG9ycy5wb3AoKTtcbiAgICB9XG4gIH1cbiAgaWYgKGV4aXQpIGV4aXQobm9kZSwgYW5jZXN0b3JzLCBzdGF0ZSk7XG59XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXRyYXZlcnNlLmpzLm1hcFxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@babel/types/lib/traverse/traverse.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@babel/types/lib/traverse/traverseFast.js":
/*!****************************************************************!*\
  !*** ./node_modules/@babel/types/lib/traverse/traverseFast.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports[\"default\"] = traverseFast;\nvar _index = __webpack_require__(/*! ../definitions/index.js */ \"(ssr)/./node_modules/@babel/types/lib/definitions/index.js\");\nconst _skip = Symbol();\nconst _stop = Symbol();\nfunction traverseFast(node, enter, opts) {\n  if (!node) return false;\n  const keys = _index.VISITOR_KEYS[node.type];\n  if (!keys) return false;\n  opts = opts || {};\n  const ret = enter(node, opts);\n  if (ret !== undefined) {\n    switch (ret) {\n      case _skip:\n        return false;\n      case _stop:\n        return true;\n    }\n  }\n  for (const key of keys) {\n    const subNode = node[key];\n    if (!subNode) continue;\n    if (Array.isArray(subNode)) {\n      for (const node of subNode) {\n        if (traverseFast(node, enter, opts)) return true;\n      }\n    } else {\n      if (traverseFast(subNode, enter, opts)) return true;\n    }\n  }\n  return false;\n}\ntraverseFast.skip = _skip;\ntraverseFast.stop = _stop;\n\n//# sourceMappingURL=traverseFast.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGJhYmVsL3R5cGVzL2xpYi90cmF2ZXJzZS90cmF2ZXJzZUZhc3QuanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWIsOENBQTZDO0FBQzdDO0FBQ0EsQ0FBQyxFQUFDO0FBQ0Ysa0JBQWU7QUFDZixhQUFhLG1CQUFPLENBQUMsMkZBQXlCO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9yZXBvLXZpc3VhbGl6ZXIvLi9ub2RlX21vZHVsZXMvQGJhYmVsL3R5cGVzL2xpYi90cmF2ZXJzZS90cmF2ZXJzZUZhc3QuanM/ZWY3OCJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuZGVmYXVsdCA9IHRyYXZlcnNlRmFzdDtcbnZhciBfaW5kZXggPSByZXF1aXJlKFwiLi4vZGVmaW5pdGlvbnMvaW5kZXguanNcIik7XG5jb25zdCBfc2tpcCA9IFN5bWJvbCgpO1xuY29uc3QgX3N0b3AgPSBTeW1ib2woKTtcbmZ1bmN0aW9uIHRyYXZlcnNlRmFzdChub2RlLCBlbnRlciwgb3B0cykge1xuICBpZiAoIW5vZGUpIHJldHVybiBmYWxzZTtcbiAgY29uc3Qga2V5cyA9IF9pbmRleC5WSVNJVE9SX0tFWVNbbm9kZS50eXBlXTtcbiAgaWYgKCFrZXlzKSByZXR1cm4gZmFsc2U7XG4gIG9wdHMgPSBvcHRzIHx8IHt9O1xuICBjb25zdCByZXQgPSBlbnRlcihub2RlLCBvcHRzKTtcbiAgaWYgKHJldCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgc3dpdGNoIChyZXQpIHtcbiAgICAgIGNhc2UgX3NraXA6XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIGNhc2UgX3N0b3A6XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfVxuICBmb3IgKGNvbnN0IGtleSBvZiBrZXlzKSB7XG4gICAgY29uc3Qgc3ViTm9kZSA9IG5vZGVba2V5XTtcbiAgICBpZiAoIXN1Yk5vZGUpIGNvbnRpbnVlO1xuICAgIGlmIChBcnJheS5pc0FycmF5KHN1Yk5vZGUpKSB7XG4gICAgICBmb3IgKGNvbnN0IG5vZGUgb2Ygc3ViTm9kZSkge1xuICAgICAgICBpZiAodHJhdmVyc2VGYXN0KG5vZGUsIGVudGVyLCBvcHRzKSkgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmICh0cmF2ZXJzZUZhc3Qoc3ViTm9kZSwgZW50ZXIsIG9wdHMpKSByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufVxudHJhdmVyc2VGYXN0LnNraXAgPSBfc2tpcDtcbnRyYXZlcnNlRmFzdC5zdG9wID0gX3N0b3A7XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXRyYXZlcnNlRmFzdC5qcy5tYXBcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@babel/types/lib/traverse/traverseFast.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@babel/types/lib/utils/deprecationWarning.js":
/*!*******************************************************************!*\
  !*** ./node_modules/@babel/types/lib/utils/deprecationWarning.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports[\"default\"] = deprecationWarning;\nconst warnings = new Set();\nfunction deprecationWarning(oldName, newName, prefix = \"\", cacheKey = oldName) {\n  if (warnings.has(cacheKey)) return;\n  warnings.add(cacheKey);\n  const {\n    internal,\n    trace\n  } = captureShortStackTrace(1, 2);\n  if (internal) {\n    return;\n  }\n  console.warn(`${prefix}\\`${oldName}\\` has been deprecated, please migrate to \\`${newName}\\`\\n${trace}`);\n}\nfunction captureShortStackTrace(skip, length) {\n  const {\n    stackTraceLimit,\n    prepareStackTrace\n  } = Error;\n  let stackTrace;\n  Error.stackTraceLimit = 1 + skip + length;\n  Error.prepareStackTrace = function (err, stack) {\n    stackTrace = stack;\n  };\n  new Error().stack;\n  Error.stackTraceLimit = stackTraceLimit;\n  Error.prepareStackTrace = prepareStackTrace;\n  if (!stackTrace) return {\n    internal: false,\n    trace: \"\"\n  };\n  const shortStackTrace = stackTrace.slice(1 + skip, 1 + skip + length);\n  return {\n    internal: /[\\\\/]@babel[\\\\/]/.test(shortStackTrace[1].getFileName()),\n    trace: shortStackTrace.map(frame => `    at ${frame}`).join(\"\\n\")\n  };\n}\n\n//# sourceMappingURL=deprecationWarning.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGJhYmVsL3R5cGVzL2xpYi91dGlscy9kZXByZWNhdGlvbldhcm5pbmcuanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWIsOENBQTZDO0FBQzdDO0FBQ0EsQ0FBQyxFQUFDO0FBQ0Ysa0JBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsT0FBTyxJQUFJLFFBQVEsOENBQThDLFFBQVEsTUFBTSxNQUFNO0FBQ3ZHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0RBQWtELE1BQU07QUFDeEQ7QUFDQTs7QUFFQSIsInNvdXJjZXMiOlsid2VicGFjazovL3JlcG8tdmlzdWFsaXplci8uL25vZGVfbW9kdWxlcy9AYmFiZWwvdHlwZXMvbGliL3V0aWxzL2RlcHJlY2F0aW9uV2FybmluZy5qcz9kMmU5Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5kZWZhdWx0ID0gZGVwcmVjYXRpb25XYXJuaW5nO1xuY29uc3Qgd2FybmluZ3MgPSBuZXcgU2V0KCk7XG5mdW5jdGlvbiBkZXByZWNhdGlvbldhcm5pbmcob2xkTmFtZSwgbmV3TmFtZSwgcHJlZml4ID0gXCJcIiwgY2FjaGVLZXkgPSBvbGROYW1lKSB7XG4gIGlmICh3YXJuaW5ncy5oYXMoY2FjaGVLZXkpKSByZXR1cm47XG4gIHdhcm5pbmdzLmFkZChjYWNoZUtleSk7XG4gIGNvbnN0IHtcbiAgICBpbnRlcm5hbCxcbiAgICB0cmFjZVxuICB9ID0gY2FwdHVyZVNob3J0U3RhY2tUcmFjZSgxLCAyKTtcbiAgaWYgKGludGVybmFsKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGNvbnNvbGUud2FybihgJHtwcmVmaXh9XFxgJHtvbGROYW1lfVxcYCBoYXMgYmVlbiBkZXByZWNhdGVkLCBwbGVhc2UgbWlncmF0ZSB0byBcXGAke25ld05hbWV9XFxgXFxuJHt0cmFjZX1gKTtcbn1cbmZ1bmN0aW9uIGNhcHR1cmVTaG9ydFN0YWNrVHJhY2Uoc2tpcCwgbGVuZ3RoKSB7XG4gIGNvbnN0IHtcbiAgICBzdGFja1RyYWNlTGltaXQsXG4gICAgcHJlcGFyZVN0YWNrVHJhY2VcbiAgfSA9IEVycm9yO1xuICBsZXQgc3RhY2tUcmFjZTtcbiAgRXJyb3Iuc3RhY2tUcmFjZUxpbWl0ID0gMSArIHNraXAgKyBsZW5ndGg7XG4gIEVycm9yLnByZXBhcmVTdGFja1RyYWNlID0gZnVuY3Rpb24gKGVyciwgc3RhY2spIHtcbiAgICBzdGFja1RyYWNlID0gc3RhY2s7XG4gIH07XG4gIG5ldyBFcnJvcigpLnN0YWNrO1xuICBFcnJvci5zdGFja1RyYWNlTGltaXQgPSBzdGFja1RyYWNlTGltaXQ7XG4gIEVycm9yLnByZXBhcmVTdGFja1RyYWNlID0gcHJlcGFyZVN0YWNrVHJhY2U7XG4gIGlmICghc3RhY2tUcmFjZSkgcmV0dXJuIHtcbiAgICBpbnRlcm5hbDogZmFsc2UsXG4gICAgdHJhY2U6IFwiXCJcbiAgfTtcbiAgY29uc3Qgc2hvcnRTdGFja1RyYWNlID0gc3RhY2tUcmFjZS5zbGljZSgxICsgc2tpcCwgMSArIHNraXAgKyBsZW5ndGgpO1xuICByZXR1cm4ge1xuICAgIGludGVybmFsOiAvW1xcXFwvXUBiYWJlbFtcXFxcL10vLnRlc3Qoc2hvcnRTdGFja1RyYWNlWzFdLmdldEZpbGVOYW1lKCkpLFxuICAgIHRyYWNlOiBzaG9ydFN0YWNrVHJhY2UubWFwKGZyYW1lID0+IGAgICAgYXQgJHtmcmFtZX1gKS5qb2luKFwiXFxuXCIpXG4gIH07XG59XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWRlcHJlY2F0aW9uV2FybmluZy5qcy5tYXBcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@babel/types/lib/utils/deprecationWarning.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@babel/types/lib/utils/inherit.js":
/*!********************************************************!*\
  !*** ./node_modules/@babel/types/lib/utils/inherit.js ***!
  \********************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports[\"default\"] = inherit;\nfunction inherit(key, child, parent) {\n  if (child && parent) {\n    child[key] = Array.from(new Set([].concat(child[key], parent[key]).filter(Boolean)));\n  }\n}\n\n//# sourceMappingURL=inherit.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGJhYmVsL3R5cGVzL2xpYi91dGlscy9pbmhlcml0LmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViLDhDQUE2QztBQUM3QztBQUNBLENBQUMsRUFBQztBQUNGLGtCQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSIsInNvdXJjZXMiOlsid2VicGFjazovL3JlcG8tdmlzdWFsaXplci8uL25vZGVfbW9kdWxlcy9AYmFiZWwvdHlwZXMvbGliL3V0aWxzL2luaGVyaXQuanM/MzQyMSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuZGVmYXVsdCA9IGluaGVyaXQ7XG5mdW5jdGlvbiBpbmhlcml0KGtleSwgY2hpbGQsIHBhcmVudCkge1xuICBpZiAoY2hpbGQgJiYgcGFyZW50KSB7XG4gICAgY2hpbGRba2V5XSA9IEFycmF5LmZyb20obmV3IFNldChbXS5jb25jYXQoY2hpbGRba2V5XSwgcGFyZW50W2tleV0pLmZpbHRlcihCb29sZWFuKSkpO1xuICB9XG59XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluaGVyaXQuanMubWFwXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@babel/types/lib/utils/inherit.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@babel/types/lib/utils/react/cleanJSXElementLiteralChild.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/@babel/types/lib/utils/react/cleanJSXElementLiteralChild.js ***!
  \**********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports[\"default\"] = cleanJSXElementLiteralChild;\nvar _index = __webpack_require__(/*! ../../builders/generated/index.js */ \"(ssr)/./node_modules/@babel/types/lib/builders/generated/index.js\");\nvar _index2 = __webpack_require__(/*! ../../index.js */ \"(ssr)/./node_modules/@babel/types/lib/index.js\");\nfunction cleanJSXElementLiteralChild(child, args) {\n  const lines = child.value.split(/\\r\\n|\\n|\\r/);\n  let lastNonEmptyLine = 0;\n  for (let i = 0; i < lines.length; i++) {\n    if (/[^ \\t]/.exec(lines[i])) {\n      lastNonEmptyLine = i;\n    }\n  }\n  let str = \"\";\n  for (let i = 0; i < lines.length; i++) {\n    const line = lines[i];\n    const isFirstLine = i === 0;\n    const isLastLine = i === lines.length - 1;\n    const isLastNonEmptyLine = i === lastNonEmptyLine;\n    let trimmedLine = line.replace(/\\t/g, \" \");\n    if (!isFirstLine) {\n      trimmedLine = trimmedLine.replace(/^ +/, \"\");\n    }\n    if (!isLastLine) {\n      trimmedLine = trimmedLine.replace(/ +$/, \"\");\n    }\n    if (trimmedLine) {\n      if (!isLastNonEmptyLine) {\n        trimmedLine += \" \";\n      }\n      str += trimmedLine;\n    }\n  }\n  if (str) args.push((0, _index2.inherits)((0, _index.stringLiteral)(str), child));\n}\n\n//# sourceMappingURL=cleanJSXElementLiteralChild.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGJhYmVsL3R5cGVzL2xpYi91dGlscy9yZWFjdC9jbGVhbkpTWEVsZW1lbnRMaXRlcmFsQ2hpbGQuanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWIsOENBQTZDO0FBQzdDO0FBQ0EsQ0FBQyxFQUFDO0FBQ0Ysa0JBQWU7QUFDZixhQUFhLG1CQUFPLENBQUMsNEdBQW1DO0FBQ3hELGNBQWMsbUJBQU8sQ0FBQyxzRUFBZ0I7QUFDdEM7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLGtCQUFrQjtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLGtCQUFrQjtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcmVwby12aXN1YWxpemVyLy4vbm9kZV9tb2R1bGVzL0BiYWJlbC90eXBlcy9saWIvdXRpbHMvcmVhY3QvY2xlYW5KU1hFbGVtZW50TGl0ZXJhbENoaWxkLmpzP2VkM2IiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLmRlZmF1bHQgPSBjbGVhbkpTWEVsZW1lbnRMaXRlcmFsQ2hpbGQ7XG52YXIgX2luZGV4ID0gcmVxdWlyZShcIi4uLy4uL2J1aWxkZXJzL2dlbmVyYXRlZC9pbmRleC5qc1wiKTtcbnZhciBfaW5kZXgyID0gcmVxdWlyZShcIi4uLy4uL2luZGV4LmpzXCIpO1xuZnVuY3Rpb24gY2xlYW5KU1hFbGVtZW50TGl0ZXJhbENoaWxkKGNoaWxkLCBhcmdzKSB7XG4gIGNvbnN0IGxpbmVzID0gY2hpbGQudmFsdWUuc3BsaXQoL1xcclxcbnxcXG58XFxyLyk7XG4gIGxldCBsYXN0Tm9uRW1wdHlMaW5lID0gMDtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBsaW5lcy5sZW5ndGg7IGkrKykge1xuICAgIGlmICgvW14gXFx0XS8uZXhlYyhsaW5lc1tpXSkpIHtcbiAgICAgIGxhc3ROb25FbXB0eUxpbmUgPSBpO1xuICAgIH1cbiAgfVxuICBsZXQgc3RyID0gXCJcIjtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBsaW5lcy5sZW5ndGg7IGkrKykge1xuICAgIGNvbnN0IGxpbmUgPSBsaW5lc1tpXTtcbiAgICBjb25zdCBpc0ZpcnN0TGluZSA9IGkgPT09IDA7XG4gICAgY29uc3QgaXNMYXN0TGluZSA9IGkgPT09IGxpbmVzLmxlbmd0aCAtIDE7XG4gICAgY29uc3QgaXNMYXN0Tm9uRW1wdHlMaW5lID0gaSA9PT0gbGFzdE5vbkVtcHR5TGluZTtcbiAgICBsZXQgdHJpbW1lZExpbmUgPSBsaW5lLnJlcGxhY2UoL1xcdC9nLCBcIiBcIik7XG4gICAgaWYgKCFpc0ZpcnN0TGluZSkge1xuICAgICAgdHJpbW1lZExpbmUgPSB0cmltbWVkTGluZS5yZXBsYWNlKC9eICsvLCBcIlwiKTtcbiAgICB9XG4gICAgaWYgKCFpc0xhc3RMaW5lKSB7XG4gICAgICB0cmltbWVkTGluZSA9IHRyaW1tZWRMaW5lLnJlcGxhY2UoLyArJC8sIFwiXCIpO1xuICAgIH1cbiAgICBpZiAodHJpbW1lZExpbmUpIHtcbiAgICAgIGlmICghaXNMYXN0Tm9uRW1wdHlMaW5lKSB7XG4gICAgICAgIHRyaW1tZWRMaW5lICs9IFwiIFwiO1xuICAgICAgfVxuICAgICAgc3RyICs9IHRyaW1tZWRMaW5lO1xuICAgIH1cbiAgfVxuICBpZiAoc3RyKSBhcmdzLnB1c2goKDAsIF9pbmRleDIuaW5oZXJpdHMpKCgwLCBfaW5kZXguc3RyaW5nTGl0ZXJhbCkoc3RyKSwgY2hpbGQpKTtcbn1cblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y2xlYW5KU1hFbGVtZW50TGl0ZXJhbENoaWxkLmpzLm1hcFxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@babel/types/lib/utils/react/cleanJSXElementLiteralChild.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@babel/types/lib/utils/shallowEqual.js":
/*!*************************************************************!*\
  !*** ./node_modules/@babel/types/lib/utils/shallowEqual.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports[\"default\"] = shallowEqual;\nfunction shallowEqual(actual, expected) {\n  const keys = Object.keys(expected);\n  for (const key of keys) {\n    if (actual[key] !== expected[key]) {\n      return false;\n    }\n  }\n  return true;\n}\n\n//# sourceMappingURL=shallowEqual.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGJhYmVsL3R5cGVzL2xpYi91dGlscy9zaGFsbG93RXF1YWwuanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWIsOENBQTZDO0FBQzdDO0FBQ0EsQ0FBQyxFQUFDO0FBQ0Ysa0JBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9yZXBvLXZpc3VhbGl6ZXIvLi9ub2RlX21vZHVsZXMvQGJhYmVsL3R5cGVzL2xpYi91dGlscy9zaGFsbG93RXF1YWwuanM/ZTI5YSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuZGVmYXVsdCA9IHNoYWxsb3dFcXVhbDtcbmZ1bmN0aW9uIHNoYWxsb3dFcXVhbChhY3R1YWwsIGV4cGVjdGVkKSB7XG4gIGNvbnN0IGtleXMgPSBPYmplY3Qua2V5cyhleHBlY3RlZCk7XG4gIGZvciAoY29uc3Qga2V5IG9mIGtleXMpIHtcbiAgICBpZiAoYWN0dWFsW2tleV0gIT09IGV4cGVjdGVkW2tleV0pIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRydWU7XG59XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXNoYWxsb3dFcXVhbC5qcy5tYXBcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@babel/types/lib/utils/shallowEqual.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@babel/types/lib/validators/buildMatchMemberExpression.js":
/*!********************************************************************************!*\
  !*** ./node_modules/@babel/types/lib/validators/buildMatchMemberExpression.js ***!
  \********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports[\"default\"] = buildMatchMemberExpression;\nvar _matchesPattern = __webpack_require__(/*! ./matchesPattern.js */ \"(ssr)/./node_modules/@babel/types/lib/validators/matchesPattern.js\");\nfunction buildMatchMemberExpression(match, allowPartial) {\n  const parts = match.split(\".\");\n  return member => (0, _matchesPattern.default)(member, parts, allowPartial);\n}\n\n//# sourceMappingURL=buildMatchMemberExpression.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGJhYmVsL3R5cGVzL2xpYi92YWxpZGF0b3JzL2J1aWxkTWF0Y2hNZW1iZXJFeHByZXNzaW9uLmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViLDhDQUE2QztBQUM3QztBQUNBLENBQUMsRUFBQztBQUNGLGtCQUFlO0FBQ2Ysc0JBQXNCLG1CQUFPLENBQUMsK0ZBQXFCO0FBQ25EO0FBQ0E7QUFDQTtBQUNBOztBQUVBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcmVwby12aXN1YWxpemVyLy4vbm9kZV9tb2R1bGVzL0BiYWJlbC90eXBlcy9saWIvdmFsaWRhdG9ycy9idWlsZE1hdGNoTWVtYmVyRXhwcmVzc2lvbi5qcz9hN2E0Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5kZWZhdWx0ID0gYnVpbGRNYXRjaE1lbWJlckV4cHJlc3Npb247XG52YXIgX21hdGNoZXNQYXR0ZXJuID0gcmVxdWlyZShcIi4vbWF0Y2hlc1BhdHRlcm4uanNcIik7XG5mdW5jdGlvbiBidWlsZE1hdGNoTWVtYmVyRXhwcmVzc2lvbihtYXRjaCwgYWxsb3dQYXJ0aWFsKSB7XG4gIGNvbnN0IHBhcnRzID0gbWF0Y2guc3BsaXQoXCIuXCIpO1xuICByZXR1cm4gbWVtYmVyID0+ICgwLCBfbWF0Y2hlc1BhdHRlcm4uZGVmYXVsdCkobWVtYmVyLCBwYXJ0cywgYWxsb3dQYXJ0aWFsKTtcbn1cblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YnVpbGRNYXRjaE1lbWJlckV4cHJlc3Npb24uanMubWFwXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@babel/types/lib/validators/buildMatchMemberExpression.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@babel/types/lib/validators/generated/index.js":
/*!*********************************************************************!*\
  !*** ./node_modules/@babel/types/lib/validators/generated/index.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports.isAccessor = isAccessor;\nexports.isAnyTypeAnnotation = isAnyTypeAnnotation;\nexports.isArgumentPlaceholder = isArgumentPlaceholder;\nexports.isArrayExpression = isArrayExpression;\nexports.isArrayPattern = isArrayPattern;\nexports.isArrayTypeAnnotation = isArrayTypeAnnotation;\nexports.isArrowFunctionExpression = isArrowFunctionExpression;\nexports.isAssignmentExpression = isAssignmentExpression;\nexports.isAssignmentPattern = isAssignmentPattern;\nexports.isAwaitExpression = isAwaitExpression;\nexports.isBigIntLiteral = isBigIntLiteral;\nexports.isBinary = isBinary;\nexports.isBinaryExpression = isBinaryExpression;\nexports.isBindExpression = isBindExpression;\nexports.isBlock = isBlock;\nexports.isBlockParent = isBlockParent;\nexports.isBlockStatement = isBlockStatement;\nexports.isBooleanLiteral = isBooleanLiteral;\nexports.isBooleanLiteralTypeAnnotation = isBooleanLiteralTypeAnnotation;\nexports.isBooleanTypeAnnotation = isBooleanTypeAnnotation;\nexports.isBreakStatement = isBreakStatement;\nexports.isCallExpression = isCallExpression;\nexports.isCatchClause = isCatchClause;\nexports.isClass = isClass;\nexports.isClassAccessorProperty = isClassAccessorProperty;\nexports.isClassBody = isClassBody;\nexports.isClassDeclaration = isClassDeclaration;\nexports.isClassExpression = isClassExpression;\nexports.isClassImplements = isClassImplements;\nexports.isClassMethod = isClassMethod;\nexports.isClassPrivateMethod = isClassPrivateMethod;\nexports.isClassPrivateProperty = isClassPrivateProperty;\nexports.isClassProperty = isClassProperty;\nexports.isCompletionStatement = isCompletionStatement;\nexports.isConditional = isConditional;\nexports.isConditionalExpression = isConditionalExpression;\nexports.isContinueStatement = isContinueStatement;\nexports.isDebuggerStatement = isDebuggerStatement;\nexports.isDecimalLiteral = isDecimalLiteral;\nexports.isDeclaration = isDeclaration;\nexports.isDeclareClass = isDeclareClass;\nexports.isDeclareExportAllDeclaration = isDeclareExportAllDeclaration;\nexports.isDeclareExportDeclaration = isDeclareExportDeclaration;\nexports.isDeclareFunction = isDeclareFunction;\nexports.isDeclareInterface = isDeclareInterface;\nexports.isDeclareModule = isDeclareModule;\nexports.isDeclareModuleExports = isDeclareModuleExports;\nexports.isDeclareOpaqueType = isDeclareOpaqueType;\nexports.isDeclareTypeAlias = isDeclareTypeAlias;\nexports.isDeclareVariable = isDeclareVariable;\nexports.isDeclaredPredicate = isDeclaredPredicate;\nexports.isDecorator = isDecorator;\nexports.isDirective = isDirective;\nexports.isDirectiveLiteral = isDirectiveLiteral;\nexports.isDoExpression = isDoExpression;\nexports.isDoWhileStatement = isDoWhileStatement;\nexports.isEmptyStatement = isEmptyStatement;\nexports.isEmptyTypeAnnotation = isEmptyTypeAnnotation;\nexports.isEnumBody = isEnumBody;\nexports.isEnumBooleanBody = isEnumBooleanBody;\nexports.isEnumBooleanMember = isEnumBooleanMember;\nexports.isEnumDeclaration = isEnumDeclaration;\nexports.isEnumDefaultedMember = isEnumDefaultedMember;\nexports.isEnumMember = isEnumMember;\nexports.isEnumNumberBody = isEnumNumberBody;\nexports.isEnumNumberMember = isEnumNumberMember;\nexports.isEnumStringBody = isEnumStringBody;\nexports.isEnumStringMember = isEnumStringMember;\nexports.isEnumSymbolBody = isEnumSymbolBody;\nexports.isExistsTypeAnnotation = isExistsTypeAnnotation;\nexports.isExportAllDeclaration = isExportAllDeclaration;\nexports.isExportDeclaration = isExportDeclaration;\nexports.isExportDefaultDeclaration = isExportDefaultDeclaration;\nexports.isExportDefaultSpecifier = isExportDefaultSpecifier;\nexports.isExportNamedDeclaration = isExportNamedDeclaration;\nexports.isExportNamespaceSpecifier = isExportNamespaceSpecifier;\nexports.isExportSpecifier = isExportSpecifier;\nexports.isExpression = isExpression;\nexports.isExpressionStatement = isExpressionStatement;\nexports.isExpressionWrapper = isExpressionWrapper;\nexports.isFile = isFile;\nexports.isFlow = isFlow;\nexports.isFlowBaseAnnotation = isFlowBaseAnnotation;\nexports.isFlowDeclaration = isFlowDeclaration;\nexports.isFlowPredicate = isFlowPredicate;\nexports.isFlowType = isFlowType;\nexports.isFor = isFor;\nexports.isForInStatement = isForInStatement;\nexports.isForOfStatement = isForOfStatement;\nexports.isForStatement = isForStatement;\nexports.isForXStatement = isForXStatement;\nexports.isFunction = isFunction;\nexports.isFunctionDeclaration = isFunctionDeclaration;\nexports.isFunctionExpression = isFunctionExpression;\nexports.isFunctionParameter = isFunctionParameter;\nexports.isFunctionParent = isFunctionParent;\nexports.isFunctionTypeAnnotation = isFunctionTypeAnnotation;\nexports.isFunctionTypeParam = isFunctionTypeParam;\nexports.isGenericTypeAnnotation = isGenericTypeAnnotation;\nexports.isIdentifier = isIdentifier;\nexports.isIfStatement = isIfStatement;\nexports.isImmutable = isImmutable;\nexports.isImport = isImport;\nexports.isImportAttribute = isImportAttribute;\nexports.isImportDeclaration = isImportDeclaration;\nexports.isImportDefaultSpecifier = isImportDefaultSpecifier;\nexports.isImportExpression = isImportExpression;\nexports.isImportNamespaceSpecifier = isImportNamespaceSpecifier;\nexports.isImportOrExportDeclaration = isImportOrExportDeclaration;\nexports.isImportSpecifier = isImportSpecifier;\nexports.isIndexedAccessType = isIndexedAccessType;\nexports.isInferredPredicate = isInferredPredicate;\nexports.isInterfaceDeclaration = isInterfaceDeclaration;\nexports.isInterfaceExtends = isInterfaceExtends;\nexports.isInterfaceTypeAnnotation = isInterfaceTypeAnnotation;\nexports.isInterpreterDirective = isInterpreterDirective;\nexports.isIntersectionTypeAnnotation = isIntersectionTypeAnnotation;\nexports.isJSX = isJSX;\nexports.isJSXAttribute = isJSXAttribute;\nexports.isJSXClosingElement = isJSXClosingElement;\nexports.isJSXClosingFragment = isJSXClosingFragment;\nexports.isJSXElement = isJSXElement;\nexports.isJSXEmptyExpression = isJSXEmptyExpression;\nexports.isJSXExpressionContainer = isJSXExpressionContainer;\nexports.isJSXFragment = isJSXFragment;\nexports.isJSXIdentifier = isJSXIdentifier;\nexports.isJSXMemberExpression = isJSXMemberExpression;\nexports.isJSXNamespacedName = isJSXNamespacedName;\nexports.isJSXOpeningElement = isJSXOpeningElement;\nexports.isJSXOpeningFragment = isJSXOpeningFragment;\nexports.isJSXSpreadAttribute = isJSXSpreadAttribute;\nexports.isJSXSpreadChild = isJSXSpreadChild;\nexports.isJSXText = isJSXText;\nexports.isLVal = isLVal;\nexports.isLabeledStatement = isLabeledStatement;\nexports.isLiteral = isLiteral;\nexports.isLogicalExpression = isLogicalExpression;\nexports.isLoop = isLoop;\nexports.isMemberExpression = isMemberExpression;\nexports.isMetaProperty = isMetaProperty;\nexports.isMethod = isMethod;\nexports.isMiscellaneous = isMiscellaneous;\nexports.isMixedTypeAnnotation = isMixedTypeAnnotation;\nexports.isModuleDeclaration = isModuleDeclaration;\nexports.isModuleExpression = isModuleExpression;\nexports.isModuleSpecifier = isModuleSpecifier;\nexports.isNewExpression = isNewExpression;\nexports.isNoop = isNoop;\nexports.isNullLiteral = isNullLiteral;\nexports.isNullLiteralTypeAnnotation = isNullLiteralTypeAnnotation;\nexports.isNullableTypeAnnotation = isNullableTypeAnnotation;\nexports.isNumberLiteral = isNumberLiteral;\nexports.isNumberLiteralTypeAnnotation = isNumberLiteralTypeAnnotation;\nexports.isNumberTypeAnnotation = isNumberTypeAnnotation;\nexports.isNumericLiteral = isNumericLiteral;\nexports.isObjectExpression = isObjectExpression;\nexports.isObjectMember = isObjectMember;\nexports.isObjectMethod = isObjectMethod;\nexports.isObjectPattern = isObjectPattern;\nexports.isObjectProperty = isObjectProperty;\nexports.isObjectTypeAnnotation = isObjectTypeAnnotation;\nexports.isObjectTypeCallProperty = isObjectTypeCallProperty;\nexports.isObjectTypeIndexer = isObjectTypeIndexer;\nexports.isObjectTypeInternalSlot = isObjectTypeInternalSlot;\nexports.isObjectTypeProperty = isObjectTypeProperty;\nexports.isObjectTypeSpreadProperty = isObjectTypeSpreadProperty;\nexports.isOpaqueType = isOpaqueType;\nexports.isOptionalCallExpression = isOptionalCallExpression;\nexports.isOptionalIndexedAccessType = isOptionalIndexedAccessType;\nexports.isOptionalMemberExpression = isOptionalMemberExpression;\nexports.isParenthesizedExpression = isParenthesizedExpression;\nexports.isPattern = isPattern;\nexports.isPatternLike = isPatternLike;\nexports.isPipelineBareFunction = isPipelineBareFunction;\nexports.isPipelinePrimaryTopicReference = isPipelinePrimaryTopicReference;\nexports.isPipelineTopicExpression = isPipelineTopicExpression;\nexports.isPlaceholder = isPlaceholder;\nexports.isPrivate = isPrivate;\nexports.isPrivateName = isPrivateName;\nexports.isProgram = isProgram;\nexports.isProperty = isProperty;\nexports.isPureish = isPureish;\nexports.isQualifiedTypeIdentifier = isQualifiedTypeIdentifier;\nexports.isRecordExpression = isRecordExpression;\nexports.isRegExpLiteral = isRegExpLiteral;\nexports.isRegexLiteral = isRegexLiteral;\nexports.isRestElement = isRestElement;\nexports.isRestProperty = isRestProperty;\nexports.isReturnStatement = isReturnStatement;\nexports.isScopable = isScopable;\nexports.isSequenceExpression = isSequenceExpression;\nexports.isSpreadElement = isSpreadElement;\nexports.isSpreadProperty = isSpreadProperty;\nexports.isStandardized = isStandardized;\nexports.isStatement = isStatement;\nexports.isStaticBlock = isStaticBlock;\nexports.isStringLiteral = isStringLiteral;\nexports.isStringLiteralTypeAnnotation = isStringLiteralTypeAnnotation;\nexports.isStringTypeAnnotation = isStringTypeAnnotation;\nexports.isSuper = isSuper;\nexports.isSwitchCase = isSwitchCase;\nexports.isSwitchStatement = isSwitchStatement;\nexports.isSymbolTypeAnnotation = isSymbolTypeAnnotation;\nexports.isTSAnyKeyword = isTSAnyKeyword;\nexports.isTSArrayType = isTSArrayType;\nexports.isTSAsExpression = isTSAsExpression;\nexports.isTSBaseType = isTSBaseType;\nexports.isTSBigIntKeyword = isTSBigIntKeyword;\nexports.isTSBooleanKeyword = isTSBooleanKeyword;\nexports.isTSCallSignatureDeclaration = isTSCallSignatureDeclaration;\nexports.isTSConditionalType = isTSConditionalType;\nexports.isTSConstructSignatureDeclaration = isTSConstructSignatureDeclaration;\nexports.isTSConstructorType = isTSConstructorType;\nexports.isTSDeclareFunction = isTSDeclareFunction;\nexports.isTSDeclareMethod = isTSDeclareMethod;\nexports.isTSEntityName = isTSEntityName;\nexports.isTSEnumBody = isTSEnumBody;\nexports.isTSEnumDeclaration = isTSEnumDeclaration;\nexports.isTSEnumMember = isTSEnumMember;\nexports.isTSExportAssignment = isTSExportAssignment;\nexports.isTSExpressionWithTypeArguments = isTSExpressionWithTypeArguments;\nexports.isTSExternalModuleReference = isTSExternalModuleReference;\nexports.isTSFunctionType = isTSFunctionType;\nexports.isTSImportEqualsDeclaration = isTSImportEqualsDeclaration;\nexports.isTSImportType = isTSImportType;\nexports.isTSIndexSignature = isTSIndexSignature;\nexports.isTSIndexedAccessType = isTSIndexedAccessType;\nexports.isTSInferType = isTSInferType;\nexports.isTSInstantiationExpression = isTSInstantiationExpression;\nexports.isTSInterfaceBody = isTSInterfaceBody;\nexports.isTSInterfaceDeclaration = isTSInterfaceDeclaration;\nexports.isTSIntersectionType = isTSIntersectionType;\nexports.isTSIntrinsicKeyword = isTSIntrinsicKeyword;\nexports.isTSLiteralType = isTSLiteralType;\nexports.isTSMappedType = isTSMappedType;\nexports.isTSMethodSignature = isTSMethodSignature;\nexports.isTSModuleBlock = isTSModuleBlock;\nexports.isTSModuleDeclaration = isTSModuleDeclaration;\nexports.isTSNamedTupleMember = isTSNamedTupleMember;\nexports.isTSNamespaceExportDeclaration = isTSNamespaceExportDeclaration;\nexports.isTSNeverKeyword = isTSNeverKeyword;\nexports.isTSNonNullExpression = isTSNonNullExpression;\nexports.isTSNullKeyword = isTSNullKeyword;\nexports.isTSNumberKeyword = isTSNumberKeyword;\nexports.isTSObjectKeyword = isTSObjectKeyword;\nexports.isTSOptionalType = isTSOptionalType;\nexports.isTSParameterProperty = isTSParameterProperty;\nexports.isTSParenthesizedType = isTSParenthesizedType;\nexports.isTSPropertySignature = isTSPropertySignature;\nexports.isTSQualifiedName = isTSQualifiedName;\nexports.isTSRestType = isTSRestType;\nexports.isTSSatisfiesExpression = isTSSatisfiesExpression;\nexports.isTSStringKeyword = isTSStringKeyword;\nexports.isTSSymbolKeyword = isTSSymbolKeyword;\nexports.isTSTemplateLiteralType = isTSTemplateLiteralType;\nexports.isTSThisType = isTSThisType;\nexports.isTSTupleType = isTSTupleType;\nexports.isTSType = isTSType;\nexports.isTSTypeAliasDeclaration = isTSTypeAliasDeclaration;\nexports.isTSTypeAnnotation = isTSTypeAnnotation;\nexports.isTSTypeAssertion = isTSTypeAssertion;\nexports.isTSTypeElement = isTSTypeElement;\nexports.isTSTypeLiteral = isTSTypeLiteral;\nexports.isTSTypeOperator = isTSTypeOperator;\nexports.isTSTypeParameter = isTSTypeParameter;\nexports.isTSTypeParameterDeclaration = isTSTypeParameterDeclaration;\nexports.isTSTypeParameterInstantiation = isTSTypeParameterInstantiation;\nexports.isTSTypePredicate = isTSTypePredicate;\nexports.isTSTypeQuery = isTSTypeQuery;\nexports.isTSTypeReference = isTSTypeReference;\nexports.isTSUndefinedKeyword = isTSUndefinedKeyword;\nexports.isTSUnionType = isTSUnionType;\nexports.isTSUnknownKeyword = isTSUnknownKeyword;\nexports.isTSVoidKeyword = isTSVoidKeyword;\nexports.isTaggedTemplateExpression = isTaggedTemplateExpression;\nexports.isTemplateElement = isTemplateElement;\nexports.isTemplateLiteral = isTemplateLiteral;\nexports.isTerminatorless = isTerminatorless;\nexports.isThisExpression = isThisExpression;\nexports.isThisTypeAnnotation = isThisTypeAnnotation;\nexports.isThrowStatement = isThrowStatement;\nexports.isTopicReference = isTopicReference;\nexports.isTryStatement = isTryStatement;\nexports.isTupleExpression = isTupleExpression;\nexports.isTupleTypeAnnotation = isTupleTypeAnnotation;\nexports.isTypeAlias = isTypeAlias;\nexports.isTypeAnnotation = isTypeAnnotation;\nexports.isTypeCastExpression = isTypeCastExpression;\nexports.isTypeParameter = isTypeParameter;\nexports.isTypeParameterDeclaration = isTypeParameterDeclaration;\nexports.isTypeParameterInstantiation = isTypeParameterInstantiation;\nexports.isTypeScript = isTypeScript;\nexports.isTypeofTypeAnnotation = isTypeofTypeAnnotation;\nexports.isUnaryExpression = isUnaryExpression;\nexports.isUnaryLike = isUnaryLike;\nexports.isUnionTypeAnnotation = isUnionTypeAnnotation;\nexports.isUpdateExpression = isUpdateExpression;\nexports.isUserWhitespacable = isUserWhitespacable;\nexports.isV8IntrinsicIdentifier = isV8IntrinsicIdentifier;\nexports.isVariableDeclaration = isVariableDeclaration;\nexports.isVariableDeclarator = isVariableDeclarator;\nexports.isVariance = isVariance;\nexports.isVoidPattern = isVoidPattern;\nexports.isVoidTypeAnnotation = isVoidTypeAnnotation;\nexports.isWhile = isWhile;\nexports.isWhileStatement = isWhileStatement;\nexports.isWithStatement = isWithStatement;\nexports.isYieldExpression = isYieldExpression;\nvar _shallowEqual = __webpack_require__(/*! ../../utils/shallowEqual.js */ \"(ssr)/./node_modules/@babel/types/lib/utils/shallowEqual.js\");\nvar _deprecationWarning = __webpack_require__(/*! ../../utils/deprecationWarning.js */ \"(ssr)/./node_modules/@babel/types/lib/utils/deprecationWarning.js\");\nfunction isArrayExpression(node, opts) {\n  if (!node) return false;\n  if (node.type !== \"ArrayExpression\") return false;\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isAssignmentExpression(node, opts) {\n  if (!node) return false;\n  if (node.type !== \"AssignmentExpression\") return false;\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isBinaryExpression(node, opts) {\n  if (!node) return false;\n  if (node.type !== \"BinaryExpression\") return false;\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isInterpreterDirective(node, opts) {\n  if (!node) return false;\n  if (node.type !== \"InterpreterDirective\") return false;\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isDirective(node, opts) {\n  if (!node) return false;\n  if (node.type !== \"Directive\") return false;\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isDirectiveLiteral(node, opts) {\n  if (!node) return false;\n  if (node.type !== \"DirectiveLiteral\") return false;\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isBlockStatement(node, opts) {\n  if (!node) return false;\n  if (node.type !== \"BlockStatement\") return false;\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isBreakStatement(node, opts) {\n  if (!node) return false;\n  if (node.type !== \"BreakStatement\") return false;\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isCallExpression(node, opts) {\n  if (!node) return false;\n  if (node.type !== \"CallExpression\") return false;\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isCatchClause(node, opts) {\n  if (!node) return false;\n  if (node.type !== \"CatchClause\") return false;\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isConditionalExpression(node, opts) {\n  if (!node) return false;\n  if (node.type !== \"ConditionalExpression\") return false;\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isContinueStatement(node, opts) {\n  if (!node) return false;\n  if (node.type !== \"ContinueStatement\") return false;\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isDebuggerStatement(node, opts) {\n  if (!node) return false;\n  if (node.type !== \"DebuggerStatement\") return false;\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isDoWhileStatement(node, opts) {\n  if (!node) return false;\n  if (node.type !== \"DoWhileStatement\") return false;\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isEmptyStatement(node, opts) {\n  if (!node) return false;\n  if (node.type !== \"EmptyStatement\") return false;\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isExpressionStatement(node, opts) {\n  if (!node) return false;\n  if (node.type !== \"ExpressionStatement\") return false;\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isFile(node, opts) {\n  if (!node) return false;\n  if (node.type !== \"File\") return false;\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isForInStatement(node, opts) {\n  if (!node) return false;\n  if (node.type !== \"ForInStatement\") return false;\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isForStatement(node, opts) {\n  if (!node) return false;\n  if (node.type !== \"ForStatement\") return false;\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isFunctionDeclaration(node, opts) {\n  if (!node) return false;\n  if (node.type !== \"FunctionDeclaration\") return false;\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isFunctionExpression(node, opts) {\n  if (!node) return false;\n  if (node.type !== \"FunctionExpression\") return false;\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isIdentifier(node, opts) {\n  if (!node) return false;\n  if (node.type !== \"Identifier\") return false;\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isIfStatement(node, opts) {\n  if (!node) return false;\n  if (node.type !== \"IfStatement\") return false;\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isLabeledStatement(node, opts) {\n  if (!node) return false;\n  if (node.type !== \"LabeledStatement\") return false;\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isStringLiteral(node, opts) {\n  if (!node) return false;\n  if (node.type !== \"StringLiteral\") return false;\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isNumericLiteral(node, opts) {\n  if (!node) return false;\n  if (node.type !== \"NumericLiteral\") return false;\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isNullLiteral(node, opts) {\n  if (!node) return false;\n  if (node.type !== \"NullLiteral\") return false;\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isBooleanLiteral(node, opts) {\n  if (!node) return false;\n  if (node.type !== \"BooleanLiteral\") return false;\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isRegExpLiteral(node, opts) {\n  if (!node) return false;\n  if (node.type !== \"RegExpLiteral\") return false;\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isLogicalExpression(node, opts) {\n  if (!node) return false;\n  if (node.type !== \"LogicalExpression\") return false;\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isMemberExpression(node, opts) {\n  if (!node) return false;\n  if (node.type !== \"MemberExpression\") return false;\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isNewExpression(node, opts) {\n  if (!node) return false;\n  if (node.type !== \"NewExpression\") return false;\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isProgram(node, opts) {\n  if (!node) return false;\n  if (node.type !== \"Program\") return false;\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isObjectExpression(node, opts) {\n  if (!node) return false;\n  if (node.type !== \"ObjectExpression\") return false;\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isObjectMethod(node, opts) {\n  if (!node) return false;\n  if (node.type !== \"ObjectMethod\") return false;\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isObjectProperty(node, opts) {\n  if (!node) return false;\n  if (node.type !== \"ObjectProperty\") return false;\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isRestElement(node, opts) {\n  if (!node) return false;\n  if (node.type !== \"RestElement\") return false;\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isReturnStatement(node, opts) {\n  if (!node) return false;\n  if (node.type !== \"ReturnStatement\") return false;\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isSequenceExpression(node, opts) {\n  if (!node) return false;\n  if (node.type !== \"SequenceExpression\") return false;\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isParenthesizedExpression(node, opts) {\n  if (!node) return false;\n  if (node.type !== \"ParenthesizedExpression\") return false;\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isSwitchCase(node, opts) {\n  if (!node) return false;\n  if (node.type !== \"SwitchCase\") return false;\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isSwitchStatement(node, opts) {\n  if (!node) return false;\n  if (node.type !== \"SwitchStatement\") return false;\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isThisExpression(node, opts) {\n  if (!node) return false;\n  if (node.type !== \"ThisExpression\") return false;\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isThrowStatement(node, opts) {\n  if (!node) return false;\n  if (node.type !== \"ThrowStatement\") return false;\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isTryStatement(node, opts) {\n  if (!node) return false;\n  if (node.type !== \"TryStatement\") return false;\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isUnaryExpression(node, opts) {\n  if (!node) return false;\n  if (node.type !== \"UnaryExpression\") return false;\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isUpdateExpression(node, opts) {\n  if (!node) return false;\n  if (node.type !== \"UpdateExpression\") return false;\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isVariableDeclaration(node, opts) {\n  if (!node) return false;\n  if (node.type !== \"VariableDeclaration\") return false;\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isVariableDeclarator(node, opts) {\n  if (!node) return false;\n  if (node.type !== \"VariableDeclarator\") return false;\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isWhileStatement(node, opts) {\n  if (!node) return false;\n  if (node.type !== \"WhileStatement\") return false;\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isWithStatement(node, opts) {\n  if (!node) return false;\n  if (node.type !== \"WithStatement\") return false;\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isAssignmentPattern(node, opts) {\n  if (!node) return false;\n  if (node.type !== \"AssignmentPattern\") return false;\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isArrayPattern(node, opts) {\n  if (!node) return false;\n  if (node.type !== \"ArrayPattern\") return false;\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isArrowFunctionExpression(node, opts) {\n  if (!node) return false;\n  if (node.type !== \"ArrowFunctionExpression\") return false;\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isClassBody(node, opts) {\n  if (!node) return false;\n  if (node.type !== \"ClassBody\") return false;\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isClassExpression(node, opts) {\n  if (!node) return false;\n  if (node.type !== \"ClassExpression\") return false;\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isClassDeclaration(node, opts) {\n  if (!node) return false;\n  if (node.type !== \"ClassDeclaration\") return false;\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isExportAllDeclaration(node, opts) {\n  if (!node) return false;\n  if (node.type !== \"ExportAllDeclaration\") return false;\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isExportDefaultDeclaration(node, opts) {\n  if (!node) return false;\n  if (node.type !== \"ExportDefaultDeclaration\") return false;\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isExportNamedDeclaration(node, opts) {\n  if (!node) return false;\n  if (node.type !== \"ExportNamedDeclaration\") return false;\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isExportSpecifier(node, opts) {\n  if (!node) return false;\n  if (node.type !== \"ExportSpecifier\") return false;\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isForOfStatement(node, opts) {\n  if (!node) return false;\n  if (node.type !== \"ForOfStatement\") return false;\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isImportDeclaration(node, opts) {\n  if (!node) return false;\n  if (node.type !== \"ImportDeclaration\") return false;\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isImportDefaultSpecifier(node, opts) {\n  if (!node) return false;\n  if (node.type !== \"ImportDefaultSpecifier\") return false;\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isImportNamespaceSpecifier(node, opts) {\n  if (!node) return false;\n  if (node.type !== \"ImportNamespaceSpecifier\") return false;\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isImportSpecifier(node, opts) {\n  if (!node) return false;\n  if (node.type !== \"ImportSpecifier\") return false;\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isImportExpression(node, opts) {\n  if (!node) return false;\n  if (node.type !== \"ImportExpression\") return false;\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isMetaProperty(node, opts) {\n  if (!node) return false;\n  if (node.type !== \"MetaProperty\") return false;\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isClassMethod(node, opts) {\n  if (!node) return false;\n  if (node.type !== \"ClassMethod\") return false;\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isObjectPattern(node, opts) {\n  if (!node) return false;\n  if (node.type !== \"ObjectPattern\") return false;\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isSpreadElement(node, opts) {\n  if (!node) return false;\n  if (node.type !== \"SpreadElement\") return false;\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isSuper(node, opts) {\n  if (!node) return false;\n  if (node.type !== \"Super\") return false;\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isTaggedTemplateExpression(node, opts) {\n  if (!node) return false;\n  if (node.type !== \"TaggedTemplateExpression\") return false;\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isTemplateElement(node, opts) {\n  if (!node) return false;\n  if (node.type !== \"TemplateElement\") return false;\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isTemplateLiteral(node, opts) {\n  if (!node) return false;\n  if (node.type !== \"TemplateLiteral\") return false;\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isYieldExpression(node, opts) {\n  if (!node) return false;\n  if (node.type !== \"YieldExpression\") return false;\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isAwaitExpression(node, opts) {\n  if (!node) return false;\n  if (node.type !== \"AwaitExpression\") return false;\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isImport(node, opts) {\n  if (!node) return false;\n  if (node.type !== \"Import\") return false;\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isBigIntLiteral(node, opts) {\n  if (!node) return false;\n  if (node.type !== \"BigIntLiteral\") return false;\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isExportNamespaceSpecifier(node, opts) {\n  if (!node) return false;\n  if (node.type !== \"ExportNamespaceSpecifier\") return false;\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isOptionalMemberExpression(node, opts) {\n  if (!node) return false;\n  if (node.type !== \"OptionalMemberExpression\") return false;\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isOptionalCallExpression(node, opts) {\n  if (!node) return false;\n  if (node.type !== \"OptionalCallExpression\") return false;\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isClassProperty(node, opts) {\n  if (!node) return false;\n  if (node.type !== \"ClassProperty\") return false;\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isClassAccessorProperty(node, opts) {\n  if (!node) return false;\n  if (node.type !== \"ClassAccessorProperty\") return false;\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isClassPrivateProperty(node, opts) {\n  if (!node) return false;\n  if (node.type !== \"ClassPrivateProperty\") return false;\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isClassPrivateMethod(node, opts) {\n  if (!node) return false;\n  if (node.type !== \"ClassPrivateMethod\") return false;\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isPrivateName(node, opts) {\n  if (!node) return false;\n  if (node.type !== \"PrivateName\") return false;\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isStaticBlock(node, opts) {\n  if (!node) return false;\n  if (node.type !== \"StaticBlock\") return false;\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isImportAttribute(node, opts) {\n  if (!node) return false;\n  if (node.type !== \"ImportAttribute\") return false;\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isAnyTypeAnnotation(node, opts) {\n  if (!node) return false;\n  if (node.type !== \"AnyTypeAnnotation\") return false;\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isArrayTypeAnnotation(node, opts) {\n  if (!node) return false;\n  if (node.type !== \"ArrayTypeAnnotation\") return false;\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isBooleanTypeAnnotation(node, opts) {\n  if (!node) return false;\n  if (node.type !== \"BooleanTypeAnnotation\") return false;\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isBooleanLiteralTypeAnnotation(node, opts) {\n  if (!node) return false;\n  if (node.type !== \"BooleanLiteralTypeAnnotation\") return false;\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isNullLiteralTypeAnnotation(node, opts) {\n  if (!node) return false;\n  if (node.type !== \"NullLiteralTypeAnnotation\") return false;\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isClassImplements(node, opts) {\n  if (!node) return false;\n  if (node.type !== \"ClassImplements\") return false;\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isDeclareClass(node, opts) {\n  if (!node) return false;\n  if (node.type !== \"DeclareClass\") return false;\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isDeclareFunction(node, opts) {\n  if (!node) return false;\n  if (node.type !== \"DeclareFunction\") return false;\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isDeclareInterface(node, opts) {\n  if (!node) return false;\n  if (node.type !== \"DeclareInterface\") return false;\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isDeclareModule(node, opts) {\n  if (!node) return false;\n  if (node.type !== \"DeclareModule\") return false;\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isDeclareModuleExports(node, opts) {\n  if (!node) return false;\n  if (node.type !== \"DeclareModuleExports\") return false;\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isDeclareTypeAlias(node, opts) {\n  if (!node) return false;\n  if (node.type !== \"DeclareTypeAlias\") return false;\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isDeclareOpaqueType(node, opts) {\n  if (!node) return false;\n  if (node.type !== \"DeclareOpaqueType\") return false;\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isDeclareVariable(node, opts) {\n  if (!node) return false;\n  if (node.type !== \"DeclareVariable\") return false;\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isDeclareExportDeclaration(node, opts) {\n  if (!node) return false;\n  if (node.type !== \"DeclareExportDeclaration\") return false;\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isDeclareExportAllDeclaration(node, opts) {\n  if (!node) return false;\n  if (node.type !== \"DeclareExportAllDeclaration\") return false;\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isDeclaredPredicate(node, opts) {\n  if (!node) return false;\n  if (node.type !== \"DeclaredPredicate\") return false;\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isExistsTypeAnnotation(node, opts) {\n  if (!node) return false;\n  if (node.type !== \"ExistsTypeAnnotation\") return false;\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isFunctionTypeAnnotation(node, opts) {\n  if (!node) return false;\n  if (node.type !== \"FunctionTypeAnnotation\") return false;\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isFunctionTypeParam(node, opts) {\n  if (!node) return false;\n  if (node.type !== \"FunctionTypeParam\") return false;\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isGenericTypeAnnotation(node, opts) {\n  if (!node) return false;\n  if (node.type !== \"GenericTypeAnnotation\") return false;\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isInferredPredicate(node, opts) {\n  if (!node) return false;\n  if (node.type !== \"InferredPredicate\") return false;\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isInterfaceExtends(node, opts) {\n  if (!node) return false;\n  if (node.type !== \"InterfaceExtends\") return false;\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isInterfaceDeclaration(node, opts) {\n  if (!node) return false;\n  if (node.type !== \"InterfaceDeclaration\") return false;\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isInterfaceTypeAnnotation(node, opts) {\n  if (!node) return false;\n  if (node.type !== \"InterfaceTypeAnnotation\") return false;\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isIntersectionTypeAnnotation(node, opts) {\n  if (!node) return false;\n  if (node.type !== \"IntersectionTypeAnnotation\") return false;\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isMixedTypeAnnotation(node, opts) {\n  if (!node) return false;\n  if (node.type !== \"MixedTypeAnnotation\") return false;\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isEmptyTypeAnnotation(node, opts) {\n  if (!node) return false;\n  if (node.type !== \"EmptyTypeAnnotation\") return false;\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isNullableTypeAnnotation(node, opts) {\n  if (!node) return false;\n  if (node.type !== \"NullableTypeAnnotation\") return false;\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isNumberLiteralTypeAnnotation(node, opts) {\n  if (!node) return false;\n  if (node.type !== \"NumberLiteralTypeAnnotation\") return false;\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isNumberTypeAnnotation(node, opts) {\n  if (!node) return false;\n  if (node.type !== \"NumberTypeAnnotation\") return false;\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isObjectTypeAnnotation(node, opts) {\n  if (!node) return false;\n  if (node.type !== \"ObjectTypeAnnotation\") return false;\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isObjectTypeInternalSlot(node, opts) {\n  if (!node) return false;\n  if (node.type !== \"ObjectTypeInternalSlot\") return false;\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isObjectTypeCallProperty(node, opts) {\n  if (!node) return false;\n  if (node.type !== \"ObjectTypeCallProperty\") return false;\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isObjectTypeIndexer(node, opts) {\n  if (!node) return false;\n  if (node.type !== \"ObjectTypeIndexer\") return false;\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isObjectTypeProperty(node, opts) {\n  if (!node) return false;\n  if (node.type !== \"ObjectTypeProperty\") return false;\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isObjectTypeSpreadProperty(node, opts) {\n  if (!node) return false;\n  if (node.type !== \"ObjectTypeSpreadProperty\") return false;\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isOpaqueType(node, opts) {\n  if (!node) return false;\n  if (node.type !== \"OpaqueType\") return false;\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isQualifiedTypeIdentifier(node, opts) {\n  if (!node) return false;\n  if (node.type !== \"QualifiedTypeIdentifier\") return false;\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isStringLiteralTypeAnnotation(node, opts) {\n  if (!node) return false;\n  if (node.type !== \"StringLiteralTypeAnnotation\") return false;\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isStringTypeAnnotation(node, opts) {\n  if (!node) return false;\n  if (node.type !== \"StringTypeAnnotation\") return false;\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isSymbolTypeAnnotation(node, opts) {\n  if (!node) return false;\n  if (node.type !== \"SymbolTypeAnnotation\") return false;\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isThisTypeAnnotation(node, opts) {\n  if (!node) return false;\n  if (node.type !== \"ThisTypeAnnotation\") return false;\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isTupleTypeAnnotation(node, opts) {\n  if (!node) return false;\n  if (node.type !== \"TupleTypeAnnotation\") return false;\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isTypeofTypeAnnotation(node, opts) {\n  if (!node) return false;\n  if (node.type !== \"TypeofTypeAnnotation\") return false;\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isTypeAlias(node, opts) {\n  if (!node) return false;\n  if (node.type !== \"TypeAlias\") return false;\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isTypeAnnotation(node, opts) {\n  if (!node) return false;\n  if (node.type !== \"TypeAnnotation\") return false;\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isTypeCastExpression(node, opts) {\n  if (!node) return false;\n  if (node.type !== \"TypeCastExpression\") return false;\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isTypeParameter(node, opts) {\n  if (!node) return false;\n  if (node.type !== \"TypeParameter\") return false;\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isTypeParameterDeclaration(node, opts) {\n  if (!node) return false;\n  if (node.type !== \"TypeParameterDeclaration\") return false;\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isTypeParameterInstantiation(node, opts) {\n  if (!node) return false;\n  if (node.type !== \"TypeParameterInstantiation\") return false;\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isUnionTypeAnnotation(node, opts) {\n  if (!node) return false;\n  if (node.type !== \"UnionTypeAnnotation\") return false;\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isVariance(node, opts) {\n  if (!node) return false;\n  if (node.type !== \"Variance\") return false;\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isVoidTypeAnnotation(node, opts) {\n  if (!node) return false;\n  if (node.type !== \"VoidTypeAnnotation\") return false;\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isEnumDeclaration(node, opts) {\n  if (!node) return false;\n  if (node.type !== \"EnumDeclaration\") return false;\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isEnumBooleanBody(node, opts) {\n  if (!node) return false;\n  if (node.type !== \"EnumBooleanBody\") return false;\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isEnumNumberBody(node, opts) {\n  if (!node) return false;\n  if (node.type !== \"EnumNumberBody\") return false;\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isEnumStringBody(node, opts) {\n  if (!node) return false;\n  if (node.type !== \"EnumStringBody\") return false;\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isEnumSymbolBody(node, opts) {\n  if (!node) return false;\n  if (node.type !== \"EnumSymbolBody\") return false;\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isEnumBooleanMember(node, opts) {\n  if (!node) return false;\n  if (node.type !== \"EnumBooleanMember\") return false;\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isEnumNumberMember(node, opts) {\n  if (!node) return false;\n  if (node.type !== \"EnumNumberMember\") return false;\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isEnumStringMember(node, opts) {\n  if (!node) return false;\n  if (node.type !== \"EnumStringMember\") return false;\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isEnumDefaultedMember(node, opts) {\n  if (!node) return false;\n  if (node.type !== \"EnumDefaultedMember\") return false;\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isIndexedAccessType(node, opts) {\n  if (!node) return false;\n  if (node.type !== \"IndexedAccessType\") return false;\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isOptionalIndexedAccessType(node, opts) {\n  if (!node) return false;\n  if (node.type !== \"OptionalIndexedAccessType\") return false;\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isJSXAttribute(node, opts) {\n  if (!node) return false;\n  if (node.type !== \"JSXAttribute\") return false;\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isJSXClosingElement(node, opts) {\n  if (!node) return false;\n  if (node.type !== \"JSXClosingElement\") return false;\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isJSXElement(node, opts) {\n  if (!node) return false;\n  if (node.type !== \"JSXElement\") return false;\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isJSXEmptyExpression(node, opts) {\n  if (!node) return false;\n  if (node.type !== \"JSXEmptyExpression\") return false;\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isJSXExpressionContainer(node, opts) {\n  if (!node) return false;\n  if (node.type !== \"JSXExpressionContainer\") return false;\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isJSXSpreadChild(node, opts) {\n  if (!node) return false;\n  if (node.type !== \"JSXSpreadChild\") return false;\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isJSXIdentifier(node, opts) {\n  if (!node) return false;\n  if (node.type !== \"JSXIdentifier\") return false;\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isJSXMemberExpression(node, opts) {\n  if (!node) return false;\n  if (node.type !== \"JSXMemberExpression\") return false;\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isJSXNamespacedName(node, opts) {\n  if (!node) return false;\n  if (node.type !== \"JSXNamespacedName\") return false;\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isJSXOpeningElement(node, opts) {\n  if (!node) return false;\n  if (node.type !== \"JSXOpeningElement\") return false;\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isJSXSpreadAttribute(node, opts) {\n  if (!node) return false;\n  if (node.type !== \"JSXSpreadAttribute\") return false;\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isJSXText(node, opts) {\n  if (!node) return false;\n  if (node.type !== \"JSXText\") return false;\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isJSXFragment(node, opts) {\n  if (!node) return false;\n  if (node.type !== \"JSXFragment\") return false;\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isJSXOpeningFragment(node, opts) {\n  if (!node) return false;\n  if (node.type !== \"JSXOpeningFragment\") return false;\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isJSXClosingFragment(node, opts) {\n  if (!node) return false;\n  if (node.type !== \"JSXClosingFragment\") return false;\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isNoop(node, opts) {\n  if (!node) return false;\n  if (node.type !== \"Noop\") return false;\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isPlaceholder(node, opts) {\n  if (!node) return false;\n  if (node.type !== \"Placeholder\") return false;\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isV8IntrinsicIdentifier(node, opts) {\n  if (!node) return false;\n  if (node.type !== \"V8IntrinsicIdentifier\") return false;\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isArgumentPlaceholder(node, opts) {\n  if (!node) return false;\n  if (node.type !== \"ArgumentPlaceholder\") return false;\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isBindExpression(node, opts) {\n  if (!node) return false;\n  if (node.type !== \"BindExpression\") return false;\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isDecorator(node, opts) {\n  if (!node) return false;\n  if (node.type !== \"Decorator\") return false;\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isDoExpression(node, opts) {\n  if (!node) return false;\n  if (node.type !== \"DoExpression\") return false;\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isExportDefaultSpecifier(node, opts) {\n  if (!node) return false;\n  if (node.type !== \"ExportDefaultSpecifier\") return false;\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isRecordExpression(node, opts) {\n  if (!node) return false;\n  if (node.type !== \"RecordExpression\") return false;\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isTupleExpression(node, opts) {\n  if (!node) return false;\n  if (node.type !== \"TupleExpression\") return false;\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isDecimalLiteral(node, opts) {\n  if (!node) return false;\n  if (node.type !== \"DecimalLiteral\") return false;\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isModuleExpression(node, opts) {\n  if (!node) return false;\n  if (node.type !== \"ModuleExpression\") return false;\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isTopicReference(node, opts) {\n  if (!node) return false;\n  if (node.type !== \"TopicReference\") return false;\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isPipelineTopicExpression(node, opts) {\n  if (!node) return false;\n  if (node.type !== \"PipelineTopicExpression\") return false;\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isPipelineBareFunction(node, opts) {\n  if (!node) return false;\n  if (node.type !== \"PipelineBareFunction\") return false;\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isPipelinePrimaryTopicReference(node, opts) {\n  if (!node) return false;\n  if (node.type !== \"PipelinePrimaryTopicReference\") return false;\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isVoidPattern(node, opts) {\n  if (!node) return false;\n  if (node.type !== \"VoidPattern\") return false;\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isTSParameterProperty(node, opts) {\n  if (!node) return false;\n  if (node.type !== \"TSParameterProperty\") return false;\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isTSDeclareFunction(node, opts) {\n  if (!node) return false;\n  if (node.type !== \"TSDeclareFunction\") return false;\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isTSDeclareMethod(node, opts) {\n  if (!node) return false;\n  if (node.type !== \"TSDeclareMethod\") return false;\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isTSQualifiedName(node, opts) {\n  if (!node) return false;\n  if (node.type !== \"TSQualifiedName\") return false;\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isTSCallSignatureDeclaration(node, opts) {\n  if (!node) return false;\n  if (node.type !== \"TSCallSignatureDeclaration\") return false;\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isTSConstructSignatureDeclaration(node, opts) {\n  if (!node) return false;\n  if (node.type !== \"TSConstructSignatureDeclaration\") return false;\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isTSPropertySignature(node, opts) {\n  if (!node) return false;\n  if (node.type !== \"TSPropertySignature\") return false;\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isTSMethodSignature(node, opts) {\n  if (!node) return false;\n  if (node.type !== \"TSMethodSignature\") return false;\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isTSIndexSignature(node, opts) {\n  if (!node) return false;\n  if (node.type !== \"TSIndexSignature\") return false;\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isTSAnyKeyword(node, opts) {\n  if (!node) return false;\n  if (node.type !== \"TSAnyKeyword\") return false;\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isTSBooleanKeyword(node, opts) {\n  if (!node) return false;\n  if (node.type !== \"TSBooleanKeyword\") return false;\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isTSBigIntKeyword(node, opts) {\n  if (!node) return false;\n  if (node.type !== \"TSBigIntKeyword\") return false;\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isTSIntrinsicKeyword(node, opts) {\n  if (!node) return false;\n  if (node.type !== \"TSIntrinsicKeyword\") return false;\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isTSNeverKeyword(node, opts) {\n  if (!node) return false;\n  if (node.type !== \"TSNeverKeyword\") return false;\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isTSNullKeyword(node, opts) {\n  if (!node) return false;\n  if (node.type !== \"TSNullKeyword\") return false;\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isTSNumberKeyword(node, opts) {\n  if (!node) return false;\n  if (node.type !== \"TSNumberKeyword\") return false;\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isTSObjectKeyword(node, opts) {\n  if (!node) return false;\n  if (node.type !== \"TSObjectKeyword\") return false;\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isTSStringKeyword(node, opts) {\n  if (!node) return false;\n  if (node.type !== \"TSStringKeyword\") return false;\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isTSSymbolKeyword(node, opts) {\n  if (!node) return false;\n  if (node.type !== \"TSSymbolKeyword\") return false;\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isTSUndefinedKeyword(node, opts) {\n  if (!node) return false;\n  if (node.type !== \"TSUndefinedKeyword\") return false;\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isTSUnknownKeyword(node, opts) {\n  if (!node) return false;\n  if (node.type !== \"TSUnknownKeyword\") return false;\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isTSVoidKeyword(node, opts) {\n  if (!node) return false;\n  if (node.type !== \"TSVoidKeyword\") return false;\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isTSThisType(node, opts) {\n  if (!node) return false;\n  if (node.type !== \"TSThisType\") return false;\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isTSFunctionType(node, opts) {\n  if (!node) return false;\n  if (node.type !== \"TSFunctionType\") return false;\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isTSConstructorType(node, opts) {\n  if (!node) return false;\n  if (node.type !== \"TSConstructorType\") return false;\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isTSTypeReference(node, opts) {\n  if (!node) return false;\n  if (node.type !== \"TSTypeReference\") return false;\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isTSTypePredicate(node, opts) {\n  if (!node) return false;\n  if (node.type !== \"TSTypePredicate\") return false;\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isTSTypeQuery(node, opts) {\n  if (!node) return false;\n  if (node.type !== \"TSTypeQuery\") return false;\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isTSTypeLiteral(node, opts) {\n  if (!node) return false;\n  if (node.type !== \"TSTypeLiteral\") return false;\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isTSArrayType(node, opts) {\n  if (!node) return false;\n  if (node.type !== \"TSArrayType\") return false;\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isTSTupleType(node, opts) {\n  if (!node) return false;\n  if (node.type !== \"TSTupleType\") return false;\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isTSOptionalType(node, opts) {\n  if (!node) return false;\n  if (node.type !== \"TSOptionalType\") return false;\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isTSRestType(node, opts) {\n  if (!node) return false;\n  if (node.type !== \"TSRestType\") return false;\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isTSNamedTupleMember(node, opts) {\n  if (!node) return false;\n  if (node.type !== \"TSNamedTupleMember\") return false;\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isTSUnionType(node, opts) {\n  if (!node) return false;\n  if (node.type !== \"TSUnionType\") return false;\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isTSIntersectionType(node, opts) {\n  if (!node) return false;\n  if (node.type !== \"TSIntersectionType\") return false;\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isTSConditionalType(node, opts) {\n  if (!node) return false;\n  if (node.type !== \"TSConditionalType\") return false;\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isTSInferType(node, opts) {\n  if (!node) return false;\n  if (node.type !== \"TSInferType\") return false;\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isTSParenthesizedType(node, opts) {\n  if (!node) return false;\n  if (node.type !== \"TSParenthesizedType\") return false;\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isTSTypeOperator(node, opts) {\n  if (!node) return false;\n  if (node.type !== \"TSTypeOperator\") return false;\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isTSIndexedAccessType(node, opts) {\n  if (!node) return false;\n  if (node.type !== \"TSIndexedAccessType\") return false;\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isTSMappedType(node, opts) {\n  if (!node) return false;\n  if (node.type !== \"TSMappedType\") return false;\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isTSTemplateLiteralType(node, opts) {\n  if (!node) return false;\n  if (node.type !== \"TSTemplateLiteralType\") return false;\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isTSLiteralType(node, opts) {\n  if (!node) return false;\n  if (node.type !== \"TSLiteralType\") return false;\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isTSExpressionWithTypeArguments(node, opts) {\n  if (!node) return false;\n  if (node.type !== \"TSExpressionWithTypeArguments\") return false;\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isTSInterfaceDeclaration(node, opts) {\n  if (!node) return false;\n  if (node.type !== \"TSInterfaceDeclaration\") return false;\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isTSInterfaceBody(node, opts) {\n  if (!node) return false;\n  if (node.type !== \"TSInterfaceBody\") return false;\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isTSTypeAliasDeclaration(node, opts) {\n  if (!node) return false;\n  if (node.type !== \"TSTypeAliasDeclaration\") return false;\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isTSInstantiationExpression(node, opts) {\n  if (!node) return false;\n  if (node.type !== \"TSInstantiationExpression\") return false;\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isTSAsExpression(node, opts) {\n  if (!node) return false;\n  if (node.type !== \"TSAsExpression\") return false;\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isTSSatisfiesExpression(node, opts) {\n  if (!node) return false;\n  if (node.type !== \"TSSatisfiesExpression\") return false;\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isTSTypeAssertion(node, opts) {\n  if (!node) return false;\n  if (node.type !== \"TSTypeAssertion\") return false;\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isTSEnumBody(node, opts) {\n  if (!node) return false;\n  if (node.type !== \"TSEnumBody\") return false;\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isTSEnumDeclaration(node, opts) {\n  if (!node) return false;\n  if (node.type !== \"TSEnumDeclaration\") return false;\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isTSEnumMember(node, opts) {\n  if (!node) return false;\n  if (node.type !== \"TSEnumMember\") return false;\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isTSModuleDeclaration(node, opts) {\n  if (!node) return false;\n  if (node.type !== \"TSModuleDeclaration\") return false;\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isTSModuleBlock(node, opts) {\n  if (!node) return false;\n  if (node.type !== \"TSModuleBlock\") return false;\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isTSImportType(node, opts) {\n  if (!node) return false;\n  if (node.type !== \"TSImportType\") return false;\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isTSImportEqualsDeclaration(node, opts) {\n  if (!node) return false;\n  if (node.type !== \"TSImportEqualsDeclaration\") return false;\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isTSExternalModuleReference(node, opts) {\n  if (!node) return false;\n  if (node.type !== \"TSExternalModuleReference\") return false;\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isTSNonNullExpression(node, opts) {\n  if (!node) return false;\n  if (node.type !== \"TSNonNullExpression\") return false;\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isTSExportAssignment(node, opts) {\n  if (!node) return false;\n  if (node.type !== \"TSExportAssignment\") return false;\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isTSNamespaceExportDeclaration(node, opts) {\n  if (!node) return false;\n  if (node.type !== \"TSNamespaceExportDeclaration\") return false;\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isTSTypeAnnotation(node, opts) {\n  if (!node) return false;\n  if (node.type !== \"TSTypeAnnotation\") return false;\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isTSTypeParameterInstantiation(node, opts) {\n  if (!node) return false;\n  if (node.type !== \"TSTypeParameterInstantiation\") return false;\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isTSTypeParameterDeclaration(node, opts) {\n  if (!node) return false;\n  if (node.type !== \"TSTypeParameterDeclaration\") return false;\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isTSTypeParameter(node, opts) {\n  if (!node) return false;\n  if (node.type !== \"TSTypeParameter\") return false;\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isStandardized(node, opts) {\n  if (!node) return false;\n  switch (node.type) {\n    case \"ArrayExpression\":\n    case \"AssignmentExpression\":\n    case \"BinaryExpression\":\n    case \"InterpreterDirective\":\n    case \"Directive\":\n    case \"DirectiveLiteral\":\n    case \"BlockStatement\":\n    case \"BreakStatement\":\n    case \"CallExpression\":\n    case \"CatchClause\":\n    case \"ConditionalExpression\":\n    case \"ContinueStatement\":\n    case \"DebuggerStatement\":\n    case \"DoWhileStatement\":\n    case \"EmptyStatement\":\n    case \"ExpressionStatement\":\n    case \"File\":\n    case \"ForInStatement\":\n    case \"ForStatement\":\n    case \"FunctionDeclaration\":\n    case \"FunctionExpression\":\n    case \"Identifier\":\n    case \"IfStatement\":\n    case \"LabeledStatement\":\n    case \"StringLiteral\":\n    case \"NumericLiteral\":\n    case \"NullLiteral\":\n    case \"BooleanLiteral\":\n    case \"RegExpLiteral\":\n    case \"LogicalExpression\":\n    case \"MemberExpression\":\n    case \"NewExpression\":\n    case \"Program\":\n    case \"ObjectExpression\":\n    case \"ObjectMethod\":\n    case \"ObjectProperty\":\n    case \"RestElement\":\n    case \"ReturnStatement\":\n    case \"SequenceExpression\":\n    case \"ParenthesizedExpression\":\n    case \"SwitchCase\":\n    case \"SwitchStatement\":\n    case \"ThisExpression\":\n    case \"ThrowStatement\":\n    case \"TryStatement\":\n    case \"UnaryExpression\":\n    case \"UpdateExpression\":\n    case \"VariableDeclaration\":\n    case \"VariableDeclarator\":\n    case \"WhileStatement\":\n    case \"WithStatement\":\n    case \"AssignmentPattern\":\n    case \"ArrayPattern\":\n    case \"ArrowFunctionExpression\":\n    case \"ClassBody\":\n    case \"ClassExpression\":\n    case \"ClassDeclaration\":\n    case \"ExportAllDeclaration\":\n    case \"ExportDefaultDeclaration\":\n    case \"ExportNamedDeclaration\":\n    case \"ExportSpecifier\":\n    case \"ForOfStatement\":\n    case \"ImportDeclaration\":\n    case \"ImportDefaultSpecifier\":\n    case \"ImportNamespaceSpecifier\":\n    case \"ImportSpecifier\":\n    case \"ImportExpression\":\n    case \"MetaProperty\":\n    case \"ClassMethod\":\n    case \"ObjectPattern\":\n    case \"SpreadElement\":\n    case \"Super\":\n    case \"TaggedTemplateExpression\":\n    case \"TemplateElement\":\n    case \"TemplateLiteral\":\n    case \"YieldExpression\":\n    case \"AwaitExpression\":\n    case \"Import\":\n    case \"BigIntLiteral\":\n    case \"ExportNamespaceSpecifier\":\n    case \"OptionalMemberExpression\":\n    case \"OptionalCallExpression\":\n    case \"ClassProperty\":\n    case \"ClassAccessorProperty\":\n    case \"ClassPrivateProperty\":\n    case \"ClassPrivateMethod\":\n    case \"PrivateName\":\n    case \"StaticBlock\":\n    case \"ImportAttribute\":\n      break;\n    case \"Placeholder\":\n      switch (node.expectedNode) {\n        case \"Identifier\":\n        case \"StringLiteral\":\n        case \"BlockStatement\":\n        case \"ClassBody\":\n          break;\n        default:\n          return false;\n      }\n      break;\n    default:\n      return false;\n  }\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isExpression(node, opts) {\n  if (!node) return false;\n  switch (node.type) {\n    case \"ArrayExpression\":\n    case \"AssignmentExpression\":\n    case \"BinaryExpression\":\n    case \"CallExpression\":\n    case \"ConditionalExpression\":\n    case \"FunctionExpression\":\n    case \"Identifier\":\n    case \"StringLiteral\":\n    case \"NumericLiteral\":\n    case \"NullLiteral\":\n    case \"BooleanLiteral\":\n    case \"RegExpLiteral\":\n    case \"LogicalExpression\":\n    case \"MemberExpression\":\n    case \"NewExpression\":\n    case \"ObjectExpression\":\n    case \"SequenceExpression\":\n    case \"ParenthesizedExpression\":\n    case \"ThisExpression\":\n    case \"UnaryExpression\":\n    case \"UpdateExpression\":\n    case \"ArrowFunctionExpression\":\n    case \"ClassExpression\":\n    case \"ImportExpression\":\n    case \"MetaProperty\":\n    case \"Super\":\n    case \"TaggedTemplateExpression\":\n    case \"TemplateLiteral\":\n    case \"YieldExpression\":\n    case \"AwaitExpression\":\n    case \"Import\":\n    case \"BigIntLiteral\":\n    case \"OptionalMemberExpression\":\n    case \"OptionalCallExpression\":\n    case \"TypeCastExpression\":\n    case \"JSXElement\":\n    case \"JSXFragment\":\n    case \"BindExpression\":\n    case \"DoExpression\":\n    case \"RecordExpression\":\n    case \"TupleExpression\":\n    case \"DecimalLiteral\":\n    case \"ModuleExpression\":\n    case \"TopicReference\":\n    case \"PipelineTopicExpression\":\n    case \"PipelineBareFunction\":\n    case \"PipelinePrimaryTopicReference\":\n    case \"TSInstantiationExpression\":\n    case \"TSAsExpression\":\n    case \"TSSatisfiesExpression\":\n    case \"TSTypeAssertion\":\n    case \"TSNonNullExpression\":\n      break;\n    case \"Placeholder\":\n      switch (node.expectedNode) {\n        case \"Expression\":\n        case \"Identifier\":\n        case \"StringLiteral\":\n          break;\n        default:\n          return false;\n      }\n      break;\n    default:\n      return false;\n  }\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isBinary(node, opts) {\n  if (!node) return false;\n  switch (node.type) {\n    case \"BinaryExpression\":\n    case \"LogicalExpression\":\n      break;\n    default:\n      return false;\n  }\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isScopable(node, opts) {\n  if (!node) return false;\n  switch (node.type) {\n    case \"BlockStatement\":\n    case \"CatchClause\":\n    case \"DoWhileStatement\":\n    case \"ForInStatement\":\n    case \"ForStatement\":\n    case \"FunctionDeclaration\":\n    case \"FunctionExpression\":\n    case \"Program\":\n    case \"ObjectMethod\":\n    case \"SwitchStatement\":\n    case \"WhileStatement\":\n    case \"ArrowFunctionExpression\":\n    case \"ClassExpression\":\n    case \"ClassDeclaration\":\n    case \"ForOfStatement\":\n    case \"ClassMethod\":\n    case \"ClassPrivateMethod\":\n    case \"StaticBlock\":\n    case \"TSModuleBlock\":\n      break;\n    case \"Placeholder\":\n      if (node.expectedNode === \"BlockStatement\") break;\n    default:\n      return false;\n  }\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isBlockParent(node, opts) {\n  if (!node) return false;\n  switch (node.type) {\n    case \"BlockStatement\":\n    case \"CatchClause\":\n    case \"DoWhileStatement\":\n    case \"ForInStatement\":\n    case \"ForStatement\":\n    case \"FunctionDeclaration\":\n    case \"FunctionExpression\":\n    case \"Program\":\n    case \"ObjectMethod\":\n    case \"SwitchStatement\":\n    case \"WhileStatement\":\n    case \"ArrowFunctionExpression\":\n    case \"ForOfStatement\":\n    case \"ClassMethod\":\n    case \"ClassPrivateMethod\":\n    case \"StaticBlock\":\n    case \"TSModuleBlock\":\n      break;\n    case \"Placeholder\":\n      if (node.expectedNode === \"BlockStatement\") break;\n    default:\n      return false;\n  }\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isBlock(node, opts) {\n  if (!node) return false;\n  switch (node.type) {\n    case \"BlockStatement\":\n    case \"Program\":\n    case \"TSModuleBlock\":\n      break;\n    case \"Placeholder\":\n      if (node.expectedNode === \"BlockStatement\") break;\n    default:\n      return false;\n  }\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isStatement(node, opts) {\n  if (!node) return false;\n  switch (node.type) {\n    case \"BlockStatement\":\n    case \"BreakStatement\":\n    case \"ContinueStatement\":\n    case \"DebuggerStatement\":\n    case \"DoWhileStatement\":\n    case \"EmptyStatement\":\n    case \"ExpressionStatement\":\n    case \"ForInStatement\":\n    case \"ForStatement\":\n    case \"FunctionDeclaration\":\n    case \"IfStatement\":\n    case \"LabeledStatement\":\n    case \"ReturnStatement\":\n    case \"SwitchStatement\":\n    case \"ThrowStatement\":\n    case \"TryStatement\":\n    case \"VariableDeclaration\":\n    case \"WhileStatement\":\n    case \"WithStatement\":\n    case \"ClassDeclaration\":\n    case \"ExportAllDeclaration\":\n    case \"ExportDefaultDeclaration\":\n    case \"ExportNamedDeclaration\":\n    case \"ForOfStatement\":\n    case \"ImportDeclaration\":\n    case \"DeclareClass\":\n    case \"DeclareFunction\":\n    case \"DeclareInterface\":\n    case \"DeclareModule\":\n    case \"DeclareModuleExports\":\n    case \"DeclareTypeAlias\":\n    case \"DeclareOpaqueType\":\n    case \"DeclareVariable\":\n    case \"DeclareExportDeclaration\":\n    case \"DeclareExportAllDeclaration\":\n    case \"InterfaceDeclaration\":\n    case \"OpaqueType\":\n    case \"TypeAlias\":\n    case \"EnumDeclaration\":\n    case \"TSDeclareFunction\":\n    case \"TSInterfaceDeclaration\":\n    case \"TSTypeAliasDeclaration\":\n    case \"TSEnumDeclaration\":\n    case \"TSModuleDeclaration\":\n    case \"TSImportEqualsDeclaration\":\n    case \"TSExportAssignment\":\n    case \"TSNamespaceExportDeclaration\":\n      break;\n    case \"Placeholder\":\n      switch (node.expectedNode) {\n        case \"Statement\":\n        case \"Declaration\":\n        case \"BlockStatement\":\n          break;\n        default:\n          return false;\n      }\n      break;\n    default:\n      return false;\n  }\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isTerminatorless(node, opts) {\n  if (!node) return false;\n  switch (node.type) {\n    case \"BreakStatement\":\n    case \"ContinueStatement\":\n    case \"ReturnStatement\":\n    case \"ThrowStatement\":\n    case \"YieldExpression\":\n    case \"AwaitExpression\":\n      break;\n    default:\n      return false;\n  }\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isCompletionStatement(node, opts) {\n  if (!node) return false;\n  switch (node.type) {\n    case \"BreakStatement\":\n    case \"ContinueStatement\":\n    case \"ReturnStatement\":\n    case \"ThrowStatement\":\n      break;\n    default:\n      return false;\n  }\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isConditional(node, opts) {\n  if (!node) return false;\n  switch (node.type) {\n    case \"ConditionalExpression\":\n    case \"IfStatement\":\n      break;\n    default:\n      return false;\n  }\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isLoop(node, opts) {\n  if (!node) return false;\n  switch (node.type) {\n    case \"DoWhileStatement\":\n    case \"ForInStatement\":\n    case \"ForStatement\":\n    case \"WhileStatement\":\n    case \"ForOfStatement\":\n      break;\n    default:\n      return false;\n  }\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isWhile(node, opts) {\n  if (!node) return false;\n  switch (node.type) {\n    case \"DoWhileStatement\":\n    case \"WhileStatement\":\n      break;\n    default:\n      return false;\n  }\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isExpressionWrapper(node, opts) {\n  if (!node) return false;\n  switch (node.type) {\n    case \"ExpressionStatement\":\n    case \"ParenthesizedExpression\":\n    case \"TypeCastExpression\":\n      break;\n    default:\n      return false;\n  }\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isFor(node, opts) {\n  if (!node) return false;\n  switch (node.type) {\n    case \"ForInStatement\":\n    case \"ForStatement\":\n    case \"ForOfStatement\":\n      break;\n    default:\n      return false;\n  }\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isForXStatement(node, opts) {\n  if (!node) return false;\n  switch (node.type) {\n    case \"ForInStatement\":\n    case \"ForOfStatement\":\n      break;\n    default:\n      return false;\n  }\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isFunction(node, opts) {\n  if (!node) return false;\n  switch (node.type) {\n    case \"FunctionDeclaration\":\n    case \"FunctionExpression\":\n    case \"ObjectMethod\":\n    case \"ArrowFunctionExpression\":\n    case \"ClassMethod\":\n    case \"ClassPrivateMethod\":\n      break;\n    default:\n      return false;\n  }\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isFunctionParent(node, opts) {\n  if (!node) return false;\n  switch (node.type) {\n    case \"FunctionDeclaration\":\n    case \"FunctionExpression\":\n    case \"ObjectMethod\":\n    case \"ArrowFunctionExpression\":\n    case \"ClassMethod\":\n    case \"ClassPrivateMethod\":\n    case \"StaticBlock\":\n    case \"TSModuleBlock\":\n      break;\n    default:\n      return false;\n  }\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isPureish(node, opts) {\n  if (!node) return false;\n  switch (node.type) {\n    case \"FunctionDeclaration\":\n    case \"FunctionExpression\":\n    case \"StringLiteral\":\n    case \"NumericLiteral\":\n    case \"NullLiteral\":\n    case \"BooleanLiteral\":\n    case \"RegExpLiteral\":\n    case \"ArrowFunctionExpression\":\n    case \"BigIntLiteral\":\n    case \"DecimalLiteral\":\n      break;\n    case \"Placeholder\":\n      if (node.expectedNode === \"StringLiteral\") break;\n    default:\n      return false;\n  }\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isDeclaration(node, opts) {\n  if (!node) return false;\n  switch (node.type) {\n    case \"FunctionDeclaration\":\n    case \"VariableDeclaration\":\n    case \"ClassDeclaration\":\n    case \"ExportAllDeclaration\":\n    case \"ExportDefaultDeclaration\":\n    case \"ExportNamedDeclaration\":\n    case \"ImportDeclaration\":\n    case \"DeclareClass\":\n    case \"DeclareFunction\":\n    case \"DeclareInterface\":\n    case \"DeclareModule\":\n    case \"DeclareModuleExports\":\n    case \"DeclareTypeAlias\":\n    case \"DeclareOpaqueType\":\n    case \"DeclareVariable\":\n    case \"DeclareExportDeclaration\":\n    case \"DeclareExportAllDeclaration\":\n    case \"InterfaceDeclaration\":\n    case \"OpaqueType\":\n    case \"TypeAlias\":\n    case \"EnumDeclaration\":\n    case \"TSDeclareFunction\":\n    case \"TSInterfaceDeclaration\":\n    case \"TSTypeAliasDeclaration\":\n    case \"TSEnumDeclaration\":\n    case \"TSModuleDeclaration\":\n    case \"TSImportEqualsDeclaration\":\n      break;\n    case \"Placeholder\":\n      if (node.expectedNode === \"Declaration\") break;\n    default:\n      return false;\n  }\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isFunctionParameter(node, opts) {\n  if (!node) return false;\n  switch (node.type) {\n    case \"Identifier\":\n    case \"RestElement\":\n    case \"AssignmentPattern\":\n    case \"ArrayPattern\":\n    case \"ObjectPattern\":\n    case \"VoidPattern\":\n      break;\n    case \"Placeholder\":\n      if (node.expectedNode === \"Identifier\") break;\n    default:\n      return false;\n  }\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isPatternLike(node, opts) {\n  if (!node) return false;\n  switch (node.type) {\n    case \"Identifier\":\n    case \"MemberExpression\":\n    case \"RestElement\":\n    case \"AssignmentPattern\":\n    case \"ArrayPattern\":\n    case \"ObjectPattern\":\n    case \"VoidPattern\":\n    case \"TSAsExpression\":\n    case \"TSSatisfiesExpression\":\n    case \"TSTypeAssertion\":\n    case \"TSNonNullExpression\":\n      break;\n    case \"Placeholder\":\n      switch (node.expectedNode) {\n        case \"Pattern\":\n        case \"Identifier\":\n          break;\n        default:\n          return false;\n      }\n      break;\n    default:\n      return false;\n  }\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isLVal(node, opts) {\n  if (!node) return false;\n  switch (node.type) {\n    case \"Identifier\":\n    case \"MemberExpression\":\n    case \"RestElement\":\n    case \"AssignmentPattern\":\n    case \"ArrayPattern\":\n    case \"ObjectPattern\":\n    case \"TSParameterProperty\":\n    case \"TSAsExpression\":\n    case \"TSSatisfiesExpression\":\n    case \"TSTypeAssertion\":\n    case \"TSNonNullExpression\":\n      break;\n    case \"Placeholder\":\n      switch (node.expectedNode) {\n        case \"Pattern\":\n        case \"Identifier\":\n          break;\n        default:\n          return false;\n      }\n      break;\n    default:\n      return false;\n  }\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isTSEntityName(node, opts) {\n  if (!node) return false;\n  switch (node.type) {\n    case \"Identifier\":\n    case \"TSQualifiedName\":\n      break;\n    case \"Placeholder\":\n      if (node.expectedNode === \"Identifier\") break;\n    default:\n      return false;\n  }\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isLiteral(node, opts) {\n  if (!node) return false;\n  switch (node.type) {\n    case \"StringLiteral\":\n    case \"NumericLiteral\":\n    case \"NullLiteral\":\n    case \"BooleanLiteral\":\n    case \"RegExpLiteral\":\n    case \"TemplateLiteral\":\n    case \"BigIntLiteral\":\n    case \"DecimalLiteral\":\n      break;\n    case \"Placeholder\":\n      if (node.expectedNode === \"StringLiteral\") break;\n    default:\n      return false;\n  }\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isImmutable(node, opts) {\n  if (!node) return false;\n  switch (node.type) {\n    case \"StringLiteral\":\n    case \"NumericLiteral\":\n    case \"NullLiteral\":\n    case \"BooleanLiteral\":\n    case \"BigIntLiteral\":\n    case \"JSXAttribute\":\n    case \"JSXClosingElement\":\n    case \"JSXElement\":\n    case \"JSXExpressionContainer\":\n    case \"JSXSpreadChild\":\n    case \"JSXOpeningElement\":\n    case \"JSXText\":\n    case \"JSXFragment\":\n    case \"JSXOpeningFragment\":\n    case \"JSXClosingFragment\":\n    case \"DecimalLiteral\":\n      break;\n    case \"Placeholder\":\n      if (node.expectedNode === \"StringLiteral\") break;\n    default:\n      return false;\n  }\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isUserWhitespacable(node, opts) {\n  if (!node) return false;\n  switch (node.type) {\n    case \"ObjectMethod\":\n    case \"ObjectProperty\":\n    case \"ObjectTypeInternalSlot\":\n    case \"ObjectTypeCallProperty\":\n    case \"ObjectTypeIndexer\":\n    case \"ObjectTypeProperty\":\n    case \"ObjectTypeSpreadProperty\":\n      break;\n    default:\n      return false;\n  }\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isMethod(node, opts) {\n  if (!node) return false;\n  switch (node.type) {\n    case \"ObjectMethod\":\n    case \"ClassMethod\":\n    case \"ClassPrivateMethod\":\n      break;\n    default:\n      return false;\n  }\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isObjectMember(node, opts) {\n  if (!node) return false;\n  switch (node.type) {\n    case \"ObjectMethod\":\n    case \"ObjectProperty\":\n      break;\n    default:\n      return false;\n  }\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isProperty(node, opts) {\n  if (!node) return false;\n  switch (node.type) {\n    case \"ObjectProperty\":\n    case \"ClassProperty\":\n    case \"ClassAccessorProperty\":\n    case \"ClassPrivateProperty\":\n      break;\n    default:\n      return false;\n  }\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isUnaryLike(node, opts) {\n  if (!node) return false;\n  switch (node.type) {\n    case \"UnaryExpression\":\n    case \"SpreadElement\":\n      break;\n    default:\n      return false;\n  }\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isPattern(node, opts) {\n  if (!node) return false;\n  switch (node.type) {\n    case \"AssignmentPattern\":\n    case \"ArrayPattern\":\n    case \"ObjectPattern\":\n    case \"VoidPattern\":\n      break;\n    case \"Placeholder\":\n      if (node.expectedNode === \"Pattern\") break;\n    default:\n      return false;\n  }\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isClass(node, opts) {\n  if (!node) return false;\n  switch (node.type) {\n    case \"ClassExpression\":\n    case \"ClassDeclaration\":\n      break;\n    default:\n      return false;\n  }\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isImportOrExportDeclaration(node, opts) {\n  if (!node) return false;\n  switch (node.type) {\n    case \"ExportAllDeclaration\":\n    case \"ExportDefaultDeclaration\":\n    case \"ExportNamedDeclaration\":\n    case \"ImportDeclaration\":\n      break;\n    default:\n      return false;\n  }\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isExportDeclaration(node, opts) {\n  if (!node) return false;\n  switch (node.type) {\n    case \"ExportAllDeclaration\":\n    case \"ExportDefaultDeclaration\":\n    case \"ExportNamedDeclaration\":\n      break;\n    default:\n      return false;\n  }\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isModuleSpecifier(node, opts) {\n  if (!node) return false;\n  switch (node.type) {\n    case \"ExportSpecifier\":\n    case \"ImportDefaultSpecifier\":\n    case \"ImportNamespaceSpecifier\":\n    case \"ImportSpecifier\":\n    case \"ExportNamespaceSpecifier\":\n    case \"ExportDefaultSpecifier\":\n      break;\n    default:\n      return false;\n  }\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isAccessor(node, opts) {\n  if (!node) return false;\n  switch (node.type) {\n    case \"ClassAccessorProperty\":\n      break;\n    default:\n      return false;\n  }\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isPrivate(node, opts) {\n  if (!node) return false;\n  switch (node.type) {\n    case \"ClassPrivateProperty\":\n    case \"ClassPrivateMethod\":\n    case \"PrivateName\":\n      break;\n    default:\n      return false;\n  }\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isFlow(node, opts) {\n  if (!node) return false;\n  switch (node.type) {\n    case \"AnyTypeAnnotation\":\n    case \"ArrayTypeAnnotation\":\n    case \"BooleanTypeAnnotation\":\n    case \"BooleanLiteralTypeAnnotation\":\n    case \"NullLiteralTypeAnnotation\":\n    case \"ClassImplements\":\n    case \"DeclareClass\":\n    case \"DeclareFunction\":\n    case \"DeclareInterface\":\n    case \"DeclareModule\":\n    case \"DeclareModuleExports\":\n    case \"DeclareTypeAlias\":\n    case \"DeclareOpaqueType\":\n    case \"DeclareVariable\":\n    case \"DeclareExportDeclaration\":\n    case \"DeclareExportAllDeclaration\":\n    case \"DeclaredPredicate\":\n    case \"ExistsTypeAnnotation\":\n    case \"FunctionTypeAnnotation\":\n    case \"FunctionTypeParam\":\n    case \"GenericTypeAnnotation\":\n    case \"InferredPredicate\":\n    case \"InterfaceExtends\":\n    case \"InterfaceDeclaration\":\n    case \"InterfaceTypeAnnotation\":\n    case \"IntersectionTypeAnnotation\":\n    case \"MixedTypeAnnotation\":\n    case \"EmptyTypeAnnotation\":\n    case \"NullableTypeAnnotation\":\n    case \"NumberLiteralTypeAnnotation\":\n    case \"NumberTypeAnnotation\":\n    case \"ObjectTypeAnnotation\":\n    case \"ObjectTypeInternalSlot\":\n    case \"ObjectTypeCallProperty\":\n    case \"ObjectTypeIndexer\":\n    case \"ObjectTypeProperty\":\n    case \"ObjectTypeSpreadProperty\":\n    case \"OpaqueType\":\n    case \"QualifiedTypeIdentifier\":\n    case \"StringLiteralTypeAnnotation\":\n    case \"StringTypeAnnotation\":\n    case \"SymbolTypeAnnotation\":\n    case \"ThisTypeAnnotation\":\n    case \"TupleTypeAnnotation\":\n    case \"TypeofTypeAnnotation\":\n    case \"TypeAlias\":\n    case \"TypeAnnotation\":\n    case \"TypeCastExpression\":\n    case \"TypeParameter\":\n    case \"TypeParameterDeclaration\":\n    case \"TypeParameterInstantiation\":\n    case \"UnionTypeAnnotation\":\n    case \"Variance\":\n    case \"VoidTypeAnnotation\":\n    case \"EnumDeclaration\":\n    case \"EnumBooleanBody\":\n    case \"EnumNumberBody\":\n    case \"EnumStringBody\":\n    case \"EnumSymbolBody\":\n    case \"EnumBooleanMember\":\n    case \"EnumNumberMember\":\n    case \"EnumStringMember\":\n    case \"EnumDefaultedMember\":\n    case \"IndexedAccessType\":\n    case \"OptionalIndexedAccessType\":\n      break;\n    default:\n      return false;\n  }\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isFlowType(node, opts) {\n  if (!node) return false;\n  switch (node.type) {\n    case \"AnyTypeAnnotation\":\n    case \"ArrayTypeAnnotation\":\n    case \"BooleanTypeAnnotation\":\n    case \"BooleanLiteralTypeAnnotation\":\n    case \"NullLiteralTypeAnnotation\":\n    case \"ExistsTypeAnnotation\":\n    case \"FunctionTypeAnnotation\":\n    case \"GenericTypeAnnotation\":\n    case \"InterfaceTypeAnnotation\":\n    case \"IntersectionTypeAnnotation\":\n    case \"MixedTypeAnnotation\":\n    case \"EmptyTypeAnnotation\":\n    case \"NullableTypeAnnotation\":\n    case \"NumberLiteralTypeAnnotation\":\n    case \"NumberTypeAnnotation\":\n    case \"ObjectTypeAnnotation\":\n    case \"StringLiteralTypeAnnotation\":\n    case \"StringTypeAnnotation\":\n    case \"SymbolTypeAnnotation\":\n    case \"ThisTypeAnnotation\":\n    case \"TupleTypeAnnotation\":\n    case \"TypeofTypeAnnotation\":\n    case \"UnionTypeAnnotation\":\n    case \"VoidTypeAnnotation\":\n    case \"IndexedAccessType\":\n    case \"OptionalIndexedAccessType\":\n      break;\n    default:\n      return false;\n  }\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isFlowBaseAnnotation(node, opts) {\n  if (!node) return false;\n  switch (node.type) {\n    case \"AnyTypeAnnotation\":\n    case \"BooleanTypeAnnotation\":\n    case \"NullLiteralTypeAnnotation\":\n    case \"MixedTypeAnnotation\":\n    case \"EmptyTypeAnnotation\":\n    case \"NumberTypeAnnotation\":\n    case \"StringTypeAnnotation\":\n    case \"SymbolTypeAnnotation\":\n    case \"ThisTypeAnnotation\":\n    case \"VoidTypeAnnotation\":\n      break;\n    default:\n      return false;\n  }\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isFlowDeclaration(node, opts) {\n  if (!node) return false;\n  switch (node.type) {\n    case \"DeclareClass\":\n    case \"DeclareFunction\":\n    case \"DeclareInterface\":\n    case \"DeclareModule\":\n    case \"DeclareModuleExports\":\n    case \"DeclareTypeAlias\":\n    case \"DeclareOpaqueType\":\n    case \"DeclareVariable\":\n    case \"DeclareExportDeclaration\":\n    case \"DeclareExportAllDeclaration\":\n    case \"InterfaceDeclaration\":\n    case \"OpaqueType\":\n    case \"TypeAlias\":\n      break;\n    default:\n      return false;\n  }\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isFlowPredicate(node, opts) {\n  if (!node) return false;\n  switch (node.type) {\n    case \"DeclaredPredicate\":\n    case \"InferredPredicate\":\n      break;\n    default:\n      return false;\n  }\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isEnumBody(node, opts) {\n  if (!node) return false;\n  switch (node.type) {\n    case \"EnumBooleanBody\":\n    case \"EnumNumberBody\":\n    case \"EnumStringBody\":\n    case \"EnumSymbolBody\":\n      break;\n    default:\n      return false;\n  }\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isEnumMember(node, opts) {\n  if (!node) return false;\n  switch (node.type) {\n    case \"EnumBooleanMember\":\n    case \"EnumNumberMember\":\n    case \"EnumStringMember\":\n    case \"EnumDefaultedMember\":\n      break;\n    default:\n      return false;\n  }\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isJSX(node, opts) {\n  if (!node) return false;\n  switch (node.type) {\n    case \"JSXAttribute\":\n    case \"JSXClosingElement\":\n    case \"JSXElement\":\n    case \"JSXEmptyExpression\":\n    case \"JSXExpressionContainer\":\n    case \"JSXSpreadChild\":\n    case \"JSXIdentifier\":\n    case \"JSXMemberExpression\":\n    case \"JSXNamespacedName\":\n    case \"JSXOpeningElement\":\n    case \"JSXSpreadAttribute\":\n    case \"JSXText\":\n    case \"JSXFragment\":\n    case \"JSXOpeningFragment\":\n    case \"JSXClosingFragment\":\n      break;\n    default:\n      return false;\n  }\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isMiscellaneous(node, opts) {\n  if (!node) return false;\n  switch (node.type) {\n    case \"Noop\":\n    case \"Placeholder\":\n    case \"V8IntrinsicIdentifier\":\n      break;\n    default:\n      return false;\n  }\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isTypeScript(node, opts) {\n  if (!node) return false;\n  switch (node.type) {\n    case \"TSParameterProperty\":\n    case \"TSDeclareFunction\":\n    case \"TSDeclareMethod\":\n    case \"TSQualifiedName\":\n    case \"TSCallSignatureDeclaration\":\n    case \"TSConstructSignatureDeclaration\":\n    case \"TSPropertySignature\":\n    case \"TSMethodSignature\":\n    case \"TSIndexSignature\":\n    case \"TSAnyKeyword\":\n    case \"TSBooleanKeyword\":\n    case \"TSBigIntKeyword\":\n    case \"TSIntrinsicKeyword\":\n    case \"TSNeverKeyword\":\n    case \"TSNullKeyword\":\n    case \"TSNumberKeyword\":\n    case \"TSObjectKeyword\":\n    case \"TSStringKeyword\":\n    case \"TSSymbolKeyword\":\n    case \"TSUndefinedKeyword\":\n    case \"TSUnknownKeyword\":\n    case \"TSVoidKeyword\":\n    case \"TSThisType\":\n    case \"TSFunctionType\":\n    case \"TSConstructorType\":\n    case \"TSTypeReference\":\n    case \"TSTypePredicate\":\n    case \"TSTypeQuery\":\n    case \"TSTypeLiteral\":\n    case \"TSArrayType\":\n    case \"TSTupleType\":\n    case \"TSOptionalType\":\n    case \"TSRestType\":\n    case \"TSNamedTupleMember\":\n    case \"TSUnionType\":\n    case \"TSIntersectionType\":\n    case \"TSConditionalType\":\n    case \"TSInferType\":\n    case \"TSParenthesizedType\":\n    case \"TSTypeOperator\":\n    case \"TSIndexedAccessType\":\n    case \"TSMappedType\":\n    case \"TSTemplateLiteralType\":\n    case \"TSLiteralType\":\n    case \"TSExpressionWithTypeArguments\":\n    case \"TSInterfaceDeclaration\":\n    case \"TSInterfaceBody\":\n    case \"TSTypeAliasDeclaration\":\n    case \"TSInstantiationExpression\":\n    case \"TSAsExpression\":\n    case \"TSSatisfiesExpression\":\n    case \"TSTypeAssertion\":\n    case \"TSEnumBody\":\n    case \"TSEnumDeclaration\":\n    case \"TSEnumMember\":\n    case \"TSModuleDeclaration\":\n    case \"TSModuleBlock\":\n    case \"TSImportType\":\n    case \"TSImportEqualsDeclaration\":\n    case \"TSExternalModuleReference\":\n    case \"TSNonNullExpression\":\n    case \"TSExportAssignment\":\n    case \"TSNamespaceExportDeclaration\":\n    case \"TSTypeAnnotation\":\n    case \"TSTypeParameterInstantiation\":\n    case \"TSTypeParameterDeclaration\":\n    case \"TSTypeParameter\":\n      break;\n    default:\n      return false;\n  }\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isTSTypeElement(node, opts) {\n  if (!node) return false;\n  switch (node.type) {\n    case \"TSCallSignatureDeclaration\":\n    case \"TSConstructSignatureDeclaration\":\n    case \"TSPropertySignature\":\n    case \"TSMethodSignature\":\n    case \"TSIndexSignature\":\n      break;\n    default:\n      return false;\n  }\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isTSType(node, opts) {\n  if (!node) return false;\n  switch (node.type) {\n    case \"TSAnyKeyword\":\n    case \"TSBooleanKeyword\":\n    case \"TSBigIntKeyword\":\n    case \"TSIntrinsicKeyword\":\n    case \"TSNeverKeyword\":\n    case \"TSNullKeyword\":\n    case \"TSNumberKeyword\":\n    case \"TSObjectKeyword\":\n    case \"TSStringKeyword\":\n    case \"TSSymbolKeyword\":\n    case \"TSUndefinedKeyword\":\n    case \"TSUnknownKeyword\":\n    case \"TSVoidKeyword\":\n    case \"TSThisType\":\n    case \"TSFunctionType\":\n    case \"TSConstructorType\":\n    case \"TSTypeReference\":\n    case \"TSTypePredicate\":\n    case \"TSTypeQuery\":\n    case \"TSTypeLiteral\":\n    case \"TSArrayType\":\n    case \"TSTupleType\":\n    case \"TSOptionalType\":\n    case \"TSRestType\":\n    case \"TSUnionType\":\n    case \"TSIntersectionType\":\n    case \"TSConditionalType\":\n    case \"TSInferType\":\n    case \"TSParenthesizedType\":\n    case \"TSTypeOperator\":\n    case \"TSIndexedAccessType\":\n    case \"TSMappedType\":\n    case \"TSTemplateLiteralType\":\n    case \"TSLiteralType\":\n    case \"TSExpressionWithTypeArguments\":\n    case \"TSImportType\":\n      break;\n    default:\n      return false;\n  }\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isTSBaseType(node, opts) {\n  if (!node) return false;\n  switch (node.type) {\n    case \"TSAnyKeyword\":\n    case \"TSBooleanKeyword\":\n    case \"TSBigIntKeyword\":\n    case \"TSIntrinsicKeyword\":\n    case \"TSNeverKeyword\":\n    case \"TSNullKeyword\":\n    case \"TSNumberKeyword\":\n    case \"TSObjectKeyword\":\n    case \"TSStringKeyword\":\n    case \"TSSymbolKeyword\":\n    case \"TSUndefinedKeyword\":\n    case \"TSUnknownKeyword\":\n    case \"TSVoidKeyword\":\n    case \"TSThisType\":\n    case \"TSTemplateLiteralType\":\n    case \"TSLiteralType\":\n      break;\n    default:\n      return false;\n  }\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isNumberLiteral(node, opts) {\n  (0, _deprecationWarning.default)(\"isNumberLiteral\", \"isNumericLiteral\");\n  if (!node) return false;\n  if (node.type !== \"NumberLiteral\") return false;\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isRegexLiteral(node, opts) {\n  (0, _deprecationWarning.default)(\"isRegexLiteral\", \"isRegExpLiteral\");\n  if (!node) return false;\n  if (node.type !== \"RegexLiteral\") return false;\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isRestProperty(node, opts) {\n  (0, _deprecationWarning.default)(\"isRestProperty\", \"isRestElement\");\n  if (!node) return false;\n  if (node.type !== \"RestProperty\") return false;\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isSpreadProperty(node, opts) {\n  (0, _deprecationWarning.default)(\"isSpreadProperty\", \"isSpreadElement\");\n  if (!node) return false;\n  if (node.type !== \"SpreadProperty\") return false;\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isModuleDeclaration(node, opts) {\n  (0, _deprecationWarning.default)(\"isModuleDeclaration\", \"isImportOrExportDeclaration\");\n  return isImportOrExportDeclaration(node, opts);\n}\n\n//# sourceMappingURL=index.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGJhYmVsL3R5cGVzL2xpYi92YWxpZGF0b3JzL2dlbmVyYXRlZC9pbmRleC5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYiw4Q0FBNkM7QUFDN0M7QUFDQSxDQUFDLEVBQUM7QUFDRixrQkFBa0I7QUFDbEIsMkJBQTJCO0FBQzNCLDZCQUE2QjtBQUM3Qix5QkFBeUI7QUFDekIsc0JBQXNCO0FBQ3RCLDZCQUE2QjtBQUM3QixpQ0FBaUM7QUFDakMsOEJBQThCO0FBQzlCLDJCQUEyQjtBQUMzQix5QkFBeUI7QUFDekIsdUJBQXVCO0FBQ3ZCLGdCQUFnQjtBQUNoQiwwQkFBMEI7QUFDMUIsd0JBQXdCO0FBQ3hCLGVBQWU7QUFDZixxQkFBcUI7QUFDckIsd0JBQXdCO0FBQ3hCLHdCQUF3QjtBQUN4QixzQ0FBc0M7QUFDdEMsK0JBQStCO0FBQy9CLHdCQUF3QjtBQUN4Qix3QkFBd0I7QUFDeEIscUJBQXFCO0FBQ3JCLGVBQWU7QUFDZiwrQkFBK0I7QUFDL0IsbUJBQW1CO0FBQ25CLDBCQUEwQjtBQUMxQix5QkFBeUI7QUFDekIseUJBQXlCO0FBQ3pCLHFCQUFxQjtBQUNyQiw0QkFBNEI7QUFDNUIsOEJBQThCO0FBQzlCLHVCQUF1QjtBQUN2Qiw2QkFBNkI7QUFDN0IscUJBQXFCO0FBQ3JCLCtCQUErQjtBQUMvQiwyQkFBMkI7QUFDM0IsMkJBQTJCO0FBQzNCLHdCQUF3QjtBQUN4QixxQkFBcUI7QUFDckIsc0JBQXNCO0FBQ3RCLHFDQUFxQztBQUNyQyxrQ0FBa0M7QUFDbEMseUJBQXlCO0FBQ3pCLDBCQUEwQjtBQUMxQix1QkFBdUI7QUFDdkIsOEJBQThCO0FBQzlCLDJCQUEyQjtBQUMzQiwwQkFBMEI7QUFDMUIseUJBQXlCO0FBQ3pCLDJCQUEyQjtBQUMzQixtQkFBbUI7QUFDbkIsbUJBQW1CO0FBQ25CLDBCQUEwQjtBQUMxQixzQkFBc0I7QUFDdEIsMEJBQTBCO0FBQzFCLHdCQUF3QjtBQUN4Qiw2QkFBNkI7QUFDN0Isa0JBQWtCO0FBQ2xCLHlCQUF5QjtBQUN6QiwyQkFBMkI7QUFDM0IseUJBQXlCO0FBQ3pCLDZCQUE2QjtBQUM3QixvQkFBb0I7QUFDcEIsd0JBQXdCO0FBQ3hCLDBCQUEwQjtBQUMxQix3QkFBd0I7QUFDeEIsMEJBQTBCO0FBQzFCLHdCQUF3QjtBQUN4Qiw4QkFBOEI7QUFDOUIsOEJBQThCO0FBQzlCLDJCQUEyQjtBQUMzQixrQ0FBa0M7QUFDbEMsZ0NBQWdDO0FBQ2hDLGdDQUFnQztBQUNoQyxrQ0FBa0M7QUFDbEMseUJBQXlCO0FBQ3pCLG9CQUFvQjtBQUNwQiw2QkFBNkI7QUFDN0IsMkJBQTJCO0FBQzNCLGNBQWM7QUFDZCxjQUFjO0FBQ2QsNEJBQTRCO0FBQzVCLHlCQUF5QjtBQUN6Qix1QkFBdUI7QUFDdkIsa0JBQWtCO0FBQ2xCLGFBQWE7QUFDYix3QkFBd0I7QUFDeEIsd0JBQXdCO0FBQ3hCLHNCQUFzQjtBQUN0Qix1QkFBdUI7QUFDdkIsa0JBQWtCO0FBQ2xCLDZCQUE2QjtBQUM3Qiw0QkFBNEI7QUFDNUIsMkJBQTJCO0FBQzNCLHdCQUF3QjtBQUN4QixnQ0FBZ0M7QUFDaEMsMkJBQTJCO0FBQzNCLCtCQUErQjtBQUMvQixvQkFBb0I7QUFDcEIscUJBQXFCO0FBQ3JCLG1CQUFtQjtBQUNuQixnQkFBZ0I7QUFDaEIseUJBQXlCO0FBQ3pCLDJCQUEyQjtBQUMzQixnQ0FBZ0M7QUFDaEMsMEJBQTBCO0FBQzFCLGtDQUFrQztBQUNsQyxtQ0FBbUM7QUFDbkMseUJBQXlCO0FBQ3pCLDJCQUEyQjtBQUMzQiwyQkFBMkI7QUFDM0IsOEJBQThCO0FBQzlCLDBCQUEwQjtBQUMxQixpQ0FBaUM7QUFDakMsOEJBQThCO0FBQzlCLG9DQUFvQztBQUNwQyxhQUFhO0FBQ2Isc0JBQXNCO0FBQ3RCLDJCQUEyQjtBQUMzQiw0QkFBNEI7QUFDNUIsb0JBQW9CO0FBQ3BCLDRCQUE0QjtBQUM1QixnQ0FBZ0M7QUFDaEMscUJBQXFCO0FBQ3JCLHVCQUF1QjtBQUN2Qiw2QkFBNkI7QUFDN0IsMkJBQTJCO0FBQzNCLDJCQUEyQjtBQUMzQiw0QkFBNEI7QUFDNUIsNEJBQTRCO0FBQzVCLHdCQUF3QjtBQUN4QixpQkFBaUI7QUFDakIsY0FBYztBQUNkLDBCQUEwQjtBQUMxQixpQkFBaUI7QUFDakIsMkJBQTJCO0FBQzNCLGNBQWM7QUFDZCwwQkFBMEI7QUFDMUIsc0JBQXNCO0FBQ3RCLGdCQUFnQjtBQUNoQix1QkFBdUI7QUFDdkIsNkJBQTZCO0FBQzdCLDJCQUEyQjtBQUMzQiwwQkFBMEI7QUFDMUIseUJBQXlCO0FBQ3pCLHVCQUF1QjtBQUN2QixjQUFjO0FBQ2QscUJBQXFCO0FBQ3JCLG1DQUFtQztBQUNuQyxnQ0FBZ0M7QUFDaEMsdUJBQXVCO0FBQ3ZCLHFDQUFxQztBQUNyQyw4QkFBOEI7QUFDOUIsd0JBQXdCO0FBQ3hCLDBCQUEwQjtBQUMxQixzQkFBc0I7QUFDdEIsc0JBQXNCO0FBQ3RCLHVCQUF1QjtBQUN2Qix3QkFBd0I7QUFDeEIsOEJBQThCO0FBQzlCLGdDQUFnQztBQUNoQywyQkFBMkI7QUFDM0IsZ0NBQWdDO0FBQ2hDLDRCQUE0QjtBQUM1QixrQ0FBa0M7QUFDbEMsb0JBQW9CO0FBQ3BCLGdDQUFnQztBQUNoQyxtQ0FBbUM7QUFDbkMsa0NBQWtDO0FBQ2xDLGlDQUFpQztBQUNqQyxpQkFBaUI7QUFDakIscUJBQXFCO0FBQ3JCLDhCQUE4QjtBQUM5Qix1Q0FBdUM7QUFDdkMsaUNBQWlDO0FBQ2pDLHFCQUFxQjtBQUNyQixpQkFBaUI7QUFDakIscUJBQXFCO0FBQ3JCLGlCQUFpQjtBQUNqQixrQkFBa0I7QUFDbEIsaUJBQWlCO0FBQ2pCLGlDQUFpQztBQUNqQywwQkFBMEI7QUFDMUIsdUJBQXVCO0FBQ3ZCLHNCQUFzQjtBQUN0QixxQkFBcUI7QUFDckIsc0JBQXNCO0FBQ3RCLHlCQUF5QjtBQUN6QixrQkFBa0I7QUFDbEIsNEJBQTRCO0FBQzVCLHVCQUF1QjtBQUN2Qix3QkFBd0I7QUFDeEIsc0JBQXNCO0FBQ3RCLG1CQUFtQjtBQUNuQixxQkFBcUI7QUFDckIsdUJBQXVCO0FBQ3ZCLHFDQUFxQztBQUNyQyw4QkFBOEI7QUFDOUIsZUFBZTtBQUNmLG9CQUFvQjtBQUNwQix5QkFBeUI7QUFDekIsOEJBQThCO0FBQzlCLHNCQUFzQjtBQUN0QixxQkFBcUI7QUFDckIsd0JBQXdCO0FBQ3hCLG9CQUFvQjtBQUNwQix5QkFBeUI7QUFDekIsMEJBQTBCO0FBQzFCLG9DQUFvQztBQUNwQywyQkFBMkI7QUFDM0IseUNBQXlDO0FBQ3pDLDJCQUEyQjtBQUMzQiwyQkFBMkI7QUFDM0IseUJBQXlCO0FBQ3pCLHNCQUFzQjtBQUN0QixvQkFBb0I7QUFDcEIsMkJBQTJCO0FBQzNCLHNCQUFzQjtBQUN0Qiw0QkFBNEI7QUFDNUIsdUNBQXVDO0FBQ3ZDLG1DQUFtQztBQUNuQyx3QkFBd0I7QUFDeEIsbUNBQW1DO0FBQ25DLHNCQUFzQjtBQUN0QiwwQkFBMEI7QUFDMUIsNkJBQTZCO0FBQzdCLHFCQUFxQjtBQUNyQixtQ0FBbUM7QUFDbkMseUJBQXlCO0FBQ3pCLGdDQUFnQztBQUNoQyw0QkFBNEI7QUFDNUIsNEJBQTRCO0FBQzVCLHVCQUF1QjtBQUN2QixzQkFBc0I7QUFDdEIsMkJBQTJCO0FBQzNCLHVCQUF1QjtBQUN2Qiw2QkFBNkI7QUFDN0IsNEJBQTRCO0FBQzVCLHNDQUFzQztBQUN0Qyx3QkFBd0I7QUFDeEIsNkJBQTZCO0FBQzdCLHVCQUF1QjtBQUN2Qix5QkFBeUI7QUFDekIseUJBQXlCO0FBQ3pCLHdCQUF3QjtBQUN4Qiw2QkFBNkI7QUFDN0IsNkJBQTZCO0FBQzdCLDZCQUE2QjtBQUM3Qix5QkFBeUI7QUFDekIsb0JBQW9CO0FBQ3BCLCtCQUErQjtBQUMvQix5QkFBeUI7QUFDekIseUJBQXlCO0FBQ3pCLCtCQUErQjtBQUMvQixvQkFBb0I7QUFDcEIscUJBQXFCO0FBQ3JCLGdCQUFnQjtBQUNoQixnQ0FBZ0M7QUFDaEMsMEJBQTBCO0FBQzFCLHlCQUF5QjtBQUN6Qix1QkFBdUI7QUFDdkIsdUJBQXVCO0FBQ3ZCLHdCQUF3QjtBQUN4Qix5QkFBeUI7QUFDekIsb0NBQW9DO0FBQ3BDLHNDQUFzQztBQUN0Qyx5QkFBeUI7QUFDekIscUJBQXFCO0FBQ3JCLHlCQUF5QjtBQUN6Qiw0QkFBNEI7QUFDNUIscUJBQXFCO0FBQ3JCLDBCQUEwQjtBQUMxQix1QkFBdUI7QUFDdkIsa0NBQWtDO0FBQ2xDLHlCQUF5QjtBQUN6Qix5QkFBeUI7QUFDekIsd0JBQXdCO0FBQ3hCLHdCQUF3QjtBQUN4Qiw0QkFBNEI7QUFDNUIsd0JBQXdCO0FBQ3hCLHdCQUF3QjtBQUN4QixzQkFBc0I7QUFDdEIseUJBQXlCO0FBQ3pCLDZCQUE2QjtBQUM3QixtQkFBbUI7QUFDbkIsd0JBQXdCO0FBQ3hCLDRCQUE0QjtBQUM1Qix1QkFBdUI7QUFDdkIsa0NBQWtDO0FBQ2xDLG9DQUFvQztBQUNwQyxvQkFBb0I7QUFDcEIsOEJBQThCO0FBQzlCLHlCQUF5QjtBQUN6QixtQkFBbUI7QUFDbkIsNkJBQTZCO0FBQzdCLDBCQUEwQjtBQUMxQiwyQkFBMkI7QUFDM0IsK0JBQStCO0FBQy9CLDZCQUE2QjtBQUM3Qiw0QkFBNEI7QUFDNUIsa0JBQWtCO0FBQ2xCLHFCQUFxQjtBQUNyQiw0QkFBNEI7QUFDNUIsZUFBZTtBQUNmLHdCQUF3QjtBQUN4Qix1QkFBdUI7QUFDdkIseUJBQXlCO0FBQ3pCLG9CQUFvQixtQkFBTyxDQUFDLGdHQUE2QjtBQUN6RCwwQkFBMEIsbUJBQU8sQ0FBQyw0R0FBbUM7QUFDckU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSIsInNvdXJjZXMiOlsid2VicGFjazovL3JlcG8tdmlzdWFsaXplci8uL25vZGVfbW9kdWxlcy9AYmFiZWwvdHlwZXMvbGliL3ZhbGlkYXRvcnMvZ2VuZXJhdGVkL2luZGV4LmpzP2RiNzMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLmlzQWNjZXNzb3IgPSBpc0FjY2Vzc29yO1xuZXhwb3J0cy5pc0FueVR5cGVBbm5vdGF0aW9uID0gaXNBbnlUeXBlQW5ub3RhdGlvbjtcbmV4cG9ydHMuaXNBcmd1bWVudFBsYWNlaG9sZGVyID0gaXNBcmd1bWVudFBsYWNlaG9sZGVyO1xuZXhwb3J0cy5pc0FycmF5RXhwcmVzc2lvbiA9IGlzQXJyYXlFeHByZXNzaW9uO1xuZXhwb3J0cy5pc0FycmF5UGF0dGVybiA9IGlzQXJyYXlQYXR0ZXJuO1xuZXhwb3J0cy5pc0FycmF5VHlwZUFubm90YXRpb24gPSBpc0FycmF5VHlwZUFubm90YXRpb247XG5leHBvcnRzLmlzQXJyb3dGdW5jdGlvbkV4cHJlc3Npb24gPSBpc0Fycm93RnVuY3Rpb25FeHByZXNzaW9uO1xuZXhwb3J0cy5pc0Fzc2lnbm1lbnRFeHByZXNzaW9uID0gaXNBc3NpZ25tZW50RXhwcmVzc2lvbjtcbmV4cG9ydHMuaXNBc3NpZ25tZW50UGF0dGVybiA9IGlzQXNzaWdubWVudFBhdHRlcm47XG5leHBvcnRzLmlzQXdhaXRFeHByZXNzaW9uID0gaXNBd2FpdEV4cHJlc3Npb247XG5leHBvcnRzLmlzQmlnSW50TGl0ZXJhbCA9IGlzQmlnSW50TGl0ZXJhbDtcbmV4cG9ydHMuaXNCaW5hcnkgPSBpc0JpbmFyeTtcbmV4cG9ydHMuaXNCaW5hcnlFeHByZXNzaW9uID0gaXNCaW5hcnlFeHByZXNzaW9uO1xuZXhwb3J0cy5pc0JpbmRFeHByZXNzaW9uID0gaXNCaW5kRXhwcmVzc2lvbjtcbmV4cG9ydHMuaXNCbG9jayA9IGlzQmxvY2s7XG5leHBvcnRzLmlzQmxvY2tQYXJlbnQgPSBpc0Jsb2NrUGFyZW50O1xuZXhwb3J0cy5pc0Jsb2NrU3RhdGVtZW50ID0gaXNCbG9ja1N0YXRlbWVudDtcbmV4cG9ydHMuaXNCb29sZWFuTGl0ZXJhbCA9IGlzQm9vbGVhbkxpdGVyYWw7XG5leHBvcnRzLmlzQm9vbGVhbkxpdGVyYWxUeXBlQW5ub3RhdGlvbiA9IGlzQm9vbGVhbkxpdGVyYWxUeXBlQW5ub3RhdGlvbjtcbmV4cG9ydHMuaXNCb29sZWFuVHlwZUFubm90YXRpb24gPSBpc0Jvb2xlYW5UeXBlQW5ub3RhdGlvbjtcbmV4cG9ydHMuaXNCcmVha1N0YXRlbWVudCA9IGlzQnJlYWtTdGF0ZW1lbnQ7XG5leHBvcnRzLmlzQ2FsbEV4cHJlc3Npb24gPSBpc0NhbGxFeHByZXNzaW9uO1xuZXhwb3J0cy5pc0NhdGNoQ2xhdXNlID0gaXNDYXRjaENsYXVzZTtcbmV4cG9ydHMuaXNDbGFzcyA9IGlzQ2xhc3M7XG5leHBvcnRzLmlzQ2xhc3NBY2Nlc3NvclByb3BlcnR5ID0gaXNDbGFzc0FjY2Vzc29yUHJvcGVydHk7XG5leHBvcnRzLmlzQ2xhc3NCb2R5ID0gaXNDbGFzc0JvZHk7XG5leHBvcnRzLmlzQ2xhc3NEZWNsYXJhdGlvbiA9IGlzQ2xhc3NEZWNsYXJhdGlvbjtcbmV4cG9ydHMuaXNDbGFzc0V4cHJlc3Npb24gPSBpc0NsYXNzRXhwcmVzc2lvbjtcbmV4cG9ydHMuaXNDbGFzc0ltcGxlbWVudHMgPSBpc0NsYXNzSW1wbGVtZW50cztcbmV4cG9ydHMuaXNDbGFzc01ldGhvZCA9IGlzQ2xhc3NNZXRob2Q7XG5leHBvcnRzLmlzQ2xhc3NQcml2YXRlTWV0aG9kID0gaXNDbGFzc1ByaXZhdGVNZXRob2Q7XG5leHBvcnRzLmlzQ2xhc3NQcml2YXRlUHJvcGVydHkgPSBpc0NsYXNzUHJpdmF0ZVByb3BlcnR5O1xuZXhwb3J0cy5pc0NsYXNzUHJvcGVydHkgPSBpc0NsYXNzUHJvcGVydHk7XG5leHBvcnRzLmlzQ29tcGxldGlvblN0YXRlbWVudCA9IGlzQ29tcGxldGlvblN0YXRlbWVudDtcbmV4cG9ydHMuaXNDb25kaXRpb25hbCA9IGlzQ29uZGl0aW9uYWw7XG5leHBvcnRzLmlzQ29uZGl0aW9uYWxFeHByZXNzaW9uID0gaXNDb25kaXRpb25hbEV4cHJlc3Npb247XG5leHBvcnRzLmlzQ29udGludWVTdGF0ZW1lbnQgPSBpc0NvbnRpbnVlU3RhdGVtZW50O1xuZXhwb3J0cy5pc0RlYnVnZ2VyU3RhdGVtZW50ID0gaXNEZWJ1Z2dlclN0YXRlbWVudDtcbmV4cG9ydHMuaXNEZWNpbWFsTGl0ZXJhbCA9IGlzRGVjaW1hbExpdGVyYWw7XG5leHBvcnRzLmlzRGVjbGFyYXRpb24gPSBpc0RlY2xhcmF0aW9uO1xuZXhwb3J0cy5pc0RlY2xhcmVDbGFzcyA9IGlzRGVjbGFyZUNsYXNzO1xuZXhwb3J0cy5pc0RlY2xhcmVFeHBvcnRBbGxEZWNsYXJhdGlvbiA9IGlzRGVjbGFyZUV4cG9ydEFsbERlY2xhcmF0aW9uO1xuZXhwb3J0cy5pc0RlY2xhcmVFeHBvcnREZWNsYXJhdGlvbiA9IGlzRGVjbGFyZUV4cG9ydERlY2xhcmF0aW9uO1xuZXhwb3J0cy5pc0RlY2xhcmVGdW5jdGlvbiA9IGlzRGVjbGFyZUZ1bmN0aW9uO1xuZXhwb3J0cy5pc0RlY2xhcmVJbnRlcmZhY2UgPSBpc0RlY2xhcmVJbnRlcmZhY2U7XG5leHBvcnRzLmlzRGVjbGFyZU1vZHVsZSA9IGlzRGVjbGFyZU1vZHVsZTtcbmV4cG9ydHMuaXNEZWNsYXJlTW9kdWxlRXhwb3J0cyA9IGlzRGVjbGFyZU1vZHVsZUV4cG9ydHM7XG5leHBvcnRzLmlzRGVjbGFyZU9wYXF1ZVR5cGUgPSBpc0RlY2xhcmVPcGFxdWVUeXBlO1xuZXhwb3J0cy5pc0RlY2xhcmVUeXBlQWxpYXMgPSBpc0RlY2xhcmVUeXBlQWxpYXM7XG5leHBvcnRzLmlzRGVjbGFyZVZhcmlhYmxlID0gaXNEZWNsYXJlVmFyaWFibGU7XG5leHBvcnRzLmlzRGVjbGFyZWRQcmVkaWNhdGUgPSBpc0RlY2xhcmVkUHJlZGljYXRlO1xuZXhwb3J0cy5pc0RlY29yYXRvciA9IGlzRGVjb3JhdG9yO1xuZXhwb3J0cy5pc0RpcmVjdGl2ZSA9IGlzRGlyZWN0aXZlO1xuZXhwb3J0cy5pc0RpcmVjdGl2ZUxpdGVyYWwgPSBpc0RpcmVjdGl2ZUxpdGVyYWw7XG5leHBvcnRzLmlzRG9FeHByZXNzaW9uID0gaXNEb0V4cHJlc3Npb247XG5leHBvcnRzLmlzRG9XaGlsZVN0YXRlbWVudCA9IGlzRG9XaGlsZVN0YXRlbWVudDtcbmV4cG9ydHMuaXNFbXB0eVN0YXRlbWVudCA9IGlzRW1wdHlTdGF0ZW1lbnQ7XG5leHBvcnRzLmlzRW1wdHlUeXBlQW5ub3RhdGlvbiA9IGlzRW1wdHlUeXBlQW5ub3RhdGlvbjtcbmV4cG9ydHMuaXNFbnVtQm9keSA9IGlzRW51bUJvZHk7XG5leHBvcnRzLmlzRW51bUJvb2xlYW5Cb2R5ID0gaXNFbnVtQm9vbGVhbkJvZHk7XG5leHBvcnRzLmlzRW51bUJvb2xlYW5NZW1iZXIgPSBpc0VudW1Cb29sZWFuTWVtYmVyO1xuZXhwb3J0cy5pc0VudW1EZWNsYXJhdGlvbiA9IGlzRW51bURlY2xhcmF0aW9uO1xuZXhwb3J0cy5pc0VudW1EZWZhdWx0ZWRNZW1iZXIgPSBpc0VudW1EZWZhdWx0ZWRNZW1iZXI7XG5leHBvcnRzLmlzRW51bU1lbWJlciA9IGlzRW51bU1lbWJlcjtcbmV4cG9ydHMuaXNFbnVtTnVtYmVyQm9keSA9IGlzRW51bU51bWJlckJvZHk7XG5leHBvcnRzLmlzRW51bU51bWJlck1lbWJlciA9IGlzRW51bU51bWJlck1lbWJlcjtcbmV4cG9ydHMuaXNFbnVtU3RyaW5nQm9keSA9IGlzRW51bVN0cmluZ0JvZHk7XG5leHBvcnRzLmlzRW51bVN0cmluZ01lbWJlciA9IGlzRW51bVN0cmluZ01lbWJlcjtcbmV4cG9ydHMuaXNFbnVtU3ltYm9sQm9keSA9IGlzRW51bVN5bWJvbEJvZHk7XG5leHBvcnRzLmlzRXhpc3RzVHlwZUFubm90YXRpb24gPSBpc0V4aXN0c1R5cGVBbm5vdGF0aW9uO1xuZXhwb3J0cy5pc0V4cG9ydEFsbERlY2xhcmF0aW9uID0gaXNFeHBvcnRBbGxEZWNsYXJhdGlvbjtcbmV4cG9ydHMuaXNFeHBvcnREZWNsYXJhdGlvbiA9IGlzRXhwb3J0RGVjbGFyYXRpb247XG5leHBvcnRzLmlzRXhwb3J0RGVmYXVsdERlY2xhcmF0aW9uID0gaXNFeHBvcnREZWZhdWx0RGVjbGFyYXRpb247XG5leHBvcnRzLmlzRXhwb3J0RGVmYXVsdFNwZWNpZmllciA9IGlzRXhwb3J0RGVmYXVsdFNwZWNpZmllcjtcbmV4cG9ydHMuaXNFeHBvcnROYW1lZERlY2xhcmF0aW9uID0gaXNFeHBvcnROYW1lZERlY2xhcmF0aW9uO1xuZXhwb3J0cy5pc0V4cG9ydE5hbWVzcGFjZVNwZWNpZmllciA9IGlzRXhwb3J0TmFtZXNwYWNlU3BlY2lmaWVyO1xuZXhwb3J0cy5pc0V4cG9ydFNwZWNpZmllciA9IGlzRXhwb3J0U3BlY2lmaWVyO1xuZXhwb3J0cy5pc0V4cHJlc3Npb24gPSBpc0V4cHJlc3Npb247XG5leHBvcnRzLmlzRXhwcmVzc2lvblN0YXRlbWVudCA9IGlzRXhwcmVzc2lvblN0YXRlbWVudDtcbmV4cG9ydHMuaXNFeHByZXNzaW9uV3JhcHBlciA9IGlzRXhwcmVzc2lvbldyYXBwZXI7XG5leHBvcnRzLmlzRmlsZSA9IGlzRmlsZTtcbmV4cG9ydHMuaXNGbG93ID0gaXNGbG93O1xuZXhwb3J0cy5pc0Zsb3dCYXNlQW5ub3RhdGlvbiA9IGlzRmxvd0Jhc2VBbm5vdGF0aW9uO1xuZXhwb3J0cy5pc0Zsb3dEZWNsYXJhdGlvbiA9IGlzRmxvd0RlY2xhcmF0aW9uO1xuZXhwb3J0cy5pc0Zsb3dQcmVkaWNhdGUgPSBpc0Zsb3dQcmVkaWNhdGU7XG5leHBvcnRzLmlzRmxvd1R5cGUgPSBpc0Zsb3dUeXBlO1xuZXhwb3J0cy5pc0ZvciA9IGlzRm9yO1xuZXhwb3J0cy5pc0ZvckluU3RhdGVtZW50ID0gaXNGb3JJblN0YXRlbWVudDtcbmV4cG9ydHMuaXNGb3JPZlN0YXRlbWVudCA9IGlzRm9yT2ZTdGF0ZW1lbnQ7XG5leHBvcnRzLmlzRm9yU3RhdGVtZW50ID0gaXNGb3JTdGF0ZW1lbnQ7XG5leHBvcnRzLmlzRm9yWFN0YXRlbWVudCA9IGlzRm9yWFN0YXRlbWVudDtcbmV4cG9ydHMuaXNGdW5jdGlvbiA9IGlzRnVuY3Rpb247XG5leHBvcnRzLmlzRnVuY3Rpb25EZWNsYXJhdGlvbiA9IGlzRnVuY3Rpb25EZWNsYXJhdGlvbjtcbmV4cG9ydHMuaXNGdW5jdGlvbkV4cHJlc3Npb24gPSBpc0Z1bmN0aW9uRXhwcmVzc2lvbjtcbmV4cG9ydHMuaXNGdW5jdGlvblBhcmFtZXRlciA9IGlzRnVuY3Rpb25QYXJhbWV0ZXI7XG5leHBvcnRzLmlzRnVuY3Rpb25QYXJlbnQgPSBpc0Z1bmN0aW9uUGFyZW50O1xuZXhwb3J0cy5pc0Z1bmN0aW9uVHlwZUFubm90YXRpb24gPSBpc0Z1bmN0aW9uVHlwZUFubm90YXRpb247XG5leHBvcnRzLmlzRnVuY3Rpb25UeXBlUGFyYW0gPSBpc0Z1bmN0aW9uVHlwZVBhcmFtO1xuZXhwb3J0cy5pc0dlbmVyaWNUeXBlQW5ub3RhdGlvbiA9IGlzR2VuZXJpY1R5cGVBbm5vdGF0aW9uO1xuZXhwb3J0cy5pc0lkZW50aWZpZXIgPSBpc0lkZW50aWZpZXI7XG5leHBvcnRzLmlzSWZTdGF0ZW1lbnQgPSBpc0lmU3RhdGVtZW50O1xuZXhwb3J0cy5pc0ltbXV0YWJsZSA9IGlzSW1tdXRhYmxlO1xuZXhwb3J0cy5pc0ltcG9ydCA9IGlzSW1wb3J0O1xuZXhwb3J0cy5pc0ltcG9ydEF0dHJpYnV0ZSA9IGlzSW1wb3J0QXR0cmlidXRlO1xuZXhwb3J0cy5pc0ltcG9ydERlY2xhcmF0aW9uID0gaXNJbXBvcnREZWNsYXJhdGlvbjtcbmV4cG9ydHMuaXNJbXBvcnREZWZhdWx0U3BlY2lmaWVyID0gaXNJbXBvcnREZWZhdWx0U3BlY2lmaWVyO1xuZXhwb3J0cy5pc0ltcG9ydEV4cHJlc3Npb24gPSBpc0ltcG9ydEV4cHJlc3Npb247XG5leHBvcnRzLmlzSW1wb3J0TmFtZXNwYWNlU3BlY2lmaWVyID0gaXNJbXBvcnROYW1lc3BhY2VTcGVjaWZpZXI7XG5leHBvcnRzLmlzSW1wb3J0T3JFeHBvcnREZWNsYXJhdGlvbiA9IGlzSW1wb3J0T3JFeHBvcnREZWNsYXJhdGlvbjtcbmV4cG9ydHMuaXNJbXBvcnRTcGVjaWZpZXIgPSBpc0ltcG9ydFNwZWNpZmllcjtcbmV4cG9ydHMuaXNJbmRleGVkQWNjZXNzVHlwZSA9IGlzSW5kZXhlZEFjY2Vzc1R5cGU7XG5leHBvcnRzLmlzSW5mZXJyZWRQcmVkaWNhdGUgPSBpc0luZmVycmVkUHJlZGljYXRlO1xuZXhwb3J0cy5pc0ludGVyZmFjZURlY2xhcmF0aW9uID0gaXNJbnRlcmZhY2VEZWNsYXJhdGlvbjtcbmV4cG9ydHMuaXNJbnRlcmZhY2VFeHRlbmRzID0gaXNJbnRlcmZhY2VFeHRlbmRzO1xuZXhwb3J0cy5pc0ludGVyZmFjZVR5cGVBbm5vdGF0aW9uID0gaXNJbnRlcmZhY2VUeXBlQW5ub3RhdGlvbjtcbmV4cG9ydHMuaXNJbnRlcnByZXRlckRpcmVjdGl2ZSA9IGlzSW50ZXJwcmV0ZXJEaXJlY3RpdmU7XG5leHBvcnRzLmlzSW50ZXJzZWN0aW9uVHlwZUFubm90YXRpb24gPSBpc0ludGVyc2VjdGlvblR5cGVBbm5vdGF0aW9uO1xuZXhwb3J0cy5pc0pTWCA9IGlzSlNYO1xuZXhwb3J0cy5pc0pTWEF0dHJpYnV0ZSA9IGlzSlNYQXR0cmlidXRlO1xuZXhwb3J0cy5pc0pTWENsb3NpbmdFbGVtZW50ID0gaXNKU1hDbG9zaW5nRWxlbWVudDtcbmV4cG9ydHMuaXNKU1hDbG9zaW5nRnJhZ21lbnQgPSBpc0pTWENsb3NpbmdGcmFnbWVudDtcbmV4cG9ydHMuaXNKU1hFbGVtZW50ID0gaXNKU1hFbGVtZW50O1xuZXhwb3J0cy5pc0pTWEVtcHR5RXhwcmVzc2lvbiA9IGlzSlNYRW1wdHlFeHByZXNzaW9uO1xuZXhwb3J0cy5pc0pTWEV4cHJlc3Npb25Db250YWluZXIgPSBpc0pTWEV4cHJlc3Npb25Db250YWluZXI7XG5leHBvcnRzLmlzSlNYRnJhZ21lbnQgPSBpc0pTWEZyYWdtZW50O1xuZXhwb3J0cy5pc0pTWElkZW50aWZpZXIgPSBpc0pTWElkZW50aWZpZXI7XG5leHBvcnRzLmlzSlNYTWVtYmVyRXhwcmVzc2lvbiA9IGlzSlNYTWVtYmVyRXhwcmVzc2lvbjtcbmV4cG9ydHMuaXNKU1hOYW1lc3BhY2VkTmFtZSA9IGlzSlNYTmFtZXNwYWNlZE5hbWU7XG5leHBvcnRzLmlzSlNYT3BlbmluZ0VsZW1lbnQgPSBpc0pTWE9wZW5pbmdFbGVtZW50O1xuZXhwb3J0cy5pc0pTWE9wZW5pbmdGcmFnbWVudCA9IGlzSlNYT3BlbmluZ0ZyYWdtZW50O1xuZXhwb3J0cy5pc0pTWFNwcmVhZEF0dHJpYnV0ZSA9IGlzSlNYU3ByZWFkQXR0cmlidXRlO1xuZXhwb3J0cy5pc0pTWFNwcmVhZENoaWxkID0gaXNKU1hTcHJlYWRDaGlsZDtcbmV4cG9ydHMuaXNKU1hUZXh0ID0gaXNKU1hUZXh0O1xuZXhwb3J0cy5pc0xWYWwgPSBpc0xWYWw7XG5leHBvcnRzLmlzTGFiZWxlZFN0YXRlbWVudCA9IGlzTGFiZWxlZFN0YXRlbWVudDtcbmV4cG9ydHMuaXNMaXRlcmFsID0gaXNMaXRlcmFsO1xuZXhwb3J0cy5pc0xvZ2ljYWxFeHByZXNzaW9uID0gaXNMb2dpY2FsRXhwcmVzc2lvbjtcbmV4cG9ydHMuaXNMb29wID0gaXNMb29wO1xuZXhwb3J0cy5pc01lbWJlckV4cHJlc3Npb24gPSBpc01lbWJlckV4cHJlc3Npb247XG5leHBvcnRzLmlzTWV0YVByb3BlcnR5ID0gaXNNZXRhUHJvcGVydHk7XG5leHBvcnRzLmlzTWV0aG9kID0gaXNNZXRob2Q7XG5leHBvcnRzLmlzTWlzY2VsbGFuZW91cyA9IGlzTWlzY2VsbGFuZW91cztcbmV4cG9ydHMuaXNNaXhlZFR5cGVBbm5vdGF0aW9uID0gaXNNaXhlZFR5cGVBbm5vdGF0aW9uO1xuZXhwb3J0cy5pc01vZHVsZURlY2xhcmF0aW9uID0gaXNNb2R1bGVEZWNsYXJhdGlvbjtcbmV4cG9ydHMuaXNNb2R1bGVFeHByZXNzaW9uID0gaXNNb2R1bGVFeHByZXNzaW9uO1xuZXhwb3J0cy5pc01vZHVsZVNwZWNpZmllciA9IGlzTW9kdWxlU3BlY2lmaWVyO1xuZXhwb3J0cy5pc05ld0V4cHJlc3Npb24gPSBpc05ld0V4cHJlc3Npb247XG5leHBvcnRzLmlzTm9vcCA9IGlzTm9vcDtcbmV4cG9ydHMuaXNOdWxsTGl0ZXJhbCA9IGlzTnVsbExpdGVyYWw7XG5leHBvcnRzLmlzTnVsbExpdGVyYWxUeXBlQW5ub3RhdGlvbiA9IGlzTnVsbExpdGVyYWxUeXBlQW5ub3RhdGlvbjtcbmV4cG9ydHMuaXNOdWxsYWJsZVR5cGVBbm5vdGF0aW9uID0gaXNOdWxsYWJsZVR5cGVBbm5vdGF0aW9uO1xuZXhwb3J0cy5pc051bWJlckxpdGVyYWwgPSBpc051bWJlckxpdGVyYWw7XG5leHBvcnRzLmlzTnVtYmVyTGl0ZXJhbFR5cGVBbm5vdGF0aW9uID0gaXNOdW1iZXJMaXRlcmFsVHlwZUFubm90YXRpb247XG5leHBvcnRzLmlzTnVtYmVyVHlwZUFubm90YXRpb24gPSBpc051bWJlclR5cGVBbm5vdGF0aW9uO1xuZXhwb3J0cy5pc051bWVyaWNMaXRlcmFsID0gaXNOdW1lcmljTGl0ZXJhbDtcbmV4cG9ydHMuaXNPYmplY3RFeHByZXNzaW9uID0gaXNPYmplY3RFeHByZXNzaW9uO1xuZXhwb3J0cy5pc09iamVjdE1lbWJlciA9IGlzT2JqZWN0TWVtYmVyO1xuZXhwb3J0cy5pc09iamVjdE1ldGhvZCA9IGlzT2JqZWN0TWV0aG9kO1xuZXhwb3J0cy5pc09iamVjdFBhdHRlcm4gPSBpc09iamVjdFBhdHRlcm47XG5leHBvcnRzLmlzT2JqZWN0UHJvcGVydHkgPSBpc09iamVjdFByb3BlcnR5O1xuZXhwb3J0cy5pc09iamVjdFR5cGVBbm5vdGF0aW9uID0gaXNPYmplY3RUeXBlQW5ub3RhdGlvbjtcbmV4cG9ydHMuaXNPYmplY3RUeXBlQ2FsbFByb3BlcnR5ID0gaXNPYmplY3RUeXBlQ2FsbFByb3BlcnR5O1xuZXhwb3J0cy5pc09iamVjdFR5cGVJbmRleGVyID0gaXNPYmplY3RUeXBlSW5kZXhlcjtcbmV4cG9ydHMuaXNPYmplY3RUeXBlSW50ZXJuYWxTbG90ID0gaXNPYmplY3RUeXBlSW50ZXJuYWxTbG90O1xuZXhwb3J0cy5pc09iamVjdFR5cGVQcm9wZXJ0eSA9IGlzT2JqZWN0VHlwZVByb3BlcnR5O1xuZXhwb3J0cy5pc09iamVjdFR5cGVTcHJlYWRQcm9wZXJ0eSA9IGlzT2JqZWN0VHlwZVNwcmVhZFByb3BlcnR5O1xuZXhwb3J0cy5pc09wYXF1ZVR5cGUgPSBpc09wYXF1ZVR5cGU7XG5leHBvcnRzLmlzT3B0aW9uYWxDYWxsRXhwcmVzc2lvbiA9IGlzT3B0aW9uYWxDYWxsRXhwcmVzc2lvbjtcbmV4cG9ydHMuaXNPcHRpb25hbEluZGV4ZWRBY2Nlc3NUeXBlID0gaXNPcHRpb25hbEluZGV4ZWRBY2Nlc3NUeXBlO1xuZXhwb3J0cy5pc09wdGlvbmFsTWVtYmVyRXhwcmVzc2lvbiA9IGlzT3B0aW9uYWxNZW1iZXJFeHByZXNzaW9uO1xuZXhwb3J0cy5pc1BhcmVudGhlc2l6ZWRFeHByZXNzaW9uID0gaXNQYXJlbnRoZXNpemVkRXhwcmVzc2lvbjtcbmV4cG9ydHMuaXNQYXR0ZXJuID0gaXNQYXR0ZXJuO1xuZXhwb3J0cy5pc1BhdHRlcm5MaWtlID0gaXNQYXR0ZXJuTGlrZTtcbmV4cG9ydHMuaXNQaXBlbGluZUJhcmVGdW5jdGlvbiA9IGlzUGlwZWxpbmVCYXJlRnVuY3Rpb247XG5leHBvcnRzLmlzUGlwZWxpbmVQcmltYXJ5VG9waWNSZWZlcmVuY2UgPSBpc1BpcGVsaW5lUHJpbWFyeVRvcGljUmVmZXJlbmNlO1xuZXhwb3J0cy5pc1BpcGVsaW5lVG9waWNFeHByZXNzaW9uID0gaXNQaXBlbGluZVRvcGljRXhwcmVzc2lvbjtcbmV4cG9ydHMuaXNQbGFjZWhvbGRlciA9IGlzUGxhY2Vob2xkZXI7XG5leHBvcnRzLmlzUHJpdmF0ZSA9IGlzUHJpdmF0ZTtcbmV4cG9ydHMuaXNQcml2YXRlTmFtZSA9IGlzUHJpdmF0ZU5hbWU7XG5leHBvcnRzLmlzUHJvZ3JhbSA9IGlzUHJvZ3JhbTtcbmV4cG9ydHMuaXNQcm9wZXJ0eSA9IGlzUHJvcGVydHk7XG5leHBvcnRzLmlzUHVyZWlzaCA9IGlzUHVyZWlzaDtcbmV4cG9ydHMuaXNRdWFsaWZpZWRUeXBlSWRlbnRpZmllciA9IGlzUXVhbGlmaWVkVHlwZUlkZW50aWZpZXI7XG5leHBvcnRzLmlzUmVjb3JkRXhwcmVzc2lvbiA9IGlzUmVjb3JkRXhwcmVzc2lvbjtcbmV4cG9ydHMuaXNSZWdFeHBMaXRlcmFsID0gaXNSZWdFeHBMaXRlcmFsO1xuZXhwb3J0cy5pc1JlZ2V4TGl0ZXJhbCA9IGlzUmVnZXhMaXRlcmFsO1xuZXhwb3J0cy5pc1Jlc3RFbGVtZW50ID0gaXNSZXN0RWxlbWVudDtcbmV4cG9ydHMuaXNSZXN0UHJvcGVydHkgPSBpc1Jlc3RQcm9wZXJ0eTtcbmV4cG9ydHMuaXNSZXR1cm5TdGF0ZW1lbnQgPSBpc1JldHVyblN0YXRlbWVudDtcbmV4cG9ydHMuaXNTY29wYWJsZSA9IGlzU2NvcGFibGU7XG5leHBvcnRzLmlzU2VxdWVuY2VFeHByZXNzaW9uID0gaXNTZXF1ZW5jZUV4cHJlc3Npb247XG5leHBvcnRzLmlzU3ByZWFkRWxlbWVudCA9IGlzU3ByZWFkRWxlbWVudDtcbmV4cG9ydHMuaXNTcHJlYWRQcm9wZXJ0eSA9IGlzU3ByZWFkUHJvcGVydHk7XG5leHBvcnRzLmlzU3RhbmRhcmRpemVkID0gaXNTdGFuZGFyZGl6ZWQ7XG5leHBvcnRzLmlzU3RhdGVtZW50ID0gaXNTdGF0ZW1lbnQ7XG5leHBvcnRzLmlzU3RhdGljQmxvY2sgPSBpc1N0YXRpY0Jsb2NrO1xuZXhwb3J0cy5pc1N0cmluZ0xpdGVyYWwgPSBpc1N0cmluZ0xpdGVyYWw7XG5leHBvcnRzLmlzU3RyaW5nTGl0ZXJhbFR5cGVBbm5vdGF0aW9uID0gaXNTdHJpbmdMaXRlcmFsVHlwZUFubm90YXRpb247XG5leHBvcnRzLmlzU3RyaW5nVHlwZUFubm90YXRpb24gPSBpc1N0cmluZ1R5cGVBbm5vdGF0aW9uO1xuZXhwb3J0cy5pc1N1cGVyID0gaXNTdXBlcjtcbmV4cG9ydHMuaXNTd2l0Y2hDYXNlID0gaXNTd2l0Y2hDYXNlO1xuZXhwb3J0cy5pc1N3aXRjaFN0YXRlbWVudCA9IGlzU3dpdGNoU3RhdGVtZW50O1xuZXhwb3J0cy5pc1N5bWJvbFR5cGVBbm5vdGF0aW9uID0gaXNTeW1ib2xUeXBlQW5ub3RhdGlvbjtcbmV4cG9ydHMuaXNUU0FueUtleXdvcmQgPSBpc1RTQW55S2V5d29yZDtcbmV4cG9ydHMuaXNUU0FycmF5VHlwZSA9IGlzVFNBcnJheVR5cGU7XG5leHBvcnRzLmlzVFNBc0V4cHJlc3Npb24gPSBpc1RTQXNFeHByZXNzaW9uO1xuZXhwb3J0cy5pc1RTQmFzZVR5cGUgPSBpc1RTQmFzZVR5cGU7XG5leHBvcnRzLmlzVFNCaWdJbnRLZXl3b3JkID0gaXNUU0JpZ0ludEtleXdvcmQ7XG5leHBvcnRzLmlzVFNCb29sZWFuS2V5d29yZCA9IGlzVFNCb29sZWFuS2V5d29yZDtcbmV4cG9ydHMuaXNUU0NhbGxTaWduYXR1cmVEZWNsYXJhdGlvbiA9IGlzVFNDYWxsU2lnbmF0dXJlRGVjbGFyYXRpb247XG5leHBvcnRzLmlzVFNDb25kaXRpb25hbFR5cGUgPSBpc1RTQ29uZGl0aW9uYWxUeXBlO1xuZXhwb3J0cy5pc1RTQ29uc3RydWN0U2lnbmF0dXJlRGVjbGFyYXRpb24gPSBpc1RTQ29uc3RydWN0U2lnbmF0dXJlRGVjbGFyYXRpb247XG5leHBvcnRzLmlzVFNDb25zdHJ1Y3RvclR5cGUgPSBpc1RTQ29uc3RydWN0b3JUeXBlO1xuZXhwb3J0cy5pc1RTRGVjbGFyZUZ1bmN0aW9uID0gaXNUU0RlY2xhcmVGdW5jdGlvbjtcbmV4cG9ydHMuaXNUU0RlY2xhcmVNZXRob2QgPSBpc1RTRGVjbGFyZU1ldGhvZDtcbmV4cG9ydHMuaXNUU0VudGl0eU5hbWUgPSBpc1RTRW50aXR5TmFtZTtcbmV4cG9ydHMuaXNUU0VudW1Cb2R5ID0gaXNUU0VudW1Cb2R5O1xuZXhwb3J0cy5pc1RTRW51bURlY2xhcmF0aW9uID0gaXNUU0VudW1EZWNsYXJhdGlvbjtcbmV4cG9ydHMuaXNUU0VudW1NZW1iZXIgPSBpc1RTRW51bU1lbWJlcjtcbmV4cG9ydHMuaXNUU0V4cG9ydEFzc2lnbm1lbnQgPSBpc1RTRXhwb3J0QXNzaWdubWVudDtcbmV4cG9ydHMuaXNUU0V4cHJlc3Npb25XaXRoVHlwZUFyZ3VtZW50cyA9IGlzVFNFeHByZXNzaW9uV2l0aFR5cGVBcmd1bWVudHM7XG5leHBvcnRzLmlzVFNFeHRlcm5hbE1vZHVsZVJlZmVyZW5jZSA9IGlzVFNFeHRlcm5hbE1vZHVsZVJlZmVyZW5jZTtcbmV4cG9ydHMuaXNUU0Z1bmN0aW9uVHlwZSA9IGlzVFNGdW5jdGlvblR5cGU7XG5leHBvcnRzLmlzVFNJbXBvcnRFcXVhbHNEZWNsYXJhdGlvbiA9IGlzVFNJbXBvcnRFcXVhbHNEZWNsYXJhdGlvbjtcbmV4cG9ydHMuaXNUU0ltcG9ydFR5cGUgPSBpc1RTSW1wb3J0VHlwZTtcbmV4cG9ydHMuaXNUU0luZGV4U2lnbmF0dXJlID0gaXNUU0luZGV4U2lnbmF0dXJlO1xuZXhwb3J0cy5pc1RTSW5kZXhlZEFjY2Vzc1R5cGUgPSBpc1RTSW5kZXhlZEFjY2Vzc1R5cGU7XG5leHBvcnRzLmlzVFNJbmZlclR5cGUgPSBpc1RTSW5mZXJUeXBlO1xuZXhwb3J0cy5pc1RTSW5zdGFudGlhdGlvbkV4cHJlc3Npb24gPSBpc1RTSW5zdGFudGlhdGlvbkV4cHJlc3Npb247XG5leHBvcnRzLmlzVFNJbnRlcmZhY2VCb2R5ID0gaXNUU0ludGVyZmFjZUJvZHk7XG5leHBvcnRzLmlzVFNJbnRlcmZhY2VEZWNsYXJhdGlvbiA9IGlzVFNJbnRlcmZhY2VEZWNsYXJhdGlvbjtcbmV4cG9ydHMuaXNUU0ludGVyc2VjdGlvblR5cGUgPSBpc1RTSW50ZXJzZWN0aW9uVHlwZTtcbmV4cG9ydHMuaXNUU0ludHJpbnNpY0tleXdvcmQgPSBpc1RTSW50cmluc2ljS2V5d29yZDtcbmV4cG9ydHMuaXNUU0xpdGVyYWxUeXBlID0gaXNUU0xpdGVyYWxUeXBlO1xuZXhwb3J0cy5pc1RTTWFwcGVkVHlwZSA9IGlzVFNNYXBwZWRUeXBlO1xuZXhwb3J0cy5pc1RTTWV0aG9kU2lnbmF0dXJlID0gaXNUU01ldGhvZFNpZ25hdHVyZTtcbmV4cG9ydHMuaXNUU01vZHVsZUJsb2NrID0gaXNUU01vZHVsZUJsb2NrO1xuZXhwb3J0cy5pc1RTTW9kdWxlRGVjbGFyYXRpb24gPSBpc1RTTW9kdWxlRGVjbGFyYXRpb247XG5leHBvcnRzLmlzVFNOYW1lZFR1cGxlTWVtYmVyID0gaXNUU05hbWVkVHVwbGVNZW1iZXI7XG5leHBvcnRzLmlzVFNOYW1lc3BhY2VFeHBvcnREZWNsYXJhdGlvbiA9IGlzVFNOYW1lc3BhY2VFeHBvcnREZWNsYXJhdGlvbjtcbmV4cG9ydHMuaXNUU05ldmVyS2V5d29yZCA9IGlzVFNOZXZlcktleXdvcmQ7XG5leHBvcnRzLmlzVFNOb25OdWxsRXhwcmVzc2lvbiA9IGlzVFNOb25OdWxsRXhwcmVzc2lvbjtcbmV4cG9ydHMuaXNUU051bGxLZXl3b3JkID0gaXNUU051bGxLZXl3b3JkO1xuZXhwb3J0cy5pc1RTTnVtYmVyS2V5d29yZCA9IGlzVFNOdW1iZXJLZXl3b3JkO1xuZXhwb3J0cy5pc1RTT2JqZWN0S2V5d29yZCA9IGlzVFNPYmplY3RLZXl3b3JkO1xuZXhwb3J0cy5pc1RTT3B0aW9uYWxUeXBlID0gaXNUU09wdGlvbmFsVHlwZTtcbmV4cG9ydHMuaXNUU1BhcmFtZXRlclByb3BlcnR5ID0gaXNUU1BhcmFtZXRlclByb3BlcnR5O1xuZXhwb3J0cy5pc1RTUGFyZW50aGVzaXplZFR5cGUgPSBpc1RTUGFyZW50aGVzaXplZFR5cGU7XG5leHBvcnRzLmlzVFNQcm9wZXJ0eVNpZ25hdHVyZSA9IGlzVFNQcm9wZXJ0eVNpZ25hdHVyZTtcbmV4cG9ydHMuaXNUU1F1YWxpZmllZE5hbWUgPSBpc1RTUXVhbGlmaWVkTmFtZTtcbmV4cG9ydHMuaXNUU1Jlc3RUeXBlID0gaXNUU1Jlc3RUeXBlO1xuZXhwb3J0cy5pc1RTU2F0aXNmaWVzRXhwcmVzc2lvbiA9IGlzVFNTYXRpc2ZpZXNFeHByZXNzaW9uO1xuZXhwb3J0cy5pc1RTU3RyaW5nS2V5d29yZCA9IGlzVFNTdHJpbmdLZXl3b3JkO1xuZXhwb3J0cy5pc1RTU3ltYm9sS2V5d29yZCA9IGlzVFNTeW1ib2xLZXl3b3JkO1xuZXhwb3J0cy5pc1RTVGVtcGxhdGVMaXRlcmFsVHlwZSA9IGlzVFNUZW1wbGF0ZUxpdGVyYWxUeXBlO1xuZXhwb3J0cy5pc1RTVGhpc1R5cGUgPSBpc1RTVGhpc1R5cGU7XG5leHBvcnRzLmlzVFNUdXBsZVR5cGUgPSBpc1RTVHVwbGVUeXBlO1xuZXhwb3J0cy5pc1RTVHlwZSA9IGlzVFNUeXBlO1xuZXhwb3J0cy5pc1RTVHlwZUFsaWFzRGVjbGFyYXRpb24gPSBpc1RTVHlwZUFsaWFzRGVjbGFyYXRpb247XG5leHBvcnRzLmlzVFNUeXBlQW5ub3RhdGlvbiA9IGlzVFNUeXBlQW5ub3RhdGlvbjtcbmV4cG9ydHMuaXNUU1R5cGVBc3NlcnRpb24gPSBpc1RTVHlwZUFzc2VydGlvbjtcbmV4cG9ydHMuaXNUU1R5cGVFbGVtZW50ID0gaXNUU1R5cGVFbGVtZW50O1xuZXhwb3J0cy5pc1RTVHlwZUxpdGVyYWwgPSBpc1RTVHlwZUxpdGVyYWw7XG5leHBvcnRzLmlzVFNUeXBlT3BlcmF0b3IgPSBpc1RTVHlwZU9wZXJhdG9yO1xuZXhwb3J0cy5pc1RTVHlwZVBhcmFtZXRlciA9IGlzVFNUeXBlUGFyYW1ldGVyO1xuZXhwb3J0cy5pc1RTVHlwZVBhcmFtZXRlckRlY2xhcmF0aW9uID0gaXNUU1R5cGVQYXJhbWV0ZXJEZWNsYXJhdGlvbjtcbmV4cG9ydHMuaXNUU1R5cGVQYXJhbWV0ZXJJbnN0YW50aWF0aW9uID0gaXNUU1R5cGVQYXJhbWV0ZXJJbnN0YW50aWF0aW9uO1xuZXhwb3J0cy5pc1RTVHlwZVByZWRpY2F0ZSA9IGlzVFNUeXBlUHJlZGljYXRlO1xuZXhwb3J0cy5pc1RTVHlwZVF1ZXJ5ID0gaXNUU1R5cGVRdWVyeTtcbmV4cG9ydHMuaXNUU1R5cGVSZWZlcmVuY2UgPSBpc1RTVHlwZVJlZmVyZW5jZTtcbmV4cG9ydHMuaXNUU1VuZGVmaW5lZEtleXdvcmQgPSBpc1RTVW5kZWZpbmVkS2V5d29yZDtcbmV4cG9ydHMuaXNUU1VuaW9uVHlwZSA9IGlzVFNVbmlvblR5cGU7XG5leHBvcnRzLmlzVFNVbmtub3duS2V5d29yZCA9IGlzVFNVbmtub3duS2V5d29yZDtcbmV4cG9ydHMuaXNUU1ZvaWRLZXl3b3JkID0gaXNUU1ZvaWRLZXl3b3JkO1xuZXhwb3J0cy5pc1RhZ2dlZFRlbXBsYXRlRXhwcmVzc2lvbiA9IGlzVGFnZ2VkVGVtcGxhdGVFeHByZXNzaW9uO1xuZXhwb3J0cy5pc1RlbXBsYXRlRWxlbWVudCA9IGlzVGVtcGxhdGVFbGVtZW50O1xuZXhwb3J0cy5pc1RlbXBsYXRlTGl0ZXJhbCA9IGlzVGVtcGxhdGVMaXRlcmFsO1xuZXhwb3J0cy5pc1Rlcm1pbmF0b3JsZXNzID0gaXNUZXJtaW5hdG9ybGVzcztcbmV4cG9ydHMuaXNUaGlzRXhwcmVzc2lvbiA9IGlzVGhpc0V4cHJlc3Npb247XG5leHBvcnRzLmlzVGhpc1R5cGVBbm5vdGF0aW9uID0gaXNUaGlzVHlwZUFubm90YXRpb247XG5leHBvcnRzLmlzVGhyb3dTdGF0ZW1lbnQgPSBpc1Rocm93U3RhdGVtZW50O1xuZXhwb3J0cy5pc1RvcGljUmVmZXJlbmNlID0gaXNUb3BpY1JlZmVyZW5jZTtcbmV4cG9ydHMuaXNUcnlTdGF0ZW1lbnQgPSBpc1RyeVN0YXRlbWVudDtcbmV4cG9ydHMuaXNUdXBsZUV4cHJlc3Npb24gPSBpc1R1cGxlRXhwcmVzc2lvbjtcbmV4cG9ydHMuaXNUdXBsZVR5cGVBbm5vdGF0aW9uID0gaXNUdXBsZVR5cGVBbm5vdGF0aW9uO1xuZXhwb3J0cy5pc1R5cGVBbGlhcyA9IGlzVHlwZUFsaWFzO1xuZXhwb3J0cy5pc1R5cGVBbm5vdGF0aW9uID0gaXNUeXBlQW5ub3RhdGlvbjtcbmV4cG9ydHMuaXNUeXBlQ2FzdEV4cHJlc3Npb24gPSBpc1R5cGVDYXN0RXhwcmVzc2lvbjtcbmV4cG9ydHMuaXNUeXBlUGFyYW1ldGVyID0gaXNUeXBlUGFyYW1ldGVyO1xuZXhwb3J0cy5pc1R5cGVQYXJhbWV0ZXJEZWNsYXJhdGlvbiA9IGlzVHlwZVBhcmFtZXRlckRlY2xhcmF0aW9uO1xuZXhwb3J0cy5pc1R5cGVQYXJhbWV0ZXJJbnN0YW50aWF0aW9uID0gaXNUeXBlUGFyYW1ldGVySW5zdGFudGlhdGlvbjtcbmV4cG9ydHMuaXNUeXBlU2NyaXB0ID0gaXNUeXBlU2NyaXB0O1xuZXhwb3J0cy5pc1R5cGVvZlR5cGVBbm5vdGF0aW9uID0gaXNUeXBlb2ZUeXBlQW5ub3RhdGlvbjtcbmV4cG9ydHMuaXNVbmFyeUV4cHJlc3Npb24gPSBpc1VuYXJ5RXhwcmVzc2lvbjtcbmV4cG9ydHMuaXNVbmFyeUxpa2UgPSBpc1VuYXJ5TGlrZTtcbmV4cG9ydHMuaXNVbmlvblR5cGVBbm5vdGF0aW9uID0gaXNVbmlvblR5cGVBbm5vdGF0aW9uO1xuZXhwb3J0cy5pc1VwZGF0ZUV4cHJlc3Npb24gPSBpc1VwZGF0ZUV4cHJlc3Npb247XG5leHBvcnRzLmlzVXNlcldoaXRlc3BhY2FibGUgPSBpc1VzZXJXaGl0ZXNwYWNhYmxlO1xuZXhwb3J0cy5pc1Y4SW50cmluc2ljSWRlbnRpZmllciA9IGlzVjhJbnRyaW5zaWNJZGVudGlmaWVyO1xuZXhwb3J0cy5pc1ZhcmlhYmxlRGVjbGFyYXRpb24gPSBpc1ZhcmlhYmxlRGVjbGFyYXRpb247XG5leHBvcnRzLmlzVmFyaWFibGVEZWNsYXJhdG9yID0gaXNWYXJpYWJsZURlY2xhcmF0b3I7XG5leHBvcnRzLmlzVmFyaWFuY2UgPSBpc1ZhcmlhbmNlO1xuZXhwb3J0cy5pc1ZvaWRQYXR0ZXJuID0gaXNWb2lkUGF0dGVybjtcbmV4cG9ydHMuaXNWb2lkVHlwZUFubm90YXRpb24gPSBpc1ZvaWRUeXBlQW5ub3RhdGlvbjtcbmV4cG9ydHMuaXNXaGlsZSA9IGlzV2hpbGU7XG5leHBvcnRzLmlzV2hpbGVTdGF0ZW1lbnQgPSBpc1doaWxlU3RhdGVtZW50O1xuZXhwb3J0cy5pc1dpdGhTdGF0ZW1lbnQgPSBpc1dpdGhTdGF0ZW1lbnQ7XG5leHBvcnRzLmlzWWllbGRFeHByZXNzaW9uID0gaXNZaWVsZEV4cHJlc3Npb247XG52YXIgX3NoYWxsb3dFcXVhbCA9IHJlcXVpcmUoXCIuLi8uLi91dGlscy9zaGFsbG93RXF1YWwuanNcIik7XG52YXIgX2RlcHJlY2F0aW9uV2FybmluZyA9IHJlcXVpcmUoXCIuLi8uLi91dGlscy9kZXByZWNhdGlvbldhcm5pbmcuanNcIik7XG5mdW5jdGlvbiBpc0FycmF5RXhwcmVzc2lvbihub2RlLCBvcHRzKSB7XG4gIGlmICghbm9kZSkgcmV0dXJuIGZhbHNlO1xuICBpZiAobm9kZS50eXBlICE9PSBcIkFycmF5RXhwcmVzc2lvblwiKSByZXR1cm4gZmFsc2U7XG4gIHJldHVybiBvcHRzID09IG51bGwgfHwgKDAsIF9zaGFsbG93RXF1YWwuZGVmYXVsdCkobm9kZSwgb3B0cyk7XG59XG5mdW5jdGlvbiBpc0Fzc2lnbm1lbnRFeHByZXNzaW9uKG5vZGUsIG9wdHMpIHtcbiAgaWYgKCFub2RlKSByZXR1cm4gZmFsc2U7XG4gIGlmIChub2RlLnR5cGUgIT09IFwiQXNzaWdubWVudEV4cHJlc3Npb25cIikgcmV0dXJuIGZhbHNlO1xuICByZXR1cm4gb3B0cyA9PSBudWxsIHx8ICgwLCBfc2hhbGxvd0VxdWFsLmRlZmF1bHQpKG5vZGUsIG9wdHMpO1xufVxuZnVuY3Rpb24gaXNCaW5hcnlFeHByZXNzaW9uKG5vZGUsIG9wdHMpIHtcbiAgaWYgKCFub2RlKSByZXR1cm4gZmFsc2U7XG4gIGlmIChub2RlLnR5cGUgIT09IFwiQmluYXJ5RXhwcmVzc2lvblwiKSByZXR1cm4gZmFsc2U7XG4gIHJldHVybiBvcHRzID09IG51bGwgfHwgKDAsIF9zaGFsbG93RXF1YWwuZGVmYXVsdCkobm9kZSwgb3B0cyk7XG59XG5mdW5jdGlvbiBpc0ludGVycHJldGVyRGlyZWN0aXZlKG5vZGUsIG9wdHMpIHtcbiAgaWYgKCFub2RlKSByZXR1cm4gZmFsc2U7XG4gIGlmIChub2RlLnR5cGUgIT09IFwiSW50ZXJwcmV0ZXJEaXJlY3RpdmVcIikgcmV0dXJuIGZhbHNlO1xuICByZXR1cm4gb3B0cyA9PSBudWxsIHx8ICgwLCBfc2hhbGxvd0VxdWFsLmRlZmF1bHQpKG5vZGUsIG9wdHMpO1xufVxuZnVuY3Rpb24gaXNEaXJlY3RpdmUobm9kZSwgb3B0cykge1xuICBpZiAoIW5vZGUpIHJldHVybiBmYWxzZTtcbiAgaWYgKG5vZGUudHlwZSAhPT0gXCJEaXJlY3RpdmVcIikgcmV0dXJuIGZhbHNlO1xuICByZXR1cm4gb3B0cyA9PSBudWxsIHx8ICgwLCBfc2hhbGxvd0VxdWFsLmRlZmF1bHQpKG5vZGUsIG9wdHMpO1xufVxuZnVuY3Rpb24gaXNEaXJlY3RpdmVMaXRlcmFsKG5vZGUsIG9wdHMpIHtcbiAgaWYgKCFub2RlKSByZXR1cm4gZmFsc2U7XG4gIGlmIChub2RlLnR5cGUgIT09IFwiRGlyZWN0aXZlTGl0ZXJhbFwiKSByZXR1cm4gZmFsc2U7XG4gIHJldHVybiBvcHRzID09IG51bGwgfHwgKDAsIF9zaGFsbG93RXF1YWwuZGVmYXVsdCkobm9kZSwgb3B0cyk7XG59XG5mdW5jdGlvbiBpc0Jsb2NrU3RhdGVtZW50KG5vZGUsIG9wdHMpIHtcbiAgaWYgKCFub2RlKSByZXR1cm4gZmFsc2U7XG4gIGlmIChub2RlLnR5cGUgIT09IFwiQmxvY2tTdGF0ZW1lbnRcIikgcmV0dXJuIGZhbHNlO1xuICByZXR1cm4gb3B0cyA9PSBudWxsIHx8ICgwLCBfc2hhbGxvd0VxdWFsLmRlZmF1bHQpKG5vZGUsIG9wdHMpO1xufVxuZnVuY3Rpb24gaXNCcmVha1N0YXRlbWVudChub2RlLCBvcHRzKSB7XG4gIGlmICghbm9kZSkgcmV0dXJuIGZhbHNlO1xuICBpZiAobm9kZS50eXBlICE9PSBcIkJyZWFrU3RhdGVtZW50XCIpIHJldHVybiBmYWxzZTtcbiAgcmV0dXJuIG9wdHMgPT0gbnVsbCB8fCAoMCwgX3NoYWxsb3dFcXVhbC5kZWZhdWx0KShub2RlLCBvcHRzKTtcbn1cbmZ1bmN0aW9uIGlzQ2FsbEV4cHJlc3Npb24obm9kZSwgb3B0cykge1xuICBpZiAoIW5vZGUpIHJldHVybiBmYWxzZTtcbiAgaWYgKG5vZGUudHlwZSAhPT0gXCJDYWxsRXhwcmVzc2lvblwiKSByZXR1cm4gZmFsc2U7XG4gIHJldHVybiBvcHRzID09IG51bGwgfHwgKDAsIF9zaGFsbG93RXF1YWwuZGVmYXVsdCkobm9kZSwgb3B0cyk7XG59XG5mdW5jdGlvbiBpc0NhdGNoQ2xhdXNlKG5vZGUsIG9wdHMpIHtcbiAgaWYgKCFub2RlKSByZXR1cm4gZmFsc2U7XG4gIGlmIChub2RlLnR5cGUgIT09IFwiQ2F0Y2hDbGF1c2VcIikgcmV0dXJuIGZhbHNlO1xuICByZXR1cm4gb3B0cyA9PSBudWxsIHx8ICgwLCBfc2hhbGxvd0VxdWFsLmRlZmF1bHQpKG5vZGUsIG9wdHMpO1xufVxuZnVuY3Rpb24gaXNDb25kaXRpb25hbEV4cHJlc3Npb24obm9kZSwgb3B0cykge1xuICBpZiAoIW5vZGUpIHJldHVybiBmYWxzZTtcbiAgaWYgKG5vZGUudHlwZSAhPT0gXCJDb25kaXRpb25hbEV4cHJlc3Npb25cIikgcmV0dXJuIGZhbHNlO1xuICByZXR1cm4gb3B0cyA9PSBudWxsIHx8ICgwLCBfc2hhbGxvd0VxdWFsLmRlZmF1bHQpKG5vZGUsIG9wdHMpO1xufVxuZnVuY3Rpb24gaXNDb250aW51ZVN0YXRlbWVudChub2RlLCBvcHRzKSB7XG4gIGlmICghbm9kZSkgcmV0dXJuIGZhbHNlO1xuICBpZiAobm9kZS50eXBlICE9PSBcIkNvbnRpbnVlU3RhdGVtZW50XCIpIHJldHVybiBmYWxzZTtcbiAgcmV0dXJuIG9wdHMgPT0gbnVsbCB8fCAoMCwgX3NoYWxsb3dFcXVhbC5kZWZhdWx0KShub2RlLCBvcHRzKTtcbn1cbmZ1bmN0aW9uIGlzRGVidWdnZXJTdGF0ZW1lbnQobm9kZSwgb3B0cykge1xuICBpZiAoIW5vZGUpIHJldHVybiBmYWxzZTtcbiAgaWYgKG5vZGUudHlwZSAhPT0gXCJEZWJ1Z2dlclN0YXRlbWVudFwiKSByZXR1cm4gZmFsc2U7XG4gIHJldHVybiBvcHRzID09IG51bGwgfHwgKDAsIF9zaGFsbG93RXF1YWwuZGVmYXVsdCkobm9kZSwgb3B0cyk7XG59XG5mdW5jdGlvbiBpc0RvV2hpbGVTdGF0ZW1lbnQobm9kZSwgb3B0cykge1xuICBpZiAoIW5vZGUpIHJldHVybiBmYWxzZTtcbiAgaWYgKG5vZGUudHlwZSAhPT0gXCJEb1doaWxlU3RhdGVtZW50XCIpIHJldHVybiBmYWxzZTtcbiAgcmV0dXJuIG9wdHMgPT0gbnVsbCB8fCAoMCwgX3NoYWxsb3dFcXVhbC5kZWZhdWx0KShub2RlLCBvcHRzKTtcbn1cbmZ1bmN0aW9uIGlzRW1wdHlTdGF0ZW1lbnQobm9kZSwgb3B0cykge1xuICBpZiAoIW5vZGUpIHJldHVybiBmYWxzZTtcbiAgaWYgKG5vZGUudHlwZSAhPT0gXCJFbXB0eVN0YXRlbWVudFwiKSByZXR1cm4gZmFsc2U7XG4gIHJldHVybiBvcHRzID09IG51bGwgfHwgKDAsIF9zaGFsbG93RXF1YWwuZGVmYXVsdCkobm9kZSwgb3B0cyk7XG59XG5mdW5jdGlvbiBpc0V4cHJlc3Npb25TdGF0ZW1lbnQobm9kZSwgb3B0cykge1xuICBpZiAoIW5vZGUpIHJldHVybiBmYWxzZTtcbiAgaWYgKG5vZGUudHlwZSAhPT0gXCJFeHByZXNzaW9uU3RhdGVtZW50XCIpIHJldHVybiBmYWxzZTtcbiAgcmV0dXJuIG9wdHMgPT0gbnVsbCB8fCAoMCwgX3NoYWxsb3dFcXVhbC5kZWZhdWx0KShub2RlLCBvcHRzKTtcbn1cbmZ1bmN0aW9uIGlzRmlsZShub2RlLCBvcHRzKSB7XG4gIGlmICghbm9kZSkgcmV0dXJuIGZhbHNlO1xuICBpZiAobm9kZS50eXBlICE9PSBcIkZpbGVcIikgcmV0dXJuIGZhbHNlO1xuICByZXR1cm4gb3B0cyA9PSBudWxsIHx8ICgwLCBfc2hhbGxvd0VxdWFsLmRlZmF1bHQpKG5vZGUsIG9wdHMpO1xufVxuZnVuY3Rpb24gaXNGb3JJblN0YXRlbWVudChub2RlLCBvcHRzKSB7XG4gIGlmICghbm9kZSkgcmV0dXJuIGZhbHNlO1xuICBpZiAobm9kZS50eXBlICE9PSBcIkZvckluU3RhdGVtZW50XCIpIHJldHVybiBmYWxzZTtcbiAgcmV0dXJuIG9wdHMgPT0gbnVsbCB8fCAoMCwgX3NoYWxsb3dFcXVhbC5kZWZhdWx0KShub2RlLCBvcHRzKTtcbn1cbmZ1bmN0aW9uIGlzRm9yU3RhdGVtZW50KG5vZGUsIG9wdHMpIHtcbiAgaWYgKCFub2RlKSByZXR1cm4gZmFsc2U7XG4gIGlmIChub2RlLnR5cGUgIT09IFwiRm9yU3RhdGVtZW50XCIpIHJldHVybiBmYWxzZTtcbiAgcmV0dXJuIG9wdHMgPT0gbnVsbCB8fCAoMCwgX3NoYWxsb3dFcXVhbC5kZWZhdWx0KShub2RlLCBvcHRzKTtcbn1cbmZ1bmN0aW9uIGlzRnVuY3Rpb25EZWNsYXJhdGlvbihub2RlLCBvcHRzKSB7XG4gIGlmICghbm9kZSkgcmV0dXJuIGZhbHNlO1xuICBpZiAobm9kZS50eXBlICE9PSBcIkZ1bmN0aW9uRGVjbGFyYXRpb25cIikgcmV0dXJuIGZhbHNlO1xuICByZXR1cm4gb3B0cyA9PSBudWxsIHx8ICgwLCBfc2hhbGxvd0VxdWFsLmRlZmF1bHQpKG5vZGUsIG9wdHMpO1xufVxuZnVuY3Rpb24gaXNGdW5jdGlvbkV4cHJlc3Npb24obm9kZSwgb3B0cykge1xuICBpZiAoIW5vZGUpIHJldHVybiBmYWxzZTtcbiAgaWYgKG5vZGUudHlwZSAhPT0gXCJGdW5jdGlvbkV4cHJlc3Npb25cIikgcmV0dXJuIGZhbHNlO1xuICByZXR1cm4gb3B0cyA9PSBudWxsIHx8ICgwLCBfc2hhbGxvd0VxdWFsLmRlZmF1bHQpKG5vZGUsIG9wdHMpO1xufVxuZnVuY3Rpb24gaXNJZGVudGlmaWVyKG5vZGUsIG9wdHMpIHtcbiAgaWYgKCFub2RlKSByZXR1cm4gZmFsc2U7XG4gIGlmIChub2RlLnR5cGUgIT09IFwiSWRlbnRpZmllclwiKSByZXR1cm4gZmFsc2U7XG4gIHJldHVybiBvcHRzID09IG51bGwgfHwgKDAsIF9zaGFsbG93RXF1YWwuZGVmYXVsdCkobm9kZSwgb3B0cyk7XG59XG5mdW5jdGlvbiBpc0lmU3RhdGVtZW50KG5vZGUsIG9wdHMpIHtcbiAgaWYgKCFub2RlKSByZXR1cm4gZmFsc2U7XG4gIGlmIChub2RlLnR5cGUgIT09IFwiSWZTdGF0ZW1lbnRcIikgcmV0dXJuIGZhbHNlO1xuICByZXR1cm4gb3B0cyA9PSBudWxsIHx8ICgwLCBfc2hhbGxvd0VxdWFsLmRlZmF1bHQpKG5vZGUsIG9wdHMpO1xufVxuZnVuY3Rpb24gaXNMYWJlbGVkU3RhdGVtZW50KG5vZGUsIG9wdHMpIHtcbiAgaWYgKCFub2RlKSByZXR1cm4gZmFsc2U7XG4gIGlmIChub2RlLnR5cGUgIT09IFwiTGFiZWxlZFN0YXRlbWVudFwiKSByZXR1cm4gZmFsc2U7XG4gIHJldHVybiBvcHRzID09IG51bGwgfHwgKDAsIF9zaGFsbG93RXF1YWwuZGVmYXVsdCkobm9kZSwgb3B0cyk7XG59XG5mdW5jdGlvbiBpc1N0cmluZ0xpdGVyYWwobm9kZSwgb3B0cykge1xuICBpZiAoIW5vZGUpIHJldHVybiBmYWxzZTtcbiAgaWYgKG5vZGUudHlwZSAhPT0gXCJTdHJpbmdMaXRlcmFsXCIpIHJldHVybiBmYWxzZTtcbiAgcmV0dXJuIG9wdHMgPT0gbnVsbCB8fCAoMCwgX3NoYWxsb3dFcXVhbC5kZWZhdWx0KShub2RlLCBvcHRzKTtcbn1cbmZ1bmN0aW9uIGlzTnVtZXJpY0xpdGVyYWwobm9kZSwgb3B0cykge1xuICBpZiAoIW5vZGUpIHJldHVybiBmYWxzZTtcbiAgaWYgKG5vZGUudHlwZSAhPT0gXCJOdW1lcmljTGl0ZXJhbFwiKSByZXR1cm4gZmFsc2U7XG4gIHJldHVybiBvcHRzID09IG51bGwgfHwgKDAsIF9zaGFsbG93RXF1YWwuZGVmYXVsdCkobm9kZSwgb3B0cyk7XG59XG5mdW5jdGlvbiBpc051bGxMaXRlcmFsKG5vZGUsIG9wdHMpIHtcbiAgaWYgKCFub2RlKSByZXR1cm4gZmFsc2U7XG4gIGlmIChub2RlLnR5cGUgIT09IFwiTnVsbExpdGVyYWxcIikgcmV0dXJuIGZhbHNlO1xuICByZXR1cm4gb3B0cyA9PSBudWxsIHx8ICgwLCBfc2hhbGxvd0VxdWFsLmRlZmF1bHQpKG5vZGUsIG9wdHMpO1xufVxuZnVuY3Rpb24gaXNCb29sZWFuTGl0ZXJhbChub2RlLCBvcHRzKSB7XG4gIGlmICghbm9kZSkgcmV0dXJuIGZhbHNlO1xuICBpZiAobm9kZS50eXBlICE9PSBcIkJvb2xlYW5MaXRlcmFsXCIpIHJldHVybiBmYWxzZTtcbiAgcmV0dXJuIG9wdHMgPT0gbnVsbCB8fCAoMCwgX3NoYWxsb3dFcXVhbC5kZWZhdWx0KShub2RlLCBvcHRzKTtcbn1cbmZ1bmN0aW9uIGlzUmVnRXhwTGl0ZXJhbChub2RlLCBvcHRzKSB7XG4gIGlmICghbm9kZSkgcmV0dXJuIGZhbHNlO1xuICBpZiAobm9kZS50eXBlICE9PSBcIlJlZ0V4cExpdGVyYWxcIikgcmV0dXJuIGZhbHNlO1xuICByZXR1cm4gb3B0cyA9PSBudWxsIHx8ICgwLCBfc2hhbGxvd0VxdWFsLmRlZmF1bHQpKG5vZGUsIG9wdHMpO1xufVxuZnVuY3Rpb24gaXNMb2dpY2FsRXhwcmVzc2lvbihub2RlLCBvcHRzKSB7XG4gIGlmICghbm9kZSkgcmV0dXJuIGZhbHNlO1xuICBpZiAobm9kZS50eXBlICE9PSBcIkxvZ2ljYWxFeHByZXNzaW9uXCIpIHJldHVybiBmYWxzZTtcbiAgcmV0dXJuIG9wdHMgPT0gbnVsbCB8fCAoMCwgX3NoYWxsb3dFcXVhbC5kZWZhdWx0KShub2RlLCBvcHRzKTtcbn1cbmZ1bmN0aW9uIGlzTWVtYmVyRXhwcmVzc2lvbihub2RlLCBvcHRzKSB7XG4gIGlmICghbm9kZSkgcmV0dXJuIGZhbHNlO1xuICBpZiAobm9kZS50eXBlICE9PSBcIk1lbWJlckV4cHJlc3Npb25cIikgcmV0dXJuIGZhbHNlO1xuICByZXR1cm4gb3B0cyA9PSBudWxsIHx8ICgwLCBfc2hhbGxvd0VxdWFsLmRlZmF1bHQpKG5vZGUsIG9wdHMpO1xufVxuZnVuY3Rpb24gaXNOZXdFeHByZXNzaW9uKG5vZGUsIG9wdHMpIHtcbiAgaWYgKCFub2RlKSByZXR1cm4gZmFsc2U7XG4gIGlmIChub2RlLnR5cGUgIT09IFwiTmV3RXhwcmVzc2lvblwiKSByZXR1cm4gZmFsc2U7XG4gIHJldHVybiBvcHRzID09IG51bGwgfHwgKDAsIF9zaGFsbG93RXF1YWwuZGVmYXVsdCkobm9kZSwgb3B0cyk7XG59XG5mdW5jdGlvbiBpc1Byb2dyYW0obm9kZSwgb3B0cykge1xuICBpZiAoIW5vZGUpIHJldHVybiBmYWxzZTtcbiAgaWYgKG5vZGUudHlwZSAhPT0gXCJQcm9ncmFtXCIpIHJldHVybiBmYWxzZTtcbiAgcmV0dXJuIG9wdHMgPT0gbnVsbCB8fCAoMCwgX3NoYWxsb3dFcXVhbC5kZWZhdWx0KShub2RlLCBvcHRzKTtcbn1cbmZ1bmN0aW9uIGlzT2JqZWN0RXhwcmVzc2lvbihub2RlLCBvcHRzKSB7XG4gIGlmICghbm9kZSkgcmV0dXJuIGZhbHNlO1xuICBpZiAobm9kZS50eXBlICE9PSBcIk9iamVjdEV4cHJlc3Npb25cIikgcmV0dXJuIGZhbHNlO1xuICByZXR1cm4gb3B0cyA9PSBudWxsIHx8ICgwLCBfc2hhbGxvd0VxdWFsLmRlZmF1bHQpKG5vZGUsIG9wdHMpO1xufVxuZnVuY3Rpb24gaXNPYmplY3RNZXRob2Qobm9kZSwgb3B0cykge1xuICBpZiAoIW5vZGUpIHJldHVybiBmYWxzZTtcbiAgaWYgKG5vZGUudHlwZSAhPT0gXCJPYmplY3RNZXRob2RcIikgcmV0dXJuIGZhbHNlO1xuICByZXR1cm4gb3B0cyA9PSBudWxsIHx8ICgwLCBfc2hhbGxvd0VxdWFsLmRlZmF1bHQpKG5vZGUsIG9wdHMpO1xufVxuZnVuY3Rpb24gaXNPYmplY3RQcm9wZXJ0eShub2RlLCBvcHRzKSB7XG4gIGlmICghbm9kZSkgcmV0dXJuIGZhbHNlO1xuICBpZiAobm9kZS50eXBlICE9PSBcIk9iamVjdFByb3BlcnR5XCIpIHJldHVybiBmYWxzZTtcbiAgcmV0dXJuIG9wdHMgPT0gbnVsbCB8fCAoMCwgX3NoYWxsb3dFcXVhbC5kZWZhdWx0KShub2RlLCBvcHRzKTtcbn1cbmZ1bmN0aW9uIGlzUmVzdEVsZW1lbnQobm9kZSwgb3B0cykge1xuICBpZiAoIW5vZGUpIHJldHVybiBmYWxzZTtcbiAgaWYgKG5vZGUudHlwZSAhPT0gXCJSZXN0RWxlbWVudFwiKSByZXR1cm4gZmFsc2U7XG4gIHJldHVybiBvcHRzID09IG51bGwgfHwgKDAsIF9zaGFsbG93RXF1YWwuZGVmYXVsdCkobm9kZSwgb3B0cyk7XG59XG5mdW5jdGlvbiBpc1JldHVyblN0YXRlbWVudChub2RlLCBvcHRzKSB7XG4gIGlmICghbm9kZSkgcmV0dXJuIGZhbHNlO1xuICBpZiAobm9kZS50eXBlICE9PSBcIlJldHVyblN0YXRlbWVudFwiKSByZXR1cm4gZmFsc2U7XG4gIHJldHVybiBvcHRzID09IG51bGwgfHwgKDAsIF9zaGFsbG93RXF1YWwuZGVmYXVsdCkobm9kZSwgb3B0cyk7XG59XG5mdW5jdGlvbiBpc1NlcXVlbmNlRXhwcmVzc2lvbihub2RlLCBvcHRzKSB7XG4gIGlmICghbm9kZSkgcmV0dXJuIGZhbHNlO1xuICBpZiAobm9kZS50eXBlICE9PSBcIlNlcXVlbmNlRXhwcmVzc2lvblwiKSByZXR1cm4gZmFsc2U7XG4gIHJldHVybiBvcHRzID09IG51bGwgfHwgKDAsIF9zaGFsbG93RXF1YWwuZGVmYXVsdCkobm9kZSwgb3B0cyk7XG59XG5mdW5jdGlvbiBpc1BhcmVudGhlc2l6ZWRFeHByZXNzaW9uKG5vZGUsIG9wdHMpIHtcbiAgaWYgKCFub2RlKSByZXR1cm4gZmFsc2U7XG4gIGlmIChub2RlLnR5cGUgIT09IFwiUGFyZW50aGVzaXplZEV4cHJlc3Npb25cIikgcmV0dXJuIGZhbHNlO1xuICByZXR1cm4gb3B0cyA9PSBudWxsIHx8ICgwLCBfc2hhbGxvd0VxdWFsLmRlZmF1bHQpKG5vZGUsIG9wdHMpO1xufVxuZnVuY3Rpb24gaXNTd2l0Y2hDYXNlKG5vZGUsIG9wdHMpIHtcbiAgaWYgKCFub2RlKSByZXR1cm4gZmFsc2U7XG4gIGlmIChub2RlLnR5cGUgIT09IFwiU3dpdGNoQ2FzZVwiKSByZXR1cm4gZmFsc2U7XG4gIHJldHVybiBvcHRzID09IG51bGwgfHwgKDAsIF9zaGFsbG93RXF1YWwuZGVmYXVsdCkobm9kZSwgb3B0cyk7XG59XG5mdW5jdGlvbiBpc1N3aXRjaFN0YXRlbWVudChub2RlLCBvcHRzKSB7XG4gIGlmICghbm9kZSkgcmV0dXJuIGZhbHNlO1xuICBpZiAobm9kZS50eXBlICE9PSBcIlN3aXRjaFN0YXRlbWVudFwiKSByZXR1cm4gZmFsc2U7XG4gIHJldHVybiBvcHRzID09IG51bGwgfHwgKDAsIF9zaGFsbG93RXF1YWwuZGVmYXVsdCkobm9kZSwgb3B0cyk7XG59XG5mdW5jdGlvbiBpc1RoaXNFeHByZXNzaW9uKG5vZGUsIG9wdHMpIHtcbiAgaWYgKCFub2RlKSByZXR1cm4gZmFsc2U7XG4gIGlmIChub2RlLnR5cGUgIT09IFwiVGhpc0V4cHJlc3Npb25cIikgcmV0dXJuIGZhbHNlO1xuICByZXR1cm4gb3B0cyA9PSBudWxsIHx8ICgwLCBfc2hhbGxvd0VxdWFsLmRlZmF1bHQpKG5vZGUsIG9wdHMpO1xufVxuZnVuY3Rpb24gaXNUaHJvd1N0YXRlbWVudChub2RlLCBvcHRzKSB7XG4gIGlmICghbm9kZSkgcmV0dXJuIGZhbHNlO1xuICBpZiAobm9kZS50eXBlICE9PSBcIlRocm93U3RhdGVtZW50XCIpIHJldHVybiBmYWxzZTtcbiAgcmV0dXJuIG9wdHMgPT0gbnVsbCB8fCAoMCwgX3NoYWxsb3dFcXVhbC5kZWZhdWx0KShub2RlLCBvcHRzKTtcbn1cbmZ1bmN0aW9uIGlzVHJ5U3RhdGVtZW50KG5vZGUsIG9wdHMpIHtcbiAgaWYgKCFub2RlKSByZXR1cm4gZmFsc2U7XG4gIGlmIChub2RlLnR5cGUgIT09IFwiVHJ5U3RhdGVtZW50XCIpIHJldHVybiBmYWxzZTtcbiAgcmV0dXJuIG9wdHMgPT0gbnVsbCB8fCAoMCwgX3NoYWxsb3dFcXVhbC5kZWZhdWx0KShub2RlLCBvcHRzKTtcbn1cbmZ1bmN0aW9uIGlzVW5hcnlFeHByZXNzaW9uKG5vZGUsIG9wdHMpIHtcbiAgaWYgKCFub2RlKSByZXR1cm4gZmFsc2U7XG4gIGlmIChub2RlLnR5cGUgIT09IFwiVW5hcnlFeHByZXNzaW9uXCIpIHJldHVybiBmYWxzZTtcbiAgcmV0dXJuIG9wdHMgPT0gbnVsbCB8fCAoMCwgX3NoYWxsb3dFcXVhbC5kZWZhdWx0KShub2RlLCBvcHRzKTtcbn1cbmZ1bmN0aW9uIGlzVXBkYXRlRXhwcmVzc2lvbihub2RlLCBvcHRzKSB7XG4gIGlmICghbm9kZSkgcmV0dXJuIGZhbHNlO1xuICBpZiAobm9kZS50eXBlICE9PSBcIlVwZGF0ZUV4cHJlc3Npb25cIikgcmV0dXJuIGZhbHNlO1xuICByZXR1cm4gb3B0cyA9PSBudWxsIHx8ICgwLCBfc2hhbGxvd0VxdWFsLmRlZmF1bHQpKG5vZGUsIG9wdHMpO1xufVxuZnVuY3Rpb24gaXNWYXJpYWJsZURlY2xhcmF0aW9uKG5vZGUsIG9wdHMpIHtcbiAgaWYgKCFub2RlKSByZXR1cm4gZmFsc2U7XG4gIGlmIChub2RlLnR5cGUgIT09IFwiVmFyaWFibGVEZWNsYXJhdGlvblwiKSByZXR1cm4gZmFsc2U7XG4gIHJldHVybiBvcHRzID09IG51bGwgfHwgKDAsIF9zaGFsbG93RXF1YWwuZGVmYXVsdCkobm9kZSwgb3B0cyk7XG59XG5mdW5jdGlvbiBpc1ZhcmlhYmxlRGVjbGFyYXRvcihub2RlLCBvcHRzKSB7XG4gIGlmICghbm9kZSkgcmV0dXJuIGZhbHNlO1xuICBpZiAobm9kZS50eXBlICE9PSBcIlZhcmlhYmxlRGVjbGFyYXRvclwiKSByZXR1cm4gZmFsc2U7XG4gIHJldHVybiBvcHRzID09IG51bGwgfHwgKDAsIF9zaGFsbG93RXF1YWwuZGVmYXVsdCkobm9kZSwgb3B0cyk7XG59XG5mdW5jdGlvbiBpc1doaWxlU3RhdGVtZW50KG5vZGUsIG9wdHMpIHtcbiAgaWYgKCFub2RlKSByZXR1cm4gZmFsc2U7XG4gIGlmIChub2RlLnR5cGUgIT09IFwiV2hpbGVTdGF0ZW1lbnRcIikgcmV0dXJuIGZhbHNlO1xuICByZXR1cm4gb3B0cyA9PSBudWxsIHx8ICgwLCBfc2hhbGxvd0VxdWFsLmRlZmF1bHQpKG5vZGUsIG9wdHMpO1xufVxuZnVuY3Rpb24gaXNXaXRoU3RhdGVtZW50KG5vZGUsIG9wdHMpIHtcbiAgaWYgKCFub2RlKSByZXR1cm4gZmFsc2U7XG4gIGlmIChub2RlLnR5cGUgIT09IFwiV2l0aFN0YXRlbWVudFwiKSByZXR1cm4gZmFsc2U7XG4gIHJldHVybiBvcHRzID09IG51bGwgfHwgKDAsIF9zaGFsbG93RXF1YWwuZGVmYXVsdCkobm9kZSwgb3B0cyk7XG59XG5mdW5jdGlvbiBpc0Fzc2lnbm1lbnRQYXR0ZXJuKG5vZGUsIG9wdHMpIHtcbiAgaWYgKCFub2RlKSByZXR1cm4gZmFsc2U7XG4gIGlmIChub2RlLnR5cGUgIT09IFwiQXNzaWdubWVudFBhdHRlcm5cIikgcmV0dXJuIGZhbHNlO1xuICByZXR1cm4gb3B0cyA9PSBudWxsIHx8ICgwLCBfc2hhbGxvd0VxdWFsLmRlZmF1bHQpKG5vZGUsIG9wdHMpO1xufVxuZnVuY3Rpb24gaXNBcnJheVBhdHRlcm4obm9kZSwgb3B0cykge1xuICBpZiAoIW5vZGUpIHJldHVybiBmYWxzZTtcbiAgaWYgKG5vZGUudHlwZSAhPT0gXCJBcnJheVBhdHRlcm5cIikgcmV0dXJuIGZhbHNlO1xuICByZXR1cm4gb3B0cyA9PSBudWxsIHx8ICgwLCBfc2hhbGxvd0VxdWFsLmRlZmF1bHQpKG5vZGUsIG9wdHMpO1xufVxuZnVuY3Rpb24gaXNBcnJvd0Z1bmN0aW9uRXhwcmVzc2lvbihub2RlLCBvcHRzKSB7XG4gIGlmICghbm9kZSkgcmV0dXJuIGZhbHNlO1xuICBpZiAobm9kZS50eXBlICE9PSBcIkFycm93RnVuY3Rpb25FeHByZXNzaW9uXCIpIHJldHVybiBmYWxzZTtcbiAgcmV0dXJuIG9wdHMgPT0gbnVsbCB8fCAoMCwgX3NoYWxsb3dFcXVhbC5kZWZhdWx0KShub2RlLCBvcHRzKTtcbn1cbmZ1bmN0aW9uIGlzQ2xhc3NCb2R5KG5vZGUsIG9wdHMpIHtcbiAgaWYgKCFub2RlKSByZXR1cm4gZmFsc2U7XG4gIGlmIChub2RlLnR5cGUgIT09IFwiQ2xhc3NCb2R5XCIpIHJldHVybiBmYWxzZTtcbiAgcmV0dXJuIG9wdHMgPT0gbnVsbCB8fCAoMCwgX3NoYWxsb3dFcXVhbC5kZWZhdWx0KShub2RlLCBvcHRzKTtcbn1cbmZ1bmN0aW9uIGlzQ2xhc3NFeHByZXNzaW9uKG5vZGUsIG9wdHMpIHtcbiAgaWYgKCFub2RlKSByZXR1cm4gZmFsc2U7XG4gIGlmIChub2RlLnR5cGUgIT09IFwiQ2xhc3NFeHByZXNzaW9uXCIpIHJldHVybiBmYWxzZTtcbiAgcmV0dXJuIG9wdHMgPT0gbnVsbCB8fCAoMCwgX3NoYWxsb3dFcXVhbC5kZWZhdWx0KShub2RlLCBvcHRzKTtcbn1cbmZ1bmN0aW9uIGlzQ2xhc3NEZWNsYXJhdGlvbihub2RlLCBvcHRzKSB7XG4gIGlmICghbm9kZSkgcmV0dXJuIGZhbHNlO1xuICBpZiAobm9kZS50eXBlICE9PSBcIkNsYXNzRGVjbGFyYXRpb25cIikgcmV0dXJuIGZhbHNlO1xuICByZXR1cm4gb3B0cyA9PSBudWxsIHx8ICgwLCBfc2hhbGxvd0VxdWFsLmRlZmF1bHQpKG5vZGUsIG9wdHMpO1xufVxuZnVuY3Rpb24gaXNFeHBvcnRBbGxEZWNsYXJhdGlvbihub2RlLCBvcHRzKSB7XG4gIGlmICghbm9kZSkgcmV0dXJuIGZhbHNlO1xuICBpZiAobm9kZS50eXBlICE9PSBcIkV4cG9ydEFsbERlY2xhcmF0aW9uXCIpIHJldHVybiBmYWxzZTtcbiAgcmV0dXJuIG9wdHMgPT0gbnVsbCB8fCAoMCwgX3NoYWxsb3dFcXVhbC5kZWZhdWx0KShub2RlLCBvcHRzKTtcbn1cbmZ1bmN0aW9uIGlzRXhwb3J0RGVmYXVsdERlY2xhcmF0aW9uKG5vZGUsIG9wdHMpIHtcbiAgaWYgKCFub2RlKSByZXR1cm4gZmFsc2U7XG4gIGlmIChub2RlLnR5cGUgIT09IFwiRXhwb3J0RGVmYXVsdERlY2xhcmF0aW9uXCIpIHJldHVybiBmYWxzZTtcbiAgcmV0dXJuIG9wdHMgPT0gbnVsbCB8fCAoMCwgX3NoYWxsb3dFcXVhbC5kZWZhdWx0KShub2RlLCBvcHRzKTtcbn1cbmZ1bmN0aW9uIGlzRXhwb3J0TmFtZWREZWNsYXJhdGlvbihub2RlLCBvcHRzKSB7XG4gIGlmICghbm9kZSkgcmV0dXJuIGZhbHNlO1xuICBpZiAobm9kZS50eXBlICE9PSBcIkV4cG9ydE5hbWVkRGVjbGFyYXRpb25cIikgcmV0dXJuIGZhbHNlO1xuICByZXR1cm4gb3B0cyA9PSBudWxsIHx8ICgwLCBfc2hhbGxvd0VxdWFsLmRlZmF1bHQpKG5vZGUsIG9wdHMpO1xufVxuZnVuY3Rpb24gaXNFeHBvcnRTcGVjaWZpZXIobm9kZSwgb3B0cykge1xuICBpZiAoIW5vZGUpIHJldHVybiBmYWxzZTtcbiAgaWYgKG5vZGUudHlwZSAhPT0gXCJFeHBvcnRTcGVjaWZpZXJcIikgcmV0dXJuIGZhbHNlO1xuICByZXR1cm4gb3B0cyA9PSBudWxsIHx8ICgwLCBfc2hhbGxvd0VxdWFsLmRlZmF1bHQpKG5vZGUsIG9wdHMpO1xufVxuZnVuY3Rpb24gaXNGb3JPZlN0YXRlbWVudChub2RlLCBvcHRzKSB7XG4gIGlmICghbm9kZSkgcmV0dXJuIGZhbHNlO1xuICBpZiAobm9kZS50eXBlICE9PSBcIkZvck9mU3RhdGVtZW50XCIpIHJldHVybiBmYWxzZTtcbiAgcmV0dXJuIG9wdHMgPT0gbnVsbCB8fCAoMCwgX3NoYWxsb3dFcXVhbC5kZWZhdWx0KShub2RlLCBvcHRzKTtcbn1cbmZ1bmN0aW9uIGlzSW1wb3J0RGVjbGFyYXRpb24obm9kZSwgb3B0cykge1xuICBpZiAoIW5vZGUpIHJldHVybiBmYWxzZTtcbiAgaWYgKG5vZGUudHlwZSAhPT0gXCJJbXBvcnREZWNsYXJhdGlvblwiKSByZXR1cm4gZmFsc2U7XG4gIHJldHVybiBvcHRzID09IG51bGwgfHwgKDAsIF9zaGFsbG93RXF1YWwuZGVmYXVsdCkobm9kZSwgb3B0cyk7XG59XG5mdW5jdGlvbiBpc0ltcG9ydERlZmF1bHRTcGVjaWZpZXIobm9kZSwgb3B0cykge1xuICBpZiAoIW5vZGUpIHJldHVybiBmYWxzZTtcbiAgaWYgKG5vZGUudHlwZSAhPT0gXCJJbXBvcnREZWZhdWx0U3BlY2lmaWVyXCIpIHJldHVybiBmYWxzZTtcbiAgcmV0dXJuIG9wdHMgPT0gbnVsbCB8fCAoMCwgX3NoYWxsb3dFcXVhbC5kZWZhdWx0KShub2RlLCBvcHRzKTtcbn1cbmZ1bmN0aW9uIGlzSW1wb3J0TmFtZXNwYWNlU3BlY2lmaWVyKG5vZGUsIG9wdHMpIHtcbiAgaWYgKCFub2RlKSByZXR1cm4gZmFsc2U7XG4gIGlmIChub2RlLnR5cGUgIT09IFwiSW1wb3J0TmFtZXNwYWNlU3BlY2lmaWVyXCIpIHJldHVybiBmYWxzZTtcbiAgcmV0dXJuIG9wdHMgPT0gbnVsbCB8fCAoMCwgX3NoYWxsb3dFcXVhbC5kZWZhdWx0KShub2RlLCBvcHRzKTtcbn1cbmZ1bmN0aW9uIGlzSW1wb3J0U3BlY2lmaWVyKG5vZGUsIG9wdHMpIHtcbiAgaWYgKCFub2RlKSByZXR1cm4gZmFsc2U7XG4gIGlmIChub2RlLnR5cGUgIT09IFwiSW1wb3J0U3BlY2lmaWVyXCIpIHJldHVybiBmYWxzZTtcbiAgcmV0dXJuIG9wdHMgPT0gbnVsbCB8fCAoMCwgX3NoYWxsb3dFcXVhbC5kZWZhdWx0KShub2RlLCBvcHRzKTtcbn1cbmZ1bmN0aW9uIGlzSW1wb3J0RXhwcmVzc2lvbihub2RlLCBvcHRzKSB7XG4gIGlmICghbm9kZSkgcmV0dXJuIGZhbHNlO1xuICBpZiAobm9kZS50eXBlICE9PSBcIkltcG9ydEV4cHJlc3Npb25cIikgcmV0dXJuIGZhbHNlO1xuICByZXR1cm4gb3B0cyA9PSBudWxsIHx8ICgwLCBfc2hhbGxvd0VxdWFsLmRlZmF1bHQpKG5vZGUsIG9wdHMpO1xufVxuZnVuY3Rpb24gaXNNZXRhUHJvcGVydHkobm9kZSwgb3B0cykge1xuICBpZiAoIW5vZGUpIHJldHVybiBmYWxzZTtcbiAgaWYgKG5vZGUudHlwZSAhPT0gXCJNZXRhUHJvcGVydHlcIikgcmV0dXJuIGZhbHNlO1xuICByZXR1cm4gb3B0cyA9PSBudWxsIHx8ICgwLCBfc2hhbGxvd0VxdWFsLmRlZmF1bHQpKG5vZGUsIG9wdHMpO1xufVxuZnVuY3Rpb24gaXNDbGFzc01ldGhvZChub2RlLCBvcHRzKSB7XG4gIGlmICghbm9kZSkgcmV0dXJuIGZhbHNlO1xuICBpZiAobm9kZS50eXBlICE9PSBcIkNsYXNzTWV0aG9kXCIpIHJldHVybiBmYWxzZTtcbiAgcmV0dXJuIG9wdHMgPT0gbnVsbCB8fCAoMCwgX3NoYWxsb3dFcXVhbC5kZWZhdWx0KShub2RlLCBvcHRzKTtcbn1cbmZ1bmN0aW9uIGlzT2JqZWN0UGF0dGVybihub2RlLCBvcHRzKSB7XG4gIGlmICghbm9kZSkgcmV0dXJuIGZhbHNlO1xuICBpZiAobm9kZS50eXBlICE9PSBcIk9iamVjdFBhdHRlcm5cIikgcmV0dXJuIGZhbHNlO1xuICByZXR1cm4gb3B0cyA9PSBudWxsIHx8ICgwLCBfc2hhbGxvd0VxdWFsLmRlZmF1bHQpKG5vZGUsIG9wdHMpO1xufVxuZnVuY3Rpb24gaXNTcHJlYWRFbGVtZW50KG5vZGUsIG9wdHMpIHtcbiAgaWYgKCFub2RlKSByZXR1cm4gZmFsc2U7XG4gIGlmIChub2RlLnR5cGUgIT09IFwiU3ByZWFkRWxlbWVudFwiKSByZXR1cm4gZmFsc2U7XG4gIHJldHVybiBvcHRzID09IG51bGwgfHwgKDAsIF9zaGFsbG93RXF1YWwuZGVmYXVsdCkobm9kZSwgb3B0cyk7XG59XG5mdW5jdGlvbiBpc1N1cGVyKG5vZGUsIG9wdHMpIHtcbiAgaWYgKCFub2RlKSByZXR1cm4gZmFsc2U7XG4gIGlmIChub2RlLnR5cGUgIT09IFwiU3VwZXJcIikgcmV0dXJuIGZhbHNlO1xuICByZXR1cm4gb3B0cyA9PSBudWxsIHx8ICgwLCBfc2hhbGxvd0VxdWFsLmRlZmF1bHQpKG5vZGUsIG9wdHMpO1xufVxuZnVuY3Rpb24gaXNUYWdnZWRUZW1wbGF0ZUV4cHJlc3Npb24obm9kZSwgb3B0cykge1xuICBpZiAoIW5vZGUpIHJldHVybiBmYWxzZTtcbiAgaWYgKG5vZGUudHlwZSAhPT0gXCJUYWdnZWRUZW1wbGF0ZUV4cHJlc3Npb25cIikgcmV0dXJuIGZhbHNlO1xuICByZXR1cm4gb3B0cyA9PSBudWxsIHx8ICgwLCBfc2hhbGxvd0VxdWFsLmRlZmF1bHQpKG5vZGUsIG9wdHMpO1xufVxuZnVuY3Rpb24gaXNUZW1wbGF0ZUVsZW1lbnQobm9kZSwgb3B0cykge1xuICBpZiAoIW5vZGUpIHJldHVybiBmYWxzZTtcbiAgaWYgKG5vZGUudHlwZSAhPT0gXCJUZW1wbGF0ZUVsZW1lbnRcIikgcmV0dXJuIGZhbHNlO1xuICByZXR1cm4gb3B0cyA9PSBudWxsIHx8ICgwLCBfc2hhbGxvd0VxdWFsLmRlZmF1bHQpKG5vZGUsIG9wdHMpO1xufVxuZnVuY3Rpb24gaXNUZW1wbGF0ZUxpdGVyYWwobm9kZSwgb3B0cykge1xuICBpZiAoIW5vZGUpIHJldHVybiBmYWxzZTtcbiAgaWYgKG5vZGUudHlwZSAhPT0gXCJUZW1wbGF0ZUxpdGVyYWxcIikgcmV0dXJuIGZhbHNlO1xuICByZXR1cm4gb3B0cyA9PSBudWxsIHx8ICgwLCBfc2hhbGxvd0VxdWFsLmRlZmF1bHQpKG5vZGUsIG9wdHMpO1xufVxuZnVuY3Rpb24gaXNZaWVsZEV4cHJlc3Npb24obm9kZSwgb3B0cykge1xuICBpZiAoIW5vZGUpIHJldHVybiBmYWxzZTtcbiAgaWYgKG5vZGUudHlwZSAhPT0gXCJZaWVsZEV4cHJlc3Npb25cIikgcmV0dXJuIGZhbHNlO1xuICByZXR1cm4gb3B0cyA9PSBudWxsIHx8ICgwLCBfc2hhbGxvd0VxdWFsLmRlZmF1bHQpKG5vZGUsIG9wdHMpO1xufVxuZnVuY3Rpb24gaXNBd2FpdEV4cHJlc3Npb24obm9kZSwgb3B0cykge1xuICBpZiAoIW5vZGUpIHJldHVybiBmYWxzZTtcbiAgaWYgKG5vZGUudHlwZSAhPT0gXCJBd2FpdEV4cHJlc3Npb25cIikgcmV0dXJuIGZhbHNlO1xuICByZXR1cm4gb3B0cyA9PSBudWxsIHx8ICgwLCBfc2hhbGxvd0VxdWFsLmRlZmF1bHQpKG5vZGUsIG9wdHMpO1xufVxuZnVuY3Rpb24gaXNJbXBvcnQobm9kZSwgb3B0cykge1xuICBpZiAoIW5vZGUpIHJldHVybiBmYWxzZTtcbiAgaWYgKG5vZGUudHlwZSAhPT0gXCJJbXBvcnRcIikgcmV0dXJuIGZhbHNlO1xuICByZXR1cm4gb3B0cyA9PSBudWxsIHx8ICgwLCBfc2hhbGxvd0VxdWFsLmRlZmF1bHQpKG5vZGUsIG9wdHMpO1xufVxuZnVuY3Rpb24gaXNCaWdJbnRMaXRlcmFsKG5vZGUsIG9wdHMpIHtcbiAgaWYgKCFub2RlKSByZXR1cm4gZmFsc2U7XG4gIGlmIChub2RlLnR5cGUgIT09IFwiQmlnSW50TGl0ZXJhbFwiKSByZXR1cm4gZmFsc2U7XG4gIHJldHVybiBvcHRzID09IG51bGwgfHwgKDAsIF9zaGFsbG93RXF1YWwuZGVmYXVsdCkobm9kZSwgb3B0cyk7XG59XG5mdW5jdGlvbiBpc0V4cG9ydE5hbWVzcGFjZVNwZWNpZmllcihub2RlLCBvcHRzKSB7XG4gIGlmICghbm9kZSkgcmV0dXJuIGZhbHNlO1xuICBpZiAobm9kZS50eXBlICE9PSBcIkV4cG9ydE5hbWVzcGFjZVNwZWNpZmllclwiKSByZXR1cm4gZmFsc2U7XG4gIHJldHVybiBvcHRzID09IG51bGwgfHwgKDAsIF9zaGFsbG93RXF1YWwuZGVmYXVsdCkobm9kZSwgb3B0cyk7XG59XG5mdW5jdGlvbiBpc09wdGlvbmFsTWVtYmVyRXhwcmVzc2lvbihub2RlLCBvcHRzKSB7XG4gIGlmICghbm9kZSkgcmV0dXJuIGZhbHNlO1xuICBpZiAobm9kZS50eXBlICE9PSBcIk9wdGlvbmFsTWVtYmVyRXhwcmVzc2lvblwiKSByZXR1cm4gZmFsc2U7XG4gIHJldHVybiBvcHRzID09IG51bGwgfHwgKDAsIF9zaGFsbG93RXF1YWwuZGVmYXVsdCkobm9kZSwgb3B0cyk7XG59XG5mdW5jdGlvbiBpc09wdGlvbmFsQ2FsbEV4cHJlc3Npb24obm9kZSwgb3B0cykge1xuICBpZiAoIW5vZGUpIHJldHVybiBmYWxzZTtcbiAgaWYgKG5vZGUudHlwZSAhPT0gXCJPcHRpb25hbENhbGxFeHByZXNzaW9uXCIpIHJldHVybiBmYWxzZTtcbiAgcmV0dXJuIG9wdHMgPT0gbnVsbCB8fCAoMCwgX3NoYWxsb3dFcXVhbC5kZWZhdWx0KShub2RlLCBvcHRzKTtcbn1cbmZ1bmN0aW9uIGlzQ2xhc3NQcm9wZXJ0eShub2RlLCBvcHRzKSB7XG4gIGlmICghbm9kZSkgcmV0dXJuIGZhbHNlO1xuICBpZiAobm9kZS50eXBlICE9PSBcIkNsYXNzUHJvcGVydHlcIikgcmV0dXJuIGZhbHNlO1xuICByZXR1cm4gb3B0cyA9PSBudWxsIHx8ICgwLCBfc2hhbGxvd0VxdWFsLmRlZmF1bHQpKG5vZGUsIG9wdHMpO1xufVxuZnVuY3Rpb24gaXNDbGFzc0FjY2Vzc29yUHJvcGVydHkobm9kZSwgb3B0cykge1xuICBpZiAoIW5vZGUpIHJldHVybiBmYWxzZTtcbiAgaWYgKG5vZGUudHlwZSAhPT0gXCJDbGFzc0FjY2Vzc29yUHJvcGVydHlcIikgcmV0dXJuIGZhbHNlO1xuICByZXR1cm4gb3B0cyA9PSBudWxsIHx8ICgwLCBfc2hhbGxvd0VxdWFsLmRlZmF1bHQpKG5vZGUsIG9wdHMpO1xufVxuZnVuY3Rpb24gaXNDbGFzc1ByaXZhdGVQcm9wZXJ0eShub2RlLCBvcHRzKSB7XG4gIGlmICghbm9kZSkgcmV0dXJuIGZhbHNlO1xuICBpZiAobm9kZS50eXBlICE9PSBcIkNsYXNzUHJpdmF0ZVByb3BlcnR5XCIpIHJldHVybiBmYWxzZTtcbiAgcmV0dXJuIG9wdHMgPT0gbnVsbCB8fCAoMCwgX3NoYWxsb3dFcXVhbC5kZWZhdWx0KShub2RlLCBvcHRzKTtcbn1cbmZ1bmN0aW9uIGlzQ2xhc3NQcml2YXRlTWV0aG9kKG5vZGUsIG9wdHMpIHtcbiAgaWYgKCFub2RlKSByZXR1cm4gZmFsc2U7XG4gIGlmIChub2RlLnR5cGUgIT09IFwiQ2xhc3NQcml2YXRlTWV0aG9kXCIpIHJldHVybiBmYWxzZTtcbiAgcmV0dXJuIG9wdHMgPT0gbnVsbCB8fCAoMCwgX3NoYWxsb3dFcXVhbC5kZWZhdWx0KShub2RlLCBvcHRzKTtcbn1cbmZ1bmN0aW9uIGlzUHJpdmF0ZU5hbWUobm9kZSwgb3B0cykge1xuICBpZiAoIW5vZGUpIHJldHVybiBmYWxzZTtcbiAgaWYgKG5vZGUudHlwZSAhPT0gXCJQcml2YXRlTmFtZVwiKSByZXR1cm4gZmFsc2U7XG4gIHJldHVybiBvcHRzID09IG51bGwgfHwgKDAsIF9zaGFsbG93RXF1YWwuZGVmYXVsdCkobm9kZSwgb3B0cyk7XG59XG5mdW5jdGlvbiBpc1N0YXRpY0Jsb2NrKG5vZGUsIG9wdHMpIHtcbiAgaWYgKCFub2RlKSByZXR1cm4gZmFsc2U7XG4gIGlmIChub2RlLnR5cGUgIT09IFwiU3RhdGljQmxvY2tcIikgcmV0dXJuIGZhbHNlO1xuICByZXR1cm4gb3B0cyA9PSBudWxsIHx8ICgwLCBfc2hhbGxvd0VxdWFsLmRlZmF1bHQpKG5vZGUsIG9wdHMpO1xufVxuZnVuY3Rpb24gaXNJbXBvcnRBdHRyaWJ1dGUobm9kZSwgb3B0cykge1xuICBpZiAoIW5vZGUpIHJldHVybiBmYWxzZTtcbiAgaWYgKG5vZGUudHlwZSAhPT0gXCJJbXBvcnRBdHRyaWJ1dGVcIikgcmV0dXJuIGZhbHNlO1xuICByZXR1cm4gb3B0cyA9PSBudWxsIHx8ICgwLCBfc2hhbGxvd0VxdWFsLmRlZmF1bHQpKG5vZGUsIG9wdHMpO1xufVxuZnVuY3Rpb24gaXNBbnlUeXBlQW5ub3RhdGlvbihub2RlLCBvcHRzKSB7XG4gIGlmICghbm9kZSkgcmV0dXJuIGZhbHNlO1xuICBpZiAobm9kZS50eXBlICE9PSBcIkFueVR5cGVBbm5vdGF0aW9uXCIpIHJldHVybiBmYWxzZTtcbiAgcmV0dXJuIG9wdHMgPT0gbnVsbCB8fCAoMCwgX3NoYWxsb3dFcXVhbC5kZWZhdWx0KShub2RlLCBvcHRzKTtcbn1cbmZ1bmN0aW9uIGlzQXJyYXlUeXBlQW5ub3RhdGlvbihub2RlLCBvcHRzKSB7XG4gIGlmICghbm9kZSkgcmV0dXJuIGZhbHNlO1xuICBpZiAobm9kZS50eXBlICE9PSBcIkFycmF5VHlwZUFubm90YXRpb25cIikgcmV0dXJuIGZhbHNlO1xuICByZXR1cm4gb3B0cyA9PSBudWxsIHx8ICgwLCBfc2hhbGxvd0VxdWFsLmRlZmF1bHQpKG5vZGUsIG9wdHMpO1xufVxuZnVuY3Rpb24gaXNCb29sZWFuVHlwZUFubm90YXRpb24obm9kZSwgb3B0cykge1xuICBpZiAoIW5vZGUpIHJldHVybiBmYWxzZTtcbiAgaWYgKG5vZGUudHlwZSAhPT0gXCJCb29sZWFuVHlwZUFubm90YXRpb25cIikgcmV0dXJuIGZhbHNlO1xuICByZXR1cm4gb3B0cyA9PSBudWxsIHx8ICgwLCBfc2hhbGxvd0VxdWFsLmRlZmF1bHQpKG5vZGUsIG9wdHMpO1xufVxuZnVuY3Rpb24gaXNCb29sZWFuTGl0ZXJhbFR5cGVBbm5vdGF0aW9uKG5vZGUsIG9wdHMpIHtcbiAgaWYgKCFub2RlKSByZXR1cm4gZmFsc2U7XG4gIGlmIChub2RlLnR5cGUgIT09IFwiQm9vbGVhbkxpdGVyYWxUeXBlQW5ub3RhdGlvblwiKSByZXR1cm4gZmFsc2U7XG4gIHJldHVybiBvcHRzID09IG51bGwgfHwgKDAsIF9zaGFsbG93RXF1YWwuZGVmYXVsdCkobm9kZSwgb3B0cyk7XG59XG5mdW5jdGlvbiBpc051bGxMaXRlcmFsVHlwZUFubm90YXRpb24obm9kZSwgb3B0cykge1xuICBpZiAoIW5vZGUpIHJldHVybiBmYWxzZTtcbiAgaWYgKG5vZGUudHlwZSAhPT0gXCJOdWxsTGl0ZXJhbFR5cGVBbm5vdGF0aW9uXCIpIHJldHVybiBmYWxzZTtcbiAgcmV0dXJuIG9wdHMgPT0gbnVsbCB8fCAoMCwgX3NoYWxsb3dFcXVhbC5kZWZhdWx0KShub2RlLCBvcHRzKTtcbn1cbmZ1bmN0aW9uIGlzQ2xhc3NJbXBsZW1lbnRzKG5vZGUsIG9wdHMpIHtcbiAgaWYgKCFub2RlKSByZXR1cm4gZmFsc2U7XG4gIGlmIChub2RlLnR5cGUgIT09IFwiQ2xhc3NJbXBsZW1lbnRzXCIpIHJldHVybiBmYWxzZTtcbiAgcmV0dXJuIG9wdHMgPT0gbnVsbCB8fCAoMCwgX3NoYWxsb3dFcXVhbC5kZWZhdWx0KShub2RlLCBvcHRzKTtcbn1cbmZ1bmN0aW9uIGlzRGVjbGFyZUNsYXNzKG5vZGUsIG9wdHMpIHtcbiAgaWYgKCFub2RlKSByZXR1cm4gZmFsc2U7XG4gIGlmIChub2RlLnR5cGUgIT09IFwiRGVjbGFyZUNsYXNzXCIpIHJldHVybiBmYWxzZTtcbiAgcmV0dXJuIG9wdHMgPT0gbnVsbCB8fCAoMCwgX3NoYWxsb3dFcXVhbC5kZWZhdWx0KShub2RlLCBvcHRzKTtcbn1cbmZ1bmN0aW9uIGlzRGVjbGFyZUZ1bmN0aW9uKG5vZGUsIG9wdHMpIHtcbiAgaWYgKCFub2RlKSByZXR1cm4gZmFsc2U7XG4gIGlmIChub2RlLnR5cGUgIT09IFwiRGVjbGFyZUZ1bmN0aW9uXCIpIHJldHVybiBmYWxzZTtcbiAgcmV0dXJuIG9wdHMgPT0gbnVsbCB8fCAoMCwgX3NoYWxsb3dFcXVhbC5kZWZhdWx0KShub2RlLCBvcHRzKTtcbn1cbmZ1bmN0aW9uIGlzRGVjbGFyZUludGVyZmFjZShub2RlLCBvcHRzKSB7XG4gIGlmICghbm9kZSkgcmV0dXJuIGZhbHNlO1xuICBpZiAobm9kZS50eXBlICE9PSBcIkRlY2xhcmVJbnRlcmZhY2VcIikgcmV0dXJuIGZhbHNlO1xuICByZXR1cm4gb3B0cyA9PSBudWxsIHx8ICgwLCBfc2hhbGxvd0VxdWFsLmRlZmF1bHQpKG5vZGUsIG9wdHMpO1xufVxuZnVuY3Rpb24gaXNEZWNsYXJlTW9kdWxlKG5vZGUsIG9wdHMpIHtcbiAgaWYgKCFub2RlKSByZXR1cm4gZmFsc2U7XG4gIGlmIChub2RlLnR5cGUgIT09IFwiRGVjbGFyZU1vZHVsZVwiKSByZXR1cm4gZmFsc2U7XG4gIHJldHVybiBvcHRzID09IG51bGwgfHwgKDAsIF9zaGFsbG93RXF1YWwuZGVmYXVsdCkobm9kZSwgb3B0cyk7XG59XG5mdW5jdGlvbiBpc0RlY2xhcmVNb2R1bGVFeHBvcnRzKG5vZGUsIG9wdHMpIHtcbiAgaWYgKCFub2RlKSByZXR1cm4gZmFsc2U7XG4gIGlmIChub2RlLnR5cGUgIT09IFwiRGVjbGFyZU1vZHVsZUV4cG9ydHNcIikgcmV0dXJuIGZhbHNlO1xuICByZXR1cm4gb3B0cyA9PSBudWxsIHx8ICgwLCBfc2hhbGxvd0VxdWFsLmRlZmF1bHQpKG5vZGUsIG9wdHMpO1xufVxuZnVuY3Rpb24gaXNEZWNsYXJlVHlwZUFsaWFzKG5vZGUsIG9wdHMpIHtcbiAgaWYgKCFub2RlKSByZXR1cm4gZmFsc2U7XG4gIGlmIChub2RlLnR5cGUgIT09IFwiRGVjbGFyZVR5cGVBbGlhc1wiKSByZXR1cm4gZmFsc2U7XG4gIHJldHVybiBvcHRzID09IG51bGwgfHwgKDAsIF9zaGFsbG93RXF1YWwuZGVmYXVsdCkobm9kZSwgb3B0cyk7XG59XG5mdW5jdGlvbiBpc0RlY2xhcmVPcGFxdWVUeXBlKG5vZGUsIG9wdHMpIHtcbiAgaWYgKCFub2RlKSByZXR1cm4gZmFsc2U7XG4gIGlmIChub2RlLnR5cGUgIT09IFwiRGVjbGFyZU9wYXF1ZVR5cGVcIikgcmV0dXJuIGZhbHNlO1xuICByZXR1cm4gb3B0cyA9PSBudWxsIHx8ICgwLCBfc2hhbGxvd0VxdWFsLmRlZmF1bHQpKG5vZGUsIG9wdHMpO1xufVxuZnVuY3Rpb24gaXNEZWNsYXJlVmFyaWFibGUobm9kZSwgb3B0cykge1xuICBpZiAoIW5vZGUpIHJldHVybiBmYWxzZTtcbiAgaWYgKG5vZGUudHlwZSAhPT0gXCJEZWNsYXJlVmFyaWFibGVcIikgcmV0dXJuIGZhbHNlO1xuICByZXR1cm4gb3B0cyA9PSBudWxsIHx8ICgwLCBfc2hhbGxvd0VxdWFsLmRlZmF1bHQpKG5vZGUsIG9wdHMpO1xufVxuZnVuY3Rpb24gaXNEZWNsYXJlRXhwb3J0RGVjbGFyYXRpb24obm9kZSwgb3B0cykge1xuICBpZiAoIW5vZGUpIHJldHVybiBmYWxzZTtcbiAgaWYgKG5vZGUudHlwZSAhPT0gXCJEZWNsYXJlRXhwb3J0RGVjbGFyYXRpb25cIikgcmV0dXJuIGZhbHNlO1xuICByZXR1cm4gb3B0cyA9PSBudWxsIHx8ICgwLCBfc2hhbGxvd0VxdWFsLmRlZmF1bHQpKG5vZGUsIG9wdHMpO1xufVxuZnVuY3Rpb24gaXNEZWNsYXJlRXhwb3J0QWxsRGVjbGFyYXRpb24obm9kZSwgb3B0cykge1xuICBpZiAoIW5vZGUpIHJldHVybiBmYWxzZTtcbiAgaWYgKG5vZGUudHlwZSAhPT0gXCJEZWNsYXJlRXhwb3J0QWxsRGVjbGFyYXRpb25cIikgcmV0dXJuIGZhbHNlO1xuICByZXR1cm4gb3B0cyA9PSBudWxsIHx8ICgwLCBfc2hhbGxvd0VxdWFsLmRlZmF1bHQpKG5vZGUsIG9wdHMpO1xufVxuZnVuY3Rpb24gaXNEZWNsYXJlZFByZWRpY2F0ZShub2RlLCBvcHRzKSB7XG4gIGlmICghbm9kZSkgcmV0dXJuIGZhbHNlO1xuICBpZiAobm9kZS50eXBlICE9PSBcIkRlY2xhcmVkUHJlZGljYXRlXCIpIHJldHVybiBmYWxzZTtcbiAgcmV0dXJuIG9wdHMgPT0gbnVsbCB8fCAoMCwgX3NoYWxsb3dFcXVhbC5kZWZhdWx0KShub2RlLCBvcHRzKTtcbn1cbmZ1bmN0aW9uIGlzRXhpc3RzVHlwZUFubm90YXRpb24obm9kZSwgb3B0cykge1xuICBpZiAoIW5vZGUpIHJldHVybiBmYWxzZTtcbiAgaWYgKG5vZGUudHlwZSAhPT0gXCJFeGlzdHNUeXBlQW5ub3RhdGlvblwiKSByZXR1cm4gZmFsc2U7XG4gIHJldHVybiBvcHRzID09IG51bGwgfHwgKDAsIF9zaGFsbG93RXF1YWwuZGVmYXVsdCkobm9kZSwgb3B0cyk7XG59XG5mdW5jdGlvbiBpc0Z1bmN0aW9uVHlwZUFubm90YXRpb24obm9kZSwgb3B0cykge1xuICBpZiAoIW5vZGUpIHJldHVybiBmYWxzZTtcbiAgaWYgKG5vZGUudHlwZSAhPT0gXCJGdW5jdGlvblR5cGVBbm5vdGF0aW9uXCIpIHJldHVybiBmYWxzZTtcbiAgcmV0dXJuIG9wdHMgPT0gbnVsbCB8fCAoMCwgX3NoYWxsb3dFcXVhbC5kZWZhdWx0KShub2RlLCBvcHRzKTtcbn1cbmZ1bmN0aW9uIGlzRnVuY3Rpb25UeXBlUGFyYW0obm9kZSwgb3B0cykge1xuICBpZiAoIW5vZGUpIHJldHVybiBmYWxzZTtcbiAgaWYgKG5vZGUudHlwZSAhPT0gXCJGdW5jdGlvblR5cGVQYXJhbVwiKSByZXR1cm4gZmFsc2U7XG4gIHJldHVybiBvcHRzID09IG51bGwgfHwgKDAsIF9zaGFsbG93RXF1YWwuZGVmYXVsdCkobm9kZSwgb3B0cyk7XG59XG5mdW5jdGlvbiBpc0dlbmVyaWNUeXBlQW5ub3RhdGlvbihub2RlLCBvcHRzKSB7XG4gIGlmICghbm9kZSkgcmV0dXJuIGZhbHNlO1xuICBpZiAobm9kZS50eXBlICE9PSBcIkdlbmVyaWNUeXBlQW5ub3RhdGlvblwiKSByZXR1cm4gZmFsc2U7XG4gIHJldHVybiBvcHRzID09IG51bGwgfHwgKDAsIF9zaGFsbG93RXF1YWwuZGVmYXVsdCkobm9kZSwgb3B0cyk7XG59XG5mdW5jdGlvbiBpc0luZmVycmVkUHJlZGljYXRlKG5vZGUsIG9wdHMpIHtcbiAgaWYgKCFub2RlKSByZXR1cm4gZmFsc2U7XG4gIGlmIChub2RlLnR5cGUgIT09IFwiSW5mZXJyZWRQcmVkaWNhdGVcIikgcmV0dXJuIGZhbHNlO1xuICByZXR1cm4gb3B0cyA9PSBudWxsIHx8ICgwLCBfc2hhbGxvd0VxdWFsLmRlZmF1bHQpKG5vZGUsIG9wdHMpO1xufVxuZnVuY3Rpb24gaXNJbnRlcmZhY2VFeHRlbmRzKG5vZGUsIG9wdHMpIHtcbiAgaWYgKCFub2RlKSByZXR1cm4gZmFsc2U7XG4gIGlmIChub2RlLnR5cGUgIT09IFwiSW50ZXJmYWNlRXh0ZW5kc1wiKSByZXR1cm4gZmFsc2U7XG4gIHJldHVybiBvcHRzID09IG51bGwgfHwgKDAsIF9zaGFsbG93RXF1YWwuZGVmYXVsdCkobm9kZSwgb3B0cyk7XG59XG5mdW5jdGlvbiBpc0ludGVyZmFjZURlY2xhcmF0aW9uKG5vZGUsIG9wdHMpIHtcbiAgaWYgKCFub2RlKSByZXR1cm4gZmFsc2U7XG4gIGlmIChub2RlLnR5cGUgIT09IFwiSW50ZXJmYWNlRGVjbGFyYXRpb25cIikgcmV0dXJuIGZhbHNlO1xuICByZXR1cm4gb3B0cyA9PSBudWxsIHx8ICgwLCBfc2hhbGxvd0VxdWFsLmRlZmF1bHQpKG5vZGUsIG9wdHMpO1xufVxuZnVuY3Rpb24gaXNJbnRlcmZhY2VUeXBlQW5ub3RhdGlvbihub2RlLCBvcHRzKSB7XG4gIGlmICghbm9kZSkgcmV0dXJuIGZhbHNlO1xuICBpZiAobm9kZS50eXBlICE9PSBcIkludGVyZmFjZVR5cGVBbm5vdGF0aW9uXCIpIHJldHVybiBmYWxzZTtcbiAgcmV0dXJuIG9wdHMgPT0gbnVsbCB8fCAoMCwgX3NoYWxsb3dFcXVhbC5kZWZhdWx0KShub2RlLCBvcHRzKTtcbn1cbmZ1bmN0aW9uIGlzSW50ZXJzZWN0aW9uVHlwZUFubm90YXRpb24obm9kZSwgb3B0cykge1xuICBpZiAoIW5vZGUpIHJldHVybiBmYWxzZTtcbiAgaWYgKG5vZGUudHlwZSAhPT0gXCJJbnRlcnNlY3Rpb25UeXBlQW5ub3RhdGlvblwiKSByZXR1cm4gZmFsc2U7XG4gIHJldHVybiBvcHRzID09IG51bGwgfHwgKDAsIF9zaGFsbG93RXF1YWwuZGVmYXVsdCkobm9kZSwgb3B0cyk7XG59XG5mdW5jdGlvbiBpc01peGVkVHlwZUFubm90YXRpb24obm9kZSwgb3B0cykge1xuICBpZiAoIW5vZGUpIHJldHVybiBmYWxzZTtcbiAgaWYgKG5vZGUudHlwZSAhPT0gXCJNaXhlZFR5cGVBbm5vdGF0aW9uXCIpIHJldHVybiBmYWxzZTtcbiAgcmV0dXJuIG9wdHMgPT0gbnVsbCB8fCAoMCwgX3NoYWxsb3dFcXVhbC5kZWZhdWx0KShub2RlLCBvcHRzKTtcbn1cbmZ1bmN0aW9uIGlzRW1wdHlUeXBlQW5ub3RhdGlvbihub2RlLCBvcHRzKSB7XG4gIGlmICghbm9kZSkgcmV0dXJuIGZhbHNlO1xuICBpZiAobm9kZS50eXBlICE9PSBcIkVtcHR5VHlwZUFubm90YXRpb25cIikgcmV0dXJuIGZhbHNlO1xuICByZXR1cm4gb3B0cyA9PSBudWxsIHx8ICgwLCBfc2hhbGxvd0VxdWFsLmRlZmF1bHQpKG5vZGUsIG9wdHMpO1xufVxuZnVuY3Rpb24gaXNOdWxsYWJsZVR5cGVBbm5vdGF0aW9uKG5vZGUsIG9wdHMpIHtcbiAgaWYgKCFub2RlKSByZXR1cm4gZmFsc2U7XG4gIGlmIChub2RlLnR5cGUgIT09IFwiTnVsbGFibGVUeXBlQW5ub3RhdGlvblwiKSByZXR1cm4gZmFsc2U7XG4gIHJldHVybiBvcHRzID09IG51bGwgfHwgKDAsIF9zaGFsbG93RXF1YWwuZGVmYXVsdCkobm9kZSwgb3B0cyk7XG59XG5mdW5jdGlvbiBpc051bWJlckxpdGVyYWxUeXBlQW5ub3RhdGlvbihub2RlLCBvcHRzKSB7XG4gIGlmICghbm9kZSkgcmV0dXJuIGZhbHNlO1xuICBpZiAobm9kZS50eXBlICE9PSBcIk51bWJlckxpdGVyYWxUeXBlQW5ub3RhdGlvblwiKSByZXR1cm4gZmFsc2U7XG4gIHJldHVybiBvcHRzID09IG51bGwgfHwgKDAsIF9zaGFsbG93RXF1YWwuZGVmYXVsdCkobm9kZSwgb3B0cyk7XG59XG5mdW5jdGlvbiBpc051bWJlclR5cGVBbm5vdGF0aW9uKG5vZGUsIG9wdHMpIHtcbiAgaWYgKCFub2RlKSByZXR1cm4gZmFsc2U7XG4gIGlmIChub2RlLnR5cGUgIT09IFwiTnVtYmVyVHlwZUFubm90YXRpb25cIikgcmV0dXJuIGZhbHNlO1xuICByZXR1cm4gb3B0cyA9PSBudWxsIHx8ICgwLCBfc2hhbGxvd0VxdWFsLmRlZmF1bHQpKG5vZGUsIG9wdHMpO1xufVxuZnVuY3Rpb24gaXNPYmplY3RUeXBlQW5ub3RhdGlvbihub2RlLCBvcHRzKSB7XG4gIGlmICghbm9kZSkgcmV0dXJuIGZhbHNlO1xuICBpZiAobm9kZS50eXBlICE9PSBcIk9iamVjdFR5cGVBbm5vdGF0aW9uXCIpIHJldHVybiBmYWxzZTtcbiAgcmV0dXJuIG9wdHMgPT0gbnVsbCB8fCAoMCwgX3NoYWxsb3dFcXVhbC5kZWZhdWx0KShub2RlLCBvcHRzKTtcbn1cbmZ1bmN0aW9uIGlzT2JqZWN0VHlwZUludGVybmFsU2xvdChub2RlLCBvcHRzKSB7XG4gIGlmICghbm9kZSkgcmV0dXJuIGZhbHNlO1xuICBpZiAobm9kZS50eXBlICE9PSBcIk9iamVjdFR5cGVJbnRlcm5hbFNsb3RcIikgcmV0dXJuIGZhbHNlO1xuICByZXR1cm4gb3B0cyA9PSBudWxsIHx8ICgwLCBfc2hhbGxvd0VxdWFsLmRlZmF1bHQpKG5vZGUsIG9wdHMpO1xufVxuZnVuY3Rpb24gaXNPYmplY3RUeXBlQ2FsbFByb3BlcnR5KG5vZGUsIG9wdHMpIHtcbiAgaWYgKCFub2RlKSByZXR1cm4gZmFsc2U7XG4gIGlmIChub2RlLnR5cGUgIT09IFwiT2JqZWN0VHlwZUNhbGxQcm9wZXJ0eVwiKSByZXR1cm4gZmFsc2U7XG4gIHJldHVybiBvcHRzID09IG51bGwgfHwgKDAsIF9zaGFsbG93RXF1YWwuZGVmYXVsdCkobm9kZSwgb3B0cyk7XG59XG5mdW5jdGlvbiBpc09iamVjdFR5cGVJbmRleGVyKG5vZGUsIG9wdHMpIHtcbiAgaWYgKCFub2RlKSByZXR1cm4gZmFsc2U7XG4gIGlmIChub2RlLnR5cGUgIT09IFwiT2JqZWN0VHlwZUluZGV4ZXJcIikgcmV0dXJuIGZhbHNlO1xuICByZXR1cm4gb3B0cyA9PSBudWxsIHx8ICgwLCBfc2hhbGxvd0VxdWFsLmRlZmF1bHQpKG5vZGUsIG9wdHMpO1xufVxuZnVuY3Rpb24gaXNPYmplY3RUeXBlUHJvcGVydHkobm9kZSwgb3B0cykge1xuICBpZiAoIW5vZGUpIHJldHVybiBmYWxzZTtcbiAgaWYgKG5vZGUudHlwZSAhPT0gXCJPYmplY3RUeXBlUHJvcGVydHlcIikgcmV0dXJuIGZhbHNlO1xuICByZXR1cm4gb3B0cyA9PSBudWxsIHx8ICgwLCBfc2hhbGxvd0VxdWFsLmRlZmF1bHQpKG5vZGUsIG9wdHMpO1xufVxuZnVuY3Rpb24gaXNPYmplY3RUeXBlU3ByZWFkUHJvcGVydHkobm9kZSwgb3B0cykge1xuICBpZiAoIW5vZGUpIHJldHVybiBmYWxzZTtcbiAgaWYgKG5vZGUudHlwZSAhPT0gXCJPYmplY3RUeXBlU3ByZWFkUHJvcGVydHlcIikgcmV0dXJuIGZhbHNlO1xuICByZXR1cm4gb3B0cyA9PSBudWxsIHx8ICgwLCBfc2hhbGxvd0VxdWFsLmRlZmF1bHQpKG5vZGUsIG9wdHMpO1xufVxuZnVuY3Rpb24gaXNPcGFxdWVUeXBlKG5vZGUsIG9wdHMpIHtcbiAgaWYgKCFub2RlKSByZXR1cm4gZmFsc2U7XG4gIGlmIChub2RlLnR5cGUgIT09IFwiT3BhcXVlVHlwZVwiKSByZXR1cm4gZmFsc2U7XG4gIHJldHVybiBvcHRzID09IG51bGwgfHwgKDAsIF9zaGFsbG93RXF1YWwuZGVmYXVsdCkobm9kZSwgb3B0cyk7XG59XG5mdW5jdGlvbiBpc1F1YWxpZmllZFR5cGVJZGVudGlmaWVyKG5vZGUsIG9wdHMpIHtcbiAgaWYgKCFub2RlKSByZXR1cm4gZmFsc2U7XG4gIGlmIChub2RlLnR5cGUgIT09IFwiUXVhbGlmaWVkVHlwZUlkZW50aWZpZXJcIikgcmV0dXJuIGZhbHNlO1xuICByZXR1cm4gb3B0cyA9PSBudWxsIHx8ICgwLCBfc2hhbGxvd0VxdWFsLmRlZmF1bHQpKG5vZGUsIG9wdHMpO1xufVxuZnVuY3Rpb24gaXNTdHJpbmdMaXRlcmFsVHlwZUFubm90YXRpb24obm9kZSwgb3B0cykge1xuICBpZiAoIW5vZGUpIHJldHVybiBmYWxzZTtcbiAgaWYgKG5vZGUudHlwZSAhPT0gXCJTdHJpbmdMaXRlcmFsVHlwZUFubm90YXRpb25cIikgcmV0dXJuIGZhbHNlO1xuICByZXR1cm4gb3B0cyA9PSBudWxsIHx8ICgwLCBfc2hhbGxvd0VxdWFsLmRlZmF1bHQpKG5vZGUsIG9wdHMpO1xufVxuZnVuY3Rpb24gaXNTdHJpbmdUeXBlQW5ub3RhdGlvbihub2RlLCBvcHRzKSB7XG4gIGlmICghbm9kZSkgcmV0dXJuIGZhbHNlO1xuICBpZiAobm9kZS50eXBlICE9PSBcIlN0cmluZ1R5cGVBbm5vdGF0aW9uXCIpIHJldHVybiBmYWxzZTtcbiAgcmV0dXJuIG9wdHMgPT0gbnVsbCB8fCAoMCwgX3NoYWxsb3dFcXVhbC5kZWZhdWx0KShub2RlLCBvcHRzKTtcbn1cbmZ1bmN0aW9uIGlzU3ltYm9sVHlwZUFubm90YXRpb24obm9kZSwgb3B0cykge1xuICBpZiAoIW5vZGUpIHJldHVybiBmYWxzZTtcbiAgaWYgKG5vZGUudHlwZSAhPT0gXCJTeW1ib2xUeXBlQW5ub3RhdGlvblwiKSByZXR1cm4gZmFsc2U7XG4gIHJldHVybiBvcHRzID09IG51bGwgfHwgKDAsIF9zaGFsbG93RXF1YWwuZGVmYXVsdCkobm9kZSwgb3B0cyk7XG59XG5mdW5jdGlvbiBpc1RoaXNUeXBlQW5ub3RhdGlvbihub2RlLCBvcHRzKSB7XG4gIGlmICghbm9kZSkgcmV0dXJuIGZhbHNlO1xuICBpZiAobm9kZS50eXBlICE9PSBcIlRoaXNUeXBlQW5ub3RhdGlvblwiKSByZXR1cm4gZmFsc2U7XG4gIHJldHVybiBvcHRzID09IG51bGwgfHwgKDAsIF9zaGFsbG93RXF1YWwuZGVmYXVsdCkobm9kZSwgb3B0cyk7XG59XG5mdW5jdGlvbiBpc1R1cGxlVHlwZUFubm90YXRpb24obm9kZSwgb3B0cykge1xuICBpZiAoIW5vZGUpIHJldHVybiBmYWxzZTtcbiAgaWYgKG5vZGUudHlwZSAhPT0gXCJUdXBsZVR5cGVBbm5vdGF0aW9uXCIpIHJldHVybiBmYWxzZTtcbiAgcmV0dXJuIG9wdHMgPT0gbnVsbCB8fCAoMCwgX3NoYWxsb3dFcXVhbC5kZWZhdWx0KShub2RlLCBvcHRzKTtcbn1cbmZ1bmN0aW9uIGlzVHlwZW9mVHlwZUFubm90YXRpb24obm9kZSwgb3B0cykge1xuICBpZiAoIW5vZGUpIHJldHVybiBmYWxzZTtcbiAgaWYgKG5vZGUudHlwZSAhPT0gXCJUeXBlb2ZUeXBlQW5ub3RhdGlvblwiKSByZXR1cm4gZmFsc2U7XG4gIHJldHVybiBvcHRzID09IG51bGwgfHwgKDAsIF9zaGFsbG93RXF1YWwuZGVmYXVsdCkobm9kZSwgb3B0cyk7XG59XG5mdW5jdGlvbiBpc1R5cGVBbGlhcyhub2RlLCBvcHRzKSB7XG4gIGlmICghbm9kZSkgcmV0dXJuIGZhbHNlO1xuICBpZiAobm9kZS50eXBlICE9PSBcIlR5cGVBbGlhc1wiKSByZXR1cm4gZmFsc2U7XG4gIHJldHVybiBvcHRzID09IG51bGwgfHwgKDAsIF9zaGFsbG93RXF1YWwuZGVmYXVsdCkobm9kZSwgb3B0cyk7XG59XG5mdW5jdGlvbiBpc1R5cGVBbm5vdGF0aW9uKG5vZGUsIG9wdHMpIHtcbiAgaWYgKCFub2RlKSByZXR1cm4gZmFsc2U7XG4gIGlmIChub2RlLnR5cGUgIT09IFwiVHlwZUFubm90YXRpb25cIikgcmV0dXJuIGZhbHNlO1xuICByZXR1cm4gb3B0cyA9PSBudWxsIHx8ICgwLCBfc2hhbGxvd0VxdWFsLmRlZmF1bHQpKG5vZGUsIG9wdHMpO1xufVxuZnVuY3Rpb24gaXNUeXBlQ2FzdEV4cHJlc3Npb24obm9kZSwgb3B0cykge1xuICBpZiAoIW5vZGUpIHJldHVybiBmYWxzZTtcbiAgaWYgKG5vZGUudHlwZSAhPT0gXCJUeXBlQ2FzdEV4cHJlc3Npb25cIikgcmV0dXJuIGZhbHNlO1xuICByZXR1cm4gb3B0cyA9PSBudWxsIHx8ICgwLCBfc2hhbGxvd0VxdWFsLmRlZmF1bHQpKG5vZGUsIG9wdHMpO1xufVxuZnVuY3Rpb24gaXNUeXBlUGFyYW1ldGVyKG5vZGUsIG9wdHMpIHtcbiAgaWYgKCFub2RlKSByZXR1cm4gZmFsc2U7XG4gIGlmIChub2RlLnR5cGUgIT09IFwiVHlwZVBhcmFtZXRlclwiKSByZXR1cm4gZmFsc2U7XG4gIHJldHVybiBvcHRzID09IG51bGwgfHwgKDAsIF9zaGFsbG93RXF1YWwuZGVmYXVsdCkobm9kZSwgb3B0cyk7XG59XG5mdW5jdGlvbiBpc1R5cGVQYXJhbWV0ZXJEZWNsYXJhdGlvbihub2RlLCBvcHRzKSB7XG4gIGlmICghbm9kZSkgcmV0dXJuIGZhbHNlO1xuICBpZiAobm9kZS50eXBlICE9PSBcIlR5cGVQYXJhbWV0ZXJEZWNsYXJhdGlvblwiKSByZXR1cm4gZmFsc2U7XG4gIHJldHVybiBvcHRzID09IG51bGwgfHwgKDAsIF9zaGFsbG93RXF1YWwuZGVmYXVsdCkobm9kZSwgb3B0cyk7XG59XG5mdW5jdGlvbiBpc1R5cGVQYXJhbWV0ZXJJbnN0YW50aWF0aW9uKG5vZGUsIG9wdHMpIHtcbiAgaWYgKCFub2RlKSByZXR1cm4gZmFsc2U7XG4gIGlmIChub2RlLnR5cGUgIT09IFwiVHlwZVBhcmFtZXRlckluc3RhbnRpYXRpb25cIikgcmV0dXJuIGZhbHNlO1xuICByZXR1cm4gb3B0cyA9PSBudWxsIHx8ICgwLCBfc2hhbGxvd0VxdWFsLmRlZmF1bHQpKG5vZGUsIG9wdHMpO1xufVxuZnVuY3Rpb24gaXNVbmlvblR5cGVBbm5vdGF0aW9uKG5vZGUsIG9wdHMpIHtcbiAgaWYgKCFub2RlKSByZXR1cm4gZmFsc2U7XG4gIGlmIChub2RlLnR5cGUgIT09IFwiVW5pb25UeXBlQW5ub3RhdGlvblwiKSByZXR1cm4gZmFsc2U7XG4gIHJldHVybiBvcHRzID09IG51bGwgfHwgKDAsIF9zaGFsbG93RXF1YWwuZGVmYXVsdCkobm9kZSwgb3B0cyk7XG59XG5mdW5jdGlvbiBpc1ZhcmlhbmNlKG5vZGUsIG9wdHMpIHtcbiAgaWYgKCFub2RlKSByZXR1cm4gZmFsc2U7XG4gIGlmIChub2RlLnR5cGUgIT09IFwiVmFyaWFuY2VcIikgcmV0dXJuIGZhbHNlO1xuICByZXR1cm4gb3B0cyA9PSBudWxsIHx8ICgwLCBfc2hhbGxvd0VxdWFsLmRlZmF1bHQpKG5vZGUsIG9wdHMpO1xufVxuZnVuY3Rpb24gaXNWb2lkVHlwZUFubm90YXRpb24obm9kZSwgb3B0cykge1xuICBpZiAoIW5vZGUpIHJldHVybiBmYWxzZTtcbiAgaWYgKG5vZGUudHlwZSAhPT0gXCJWb2lkVHlwZUFubm90YXRpb25cIikgcmV0dXJuIGZhbHNlO1xuICByZXR1cm4gb3B0cyA9PSBudWxsIHx8ICgwLCBfc2hhbGxvd0VxdWFsLmRlZmF1bHQpKG5vZGUsIG9wdHMpO1xufVxuZnVuY3Rpb24gaXNFbnVtRGVjbGFyYXRpb24obm9kZSwgb3B0cykge1xuICBpZiAoIW5vZGUpIHJldHVybiBmYWxzZTtcbiAgaWYgKG5vZGUudHlwZSAhPT0gXCJFbnVtRGVjbGFyYXRpb25cIikgcmV0dXJuIGZhbHNlO1xuICByZXR1cm4gb3B0cyA9PSBudWxsIHx8ICgwLCBfc2hhbGxvd0VxdWFsLmRlZmF1bHQpKG5vZGUsIG9wdHMpO1xufVxuZnVuY3Rpb24gaXNFbnVtQm9vbGVhbkJvZHkobm9kZSwgb3B0cykge1xuICBpZiAoIW5vZGUpIHJldHVybiBmYWxzZTtcbiAgaWYgKG5vZGUudHlwZSAhPT0gXCJFbnVtQm9vbGVhbkJvZHlcIikgcmV0dXJuIGZhbHNlO1xuICByZXR1cm4gb3B0cyA9PSBudWxsIHx8ICgwLCBfc2hhbGxvd0VxdWFsLmRlZmF1bHQpKG5vZGUsIG9wdHMpO1xufVxuZnVuY3Rpb24gaXNFbnVtTnVtYmVyQm9keShub2RlLCBvcHRzKSB7XG4gIGlmICghbm9kZSkgcmV0dXJuIGZhbHNlO1xuICBpZiAobm9kZS50eXBlICE9PSBcIkVudW1OdW1iZXJCb2R5XCIpIHJldHVybiBmYWxzZTtcbiAgcmV0dXJuIG9wdHMgPT0gbnVsbCB8fCAoMCwgX3NoYWxsb3dFcXVhbC5kZWZhdWx0KShub2RlLCBvcHRzKTtcbn1cbmZ1bmN0aW9uIGlzRW51bVN0cmluZ0JvZHkobm9kZSwgb3B0cykge1xuICBpZiAoIW5vZGUpIHJldHVybiBmYWxzZTtcbiAgaWYgKG5vZGUudHlwZSAhPT0gXCJFbnVtU3RyaW5nQm9keVwiKSByZXR1cm4gZmFsc2U7XG4gIHJldHVybiBvcHRzID09IG51bGwgfHwgKDAsIF9zaGFsbG93RXF1YWwuZGVmYXVsdCkobm9kZSwgb3B0cyk7XG59XG5mdW5jdGlvbiBpc0VudW1TeW1ib2xCb2R5KG5vZGUsIG9wdHMpIHtcbiAgaWYgKCFub2RlKSByZXR1cm4gZmFsc2U7XG4gIGlmIChub2RlLnR5cGUgIT09IFwiRW51bVN5bWJvbEJvZHlcIikgcmV0dXJuIGZhbHNlO1xuICByZXR1cm4gb3B0cyA9PSBudWxsIHx8ICgwLCBfc2hhbGxvd0VxdWFsLmRlZmF1bHQpKG5vZGUsIG9wdHMpO1xufVxuZnVuY3Rpb24gaXNFbnVtQm9vbGVhbk1lbWJlcihub2RlLCBvcHRzKSB7XG4gIGlmICghbm9kZSkgcmV0dXJuIGZhbHNlO1xuICBpZiAobm9kZS50eXBlICE9PSBcIkVudW1Cb29sZWFuTWVtYmVyXCIpIHJldHVybiBmYWxzZTtcbiAgcmV0dXJuIG9wdHMgPT0gbnVsbCB8fCAoMCwgX3NoYWxsb3dFcXVhbC5kZWZhdWx0KShub2RlLCBvcHRzKTtcbn1cbmZ1bmN0aW9uIGlzRW51bU51bWJlck1lbWJlcihub2RlLCBvcHRzKSB7XG4gIGlmICghbm9kZSkgcmV0dXJuIGZhbHNlO1xuICBpZiAobm9kZS50eXBlICE9PSBcIkVudW1OdW1iZXJNZW1iZXJcIikgcmV0dXJuIGZhbHNlO1xuICByZXR1cm4gb3B0cyA9PSBudWxsIHx8ICgwLCBfc2hhbGxvd0VxdWFsLmRlZmF1bHQpKG5vZGUsIG9wdHMpO1xufVxuZnVuY3Rpb24gaXNFbnVtU3RyaW5nTWVtYmVyKG5vZGUsIG9wdHMpIHtcbiAgaWYgKCFub2RlKSByZXR1cm4gZmFsc2U7XG4gIGlmIChub2RlLnR5cGUgIT09IFwiRW51bVN0cmluZ01lbWJlclwiKSByZXR1cm4gZmFsc2U7XG4gIHJldHVybiBvcHRzID09IG51bGwgfHwgKDAsIF9zaGFsbG93RXF1YWwuZGVmYXVsdCkobm9kZSwgb3B0cyk7XG59XG5mdW5jdGlvbiBpc0VudW1EZWZhdWx0ZWRNZW1iZXIobm9kZSwgb3B0cykge1xuICBpZiAoIW5vZGUpIHJldHVybiBmYWxzZTtcbiAgaWYgKG5vZGUudHlwZSAhPT0gXCJFbnVtRGVmYXVsdGVkTWVtYmVyXCIpIHJldHVybiBmYWxzZTtcbiAgcmV0dXJuIG9wdHMgPT0gbnVsbCB8fCAoMCwgX3NoYWxsb3dFcXVhbC5kZWZhdWx0KShub2RlLCBvcHRzKTtcbn1cbmZ1bmN0aW9uIGlzSW5kZXhlZEFjY2Vzc1R5cGUobm9kZSwgb3B0cykge1xuICBpZiAoIW5vZGUpIHJldHVybiBmYWxzZTtcbiAgaWYgKG5vZGUudHlwZSAhPT0gXCJJbmRleGVkQWNjZXNzVHlwZVwiKSByZXR1cm4gZmFsc2U7XG4gIHJldHVybiBvcHRzID09IG51bGwgfHwgKDAsIF9zaGFsbG93RXF1YWwuZGVmYXVsdCkobm9kZSwgb3B0cyk7XG59XG5mdW5jdGlvbiBpc09wdGlvbmFsSW5kZXhlZEFjY2Vzc1R5cGUobm9kZSwgb3B0cykge1xuICBpZiAoIW5vZGUpIHJldHVybiBmYWxzZTtcbiAgaWYgKG5vZGUudHlwZSAhPT0gXCJPcHRpb25hbEluZGV4ZWRBY2Nlc3NUeXBlXCIpIHJldHVybiBmYWxzZTtcbiAgcmV0dXJuIG9wdHMgPT0gbnVsbCB8fCAoMCwgX3NoYWxsb3dFcXVhbC5kZWZhdWx0KShub2RlLCBvcHRzKTtcbn1cbmZ1bmN0aW9uIGlzSlNYQXR0cmlidXRlKG5vZGUsIG9wdHMpIHtcbiAgaWYgKCFub2RlKSByZXR1cm4gZmFsc2U7XG4gIGlmIChub2RlLnR5cGUgIT09IFwiSlNYQXR0cmlidXRlXCIpIHJldHVybiBmYWxzZTtcbiAgcmV0dXJuIG9wdHMgPT0gbnVsbCB8fCAoMCwgX3NoYWxsb3dFcXVhbC5kZWZhdWx0KShub2RlLCBvcHRzKTtcbn1cbmZ1bmN0aW9uIGlzSlNYQ2xvc2luZ0VsZW1lbnQobm9kZSwgb3B0cykge1xuICBpZiAoIW5vZGUpIHJldHVybiBmYWxzZTtcbiAgaWYgKG5vZGUudHlwZSAhPT0gXCJKU1hDbG9zaW5nRWxlbWVudFwiKSByZXR1cm4gZmFsc2U7XG4gIHJldHVybiBvcHRzID09IG51bGwgfHwgKDAsIF9zaGFsbG93RXF1YWwuZGVmYXVsdCkobm9kZSwgb3B0cyk7XG59XG5mdW5jdGlvbiBpc0pTWEVsZW1lbnQobm9kZSwgb3B0cykge1xuICBpZiAoIW5vZGUpIHJldHVybiBmYWxzZTtcbiAgaWYgKG5vZGUudHlwZSAhPT0gXCJKU1hFbGVtZW50XCIpIHJldHVybiBmYWxzZTtcbiAgcmV0dXJuIG9wdHMgPT0gbnVsbCB8fCAoMCwgX3NoYWxsb3dFcXVhbC5kZWZhdWx0KShub2RlLCBvcHRzKTtcbn1cbmZ1bmN0aW9uIGlzSlNYRW1wdHlFeHByZXNzaW9uKG5vZGUsIG9wdHMpIHtcbiAgaWYgKCFub2RlKSByZXR1cm4gZmFsc2U7XG4gIGlmIChub2RlLnR5cGUgIT09IFwiSlNYRW1wdHlFeHByZXNzaW9uXCIpIHJldHVybiBmYWxzZTtcbiAgcmV0dXJuIG9wdHMgPT0gbnVsbCB8fCAoMCwgX3NoYWxsb3dFcXVhbC5kZWZhdWx0KShub2RlLCBvcHRzKTtcbn1cbmZ1bmN0aW9uIGlzSlNYRXhwcmVzc2lvbkNvbnRhaW5lcihub2RlLCBvcHRzKSB7XG4gIGlmICghbm9kZSkgcmV0dXJuIGZhbHNlO1xuICBpZiAobm9kZS50eXBlICE9PSBcIkpTWEV4cHJlc3Npb25Db250YWluZXJcIikgcmV0dXJuIGZhbHNlO1xuICByZXR1cm4gb3B0cyA9PSBudWxsIHx8ICgwLCBfc2hhbGxvd0VxdWFsLmRlZmF1bHQpKG5vZGUsIG9wdHMpO1xufVxuZnVuY3Rpb24gaXNKU1hTcHJlYWRDaGlsZChub2RlLCBvcHRzKSB7XG4gIGlmICghbm9kZSkgcmV0dXJuIGZhbHNlO1xuICBpZiAobm9kZS50eXBlICE9PSBcIkpTWFNwcmVhZENoaWxkXCIpIHJldHVybiBmYWxzZTtcbiAgcmV0dXJuIG9wdHMgPT0gbnVsbCB8fCAoMCwgX3NoYWxsb3dFcXVhbC5kZWZhdWx0KShub2RlLCBvcHRzKTtcbn1cbmZ1bmN0aW9uIGlzSlNYSWRlbnRpZmllcihub2RlLCBvcHRzKSB7XG4gIGlmICghbm9kZSkgcmV0dXJuIGZhbHNlO1xuICBpZiAobm9kZS50eXBlICE9PSBcIkpTWElkZW50aWZpZXJcIikgcmV0dXJuIGZhbHNlO1xuICByZXR1cm4gb3B0cyA9PSBudWxsIHx8ICgwLCBfc2hhbGxvd0VxdWFsLmRlZmF1bHQpKG5vZGUsIG9wdHMpO1xufVxuZnVuY3Rpb24gaXNKU1hNZW1iZXJFeHByZXNzaW9uKG5vZGUsIG9wdHMpIHtcbiAgaWYgKCFub2RlKSByZXR1cm4gZmFsc2U7XG4gIGlmIChub2RlLnR5cGUgIT09IFwiSlNYTWVtYmVyRXhwcmVzc2lvblwiKSByZXR1cm4gZmFsc2U7XG4gIHJldHVybiBvcHRzID09IG51bGwgfHwgKDAsIF9zaGFsbG93RXF1YWwuZGVmYXVsdCkobm9kZSwgb3B0cyk7XG59XG5mdW5jdGlvbiBpc0pTWE5hbWVzcGFjZWROYW1lKG5vZGUsIG9wdHMpIHtcbiAgaWYgKCFub2RlKSByZXR1cm4gZmFsc2U7XG4gIGlmIChub2RlLnR5cGUgIT09IFwiSlNYTmFtZXNwYWNlZE5hbWVcIikgcmV0dXJuIGZhbHNlO1xuICByZXR1cm4gb3B0cyA9PSBudWxsIHx8ICgwLCBfc2hhbGxvd0VxdWFsLmRlZmF1bHQpKG5vZGUsIG9wdHMpO1xufVxuZnVuY3Rpb24gaXNKU1hPcGVuaW5nRWxlbWVudChub2RlLCBvcHRzKSB7XG4gIGlmICghbm9kZSkgcmV0dXJuIGZhbHNlO1xuICBpZiAobm9kZS50eXBlICE9PSBcIkpTWE9wZW5pbmdFbGVtZW50XCIpIHJldHVybiBmYWxzZTtcbiAgcmV0dXJuIG9wdHMgPT0gbnVsbCB8fCAoMCwgX3NoYWxsb3dFcXVhbC5kZWZhdWx0KShub2RlLCBvcHRzKTtcbn1cbmZ1bmN0aW9uIGlzSlNYU3ByZWFkQXR0cmlidXRlKG5vZGUsIG9wdHMpIHtcbiAgaWYgKCFub2RlKSByZXR1cm4gZmFsc2U7XG4gIGlmIChub2RlLnR5cGUgIT09IFwiSlNYU3ByZWFkQXR0cmlidXRlXCIpIHJldHVybiBmYWxzZTtcbiAgcmV0dXJuIG9wdHMgPT0gbnVsbCB8fCAoMCwgX3NoYWxsb3dFcXVhbC5kZWZhdWx0KShub2RlLCBvcHRzKTtcbn1cbmZ1bmN0aW9uIGlzSlNYVGV4dChub2RlLCBvcHRzKSB7XG4gIGlmICghbm9kZSkgcmV0dXJuIGZhbHNlO1xuICBpZiAobm9kZS50eXBlICE9PSBcIkpTWFRleHRcIikgcmV0dXJuIGZhbHNlO1xuICByZXR1cm4gb3B0cyA9PSBudWxsIHx8ICgwLCBfc2hhbGxvd0VxdWFsLmRlZmF1bHQpKG5vZGUsIG9wdHMpO1xufVxuZnVuY3Rpb24gaXNKU1hGcmFnbWVudChub2RlLCBvcHRzKSB7XG4gIGlmICghbm9kZSkgcmV0dXJuIGZhbHNlO1xuICBpZiAobm9kZS50eXBlICE9PSBcIkpTWEZyYWdtZW50XCIpIHJldHVybiBmYWxzZTtcbiAgcmV0dXJuIG9wdHMgPT0gbnVsbCB8fCAoMCwgX3NoYWxsb3dFcXVhbC5kZWZhdWx0KShub2RlLCBvcHRzKTtcbn1cbmZ1bmN0aW9uIGlzSlNYT3BlbmluZ0ZyYWdtZW50KG5vZGUsIG9wdHMpIHtcbiAgaWYgKCFub2RlKSByZXR1cm4gZmFsc2U7XG4gIGlmIChub2RlLnR5cGUgIT09IFwiSlNYT3BlbmluZ0ZyYWdtZW50XCIpIHJldHVybiBmYWxzZTtcbiAgcmV0dXJuIG9wdHMgPT0gbnVsbCB8fCAoMCwgX3NoYWxsb3dFcXVhbC5kZWZhdWx0KShub2RlLCBvcHRzKTtcbn1cbmZ1bmN0aW9uIGlzSlNYQ2xvc2luZ0ZyYWdtZW50KG5vZGUsIG9wdHMpIHtcbiAgaWYgKCFub2RlKSByZXR1cm4gZmFsc2U7XG4gIGlmIChub2RlLnR5cGUgIT09IFwiSlNYQ2xvc2luZ0ZyYWdtZW50XCIpIHJldHVybiBmYWxzZTtcbiAgcmV0dXJuIG9wdHMgPT0gbnVsbCB8fCAoMCwgX3NoYWxsb3dFcXVhbC5kZWZhdWx0KShub2RlLCBvcHRzKTtcbn1cbmZ1bmN0aW9uIGlzTm9vcChub2RlLCBvcHRzKSB7XG4gIGlmICghbm9kZSkgcmV0dXJuIGZhbHNlO1xuICBpZiAobm9kZS50eXBlICE9PSBcIk5vb3BcIikgcmV0dXJuIGZhbHNlO1xuICByZXR1cm4gb3B0cyA9PSBudWxsIHx8ICgwLCBfc2hhbGxvd0VxdWFsLmRlZmF1bHQpKG5vZGUsIG9wdHMpO1xufVxuZnVuY3Rpb24gaXNQbGFjZWhvbGRlcihub2RlLCBvcHRzKSB7XG4gIGlmICghbm9kZSkgcmV0dXJuIGZhbHNlO1xuICBpZiAobm9kZS50eXBlICE9PSBcIlBsYWNlaG9sZGVyXCIpIHJldHVybiBmYWxzZTtcbiAgcmV0dXJuIG9wdHMgPT0gbnVsbCB8fCAoMCwgX3NoYWxsb3dFcXVhbC5kZWZhdWx0KShub2RlLCBvcHRzKTtcbn1cbmZ1bmN0aW9uIGlzVjhJbnRyaW5zaWNJZGVudGlmaWVyKG5vZGUsIG9wdHMpIHtcbiAgaWYgKCFub2RlKSByZXR1cm4gZmFsc2U7XG4gIGlmIChub2RlLnR5cGUgIT09IFwiVjhJbnRyaW5zaWNJZGVudGlmaWVyXCIpIHJldHVybiBmYWxzZTtcbiAgcmV0dXJuIG9wdHMgPT0gbnVsbCB8fCAoMCwgX3NoYWxsb3dFcXVhbC5kZWZhdWx0KShub2RlLCBvcHRzKTtcbn1cbmZ1bmN0aW9uIGlzQXJndW1lbnRQbGFjZWhvbGRlcihub2RlLCBvcHRzKSB7XG4gIGlmICghbm9kZSkgcmV0dXJuIGZhbHNlO1xuICBpZiAobm9kZS50eXBlICE9PSBcIkFyZ3VtZW50UGxhY2Vob2xkZXJcIikgcmV0dXJuIGZhbHNlO1xuICByZXR1cm4gb3B0cyA9PSBudWxsIHx8ICgwLCBfc2hhbGxvd0VxdWFsLmRlZmF1bHQpKG5vZGUsIG9wdHMpO1xufVxuZnVuY3Rpb24gaXNCaW5kRXhwcmVzc2lvbihub2RlLCBvcHRzKSB7XG4gIGlmICghbm9kZSkgcmV0dXJuIGZhbHNlO1xuICBpZiAobm9kZS50eXBlICE9PSBcIkJpbmRFeHByZXNzaW9uXCIpIHJldHVybiBmYWxzZTtcbiAgcmV0dXJuIG9wdHMgPT0gbnVsbCB8fCAoMCwgX3NoYWxsb3dFcXVhbC5kZWZhdWx0KShub2RlLCBvcHRzKTtcbn1cbmZ1bmN0aW9uIGlzRGVjb3JhdG9yKG5vZGUsIG9wdHMpIHtcbiAgaWYgKCFub2RlKSByZXR1cm4gZmFsc2U7XG4gIGlmIChub2RlLnR5cGUgIT09IFwiRGVjb3JhdG9yXCIpIHJldHVybiBmYWxzZTtcbiAgcmV0dXJuIG9wdHMgPT0gbnVsbCB8fCAoMCwgX3NoYWxsb3dFcXVhbC5kZWZhdWx0KShub2RlLCBvcHRzKTtcbn1cbmZ1bmN0aW9uIGlzRG9FeHByZXNzaW9uKG5vZGUsIG9wdHMpIHtcbiAgaWYgKCFub2RlKSByZXR1cm4gZmFsc2U7XG4gIGlmIChub2RlLnR5cGUgIT09IFwiRG9FeHByZXNzaW9uXCIpIHJldHVybiBmYWxzZTtcbiAgcmV0dXJuIG9wdHMgPT0gbnVsbCB8fCAoMCwgX3NoYWxsb3dFcXVhbC5kZWZhdWx0KShub2RlLCBvcHRzKTtcbn1cbmZ1bmN0aW9uIGlzRXhwb3J0RGVmYXVsdFNwZWNpZmllcihub2RlLCBvcHRzKSB7XG4gIGlmICghbm9kZSkgcmV0dXJuIGZhbHNlO1xuICBpZiAobm9kZS50eXBlICE9PSBcIkV4cG9ydERlZmF1bHRTcGVjaWZpZXJcIikgcmV0dXJuIGZhbHNlO1xuICByZXR1cm4gb3B0cyA9PSBudWxsIHx8ICgwLCBfc2hhbGxvd0VxdWFsLmRlZmF1bHQpKG5vZGUsIG9wdHMpO1xufVxuZnVuY3Rpb24gaXNSZWNvcmRFeHByZXNzaW9uKG5vZGUsIG9wdHMpIHtcbiAgaWYgKCFub2RlKSByZXR1cm4gZmFsc2U7XG4gIGlmIChub2RlLnR5cGUgIT09IFwiUmVjb3JkRXhwcmVzc2lvblwiKSByZXR1cm4gZmFsc2U7XG4gIHJldHVybiBvcHRzID09IG51bGwgfHwgKDAsIF9zaGFsbG93RXF1YWwuZGVmYXVsdCkobm9kZSwgb3B0cyk7XG59XG5mdW5jdGlvbiBpc1R1cGxlRXhwcmVzc2lvbihub2RlLCBvcHRzKSB7XG4gIGlmICghbm9kZSkgcmV0dXJuIGZhbHNlO1xuICBpZiAobm9kZS50eXBlICE9PSBcIlR1cGxlRXhwcmVzc2lvblwiKSByZXR1cm4gZmFsc2U7XG4gIHJldHVybiBvcHRzID09IG51bGwgfHwgKDAsIF9zaGFsbG93RXF1YWwuZGVmYXVsdCkobm9kZSwgb3B0cyk7XG59XG5mdW5jdGlvbiBpc0RlY2ltYWxMaXRlcmFsKG5vZGUsIG9wdHMpIHtcbiAgaWYgKCFub2RlKSByZXR1cm4gZmFsc2U7XG4gIGlmIChub2RlLnR5cGUgIT09IFwiRGVjaW1hbExpdGVyYWxcIikgcmV0dXJuIGZhbHNlO1xuICByZXR1cm4gb3B0cyA9PSBudWxsIHx8ICgwLCBfc2hhbGxvd0VxdWFsLmRlZmF1bHQpKG5vZGUsIG9wdHMpO1xufVxuZnVuY3Rpb24gaXNNb2R1bGVFeHByZXNzaW9uKG5vZGUsIG9wdHMpIHtcbiAgaWYgKCFub2RlKSByZXR1cm4gZmFsc2U7XG4gIGlmIChub2RlLnR5cGUgIT09IFwiTW9kdWxlRXhwcmVzc2lvblwiKSByZXR1cm4gZmFsc2U7XG4gIHJldHVybiBvcHRzID09IG51bGwgfHwgKDAsIF9zaGFsbG93RXF1YWwuZGVmYXVsdCkobm9kZSwgb3B0cyk7XG59XG5mdW5jdGlvbiBpc1RvcGljUmVmZXJlbmNlKG5vZGUsIG9wdHMpIHtcbiAgaWYgKCFub2RlKSByZXR1cm4gZmFsc2U7XG4gIGlmIChub2RlLnR5cGUgIT09IFwiVG9waWNSZWZlcmVuY2VcIikgcmV0dXJuIGZhbHNlO1xuICByZXR1cm4gb3B0cyA9PSBudWxsIHx8ICgwLCBfc2hhbGxvd0VxdWFsLmRlZmF1bHQpKG5vZGUsIG9wdHMpO1xufVxuZnVuY3Rpb24gaXNQaXBlbGluZVRvcGljRXhwcmVzc2lvbihub2RlLCBvcHRzKSB7XG4gIGlmICghbm9kZSkgcmV0dXJuIGZhbHNlO1xuICBpZiAobm9kZS50eXBlICE9PSBcIlBpcGVsaW5lVG9waWNFeHByZXNzaW9uXCIpIHJldHVybiBmYWxzZTtcbiAgcmV0dXJuIG9wdHMgPT0gbnVsbCB8fCAoMCwgX3NoYWxsb3dFcXVhbC5kZWZhdWx0KShub2RlLCBvcHRzKTtcbn1cbmZ1bmN0aW9uIGlzUGlwZWxpbmVCYXJlRnVuY3Rpb24obm9kZSwgb3B0cykge1xuICBpZiAoIW5vZGUpIHJldHVybiBmYWxzZTtcbiAgaWYgKG5vZGUudHlwZSAhPT0gXCJQaXBlbGluZUJhcmVGdW5jdGlvblwiKSByZXR1cm4gZmFsc2U7XG4gIHJldHVybiBvcHRzID09IG51bGwgfHwgKDAsIF9zaGFsbG93RXF1YWwuZGVmYXVsdCkobm9kZSwgb3B0cyk7XG59XG5mdW5jdGlvbiBpc1BpcGVsaW5lUHJpbWFyeVRvcGljUmVmZXJlbmNlKG5vZGUsIG9wdHMpIHtcbiAgaWYgKCFub2RlKSByZXR1cm4gZmFsc2U7XG4gIGlmIChub2RlLnR5cGUgIT09IFwiUGlwZWxpbmVQcmltYXJ5VG9waWNSZWZlcmVuY2VcIikgcmV0dXJuIGZhbHNlO1xuICByZXR1cm4gb3B0cyA9PSBudWxsIHx8ICgwLCBfc2hhbGxvd0VxdWFsLmRlZmF1bHQpKG5vZGUsIG9wdHMpO1xufVxuZnVuY3Rpb24gaXNWb2lkUGF0dGVybihub2RlLCBvcHRzKSB7XG4gIGlmICghbm9kZSkgcmV0dXJuIGZhbHNlO1xuICBpZiAobm9kZS50eXBlICE9PSBcIlZvaWRQYXR0ZXJuXCIpIHJldHVybiBmYWxzZTtcbiAgcmV0dXJuIG9wdHMgPT0gbnVsbCB8fCAoMCwgX3NoYWxsb3dFcXVhbC5kZWZhdWx0KShub2RlLCBvcHRzKTtcbn1cbmZ1bmN0aW9uIGlzVFNQYXJhbWV0ZXJQcm9wZXJ0eShub2RlLCBvcHRzKSB7XG4gIGlmICghbm9kZSkgcmV0dXJuIGZhbHNlO1xuICBpZiAobm9kZS50eXBlICE9PSBcIlRTUGFyYW1ldGVyUHJvcGVydHlcIikgcmV0dXJuIGZhbHNlO1xuICByZXR1cm4gb3B0cyA9PSBudWxsIHx8ICgwLCBfc2hhbGxvd0VxdWFsLmRlZmF1bHQpKG5vZGUsIG9wdHMpO1xufVxuZnVuY3Rpb24gaXNUU0RlY2xhcmVGdW5jdGlvbihub2RlLCBvcHRzKSB7XG4gIGlmICghbm9kZSkgcmV0dXJuIGZhbHNlO1xuICBpZiAobm9kZS50eXBlICE9PSBcIlRTRGVjbGFyZUZ1bmN0aW9uXCIpIHJldHVybiBmYWxzZTtcbiAgcmV0dXJuIG9wdHMgPT0gbnVsbCB8fCAoMCwgX3NoYWxsb3dFcXVhbC5kZWZhdWx0KShub2RlLCBvcHRzKTtcbn1cbmZ1bmN0aW9uIGlzVFNEZWNsYXJlTWV0aG9kKG5vZGUsIG9wdHMpIHtcbiAgaWYgKCFub2RlKSByZXR1cm4gZmFsc2U7XG4gIGlmIChub2RlLnR5cGUgIT09IFwiVFNEZWNsYXJlTWV0aG9kXCIpIHJldHVybiBmYWxzZTtcbiAgcmV0dXJuIG9wdHMgPT0gbnVsbCB8fCAoMCwgX3NoYWxsb3dFcXVhbC5kZWZhdWx0KShub2RlLCBvcHRzKTtcbn1cbmZ1bmN0aW9uIGlzVFNRdWFsaWZpZWROYW1lKG5vZGUsIG9wdHMpIHtcbiAgaWYgKCFub2RlKSByZXR1cm4gZmFsc2U7XG4gIGlmIChub2RlLnR5cGUgIT09IFwiVFNRdWFsaWZpZWROYW1lXCIpIHJldHVybiBmYWxzZTtcbiAgcmV0dXJuIG9wdHMgPT0gbnVsbCB8fCAoMCwgX3NoYWxsb3dFcXVhbC5kZWZhdWx0KShub2RlLCBvcHRzKTtcbn1cbmZ1bmN0aW9uIGlzVFNDYWxsU2lnbmF0dXJlRGVjbGFyYXRpb24obm9kZSwgb3B0cykge1xuICBpZiAoIW5vZGUpIHJldHVybiBmYWxzZTtcbiAgaWYgKG5vZGUudHlwZSAhPT0gXCJUU0NhbGxTaWduYXR1cmVEZWNsYXJhdGlvblwiKSByZXR1cm4gZmFsc2U7XG4gIHJldHVybiBvcHRzID09IG51bGwgfHwgKDAsIF9zaGFsbG93RXF1YWwuZGVmYXVsdCkobm9kZSwgb3B0cyk7XG59XG5mdW5jdGlvbiBpc1RTQ29uc3RydWN0U2lnbmF0dXJlRGVjbGFyYXRpb24obm9kZSwgb3B0cykge1xuICBpZiAoIW5vZGUpIHJldHVybiBmYWxzZTtcbiAgaWYgKG5vZGUudHlwZSAhPT0gXCJUU0NvbnN0cnVjdFNpZ25hdHVyZURlY2xhcmF0aW9uXCIpIHJldHVybiBmYWxzZTtcbiAgcmV0dXJuIG9wdHMgPT0gbnVsbCB8fCAoMCwgX3NoYWxsb3dFcXVhbC5kZWZhdWx0KShub2RlLCBvcHRzKTtcbn1cbmZ1bmN0aW9uIGlzVFNQcm9wZXJ0eVNpZ25hdHVyZShub2RlLCBvcHRzKSB7XG4gIGlmICghbm9kZSkgcmV0dXJuIGZhbHNlO1xuICBpZiAobm9kZS50eXBlICE9PSBcIlRTUHJvcGVydHlTaWduYXR1cmVcIikgcmV0dXJuIGZhbHNlO1xuICByZXR1cm4gb3B0cyA9PSBudWxsIHx8ICgwLCBfc2hhbGxvd0VxdWFsLmRlZmF1bHQpKG5vZGUsIG9wdHMpO1xufVxuZnVuY3Rpb24gaXNUU01ldGhvZFNpZ25hdHVyZShub2RlLCBvcHRzKSB7XG4gIGlmICghbm9kZSkgcmV0dXJuIGZhbHNlO1xuICBpZiAobm9kZS50eXBlICE9PSBcIlRTTWV0aG9kU2lnbmF0dXJlXCIpIHJldHVybiBmYWxzZTtcbiAgcmV0dXJuIG9wdHMgPT0gbnVsbCB8fCAoMCwgX3NoYWxsb3dFcXVhbC5kZWZhdWx0KShub2RlLCBvcHRzKTtcbn1cbmZ1bmN0aW9uIGlzVFNJbmRleFNpZ25hdHVyZShub2RlLCBvcHRzKSB7XG4gIGlmICghbm9kZSkgcmV0dXJuIGZhbHNlO1xuICBpZiAobm9kZS50eXBlICE9PSBcIlRTSW5kZXhTaWduYXR1cmVcIikgcmV0dXJuIGZhbHNlO1xuICByZXR1cm4gb3B0cyA9PSBudWxsIHx8ICgwLCBfc2hhbGxvd0VxdWFsLmRlZmF1bHQpKG5vZGUsIG9wdHMpO1xufVxuZnVuY3Rpb24gaXNUU0FueUtleXdvcmQobm9kZSwgb3B0cykge1xuICBpZiAoIW5vZGUpIHJldHVybiBmYWxzZTtcbiAgaWYgKG5vZGUudHlwZSAhPT0gXCJUU0FueUtleXdvcmRcIikgcmV0dXJuIGZhbHNlO1xuICByZXR1cm4gb3B0cyA9PSBudWxsIHx8ICgwLCBfc2hhbGxvd0VxdWFsLmRlZmF1bHQpKG5vZGUsIG9wdHMpO1xufVxuZnVuY3Rpb24gaXNUU0Jvb2xlYW5LZXl3b3JkKG5vZGUsIG9wdHMpIHtcbiAgaWYgKCFub2RlKSByZXR1cm4gZmFsc2U7XG4gIGlmIChub2RlLnR5cGUgIT09IFwiVFNCb29sZWFuS2V5d29yZFwiKSByZXR1cm4gZmFsc2U7XG4gIHJldHVybiBvcHRzID09IG51bGwgfHwgKDAsIF9zaGFsbG93RXF1YWwuZGVmYXVsdCkobm9kZSwgb3B0cyk7XG59XG5mdW5jdGlvbiBpc1RTQmlnSW50S2V5d29yZChub2RlLCBvcHRzKSB7XG4gIGlmICghbm9kZSkgcmV0dXJuIGZhbHNlO1xuICBpZiAobm9kZS50eXBlICE9PSBcIlRTQmlnSW50S2V5d29yZFwiKSByZXR1cm4gZmFsc2U7XG4gIHJldHVybiBvcHRzID09IG51bGwgfHwgKDAsIF9zaGFsbG93RXF1YWwuZGVmYXVsdCkobm9kZSwgb3B0cyk7XG59XG5mdW5jdGlvbiBpc1RTSW50cmluc2ljS2V5d29yZChub2RlLCBvcHRzKSB7XG4gIGlmICghbm9kZSkgcmV0dXJuIGZhbHNlO1xuICBpZiAobm9kZS50eXBlICE9PSBcIlRTSW50cmluc2ljS2V5d29yZFwiKSByZXR1cm4gZmFsc2U7XG4gIHJldHVybiBvcHRzID09IG51bGwgfHwgKDAsIF9zaGFsbG93RXF1YWwuZGVmYXVsdCkobm9kZSwgb3B0cyk7XG59XG5mdW5jdGlvbiBpc1RTTmV2ZXJLZXl3b3JkKG5vZGUsIG9wdHMpIHtcbiAgaWYgKCFub2RlKSByZXR1cm4gZmFsc2U7XG4gIGlmIChub2RlLnR5cGUgIT09IFwiVFNOZXZlcktleXdvcmRcIikgcmV0dXJuIGZhbHNlO1xuICByZXR1cm4gb3B0cyA9PSBudWxsIHx8ICgwLCBfc2hhbGxvd0VxdWFsLmRlZmF1bHQpKG5vZGUsIG9wdHMpO1xufVxuZnVuY3Rpb24gaXNUU051bGxLZXl3b3JkKG5vZGUsIG9wdHMpIHtcbiAgaWYgKCFub2RlKSByZXR1cm4gZmFsc2U7XG4gIGlmIChub2RlLnR5cGUgIT09IFwiVFNOdWxsS2V5d29yZFwiKSByZXR1cm4gZmFsc2U7XG4gIHJldHVybiBvcHRzID09IG51bGwgfHwgKDAsIF9zaGFsbG93RXF1YWwuZGVmYXVsdCkobm9kZSwgb3B0cyk7XG59XG5mdW5jdGlvbiBpc1RTTnVtYmVyS2V5d29yZChub2RlLCBvcHRzKSB7XG4gIGlmICghbm9kZSkgcmV0dXJuIGZhbHNlO1xuICBpZiAobm9kZS50eXBlICE9PSBcIlRTTnVtYmVyS2V5d29yZFwiKSByZXR1cm4gZmFsc2U7XG4gIHJldHVybiBvcHRzID09IG51bGwgfHwgKDAsIF9zaGFsbG93RXF1YWwuZGVmYXVsdCkobm9kZSwgb3B0cyk7XG59XG5mdW5jdGlvbiBpc1RTT2JqZWN0S2V5d29yZChub2RlLCBvcHRzKSB7XG4gIGlmICghbm9kZSkgcmV0dXJuIGZhbHNlO1xuICBpZiAobm9kZS50eXBlICE9PSBcIlRTT2JqZWN0S2V5d29yZFwiKSByZXR1cm4gZmFsc2U7XG4gIHJldHVybiBvcHRzID09IG51bGwgfHwgKDAsIF9zaGFsbG93RXF1YWwuZGVmYXVsdCkobm9kZSwgb3B0cyk7XG59XG5mdW5jdGlvbiBpc1RTU3RyaW5nS2V5d29yZChub2RlLCBvcHRzKSB7XG4gIGlmICghbm9kZSkgcmV0dXJuIGZhbHNlO1xuICBpZiAobm9kZS50eXBlICE9PSBcIlRTU3RyaW5nS2V5d29yZFwiKSByZXR1cm4gZmFsc2U7XG4gIHJldHVybiBvcHRzID09IG51bGwgfHwgKDAsIF9zaGFsbG93RXF1YWwuZGVmYXVsdCkobm9kZSwgb3B0cyk7XG59XG5mdW5jdGlvbiBpc1RTU3ltYm9sS2V5d29yZChub2RlLCBvcHRzKSB7XG4gIGlmICghbm9kZSkgcmV0dXJuIGZhbHNlO1xuICBpZiAobm9kZS50eXBlICE9PSBcIlRTU3ltYm9sS2V5d29yZFwiKSByZXR1cm4gZmFsc2U7XG4gIHJldHVybiBvcHRzID09IG51bGwgfHwgKDAsIF9zaGFsbG93RXF1YWwuZGVmYXVsdCkobm9kZSwgb3B0cyk7XG59XG5mdW5jdGlvbiBpc1RTVW5kZWZpbmVkS2V5d29yZChub2RlLCBvcHRzKSB7XG4gIGlmICghbm9kZSkgcmV0dXJuIGZhbHNlO1xuICBpZiAobm9kZS50eXBlICE9PSBcIlRTVW5kZWZpbmVkS2V5d29yZFwiKSByZXR1cm4gZmFsc2U7XG4gIHJldHVybiBvcHRzID09IG51bGwgfHwgKDAsIF9zaGFsbG93RXF1YWwuZGVmYXVsdCkobm9kZSwgb3B0cyk7XG59XG5mdW5jdGlvbiBpc1RTVW5rbm93bktleXdvcmQobm9kZSwgb3B0cykge1xuICBpZiAoIW5vZGUpIHJldHVybiBmYWxzZTtcbiAgaWYgKG5vZGUudHlwZSAhPT0gXCJUU1Vua25vd25LZXl3b3JkXCIpIHJldHVybiBmYWxzZTtcbiAgcmV0dXJuIG9wdHMgPT0gbnVsbCB8fCAoMCwgX3NoYWxsb3dFcXVhbC5kZWZhdWx0KShub2RlLCBvcHRzKTtcbn1cbmZ1bmN0aW9uIGlzVFNWb2lkS2V5d29yZChub2RlLCBvcHRzKSB7XG4gIGlmICghbm9kZSkgcmV0dXJuIGZhbHNlO1xuICBpZiAobm9kZS50eXBlICE9PSBcIlRTVm9pZEtleXdvcmRcIikgcmV0dXJuIGZhbHNlO1xuICByZXR1cm4gb3B0cyA9PSBudWxsIHx8ICgwLCBfc2hhbGxvd0VxdWFsLmRlZmF1bHQpKG5vZGUsIG9wdHMpO1xufVxuZnVuY3Rpb24gaXNUU1RoaXNUeXBlKG5vZGUsIG9wdHMpIHtcbiAgaWYgKCFub2RlKSByZXR1cm4gZmFsc2U7XG4gIGlmIChub2RlLnR5cGUgIT09IFwiVFNUaGlzVHlwZVwiKSByZXR1cm4gZmFsc2U7XG4gIHJldHVybiBvcHRzID09IG51bGwgfHwgKDAsIF9zaGFsbG93RXF1YWwuZGVmYXVsdCkobm9kZSwgb3B0cyk7XG59XG5mdW5jdGlvbiBpc1RTRnVuY3Rpb25UeXBlKG5vZGUsIG9wdHMpIHtcbiAgaWYgKCFub2RlKSByZXR1cm4gZmFsc2U7XG4gIGlmIChub2RlLnR5cGUgIT09IFwiVFNGdW5jdGlvblR5cGVcIikgcmV0dXJuIGZhbHNlO1xuICByZXR1cm4gb3B0cyA9PSBudWxsIHx8ICgwLCBfc2hhbGxvd0VxdWFsLmRlZmF1bHQpKG5vZGUsIG9wdHMpO1xufVxuZnVuY3Rpb24gaXNUU0NvbnN0cnVjdG9yVHlwZShub2RlLCBvcHRzKSB7XG4gIGlmICghbm9kZSkgcmV0dXJuIGZhbHNlO1xuICBpZiAobm9kZS50eXBlICE9PSBcIlRTQ29uc3RydWN0b3JUeXBlXCIpIHJldHVybiBmYWxzZTtcbiAgcmV0dXJuIG9wdHMgPT0gbnVsbCB8fCAoMCwgX3NoYWxsb3dFcXVhbC5kZWZhdWx0KShub2RlLCBvcHRzKTtcbn1cbmZ1bmN0aW9uIGlzVFNUeXBlUmVmZXJlbmNlKG5vZGUsIG9wdHMpIHtcbiAgaWYgKCFub2RlKSByZXR1cm4gZmFsc2U7XG4gIGlmIChub2RlLnR5cGUgIT09IFwiVFNUeXBlUmVmZXJlbmNlXCIpIHJldHVybiBmYWxzZTtcbiAgcmV0dXJuIG9wdHMgPT0gbnVsbCB8fCAoMCwgX3NoYWxsb3dFcXVhbC5kZWZhdWx0KShub2RlLCBvcHRzKTtcbn1cbmZ1bmN0aW9uIGlzVFNUeXBlUHJlZGljYXRlKG5vZGUsIG9wdHMpIHtcbiAgaWYgKCFub2RlKSByZXR1cm4gZmFsc2U7XG4gIGlmIChub2RlLnR5cGUgIT09IFwiVFNUeXBlUHJlZGljYXRlXCIpIHJldHVybiBmYWxzZTtcbiAgcmV0dXJuIG9wdHMgPT0gbnVsbCB8fCAoMCwgX3NoYWxsb3dFcXVhbC5kZWZhdWx0KShub2RlLCBvcHRzKTtcbn1cbmZ1bmN0aW9uIGlzVFNUeXBlUXVlcnkobm9kZSwgb3B0cykge1xuICBpZiAoIW5vZGUpIHJldHVybiBmYWxzZTtcbiAgaWYgKG5vZGUudHlwZSAhPT0gXCJUU1R5cGVRdWVyeVwiKSByZXR1cm4gZmFsc2U7XG4gIHJldHVybiBvcHRzID09IG51bGwgfHwgKDAsIF9zaGFsbG93RXF1YWwuZGVmYXVsdCkobm9kZSwgb3B0cyk7XG59XG5mdW5jdGlvbiBpc1RTVHlwZUxpdGVyYWwobm9kZSwgb3B0cykge1xuICBpZiAoIW5vZGUpIHJldHVybiBmYWxzZTtcbiAgaWYgKG5vZGUudHlwZSAhPT0gXCJUU1R5cGVMaXRlcmFsXCIpIHJldHVybiBmYWxzZTtcbiAgcmV0dXJuIG9wdHMgPT0gbnVsbCB8fCAoMCwgX3NoYWxsb3dFcXVhbC5kZWZhdWx0KShub2RlLCBvcHRzKTtcbn1cbmZ1bmN0aW9uIGlzVFNBcnJheVR5cGUobm9kZSwgb3B0cykge1xuICBpZiAoIW5vZGUpIHJldHVybiBmYWxzZTtcbiAgaWYgKG5vZGUudHlwZSAhPT0gXCJUU0FycmF5VHlwZVwiKSByZXR1cm4gZmFsc2U7XG4gIHJldHVybiBvcHRzID09IG51bGwgfHwgKDAsIF9zaGFsbG93RXF1YWwuZGVmYXVsdCkobm9kZSwgb3B0cyk7XG59XG5mdW5jdGlvbiBpc1RTVHVwbGVUeXBlKG5vZGUsIG9wdHMpIHtcbiAgaWYgKCFub2RlKSByZXR1cm4gZmFsc2U7XG4gIGlmIChub2RlLnR5cGUgIT09IFwiVFNUdXBsZVR5cGVcIikgcmV0dXJuIGZhbHNlO1xuICByZXR1cm4gb3B0cyA9PSBudWxsIHx8ICgwLCBfc2hhbGxvd0VxdWFsLmRlZmF1bHQpKG5vZGUsIG9wdHMpO1xufVxuZnVuY3Rpb24gaXNUU09wdGlvbmFsVHlwZShub2RlLCBvcHRzKSB7XG4gIGlmICghbm9kZSkgcmV0dXJuIGZhbHNlO1xuICBpZiAobm9kZS50eXBlICE9PSBcIlRTT3B0aW9uYWxUeXBlXCIpIHJldHVybiBmYWxzZTtcbiAgcmV0dXJuIG9wdHMgPT0gbnVsbCB8fCAoMCwgX3NoYWxsb3dFcXVhbC5kZWZhdWx0KShub2RlLCBvcHRzKTtcbn1cbmZ1bmN0aW9uIGlzVFNSZXN0VHlwZShub2RlLCBvcHRzKSB7XG4gIGlmICghbm9kZSkgcmV0dXJuIGZhbHNlO1xuICBpZiAobm9kZS50eXBlICE9PSBcIlRTUmVzdFR5cGVcIikgcmV0dXJuIGZhbHNlO1xuICByZXR1cm4gb3B0cyA9PSBudWxsIHx8ICgwLCBfc2hhbGxvd0VxdWFsLmRlZmF1bHQpKG5vZGUsIG9wdHMpO1xufVxuZnVuY3Rpb24gaXNUU05hbWVkVHVwbGVNZW1iZXIobm9kZSwgb3B0cykge1xuICBpZiAoIW5vZGUpIHJldHVybiBmYWxzZTtcbiAgaWYgKG5vZGUudHlwZSAhPT0gXCJUU05hbWVkVHVwbGVNZW1iZXJcIikgcmV0dXJuIGZhbHNlO1xuICByZXR1cm4gb3B0cyA9PSBudWxsIHx8ICgwLCBfc2hhbGxvd0VxdWFsLmRlZmF1bHQpKG5vZGUsIG9wdHMpO1xufVxuZnVuY3Rpb24gaXNUU1VuaW9uVHlwZShub2RlLCBvcHRzKSB7XG4gIGlmICghbm9kZSkgcmV0dXJuIGZhbHNlO1xuICBpZiAobm9kZS50eXBlICE9PSBcIlRTVW5pb25UeXBlXCIpIHJldHVybiBmYWxzZTtcbiAgcmV0dXJuIG9wdHMgPT0gbnVsbCB8fCAoMCwgX3NoYWxsb3dFcXVhbC5kZWZhdWx0KShub2RlLCBvcHRzKTtcbn1cbmZ1bmN0aW9uIGlzVFNJbnRlcnNlY3Rpb25UeXBlKG5vZGUsIG9wdHMpIHtcbiAgaWYgKCFub2RlKSByZXR1cm4gZmFsc2U7XG4gIGlmIChub2RlLnR5cGUgIT09IFwiVFNJbnRlcnNlY3Rpb25UeXBlXCIpIHJldHVybiBmYWxzZTtcbiAgcmV0dXJuIG9wdHMgPT0gbnVsbCB8fCAoMCwgX3NoYWxsb3dFcXVhbC5kZWZhdWx0KShub2RlLCBvcHRzKTtcbn1cbmZ1bmN0aW9uIGlzVFNDb25kaXRpb25hbFR5cGUobm9kZSwgb3B0cykge1xuICBpZiAoIW5vZGUpIHJldHVybiBmYWxzZTtcbiAgaWYgKG5vZGUudHlwZSAhPT0gXCJUU0NvbmRpdGlvbmFsVHlwZVwiKSByZXR1cm4gZmFsc2U7XG4gIHJldHVybiBvcHRzID09IG51bGwgfHwgKDAsIF9zaGFsbG93RXF1YWwuZGVmYXVsdCkobm9kZSwgb3B0cyk7XG59XG5mdW5jdGlvbiBpc1RTSW5mZXJUeXBlKG5vZGUsIG9wdHMpIHtcbiAgaWYgKCFub2RlKSByZXR1cm4gZmFsc2U7XG4gIGlmIChub2RlLnR5cGUgIT09IFwiVFNJbmZlclR5cGVcIikgcmV0dXJuIGZhbHNlO1xuICByZXR1cm4gb3B0cyA9PSBudWxsIHx8ICgwLCBfc2hhbGxvd0VxdWFsLmRlZmF1bHQpKG5vZGUsIG9wdHMpO1xufVxuZnVuY3Rpb24gaXNUU1BhcmVudGhlc2l6ZWRUeXBlKG5vZGUsIG9wdHMpIHtcbiAgaWYgKCFub2RlKSByZXR1cm4gZmFsc2U7XG4gIGlmIChub2RlLnR5cGUgIT09IFwiVFNQYXJlbnRoZXNpemVkVHlwZVwiKSByZXR1cm4gZmFsc2U7XG4gIHJldHVybiBvcHRzID09IG51bGwgfHwgKDAsIF9zaGFsbG93RXF1YWwuZGVmYXVsdCkobm9kZSwgb3B0cyk7XG59XG5mdW5jdGlvbiBpc1RTVHlwZU9wZXJhdG9yKG5vZGUsIG9wdHMpIHtcbiAgaWYgKCFub2RlKSByZXR1cm4gZmFsc2U7XG4gIGlmIChub2RlLnR5cGUgIT09IFwiVFNUeXBlT3BlcmF0b3JcIikgcmV0dXJuIGZhbHNlO1xuICByZXR1cm4gb3B0cyA9PSBudWxsIHx8ICgwLCBfc2hhbGxvd0VxdWFsLmRlZmF1bHQpKG5vZGUsIG9wdHMpO1xufVxuZnVuY3Rpb24gaXNUU0luZGV4ZWRBY2Nlc3NUeXBlKG5vZGUsIG9wdHMpIHtcbiAgaWYgKCFub2RlKSByZXR1cm4gZmFsc2U7XG4gIGlmIChub2RlLnR5cGUgIT09IFwiVFNJbmRleGVkQWNjZXNzVHlwZVwiKSByZXR1cm4gZmFsc2U7XG4gIHJldHVybiBvcHRzID09IG51bGwgfHwgKDAsIF9zaGFsbG93RXF1YWwuZGVmYXVsdCkobm9kZSwgb3B0cyk7XG59XG5mdW5jdGlvbiBpc1RTTWFwcGVkVHlwZShub2RlLCBvcHRzKSB7XG4gIGlmICghbm9kZSkgcmV0dXJuIGZhbHNlO1xuICBpZiAobm9kZS50eXBlICE9PSBcIlRTTWFwcGVkVHlwZVwiKSByZXR1cm4gZmFsc2U7XG4gIHJldHVybiBvcHRzID09IG51bGwgfHwgKDAsIF9zaGFsbG93RXF1YWwuZGVmYXVsdCkobm9kZSwgb3B0cyk7XG59XG5mdW5jdGlvbiBpc1RTVGVtcGxhdGVMaXRlcmFsVHlwZShub2RlLCBvcHRzKSB7XG4gIGlmICghbm9kZSkgcmV0dXJuIGZhbHNlO1xuICBpZiAobm9kZS50eXBlICE9PSBcIlRTVGVtcGxhdGVMaXRlcmFsVHlwZVwiKSByZXR1cm4gZmFsc2U7XG4gIHJldHVybiBvcHRzID09IG51bGwgfHwgKDAsIF9zaGFsbG93RXF1YWwuZGVmYXVsdCkobm9kZSwgb3B0cyk7XG59XG5mdW5jdGlvbiBpc1RTTGl0ZXJhbFR5cGUobm9kZSwgb3B0cykge1xuICBpZiAoIW5vZGUpIHJldHVybiBmYWxzZTtcbiAgaWYgKG5vZGUudHlwZSAhPT0gXCJUU0xpdGVyYWxUeXBlXCIpIHJldHVybiBmYWxzZTtcbiAgcmV0dXJuIG9wdHMgPT0gbnVsbCB8fCAoMCwgX3NoYWxsb3dFcXVhbC5kZWZhdWx0KShub2RlLCBvcHRzKTtcbn1cbmZ1bmN0aW9uIGlzVFNFeHByZXNzaW9uV2l0aFR5cGVBcmd1bWVudHMobm9kZSwgb3B0cykge1xuICBpZiAoIW5vZGUpIHJldHVybiBmYWxzZTtcbiAgaWYgKG5vZGUudHlwZSAhPT0gXCJUU0V4cHJlc3Npb25XaXRoVHlwZUFyZ3VtZW50c1wiKSByZXR1cm4gZmFsc2U7XG4gIHJldHVybiBvcHRzID09IG51bGwgfHwgKDAsIF9zaGFsbG93RXF1YWwuZGVmYXVsdCkobm9kZSwgb3B0cyk7XG59XG5mdW5jdGlvbiBpc1RTSW50ZXJmYWNlRGVjbGFyYXRpb24obm9kZSwgb3B0cykge1xuICBpZiAoIW5vZGUpIHJldHVybiBmYWxzZTtcbiAgaWYgKG5vZGUudHlwZSAhPT0gXCJUU0ludGVyZmFjZURlY2xhcmF0aW9uXCIpIHJldHVybiBmYWxzZTtcbiAgcmV0dXJuIG9wdHMgPT0gbnVsbCB8fCAoMCwgX3NoYWxsb3dFcXVhbC5kZWZhdWx0KShub2RlLCBvcHRzKTtcbn1cbmZ1bmN0aW9uIGlzVFNJbnRlcmZhY2VCb2R5KG5vZGUsIG9wdHMpIHtcbiAgaWYgKCFub2RlKSByZXR1cm4gZmFsc2U7XG4gIGlmIChub2RlLnR5cGUgIT09IFwiVFNJbnRlcmZhY2VCb2R5XCIpIHJldHVybiBmYWxzZTtcbiAgcmV0dXJuIG9wdHMgPT0gbnVsbCB8fCAoMCwgX3NoYWxsb3dFcXVhbC5kZWZhdWx0KShub2RlLCBvcHRzKTtcbn1cbmZ1bmN0aW9uIGlzVFNUeXBlQWxpYXNEZWNsYXJhdGlvbihub2RlLCBvcHRzKSB7XG4gIGlmICghbm9kZSkgcmV0dXJuIGZhbHNlO1xuICBpZiAobm9kZS50eXBlICE9PSBcIlRTVHlwZUFsaWFzRGVjbGFyYXRpb25cIikgcmV0dXJuIGZhbHNlO1xuICByZXR1cm4gb3B0cyA9PSBudWxsIHx8ICgwLCBfc2hhbGxvd0VxdWFsLmRlZmF1bHQpKG5vZGUsIG9wdHMpO1xufVxuZnVuY3Rpb24gaXNUU0luc3RhbnRpYXRpb25FeHByZXNzaW9uKG5vZGUsIG9wdHMpIHtcbiAgaWYgKCFub2RlKSByZXR1cm4gZmFsc2U7XG4gIGlmIChub2RlLnR5cGUgIT09IFwiVFNJbnN0YW50aWF0aW9uRXhwcmVzc2lvblwiKSByZXR1cm4gZmFsc2U7XG4gIHJldHVybiBvcHRzID09IG51bGwgfHwgKDAsIF9zaGFsbG93RXF1YWwuZGVmYXVsdCkobm9kZSwgb3B0cyk7XG59XG5mdW5jdGlvbiBpc1RTQXNFeHByZXNzaW9uKG5vZGUsIG9wdHMpIHtcbiAgaWYgKCFub2RlKSByZXR1cm4gZmFsc2U7XG4gIGlmIChub2RlLnR5cGUgIT09IFwiVFNBc0V4cHJlc3Npb25cIikgcmV0dXJuIGZhbHNlO1xuICByZXR1cm4gb3B0cyA9PSBudWxsIHx8ICgwLCBfc2hhbGxvd0VxdWFsLmRlZmF1bHQpKG5vZGUsIG9wdHMpO1xufVxuZnVuY3Rpb24gaXNUU1NhdGlzZmllc0V4cHJlc3Npb24obm9kZSwgb3B0cykge1xuICBpZiAoIW5vZGUpIHJldHVybiBmYWxzZTtcbiAgaWYgKG5vZGUudHlwZSAhPT0gXCJUU1NhdGlzZmllc0V4cHJlc3Npb25cIikgcmV0dXJuIGZhbHNlO1xuICByZXR1cm4gb3B0cyA9PSBudWxsIHx8ICgwLCBfc2hhbGxvd0VxdWFsLmRlZmF1bHQpKG5vZGUsIG9wdHMpO1xufVxuZnVuY3Rpb24gaXNUU1R5cGVBc3NlcnRpb24obm9kZSwgb3B0cykge1xuICBpZiAoIW5vZGUpIHJldHVybiBmYWxzZTtcbiAgaWYgKG5vZGUudHlwZSAhPT0gXCJUU1R5cGVBc3NlcnRpb25cIikgcmV0dXJuIGZhbHNlO1xuICByZXR1cm4gb3B0cyA9PSBudWxsIHx8ICgwLCBfc2hhbGxvd0VxdWFsLmRlZmF1bHQpKG5vZGUsIG9wdHMpO1xufVxuZnVuY3Rpb24gaXNUU0VudW1Cb2R5KG5vZGUsIG9wdHMpIHtcbiAgaWYgKCFub2RlKSByZXR1cm4gZmFsc2U7XG4gIGlmIChub2RlLnR5cGUgIT09IFwiVFNFbnVtQm9keVwiKSByZXR1cm4gZmFsc2U7XG4gIHJldHVybiBvcHRzID09IG51bGwgfHwgKDAsIF9zaGFsbG93RXF1YWwuZGVmYXVsdCkobm9kZSwgb3B0cyk7XG59XG5mdW5jdGlvbiBpc1RTRW51bURlY2xhcmF0aW9uKG5vZGUsIG9wdHMpIHtcbiAgaWYgKCFub2RlKSByZXR1cm4gZmFsc2U7XG4gIGlmIChub2RlLnR5cGUgIT09IFwiVFNFbnVtRGVjbGFyYXRpb25cIikgcmV0dXJuIGZhbHNlO1xuICByZXR1cm4gb3B0cyA9PSBudWxsIHx8ICgwLCBfc2hhbGxvd0VxdWFsLmRlZmF1bHQpKG5vZGUsIG9wdHMpO1xufVxuZnVuY3Rpb24gaXNUU0VudW1NZW1iZXIobm9kZSwgb3B0cykge1xuICBpZiAoIW5vZGUpIHJldHVybiBmYWxzZTtcbiAgaWYgKG5vZGUudHlwZSAhPT0gXCJUU0VudW1NZW1iZXJcIikgcmV0dXJuIGZhbHNlO1xuICByZXR1cm4gb3B0cyA9PSBudWxsIHx8ICgwLCBfc2hhbGxvd0VxdWFsLmRlZmF1bHQpKG5vZGUsIG9wdHMpO1xufVxuZnVuY3Rpb24gaXNUU01vZHVsZURlY2xhcmF0aW9uKG5vZGUsIG9wdHMpIHtcbiAgaWYgKCFub2RlKSByZXR1cm4gZmFsc2U7XG4gIGlmIChub2RlLnR5cGUgIT09IFwiVFNNb2R1bGVEZWNsYXJhdGlvblwiKSByZXR1cm4gZmFsc2U7XG4gIHJldHVybiBvcHRzID09IG51bGwgfHwgKDAsIF9zaGFsbG93RXF1YWwuZGVmYXVsdCkobm9kZSwgb3B0cyk7XG59XG5mdW5jdGlvbiBpc1RTTW9kdWxlQmxvY2sobm9kZSwgb3B0cykge1xuICBpZiAoIW5vZGUpIHJldHVybiBmYWxzZTtcbiAgaWYgKG5vZGUudHlwZSAhPT0gXCJUU01vZHVsZUJsb2NrXCIpIHJldHVybiBmYWxzZTtcbiAgcmV0dXJuIG9wdHMgPT0gbnVsbCB8fCAoMCwgX3NoYWxsb3dFcXVhbC5kZWZhdWx0KShub2RlLCBvcHRzKTtcbn1cbmZ1bmN0aW9uIGlzVFNJbXBvcnRUeXBlKG5vZGUsIG9wdHMpIHtcbiAgaWYgKCFub2RlKSByZXR1cm4gZmFsc2U7XG4gIGlmIChub2RlLnR5cGUgIT09IFwiVFNJbXBvcnRUeXBlXCIpIHJldHVybiBmYWxzZTtcbiAgcmV0dXJuIG9wdHMgPT0gbnVsbCB8fCAoMCwgX3NoYWxsb3dFcXVhbC5kZWZhdWx0KShub2RlLCBvcHRzKTtcbn1cbmZ1bmN0aW9uIGlzVFNJbXBvcnRFcXVhbHNEZWNsYXJhdGlvbihub2RlLCBvcHRzKSB7XG4gIGlmICghbm9kZSkgcmV0dXJuIGZhbHNlO1xuICBpZiAobm9kZS50eXBlICE9PSBcIlRTSW1wb3J0RXF1YWxzRGVjbGFyYXRpb25cIikgcmV0dXJuIGZhbHNlO1xuICByZXR1cm4gb3B0cyA9PSBudWxsIHx8ICgwLCBfc2hhbGxvd0VxdWFsLmRlZmF1bHQpKG5vZGUsIG9wdHMpO1xufVxuZnVuY3Rpb24gaXNUU0V4dGVybmFsTW9kdWxlUmVmZXJlbmNlKG5vZGUsIG9wdHMpIHtcbiAgaWYgKCFub2RlKSByZXR1cm4gZmFsc2U7XG4gIGlmIChub2RlLnR5cGUgIT09IFwiVFNFeHRlcm5hbE1vZHVsZVJlZmVyZW5jZVwiKSByZXR1cm4gZmFsc2U7XG4gIHJldHVybiBvcHRzID09IG51bGwgfHwgKDAsIF9zaGFsbG93RXF1YWwuZGVmYXVsdCkobm9kZSwgb3B0cyk7XG59XG5mdW5jdGlvbiBpc1RTTm9uTnVsbEV4cHJlc3Npb24obm9kZSwgb3B0cykge1xuICBpZiAoIW5vZGUpIHJldHVybiBmYWxzZTtcbiAgaWYgKG5vZGUudHlwZSAhPT0gXCJUU05vbk51bGxFeHByZXNzaW9uXCIpIHJldHVybiBmYWxzZTtcbiAgcmV0dXJuIG9wdHMgPT0gbnVsbCB8fCAoMCwgX3NoYWxsb3dFcXVhbC5kZWZhdWx0KShub2RlLCBvcHRzKTtcbn1cbmZ1bmN0aW9uIGlzVFNFeHBvcnRBc3NpZ25tZW50KG5vZGUsIG9wdHMpIHtcbiAgaWYgKCFub2RlKSByZXR1cm4gZmFsc2U7XG4gIGlmIChub2RlLnR5cGUgIT09IFwiVFNFeHBvcnRBc3NpZ25tZW50XCIpIHJldHVybiBmYWxzZTtcbiAgcmV0dXJuIG9wdHMgPT0gbnVsbCB8fCAoMCwgX3NoYWxsb3dFcXVhbC5kZWZhdWx0KShub2RlLCBvcHRzKTtcbn1cbmZ1bmN0aW9uIGlzVFNOYW1lc3BhY2VFeHBvcnREZWNsYXJhdGlvbihub2RlLCBvcHRzKSB7XG4gIGlmICghbm9kZSkgcmV0dXJuIGZhbHNlO1xuICBpZiAobm9kZS50eXBlICE9PSBcIlRTTmFtZXNwYWNlRXhwb3J0RGVjbGFyYXRpb25cIikgcmV0dXJuIGZhbHNlO1xuICByZXR1cm4gb3B0cyA9PSBudWxsIHx8ICgwLCBfc2hhbGxvd0VxdWFsLmRlZmF1bHQpKG5vZGUsIG9wdHMpO1xufVxuZnVuY3Rpb24gaXNUU1R5cGVBbm5vdGF0aW9uKG5vZGUsIG9wdHMpIHtcbiAgaWYgKCFub2RlKSByZXR1cm4gZmFsc2U7XG4gIGlmIChub2RlLnR5cGUgIT09IFwiVFNUeXBlQW5ub3RhdGlvblwiKSByZXR1cm4gZmFsc2U7XG4gIHJldHVybiBvcHRzID09IG51bGwgfHwgKDAsIF9zaGFsbG93RXF1YWwuZGVmYXVsdCkobm9kZSwgb3B0cyk7XG59XG5mdW5jdGlvbiBpc1RTVHlwZVBhcmFtZXRlckluc3RhbnRpYXRpb24obm9kZSwgb3B0cykge1xuICBpZiAoIW5vZGUpIHJldHVybiBmYWxzZTtcbiAgaWYgKG5vZGUudHlwZSAhPT0gXCJUU1R5cGVQYXJhbWV0ZXJJbnN0YW50aWF0aW9uXCIpIHJldHVybiBmYWxzZTtcbiAgcmV0dXJuIG9wdHMgPT0gbnVsbCB8fCAoMCwgX3NoYWxsb3dFcXVhbC5kZWZhdWx0KShub2RlLCBvcHRzKTtcbn1cbmZ1bmN0aW9uIGlzVFNUeXBlUGFyYW1ldGVyRGVjbGFyYXRpb24obm9kZSwgb3B0cykge1xuICBpZiAoIW5vZGUpIHJldHVybiBmYWxzZTtcbiAgaWYgKG5vZGUudHlwZSAhPT0gXCJUU1R5cGVQYXJhbWV0ZXJEZWNsYXJhdGlvblwiKSByZXR1cm4gZmFsc2U7XG4gIHJldHVybiBvcHRzID09IG51bGwgfHwgKDAsIF9zaGFsbG93RXF1YWwuZGVmYXVsdCkobm9kZSwgb3B0cyk7XG59XG5mdW5jdGlvbiBpc1RTVHlwZVBhcmFtZXRlcihub2RlLCBvcHRzKSB7XG4gIGlmICghbm9kZSkgcmV0dXJuIGZhbHNlO1xuICBpZiAobm9kZS50eXBlICE9PSBcIlRTVHlwZVBhcmFtZXRlclwiKSByZXR1cm4gZmFsc2U7XG4gIHJldHVybiBvcHRzID09IG51bGwgfHwgKDAsIF9zaGFsbG93RXF1YWwuZGVmYXVsdCkobm9kZSwgb3B0cyk7XG59XG5mdW5jdGlvbiBpc1N0YW5kYXJkaXplZChub2RlLCBvcHRzKSB7XG4gIGlmICghbm9kZSkgcmV0dXJuIGZhbHNlO1xuICBzd2l0Y2ggKG5vZGUudHlwZSkge1xuICAgIGNhc2UgXCJBcnJheUV4cHJlc3Npb25cIjpcbiAgICBjYXNlIFwiQXNzaWdubWVudEV4cHJlc3Npb25cIjpcbiAgICBjYXNlIFwiQmluYXJ5RXhwcmVzc2lvblwiOlxuICAgIGNhc2UgXCJJbnRlcnByZXRlckRpcmVjdGl2ZVwiOlxuICAgIGNhc2UgXCJEaXJlY3RpdmVcIjpcbiAgICBjYXNlIFwiRGlyZWN0aXZlTGl0ZXJhbFwiOlxuICAgIGNhc2UgXCJCbG9ja1N0YXRlbWVudFwiOlxuICAgIGNhc2UgXCJCcmVha1N0YXRlbWVudFwiOlxuICAgIGNhc2UgXCJDYWxsRXhwcmVzc2lvblwiOlxuICAgIGNhc2UgXCJDYXRjaENsYXVzZVwiOlxuICAgIGNhc2UgXCJDb25kaXRpb25hbEV4cHJlc3Npb25cIjpcbiAgICBjYXNlIFwiQ29udGludWVTdGF0ZW1lbnRcIjpcbiAgICBjYXNlIFwiRGVidWdnZXJTdGF0ZW1lbnRcIjpcbiAgICBjYXNlIFwiRG9XaGlsZVN0YXRlbWVudFwiOlxuICAgIGNhc2UgXCJFbXB0eVN0YXRlbWVudFwiOlxuICAgIGNhc2UgXCJFeHByZXNzaW9uU3RhdGVtZW50XCI6XG4gICAgY2FzZSBcIkZpbGVcIjpcbiAgICBjYXNlIFwiRm9ySW5TdGF0ZW1lbnRcIjpcbiAgICBjYXNlIFwiRm9yU3RhdGVtZW50XCI6XG4gICAgY2FzZSBcIkZ1bmN0aW9uRGVjbGFyYXRpb25cIjpcbiAgICBjYXNlIFwiRnVuY3Rpb25FeHByZXNzaW9uXCI6XG4gICAgY2FzZSBcIklkZW50aWZpZXJcIjpcbiAgICBjYXNlIFwiSWZTdGF0ZW1lbnRcIjpcbiAgICBjYXNlIFwiTGFiZWxlZFN0YXRlbWVudFwiOlxuICAgIGNhc2UgXCJTdHJpbmdMaXRlcmFsXCI6XG4gICAgY2FzZSBcIk51bWVyaWNMaXRlcmFsXCI6XG4gICAgY2FzZSBcIk51bGxMaXRlcmFsXCI6XG4gICAgY2FzZSBcIkJvb2xlYW5MaXRlcmFsXCI6XG4gICAgY2FzZSBcIlJlZ0V4cExpdGVyYWxcIjpcbiAgICBjYXNlIFwiTG9naWNhbEV4cHJlc3Npb25cIjpcbiAgICBjYXNlIFwiTWVtYmVyRXhwcmVzc2lvblwiOlxuICAgIGNhc2UgXCJOZXdFeHByZXNzaW9uXCI6XG4gICAgY2FzZSBcIlByb2dyYW1cIjpcbiAgICBjYXNlIFwiT2JqZWN0RXhwcmVzc2lvblwiOlxuICAgIGNhc2UgXCJPYmplY3RNZXRob2RcIjpcbiAgICBjYXNlIFwiT2JqZWN0UHJvcGVydHlcIjpcbiAgICBjYXNlIFwiUmVzdEVsZW1lbnRcIjpcbiAgICBjYXNlIFwiUmV0dXJuU3RhdGVtZW50XCI6XG4gICAgY2FzZSBcIlNlcXVlbmNlRXhwcmVzc2lvblwiOlxuICAgIGNhc2UgXCJQYXJlbnRoZXNpemVkRXhwcmVzc2lvblwiOlxuICAgIGNhc2UgXCJTd2l0Y2hDYXNlXCI6XG4gICAgY2FzZSBcIlN3aXRjaFN0YXRlbWVudFwiOlxuICAgIGNhc2UgXCJUaGlzRXhwcmVzc2lvblwiOlxuICAgIGNhc2UgXCJUaHJvd1N0YXRlbWVudFwiOlxuICAgIGNhc2UgXCJUcnlTdGF0ZW1lbnRcIjpcbiAgICBjYXNlIFwiVW5hcnlFeHByZXNzaW9uXCI6XG4gICAgY2FzZSBcIlVwZGF0ZUV4cHJlc3Npb25cIjpcbiAgICBjYXNlIFwiVmFyaWFibGVEZWNsYXJhdGlvblwiOlxuICAgIGNhc2UgXCJWYXJpYWJsZURlY2xhcmF0b3JcIjpcbiAgICBjYXNlIFwiV2hpbGVTdGF0ZW1lbnRcIjpcbiAgICBjYXNlIFwiV2l0aFN0YXRlbWVudFwiOlxuICAgIGNhc2UgXCJBc3NpZ25tZW50UGF0dGVyblwiOlxuICAgIGNhc2UgXCJBcnJheVBhdHRlcm5cIjpcbiAgICBjYXNlIFwiQXJyb3dGdW5jdGlvbkV4cHJlc3Npb25cIjpcbiAgICBjYXNlIFwiQ2xhc3NCb2R5XCI6XG4gICAgY2FzZSBcIkNsYXNzRXhwcmVzc2lvblwiOlxuICAgIGNhc2UgXCJDbGFzc0RlY2xhcmF0aW9uXCI6XG4gICAgY2FzZSBcIkV4cG9ydEFsbERlY2xhcmF0aW9uXCI6XG4gICAgY2FzZSBcIkV4cG9ydERlZmF1bHREZWNsYXJhdGlvblwiOlxuICAgIGNhc2UgXCJFeHBvcnROYW1lZERlY2xhcmF0aW9uXCI6XG4gICAgY2FzZSBcIkV4cG9ydFNwZWNpZmllclwiOlxuICAgIGNhc2UgXCJGb3JPZlN0YXRlbWVudFwiOlxuICAgIGNhc2UgXCJJbXBvcnREZWNsYXJhdGlvblwiOlxuICAgIGNhc2UgXCJJbXBvcnREZWZhdWx0U3BlY2lmaWVyXCI6XG4gICAgY2FzZSBcIkltcG9ydE5hbWVzcGFjZVNwZWNpZmllclwiOlxuICAgIGNhc2UgXCJJbXBvcnRTcGVjaWZpZXJcIjpcbiAgICBjYXNlIFwiSW1wb3J0RXhwcmVzc2lvblwiOlxuICAgIGNhc2UgXCJNZXRhUHJvcGVydHlcIjpcbiAgICBjYXNlIFwiQ2xhc3NNZXRob2RcIjpcbiAgICBjYXNlIFwiT2JqZWN0UGF0dGVyblwiOlxuICAgIGNhc2UgXCJTcHJlYWRFbGVtZW50XCI6XG4gICAgY2FzZSBcIlN1cGVyXCI6XG4gICAgY2FzZSBcIlRhZ2dlZFRlbXBsYXRlRXhwcmVzc2lvblwiOlxuICAgIGNhc2UgXCJUZW1wbGF0ZUVsZW1lbnRcIjpcbiAgICBjYXNlIFwiVGVtcGxhdGVMaXRlcmFsXCI6XG4gICAgY2FzZSBcIllpZWxkRXhwcmVzc2lvblwiOlxuICAgIGNhc2UgXCJBd2FpdEV4cHJlc3Npb25cIjpcbiAgICBjYXNlIFwiSW1wb3J0XCI6XG4gICAgY2FzZSBcIkJpZ0ludExpdGVyYWxcIjpcbiAgICBjYXNlIFwiRXhwb3J0TmFtZXNwYWNlU3BlY2lmaWVyXCI6XG4gICAgY2FzZSBcIk9wdGlvbmFsTWVtYmVyRXhwcmVzc2lvblwiOlxuICAgIGNhc2UgXCJPcHRpb25hbENhbGxFeHByZXNzaW9uXCI6XG4gICAgY2FzZSBcIkNsYXNzUHJvcGVydHlcIjpcbiAgICBjYXNlIFwiQ2xhc3NBY2Nlc3NvclByb3BlcnR5XCI6XG4gICAgY2FzZSBcIkNsYXNzUHJpdmF0ZVByb3BlcnR5XCI6XG4gICAgY2FzZSBcIkNsYXNzUHJpdmF0ZU1ldGhvZFwiOlxuICAgIGNhc2UgXCJQcml2YXRlTmFtZVwiOlxuICAgIGNhc2UgXCJTdGF0aWNCbG9ja1wiOlxuICAgIGNhc2UgXCJJbXBvcnRBdHRyaWJ1dGVcIjpcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgXCJQbGFjZWhvbGRlclwiOlxuICAgICAgc3dpdGNoIChub2RlLmV4cGVjdGVkTm9kZSkge1xuICAgICAgICBjYXNlIFwiSWRlbnRpZmllclwiOlxuICAgICAgICBjYXNlIFwiU3RyaW5nTGl0ZXJhbFwiOlxuICAgICAgICBjYXNlIFwiQmxvY2tTdGF0ZW1lbnRcIjpcbiAgICAgICAgY2FzZSBcIkNsYXNzQm9keVwiOlxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIGJyZWFrO1xuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgcmV0dXJuIG9wdHMgPT0gbnVsbCB8fCAoMCwgX3NoYWxsb3dFcXVhbC5kZWZhdWx0KShub2RlLCBvcHRzKTtcbn1cbmZ1bmN0aW9uIGlzRXhwcmVzc2lvbihub2RlLCBvcHRzKSB7XG4gIGlmICghbm9kZSkgcmV0dXJuIGZhbHNlO1xuICBzd2l0Y2ggKG5vZGUudHlwZSkge1xuICAgIGNhc2UgXCJBcnJheUV4cHJlc3Npb25cIjpcbiAgICBjYXNlIFwiQXNzaWdubWVudEV4cHJlc3Npb25cIjpcbiAgICBjYXNlIFwiQmluYXJ5RXhwcmVzc2lvblwiOlxuICAgIGNhc2UgXCJDYWxsRXhwcmVzc2lvblwiOlxuICAgIGNhc2UgXCJDb25kaXRpb25hbEV4cHJlc3Npb25cIjpcbiAgICBjYXNlIFwiRnVuY3Rpb25FeHByZXNzaW9uXCI6XG4gICAgY2FzZSBcIklkZW50aWZpZXJcIjpcbiAgICBjYXNlIFwiU3RyaW5nTGl0ZXJhbFwiOlxuICAgIGNhc2UgXCJOdW1lcmljTGl0ZXJhbFwiOlxuICAgIGNhc2UgXCJOdWxsTGl0ZXJhbFwiOlxuICAgIGNhc2UgXCJCb29sZWFuTGl0ZXJhbFwiOlxuICAgIGNhc2UgXCJSZWdFeHBMaXRlcmFsXCI6XG4gICAgY2FzZSBcIkxvZ2ljYWxFeHByZXNzaW9uXCI6XG4gICAgY2FzZSBcIk1lbWJlckV4cHJlc3Npb25cIjpcbiAgICBjYXNlIFwiTmV3RXhwcmVzc2lvblwiOlxuICAgIGNhc2UgXCJPYmplY3RFeHByZXNzaW9uXCI6XG4gICAgY2FzZSBcIlNlcXVlbmNlRXhwcmVzc2lvblwiOlxuICAgIGNhc2UgXCJQYXJlbnRoZXNpemVkRXhwcmVzc2lvblwiOlxuICAgIGNhc2UgXCJUaGlzRXhwcmVzc2lvblwiOlxuICAgIGNhc2UgXCJVbmFyeUV4cHJlc3Npb25cIjpcbiAgICBjYXNlIFwiVXBkYXRlRXhwcmVzc2lvblwiOlxuICAgIGNhc2UgXCJBcnJvd0Z1bmN0aW9uRXhwcmVzc2lvblwiOlxuICAgIGNhc2UgXCJDbGFzc0V4cHJlc3Npb25cIjpcbiAgICBjYXNlIFwiSW1wb3J0RXhwcmVzc2lvblwiOlxuICAgIGNhc2UgXCJNZXRhUHJvcGVydHlcIjpcbiAgICBjYXNlIFwiU3VwZXJcIjpcbiAgICBjYXNlIFwiVGFnZ2VkVGVtcGxhdGVFeHByZXNzaW9uXCI6XG4gICAgY2FzZSBcIlRlbXBsYXRlTGl0ZXJhbFwiOlxuICAgIGNhc2UgXCJZaWVsZEV4cHJlc3Npb25cIjpcbiAgICBjYXNlIFwiQXdhaXRFeHByZXNzaW9uXCI6XG4gICAgY2FzZSBcIkltcG9ydFwiOlxuICAgIGNhc2UgXCJCaWdJbnRMaXRlcmFsXCI6XG4gICAgY2FzZSBcIk9wdGlvbmFsTWVtYmVyRXhwcmVzc2lvblwiOlxuICAgIGNhc2UgXCJPcHRpb25hbENhbGxFeHByZXNzaW9uXCI6XG4gICAgY2FzZSBcIlR5cGVDYXN0RXhwcmVzc2lvblwiOlxuICAgIGNhc2UgXCJKU1hFbGVtZW50XCI6XG4gICAgY2FzZSBcIkpTWEZyYWdtZW50XCI6XG4gICAgY2FzZSBcIkJpbmRFeHByZXNzaW9uXCI6XG4gICAgY2FzZSBcIkRvRXhwcmVzc2lvblwiOlxuICAgIGNhc2UgXCJSZWNvcmRFeHByZXNzaW9uXCI6XG4gICAgY2FzZSBcIlR1cGxlRXhwcmVzc2lvblwiOlxuICAgIGNhc2UgXCJEZWNpbWFsTGl0ZXJhbFwiOlxuICAgIGNhc2UgXCJNb2R1bGVFeHByZXNzaW9uXCI6XG4gICAgY2FzZSBcIlRvcGljUmVmZXJlbmNlXCI6XG4gICAgY2FzZSBcIlBpcGVsaW5lVG9waWNFeHByZXNzaW9uXCI6XG4gICAgY2FzZSBcIlBpcGVsaW5lQmFyZUZ1bmN0aW9uXCI6XG4gICAgY2FzZSBcIlBpcGVsaW5lUHJpbWFyeVRvcGljUmVmZXJlbmNlXCI6XG4gICAgY2FzZSBcIlRTSW5zdGFudGlhdGlvbkV4cHJlc3Npb25cIjpcbiAgICBjYXNlIFwiVFNBc0V4cHJlc3Npb25cIjpcbiAgICBjYXNlIFwiVFNTYXRpc2ZpZXNFeHByZXNzaW9uXCI6XG4gICAgY2FzZSBcIlRTVHlwZUFzc2VydGlvblwiOlxuICAgIGNhc2UgXCJUU05vbk51bGxFeHByZXNzaW9uXCI6XG4gICAgICBicmVhaztcbiAgICBjYXNlIFwiUGxhY2Vob2xkZXJcIjpcbiAgICAgIHN3aXRjaCAobm9kZS5leHBlY3RlZE5vZGUpIHtcbiAgICAgICAgY2FzZSBcIkV4cHJlc3Npb25cIjpcbiAgICAgICAgY2FzZSBcIklkZW50aWZpZXJcIjpcbiAgICAgICAgY2FzZSBcIlN0cmluZ0xpdGVyYWxcIjpcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICBicmVhaztcbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHJldHVybiBvcHRzID09IG51bGwgfHwgKDAsIF9zaGFsbG93RXF1YWwuZGVmYXVsdCkobm9kZSwgb3B0cyk7XG59XG5mdW5jdGlvbiBpc0JpbmFyeShub2RlLCBvcHRzKSB7XG4gIGlmICghbm9kZSkgcmV0dXJuIGZhbHNlO1xuICBzd2l0Y2ggKG5vZGUudHlwZSkge1xuICAgIGNhc2UgXCJCaW5hcnlFeHByZXNzaW9uXCI6XG4gICAgY2FzZSBcIkxvZ2ljYWxFeHByZXNzaW9uXCI6XG4gICAgICBicmVhaztcbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHJldHVybiBvcHRzID09IG51bGwgfHwgKDAsIF9zaGFsbG93RXF1YWwuZGVmYXVsdCkobm9kZSwgb3B0cyk7XG59XG5mdW5jdGlvbiBpc1Njb3BhYmxlKG5vZGUsIG9wdHMpIHtcbiAgaWYgKCFub2RlKSByZXR1cm4gZmFsc2U7XG4gIHN3aXRjaCAobm9kZS50eXBlKSB7XG4gICAgY2FzZSBcIkJsb2NrU3RhdGVtZW50XCI6XG4gICAgY2FzZSBcIkNhdGNoQ2xhdXNlXCI6XG4gICAgY2FzZSBcIkRvV2hpbGVTdGF0ZW1lbnRcIjpcbiAgICBjYXNlIFwiRm9ySW5TdGF0ZW1lbnRcIjpcbiAgICBjYXNlIFwiRm9yU3RhdGVtZW50XCI6XG4gICAgY2FzZSBcIkZ1bmN0aW9uRGVjbGFyYXRpb25cIjpcbiAgICBjYXNlIFwiRnVuY3Rpb25FeHByZXNzaW9uXCI6XG4gICAgY2FzZSBcIlByb2dyYW1cIjpcbiAgICBjYXNlIFwiT2JqZWN0TWV0aG9kXCI6XG4gICAgY2FzZSBcIlN3aXRjaFN0YXRlbWVudFwiOlxuICAgIGNhc2UgXCJXaGlsZVN0YXRlbWVudFwiOlxuICAgIGNhc2UgXCJBcnJvd0Z1bmN0aW9uRXhwcmVzc2lvblwiOlxuICAgIGNhc2UgXCJDbGFzc0V4cHJlc3Npb25cIjpcbiAgICBjYXNlIFwiQ2xhc3NEZWNsYXJhdGlvblwiOlxuICAgIGNhc2UgXCJGb3JPZlN0YXRlbWVudFwiOlxuICAgIGNhc2UgXCJDbGFzc01ldGhvZFwiOlxuICAgIGNhc2UgXCJDbGFzc1ByaXZhdGVNZXRob2RcIjpcbiAgICBjYXNlIFwiU3RhdGljQmxvY2tcIjpcbiAgICBjYXNlIFwiVFNNb2R1bGVCbG9ja1wiOlxuICAgICAgYnJlYWs7XG4gICAgY2FzZSBcIlBsYWNlaG9sZGVyXCI6XG4gICAgICBpZiAobm9kZS5leHBlY3RlZE5vZGUgPT09IFwiQmxvY2tTdGF0ZW1lbnRcIikgYnJlYWs7XG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICByZXR1cm4gb3B0cyA9PSBudWxsIHx8ICgwLCBfc2hhbGxvd0VxdWFsLmRlZmF1bHQpKG5vZGUsIG9wdHMpO1xufVxuZnVuY3Rpb24gaXNCbG9ja1BhcmVudChub2RlLCBvcHRzKSB7XG4gIGlmICghbm9kZSkgcmV0dXJuIGZhbHNlO1xuICBzd2l0Y2ggKG5vZGUudHlwZSkge1xuICAgIGNhc2UgXCJCbG9ja1N0YXRlbWVudFwiOlxuICAgIGNhc2UgXCJDYXRjaENsYXVzZVwiOlxuICAgIGNhc2UgXCJEb1doaWxlU3RhdGVtZW50XCI6XG4gICAgY2FzZSBcIkZvckluU3RhdGVtZW50XCI6XG4gICAgY2FzZSBcIkZvclN0YXRlbWVudFwiOlxuICAgIGNhc2UgXCJGdW5jdGlvbkRlY2xhcmF0aW9uXCI6XG4gICAgY2FzZSBcIkZ1bmN0aW9uRXhwcmVzc2lvblwiOlxuICAgIGNhc2UgXCJQcm9ncmFtXCI6XG4gICAgY2FzZSBcIk9iamVjdE1ldGhvZFwiOlxuICAgIGNhc2UgXCJTd2l0Y2hTdGF0ZW1lbnRcIjpcbiAgICBjYXNlIFwiV2hpbGVTdGF0ZW1lbnRcIjpcbiAgICBjYXNlIFwiQXJyb3dGdW5jdGlvbkV4cHJlc3Npb25cIjpcbiAgICBjYXNlIFwiRm9yT2ZTdGF0ZW1lbnRcIjpcbiAgICBjYXNlIFwiQ2xhc3NNZXRob2RcIjpcbiAgICBjYXNlIFwiQ2xhc3NQcml2YXRlTWV0aG9kXCI6XG4gICAgY2FzZSBcIlN0YXRpY0Jsb2NrXCI6XG4gICAgY2FzZSBcIlRTTW9kdWxlQmxvY2tcIjpcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgXCJQbGFjZWhvbGRlclwiOlxuICAgICAgaWYgKG5vZGUuZXhwZWN0ZWROb2RlID09PSBcIkJsb2NrU3RhdGVtZW50XCIpIGJyZWFrO1xuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgcmV0dXJuIG9wdHMgPT0gbnVsbCB8fCAoMCwgX3NoYWxsb3dFcXVhbC5kZWZhdWx0KShub2RlLCBvcHRzKTtcbn1cbmZ1bmN0aW9uIGlzQmxvY2sobm9kZSwgb3B0cykge1xuICBpZiAoIW5vZGUpIHJldHVybiBmYWxzZTtcbiAgc3dpdGNoIChub2RlLnR5cGUpIHtcbiAgICBjYXNlIFwiQmxvY2tTdGF0ZW1lbnRcIjpcbiAgICBjYXNlIFwiUHJvZ3JhbVwiOlxuICAgIGNhc2UgXCJUU01vZHVsZUJsb2NrXCI6XG4gICAgICBicmVhaztcbiAgICBjYXNlIFwiUGxhY2Vob2xkZXJcIjpcbiAgICAgIGlmIChub2RlLmV4cGVjdGVkTm9kZSA9PT0gXCJCbG9ja1N0YXRlbWVudFwiKSBicmVhaztcbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHJldHVybiBvcHRzID09IG51bGwgfHwgKDAsIF9zaGFsbG93RXF1YWwuZGVmYXVsdCkobm9kZSwgb3B0cyk7XG59XG5mdW5jdGlvbiBpc1N0YXRlbWVudChub2RlLCBvcHRzKSB7XG4gIGlmICghbm9kZSkgcmV0dXJuIGZhbHNlO1xuICBzd2l0Y2ggKG5vZGUudHlwZSkge1xuICAgIGNhc2UgXCJCbG9ja1N0YXRlbWVudFwiOlxuICAgIGNhc2UgXCJCcmVha1N0YXRlbWVudFwiOlxuICAgIGNhc2UgXCJDb250aW51ZVN0YXRlbWVudFwiOlxuICAgIGNhc2UgXCJEZWJ1Z2dlclN0YXRlbWVudFwiOlxuICAgIGNhc2UgXCJEb1doaWxlU3RhdGVtZW50XCI6XG4gICAgY2FzZSBcIkVtcHR5U3RhdGVtZW50XCI6XG4gICAgY2FzZSBcIkV4cHJlc3Npb25TdGF0ZW1lbnRcIjpcbiAgICBjYXNlIFwiRm9ySW5TdGF0ZW1lbnRcIjpcbiAgICBjYXNlIFwiRm9yU3RhdGVtZW50XCI6XG4gICAgY2FzZSBcIkZ1bmN0aW9uRGVjbGFyYXRpb25cIjpcbiAgICBjYXNlIFwiSWZTdGF0ZW1lbnRcIjpcbiAgICBjYXNlIFwiTGFiZWxlZFN0YXRlbWVudFwiOlxuICAgIGNhc2UgXCJSZXR1cm5TdGF0ZW1lbnRcIjpcbiAgICBjYXNlIFwiU3dpdGNoU3RhdGVtZW50XCI6XG4gICAgY2FzZSBcIlRocm93U3RhdGVtZW50XCI6XG4gICAgY2FzZSBcIlRyeVN0YXRlbWVudFwiOlxuICAgIGNhc2UgXCJWYXJpYWJsZURlY2xhcmF0aW9uXCI6XG4gICAgY2FzZSBcIldoaWxlU3RhdGVtZW50XCI6XG4gICAgY2FzZSBcIldpdGhTdGF0ZW1lbnRcIjpcbiAgICBjYXNlIFwiQ2xhc3NEZWNsYXJhdGlvblwiOlxuICAgIGNhc2UgXCJFeHBvcnRBbGxEZWNsYXJhdGlvblwiOlxuICAgIGNhc2UgXCJFeHBvcnREZWZhdWx0RGVjbGFyYXRpb25cIjpcbiAgICBjYXNlIFwiRXhwb3J0TmFtZWREZWNsYXJhdGlvblwiOlxuICAgIGNhc2UgXCJGb3JPZlN0YXRlbWVudFwiOlxuICAgIGNhc2UgXCJJbXBvcnREZWNsYXJhdGlvblwiOlxuICAgIGNhc2UgXCJEZWNsYXJlQ2xhc3NcIjpcbiAgICBjYXNlIFwiRGVjbGFyZUZ1bmN0aW9uXCI6XG4gICAgY2FzZSBcIkRlY2xhcmVJbnRlcmZhY2VcIjpcbiAgICBjYXNlIFwiRGVjbGFyZU1vZHVsZVwiOlxuICAgIGNhc2UgXCJEZWNsYXJlTW9kdWxlRXhwb3J0c1wiOlxuICAgIGNhc2UgXCJEZWNsYXJlVHlwZUFsaWFzXCI6XG4gICAgY2FzZSBcIkRlY2xhcmVPcGFxdWVUeXBlXCI6XG4gICAgY2FzZSBcIkRlY2xhcmVWYXJpYWJsZVwiOlxuICAgIGNhc2UgXCJEZWNsYXJlRXhwb3J0RGVjbGFyYXRpb25cIjpcbiAgICBjYXNlIFwiRGVjbGFyZUV4cG9ydEFsbERlY2xhcmF0aW9uXCI6XG4gICAgY2FzZSBcIkludGVyZmFjZURlY2xhcmF0aW9uXCI6XG4gICAgY2FzZSBcIk9wYXF1ZVR5cGVcIjpcbiAgICBjYXNlIFwiVHlwZUFsaWFzXCI6XG4gICAgY2FzZSBcIkVudW1EZWNsYXJhdGlvblwiOlxuICAgIGNhc2UgXCJUU0RlY2xhcmVGdW5jdGlvblwiOlxuICAgIGNhc2UgXCJUU0ludGVyZmFjZURlY2xhcmF0aW9uXCI6XG4gICAgY2FzZSBcIlRTVHlwZUFsaWFzRGVjbGFyYXRpb25cIjpcbiAgICBjYXNlIFwiVFNFbnVtRGVjbGFyYXRpb25cIjpcbiAgICBjYXNlIFwiVFNNb2R1bGVEZWNsYXJhdGlvblwiOlxuICAgIGNhc2UgXCJUU0ltcG9ydEVxdWFsc0RlY2xhcmF0aW9uXCI6XG4gICAgY2FzZSBcIlRTRXhwb3J0QXNzaWdubWVudFwiOlxuICAgIGNhc2UgXCJUU05hbWVzcGFjZUV4cG9ydERlY2xhcmF0aW9uXCI6XG4gICAgICBicmVhaztcbiAgICBjYXNlIFwiUGxhY2Vob2xkZXJcIjpcbiAgICAgIHN3aXRjaCAobm9kZS5leHBlY3RlZE5vZGUpIHtcbiAgICAgICAgY2FzZSBcIlN0YXRlbWVudFwiOlxuICAgICAgICBjYXNlIFwiRGVjbGFyYXRpb25cIjpcbiAgICAgICAgY2FzZSBcIkJsb2NrU3RhdGVtZW50XCI6XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgYnJlYWs7XG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICByZXR1cm4gb3B0cyA9PSBudWxsIHx8ICgwLCBfc2hhbGxvd0VxdWFsLmRlZmF1bHQpKG5vZGUsIG9wdHMpO1xufVxuZnVuY3Rpb24gaXNUZXJtaW5hdG9ybGVzcyhub2RlLCBvcHRzKSB7XG4gIGlmICghbm9kZSkgcmV0dXJuIGZhbHNlO1xuICBzd2l0Y2ggKG5vZGUudHlwZSkge1xuICAgIGNhc2UgXCJCcmVha1N0YXRlbWVudFwiOlxuICAgIGNhc2UgXCJDb250aW51ZVN0YXRlbWVudFwiOlxuICAgIGNhc2UgXCJSZXR1cm5TdGF0ZW1lbnRcIjpcbiAgICBjYXNlIFwiVGhyb3dTdGF0ZW1lbnRcIjpcbiAgICBjYXNlIFwiWWllbGRFeHByZXNzaW9uXCI6XG4gICAgY2FzZSBcIkF3YWl0RXhwcmVzc2lvblwiOlxuICAgICAgYnJlYWs7XG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICByZXR1cm4gb3B0cyA9PSBudWxsIHx8ICgwLCBfc2hhbGxvd0VxdWFsLmRlZmF1bHQpKG5vZGUsIG9wdHMpO1xufVxuZnVuY3Rpb24gaXNDb21wbGV0aW9uU3RhdGVtZW50KG5vZGUsIG9wdHMpIHtcbiAgaWYgKCFub2RlKSByZXR1cm4gZmFsc2U7XG4gIHN3aXRjaCAobm9kZS50eXBlKSB7XG4gICAgY2FzZSBcIkJyZWFrU3RhdGVtZW50XCI6XG4gICAgY2FzZSBcIkNvbnRpbnVlU3RhdGVtZW50XCI6XG4gICAgY2FzZSBcIlJldHVyblN0YXRlbWVudFwiOlxuICAgIGNhc2UgXCJUaHJvd1N0YXRlbWVudFwiOlxuICAgICAgYnJlYWs7XG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICByZXR1cm4gb3B0cyA9PSBudWxsIHx8ICgwLCBfc2hhbGxvd0VxdWFsLmRlZmF1bHQpKG5vZGUsIG9wdHMpO1xufVxuZnVuY3Rpb24gaXNDb25kaXRpb25hbChub2RlLCBvcHRzKSB7XG4gIGlmICghbm9kZSkgcmV0dXJuIGZhbHNlO1xuICBzd2l0Y2ggKG5vZGUudHlwZSkge1xuICAgIGNhc2UgXCJDb25kaXRpb25hbEV4cHJlc3Npb25cIjpcbiAgICBjYXNlIFwiSWZTdGF0ZW1lbnRcIjpcbiAgICAgIGJyZWFrO1xuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgcmV0dXJuIG9wdHMgPT0gbnVsbCB8fCAoMCwgX3NoYWxsb3dFcXVhbC5kZWZhdWx0KShub2RlLCBvcHRzKTtcbn1cbmZ1bmN0aW9uIGlzTG9vcChub2RlLCBvcHRzKSB7XG4gIGlmICghbm9kZSkgcmV0dXJuIGZhbHNlO1xuICBzd2l0Y2ggKG5vZGUudHlwZSkge1xuICAgIGNhc2UgXCJEb1doaWxlU3RhdGVtZW50XCI6XG4gICAgY2FzZSBcIkZvckluU3RhdGVtZW50XCI6XG4gICAgY2FzZSBcIkZvclN0YXRlbWVudFwiOlxuICAgIGNhc2UgXCJXaGlsZVN0YXRlbWVudFwiOlxuICAgIGNhc2UgXCJGb3JPZlN0YXRlbWVudFwiOlxuICAgICAgYnJlYWs7XG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICByZXR1cm4gb3B0cyA9PSBudWxsIHx8ICgwLCBfc2hhbGxvd0VxdWFsLmRlZmF1bHQpKG5vZGUsIG9wdHMpO1xufVxuZnVuY3Rpb24gaXNXaGlsZShub2RlLCBvcHRzKSB7XG4gIGlmICghbm9kZSkgcmV0dXJuIGZhbHNlO1xuICBzd2l0Y2ggKG5vZGUudHlwZSkge1xuICAgIGNhc2UgXCJEb1doaWxlU3RhdGVtZW50XCI6XG4gICAgY2FzZSBcIldoaWxlU3RhdGVtZW50XCI6XG4gICAgICBicmVhaztcbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHJldHVybiBvcHRzID09IG51bGwgfHwgKDAsIF9zaGFsbG93RXF1YWwuZGVmYXVsdCkobm9kZSwgb3B0cyk7XG59XG5mdW5jdGlvbiBpc0V4cHJlc3Npb25XcmFwcGVyKG5vZGUsIG9wdHMpIHtcbiAgaWYgKCFub2RlKSByZXR1cm4gZmFsc2U7XG4gIHN3aXRjaCAobm9kZS50eXBlKSB7XG4gICAgY2FzZSBcIkV4cHJlc3Npb25TdGF0ZW1lbnRcIjpcbiAgICBjYXNlIFwiUGFyZW50aGVzaXplZEV4cHJlc3Npb25cIjpcbiAgICBjYXNlIFwiVHlwZUNhc3RFeHByZXNzaW9uXCI6XG4gICAgICBicmVhaztcbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHJldHVybiBvcHRzID09IG51bGwgfHwgKDAsIF9zaGFsbG93RXF1YWwuZGVmYXVsdCkobm9kZSwgb3B0cyk7XG59XG5mdW5jdGlvbiBpc0Zvcihub2RlLCBvcHRzKSB7XG4gIGlmICghbm9kZSkgcmV0dXJuIGZhbHNlO1xuICBzd2l0Y2ggKG5vZGUudHlwZSkge1xuICAgIGNhc2UgXCJGb3JJblN0YXRlbWVudFwiOlxuICAgIGNhc2UgXCJGb3JTdGF0ZW1lbnRcIjpcbiAgICBjYXNlIFwiRm9yT2ZTdGF0ZW1lbnRcIjpcbiAgICAgIGJyZWFrO1xuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgcmV0dXJuIG9wdHMgPT0gbnVsbCB8fCAoMCwgX3NoYWxsb3dFcXVhbC5kZWZhdWx0KShub2RlLCBvcHRzKTtcbn1cbmZ1bmN0aW9uIGlzRm9yWFN0YXRlbWVudChub2RlLCBvcHRzKSB7XG4gIGlmICghbm9kZSkgcmV0dXJuIGZhbHNlO1xuICBzd2l0Y2ggKG5vZGUudHlwZSkge1xuICAgIGNhc2UgXCJGb3JJblN0YXRlbWVudFwiOlxuICAgIGNhc2UgXCJGb3JPZlN0YXRlbWVudFwiOlxuICAgICAgYnJlYWs7XG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICByZXR1cm4gb3B0cyA9PSBudWxsIHx8ICgwLCBfc2hhbGxvd0VxdWFsLmRlZmF1bHQpKG5vZGUsIG9wdHMpO1xufVxuZnVuY3Rpb24gaXNGdW5jdGlvbihub2RlLCBvcHRzKSB7XG4gIGlmICghbm9kZSkgcmV0dXJuIGZhbHNlO1xuICBzd2l0Y2ggKG5vZGUudHlwZSkge1xuICAgIGNhc2UgXCJGdW5jdGlvbkRlY2xhcmF0aW9uXCI6XG4gICAgY2FzZSBcIkZ1bmN0aW9uRXhwcmVzc2lvblwiOlxuICAgIGNhc2UgXCJPYmplY3RNZXRob2RcIjpcbiAgICBjYXNlIFwiQXJyb3dGdW5jdGlvbkV4cHJlc3Npb25cIjpcbiAgICBjYXNlIFwiQ2xhc3NNZXRob2RcIjpcbiAgICBjYXNlIFwiQ2xhc3NQcml2YXRlTWV0aG9kXCI6XG4gICAgICBicmVhaztcbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHJldHVybiBvcHRzID09IG51bGwgfHwgKDAsIF9zaGFsbG93RXF1YWwuZGVmYXVsdCkobm9kZSwgb3B0cyk7XG59XG5mdW5jdGlvbiBpc0Z1bmN0aW9uUGFyZW50KG5vZGUsIG9wdHMpIHtcbiAgaWYgKCFub2RlKSByZXR1cm4gZmFsc2U7XG4gIHN3aXRjaCAobm9kZS50eXBlKSB7XG4gICAgY2FzZSBcIkZ1bmN0aW9uRGVjbGFyYXRpb25cIjpcbiAgICBjYXNlIFwiRnVuY3Rpb25FeHByZXNzaW9uXCI6XG4gICAgY2FzZSBcIk9iamVjdE1ldGhvZFwiOlxuICAgIGNhc2UgXCJBcnJvd0Z1bmN0aW9uRXhwcmVzc2lvblwiOlxuICAgIGNhc2UgXCJDbGFzc01ldGhvZFwiOlxuICAgIGNhc2UgXCJDbGFzc1ByaXZhdGVNZXRob2RcIjpcbiAgICBjYXNlIFwiU3RhdGljQmxvY2tcIjpcbiAgICBjYXNlIFwiVFNNb2R1bGVCbG9ja1wiOlxuICAgICAgYnJlYWs7XG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICByZXR1cm4gb3B0cyA9PSBudWxsIHx8ICgwLCBfc2hhbGxvd0VxdWFsLmRlZmF1bHQpKG5vZGUsIG9wdHMpO1xufVxuZnVuY3Rpb24gaXNQdXJlaXNoKG5vZGUsIG9wdHMpIHtcbiAgaWYgKCFub2RlKSByZXR1cm4gZmFsc2U7XG4gIHN3aXRjaCAobm9kZS50eXBlKSB7XG4gICAgY2FzZSBcIkZ1bmN0aW9uRGVjbGFyYXRpb25cIjpcbiAgICBjYXNlIFwiRnVuY3Rpb25FeHByZXNzaW9uXCI6XG4gICAgY2FzZSBcIlN0cmluZ0xpdGVyYWxcIjpcbiAgICBjYXNlIFwiTnVtZXJpY0xpdGVyYWxcIjpcbiAgICBjYXNlIFwiTnVsbExpdGVyYWxcIjpcbiAgICBjYXNlIFwiQm9vbGVhbkxpdGVyYWxcIjpcbiAgICBjYXNlIFwiUmVnRXhwTGl0ZXJhbFwiOlxuICAgIGNhc2UgXCJBcnJvd0Z1bmN0aW9uRXhwcmVzc2lvblwiOlxuICAgIGNhc2UgXCJCaWdJbnRMaXRlcmFsXCI6XG4gICAgY2FzZSBcIkRlY2ltYWxMaXRlcmFsXCI6XG4gICAgICBicmVhaztcbiAgICBjYXNlIFwiUGxhY2Vob2xkZXJcIjpcbiAgICAgIGlmIChub2RlLmV4cGVjdGVkTm9kZSA9PT0gXCJTdHJpbmdMaXRlcmFsXCIpIGJyZWFrO1xuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgcmV0dXJuIG9wdHMgPT0gbnVsbCB8fCAoMCwgX3NoYWxsb3dFcXVhbC5kZWZhdWx0KShub2RlLCBvcHRzKTtcbn1cbmZ1bmN0aW9uIGlzRGVjbGFyYXRpb24obm9kZSwgb3B0cykge1xuICBpZiAoIW5vZGUpIHJldHVybiBmYWxzZTtcbiAgc3dpdGNoIChub2RlLnR5cGUpIHtcbiAgICBjYXNlIFwiRnVuY3Rpb25EZWNsYXJhdGlvblwiOlxuICAgIGNhc2UgXCJWYXJpYWJsZURlY2xhcmF0aW9uXCI6XG4gICAgY2FzZSBcIkNsYXNzRGVjbGFyYXRpb25cIjpcbiAgICBjYXNlIFwiRXhwb3J0QWxsRGVjbGFyYXRpb25cIjpcbiAgICBjYXNlIFwiRXhwb3J0RGVmYXVsdERlY2xhcmF0aW9uXCI6XG4gICAgY2FzZSBcIkV4cG9ydE5hbWVkRGVjbGFyYXRpb25cIjpcbiAgICBjYXNlIFwiSW1wb3J0RGVjbGFyYXRpb25cIjpcbiAgICBjYXNlIFwiRGVjbGFyZUNsYXNzXCI6XG4gICAgY2FzZSBcIkRlY2xhcmVGdW5jdGlvblwiOlxuICAgIGNhc2UgXCJEZWNsYXJlSW50ZXJmYWNlXCI6XG4gICAgY2FzZSBcIkRlY2xhcmVNb2R1bGVcIjpcbiAgICBjYXNlIFwiRGVjbGFyZU1vZHVsZUV4cG9ydHNcIjpcbiAgICBjYXNlIFwiRGVjbGFyZVR5cGVBbGlhc1wiOlxuICAgIGNhc2UgXCJEZWNsYXJlT3BhcXVlVHlwZVwiOlxuICAgIGNhc2UgXCJEZWNsYXJlVmFyaWFibGVcIjpcbiAgICBjYXNlIFwiRGVjbGFyZUV4cG9ydERlY2xhcmF0aW9uXCI6XG4gICAgY2FzZSBcIkRlY2xhcmVFeHBvcnRBbGxEZWNsYXJhdGlvblwiOlxuICAgIGNhc2UgXCJJbnRlcmZhY2VEZWNsYXJhdGlvblwiOlxuICAgIGNhc2UgXCJPcGFxdWVUeXBlXCI6XG4gICAgY2FzZSBcIlR5cGVBbGlhc1wiOlxuICAgIGNhc2UgXCJFbnVtRGVjbGFyYXRpb25cIjpcbiAgICBjYXNlIFwiVFNEZWNsYXJlRnVuY3Rpb25cIjpcbiAgICBjYXNlIFwiVFNJbnRlcmZhY2VEZWNsYXJhdGlvblwiOlxuICAgIGNhc2UgXCJUU1R5cGVBbGlhc0RlY2xhcmF0aW9uXCI6XG4gICAgY2FzZSBcIlRTRW51bURlY2xhcmF0aW9uXCI6XG4gICAgY2FzZSBcIlRTTW9kdWxlRGVjbGFyYXRpb25cIjpcbiAgICBjYXNlIFwiVFNJbXBvcnRFcXVhbHNEZWNsYXJhdGlvblwiOlxuICAgICAgYnJlYWs7XG4gICAgY2FzZSBcIlBsYWNlaG9sZGVyXCI6XG4gICAgICBpZiAobm9kZS5leHBlY3RlZE5vZGUgPT09IFwiRGVjbGFyYXRpb25cIikgYnJlYWs7XG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICByZXR1cm4gb3B0cyA9PSBudWxsIHx8ICgwLCBfc2hhbGxvd0VxdWFsLmRlZmF1bHQpKG5vZGUsIG9wdHMpO1xufVxuZnVuY3Rpb24gaXNGdW5jdGlvblBhcmFtZXRlcihub2RlLCBvcHRzKSB7XG4gIGlmICghbm9kZSkgcmV0dXJuIGZhbHNlO1xuICBzd2l0Y2ggKG5vZGUudHlwZSkge1xuICAgIGNhc2UgXCJJZGVudGlmaWVyXCI6XG4gICAgY2FzZSBcIlJlc3RFbGVtZW50XCI6XG4gICAgY2FzZSBcIkFzc2lnbm1lbnRQYXR0ZXJuXCI6XG4gICAgY2FzZSBcIkFycmF5UGF0dGVyblwiOlxuICAgIGNhc2UgXCJPYmplY3RQYXR0ZXJuXCI6XG4gICAgY2FzZSBcIlZvaWRQYXR0ZXJuXCI6XG4gICAgICBicmVhaztcbiAgICBjYXNlIFwiUGxhY2Vob2xkZXJcIjpcbiAgICAgIGlmIChub2RlLmV4cGVjdGVkTm9kZSA9PT0gXCJJZGVudGlmaWVyXCIpIGJyZWFrO1xuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgcmV0dXJuIG9wdHMgPT0gbnVsbCB8fCAoMCwgX3NoYWxsb3dFcXVhbC5kZWZhdWx0KShub2RlLCBvcHRzKTtcbn1cbmZ1bmN0aW9uIGlzUGF0dGVybkxpa2Uobm9kZSwgb3B0cykge1xuICBpZiAoIW5vZGUpIHJldHVybiBmYWxzZTtcbiAgc3dpdGNoIChub2RlLnR5cGUpIHtcbiAgICBjYXNlIFwiSWRlbnRpZmllclwiOlxuICAgIGNhc2UgXCJNZW1iZXJFeHByZXNzaW9uXCI6XG4gICAgY2FzZSBcIlJlc3RFbGVtZW50XCI6XG4gICAgY2FzZSBcIkFzc2lnbm1lbnRQYXR0ZXJuXCI6XG4gICAgY2FzZSBcIkFycmF5UGF0dGVyblwiOlxuICAgIGNhc2UgXCJPYmplY3RQYXR0ZXJuXCI6XG4gICAgY2FzZSBcIlZvaWRQYXR0ZXJuXCI6XG4gICAgY2FzZSBcIlRTQXNFeHByZXNzaW9uXCI6XG4gICAgY2FzZSBcIlRTU2F0aXNmaWVzRXhwcmVzc2lvblwiOlxuICAgIGNhc2UgXCJUU1R5cGVBc3NlcnRpb25cIjpcbiAgICBjYXNlIFwiVFNOb25OdWxsRXhwcmVzc2lvblwiOlxuICAgICAgYnJlYWs7XG4gICAgY2FzZSBcIlBsYWNlaG9sZGVyXCI6XG4gICAgICBzd2l0Y2ggKG5vZGUuZXhwZWN0ZWROb2RlKSB7XG4gICAgICAgIGNhc2UgXCJQYXR0ZXJuXCI6XG4gICAgICAgIGNhc2UgXCJJZGVudGlmaWVyXCI6XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgYnJlYWs7XG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICByZXR1cm4gb3B0cyA9PSBudWxsIHx8ICgwLCBfc2hhbGxvd0VxdWFsLmRlZmF1bHQpKG5vZGUsIG9wdHMpO1xufVxuZnVuY3Rpb24gaXNMVmFsKG5vZGUsIG9wdHMpIHtcbiAgaWYgKCFub2RlKSByZXR1cm4gZmFsc2U7XG4gIHN3aXRjaCAobm9kZS50eXBlKSB7XG4gICAgY2FzZSBcIklkZW50aWZpZXJcIjpcbiAgICBjYXNlIFwiTWVtYmVyRXhwcmVzc2lvblwiOlxuICAgIGNhc2UgXCJSZXN0RWxlbWVudFwiOlxuICAgIGNhc2UgXCJBc3NpZ25tZW50UGF0dGVyblwiOlxuICAgIGNhc2UgXCJBcnJheVBhdHRlcm5cIjpcbiAgICBjYXNlIFwiT2JqZWN0UGF0dGVyblwiOlxuICAgIGNhc2UgXCJUU1BhcmFtZXRlclByb3BlcnR5XCI6XG4gICAgY2FzZSBcIlRTQXNFeHByZXNzaW9uXCI6XG4gICAgY2FzZSBcIlRTU2F0aXNmaWVzRXhwcmVzc2lvblwiOlxuICAgIGNhc2UgXCJUU1R5cGVBc3NlcnRpb25cIjpcbiAgICBjYXNlIFwiVFNOb25OdWxsRXhwcmVzc2lvblwiOlxuICAgICAgYnJlYWs7XG4gICAgY2FzZSBcIlBsYWNlaG9sZGVyXCI6XG4gICAgICBzd2l0Y2ggKG5vZGUuZXhwZWN0ZWROb2RlKSB7XG4gICAgICAgIGNhc2UgXCJQYXR0ZXJuXCI6XG4gICAgICAgIGNhc2UgXCJJZGVudGlmaWVyXCI6XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgYnJlYWs7XG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICByZXR1cm4gb3B0cyA9PSBudWxsIHx8ICgwLCBfc2hhbGxvd0VxdWFsLmRlZmF1bHQpKG5vZGUsIG9wdHMpO1xufVxuZnVuY3Rpb24gaXNUU0VudGl0eU5hbWUobm9kZSwgb3B0cykge1xuICBpZiAoIW5vZGUpIHJldHVybiBmYWxzZTtcbiAgc3dpdGNoIChub2RlLnR5cGUpIHtcbiAgICBjYXNlIFwiSWRlbnRpZmllclwiOlxuICAgIGNhc2UgXCJUU1F1YWxpZmllZE5hbWVcIjpcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgXCJQbGFjZWhvbGRlclwiOlxuICAgICAgaWYgKG5vZGUuZXhwZWN0ZWROb2RlID09PSBcIklkZW50aWZpZXJcIikgYnJlYWs7XG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICByZXR1cm4gb3B0cyA9PSBudWxsIHx8ICgwLCBfc2hhbGxvd0VxdWFsLmRlZmF1bHQpKG5vZGUsIG9wdHMpO1xufVxuZnVuY3Rpb24gaXNMaXRlcmFsKG5vZGUsIG9wdHMpIHtcbiAgaWYgKCFub2RlKSByZXR1cm4gZmFsc2U7XG4gIHN3aXRjaCAobm9kZS50eXBlKSB7XG4gICAgY2FzZSBcIlN0cmluZ0xpdGVyYWxcIjpcbiAgICBjYXNlIFwiTnVtZXJpY0xpdGVyYWxcIjpcbiAgICBjYXNlIFwiTnVsbExpdGVyYWxcIjpcbiAgICBjYXNlIFwiQm9vbGVhbkxpdGVyYWxcIjpcbiAgICBjYXNlIFwiUmVnRXhwTGl0ZXJhbFwiOlxuICAgIGNhc2UgXCJUZW1wbGF0ZUxpdGVyYWxcIjpcbiAgICBjYXNlIFwiQmlnSW50TGl0ZXJhbFwiOlxuICAgIGNhc2UgXCJEZWNpbWFsTGl0ZXJhbFwiOlxuICAgICAgYnJlYWs7XG4gICAgY2FzZSBcIlBsYWNlaG9sZGVyXCI6XG4gICAgICBpZiAobm9kZS5leHBlY3RlZE5vZGUgPT09IFwiU3RyaW5nTGl0ZXJhbFwiKSBicmVhaztcbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHJldHVybiBvcHRzID09IG51bGwgfHwgKDAsIF9zaGFsbG93RXF1YWwuZGVmYXVsdCkobm9kZSwgb3B0cyk7XG59XG5mdW5jdGlvbiBpc0ltbXV0YWJsZShub2RlLCBvcHRzKSB7XG4gIGlmICghbm9kZSkgcmV0dXJuIGZhbHNlO1xuICBzd2l0Y2ggKG5vZGUudHlwZSkge1xuICAgIGNhc2UgXCJTdHJpbmdMaXRlcmFsXCI6XG4gICAgY2FzZSBcIk51bWVyaWNMaXRlcmFsXCI6XG4gICAgY2FzZSBcIk51bGxMaXRlcmFsXCI6XG4gICAgY2FzZSBcIkJvb2xlYW5MaXRlcmFsXCI6XG4gICAgY2FzZSBcIkJpZ0ludExpdGVyYWxcIjpcbiAgICBjYXNlIFwiSlNYQXR0cmlidXRlXCI6XG4gICAgY2FzZSBcIkpTWENsb3NpbmdFbGVtZW50XCI6XG4gICAgY2FzZSBcIkpTWEVsZW1lbnRcIjpcbiAgICBjYXNlIFwiSlNYRXhwcmVzc2lvbkNvbnRhaW5lclwiOlxuICAgIGNhc2UgXCJKU1hTcHJlYWRDaGlsZFwiOlxuICAgIGNhc2UgXCJKU1hPcGVuaW5nRWxlbWVudFwiOlxuICAgIGNhc2UgXCJKU1hUZXh0XCI6XG4gICAgY2FzZSBcIkpTWEZyYWdtZW50XCI6XG4gICAgY2FzZSBcIkpTWE9wZW5pbmdGcmFnbWVudFwiOlxuICAgIGNhc2UgXCJKU1hDbG9zaW5nRnJhZ21lbnRcIjpcbiAgICBjYXNlIFwiRGVjaW1hbExpdGVyYWxcIjpcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgXCJQbGFjZWhvbGRlclwiOlxuICAgICAgaWYgKG5vZGUuZXhwZWN0ZWROb2RlID09PSBcIlN0cmluZ0xpdGVyYWxcIikgYnJlYWs7XG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICByZXR1cm4gb3B0cyA9PSBudWxsIHx8ICgwLCBfc2hhbGxvd0VxdWFsLmRlZmF1bHQpKG5vZGUsIG9wdHMpO1xufVxuZnVuY3Rpb24gaXNVc2VyV2hpdGVzcGFjYWJsZShub2RlLCBvcHRzKSB7XG4gIGlmICghbm9kZSkgcmV0dXJuIGZhbHNlO1xuICBzd2l0Y2ggKG5vZGUudHlwZSkge1xuICAgIGNhc2UgXCJPYmplY3RNZXRob2RcIjpcbiAgICBjYXNlIFwiT2JqZWN0UHJvcGVydHlcIjpcbiAgICBjYXNlIFwiT2JqZWN0VHlwZUludGVybmFsU2xvdFwiOlxuICAgIGNhc2UgXCJPYmplY3RUeXBlQ2FsbFByb3BlcnR5XCI6XG4gICAgY2FzZSBcIk9iamVjdFR5cGVJbmRleGVyXCI6XG4gICAgY2FzZSBcIk9iamVjdFR5cGVQcm9wZXJ0eVwiOlxuICAgIGNhc2UgXCJPYmplY3RUeXBlU3ByZWFkUHJvcGVydHlcIjpcbiAgICAgIGJyZWFrO1xuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgcmV0dXJuIG9wdHMgPT0gbnVsbCB8fCAoMCwgX3NoYWxsb3dFcXVhbC5kZWZhdWx0KShub2RlLCBvcHRzKTtcbn1cbmZ1bmN0aW9uIGlzTWV0aG9kKG5vZGUsIG9wdHMpIHtcbiAgaWYgKCFub2RlKSByZXR1cm4gZmFsc2U7XG4gIHN3aXRjaCAobm9kZS50eXBlKSB7XG4gICAgY2FzZSBcIk9iamVjdE1ldGhvZFwiOlxuICAgIGNhc2UgXCJDbGFzc01ldGhvZFwiOlxuICAgIGNhc2UgXCJDbGFzc1ByaXZhdGVNZXRob2RcIjpcbiAgICAgIGJyZWFrO1xuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgcmV0dXJuIG9wdHMgPT0gbnVsbCB8fCAoMCwgX3NoYWxsb3dFcXVhbC5kZWZhdWx0KShub2RlLCBvcHRzKTtcbn1cbmZ1bmN0aW9uIGlzT2JqZWN0TWVtYmVyKG5vZGUsIG9wdHMpIHtcbiAgaWYgKCFub2RlKSByZXR1cm4gZmFsc2U7XG4gIHN3aXRjaCAobm9kZS50eXBlKSB7XG4gICAgY2FzZSBcIk9iamVjdE1ldGhvZFwiOlxuICAgIGNhc2UgXCJPYmplY3RQcm9wZXJ0eVwiOlxuICAgICAgYnJlYWs7XG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICByZXR1cm4gb3B0cyA9PSBudWxsIHx8ICgwLCBfc2hhbGxvd0VxdWFsLmRlZmF1bHQpKG5vZGUsIG9wdHMpO1xufVxuZnVuY3Rpb24gaXNQcm9wZXJ0eShub2RlLCBvcHRzKSB7XG4gIGlmICghbm9kZSkgcmV0dXJuIGZhbHNlO1xuICBzd2l0Y2ggKG5vZGUudHlwZSkge1xuICAgIGNhc2UgXCJPYmplY3RQcm9wZXJ0eVwiOlxuICAgIGNhc2UgXCJDbGFzc1Byb3BlcnR5XCI6XG4gICAgY2FzZSBcIkNsYXNzQWNjZXNzb3JQcm9wZXJ0eVwiOlxuICAgIGNhc2UgXCJDbGFzc1ByaXZhdGVQcm9wZXJ0eVwiOlxuICAgICAgYnJlYWs7XG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICByZXR1cm4gb3B0cyA9PSBudWxsIHx8ICgwLCBfc2hhbGxvd0VxdWFsLmRlZmF1bHQpKG5vZGUsIG9wdHMpO1xufVxuZnVuY3Rpb24gaXNVbmFyeUxpa2Uobm9kZSwgb3B0cykge1xuICBpZiAoIW5vZGUpIHJldHVybiBmYWxzZTtcbiAgc3dpdGNoIChub2RlLnR5cGUpIHtcbiAgICBjYXNlIFwiVW5hcnlFeHByZXNzaW9uXCI6XG4gICAgY2FzZSBcIlNwcmVhZEVsZW1lbnRcIjpcbiAgICAgIGJyZWFrO1xuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgcmV0dXJuIG9wdHMgPT0gbnVsbCB8fCAoMCwgX3NoYWxsb3dFcXVhbC5kZWZhdWx0KShub2RlLCBvcHRzKTtcbn1cbmZ1bmN0aW9uIGlzUGF0dGVybihub2RlLCBvcHRzKSB7XG4gIGlmICghbm9kZSkgcmV0dXJuIGZhbHNlO1xuICBzd2l0Y2ggKG5vZGUudHlwZSkge1xuICAgIGNhc2UgXCJBc3NpZ25tZW50UGF0dGVyblwiOlxuICAgIGNhc2UgXCJBcnJheVBhdHRlcm5cIjpcbiAgICBjYXNlIFwiT2JqZWN0UGF0dGVyblwiOlxuICAgIGNhc2UgXCJWb2lkUGF0dGVyblwiOlxuICAgICAgYnJlYWs7XG4gICAgY2FzZSBcIlBsYWNlaG9sZGVyXCI6XG4gICAgICBpZiAobm9kZS5leHBlY3RlZE5vZGUgPT09IFwiUGF0dGVyblwiKSBicmVhaztcbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHJldHVybiBvcHRzID09IG51bGwgfHwgKDAsIF9zaGFsbG93RXF1YWwuZGVmYXVsdCkobm9kZSwgb3B0cyk7XG59XG5mdW5jdGlvbiBpc0NsYXNzKG5vZGUsIG9wdHMpIHtcbiAgaWYgKCFub2RlKSByZXR1cm4gZmFsc2U7XG4gIHN3aXRjaCAobm9kZS50eXBlKSB7XG4gICAgY2FzZSBcIkNsYXNzRXhwcmVzc2lvblwiOlxuICAgIGNhc2UgXCJDbGFzc0RlY2xhcmF0aW9uXCI6XG4gICAgICBicmVhaztcbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHJldHVybiBvcHRzID09IG51bGwgfHwgKDAsIF9zaGFsbG93RXF1YWwuZGVmYXVsdCkobm9kZSwgb3B0cyk7XG59XG5mdW5jdGlvbiBpc0ltcG9ydE9yRXhwb3J0RGVjbGFyYXRpb24obm9kZSwgb3B0cykge1xuICBpZiAoIW5vZGUpIHJldHVybiBmYWxzZTtcbiAgc3dpdGNoIChub2RlLnR5cGUpIHtcbiAgICBjYXNlIFwiRXhwb3J0QWxsRGVjbGFyYXRpb25cIjpcbiAgICBjYXNlIFwiRXhwb3J0RGVmYXVsdERlY2xhcmF0aW9uXCI6XG4gICAgY2FzZSBcIkV4cG9ydE5hbWVkRGVjbGFyYXRpb25cIjpcbiAgICBjYXNlIFwiSW1wb3J0RGVjbGFyYXRpb25cIjpcbiAgICAgIGJyZWFrO1xuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgcmV0dXJuIG9wdHMgPT0gbnVsbCB8fCAoMCwgX3NoYWxsb3dFcXVhbC5kZWZhdWx0KShub2RlLCBvcHRzKTtcbn1cbmZ1bmN0aW9uIGlzRXhwb3J0RGVjbGFyYXRpb24obm9kZSwgb3B0cykge1xuICBpZiAoIW5vZGUpIHJldHVybiBmYWxzZTtcbiAgc3dpdGNoIChub2RlLnR5cGUpIHtcbiAgICBjYXNlIFwiRXhwb3J0QWxsRGVjbGFyYXRpb25cIjpcbiAgICBjYXNlIFwiRXhwb3J0RGVmYXVsdERlY2xhcmF0aW9uXCI6XG4gICAgY2FzZSBcIkV4cG9ydE5hbWVkRGVjbGFyYXRpb25cIjpcbiAgICAgIGJyZWFrO1xuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgcmV0dXJuIG9wdHMgPT0gbnVsbCB8fCAoMCwgX3NoYWxsb3dFcXVhbC5kZWZhdWx0KShub2RlLCBvcHRzKTtcbn1cbmZ1bmN0aW9uIGlzTW9kdWxlU3BlY2lmaWVyKG5vZGUsIG9wdHMpIHtcbiAgaWYgKCFub2RlKSByZXR1cm4gZmFsc2U7XG4gIHN3aXRjaCAobm9kZS50eXBlKSB7XG4gICAgY2FzZSBcIkV4cG9ydFNwZWNpZmllclwiOlxuICAgIGNhc2UgXCJJbXBvcnREZWZhdWx0U3BlY2lmaWVyXCI6XG4gICAgY2FzZSBcIkltcG9ydE5hbWVzcGFjZVNwZWNpZmllclwiOlxuICAgIGNhc2UgXCJJbXBvcnRTcGVjaWZpZXJcIjpcbiAgICBjYXNlIFwiRXhwb3J0TmFtZXNwYWNlU3BlY2lmaWVyXCI6XG4gICAgY2FzZSBcIkV4cG9ydERlZmF1bHRTcGVjaWZpZXJcIjpcbiAgICAgIGJyZWFrO1xuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgcmV0dXJuIG9wdHMgPT0gbnVsbCB8fCAoMCwgX3NoYWxsb3dFcXVhbC5kZWZhdWx0KShub2RlLCBvcHRzKTtcbn1cbmZ1bmN0aW9uIGlzQWNjZXNzb3Iobm9kZSwgb3B0cykge1xuICBpZiAoIW5vZGUpIHJldHVybiBmYWxzZTtcbiAgc3dpdGNoIChub2RlLnR5cGUpIHtcbiAgICBjYXNlIFwiQ2xhc3NBY2Nlc3NvclByb3BlcnR5XCI6XG4gICAgICBicmVhaztcbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHJldHVybiBvcHRzID09IG51bGwgfHwgKDAsIF9zaGFsbG93RXF1YWwuZGVmYXVsdCkobm9kZSwgb3B0cyk7XG59XG5mdW5jdGlvbiBpc1ByaXZhdGUobm9kZSwgb3B0cykge1xuICBpZiAoIW5vZGUpIHJldHVybiBmYWxzZTtcbiAgc3dpdGNoIChub2RlLnR5cGUpIHtcbiAgICBjYXNlIFwiQ2xhc3NQcml2YXRlUHJvcGVydHlcIjpcbiAgICBjYXNlIFwiQ2xhc3NQcml2YXRlTWV0aG9kXCI6XG4gICAgY2FzZSBcIlByaXZhdGVOYW1lXCI6XG4gICAgICBicmVhaztcbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHJldHVybiBvcHRzID09IG51bGwgfHwgKDAsIF9zaGFsbG93RXF1YWwuZGVmYXVsdCkobm9kZSwgb3B0cyk7XG59XG5mdW5jdGlvbiBpc0Zsb3cobm9kZSwgb3B0cykge1xuICBpZiAoIW5vZGUpIHJldHVybiBmYWxzZTtcbiAgc3dpdGNoIChub2RlLnR5cGUpIHtcbiAgICBjYXNlIFwiQW55VHlwZUFubm90YXRpb25cIjpcbiAgICBjYXNlIFwiQXJyYXlUeXBlQW5ub3RhdGlvblwiOlxuICAgIGNhc2UgXCJCb29sZWFuVHlwZUFubm90YXRpb25cIjpcbiAgICBjYXNlIFwiQm9vbGVhbkxpdGVyYWxUeXBlQW5ub3RhdGlvblwiOlxuICAgIGNhc2UgXCJOdWxsTGl0ZXJhbFR5cGVBbm5vdGF0aW9uXCI6XG4gICAgY2FzZSBcIkNsYXNzSW1wbGVtZW50c1wiOlxuICAgIGNhc2UgXCJEZWNsYXJlQ2xhc3NcIjpcbiAgICBjYXNlIFwiRGVjbGFyZUZ1bmN0aW9uXCI6XG4gICAgY2FzZSBcIkRlY2xhcmVJbnRlcmZhY2VcIjpcbiAgICBjYXNlIFwiRGVjbGFyZU1vZHVsZVwiOlxuICAgIGNhc2UgXCJEZWNsYXJlTW9kdWxlRXhwb3J0c1wiOlxuICAgIGNhc2UgXCJEZWNsYXJlVHlwZUFsaWFzXCI6XG4gICAgY2FzZSBcIkRlY2xhcmVPcGFxdWVUeXBlXCI6XG4gICAgY2FzZSBcIkRlY2xhcmVWYXJpYWJsZVwiOlxuICAgIGNhc2UgXCJEZWNsYXJlRXhwb3J0RGVjbGFyYXRpb25cIjpcbiAgICBjYXNlIFwiRGVjbGFyZUV4cG9ydEFsbERlY2xhcmF0aW9uXCI6XG4gICAgY2FzZSBcIkRlY2xhcmVkUHJlZGljYXRlXCI6XG4gICAgY2FzZSBcIkV4aXN0c1R5cGVBbm5vdGF0aW9uXCI6XG4gICAgY2FzZSBcIkZ1bmN0aW9uVHlwZUFubm90YXRpb25cIjpcbiAgICBjYXNlIFwiRnVuY3Rpb25UeXBlUGFyYW1cIjpcbiAgICBjYXNlIFwiR2VuZXJpY1R5cGVBbm5vdGF0aW9uXCI6XG4gICAgY2FzZSBcIkluZmVycmVkUHJlZGljYXRlXCI6XG4gICAgY2FzZSBcIkludGVyZmFjZUV4dGVuZHNcIjpcbiAgICBjYXNlIFwiSW50ZXJmYWNlRGVjbGFyYXRpb25cIjpcbiAgICBjYXNlIFwiSW50ZXJmYWNlVHlwZUFubm90YXRpb25cIjpcbiAgICBjYXNlIFwiSW50ZXJzZWN0aW9uVHlwZUFubm90YXRpb25cIjpcbiAgICBjYXNlIFwiTWl4ZWRUeXBlQW5ub3RhdGlvblwiOlxuICAgIGNhc2UgXCJFbXB0eVR5cGVBbm5vdGF0aW9uXCI6XG4gICAgY2FzZSBcIk51bGxhYmxlVHlwZUFubm90YXRpb25cIjpcbiAgICBjYXNlIFwiTnVtYmVyTGl0ZXJhbFR5cGVBbm5vdGF0aW9uXCI6XG4gICAgY2FzZSBcIk51bWJlclR5cGVBbm5vdGF0aW9uXCI6XG4gICAgY2FzZSBcIk9iamVjdFR5cGVBbm5vdGF0aW9uXCI6XG4gICAgY2FzZSBcIk9iamVjdFR5cGVJbnRlcm5hbFNsb3RcIjpcbiAgICBjYXNlIFwiT2JqZWN0VHlwZUNhbGxQcm9wZXJ0eVwiOlxuICAgIGNhc2UgXCJPYmplY3RUeXBlSW5kZXhlclwiOlxuICAgIGNhc2UgXCJPYmplY3RUeXBlUHJvcGVydHlcIjpcbiAgICBjYXNlIFwiT2JqZWN0VHlwZVNwcmVhZFByb3BlcnR5XCI6XG4gICAgY2FzZSBcIk9wYXF1ZVR5cGVcIjpcbiAgICBjYXNlIFwiUXVhbGlmaWVkVHlwZUlkZW50aWZpZXJcIjpcbiAgICBjYXNlIFwiU3RyaW5nTGl0ZXJhbFR5cGVBbm5vdGF0aW9uXCI6XG4gICAgY2FzZSBcIlN0cmluZ1R5cGVBbm5vdGF0aW9uXCI6XG4gICAgY2FzZSBcIlN5bWJvbFR5cGVBbm5vdGF0aW9uXCI6XG4gICAgY2FzZSBcIlRoaXNUeXBlQW5ub3RhdGlvblwiOlxuICAgIGNhc2UgXCJUdXBsZVR5cGVBbm5vdGF0aW9uXCI6XG4gICAgY2FzZSBcIlR5cGVvZlR5cGVBbm5vdGF0aW9uXCI6XG4gICAgY2FzZSBcIlR5cGVBbGlhc1wiOlxuICAgIGNhc2UgXCJUeXBlQW5ub3RhdGlvblwiOlxuICAgIGNhc2UgXCJUeXBlQ2FzdEV4cHJlc3Npb25cIjpcbiAgICBjYXNlIFwiVHlwZVBhcmFtZXRlclwiOlxuICAgIGNhc2UgXCJUeXBlUGFyYW1ldGVyRGVjbGFyYXRpb25cIjpcbiAgICBjYXNlIFwiVHlwZVBhcmFtZXRlckluc3RhbnRpYXRpb25cIjpcbiAgICBjYXNlIFwiVW5pb25UeXBlQW5ub3RhdGlvblwiOlxuICAgIGNhc2UgXCJWYXJpYW5jZVwiOlxuICAgIGNhc2UgXCJWb2lkVHlwZUFubm90YXRpb25cIjpcbiAgICBjYXNlIFwiRW51bURlY2xhcmF0aW9uXCI6XG4gICAgY2FzZSBcIkVudW1Cb29sZWFuQm9keVwiOlxuICAgIGNhc2UgXCJFbnVtTnVtYmVyQm9keVwiOlxuICAgIGNhc2UgXCJFbnVtU3RyaW5nQm9keVwiOlxuICAgIGNhc2UgXCJFbnVtU3ltYm9sQm9keVwiOlxuICAgIGNhc2UgXCJFbnVtQm9vbGVhbk1lbWJlclwiOlxuICAgIGNhc2UgXCJFbnVtTnVtYmVyTWVtYmVyXCI6XG4gICAgY2FzZSBcIkVudW1TdHJpbmdNZW1iZXJcIjpcbiAgICBjYXNlIFwiRW51bURlZmF1bHRlZE1lbWJlclwiOlxuICAgIGNhc2UgXCJJbmRleGVkQWNjZXNzVHlwZVwiOlxuICAgIGNhc2UgXCJPcHRpb25hbEluZGV4ZWRBY2Nlc3NUeXBlXCI6XG4gICAgICBicmVhaztcbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHJldHVybiBvcHRzID09IG51bGwgfHwgKDAsIF9zaGFsbG93RXF1YWwuZGVmYXVsdCkobm9kZSwgb3B0cyk7XG59XG5mdW5jdGlvbiBpc0Zsb3dUeXBlKG5vZGUsIG9wdHMpIHtcbiAgaWYgKCFub2RlKSByZXR1cm4gZmFsc2U7XG4gIHN3aXRjaCAobm9kZS50eXBlKSB7XG4gICAgY2FzZSBcIkFueVR5cGVBbm5vdGF0aW9uXCI6XG4gICAgY2FzZSBcIkFycmF5VHlwZUFubm90YXRpb25cIjpcbiAgICBjYXNlIFwiQm9vbGVhblR5cGVBbm5vdGF0aW9uXCI6XG4gICAgY2FzZSBcIkJvb2xlYW5MaXRlcmFsVHlwZUFubm90YXRpb25cIjpcbiAgICBjYXNlIFwiTnVsbExpdGVyYWxUeXBlQW5ub3RhdGlvblwiOlxuICAgIGNhc2UgXCJFeGlzdHNUeXBlQW5ub3RhdGlvblwiOlxuICAgIGNhc2UgXCJGdW5jdGlvblR5cGVBbm5vdGF0aW9uXCI6XG4gICAgY2FzZSBcIkdlbmVyaWNUeXBlQW5ub3RhdGlvblwiOlxuICAgIGNhc2UgXCJJbnRlcmZhY2VUeXBlQW5ub3RhdGlvblwiOlxuICAgIGNhc2UgXCJJbnRlcnNlY3Rpb25UeXBlQW5ub3RhdGlvblwiOlxuICAgIGNhc2UgXCJNaXhlZFR5cGVBbm5vdGF0aW9uXCI6XG4gICAgY2FzZSBcIkVtcHR5VHlwZUFubm90YXRpb25cIjpcbiAgICBjYXNlIFwiTnVsbGFibGVUeXBlQW5ub3RhdGlvblwiOlxuICAgIGNhc2UgXCJOdW1iZXJMaXRlcmFsVHlwZUFubm90YXRpb25cIjpcbiAgICBjYXNlIFwiTnVtYmVyVHlwZUFubm90YXRpb25cIjpcbiAgICBjYXNlIFwiT2JqZWN0VHlwZUFubm90YXRpb25cIjpcbiAgICBjYXNlIFwiU3RyaW5nTGl0ZXJhbFR5cGVBbm5vdGF0aW9uXCI6XG4gICAgY2FzZSBcIlN0cmluZ1R5cGVBbm5vdGF0aW9uXCI6XG4gICAgY2FzZSBcIlN5bWJvbFR5cGVBbm5vdGF0aW9uXCI6XG4gICAgY2FzZSBcIlRoaXNUeXBlQW5ub3RhdGlvblwiOlxuICAgIGNhc2UgXCJUdXBsZVR5cGVBbm5vdGF0aW9uXCI6XG4gICAgY2FzZSBcIlR5cGVvZlR5cGVBbm5vdGF0aW9uXCI6XG4gICAgY2FzZSBcIlVuaW9uVHlwZUFubm90YXRpb25cIjpcbiAgICBjYXNlIFwiVm9pZFR5cGVBbm5vdGF0aW9uXCI6XG4gICAgY2FzZSBcIkluZGV4ZWRBY2Nlc3NUeXBlXCI6XG4gICAgY2FzZSBcIk9wdGlvbmFsSW5kZXhlZEFjY2Vzc1R5cGVcIjpcbiAgICAgIGJyZWFrO1xuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgcmV0dXJuIG9wdHMgPT0gbnVsbCB8fCAoMCwgX3NoYWxsb3dFcXVhbC5kZWZhdWx0KShub2RlLCBvcHRzKTtcbn1cbmZ1bmN0aW9uIGlzRmxvd0Jhc2VBbm5vdGF0aW9uKG5vZGUsIG9wdHMpIHtcbiAgaWYgKCFub2RlKSByZXR1cm4gZmFsc2U7XG4gIHN3aXRjaCAobm9kZS50eXBlKSB7XG4gICAgY2FzZSBcIkFueVR5cGVBbm5vdGF0aW9uXCI6XG4gICAgY2FzZSBcIkJvb2xlYW5UeXBlQW5ub3RhdGlvblwiOlxuICAgIGNhc2UgXCJOdWxsTGl0ZXJhbFR5cGVBbm5vdGF0aW9uXCI6XG4gICAgY2FzZSBcIk1peGVkVHlwZUFubm90YXRpb25cIjpcbiAgICBjYXNlIFwiRW1wdHlUeXBlQW5ub3RhdGlvblwiOlxuICAgIGNhc2UgXCJOdW1iZXJUeXBlQW5ub3RhdGlvblwiOlxuICAgIGNhc2UgXCJTdHJpbmdUeXBlQW5ub3RhdGlvblwiOlxuICAgIGNhc2UgXCJTeW1ib2xUeXBlQW5ub3RhdGlvblwiOlxuICAgIGNhc2UgXCJUaGlzVHlwZUFubm90YXRpb25cIjpcbiAgICBjYXNlIFwiVm9pZFR5cGVBbm5vdGF0aW9uXCI6XG4gICAgICBicmVhaztcbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHJldHVybiBvcHRzID09IG51bGwgfHwgKDAsIF9zaGFsbG93RXF1YWwuZGVmYXVsdCkobm9kZSwgb3B0cyk7XG59XG5mdW5jdGlvbiBpc0Zsb3dEZWNsYXJhdGlvbihub2RlLCBvcHRzKSB7XG4gIGlmICghbm9kZSkgcmV0dXJuIGZhbHNlO1xuICBzd2l0Y2ggKG5vZGUudHlwZSkge1xuICAgIGNhc2UgXCJEZWNsYXJlQ2xhc3NcIjpcbiAgICBjYXNlIFwiRGVjbGFyZUZ1bmN0aW9uXCI6XG4gICAgY2FzZSBcIkRlY2xhcmVJbnRlcmZhY2VcIjpcbiAgICBjYXNlIFwiRGVjbGFyZU1vZHVsZVwiOlxuICAgIGNhc2UgXCJEZWNsYXJlTW9kdWxlRXhwb3J0c1wiOlxuICAgIGNhc2UgXCJEZWNsYXJlVHlwZUFsaWFzXCI6XG4gICAgY2FzZSBcIkRlY2xhcmVPcGFxdWVUeXBlXCI6XG4gICAgY2FzZSBcIkRlY2xhcmVWYXJpYWJsZVwiOlxuICAgIGNhc2UgXCJEZWNsYXJlRXhwb3J0RGVjbGFyYXRpb25cIjpcbiAgICBjYXNlIFwiRGVjbGFyZUV4cG9ydEFsbERlY2xhcmF0aW9uXCI6XG4gICAgY2FzZSBcIkludGVyZmFjZURlY2xhcmF0aW9uXCI6XG4gICAgY2FzZSBcIk9wYXF1ZVR5cGVcIjpcbiAgICBjYXNlIFwiVHlwZUFsaWFzXCI6XG4gICAgICBicmVhaztcbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHJldHVybiBvcHRzID09IG51bGwgfHwgKDAsIF9zaGFsbG93RXF1YWwuZGVmYXVsdCkobm9kZSwgb3B0cyk7XG59XG5mdW5jdGlvbiBpc0Zsb3dQcmVkaWNhdGUobm9kZSwgb3B0cykge1xuICBpZiAoIW5vZGUpIHJldHVybiBmYWxzZTtcbiAgc3dpdGNoIChub2RlLnR5cGUpIHtcbiAgICBjYXNlIFwiRGVjbGFyZWRQcmVkaWNhdGVcIjpcbiAgICBjYXNlIFwiSW5mZXJyZWRQcmVkaWNhdGVcIjpcbiAgICAgIGJyZWFrO1xuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgcmV0dXJuIG9wdHMgPT0gbnVsbCB8fCAoMCwgX3NoYWxsb3dFcXVhbC5kZWZhdWx0KShub2RlLCBvcHRzKTtcbn1cbmZ1bmN0aW9uIGlzRW51bUJvZHkobm9kZSwgb3B0cykge1xuICBpZiAoIW5vZGUpIHJldHVybiBmYWxzZTtcbiAgc3dpdGNoIChub2RlLnR5cGUpIHtcbiAgICBjYXNlIFwiRW51bUJvb2xlYW5Cb2R5XCI6XG4gICAgY2FzZSBcIkVudW1OdW1iZXJCb2R5XCI6XG4gICAgY2FzZSBcIkVudW1TdHJpbmdCb2R5XCI6XG4gICAgY2FzZSBcIkVudW1TeW1ib2xCb2R5XCI6XG4gICAgICBicmVhaztcbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHJldHVybiBvcHRzID09IG51bGwgfHwgKDAsIF9zaGFsbG93RXF1YWwuZGVmYXVsdCkobm9kZSwgb3B0cyk7XG59XG5mdW5jdGlvbiBpc0VudW1NZW1iZXIobm9kZSwgb3B0cykge1xuICBpZiAoIW5vZGUpIHJldHVybiBmYWxzZTtcbiAgc3dpdGNoIChub2RlLnR5cGUpIHtcbiAgICBjYXNlIFwiRW51bUJvb2xlYW5NZW1iZXJcIjpcbiAgICBjYXNlIFwiRW51bU51bWJlck1lbWJlclwiOlxuICAgIGNhc2UgXCJFbnVtU3RyaW5nTWVtYmVyXCI6XG4gICAgY2FzZSBcIkVudW1EZWZhdWx0ZWRNZW1iZXJcIjpcbiAgICAgIGJyZWFrO1xuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgcmV0dXJuIG9wdHMgPT0gbnVsbCB8fCAoMCwgX3NoYWxsb3dFcXVhbC5kZWZhdWx0KShub2RlLCBvcHRzKTtcbn1cbmZ1bmN0aW9uIGlzSlNYKG5vZGUsIG9wdHMpIHtcbiAgaWYgKCFub2RlKSByZXR1cm4gZmFsc2U7XG4gIHN3aXRjaCAobm9kZS50eXBlKSB7XG4gICAgY2FzZSBcIkpTWEF0dHJpYnV0ZVwiOlxuICAgIGNhc2UgXCJKU1hDbG9zaW5nRWxlbWVudFwiOlxuICAgIGNhc2UgXCJKU1hFbGVtZW50XCI6XG4gICAgY2FzZSBcIkpTWEVtcHR5RXhwcmVzc2lvblwiOlxuICAgIGNhc2UgXCJKU1hFeHByZXNzaW9uQ29udGFpbmVyXCI6XG4gICAgY2FzZSBcIkpTWFNwcmVhZENoaWxkXCI6XG4gICAgY2FzZSBcIkpTWElkZW50aWZpZXJcIjpcbiAgICBjYXNlIFwiSlNYTWVtYmVyRXhwcmVzc2lvblwiOlxuICAgIGNhc2UgXCJKU1hOYW1lc3BhY2VkTmFtZVwiOlxuICAgIGNhc2UgXCJKU1hPcGVuaW5nRWxlbWVudFwiOlxuICAgIGNhc2UgXCJKU1hTcHJlYWRBdHRyaWJ1dGVcIjpcbiAgICBjYXNlIFwiSlNYVGV4dFwiOlxuICAgIGNhc2UgXCJKU1hGcmFnbWVudFwiOlxuICAgIGNhc2UgXCJKU1hPcGVuaW5nRnJhZ21lbnRcIjpcbiAgICBjYXNlIFwiSlNYQ2xvc2luZ0ZyYWdtZW50XCI6XG4gICAgICBicmVhaztcbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHJldHVybiBvcHRzID09IG51bGwgfHwgKDAsIF9zaGFsbG93RXF1YWwuZGVmYXVsdCkobm9kZSwgb3B0cyk7XG59XG5mdW5jdGlvbiBpc01pc2NlbGxhbmVvdXMobm9kZSwgb3B0cykge1xuICBpZiAoIW5vZGUpIHJldHVybiBmYWxzZTtcbiAgc3dpdGNoIChub2RlLnR5cGUpIHtcbiAgICBjYXNlIFwiTm9vcFwiOlxuICAgIGNhc2UgXCJQbGFjZWhvbGRlclwiOlxuICAgIGNhc2UgXCJWOEludHJpbnNpY0lkZW50aWZpZXJcIjpcbiAgICAgIGJyZWFrO1xuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgcmV0dXJuIG9wdHMgPT0gbnVsbCB8fCAoMCwgX3NoYWxsb3dFcXVhbC5kZWZhdWx0KShub2RlLCBvcHRzKTtcbn1cbmZ1bmN0aW9uIGlzVHlwZVNjcmlwdChub2RlLCBvcHRzKSB7XG4gIGlmICghbm9kZSkgcmV0dXJuIGZhbHNlO1xuICBzd2l0Y2ggKG5vZGUudHlwZSkge1xuICAgIGNhc2UgXCJUU1BhcmFtZXRlclByb3BlcnR5XCI6XG4gICAgY2FzZSBcIlRTRGVjbGFyZUZ1bmN0aW9uXCI6XG4gICAgY2FzZSBcIlRTRGVjbGFyZU1ldGhvZFwiOlxuICAgIGNhc2UgXCJUU1F1YWxpZmllZE5hbWVcIjpcbiAgICBjYXNlIFwiVFNDYWxsU2lnbmF0dXJlRGVjbGFyYXRpb25cIjpcbiAgICBjYXNlIFwiVFNDb25zdHJ1Y3RTaWduYXR1cmVEZWNsYXJhdGlvblwiOlxuICAgIGNhc2UgXCJUU1Byb3BlcnR5U2lnbmF0dXJlXCI6XG4gICAgY2FzZSBcIlRTTWV0aG9kU2lnbmF0dXJlXCI6XG4gICAgY2FzZSBcIlRTSW5kZXhTaWduYXR1cmVcIjpcbiAgICBjYXNlIFwiVFNBbnlLZXl3b3JkXCI6XG4gICAgY2FzZSBcIlRTQm9vbGVhbktleXdvcmRcIjpcbiAgICBjYXNlIFwiVFNCaWdJbnRLZXl3b3JkXCI6XG4gICAgY2FzZSBcIlRTSW50cmluc2ljS2V5d29yZFwiOlxuICAgIGNhc2UgXCJUU05ldmVyS2V5d29yZFwiOlxuICAgIGNhc2UgXCJUU051bGxLZXl3b3JkXCI6XG4gICAgY2FzZSBcIlRTTnVtYmVyS2V5d29yZFwiOlxuICAgIGNhc2UgXCJUU09iamVjdEtleXdvcmRcIjpcbiAgICBjYXNlIFwiVFNTdHJpbmdLZXl3b3JkXCI6XG4gICAgY2FzZSBcIlRTU3ltYm9sS2V5d29yZFwiOlxuICAgIGNhc2UgXCJUU1VuZGVmaW5lZEtleXdvcmRcIjpcbiAgICBjYXNlIFwiVFNVbmtub3duS2V5d29yZFwiOlxuICAgIGNhc2UgXCJUU1ZvaWRLZXl3b3JkXCI6XG4gICAgY2FzZSBcIlRTVGhpc1R5cGVcIjpcbiAgICBjYXNlIFwiVFNGdW5jdGlvblR5cGVcIjpcbiAgICBjYXNlIFwiVFNDb25zdHJ1Y3RvclR5cGVcIjpcbiAgICBjYXNlIFwiVFNUeXBlUmVmZXJlbmNlXCI6XG4gICAgY2FzZSBcIlRTVHlwZVByZWRpY2F0ZVwiOlxuICAgIGNhc2UgXCJUU1R5cGVRdWVyeVwiOlxuICAgIGNhc2UgXCJUU1R5cGVMaXRlcmFsXCI6XG4gICAgY2FzZSBcIlRTQXJyYXlUeXBlXCI6XG4gICAgY2FzZSBcIlRTVHVwbGVUeXBlXCI6XG4gICAgY2FzZSBcIlRTT3B0aW9uYWxUeXBlXCI6XG4gICAgY2FzZSBcIlRTUmVzdFR5cGVcIjpcbiAgICBjYXNlIFwiVFNOYW1lZFR1cGxlTWVtYmVyXCI6XG4gICAgY2FzZSBcIlRTVW5pb25UeXBlXCI6XG4gICAgY2FzZSBcIlRTSW50ZXJzZWN0aW9uVHlwZVwiOlxuICAgIGNhc2UgXCJUU0NvbmRpdGlvbmFsVHlwZVwiOlxuICAgIGNhc2UgXCJUU0luZmVyVHlwZVwiOlxuICAgIGNhc2UgXCJUU1BhcmVudGhlc2l6ZWRUeXBlXCI6XG4gICAgY2FzZSBcIlRTVHlwZU9wZXJhdG9yXCI6XG4gICAgY2FzZSBcIlRTSW5kZXhlZEFjY2Vzc1R5cGVcIjpcbiAgICBjYXNlIFwiVFNNYXBwZWRUeXBlXCI6XG4gICAgY2FzZSBcIlRTVGVtcGxhdGVMaXRlcmFsVHlwZVwiOlxuICAgIGNhc2UgXCJUU0xpdGVyYWxUeXBlXCI6XG4gICAgY2FzZSBcIlRTRXhwcmVzc2lvbldpdGhUeXBlQXJndW1lbnRzXCI6XG4gICAgY2FzZSBcIlRTSW50ZXJmYWNlRGVjbGFyYXRpb25cIjpcbiAgICBjYXNlIFwiVFNJbnRlcmZhY2VCb2R5XCI6XG4gICAgY2FzZSBcIlRTVHlwZUFsaWFzRGVjbGFyYXRpb25cIjpcbiAgICBjYXNlIFwiVFNJbnN0YW50aWF0aW9uRXhwcmVzc2lvblwiOlxuICAgIGNhc2UgXCJUU0FzRXhwcmVzc2lvblwiOlxuICAgIGNhc2UgXCJUU1NhdGlzZmllc0V4cHJlc3Npb25cIjpcbiAgICBjYXNlIFwiVFNUeXBlQXNzZXJ0aW9uXCI6XG4gICAgY2FzZSBcIlRTRW51bUJvZHlcIjpcbiAgICBjYXNlIFwiVFNFbnVtRGVjbGFyYXRpb25cIjpcbiAgICBjYXNlIFwiVFNFbnVtTWVtYmVyXCI6XG4gICAgY2FzZSBcIlRTTW9kdWxlRGVjbGFyYXRpb25cIjpcbiAgICBjYXNlIFwiVFNNb2R1bGVCbG9ja1wiOlxuICAgIGNhc2UgXCJUU0ltcG9ydFR5cGVcIjpcbiAgICBjYXNlIFwiVFNJbXBvcnRFcXVhbHNEZWNsYXJhdGlvblwiOlxuICAgIGNhc2UgXCJUU0V4dGVybmFsTW9kdWxlUmVmZXJlbmNlXCI6XG4gICAgY2FzZSBcIlRTTm9uTnVsbEV4cHJlc3Npb25cIjpcbiAgICBjYXNlIFwiVFNFeHBvcnRBc3NpZ25tZW50XCI6XG4gICAgY2FzZSBcIlRTTmFtZXNwYWNlRXhwb3J0RGVjbGFyYXRpb25cIjpcbiAgICBjYXNlIFwiVFNUeXBlQW5ub3RhdGlvblwiOlxuICAgIGNhc2UgXCJUU1R5cGVQYXJhbWV0ZXJJbnN0YW50aWF0aW9uXCI6XG4gICAgY2FzZSBcIlRTVHlwZVBhcmFtZXRlckRlY2xhcmF0aW9uXCI6XG4gICAgY2FzZSBcIlRTVHlwZVBhcmFtZXRlclwiOlxuICAgICAgYnJlYWs7XG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICByZXR1cm4gb3B0cyA9PSBudWxsIHx8ICgwLCBfc2hhbGxvd0VxdWFsLmRlZmF1bHQpKG5vZGUsIG9wdHMpO1xufVxuZnVuY3Rpb24gaXNUU1R5cGVFbGVtZW50KG5vZGUsIG9wdHMpIHtcbiAgaWYgKCFub2RlKSByZXR1cm4gZmFsc2U7XG4gIHN3aXRjaCAobm9kZS50eXBlKSB7XG4gICAgY2FzZSBcIlRTQ2FsbFNpZ25hdHVyZURlY2xhcmF0aW9uXCI6XG4gICAgY2FzZSBcIlRTQ29uc3RydWN0U2lnbmF0dXJlRGVjbGFyYXRpb25cIjpcbiAgICBjYXNlIFwiVFNQcm9wZXJ0eVNpZ25hdHVyZVwiOlxuICAgIGNhc2UgXCJUU01ldGhvZFNpZ25hdHVyZVwiOlxuICAgIGNhc2UgXCJUU0luZGV4U2lnbmF0dXJlXCI6XG4gICAgICBicmVhaztcbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHJldHVybiBvcHRzID09IG51bGwgfHwgKDAsIF9zaGFsbG93RXF1YWwuZGVmYXVsdCkobm9kZSwgb3B0cyk7XG59XG5mdW5jdGlvbiBpc1RTVHlwZShub2RlLCBvcHRzKSB7XG4gIGlmICghbm9kZSkgcmV0dXJuIGZhbHNlO1xuICBzd2l0Y2ggKG5vZGUudHlwZSkge1xuICAgIGNhc2UgXCJUU0FueUtleXdvcmRcIjpcbiAgICBjYXNlIFwiVFNCb29sZWFuS2V5d29yZFwiOlxuICAgIGNhc2UgXCJUU0JpZ0ludEtleXdvcmRcIjpcbiAgICBjYXNlIFwiVFNJbnRyaW5zaWNLZXl3b3JkXCI6XG4gICAgY2FzZSBcIlRTTmV2ZXJLZXl3b3JkXCI6XG4gICAgY2FzZSBcIlRTTnVsbEtleXdvcmRcIjpcbiAgICBjYXNlIFwiVFNOdW1iZXJLZXl3b3JkXCI6XG4gICAgY2FzZSBcIlRTT2JqZWN0S2V5d29yZFwiOlxuICAgIGNhc2UgXCJUU1N0cmluZ0tleXdvcmRcIjpcbiAgICBjYXNlIFwiVFNTeW1ib2xLZXl3b3JkXCI6XG4gICAgY2FzZSBcIlRTVW5kZWZpbmVkS2V5d29yZFwiOlxuICAgIGNhc2UgXCJUU1Vua25vd25LZXl3b3JkXCI6XG4gICAgY2FzZSBcIlRTVm9pZEtleXdvcmRcIjpcbiAgICBjYXNlIFwiVFNUaGlzVHlwZVwiOlxuICAgIGNhc2UgXCJUU0Z1bmN0aW9uVHlwZVwiOlxuICAgIGNhc2UgXCJUU0NvbnN0cnVjdG9yVHlwZVwiOlxuICAgIGNhc2UgXCJUU1R5cGVSZWZlcmVuY2VcIjpcbiAgICBjYXNlIFwiVFNUeXBlUHJlZGljYXRlXCI6XG4gICAgY2FzZSBcIlRTVHlwZVF1ZXJ5XCI6XG4gICAgY2FzZSBcIlRTVHlwZUxpdGVyYWxcIjpcbiAgICBjYXNlIFwiVFNBcnJheVR5cGVcIjpcbiAgICBjYXNlIFwiVFNUdXBsZVR5cGVcIjpcbiAgICBjYXNlIFwiVFNPcHRpb25hbFR5cGVcIjpcbiAgICBjYXNlIFwiVFNSZXN0VHlwZVwiOlxuICAgIGNhc2UgXCJUU1VuaW9uVHlwZVwiOlxuICAgIGNhc2UgXCJUU0ludGVyc2VjdGlvblR5cGVcIjpcbiAgICBjYXNlIFwiVFNDb25kaXRpb25hbFR5cGVcIjpcbiAgICBjYXNlIFwiVFNJbmZlclR5cGVcIjpcbiAgICBjYXNlIFwiVFNQYXJlbnRoZXNpemVkVHlwZVwiOlxuICAgIGNhc2UgXCJUU1R5cGVPcGVyYXRvclwiOlxuICAgIGNhc2UgXCJUU0luZGV4ZWRBY2Nlc3NUeXBlXCI6XG4gICAgY2FzZSBcIlRTTWFwcGVkVHlwZVwiOlxuICAgIGNhc2UgXCJUU1RlbXBsYXRlTGl0ZXJhbFR5cGVcIjpcbiAgICBjYXNlIFwiVFNMaXRlcmFsVHlwZVwiOlxuICAgIGNhc2UgXCJUU0V4cHJlc3Npb25XaXRoVHlwZUFyZ3VtZW50c1wiOlxuICAgIGNhc2UgXCJUU0ltcG9ydFR5cGVcIjpcbiAgICAgIGJyZWFrO1xuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgcmV0dXJuIG9wdHMgPT0gbnVsbCB8fCAoMCwgX3NoYWxsb3dFcXVhbC5kZWZhdWx0KShub2RlLCBvcHRzKTtcbn1cbmZ1bmN0aW9uIGlzVFNCYXNlVHlwZShub2RlLCBvcHRzKSB7XG4gIGlmICghbm9kZSkgcmV0dXJuIGZhbHNlO1xuICBzd2l0Y2ggKG5vZGUudHlwZSkge1xuICAgIGNhc2UgXCJUU0FueUtleXdvcmRcIjpcbiAgICBjYXNlIFwiVFNCb29sZWFuS2V5d29yZFwiOlxuICAgIGNhc2UgXCJUU0JpZ0ludEtleXdvcmRcIjpcbiAgICBjYXNlIFwiVFNJbnRyaW5zaWNLZXl3b3JkXCI6XG4gICAgY2FzZSBcIlRTTmV2ZXJLZXl3b3JkXCI6XG4gICAgY2FzZSBcIlRTTnVsbEtleXdvcmRcIjpcbiAgICBjYXNlIFwiVFNOdW1iZXJLZXl3b3JkXCI6XG4gICAgY2FzZSBcIlRTT2JqZWN0S2V5d29yZFwiOlxuICAgIGNhc2UgXCJUU1N0cmluZ0tleXdvcmRcIjpcbiAgICBjYXNlIFwiVFNTeW1ib2xLZXl3b3JkXCI6XG4gICAgY2FzZSBcIlRTVW5kZWZpbmVkS2V5d29yZFwiOlxuICAgIGNhc2UgXCJUU1Vua25vd25LZXl3b3JkXCI6XG4gICAgY2FzZSBcIlRTVm9pZEtleXdvcmRcIjpcbiAgICBjYXNlIFwiVFNUaGlzVHlwZVwiOlxuICAgIGNhc2UgXCJUU1RlbXBsYXRlTGl0ZXJhbFR5cGVcIjpcbiAgICBjYXNlIFwiVFNMaXRlcmFsVHlwZVwiOlxuICAgICAgYnJlYWs7XG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICByZXR1cm4gb3B0cyA9PSBudWxsIHx8ICgwLCBfc2hhbGxvd0VxdWFsLmRlZmF1bHQpKG5vZGUsIG9wdHMpO1xufVxuZnVuY3Rpb24gaXNOdW1iZXJMaXRlcmFsKG5vZGUsIG9wdHMpIHtcbiAgKDAsIF9kZXByZWNhdGlvbldhcm5pbmcuZGVmYXVsdCkoXCJpc051bWJlckxpdGVyYWxcIiwgXCJpc051bWVyaWNMaXRlcmFsXCIpO1xuICBpZiAoIW5vZGUpIHJldHVybiBmYWxzZTtcbiAgaWYgKG5vZGUudHlwZSAhPT0gXCJOdW1iZXJMaXRlcmFsXCIpIHJldHVybiBmYWxzZTtcbiAgcmV0dXJuIG9wdHMgPT0gbnVsbCB8fCAoMCwgX3NoYWxsb3dFcXVhbC5kZWZhdWx0KShub2RlLCBvcHRzKTtcbn1cbmZ1bmN0aW9uIGlzUmVnZXhMaXRlcmFsKG5vZGUsIG9wdHMpIHtcbiAgKDAsIF9kZXByZWNhdGlvbldhcm5pbmcuZGVmYXVsdCkoXCJpc1JlZ2V4TGl0ZXJhbFwiLCBcImlzUmVnRXhwTGl0ZXJhbFwiKTtcbiAgaWYgKCFub2RlKSByZXR1cm4gZmFsc2U7XG4gIGlmIChub2RlLnR5cGUgIT09IFwiUmVnZXhMaXRlcmFsXCIpIHJldHVybiBmYWxzZTtcbiAgcmV0dXJuIG9wdHMgPT0gbnVsbCB8fCAoMCwgX3NoYWxsb3dFcXVhbC5kZWZhdWx0KShub2RlLCBvcHRzKTtcbn1cbmZ1bmN0aW9uIGlzUmVzdFByb3BlcnR5KG5vZGUsIG9wdHMpIHtcbiAgKDAsIF9kZXByZWNhdGlvbldhcm5pbmcuZGVmYXVsdCkoXCJpc1Jlc3RQcm9wZXJ0eVwiLCBcImlzUmVzdEVsZW1lbnRcIik7XG4gIGlmICghbm9kZSkgcmV0dXJuIGZhbHNlO1xuICBpZiAobm9kZS50eXBlICE9PSBcIlJlc3RQcm9wZXJ0eVwiKSByZXR1cm4gZmFsc2U7XG4gIHJldHVybiBvcHRzID09IG51bGwgfHwgKDAsIF9zaGFsbG93RXF1YWwuZGVmYXVsdCkobm9kZSwgb3B0cyk7XG59XG5mdW5jdGlvbiBpc1NwcmVhZFByb3BlcnR5KG5vZGUsIG9wdHMpIHtcbiAgKDAsIF9kZXByZWNhdGlvbldhcm5pbmcuZGVmYXVsdCkoXCJpc1NwcmVhZFByb3BlcnR5XCIsIFwiaXNTcHJlYWRFbGVtZW50XCIpO1xuICBpZiAoIW5vZGUpIHJldHVybiBmYWxzZTtcbiAgaWYgKG5vZGUudHlwZSAhPT0gXCJTcHJlYWRQcm9wZXJ0eVwiKSByZXR1cm4gZmFsc2U7XG4gIHJldHVybiBvcHRzID09IG51bGwgfHwgKDAsIF9zaGFsbG93RXF1YWwuZGVmYXVsdCkobm9kZSwgb3B0cyk7XG59XG5mdW5jdGlvbiBpc01vZHVsZURlY2xhcmF0aW9uKG5vZGUsIG9wdHMpIHtcbiAgKDAsIF9kZXByZWNhdGlvbldhcm5pbmcuZGVmYXVsdCkoXCJpc01vZHVsZURlY2xhcmF0aW9uXCIsIFwiaXNJbXBvcnRPckV4cG9ydERlY2xhcmF0aW9uXCIpO1xuICByZXR1cm4gaXNJbXBvcnRPckV4cG9ydERlY2xhcmF0aW9uKG5vZGUsIG9wdHMpO1xufVxuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXBcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@babel/types/lib/validators/generated/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@babel/types/lib/validators/is.js":
/*!********************************************************!*\
  !*** ./node_modules/@babel/types/lib/validators/is.js ***!
  \********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports[\"default\"] = is;\nvar _shallowEqual = __webpack_require__(/*! ../utils/shallowEqual.js */ \"(ssr)/./node_modules/@babel/types/lib/utils/shallowEqual.js\");\nvar _isType = __webpack_require__(/*! ./isType.js */ \"(ssr)/./node_modules/@babel/types/lib/validators/isType.js\");\nvar _isPlaceholderType = __webpack_require__(/*! ./isPlaceholderType.js */ \"(ssr)/./node_modules/@babel/types/lib/validators/isPlaceholderType.js\");\nvar _index = __webpack_require__(/*! ../definitions/index.js */ \"(ssr)/./node_modules/@babel/types/lib/definitions/index.js\");\nfunction is(type, node, opts) {\n  if (!node) return false;\n  const matches = (0, _isType.default)(node.type, type);\n  if (!matches) {\n    if (!opts && node.type === \"Placeholder\" && type in _index.FLIPPED_ALIAS_KEYS) {\n      return (0, _isPlaceholderType.default)(node.expectedNode, type);\n    }\n    return false;\n  }\n  if (opts === undefined) {\n    return true;\n  } else {\n    return (0, _shallowEqual.default)(node, opts);\n  }\n}\n\n//# sourceMappingURL=is.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGJhYmVsL3R5cGVzL2xpYi92YWxpZGF0b3JzL2lzLmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViLDhDQUE2QztBQUM3QztBQUNBLENBQUMsRUFBQztBQUNGLGtCQUFlO0FBQ2Ysb0JBQW9CLG1CQUFPLENBQUMsNkZBQTBCO0FBQ3RELGNBQWMsbUJBQU8sQ0FBQywrRUFBYTtBQUNuQyx5QkFBeUIsbUJBQU8sQ0FBQyxxR0FBd0I7QUFDekQsYUFBYSxtQkFBTyxDQUFDLDJGQUF5QjtBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTs7QUFFQSIsInNvdXJjZXMiOlsid2VicGFjazovL3JlcG8tdmlzdWFsaXplci8uL25vZGVfbW9kdWxlcy9AYmFiZWwvdHlwZXMvbGliL3ZhbGlkYXRvcnMvaXMuanM/NjkzZiJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuZGVmYXVsdCA9IGlzO1xudmFyIF9zaGFsbG93RXF1YWwgPSByZXF1aXJlKFwiLi4vdXRpbHMvc2hhbGxvd0VxdWFsLmpzXCIpO1xudmFyIF9pc1R5cGUgPSByZXF1aXJlKFwiLi9pc1R5cGUuanNcIik7XG52YXIgX2lzUGxhY2Vob2xkZXJUeXBlID0gcmVxdWlyZShcIi4vaXNQbGFjZWhvbGRlclR5cGUuanNcIik7XG52YXIgX2luZGV4ID0gcmVxdWlyZShcIi4uL2RlZmluaXRpb25zL2luZGV4LmpzXCIpO1xuZnVuY3Rpb24gaXModHlwZSwgbm9kZSwgb3B0cykge1xuICBpZiAoIW5vZGUpIHJldHVybiBmYWxzZTtcbiAgY29uc3QgbWF0Y2hlcyA9ICgwLCBfaXNUeXBlLmRlZmF1bHQpKG5vZGUudHlwZSwgdHlwZSk7XG4gIGlmICghbWF0Y2hlcykge1xuICAgIGlmICghb3B0cyAmJiBub2RlLnR5cGUgPT09IFwiUGxhY2Vob2xkZXJcIiAmJiB0eXBlIGluIF9pbmRleC5GTElQUEVEX0FMSUFTX0tFWVMpIHtcbiAgICAgIHJldHVybiAoMCwgX2lzUGxhY2Vob2xkZXJUeXBlLmRlZmF1bHQpKG5vZGUuZXhwZWN0ZWROb2RlLCB0eXBlKTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGlmIChvcHRzID09PSB1bmRlZmluZWQpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gKDAsIF9zaGFsbG93RXF1YWwuZGVmYXVsdCkobm9kZSwgb3B0cyk7XG4gIH1cbn1cblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aXMuanMubWFwXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@babel/types/lib/validators/is.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@babel/types/lib/validators/isBinding.js":
/*!***************************************************************!*\
  !*** ./node_modules/@babel/types/lib/validators/isBinding.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports[\"default\"] = isBinding;\nvar _getBindingIdentifiers = __webpack_require__(/*! ../retrievers/getBindingIdentifiers.js */ \"(ssr)/./node_modules/@babel/types/lib/retrievers/getBindingIdentifiers.js\");\nfunction isBinding(node, parent, grandparent) {\n  if (grandparent && node.type === \"Identifier\" && parent.type === \"ObjectProperty\" && grandparent.type === \"ObjectExpression\") {\n    return false;\n  }\n  const keys = _getBindingIdentifiers.default.keys[parent.type];\n  if (keys) {\n    for (let i = 0; i < keys.length; i++) {\n      const key = keys[i];\n      const val = parent[key];\n      if (Array.isArray(val)) {\n        if (val.includes(node)) return true;\n      } else {\n        if (val === node) return true;\n      }\n    }\n  }\n  return false;\n}\n\n//# sourceMappingURL=isBinding.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGJhYmVsL3R5cGVzL2xpYi92YWxpZGF0b3JzL2lzQmluZGluZy5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYiw4Q0FBNkM7QUFDN0M7QUFDQSxDQUFDLEVBQUM7QUFDRixrQkFBZTtBQUNmLDZCQUE2QixtQkFBTyxDQUFDLHlIQUF3QztBQUM3RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsaUJBQWlCO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSIsInNvdXJjZXMiOlsid2VicGFjazovL3JlcG8tdmlzdWFsaXplci8uL25vZGVfbW9kdWxlcy9AYmFiZWwvdHlwZXMvbGliL3ZhbGlkYXRvcnMvaXNCaW5kaW5nLmpzP2Q1N2UiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLmRlZmF1bHQgPSBpc0JpbmRpbmc7XG52YXIgX2dldEJpbmRpbmdJZGVudGlmaWVycyA9IHJlcXVpcmUoXCIuLi9yZXRyaWV2ZXJzL2dldEJpbmRpbmdJZGVudGlmaWVycy5qc1wiKTtcbmZ1bmN0aW9uIGlzQmluZGluZyhub2RlLCBwYXJlbnQsIGdyYW5kcGFyZW50KSB7XG4gIGlmIChncmFuZHBhcmVudCAmJiBub2RlLnR5cGUgPT09IFwiSWRlbnRpZmllclwiICYmIHBhcmVudC50eXBlID09PSBcIk9iamVjdFByb3BlcnR5XCIgJiYgZ3JhbmRwYXJlbnQudHlwZSA9PT0gXCJPYmplY3RFeHByZXNzaW9uXCIpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgY29uc3Qga2V5cyA9IF9nZXRCaW5kaW5nSWRlbnRpZmllcnMuZGVmYXVsdC5rZXlzW3BhcmVudC50eXBlXTtcbiAgaWYgKGtleXMpIHtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvbnN0IGtleSA9IGtleXNbaV07XG4gICAgICBjb25zdCB2YWwgPSBwYXJlbnRba2V5XTtcbiAgICAgIGlmIChBcnJheS5pc0FycmF5KHZhbCkpIHtcbiAgICAgICAgaWYgKHZhbC5pbmNsdWRlcyhub2RlKSkgcmV0dXJuIHRydWU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAodmFsID09PSBub2RlKSByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1pc0JpbmRpbmcuanMubWFwXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@babel/types/lib/validators/isBinding.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@babel/types/lib/validators/isBlockScoped.js":
/*!*******************************************************************!*\
  !*** ./node_modules/@babel/types/lib/validators/isBlockScoped.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports[\"default\"] = isBlockScoped;\nvar _index = __webpack_require__(/*! ./generated/index.js */ \"(ssr)/./node_modules/@babel/types/lib/validators/generated/index.js\");\nvar _isLet = __webpack_require__(/*! ./isLet.js */ \"(ssr)/./node_modules/@babel/types/lib/validators/isLet.js\");\nfunction isBlockScoped(node) {\n  return (0, _index.isFunctionDeclaration)(node) || (0, _index.isClassDeclaration)(node) || (0, _isLet.default)(node);\n}\n\n//# sourceMappingURL=isBlockScoped.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGJhYmVsL3R5cGVzL2xpYi92YWxpZGF0b3JzL2lzQmxvY2tTY29wZWQuanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWIsOENBQTZDO0FBQzdDO0FBQ0EsQ0FBQyxFQUFDO0FBQ0Ysa0JBQWU7QUFDZixhQUFhLG1CQUFPLENBQUMsaUdBQXNCO0FBQzNDLGFBQWEsbUJBQU8sQ0FBQyw2RUFBWTtBQUNqQztBQUNBO0FBQ0E7O0FBRUEiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9yZXBvLXZpc3VhbGl6ZXIvLi9ub2RlX21vZHVsZXMvQGJhYmVsL3R5cGVzL2xpYi92YWxpZGF0b3JzL2lzQmxvY2tTY29wZWQuanM/NjEyYiJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuZGVmYXVsdCA9IGlzQmxvY2tTY29wZWQ7XG52YXIgX2luZGV4ID0gcmVxdWlyZShcIi4vZ2VuZXJhdGVkL2luZGV4LmpzXCIpO1xudmFyIF9pc0xldCA9IHJlcXVpcmUoXCIuL2lzTGV0LmpzXCIpO1xuZnVuY3Rpb24gaXNCbG9ja1Njb3BlZChub2RlKSB7XG4gIHJldHVybiAoMCwgX2luZGV4LmlzRnVuY3Rpb25EZWNsYXJhdGlvbikobm9kZSkgfHwgKDAsIF9pbmRleC5pc0NsYXNzRGVjbGFyYXRpb24pKG5vZGUpIHx8ICgwLCBfaXNMZXQuZGVmYXVsdCkobm9kZSk7XG59XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWlzQmxvY2tTY29wZWQuanMubWFwXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@babel/types/lib/validators/isBlockScoped.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@babel/types/lib/validators/isImmutable.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@babel/types/lib/validators/isImmutable.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports[\"default\"] = isImmutable;\nvar _isType = __webpack_require__(/*! ./isType.js */ \"(ssr)/./node_modules/@babel/types/lib/validators/isType.js\");\nvar _index = __webpack_require__(/*! ./generated/index.js */ \"(ssr)/./node_modules/@babel/types/lib/validators/generated/index.js\");\nfunction isImmutable(node) {\n  if ((0, _isType.default)(node.type, \"Immutable\")) return true;\n  if ((0, _index.isIdentifier)(node)) {\n    if (node.name === \"undefined\") {\n      return true;\n    } else {\n      return false;\n    }\n  }\n  return false;\n}\n\n//# sourceMappingURL=isImmutable.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGJhYmVsL3R5cGVzL2xpYi92YWxpZGF0b3JzL2lzSW1tdXRhYmxlLmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViLDhDQUE2QztBQUM3QztBQUNBLENBQUMsRUFBQztBQUNGLGtCQUFlO0FBQ2YsY0FBYyxtQkFBTyxDQUFDLCtFQUFhO0FBQ25DLGFBQWEsbUJBQU8sQ0FBQyxpR0FBc0I7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcmVwby12aXN1YWxpemVyLy4vbm9kZV9tb2R1bGVzL0BiYWJlbC90eXBlcy9saWIvdmFsaWRhdG9ycy9pc0ltbXV0YWJsZS5qcz9iZGNmIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5kZWZhdWx0ID0gaXNJbW11dGFibGU7XG52YXIgX2lzVHlwZSA9IHJlcXVpcmUoXCIuL2lzVHlwZS5qc1wiKTtcbnZhciBfaW5kZXggPSByZXF1aXJlKFwiLi9nZW5lcmF0ZWQvaW5kZXguanNcIik7XG5mdW5jdGlvbiBpc0ltbXV0YWJsZShub2RlKSB7XG4gIGlmICgoMCwgX2lzVHlwZS5kZWZhdWx0KShub2RlLnR5cGUsIFwiSW1tdXRhYmxlXCIpKSByZXR1cm4gdHJ1ZTtcbiAgaWYgKCgwLCBfaW5kZXguaXNJZGVudGlmaWVyKShub2RlKSkge1xuICAgIGlmIChub2RlLm5hbWUgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG4gIHJldHVybiBmYWxzZTtcbn1cblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aXNJbW11dGFibGUuanMubWFwXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@babel/types/lib/validators/isImmutable.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@babel/types/lib/validators/isLet.js":
/*!***********************************************************!*\
  !*** ./node_modules/@babel/types/lib/validators/isLet.js ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports[\"default\"] = isLet;\nvar _index = __webpack_require__(/*! ./generated/index.js */ \"(ssr)/./node_modules/@babel/types/lib/validators/generated/index.js\");\nvar BLOCK_SCOPED_SYMBOL = Symbol.for(\"var used to be block scoped\");\nfunction isLet(node) {\n  return (0, _index.isVariableDeclaration)(node) && (node.kind !== \"var\" || node[BLOCK_SCOPED_SYMBOL]);\n}\n\n//# sourceMappingURL=isLet.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGJhYmVsL3R5cGVzL2xpYi92YWxpZGF0b3JzL2lzTGV0LmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViLDhDQUE2QztBQUM3QztBQUNBLENBQUMsRUFBQztBQUNGLGtCQUFlO0FBQ2YsYUFBYSxtQkFBTyxDQUFDLGlHQUFzQjtBQUMzQztBQUNBO0FBQ0E7QUFDQTs7QUFFQSIsInNvdXJjZXMiOlsid2VicGFjazovL3JlcG8tdmlzdWFsaXplci8uL25vZGVfbW9kdWxlcy9AYmFiZWwvdHlwZXMvbGliL3ZhbGlkYXRvcnMvaXNMZXQuanM/OWQwMyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuZGVmYXVsdCA9IGlzTGV0O1xudmFyIF9pbmRleCA9IHJlcXVpcmUoXCIuL2dlbmVyYXRlZC9pbmRleC5qc1wiKTtcbnZhciBCTE9DS19TQ09QRURfU1lNQk9MID0gU3ltYm9sLmZvcihcInZhciB1c2VkIHRvIGJlIGJsb2NrIHNjb3BlZFwiKTtcbmZ1bmN0aW9uIGlzTGV0KG5vZGUpIHtcbiAgcmV0dXJuICgwLCBfaW5kZXguaXNWYXJpYWJsZURlY2xhcmF0aW9uKShub2RlKSAmJiAobm9kZS5raW5kICE9PSBcInZhclwiIHx8IG5vZGVbQkxPQ0tfU0NPUEVEX1NZTUJPTF0pO1xufVxuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1pc0xldC5qcy5tYXBcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@babel/types/lib/validators/isLet.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@babel/types/lib/validators/isNode.js":
/*!************************************************************!*\
  !*** ./node_modules/@babel/types/lib/validators/isNode.js ***!
  \************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports[\"default\"] = isNode;\nvar _index = __webpack_require__(/*! ../definitions/index.js */ \"(ssr)/./node_modules/@babel/types/lib/definitions/index.js\");\nfunction isNode(node) {\n  return !!(node && _index.VISITOR_KEYS[node.type]);\n}\n\n//# sourceMappingURL=isNode.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGJhYmVsL3R5cGVzL2xpYi92YWxpZGF0b3JzL2lzTm9kZS5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYiw4Q0FBNkM7QUFDN0M7QUFDQSxDQUFDLEVBQUM7QUFDRixrQkFBZTtBQUNmLGFBQWEsbUJBQU8sQ0FBQywyRkFBeUI7QUFDOUM7QUFDQTtBQUNBOztBQUVBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcmVwby12aXN1YWxpemVyLy4vbm9kZV9tb2R1bGVzL0BiYWJlbC90eXBlcy9saWIvdmFsaWRhdG9ycy9pc05vZGUuanM/YzM1MiJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuZGVmYXVsdCA9IGlzTm9kZTtcbnZhciBfaW5kZXggPSByZXF1aXJlKFwiLi4vZGVmaW5pdGlvbnMvaW5kZXguanNcIik7XG5mdW5jdGlvbiBpc05vZGUobm9kZSkge1xuICByZXR1cm4gISEobm9kZSAmJiBfaW5kZXguVklTSVRPUl9LRVlTW25vZGUudHlwZV0pO1xufVxuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1pc05vZGUuanMubWFwXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@babel/types/lib/validators/isNode.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@babel/types/lib/validators/isNodesEquivalent.js":
/*!***********************************************************************!*\
  !*** ./node_modules/@babel/types/lib/validators/isNodesEquivalent.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports[\"default\"] = isNodesEquivalent;\nvar _index = __webpack_require__(/*! ../definitions/index.js */ \"(ssr)/./node_modules/@babel/types/lib/definitions/index.js\");\nfunction isNodesEquivalent(a, b) {\n  if (typeof a !== \"object\" || typeof b !== \"object\" || a == null || b == null) {\n    return a === b;\n  }\n  if (a.type !== b.type) {\n    return false;\n  }\n  const fields = Object.keys(_index.NODE_FIELDS[a.type] || a.type);\n  const visitorKeys = _index.VISITOR_KEYS[a.type];\n  for (const field of fields) {\n    const val_a = a[field];\n    const val_b = b[field];\n    if (typeof val_a !== typeof val_b) {\n      return false;\n    }\n    if (val_a == null && val_b == null) {\n      continue;\n    } else if (val_a == null || val_b == null) {\n      return false;\n    }\n    if (Array.isArray(val_a)) {\n      if (!Array.isArray(val_b)) {\n        return false;\n      }\n      if (val_a.length !== val_b.length) {\n        return false;\n      }\n      for (let i = 0; i < val_a.length; i++) {\n        if (!isNodesEquivalent(val_a[i], val_b[i])) {\n          return false;\n        }\n      }\n      continue;\n    }\n    if (typeof val_a === \"object\" && !(visitorKeys != null && visitorKeys.includes(field))) {\n      for (const key of Object.keys(val_a)) {\n        if (val_a[key] !== val_b[key]) {\n          return false;\n        }\n      }\n      continue;\n    }\n    if (!isNodesEquivalent(val_a, val_b)) {\n      return false;\n    }\n  }\n  return true;\n}\n\n//# sourceMappingURL=isNodesEquivalent.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGJhYmVsL3R5cGVzL2xpYi92YWxpZGF0b3JzL2lzTm9kZXNFcXVpdmFsZW50LmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViLDhDQUE2QztBQUM3QztBQUNBLENBQUMsRUFBQztBQUNGLGtCQUFlO0FBQ2YsYUFBYSxtQkFBTyxDQUFDLDJGQUF5QjtBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixrQkFBa0I7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSIsInNvdXJjZXMiOlsid2VicGFjazovL3JlcG8tdmlzdWFsaXplci8uL25vZGVfbW9kdWxlcy9AYmFiZWwvdHlwZXMvbGliL3ZhbGlkYXRvcnMvaXNOb2Rlc0VxdWl2YWxlbnQuanM/N2ZlZCJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuZGVmYXVsdCA9IGlzTm9kZXNFcXVpdmFsZW50O1xudmFyIF9pbmRleCA9IHJlcXVpcmUoXCIuLi9kZWZpbml0aW9ucy9pbmRleC5qc1wiKTtcbmZ1bmN0aW9uIGlzTm9kZXNFcXVpdmFsZW50KGEsIGIpIHtcbiAgaWYgKHR5cGVvZiBhICE9PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBiICE9PSBcIm9iamVjdFwiIHx8IGEgPT0gbnVsbCB8fCBiID09IG51bGwpIHtcbiAgICByZXR1cm4gYSA9PT0gYjtcbiAgfVxuICBpZiAoYS50eXBlICE9PSBiLnR5cGUpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgY29uc3QgZmllbGRzID0gT2JqZWN0LmtleXMoX2luZGV4Lk5PREVfRklFTERTW2EudHlwZV0gfHwgYS50eXBlKTtcbiAgY29uc3QgdmlzaXRvcktleXMgPSBfaW5kZXguVklTSVRPUl9LRVlTW2EudHlwZV07XG4gIGZvciAoY29uc3QgZmllbGQgb2YgZmllbGRzKSB7XG4gICAgY29uc3QgdmFsX2EgPSBhW2ZpZWxkXTtcbiAgICBjb25zdCB2YWxfYiA9IGJbZmllbGRdO1xuICAgIGlmICh0eXBlb2YgdmFsX2EgIT09IHR5cGVvZiB2YWxfYikge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBpZiAodmFsX2EgPT0gbnVsbCAmJiB2YWxfYiA9PSBudWxsKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9IGVsc2UgaWYgKHZhbF9hID09IG51bGwgfHwgdmFsX2IgPT0gbnVsbCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBpZiAoQXJyYXkuaXNBcnJheSh2YWxfYSkpIHtcbiAgICAgIGlmICghQXJyYXkuaXNBcnJheSh2YWxfYikpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgaWYgKHZhbF9hLmxlbmd0aCAhPT0gdmFsX2IubGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdmFsX2EubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKCFpc05vZGVzRXF1aXZhbGVudCh2YWxfYVtpXSwgdmFsX2JbaV0pKSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiB2YWxfYSA9PT0gXCJvYmplY3RcIiAmJiAhKHZpc2l0b3JLZXlzICE9IG51bGwgJiYgdmlzaXRvcktleXMuaW5jbHVkZXMoZmllbGQpKSkge1xuICAgICAgZm9yIChjb25zdCBrZXkgb2YgT2JqZWN0LmtleXModmFsX2EpKSB7XG4gICAgICAgIGlmICh2YWxfYVtrZXldICE9PSB2YWxfYltrZXldKSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgaWYgKCFpc05vZGVzRXF1aXZhbGVudCh2YWxfYSwgdmFsX2IpKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG4gIHJldHVybiB0cnVlO1xufVxuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1pc05vZGVzRXF1aXZhbGVudC5qcy5tYXBcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@babel/types/lib/validators/isNodesEquivalent.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@babel/types/lib/validators/isPlaceholderType.js":
/*!***********************************************************************!*\
  !*** ./node_modules/@babel/types/lib/validators/isPlaceholderType.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports[\"default\"] = isPlaceholderType;\nvar _index = __webpack_require__(/*! ../definitions/index.js */ \"(ssr)/./node_modules/@babel/types/lib/definitions/index.js\");\nfunction isPlaceholderType(placeholderType, targetType) {\n  if (placeholderType === targetType) return true;\n  const aliases = _index.PLACEHOLDERS_ALIAS[placeholderType];\n  if (aliases != null && aliases.includes(targetType)) return true;\n  return false;\n}\n\n//# sourceMappingURL=isPlaceholderType.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGJhYmVsL3R5cGVzL2xpYi92YWxpZGF0b3JzL2lzUGxhY2Vob2xkZXJUeXBlLmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViLDhDQUE2QztBQUM3QztBQUNBLENBQUMsRUFBQztBQUNGLGtCQUFlO0FBQ2YsYUFBYSxtQkFBTyxDQUFDLDJGQUF5QjtBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9yZXBvLXZpc3VhbGl6ZXIvLi9ub2RlX21vZHVsZXMvQGJhYmVsL3R5cGVzL2xpYi92YWxpZGF0b3JzL2lzUGxhY2Vob2xkZXJUeXBlLmpzPzM3N2YiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLmRlZmF1bHQgPSBpc1BsYWNlaG9sZGVyVHlwZTtcbnZhciBfaW5kZXggPSByZXF1aXJlKFwiLi4vZGVmaW5pdGlvbnMvaW5kZXguanNcIik7XG5mdW5jdGlvbiBpc1BsYWNlaG9sZGVyVHlwZShwbGFjZWhvbGRlclR5cGUsIHRhcmdldFR5cGUpIHtcbiAgaWYgKHBsYWNlaG9sZGVyVHlwZSA9PT0gdGFyZ2V0VHlwZSkgcmV0dXJuIHRydWU7XG4gIGNvbnN0IGFsaWFzZXMgPSBfaW5kZXguUExBQ0VIT0xERVJTX0FMSUFTW3BsYWNlaG9sZGVyVHlwZV07XG4gIGlmIChhbGlhc2VzICE9IG51bGwgJiYgYWxpYXNlcy5pbmNsdWRlcyh0YXJnZXRUeXBlKSkgcmV0dXJuIHRydWU7XG4gIHJldHVybiBmYWxzZTtcbn1cblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aXNQbGFjZWhvbGRlclR5cGUuanMubWFwXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@babel/types/lib/validators/isPlaceholderType.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@babel/types/lib/validators/isReferenced.js":
/*!******************************************************************!*\
  !*** ./node_modules/@babel/types/lib/validators/isReferenced.js ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports[\"default\"] = isReferenced;\nfunction isReferenced(node, parent, grandparent) {\n  switch (parent.type) {\n    case \"MemberExpression\":\n    case \"OptionalMemberExpression\":\n      if (parent.property === node) {\n        return !!parent.computed;\n      }\n      return parent.object === node;\n    case \"JSXMemberExpression\":\n      return parent.object === node;\n    case \"VariableDeclarator\":\n      return parent.init === node;\n    case \"ArrowFunctionExpression\":\n      return parent.body === node;\n    case \"PrivateName\":\n      return false;\n    case \"ClassMethod\":\n    case \"ClassPrivateMethod\":\n    case \"ObjectMethod\":\n      if (parent.key === node) {\n        return !!parent.computed;\n      }\n      return false;\n    case \"ObjectProperty\":\n      if (parent.key === node) {\n        return !!parent.computed;\n      }\n      return (grandparent == null ? void 0 : grandparent.type) !== \"ObjectPattern\";\n    case \"ClassProperty\":\n    case \"ClassAccessorProperty\":\n      if (parent.key === node) {\n        return !!parent.computed;\n      }\n      return true;\n    case \"ClassPrivateProperty\":\n      return parent.key !== node;\n    case \"ClassDeclaration\":\n    case \"ClassExpression\":\n      return parent.superClass === node;\n    case \"AssignmentExpression\":\n      return parent.right === node;\n    case \"AssignmentPattern\":\n      return parent.right === node;\n    case \"LabeledStatement\":\n      return false;\n    case \"CatchClause\":\n      return false;\n    case \"RestElement\":\n      return false;\n    case \"BreakStatement\":\n    case \"ContinueStatement\":\n      return false;\n    case \"FunctionDeclaration\":\n    case \"FunctionExpression\":\n      return false;\n    case \"ExportNamespaceSpecifier\":\n    case \"ExportDefaultSpecifier\":\n      return false;\n    case \"ExportSpecifier\":\n      if (grandparent != null && grandparent.source) {\n        return false;\n      }\n      return parent.local === node;\n    case \"ImportDefaultSpecifier\":\n    case \"ImportNamespaceSpecifier\":\n    case \"ImportSpecifier\":\n      return false;\n    case \"ImportAttribute\":\n      return false;\n    case \"JSXAttribute\":\n      return false;\n    case \"ObjectPattern\":\n    case \"ArrayPattern\":\n      return false;\n    case \"MetaProperty\":\n      return false;\n    case \"ObjectTypeProperty\":\n      return parent.key !== node;\n    case \"TSEnumMember\":\n      return parent.id !== node;\n    case \"TSPropertySignature\":\n      if (parent.key === node) {\n        return !!parent.computed;\n      }\n      return true;\n  }\n  return true;\n}\n\n//# sourceMappingURL=isReferenced.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGJhYmVsL3R5cGVzL2xpYi92YWxpZGF0b3JzL2lzUmVmZXJlbmNlZC5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYiw4Q0FBNkM7QUFDN0M7QUFDQSxDQUFDLEVBQUM7QUFDRixrQkFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcmVwby12aXN1YWxpemVyLy4vbm9kZV9tb2R1bGVzL0BiYWJlbC90eXBlcy9saWIvdmFsaWRhdG9ycy9pc1JlZmVyZW5jZWQuanM/YjNhOCJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuZGVmYXVsdCA9IGlzUmVmZXJlbmNlZDtcbmZ1bmN0aW9uIGlzUmVmZXJlbmNlZChub2RlLCBwYXJlbnQsIGdyYW5kcGFyZW50KSB7XG4gIHN3aXRjaCAocGFyZW50LnR5cGUpIHtcbiAgICBjYXNlIFwiTWVtYmVyRXhwcmVzc2lvblwiOlxuICAgIGNhc2UgXCJPcHRpb25hbE1lbWJlckV4cHJlc3Npb25cIjpcbiAgICAgIGlmIChwYXJlbnQucHJvcGVydHkgPT09IG5vZGUpIHtcbiAgICAgICAgcmV0dXJuICEhcGFyZW50LmNvbXB1dGVkO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHBhcmVudC5vYmplY3QgPT09IG5vZGU7XG4gICAgY2FzZSBcIkpTWE1lbWJlckV4cHJlc3Npb25cIjpcbiAgICAgIHJldHVybiBwYXJlbnQub2JqZWN0ID09PSBub2RlO1xuICAgIGNhc2UgXCJWYXJpYWJsZURlY2xhcmF0b3JcIjpcbiAgICAgIHJldHVybiBwYXJlbnQuaW5pdCA9PT0gbm9kZTtcbiAgICBjYXNlIFwiQXJyb3dGdW5jdGlvbkV4cHJlc3Npb25cIjpcbiAgICAgIHJldHVybiBwYXJlbnQuYm9keSA9PT0gbm9kZTtcbiAgICBjYXNlIFwiUHJpdmF0ZU5hbWVcIjpcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICBjYXNlIFwiQ2xhc3NNZXRob2RcIjpcbiAgICBjYXNlIFwiQ2xhc3NQcml2YXRlTWV0aG9kXCI6XG4gICAgY2FzZSBcIk9iamVjdE1ldGhvZFwiOlxuICAgICAgaWYgKHBhcmVudC5rZXkgPT09IG5vZGUpIHtcbiAgICAgICAgcmV0dXJuICEhcGFyZW50LmNvbXB1dGVkO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIGNhc2UgXCJPYmplY3RQcm9wZXJ0eVwiOlxuICAgICAgaWYgKHBhcmVudC5rZXkgPT09IG5vZGUpIHtcbiAgICAgICAgcmV0dXJuICEhcGFyZW50LmNvbXB1dGVkO1xuICAgICAgfVxuICAgICAgcmV0dXJuIChncmFuZHBhcmVudCA9PSBudWxsID8gdm9pZCAwIDogZ3JhbmRwYXJlbnQudHlwZSkgIT09IFwiT2JqZWN0UGF0dGVyblwiO1xuICAgIGNhc2UgXCJDbGFzc1Byb3BlcnR5XCI6XG4gICAgY2FzZSBcIkNsYXNzQWNjZXNzb3JQcm9wZXJ0eVwiOlxuICAgICAgaWYgKHBhcmVudC5rZXkgPT09IG5vZGUpIHtcbiAgICAgICAgcmV0dXJuICEhcGFyZW50LmNvbXB1dGVkO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgY2FzZSBcIkNsYXNzUHJpdmF0ZVByb3BlcnR5XCI6XG4gICAgICByZXR1cm4gcGFyZW50LmtleSAhPT0gbm9kZTtcbiAgICBjYXNlIFwiQ2xhc3NEZWNsYXJhdGlvblwiOlxuICAgIGNhc2UgXCJDbGFzc0V4cHJlc3Npb25cIjpcbiAgICAgIHJldHVybiBwYXJlbnQuc3VwZXJDbGFzcyA9PT0gbm9kZTtcbiAgICBjYXNlIFwiQXNzaWdubWVudEV4cHJlc3Npb25cIjpcbiAgICAgIHJldHVybiBwYXJlbnQucmlnaHQgPT09IG5vZGU7XG4gICAgY2FzZSBcIkFzc2lnbm1lbnRQYXR0ZXJuXCI6XG4gICAgICByZXR1cm4gcGFyZW50LnJpZ2h0ID09PSBub2RlO1xuICAgIGNhc2UgXCJMYWJlbGVkU3RhdGVtZW50XCI6XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgY2FzZSBcIkNhdGNoQ2xhdXNlXCI6XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgY2FzZSBcIlJlc3RFbGVtZW50XCI6XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgY2FzZSBcIkJyZWFrU3RhdGVtZW50XCI6XG4gICAgY2FzZSBcIkNvbnRpbnVlU3RhdGVtZW50XCI6XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgY2FzZSBcIkZ1bmN0aW9uRGVjbGFyYXRpb25cIjpcbiAgICBjYXNlIFwiRnVuY3Rpb25FeHByZXNzaW9uXCI6XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgY2FzZSBcIkV4cG9ydE5hbWVzcGFjZVNwZWNpZmllclwiOlxuICAgIGNhc2UgXCJFeHBvcnREZWZhdWx0U3BlY2lmaWVyXCI6XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgY2FzZSBcIkV4cG9ydFNwZWNpZmllclwiOlxuICAgICAgaWYgKGdyYW5kcGFyZW50ICE9IG51bGwgJiYgZ3JhbmRwYXJlbnQuc291cmNlKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBwYXJlbnQubG9jYWwgPT09IG5vZGU7XG4gICAgY2FzZSBcIkltcG9ydERlZmF1bHRTcGVjaWZpZXJcIjpcbiAgICBjYXNlIFwiSW1wb3J0TmFtZXNwYWNlU3BlY2lmaWVyXCI6XG4gICAgY2FzZSBcIkltcG9ydFNwZWNpZmllclwiOlxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIGNhc2UgXCJJbXBvcnRBdHRyaWJ1dGVcIjpcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICBjYXNlIFwiSlNYQXR0cmlidXRlXCI6XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgY2FzZSBcIk9iamVjdFBhdHRlcm5cIjpcbiAgICBjYXNlIFwiQXJyYXlQYXR0ZXJuXCI6XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgY2FzZSBcIk1ldGFQcm9wZXJ0eVwiOlxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIGNhc2UgXCJPYmplY3RUeXBlUHJvcGVydHlcIjpcbiAgICAgIHJldHVybiBwYXJlbnQua2V5ICE9PSBub2RlO1xuICAgIGNhc2UgXCJUU0VudW1NZW1iZXJcIjpcbiAgICAgIHJldHVybiBwYXJlbnQuaWQgIT09IG5vZGU7XG4gICAgY2FzZSBcIlRTUHJvcGVydHlTaWduYXR1cmVcIjpcbiAgICAgIGlmIChwYXJlbnQua2V5ID09PSBub2RlKSB7XG4gICAgICAgIHJldHVybiAhIXBhcmVudC5jb21wdXRlZDtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0cnVlO1xuICB9XG4gIHJldHVybiB0cnVlO1xufVxuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1pc1JlZmVyZW5jZWQuanMubWFwXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@babel/types/lib/validators/isReferenced.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@babel/types/lib/validators/isScope.js":
/*!*************************************************************!*\
  !*** ./node_modules/@babel/types/lib/validators/isScope.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports[\"default\"] = isScope;\nvar _index = __webpack_require__(/*! ./generated/index.js */ \"(ssr)/./node_modules/@babel/types/lib/validators/generated/index.js\");\nfunction isScope(node, parent) {\n  if ((0, _index.isBlockStatement)(node) && ((0, _index.isFunction)(parent) || (0, _index.isCatchClause)(parent))) {\n    return false;\n  }\n  if ((0, _index.isPattern)(node) && ((0, _index.isFunction)(parent) || (0, _index.isCatchClause)(parent))) {\n    return true;\n  }\n  return (0, _index.isScopable)(node);\n}\n\n//# sourceMappingURL=isScope.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGJhYmVsL3R5cGVzL2xpYi92YWxpZGF0b3JzL2lzU2NvcGUuanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWIsOENBQTZDO0FBQzdDO0FBQ0EsQ0FBQyxFQUFDO0FBQ0Ysa0JBQWU7QUFDZixhQUFhLG1CQUFPLENBQUMsaUdBQXNCO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSIsInNvdXJjZXMiOlsid2VicGFjazovL3JlcG8tdmlzdWFsaXplci8uL25vZGVfbW9kdWxlcy9AYmFiZWwvdHlwZXMvbGliL3ZhbGlkYXRvcnMvaXNTY29wZS5qcz84YzFlIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5kZWZhdWx0ID0gaXNTY29wZTtcbnZhciBfaW5kZXggPSByZXF1aXJlKFwiLi9nZW5lcmF0ZWQvaW5kZXguanNcIik7XG5mdW5jdGlvbiBpc1Njb3BlKG5vZGUsIHBhcmVudCkge1xuICBpZiAoKDAsIF9pbmRleC5pc0Jsb2NrU3RhdGVtZW50KShub2RlKSAmJiAoKDAsIF9pbmRleC5pc0Z1bmN0aW9uKShwYXJlbnQpIHx8ICgwLCBfaW5kZXguaXNDYXRjaENsYXVzZSkocGFyZW50KSkpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgaWYgKCgwLCBfaW5kZXguaXNQYXR0ZXJuKShub2RlKSAmJiAoKDAsIF9pbmRleC5pc0Z1bmN0aW9uKShwYXJlbnQpIHx8ICgwLCBfaW5kZXguaXNDYXRjaENsYXVzZSkocGFyZW50KSkpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICByZXR1cm4gKDAsIF9pbmRleC5pc1Njb3BhYmxlKShub2RlKTtcbn1cblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aXNTY29wZS5qcy5tYXBcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@babel/types/lib/validators/isScope.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@babel/types/lib/validators/isSpecifierDefault.js":
/*!************************************************************************!*\
  !*** ./node_modules/@babel/types/lib/validators/isSpecifierDefault.js ***!
  \************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports[\"default\"] = isSpecifierDefault;\nvar _index = __webpack_require__(/*! ./generated/index.js */ \"(ssr)/./node_modules/@babel/types/lib/validators/generated/index.js\");\nfunction isSpecifierDefault(specifier) {\n  return (0, _index.isImportDefaultSpecifier)(specifier) || (0, _index.isIdentifier)(specifier.imported || specifier.exported, {\n    name: \"default\"\n  });\n}\n\n//# sourceMappingURL=isSpecifierDefault.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGJhYmVsL3R5cGVzL2xpYi92YWxpZGF0b3JzL2lzU3BlY2lmaWVyRGVmYXVsdC5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYiw4Q0FBNkM7QUFDN0M7QUFDQSxDQUFDLEVBQUM7QUFDRixrQkFBZTtBQUNmLGFBQWEsbUJBQU8sQ0FBQyxpR0FBc0I7QUFDM0M7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcmVwby12aXN1YWxpemVyLy4vbm9kZV9tb2R1bGVzL0BiYWJlbC90eXBlcy9saWIvdmFsaWRhdG9ycy9pc1NwZWNpZmllckRlZmF1bHQuanM/MGZhZiJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuZGVmYXVsdCA9IGlzU3BlY2lmaWVyRGVmYXVsdDtcbnZhciBfaW5kZXggPSByZXF1aXJlKFwiLi9nZW5lcmF0ZWQvaW5kZXguanNcIik7XG5mdW5jdGlvbiBpc1NwZWNpZmllckRlZmF1bHQoc3BlY2lmaWVyKSB7XG4gIHJldHVybiAoMCwgX2luZGV4LmlzSW1wb3J0RGVmYXVsdFNwZWNpZmllcikoc3BlY2lmaWVyKSB8fCAoMCwgX2luZGV4LmlzSWRlbnRpZmllcikoc3BlY2lmaWVyLmltcG9ydGVkIHx8IHNwZWNpZmllci5leHBvcnRlZCwge1xuICAgIG5hbWU6IFwiZGVmYXVsdFwiXG4gIH0pO1xufVxuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1pc1NwZWNpZmllckRlZmF1bHQuanMubWFwXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@babel/types/lib/validators/isSpecifierDefault.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@babel/types/lib/validators/isType.js":
/*!************************************************************!*\
  !*** ./node_modules/@babel/types/lib/validators/isType.js ***!
  \************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports[\"default\"] = isType;\nvar _index = __webpack_require__(/*! ../definitions/index.js */ \"(ssr)/./node_modules/@babel/types/lib/definitions/index.js\");\nfunction isType(nodeType, targetType) {\n  if (nodeType === targetType) return true;\n  if (nodeType == null) return false;\n  if (_index.ALIAS_KEYS[targetType]) return false;\n  const aliases = _index.FLIPPED_ALIAS_KEYS[targetType];\n  if (aliases != null && aliases.includes(nodeType)) return true;\n  return false;\n}\n\n//# sourceMappingURL=isType.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGJhYmVsL3R5cGVzL2xpYi92YWxpZGF0b3JzL2lzVHlwZS5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYiw4Q0FBNkM7QUFDN0M7QUFDQSxDQUFDLEVBQUM7QUFDRixrQkFBZTtBQUNmLGFBQWEsbUJBQU8sQ0FBQywyRkFBeUI7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSIsInNvdXJjZXMiOlsid2VicGFjazovL3JlcG8tdmlzdWFsaXplci8uL25vZGVfbW9kdWxlcy9AYmFiZWwvdHlwZXMvbGliL3ZhbGlkYXRvcnMvaXNUeXBlLmpzP2M2MDUiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLmRlZmF1bHQgPSBpc1R5cGU7XG52YXIgX2luZGV4ID0gcmVxdWlyZShcIi4uL2RlZmluaXRpb25zL2luZGV4LmpzXCIpO1xuZnVuY3Rpb24gaXNUeXBlKG5vZGVUeXBlLCB0YXJnZXRUeXBlKSB7XG4gIGlmIChub2RlVHlwZSA9PT0gdGFyZ2V0VHlwZSkgcmV0dXJuIHRydWU7XG4gIGlmIChub2RlVHlwZSA9PSBudWxsKSByZXR1cm4gZmFsc2U7XG4gIGlmIChfaW5kZXguQUxJQVNfS0VZU1t0YXJnZXRUeXBlXSkgcmV0dXJuIGZhbHNlO1xuICBjb25zdCBhbGlhc2VzID0gX2luZGV4LkZMSVBQRURfQUxJQVNfS0VZU1t0YXJnZXRUeXBlXTtcbiAgaWYgKGFsaWFzZXMgIT0gbnVsbCAmJiBhbGlhc2VzLmluY2x1ZGVzKG5vZGVUeXBlKSkgcmV0dXJuIHRydWU7XG4gIHJldHVybiBmYWxzZTtcbn1cblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aXNUeXBlLmpzLm1hcFxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@babel/types/lib/validators/isType.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@babel/types/lib/validators/isValidES3Identifier.js":
/*!**************************************************************************!*\
  !*** ./node_modules/@babel/types/lib/validators/isValidES3Identifier.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports[\"default\"] = isValidES3Identifier;\nvar _isValidIdentifier = __webpack_require__(/*! ./isValidIdentifier.js */ \"(ssr)/./node_modules/@babel/types/lib/validators/isValidIdentifier.js\");\nconst RESERVED_WORDS_ES3_ONLY = new Set([\"abstract\", \"boolean\", \"byte\", \"char\", \"double\", \"enum\", \"final\", \"float\", \"goto\", \"implements\", \"int\", \"interface\", \"long\", \"native\", \"package\", \"private\", \"protected\", \"public\", \"short\", \"static\", \"synchronized\", \"throws\", \"transient\", \"volatile\"]);\nfunction isValidES3Identifier(name) {\n  return (0, _isValidIdentifier.default)(name) && !RESERVED_WORDS_ES3_ONLY.has(name);\n}\n\n//# sourceMappingURL=isValidES3Identifier.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGJhYmVsL3R5cGVzL2xpYi92YWxpZGF0b3JzL2lzVmFsaWRFUzNJZGVudGlmaWVyLmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViLDhDQUE2QztBQUM3QztBQUNBLENBQUMsRUFBQztBQUNGLGtCQUFlO0FBQ2YseUJBQXlCLG1CQUFPLENBQUMscUdBQXdCO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBOztBQUVBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcmVwby12aXN1YWxpemVyLy4vbm9kZV9tb2R1bGVzL0BiYWJlbC90eXBlcy9saWIvdmFsaWRhdG9ycy9pc1ZhbGlkRVMzSWRlbnRpZmllci5qcz80ZGVjIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5kZWZhdWx0ID0gaXNWYWxpZEVTM0lkZW50aWZpZXI7XG52YXIgX2lzVmFsaWRJZGVudGlmaWVyID0gcmVxdWlyZShcIi4vaXNWYWxpZElkZW50aWZpZXIuanNcIik7XG5jb25zdCBSRVNFUlZFRF9XT1JEU19FUzNfT05MWSA9IG5ldyBTZXQoW1wiYWJzdHJhY3RcIiwgXCJib29sZWFuXCIsIFwiYnl0ZVwiLCBcImNoYXJcIiwgXCJkb3VibGVcIiwgXCJlbnVtXCIsIFwiZmluYWxcIiwgXCJmbG9hdFwiLCBcImdvdG9cIiwgXCJpbXBsZW1lbnRzXCIsIFwiaW50XCIsIFwiaW50ZXJmYWNlXCIsIFwibG9uZ1wiLCBcIm5hdGl2ZVwiLCBcInBhY2thZ2VcIiwgXCJwcml2YXRlXCIsIFwicHJvdGVjdGVkXCIsIFwicHVibGljXCIsIFwic2hvcnRcIiwgXCJzdGF0aWNcIiwgXCJzeW5jaHJvbml6ZWRcIiwgXCJ0aHJvd3NcIiwgXCJ0cmFuc2llbnRcIiwgXCJ2b2xhdGlsZVwiXSk7XG5mdW5jdGlvbiBpc1ZhbGlkRVMzSWRlbnRpZmllcihuYW1lKSB7XG4gIHJldHVybiAoMCwgX2lzVmFsaWRJZGVudGlmaWVyLmRlZmF1bHQpKG5hbWUpICYmICFSRVNFUlZFRF9XT1JEU19FUzNfT05MWS5oYXMobmFtZSk7XG59XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWlzVmFsaWRFUzNJZGVudGlmaWVyLmpzLm1hcFxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@babel/types/lib/validators/isValidES3Identifier.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@babel/types/lib/validators/isValidIdentifier.js":
/*!***********************************************************************!*\
  !*** ./node_modules/@babel/types/lib/validators/isValidIdentifier.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports[\"default\"] = isValidIdentifier;\nvar _helperValidatorIdentifier = __webpack_require__(/*! @babel/helper-validator-identifier */ \"(ssr)/./node_modules/@babel/helper-validator-identifier/lib/index.js\");\nfunction isValidIdentifier(name, reserved = true) {\n  if (typeof name !== \"string\") return false;\n  if (reserved) {\n    if ((0, _helperValidatorIdentifier.isKeyword)(name) || (0, _helperValidatorIdentifier.isStrictReservedWord)(name, true)) {\n      return false;\n    }\n  }\n  return (0, _helperValidatorIdentifier.isIdentifierName)(name);\n}\n\n//# sourceMappingURL=isValidIdentifier.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGJhYmVsL3R5cGVzL2xpYi92YWxpZGF0b3JzL2lzVmFsaWRJZGVudGlmaWVyLmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViLDhDQUE2QztBQUM3QztBQUNBLENBQUMsRUFBQztBQUNGLGtCQUFlO0FBQ2YsaUNBQWlDLG1CQUFPLENBQUMsZ0hBQW9DO0FBQzdFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSIsInNvdXJjZXMiOlsid2VicGFjazovL3JlcG8tdmlzdWFsaXplci8uL25vZGVfbW9kdWxlcy9AYmFiZWwvdHlwZXMvbGliL3ZhbGlkYXRvcnMvaXNWYWxpZElkZW50aWZpZXIuanM/YWM3ZCJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuZGVmYXVsdCA9IGlzVmFsaWRJZGVudGlmaWVyO1xudmFyIF9oZWxwZXJWYWxpZGF0b3JJZGVudGlmaWVyID0gcmVxdWlyZShcIkBiYWJlbC9oZWxwZXItdmFsaWRhdG9yLWlkZW50aWZpZXJcIik7XG5mdW5jdGlvbiBpc1ZhbGlkSWRlbnRpZmllcihuYW1lLCByZXNlcnZlZCA9IHRydWUpIHtcbiAgaWYgKHR5cGVvZiBuYW1lICE9PSBcInN0cmluZ1wiKSByZXR1cm4gZmFsc2U7XG4gIGlmIChyZXNlcnZlZCkge1xuICAgIGlmICgoMCwgX2hlbHBlclZhbGlkYXRvcklkZW50aWZpZXIuaXNLZXl3b3JkKShuYW1lKSB8fCAoMCwgX2hlbHBlclZhbGlkYXRvcklkZW50aWZpZXIuaXNTdHJpY3RSZXNlcnZlZFdvcmQpKG5hbWUsIHRydWUpKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG4gIHJldHVybiAoMCwgX2hlbHBlclZhbGlkYXRvcklkZW50aWZpZXIuaXNJZGVudGlmaWVyTmFtZSkobmFtZSk7XG59XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWlzVmFsaWRJZGVudGlmaWVyLmpzLm1hcFxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@babel/types/lib/validators/isValidIdentifier.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@babel/types/lib/validators/isVar.js":
/*!***********************************************************!*\
  !*** ./node_modules/@babel/types/lib/validators/isVar.js ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports[\"default\"] = isVar;\nvar _index = __webpack_require__(/*! ./generated/index.js */ \"(ssr)/./node_modules/@babel/types/lib/validators/generated/index.js\");\nvar BLOCK_SCOPED_SYMBOL = Symbol.for(\"var used to be block scoped\");\nfunction isVar(node) {\n  return (0, _index.isVariableDeclaration)(node, {\n    kind: \"var\"\n  }) && !node[BLOCK_SCOPED_SYMBOL];\n}\n\n//# sourceMappingURL=isVar.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGJhYmVsL3R5cGVzL2xpYi92YWxpZGF0b3JzL2lzVmFyLmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViLDhDQUE2QztBQUM3QztBQUNBLENBQUMsRUFBQztBQUNGLGtCQUFlO0FBQ2YsYUFBYSxtQkFBTyxDQUFDLGlHQUFzQjtBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQSIsInNvdXJjZXMiOlsid2VicGFjazovL3JlcG8tdmlzdWFsaXplci8uL25vZGVfbW9kdWxlcy9AYmFiZWwvdHlwZXMvbGliL3ZhbGlkYXRvcnMvaXNWYXIuanM/ZWFiZSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuZGVmYXVsdCA9IGlzVmFyO1xudmFyIF9pbmRleCA9IHJlcXVpcmUoXCIuL2dlbmVyYXRlZC9pbmRleC5qc1wiKTtcbnZhciBCTE9DS19TQ09QRURfU1lNQk9MID0gU3ltYm9sLmZvcihcInZhciB1c2VkIHRvIGJlIGJsb2NrIHNjb3BlZFwiKTtcbmZ1bmN0aW9uIGlzVmFyKG5vZGUpIHtcbiAgcmV0dXJuICgwLCBfaW5kZXguaXNWYXJpYWJsZURlY2xhcmF0aW9uKShub2RlLCB7XG4gICAga2luZDogXCJ2YXJcIlxuICB9KSAmJiAhbm9kZVtCTE9DS19TQ09QRURfU1lNQk9MXTtcbn1cblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aXNWYXIuanMubWFwXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@babel/types/lib/validators/isVar.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@babel/types/lib/validators/matchesPattern.js":
/*!********************************************************************!*\
  !*** ./node_modules/@babel/types/lib/validators/matchesPattern.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports[\"default\"] = matchesPattern;\nvar _index = __webpack_require__(/*! ./generated/index.js */ \"(ssr)/./node_modules/@babel/types/lib/validators/generated/index.js\");\nfunction isMemberExpressionLike(node) {\n  return (0, _index.isMemberExpression)(node) || (0, _index.isMetaProperty)(node);\n}\nfunction matchesPattern(member, match, allowPartial) {\n  if (!isMemberExpressionLike(member)) return false;\n  const parts = Array.isArray(match) ? match : match.split(\".\");\n  const nodes = [];\n  let node;\n  for (node = member; isMemberExpressionLike(node); node = (_object = node.object) != null ? _object : node.meta) {\n    var _object;\n    nodes.push(node.property);\n  }\n  nodes.push(node);\n  if (nodes.length < parts.length) return false;\n  if (!allowPartial && nodes.length > parts.length) return false;\n  for (let i = 0, j = nodes.length - 1; i < parts.length; i++, j--) {\n    const node = nodes[j];\n    let value;\n    if ((0, _index.isIdentifier)(node)) {\n      value = node.name;\n    } else if ((0, _index.isStringLiteral)(node)) {\n      value = node.value;\n    } else if ((0, _index.isThisExpression)(node)) {\n      value = \"this\";\n    } else if ((0, _index.isSuper)(node)) {\n      value = \"super\";\n    } else if ((0, _index.isPrivateName)(node)) {\n      value = \"#\" + node.id.name;\n    } else {\n      return false;\n    }\n    if (parts[i] !== value) return false;\n  }\n  return true;\n}\n\n//# sourceMappingURL=matchesPattern.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGJhYmVsL3R5cGVzL2xpYi92YWxpZGF0b3JzL21hdGNoZXNQYXR0ZXJuLmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViLDhDQUE2QztBQUM3QztBQUNBLENBQUMsRUFBQztBQUNGLGtCQUFlO0FBQ2YsYUFBYSxtQkFBTyxDQUFDLGlHQUFzQjtBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLDhCQUE4QjtBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0Msa0JBQWtCO0FBQzFEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSIsInNvdXJjZXMiOlsid2VicGFjazovL3JlcG8tdmlzdWFsaXplci8uL25vZGVfbW9kdWxlcy9AYmFiZWwvdHlwZXMvbGliL3ZhbGlkYXRvcnMvbWF0Y2hlc1BhdHRlcm4uanM/MzEyOSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuZGVmYXVsdCA9IG1hdGNoZXNQYXR0ZXJuO1xudmFyIF9pbmRleCA9IHJlcXVpcmUoXCIuL2dlbmVyYXRlZC9pbmRleC5qc1wiKTtcbmZ1bmN0aW9uIGlzTWVtYmVyRXhwcmVzc2lvbkxpa2Uobm9kZSkge1xuICByZXR1cm4gKDAsIF9pbmRleC5pc01lbWJlckV4cHJlc3Npb24pKG5vZGUpIHx8ICgwLCBfaW5kZXguaXNNZXRhUHJvcGVydHkpKG5vZGUpO1xufVxuZnVuY3Rpb24gbWF0Y2hlc1BhdHRlcm4obWVtYmVyLCBtYXRjaCwgYWxsb3dQYXJ0aWFsKSB7XG4gIGlmICghaXNNZW1iZXJFeHByZXNzaW9uTGlrZShtZW1iZXIpKSByZXR1cm4gZmFsc2U7XG4gIGNvbnN0IHBhcnRzID0gQXJyYXkuaXNBcnJheShtYXRjaCkgPyBtYXRjaCA6IG1hdGNoLnNwbGl0KFwiLlwiKTtcbiAgY29uc3Qgbm9kZXMgPSBbXTtcbiAgbGV0IG5vZGU7XG4gIGZvciAobm9kZSA9IG1lbWJlcjsgaXNNZW1iZXJFeHByZXNzaW9uTGlrZShub2RlKTsgbm9kZSA9IChfb2JqZWN0ID0gbm9kZS5vYmplY3QpICE9IG51bGwgPyBfb2JqZWN0IDogbm9kZS5tZXRhKSB7XG4gICAgdmFyIF9vYmplY3Q7XG4gICAgbm9kZXMucHVzaChub2RlLnByb3BlcnR5KTtcbiAgfVxuICBub2Rlcy5wdXNoKG5vZGUpO1xuICBpZiAobm9kZXMubGVuZ3RoIDwgcGFydHMubGVuZ3RoKSByZXR1cm4gZmFsc2U7XG4gIGlmICghYWxsb3dQYXJ0aWFsICYmIG5vZGVzLmxlbmd0aCA+IHBhcnRzLmxlbmd0aCkgcmV0dXJuIGZhbHNlO1xuICBmb3IgKGxldCBpID0gMCwgaiA9IG5vZGVzLmxlbmd0aCAtIDE7IGkgPCBwYXJ0cy5sZW5ndGg7IGkrKywgai0tKSB7XG4gICAgY29uc3Qgbm9kZSA9IG5vZGVzW2pdO1xuICAgIGxldCB2YWx1ZTtcbiAgICBpZiAoKDAsIF9pbmRleC5pc0lkZW50aWZpZXIpKG5vZGUpKSB7XG4gICAgICB2YWx1ZSA9IG5vZGUubmFtZTtcbiAgICB9IGVsc2UgaWYgKCgwLCBfaW5kZXguaXNTdHJpbmdMaXRlcmFsKShub2RlKSkge1xuICAgICAgdmFsdWUgPSBub2RlLnZhbHVlO1xuICAgIH0gZWxzZSBpZiAoKDAsIF9pbmRleC5pc1RoaXNFeHByZXNzaW9uKShub2RlKSkge1xuICAgICAgdmFsdWUgPSBcInRoaXNcIjtcbiAgICB9IGVsc2UgaWYgKCgwLCBfaW5kZXguaXNTdXBlcikobm9kZSkpIHtcbiAgICAgIHZhbHVlID0gXCJzdXBlclwiO1xuICAgIH0gZWxzZSBpZiAoKDAsIF9pbmRleC5pc1ByaXZhdGVOYW1lKShub2RlKSkge1xuICAgICAgdmFsdWUgPSBcIiNcIiArIG5vZGUuaWQubmFtZTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBpZiAocGFydHNbaV0gIT09IHZhbHVlKSByZXR1cm4gZmFsc2U7XG4gIH1cbiAgcmV0dXJuIHRydWU7XG59XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW1hdGNoZXNQYXR0ZXJuLmpzLm1hcFxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@babel/types/lib/validators/matchesPattern.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@babel/types/lib/validators/react/isCompatTag.js":
/*!***********************************************************************!*\
  !*** ./node_modules/@babel/types/lib/validators/react/isCompatTag.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports[\"default\"] = isCompatTag;\nfunction isCompatTag(tagName) {\n  return !!tagName && /^[a-z]/.test(tagName);\n}\n\n//# sourceMappingURL=isCompatTag.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGJhYmVsL3R5cGVzL2xpYi92YWxpZGF0b3JzL3JlYWN0L2lzQ29tcGF0VGFnLmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViLDhDQUE2QztBQUM3QztBQUNBLENBQUMsRUFBQztBQUNGLGtCQUFlO0FBQ2Y7QUFDQTtBQUNBOztBQUVBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcmVwby12aXN1YWxpemVyLy4vbm9kZV9tb2R1bGVzL0BiYWJlbC90eXBlcy9saWIvdmFsaWRhdG9ycy9yZWFjdC9pc0NvbXBhdFRhZy5qcz8wMmViIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5kZWZhdWx0ID0gaXNDb21wYXRUYWc7XG5mdW5jdGlvbiBpc0NvbXBhdFRhZyh0YWdOYW1lKSB7XG4gIHJldHVybiAhIXRhZ05hbWUgJiYgL15bYS16XS8udGVzdCh0YWdOYW1lKTtcbn1cblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aXNDb21wYXRUYWcuanMubWFwXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@babel/types/lib/validators/react/isCompatTag.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@babel/types/lib/validators/react/isReactComponent.js":
/*!****************************************************************************!*\
  !*** ./node_modules/@babel/types/lib/validators/react/isReactComponent.js ***!
  \****************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports[\"default\"] = void 0;\nvar _buildMatchMemberExpression = __webpack_require__(/*! ../buildMatchMemberExpression.js */ \"(ssr)/./node_modules/@babel/types/lib/validators/buildMatchMemberExpression.js\");\nconst isReactComponent = (0, _buildMatchMemberExpression.default)(\"React.Component\");\nvar _default = exports[\"default\"] = isReactComponent;\n\n//# sourceMappingURL=isReactComponent.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGJhYmVsL3R5cGVzL2xpYi92YWxpZGF0b3JzL3JlYWN0L2lzUmVhY3RDb21wb25lbnQuanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWIsOENBQTZDO0FBQzdDO0FBQ0EsQ0FBQyxFQUFDO0FBQ0Ysa0JBQWU7QUFDZixrQ0FBa0MsbUJBQU8sQ0FBQyx3SEFBa0M7QUFDNUU7QUFDQSxlQUFlLGtCQUFlOztBQUU5QiIsInNvdXJjZXMiOlsid2VicGFjazovL3JlcG8tdmlzdWFsaXplci8uL25vZGVfbW9kdWxlcy9AYmFiZWwvdHlwZXMvbGliL3ZhbGlkYXRvcnMvcmVhY3QvaXNSZWFjdENvbXBvbmVudC5qcz9kOTE0Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5kZWZhdWx0ID0gdm9pZCAwO1xudmFyIF9idWlsZE1hdGNoTWVtYmVyRXhwcmVzc2lvbiA9IHJlcXVpcmUoXCIuLi9idWlsZE1hdGNoTWVtYmVyRXhwcmVzc2lvbi5qc1wiKTtcbmNvbnN0IGlzUmVhY3RDb21wb25lbnQgPSAoMCwgX2J1aWxkTWF0Y2hNZW1iZXJFeHByZXNzaW9uLmRlZmF1bHQpKFwiUmVhY3QuQ29tcG9uZW50XCIpO1xudmFyIF9kZWZhdWx0ID0gZXhwb3J0cy5kZWZhdWx0ID0gaXNSZWFjdENvbXBvbmVudDtcblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aXNSZWFjdENvbXBvbmVudC5qcy5tYXBcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@babel/types/lib/validators/react/isReactComponent.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@babel/types/lib/validators/validate.js":
/*!**************************************************************!*\
  !*** ./node_modules/@babel/types/lib/validators/validate.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports[\"default\"] = validate;\nexports.validateChild = validateChild;\nexports.validateField = validateField;\nexports.validateInternal = validateInternal;\nvar _index = __webpack_require__(/*! ../definitions/index.js */ \"(ssr)/./node_modules/@babel/types/lib/definitions/index.js\");\nfunction validate(node, key, val) {\n  if (!node) return;\n  const fields = _index.NODE_FIELDS[node.type];\n  if (!fields) return;\n  const field = fields[key];\n  validateField(node, key, val, field);\n  validateChild(node, key, val);\n}\nfunction validateInternal(field, node, key, val, maybeNode) {\n  if (!(field != null && field.validate)) return;\n  if (field.optional && val == null) return;\n  field.validate(node, key, val);\n  if (maybeNode) {\n    var _NODE_PARENT_VALIDATI;\n    const type = val.type;\n    if (type == null) return;\n    (_NODE_PARENT_VALIDATI = _index.NODE_PARENT_VALIDATIONS[type]) == null || _NODE_PARENT_VALIDATI.call(_index.NODE_PARENT_VALIDATIONS, node, key, val);\n  }\n}\nfunction validateField(node, key, val, field) {\n  if (!(field != null && field.validate)) return;\n  if (field.optional && val == null) return;\n  field.validate(node, key, val);\n}\nfunction validateChild(node, key, val) {\n  var _NODE_PARENT_VALIDATI2;\n  const type = val == null ? void 0 : val.type;\n  if (type == null) return;\n  (_NODE_PARENT_VALIDATI2 = _index.NODE_PARENT_VALIDATIONS[type]) == null || _NODE_PARENT_VALIDATI2.call(_index.NODE_PARENT_VALIDATIONS, node, key, val);\n}\n\n//# sourceMappingURL=validate.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGJhYmVsL3R5cGVzL2xpYi92YWxpZGF0b3JzL3ZhbGlkYXRlLmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViLDhDQUE2QztBQUM3QztBQUNBLENBQUMsRUFBQztBQUNGLGtCQUFlO0FBQ2YscUJBQXFCO0FBQ3JCLHFCQUFxQjtBQUNyQix3QkFBd0I7QUFDeEIsYUFBYSxtQkFBTyxDQUFDLDJGQUF5QjtBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9yZXBvLXZpc3VhbGl6ZXIvLi9ub2RlX21vZHVsZXMvQGJhYmVsL3R5cGVzL2xpYi92YWxpZGF0b3JzL3ZhbGlkYXRlLmpzPzljMjYiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLmRlZmF1bHQgPSB2YWxpZGF0ZTtcbmV4cG9ydHMudmFsaWRhdGVDaGlsZCA9IHZhbGlkYXRlQ2hpbGQ7XG5leHBvcnRzLnZhbGlkYXRlRmllbGQgPSB2YWxpZGF0ZUZpZWxkO1xuZXhwb3J0cy52YWxpZGF0ZUludGVybmFsID0gdmFsaWRhdGVJbnRlcm5hbDtcbnZhciBfaW5kZXggPSByZXF1aXJlKFwiLi4vZGVmaW5pdGlvbnMvaW5kZXguanNcIik7XG5mdW5jdGlvbiB2YWxpZGF0ZShub2RlLCBrZXksIHZhbCkge1xuICBpZiAoIW5vZGUpIHJldHVybjtcbiAgY29uc3QgZmllbGRzID0gX2luZGV4Lk5PREVfRklFTERTW25vZGUudHlwZV07XG4gIGlmICghZmllbGRzKSByZXR1cm47XG4gIGNvbnN0IGZpZWxkID0gZmllbGRzW2tleV07XG4gIHZhbGlkYXRlRmllbGQobm9kZSwga2V5LCB2YWwsIGZpZWxkKTtcbiAgdmFsaWRhdGVDaGlsZChub2RlLCBrZXksIHZhbCk7XG59XG5mdW5jdGlvbiB2YWxpZGF0ZUludGVybmFsKGZpZWxkLCBub2RlLCBrZXksIHZhbCwgbWF5YmVOb2RlKSB7XG4gIGlmICghKGZpZWxkICE9IG51bGwgJiYgZmllbGQudmFsaWRhdGUpKSByZXR1cm47XG4gIGlmIChmaWVsZC5vcHRpb25hbCAmJiB2YWwgPT0gbnVsbCkgcmV0dXJuO1xuICBmaWVsZC52YWxpZGF0ZShub2RlLCBrZXksIHZhbCk7XG4gIGlmIChtYXliZU5vZGUpIHtcbiAgICB2YXIgX05PREVfUEFSRU5UX1ZBTElEQVRJO1xuICAgIGNvbnN0IHR5cGUgPSB2YWwudHlwZTtcbiAgICBpZiAodHlwZSA9PSBudWxsKSByZXR1cm47XG4gICAgKF9OT0RFX1BBUkVOVF9WQUxJREFUSSA9IF9pbmRleC5OT0RFX1BBUkVOVF9WQUxJREFUSU9OU1t0eXBlXSkgPT0gbnVsbCB8fCBfTk9ERV9QQVJFTlRfVkFMSURBVEkuY2FsbChfaW5kZXguTk9ERV9QQVJFTlRfVkFMSURBVElPTlMsIG5vZGUsIGtleSwgdmFsKTtcbiAgfVxufVxuZnVuY3Rpb24gdmFsaWRhdGVGaWVsZChub2RlLCBrZXksIHZhbCwgZmllbGQpIHtcbiAgaWYgKCEoZmllbGQgIT0gbnVsbCAmJiBmaWVsZC52YWxpZGF0ZSkpIHJldHVybjtcbiAgaWYgKGZpZWxkLm9wdGlvbmFsICYmIHZhbCA9PSBudWxsKSByZXR1cm47XG4gIGZpZWxkLnZhbGlkYXRlKG5vZGUsIGtleSwgdmFsKTtcbn1cbmZ1bmN0aW9uIHZhbGlkYXRlQ2hpbGQobm9kZSwga2V5LCB2YWwpIHtcbiAgdmFyIF9OT0RFX1BBUkVOVF9WQUxJREFUSTI7XG4gIGNvbnN0IHR5cGUgPSB2YWwgPT0gbnVsbCA/IHZvaWQgMCA6IHZhbC50eXBlO1xuICBpZiAodHlwZSA9PSBudWxsKSByZXR1cm47XG4gIChfTk9ERV9QQVJFTlRfVkFMSURBVEkyID0gX2luZGV4Lk5PREVfUEFSRU5UX1ZBTElEQVRJT05TW3R5cGVdKSA9PSBudWxsIHx8IF9OT0RFX1BBUkVOVF9WQUxJREFUSTIuY2FsbChfaW5kZXguTk9ERV9QQVJFTlRfVkFMSURBVElPTlMsIG5vZGUsIGtleSwgdmFsKTtcbn1cblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dmFsaWRhdGUuanMubWFwXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@babel/types/lib/validators/validate.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@babel/helper-globals/data/builtin-lower.json":
/*!********************************************************************!*\
  !*** ./node_modules/@babel/helper-globals/data/builtin-lower.json ***!
  \********************************************************************/
/***/ ((module) => {

module.exports = /*#__PURE__*/JSON.parse('["decodeURI","decodeURIComponent","encodeURI","encodeURIComponent","escape","eval","globalThis","isFinite","isNaN","parseFloat","parseInt","undefined","unescape"]');

/***/ }),

/***/ "(ssr)/./node_modules/@babel/helper-globals/data/builtin-upper.json":
/*!********************************************************************!*\
  !*** ./node_modules/@babel/helper-globals/data/builtin-upper.json ***!
  \********************************************************************/
/***/ ((module) => {

module.exports = /*#__PURE__*/JSON.parse('["AggregateError","Array","ArrayBuffer","Atomics","BigInt","BigInt64Array","BigUint64Array","Boolean","DataView","Date","Error","EvalError","FinalizationRegistry","Float16Array","Float32Array","Float64Array","Function","Infinity","Int16Array","Int32Array","Int8Array","Intl","Iterator","JSON","Map","Math","NaN","Number","Object","Promise","Proxy","RangeError","ReferenceError","Reflect","RegExp","Set","SharedArrayBuffer","String","Symbol","SyntaxError","TypeError","Uint16Array","Uint32Array","Uint8Array","Uint8ClampedArray","URIError","WeakMap","WeakRef","WeakSet"]');

/***/ })

};
;