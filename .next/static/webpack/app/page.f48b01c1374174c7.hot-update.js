"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/page",{

/***/ "(app-pages-browser)/./lib/browser-scan.ts":
/*!*****************************!*\
  !*** ./lib/browser-scan.ts ***!
  \*****************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   scanDirectoryHandle: function() { return /* binding */ scanDirectoryHandle; }\n/* harmony export */ });\n/* harmony import */ var ignore__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ignore */ \"(app-pages-browser)/./node_modules/ignore/index.js\");\n/* harmony import */ var ignore__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(ignore__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _babel_parser__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @babel/parser */ \"(app-pages-browser)/./node_modules/@babel/parser/lib/index.js\");\n/* harmony import */ var _babel_traverse__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @babel/traverse */ \"(app-pages-browser)/./node_modules/@babel/traverse/lib/index.js\");\n\n\n\nconst ALWAYS_IGNORE = [\n    \".git/\",\n    \"node_modules/\",\n    \".next/\",\n    \"dist/\",\n    \"build/\",\n    \"out/\",\n    \"coverage/\",\n    \".turbo/\",\n    \".cache/\",\n    \".DS_Store\"\n];\nconst SCRIPT_EXTENSIONS = new Set([\n    \".js\",\n    \".jsx\",\n    \".ts\",\n    \".tsx\",\n    \".mjs\",\n    \".cjs\"\n]);\nconst STYLE_EXTENSIONS = new Set([\n    \".css\",\n    \".scss\",\n    \".sass\"\n]);\nconst SUPPORTED_EXTENSIONS = new Set([\n    ...SCRIPT_EXTENSIONS,\n    ...STYLE_EXTENSIONS\n]);\nconst IMPORT_EXTENSIONS = [\n    \".ts\",\n    \".tsx\",\n    \".js\",\n    \".jsx\",\n    \".mjs\",\n    \".cjs\",\n    \".css\",\n    \".scss\",\n    \".sass\"\n];\nconst ROUTE_REGEX = {\n    app: /(^|\\/)app\\/(.*\\/)?(page|route)\\.(t|j)sx?$/,\n    pages: /(^|\\/)pages\\/.+\\.(t|j)sx?$/\n};\nconst posixJoin = function() {\n    for(var _len = arguments.length, parts = new Array(_len), _key = 0; _key < _len; _key++){\n        parts[_key] = arguments[_key];\n    }\n    return parts.filter(Boolean).join(\"/\").replace(/\\/+/g, \"/\");\n};\nconst posixDirname = (value)=>{\n    const idx = value.lastIndexOf(\"/\");\n    return idx === -1 ? \"\" : value.slice(0, idx);\n};\nconst posixBasename = (value)=>{\n    const idx = value.lastIndexOf(\"/\");\n    return idx === -1 ? value : value.slice(idx + 1);\n};\nconst posixExtname = (value)=>{\n    const base = posixBasename(value);\n    const idx = base.lastIndexOf(\".\");\n    return idx === -1 ? \"\" : base.slice(idx);\n};\nconst normalizePosixPath = (value)=>{\n    const parts = value.split(\"/\");\n    const stack = [];\n    let escapedRoot = false;\n    for (const part of parts){\n        if (!part || part === \".\") continue;\n        if (part === \"..\") {\n            if (stack.length) {\n                stack.pop();\n            } else {\n                escapedRoot = true;\n            }\n            continue;\n        }\n        stack.push(part);\n    }\n    return {\n        path: stack.join(\"/\"),\n        escapedRoot\n    };\n};\nconst normalizeGitignorePattern = (dirRel, rawPattern)=>{\n    let pattern = rawPattern.trim();\n    if (!pattern || pattern.startsWith(\"#\")) return null;\n    const negated = pattern.startsWith(\"!\");\n    if (negated) pattern = pattern.slice(1);\n    if (!pattern) return null;\n    const anchored = pattern.startsWith(\"/\");\n    if (anchored) pattern = pattern.slice(1);\n    const hasSlash = pattern.includes(\"/\");\n    const endsWithSlash = pattern.endsWith(\"/\");\n    const base = dirRel ? dirRel : \"\";\n    let prefixed = pattern;\n    if (base) {\n        if (anchored || hasSlash) {\n            prefixed = posixJoin(base, pattern);\n        } else {\n            prefixed = posixJoin(base, \"**\", pattern);\n        }\n    } else if (!anchored && !hasSlash) {\n        prefixed = posixJoin(\"**\", pattern);\n    }\n    if (endsWithSlash && !prefixed.endsWith(\"/\")) {\n        prefixed += \"/\";\n    }\n    return negated ? \"!\".concat(prefixed) : prefixed;\n};\nconst nodeTypeFromPath = (relPath)=>{\n    if (relPath === \"__external__\") return \"external\";\n    if (ROUTE_REGEX.app.test(relPath) || ROUTE_REGEX.pages.test(relPath)) {\n        if (relPath.includes(\"/pages/\") || relPath.startsWith(\"pages/\")) {\n            const basename = posixBasename(relPath);\n            if (basename.startsWith(\"_\")) return \"module\";\n        }\n        return \"route\";\n    }\n    if (STYLE_EXTENSIONS.has(posixExtname(relPath))) return \"style\";\n    return \"module\";\n};\nconst extractDependencies = (filePath, code)=>{\n    const dependencies = [];\n    if (SCRIPT_EXTENSIONS.has(posixExtname(filePath))) {\n        let ast = null;\n        try {\n            ast = (0,_babel_parser__WEBPACK_IMPORTED_MODULE_1__.parse)(code, {\n                sourceType: \"unambiguous\",\n                plugins: [\n                    \"jsx\",\n                    \"typescript\",\n                    \"dynamicImport\",\n                    \"decorators-legacy\",\n                    \"classProperties\",\n                    \"classPrivateProperties\",\n                    \"importAssertions\",\n                    \"topLevelAwait\"\n                ]\n            });\n        } catch (e) {\n            return dependencies;\n        }\n        (0,_babel_traverse__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(ast, {\n            ImportDeclaration (pathNode) {\n                const value = pathNode.node.source.value;\n                const imports = [];\n                pathNode.node.specifiers.forEach((specifier)=>{\n                    if (specifier.type === \"ImportDefaultSpecifier\") {\n                        imports.push({\n                            kind: \"default\",\n                            imported: \"default\",\n                            local: specifier.local.name\n                        });\n                    } else if (specifier.type === \"ImportSpecifier\") {\n                        const importedName = specifier.imported.type === \"Identifier\" ? specifier.imported.name : specifier.imported.value;\n                        imports.push({\n                            kind: \"named\",\n                            imported: importedName,\n                            local: specifier.local.name\n                        });\n                    } else if (specifier.type === \"ImportNamespaceSpecifier\") {\n                        imports.push({\n                            kind: \"namespace\",\n                            imported: \"*\",\n                            local: specifier.local.name\n                        });\n                    }\n                });\n                var _pathNode_node_start, _pathNode_node_end;\n                dependencies.push({\n                    specifier: value,\n                    type: \"static\",\n                    statement: code.slice((_pathNode_node_start = pathNode.node.start) !== null && _pathNode_node_start !== void 0 ? _pathNode_node_start : 0, (_pathNode_node_end = pathNode.node.end) !== null && _pathNode_node_end !== void 0 ? _pathNode_node_end : 0),\n                    loc: pathNode.node.loc ? {\n                        line: pathNode.node.loc.start.line,\n                        column: pathNode.node.loc.start.column\n                    } : undefined,\n                    imports: imports.length ? imports : undefined\n                });\n            },\n            ExportAllDeclaration (pathNode) {\n                if (!pathNode.node.source) return;\n                const value = pathNode.node.source.value;\n                var _pathNode_node_start, _pathNode_node_end;\n                dependencies.push({\n                    specifier: value,\n                    type: \"static\",\n                    statement: code.slice((_pathNode_node_start = pathNode.node.start) !== null && _pathNode_node_start !== void 0 ? _pathNode_node_start : 0, (_pathNode_node_end = pathNode.node.end) !== null && _pathNode_node_end !== void 0 ? _pathNode_node_end : 0),\n                    loc: pathNode.node.loc ? {\n                        line: pathNode.node.loc.start.line,\n                        column: pathNode.node.loc.start.column\n                    } : undefined\n                });\n            },\n            ExportNamedDeclaration (pathNode) {\n                if (!pathNode.node.source) return;\n                const value = pathNode.node.source.value;\n                var _pathNode_node_start, _pathNode_node_end;\n                dependencies.push({\n                    specifier: value,\n                    type: \"static\",\n                    statement: code.slice((_pathNode_node_start = pathNode.node.start) !== null && _pathNode_node_start !== void 0 ? _pathNode_node_start : 0, (_pathNode_node_end = pathNode.node.end) !== null && _pathNode_node_end !== void 0 ? _pathNode_node_end : 0),\n                    loc: pathNode.node.loc ? {\n                        line: pathNode.node.loc.start.line,\n                        column: pathNode.node.loc.start.column\n                    } : undefined\n                });\n            },\n            CallExpression (pathNode) {\n                const callee = pathNode.node.callee;\n                if (callee.type === \"Import\") {\n                    const arg = pathNode.node.arguments[0];\n                    if (arg && arg.type === \"StringLiteral\") {\n                        var _pathNode_node_start, _pathNode_node_end;\n                        dependencies.push({\n                            specifier: arg.value,\n                            type: \"dynamic\",\n                            statement: code.slice((_pathNode_node_start = pathNode.node.start) !== null && _pathNode_node_start !== void 0 ? _pathNode_node_start : 0, (_pathNode_node_end = pathNode.node.end) !== null && _pathNode_node_end !== void 0 ? _pathNode_node_end : 0),\n                            loc: pathNode.node.loc ? {\n                                line: pathNode.node.loc.start.line,\n                                column: pathNode.node.loc.start.column\n                            } : undefined\n                        });\n                    }\n                }\n                if (callee.type === \"Identifier\" && callee.name === \"require\") {\n                    const arg = pathNode.node.arguments[0];\n                    if (arg && arg.type === \"StringLiteral\") {\n                        var _pathNode_node_start1, _pathNode_node_end1;\n                        dependencies.push({\n                            specifier: arg.value,\n                            type: \"static\",\n                            statement: code.slice((_pathNode_node_start1 = pathNode.node.start) !== null && _pathNode_node_start1 !== void 0 ? _pathNode_node_start1 : 0, (_pathNode_node_end1 = pathNode.node.end) !== null && _pathNode_node_end1 !== void 0 ? _pathNode_node_end1 : 0),\n                            loc: pathNode.node.loc ? {\n                                line: pathNode.node.loc.start.line,\n                                column: pathNode.node.loc.start.column\n                            } : undefined\n                        });\n                    }\n                }\n            }\n        });\n    }\n    if (STYLE_EXTENSIONS.has(posixExtname(filePath))) {\n        const regex = /@import\\s+(?:url\\()?['\"]([^'\"]+)['\"]/g;\n        let match;\n        while(match = regex.exec(code)){\n            dependencies.push({\n                specifier: match[1],\n                type: \"style\",\n                statement: match[0]\n            });\n        }\n    }\n    return dependencies;\n};\nconst extractSymbols = (filePath, code)=>{\n    if (!SCRIPT_EXTENSIONS.has(posixExtname(filePath))) return [];\n    let ast = null;\n    try {\n        ast = (0,_babel_parser__WEBPACK_IMPORTED_MODULE_1__.parse)(code, {\n            sourceType: \"unambiguous\",\n            plugins: [\n                \"jsx\",\n                \"typescript\",\n                \"dynamicImport\",\n                \"decorators-legacy\",\n                \"classProperties\",\n                \"classPrivateProperties\",\n                \"importAssertions\",\n                \"topLevelAwait\"\n            ]\n        });\n    } catch (e) {\n        return [];\n    }\n    const localKinds = new Map();\n    (0,_babel_traverse__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(ast, {\n        FunctionDeclaration (pathNode) {\n            if (pathNode.parent.type !== \"Program\") return;\n            if (pathNode.node.id) localKinds.set(pathNode.node.id.name, \"function\");\n        },\n        ClassDeclaration (pathNode) {\n            if (pathNode.parent.type !== \"Program\") return;\n            if (pathNode.node.id) localKinds.set(pathNode.node.id.name, \"class\");\n        },\n        VariableDeclaration (pathNode) {\n            if (pathNode.parent.type !== \"Program\") return;\n            const kind = pathNode.node.kind;\n            pathNode.node.declarations.forEach((decl)=>{\n                if (decl.id.type === \"Identifier\") {\n                    localKinds.set(decl.id.name, kind);\n                }\n            });\n        },\n        TSInterfaceDeclaration (pathNode) {\n            if (pathNode.parent.type !== \"Program\") return;\n            localKinds.set(pathNode.node.id.name, \"interface\");\n        },\n        TSTypeAliasDeclaration (pathNode) {\n            if (pathNode.parent.type !== \"Program\") return;\n            localKinds.set(pathNode.node.id.name, \"type\");\n        },\n        TSEnumDeclaration (pathNode) {\n            if (pathNode.parent.type !== \"Program\") return;\n            localKinds.set(pathNode.node.id.name, \"enum\");\n        }\n    });\n    const symbols = [];\n    const seen = new Set();\n    const addSymbol = (symbol)=>{\n        if (seen.has(symbol.name)) return;\n        seen.add(symbol.name);\n        symbols.push(symbol);\n    };\n    (0,_babel_traverse__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(ast, {\n        ExportNamedDeclaration (pathNode) {\n            const decl = pathNode.node.declaration;\n            if (decl) {\n                if (decl.type === \"FunctionDeclaration\" && decl.id) {\n                    addSymbol({\n                        name: decl.id.name,\n                        kind: \"function\"\n                    });\n                } else if (decl.type === \"ClassDeclaration\" && decl.id) {\n                    addSymbol({\n                        name: decl.id.name,\n                        kind: \"class\"\n                    });\n                } else if (decl.type === \"VariableDeclaration\") {\n                    decl.declarations.forEach((item)=>{\n                        if (item.id.type === \"Identifier\") {\n                            addSymbol({\n                                name: item.id.name,\n                                kind: decl.kind\n                            });\n                        }\n                    });\n                } else if (decl.type === \"TSInterfaceDeclaration\") {\n                    addSymbol({\n                        name: decl.id.name,\n                        kind: \"interface\"\n                    });\n                } else if (decl.type === \"TSTypeAliasDeclaration\") {\n                    addSymbol({\n                        name: decl.id.name,\n                        kind: \"type\"\n                    });\n                } else if (decl.type === \"TSEnumDeclaration\") {\n                    addSymbol({\n                        name: decl.id.name,\n                        kind: \"enum\"\n                    });\n                }\n                return;\n            }\n            if (pathNode.node.specifiers.length) {\n                pathNode.node.specifiers.forEach((specifier)=>{\n                    if (specifier.type !== \"ExportSpecifier\") return;\n                    const exportedName = specifier.exported.type === \"Identifier\" ? specifier.exported.name : specifier.exported.value;\n                    const localName = specifier.local.type === \"Identifier\" ? specifier.local.name : specifier.local.value;\n                    var _localKinds_get;\n                    addSymbol({\n                        name: exportedName,\n                        kind: (_localKinds_get = localKinds.get(localName)) !== null && _localKinds_get !== void 0 ? _localKinds_get : \"export\"\n                    });\n                });\n            }\n        },\n        ExportDefaultDeclaration (pathNode) {\n            const decl = pathNode.node.declaration;\n            if (decl.type === \"FunctionDeclaration\") {\n                var _decl_id;\n                addSymbol({\n                    name: \"default\",\n                    kind: \"function\",\n                    displayName: (_decl_id = decl.id) === null || _decl_id === void 0 ? void 0 : _decl_id.name\n                });\n            } else if (decl.type === \"ClassDeclaration\") {\n                var _decl_id1;\n                addSymbol({\n                    name: \"default\",\n                    kind: \"class\",\n                    displayName: (_decl_id1 = decl.id) === null || _decl_id1 === void 0 ? void 0 : _decl_id1.name\n                });\n            } else if (decl.type === \"Identifier\") {\n                var _localKinds_get;\n                addSymbol({\n                    name: \"default\",\n                    kind: (_localKinds_get = localKinds.get(decl.name)) !== null && _localKinds_get !== void 0 ? _localKinds_get : \"export\",\n                    displayName: decl.name\n                });\n            } else {\n                addSymbol({\n                    name: \"default\",\n                    kind: \"export\"\n                });\n            }\n        }\n    });\n    return symbols;\n};\nconst resolveWithExtensions = (basePath, fileSet, dirSet)=>{\n    if (!basePath) return null;\n    if (fileSet.has(basePath)) return basePath;\n    if (dirSet.has(basePath)) {\n        for (const ext of IMPORT_EXTENSIONS){\n            const indexPath = posixJoin(basePath, \"index\".concat(ext));\n            if (fileSet.has(indexPath)) return indexPath;\n        }\n    }\n    if (!posixExtname(basePath)) {\n        for (const ext of IMPORT_EXTENSIONS){\n            const filePath = \"\".concat(basePath).concat(ext);\n            if (fileSet.has(filePath)) return filePath;\n        }\n    }\n    return null;\n};\nconst resolveImport = (fromFile, specifier, fileSet, dirSet)=>{\n    if (!specifier || specifier.startsWith(\"http\")) return null;\n    const cleanSpecifier = specifier.split(\"?\")[0].split(\"#\")[0];\n    let targetPath = null;\n    let escapedRoot = false;\n    if (cleanSpecifier.startsWith(\"@/\")) {\n        const normalized = normalizePosixPath(cleanSpecifier.slice(2));\n        targetPath = normalized.path;\n        escapedRoot = normalized.escapedRoot;\n    } else if (cleanSpecifier.startsWith(\"/\")) {\n        const normalized = normalizePosixPath(cleanSpecifier.slice(1));\n        targetPath = normalized.path;\n        escapedRoot = normalized.escapedRoot;\n    } else if (cleanSpecifier.startsWith(\".\")) {\n        const fromDir = posixDirname(fromFile);\n        const normalized = normalizePosixPath(posixJoin(fromDir, cleanSpecifier));\n        targetPath = normalized.path;\n        escapedRoot = normalized.escapedRoot;\n    } else {\n        return {\n            external: true,\n            resolved: null\n        };\n    }\n    if (!targetPath || escapedRoot) {\n        return {\n            external: true,\n            resolved: null\n        };\n    }\n    const resolved = resolveWithExtensions(targetPath, fileSet, dirSet);\n    if (!resolved) return {\n        external: true,\n        resolved: null\n    };\n    return {\n        external: false,\n        resolved\n    };\n};\nconst hashId = (value)=>{\n    let h1 = 0xdeadbeef ^ value.length;\n    let h2 = 0x41c6ce57 ^ value.length;\n    for(let i = 0; i < value.length; i += 1){\n        const ch = value.charCodeAt(i);\n        h1 = Math.imul(h1 ^ ch, 2654435761);\n        h2 = Math.imul(h2 ^ ch, 1597334677);\n    }\n    h1 = Math.imul(h1 ^ h1 >>> 16, 2246822507);\n    h2 = Math.imul(h2 ^ h2 >>> 16, 2246822507);\n    return \"\".concat((h1 >>> 0).toString(16)).concat((h2 >>> 0).toString(16));\n};\nconst scanDirectoryHandle = async (options)=>{\n    const { rootHandle, maxFiles, includeExternal } = options;\n    var _options_granularity;\n    const granularity = (_options_granularity = options.granularity) !== null && _options_granularity !== void 0 ? _options_granularity : \"file\";\n    const rootLabel = rootHandle.name || \"Selected folder\";\n    const nodes = new Map();\n    const edges = [];\n    const edgeKeys = new Set();\n    const ignoredNodes = [];\n    const fileHandles = new Map();\n    const fileContents = new Map();\n    const dirSet = new Set([\n        \"\"\n    ]);\n    const symbolMap = new Map();\n    let totalFiles = 0;\n    let ignoredCount = 0;\n    let externalCount = 0;\n    const walk = async (dirHandle, relDir, patterns)=>{\n        dirSet.add(relDir);\n        const gitignoreHandle = await dirHandle.getFileHandle(\".gitignore\").catch(()=>null);\n        let combinedPatterns = patterns;\n        if (gitignoreHandle) {\n            const gitignoreFile = await gitignoreHandle.getFile().catch(()=>null);\n            const gitignoreContent = await (gitignoreFile === null || gitignoreFile === void 0 ? void 0 : gitignoreFile.text());\n            if (gitignoreContent) {\n                const extraPatterns = gitignoreContent.split(/\\r?\\n/).map((line)=>normalizeGitignorePattern(relDir, line)).filter((value)=>Boolean(value));\n                combinedPatterns = patterns.concat(extraPatterns);\n            }\n        }\n        const ig = ignore__WEBPACK_IMPORTED_MODULE_0___default()().add(combinedPatterns);\n        for await (const [name, handle] of dirHandle.entries()){\n            const relPath = relDir ? \"\".concat(relDir, \"/\").concat(name) : name;\n            if (!relPath) continue;\n            if (ig.ignores(relPath)) {\n                ignoredCount += 1;\n                if (handle.kind === \"file\" && SUPPORTED_EXTENSIONS.has(posixExtname(relPath))) {\n                    ignoredNodes.push({\n                        id: relPath,\n                        path: relPath,\n                        label: posixBasename(relPath),\n                        type: nodeTypeFromPath(relPath),\n                        ignored: true\n                    });\n                }\n                continue;\n            }\n            if (handle.kind === \"directory\") {\n                await walk(handle, relPath, combinedPatterns);\n                continue;\n            }\n            totalFiles += 1;\n            if (totalFiles > maxFiles) {\n                throw new Error(\"File limit exceeded (\".concat(maxFiles, \"). Adjust the max files setting to continue.\"));\n            }\n            if (!SUPPORTED_EXTENSIONS.has(posixExtname(relPath))) continue;\n            nodes.set(relPath, {\n                id: relPath,\n                path: relPath,\n                label: posixBasename(relPath),\n                type: nodeTypeFromPath(relPath)\n            });\n            fileHandles.set(relPath, handle);\n        }\n    };\n    await walk(rootHandle, \"\", ALWAYS_IGNORE);\n    for (const ignoredNode of ignoredNodes){\n        nodes.set(ignoredNode.id, ignoredNode);\n    }\n    const fileSet = new Set(fileHandles.keys());\n    if (granularity === \"symbol\") {\n        for (const [relPath, handle] of fileHandles.entries()){\n            const file = await handle.getFile().catch(()=>null);\n            const code = await (file === null || file === void 0 ? void 0 : file.text());\n            if (!code) continue;\n            fileContents.set(relPath, code);\n            const symbols = extractSymbols(relPath, code);\n            if (!symbols.length) continue;\n            const entry = new Map();\n            for (const symbol of symbols){\n                const symbolId = \"\".concat(relPath, \"::\").concat(symbol.name);\n                entry.set(symbol.name, symbol);\n                if (!nodes.has(symbolId)) {\n                    nodes.set(symbolId, {\n                        id: symbolId,\n                        path: \"\".concat(relPath, \"#\").concat(symbol.name),\n                        label: symbol.name,\n                        type: \"symbol\",\n                        symbolKind: symbol.kind,\n                        parent: relPath,\n                        displayName: symbol.displayName\n                    });\n                }\n                const containsKey = \"\".concat(relPath, \"|\").concat(symbolId, \"|contains\");\n                if (!edgeKeys.has(containsKey)) {\n                    edgeKeys.add(containsKey);\n                    edges.push({\n                        id: hashId(containsKey),\n                        source: relPath,\n                        target: symbolId,\n                        type: \"contains\"\n                    });\n                }\n            }\n            symbolMap.set(relPath, entry);\n        }\n    }\n    for (const [relPath, handle] of fileHandles.entries()){\n        const file = await handle.getFile().catch(()=>null);\n        var _fileContents_get;\n        const code = (_fileContents_get = fileContents.get(relPath)) !== null && _fileContents_get !== void 0 ? _fileContents_get : await (file === null || file === void 0 ? void 0 : file.text());\n        if (!code) continue;\n        const dependencies = extractDependencies(relPath, code);\n        for (const dep of dependencies){\n            var _dep_imports, _dep_statement;\n            const resolved = resolveImport(relPath, dep.specifier, fileSet, dirSet);\n            if (!resolved) continue;\n            if (resolved.external) {\n                externalCount += 1;\n                if (!includeExternal) continue;\n                if (!nodes.has(\"__external__\")) {\n                    nodes.set(\"__external__\", {\n                        id: \"__external__\",\n                        path: \"__external__\",\n                        label: \"External\",\n                        type: \"external\"\n                    });\n                }\n                const edgeKey = \"\".concat(relPath, \"|__external__|external|\").concat(dep.specifier);\n                if (edgeKeys.has(edgeKey)) continue;\n                edgeKeys.add(edgeKey);\n                edges.push({\n                    id: hashId(edgeKey),\n                    source: relPath,\n                    target: \"__external__\",\n                    type: \"external\",\n                    statement: dep.statement,\n                    loc: dep.loc\n                });\n                continue;\n            }\n            if (!resolved.resolved) continue;\n            const targetRel = resolved.resolved;\n            if (!nodes.has(targetRel)) {\n                nodes.set(targetRel, {\n                    id: targetRel,\n                    path: targetRel,\n                    label: posixBasename(targetRel),\n                    type: nodeTypeFromPath(targetRel)\n                });\n            }\n            if (granularity === \"symbol\" && ((_dep_imports = dep.imports) === null || _dep_imports === void 0 ? void 0 : _dep_imports.length)) {\n                const targetSymbols = symbolMap.get(targetRel);\n                let createdSymbolEdge = false;\n                if (targetSymbols) {\n                    for (const binding of dep.imports){\n                        var _dep_statement1;\n                        if (binding.kind === \"namespace\") continue;\n                        const importName = binding.kind === \"default\" ? \"default\" : binding.imported;\n                        const symbol = targetSymbols.get(importName);\n                        if (!symbol) continue;\n                        const symbolId = \"\".concat(targetRel, \"::\").concat(importName);\n                        var _dep_statement2;\n                        const edgeKey = \"\".concat(relPath, \"|\").concat(symbolId, \"|\").concat(dep.type, \"|\").concat((_dep_statement2 = dep.statement) !== null && _dep_statement2 !== void 0 ? _dep_statement2 : \"\");\n                        if (edgeKeys.has(edgeKey)) continue;\n                        edgeKeys.add(edgeKey);\n                        edges.push({\n                            id: hashId(edgeKey),\n                            source: relPath,\n                            target: symbolId,\n                            type: dep.type,\n                            statement: (_dep_statement1 = dep.statement) === null || _dep_statement1 === void 0 ? void 0 : _dep_statement1.slice(0, 200),\n                            loc: dep.loc\n                        });\n                        createdSymbolEdge = true;\n                    }\n                }\n                if (createdSymbolEdge) continue;\n            }\n            const targetExt = posixExtname(targetRel);\n            const edgeType = STYLE_EXTENSIONS.has(targetExt) ? \"style\" : dep.type;\n            var _dep_statement3;\n            const edgeKey = \"\".concat(relPath, \"|\").concat(targetRel, \"|\").concat(edgeType, \"|\").concat((_dep_statement3 = dep.statement) !== null && _dep_statement3 !== void 0 ? _dep_statement3 : \"\");\n            if (edgeKeys.has(edgeKey)) continue;\n            edgeKeys.add(edgeKey);\n            edges.push({\n                id: hashId(edgeKey),\n                source: relPath,\n                target: targetRel,\n                type: edgeType,\n                statement: (_dep_statement = dep.statement) === null || _dep_statement === void 0 ? void 0 : _dep_statement.slice(0, 200),\n                loc: dep.loc\n            });\n        }\n    }\n    return {\n        root: rootLabel,\n        nodes: Array.from(nodes.values()),\n        edges,\n        totalFiles,\n        ignoredCount,\n        externalCount\n    };\n};\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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T0FBT2tELE1BQU1DLElBQUksQ0FBQ25ELE1BQU1vRCxNQUFNO1FBQzlCbkQ7UUFDQU07UUFDQUM7UUFDQUM7SUFDRjtBQUNGLEVBQUUiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbGliL2Jyb3dzZXItc2Nhbi50cz8zMDBmIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBpZ25vcmUgZnJvbSAnaWdub3JlJztcbmltcG9ydCB7IHBhcnNlIH0gZnJvbSAnQGJhYmVsL3BhcnNlcic7XG5pbXBvcnQgdHJhdmVyc2UgZnJvbSAnQGJhYmVsL3RyYXZlcnNlJztcbmltcG9ydCB0eXBlIHsgRmlsZSB9IGZyb20gJ0BiYWJlbC90eXBlcyc7XG5pbXBvcnQgdHlwZSB7IEVkZ2VUeXBlLCBHcmFwaERhdGEsIEdyYXBoRWRnZSwgR3JhcGhOb2RlIH0gZnJvbSAnLi90eXBlcyc7XG5cbmNvbnN0IEFMV0FZU19JR05PUkUgPSBbXG4gICcuZ2l0LycsXG4gICdub2RlX21vZHVsZXMvJyxcbiAgJy5uZXh0LycsXG4gICdkaXN0LycsXG4gICdidWlsZC8nLFxuICAnb3V0LycsXG4gICdjb3ZlcmFnZS8nLFxuICAnLnR1cmJvLycsXG4gICcuY2FjaGUvJyxcbiAgJy5EU19TdG9yZSdcbl07XG5cbmNvbnN0IFNDUklQVF9FWFRFTlNJT05TID0gbmV3IFNldChbXG4gICcuanMnLFxuICAnLmpzeCcsXG4gICcudHMnLFxuICAnLnRzeCcsXG4gICcubWpzJyxcbiAgJy5janMnXG5dKTtcbmNvbnN0IFNUWUxFX0VYVEVOU0lPTlMgPSBuZXcgU2V0KFsnLmNzcycsICcuc2NzcycsICcuc2FzcyddKTtcbmNvbnN0IFNVUFBPUlRFRF9FWFRFTlNJT05TID0gbmV3IFNldChbXG4gIC4uLlNDUklQVF9FWFRFTlNJT05TLFxuICAuLi5TVFlMRV9FWFRFTlNJT05TXG5dKTtcblxuY29uc3QgSU1QT1JUX0VYVEVOU0lPTlMgPSBbXG4gICcudHMnLFxuICAnLnRzeCcsXG4gICcuanMnLFxuICAnLmpzeCcsXG4gICcubWpzJyxcbiAgJy5janMnLFxuICAnLmNzcycsXG4gICcuc2NzcycsXG4gICcuc2Fzcydcbl07XG5cbmNvbnN0IFJPVVRFX1JFR0VYID0ge1xuICBhcHA6IC8oXnxcXC8pYXBwXFwvKC4qXFwvKT8ocGFnZXxyb3V0ZSlcXC4odHxqKXN4PyQvLFxuICBwYWdlczogLyhefFxcLylwYWdlc1xcLy4rXFwuKHR8ailzeD8kL1xufTtcblxudHlwZSBEZXBlbmRlbmN5ID0ge1xuICBzcGVjaWZpZXI6IHN0cmluZztcbiAgdHlwZTogRWRnZVR5cGU7XG4gIHN0YXRlbWVudD86IHN0cmluZztcbiAgbG9jPzogeyBsaW5lOiBudW1iZXI7IGNvbHVtbjogbnVtYmVyIH07XG4gIGltcG9ydHM/OiBJbXBvcnRCaW5kaW5nW107XG59O1xuXG50eXBlIEJyb3dzZXJTY2FuT3B0aW9ucyA9IHtcbiAgcm9vdEhhbmRsZTogRmlsZVN5c3RlbURpcmVjdG9yeUhhbmRsZTtcbiAgbWF4RmlsZXM6IG51bWJlcjtcbiAgaW5jbHVkZUV4dGVybmFsOiBib29sZWFuO1xuICBncmFudWxhcml0eT86IFNjYW5HcmFudWxhcml0eTtcbn07XG5cbnR5cGUgU2NhbkdyYW51bGFyaXR5ID0gJ2ZpbGUnIHwgJ3N5bWJvbCc7XG5cbnR5cGUgSW1wb3J0QmluZGluZyA9IHtcbiAga2luZDogJ2RlZmF1bHQnIHwgJ25hbWVkJyB8ICduYW1lc3BhY2UnO1xuICBpbXBvcnRlZDogc3RyaW5nO1xuICBsb2NhbDogc3RyaW5nO1xufTtcblxudHlwZSBTeW1ib2xJbmZvID0ge1xuICBuYW1lOiBzdHJpbmc7XG4gIGtpbmQ6IHN0cmluZztcbiAgZGlzcGxheU5hbWU/OiBzdHJpbmc7XG59O1xuXG5jb25zdCBwb3NpeEpvaW4gPSAoLi4ucGFydHM6IHN0cmluZ1tdKSA9PlxuICBwYXJ0c1xuICAgIC5maWx0ZXIoQm9vbGVhbilcbiAgICAuam9pbignLycpXG4gICAgLnJlcGxhY2UoL1xcLysvZywgJy8nKTtcblxuY29uc3QgcG9zaXhEaXJuYW1lID0gKHZhbHVlOiBzdHJpbmcpID0+IHtcbiAgY29uc3QgaWR4ID0gdmFsdWUubGFzdEluZGV4T2YoJy8nKTtcbiAgcmV0dXJuIGlkeCA9PT0gLTEgPyAnJyA6IHZhbHVlLnNsaWNlKDAsIGlkeCk7XG59O1xuXG5jb25zdCBwb3NpeEJhc2VuYW1lID0gKHZhbHVlOiBzdHJpbmcpID0+IHtcbiAgY29uc3QgaWR4ID0gdmFsdWUubGFzdEluZGV4T2YoJy8nKTtcbiAgcmV0dXJuIGlkeCA9PT0gLTEgPyB2YWx1ZSA6IHZhbHVlLnNsaWNlKGlkeCArIDEpO1xufTtcblxuY29uc3QgcG9zaXhFeHRuYW1lID0gKHZhbHVlOiBzdHJpbmcpID0+IHtcbiAgY29uc3QgYmFzZSA9IHBvc2l4QmFzZW5hbWUodmFsdWUpO1xuICBjb25zdCBpZHggPSBiYXNlLmxhc3RJbmRleE9mKCcuJyk7XG4gIHJldHVybiBpZHggPT09IC0xID8gJycgOiBiYXNlLnNsaWNlKGlkeCk7XG59O1xuXG5jb25zdCBub3JtYWxpemVQb3NpeFBhdGggPSAodmFsdWU6IHN0cmluZykgPT4ge1xuICBjb25zdCBwYXJ0cyA9IHZhbHVlLnNwbGl0KCcvJyk7XG4gIGNvbnN0IHN0YWNrOiBzdHJpbmdbXSA9IFtdO1xuICBsZXQgZXNjYXBlZFJvb3QgPSBmYWxzZTtcblxuICBmb3IgKGNvbnN0IHBhcnQgb2YgcGFydHMpIHtcbiAgICBpZiAoIXBhcnQgfHwgcGFydCA9PT0gJy4nKSBjb250aW51ZTtcbiAgICBpZiAocGFydCA9PT0gJy4uJykge1xuICAgICAgaWYgKHN0YWNrLmxlbmd0aCkge1xuICAgICAgICBzdGFjay5wb3AoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGVzY2FwZWRSb290ID0gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICBzdGFjay5wdXNoKHBhcnQpO1xuICB9XG5cbiAgcmV0dXJuIHsgcGF0aDogc3RhY2suam9pbignLycpLCBlc2NhcGVkUm9vdCB9O1xufTtcblxuY29uc3Qgbm9ybWFsaXplR2l0aWdub3JlUGF0dGVybiA9IChkaXJSZWw6IHN0cmluZywgcmF3UGF0dGVybjogc3RyaW5nKSA9PiB7XG4gIGxldCBwYXR0ZXJuID0gcmF3UGF0dGVybi50cmltKCk7XG4gIGlmICghcGF0dGVybiB8fCBwYXR0ZXJuLnN0YXJ0c1dpdGgoJyMnKSkgcmV0dXJuIG51bGw7XG4gIGNvbnN0IG5lZ2F0ZWQgPSBwYXR0ZXJuLnN0YXJ0c1dpdGgoJyEnKTtcbiAgaWYgKG5lZ2F0ZWQpIHBhdHRlcm4gPSBwYXR0ZXJuLnNsaWNlKDEpO1xuICBpZiAoIXBhdHRlcm4pIHJldHVybiBudWxsO1xuXG4gIGNvbnN0IGFuY2hvcmVkID0gcGF0dGVybi5zdGFydHNXaXRoKCcvJyk7XG4gIGlmIChhbmNob3JlZCkgcGF0dGVybiA9IHBhdHRlcm4uc2xpY2UoMSk7XG5cbiAgY29uc3QgaGFzU2xhc2ggPSBwYXR0ZXJuLmluY2x1ZGVzKCcvJyk7XG4gIGNvbnN0IGVuZHNXaXRoU2xhc2ggPSBwYXR0ZXJuLmVuZHNXaXRoKCcvJyk7XG5cbiAgY29uc3QgYmFzZSA9IGRpclJlbCA/IGRpclJlbCA6ICcnO1xuXG4gIGxldCBwcmVmaXhlZCA9IHBhdHRlcm47XG5cbiAgaWYgKGJhc2UpIHtcbiAgICBpZiAoYW5jaG9yZWQgfHwgaGFzU2xhc2gpIHtcbiAgICAgIHByZWZpeGVkID0gcG9zaXhKb2luKGJhc2UsIHBhdHRlcm4pO1xuICAgIH0gZWxzZSB7XG4gICAgICBwcmVmaXhlZCA9IHBvc2l4Sm9pbihiYXNlLCAnKionLCBwYXR0ZXJuKTtcbiAgICB9XG4gIH0gZWxzZSBpZiAoIWFuY2hvcmVkICYmICFoYXNTbGFzaCkge1xuICAgIHByZWZpeGVkID0gcG9zaXhKb2luKCcqKicsIHBhdHRlcm4pO1xuICB9XG5cbiAgaWYgKGVuZHNXaXRoU2xhc2ggJiYgIXByZWZpeGVkLmVuZHNXaXRoKCcvJykpIHtcbiAgICBwcmVmaXhlZCArPSAnLyc7XG4gIH1cblxuICByZXR1cm4gbmVnYXRlZCA/IGAhJHtwcmVmaXhlZH1gIDogcHJlZml4ZWQ7XG59O1xuXG5jb25zdCBub2RlVHlwZUZyb21QYXRoID0gKHJlbFBhdGg6IHN0cmluZykgPT4ge1xuICBpZiAocmVsUGF0aCA9PT0gJ19fZXh0ZXJuYWxfXycpIHJldHVybiAnZXh0ZXJuYWwnO1xuICBpZiAoUk9VVEVfUkVHRVguYXBwLnRlc3QocmVsUGF0aCkgfHwgUk9VVEVfUkVHRVgucGFnZXMudGVzdChyZWxQYXRoKSkge1xuICAgIGlmIChyZWxQYXRoLmluY2x1ZGVzKCcvcGFnZXMvJykgfHwgcmVsUGF0aC5zdGFydHNXaXRoKCdwYWdlcy8nKSkge1xuICAgICAgY29uc3QgYmFzZW5hbWUgPSBwb3NpeEJhc2VuYW1lKHJlbFBhdGgpO1xuICAgICAgaWYgKGJhc2VuYW1lLnN0YXJ0c1dpdGgoJ18nKSkgcmV0dXJuICdtb2R1bGUnO1xuICAgIH1cbiAgICByZXR1cm4gJ3JvdXRlJztcbiAgfVxuICBpZiAoU1RZTEVfRVhURU5TSU9OUy5oYXMocG9zaXhFeHRuYW1lKHJlbFBhdGgpKSkgcmV0dXJuICdzdHlsZSc7XG4gIHJldHVybiAnbW9kdWxlJztcbn07XG5cbmNvbnN0IGV4dHJhY3REZXBlbmRlbmNpZXMgPSAoZmlsZVBhdGg6IHN0cmluZywgY29kZTogc3RyaW5nKTogRGVwZW5kZW5jeVtdID0+IHtcbiAgY29uc3QgZGVwZW5kZW5jaWVzOiBEZXBlbmRlbmN5W10gPSBbXTtcblxuICBpZiAoU0NSSVBUX0VYVEVOU0lPTlMuaGFzKHBvc2l4RXh0bmFtZShmaWxlUGF0aCkpKSB7XG4gICAgbGV0IGFzdDogRmlsZSB8IG51bGwgPSBudWxsO1xuICAgIHRyeSB7XG4gICAgICBhc3QgPSBwYXJzZShjb2RlLCB7XG4gICAgICAgIHNvdXJjZVR5cGU6ICd1bmFtYmlndW91cycsXG4gICAgICAgIHBsdWdpbnM6IFtcbiAgICAgICAgICAnanN4JyxcbiAgICAgICAgICAndHlwZXNjcmlwdCcsXG4gICAgICAgICAgJ2R5bmFtaWNJbXBvcnQnLFxuICAgICAgICAgICdkZWNvcmF0b3JzLWxlZ2FjeScsXG4gICAgICAgICAgJ2NsYXNzUHJvcGVydGllcycsXG4gICAgICAgICAgJ2NsYXNzUHJpdmF0ZVByb3BlcnRpZXMnLFxuICAgICAgICAgICdpbXBvcnRBc3NlcnRpb25zJyxcbiAgICAgICAgICAndG9wTGV2ZWxBd2FpdCdcbiAgICAgICAgXVxuICAgICAgfSk7XG4gICAgfSBjYXRjaCB7XG4gICAgICByZXR1cm4gZGVwZW5kZW5jaWVzO1xuICAgIH1cblxuICAgIHRyYXZlcnNlKGFzdCwge1xuICAgICAgSW1wb3J0RGVjbGFyYXRpb24ocGF0aE5vZGUpIHtcbiAgICAgICAgY29uc3QgdmFsdWUgPSBwYXRoTm9kZS5ub2RlLnNvdXJjZS52YWx1ZTtcbiAgICAgICAgY29uc3QgaW1wb3J0czogSW1wb3J0QmluZGluZ1tdID0gW107XG4gICAgICAgIHBhdGhOb2RlLm5vZGUuc3BlY2lmaWVycy5mb3JFYWNoKChzcGVjaWZpZXIpID0+IHtcbiAgICAgICAgICBpZiAoc3BlY2lmaWVyLnR5cGUgPT09ICdJbXBvcnREZWZhdWx0U3BlY2lmaWVyJykge1xuICAgICAgICAgICAgaW1wb3J0cy5wdXNoKHtcbiAgICAgICAgICAgICAga2luZDogJ2RlZmF1bHQnLFxuICAgICAgICAgICAgICBpbXBvcnRlZDogJ2RlZmF1bHQnLFxuICAgICAgICAgICAgICBsb2NhbDogc3BlY2lmaWVyLmxvY2FsLm5hbWVcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH0gZWxzZSBpZiAoc3BlY2lmaWVyLnR5cGUgPT09ICdJbXBvcnRTcGVjaWZpZXInKSB7XG4gICAgICAgICAgICBjb25zdCBpbXBvcnRlZE5hbWUgPVxuICAgICAgICAgICAgICBzcGVjaWZpZXIuaW1wb3J0ZWQudHlwZSA9PT0gJ0lkZW50aWZpZXInXG4gICAgICAgICAgICAgICAgPyBzcGVjaWZpZXIuaW1wb3J0ZWQubmFtZVxuICAgICAgICAgICAgICAgIDogc3BlY2lmaWVyLmltcG9ydGVkLnZhbHVlO1xuICAgICAgICAgICAgaW1wb3J0cy5wdXNoKHtcbiAgICAgICAgICAgICAga2luZDogJ25hbWVkJyxcbiAgICAgICAgICAgICAgaW1wb3J0ZWQ6IGltcG9ydGVkTmFtZSxcbiAgICAgICAgICAgICAgbG9jYWw6IHNwZWNpZmllci5sb2NhbC5uYW1lXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9IGVsc2UgaWYgKHNwZWNpZmllci50eXBlID09PSAnSW1wb3J0TmFtZXNwYWNlU3BlY2lmaWVyJykge1xuICAgICAgICAgICAgaW1wb3J0cy5wdXNoKHtcbiAgICAgICAgICAgICAga2luZDogJ25hbWVzcGFjZScsXG4gICAgICAgICAgICAgIGltcG9ydGVkOiAnKicsXG4gICAgICAgICAgICAgIGxvY2FsOiBzcGVjaWZpZXIubG9jYWwubmFtZVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgZGVwZW5kZW5jaWVzLnB1c2goe1xuICAgICAgICAgIHNwZWNpZmllcjogdmFsdWUsXG4gICAgICAgICAgdHlwZTogJ3N0YXRpYycsXG4gICAgICAgICAgc3RhdGVtZW50OiBjb2RlLnNsaWNlKHBhdGhOb2RlLm5vZGUuc3RhcnQgPz8gMCwgcGF0aE5vZGUubm9kZS5lbmQgPz8gMCksXG4gICAgICAgICAgbG9jOiBwYXRoTm9kZS5ub2RlLmxvY1xuICAgICAgICAgICAgPyB7IGxpbmU6IHBhdGhOb2RlLm5vZGUubG9jLnN0YXJ0LmxpbmUsIGNvbHVtbjogcGF0aE5vZGUubm9kZS5sb2Muc3RhcnQuY29sdW1uIH1cbiAgICAgICAgICAgIDogdW5kZWZpbmVkLFxuICAgICAgICAgIGltcG9ydHM6IGltcG9ydHMubGVuZ3RoID8gaW1wb3J0cyA6IHVuZGVmaW5lZFxuICAgICAgICB9KTtcbiAgICAgIH0sXG4gICAgICBFeHBvcnRBbGxEZWNsYXJhdGlvbihwYXRoTm9kZSkge1xuICAgICAgICBpZiAoIXBhdGhOb2RlLm5vZGUuc291cmNlKSByZXR1cm47XG4gICAgICAgIGNvbnN0IHZhbHVlID0gcGF0aE5vZGUubm9kZS5zb3VyY2UudmFsdWU7XG4gICAgICAgIGRlcGVuZGVuY2llcy5wdXNoKHtcbiAgICAgICAgICBzcGVjaWZpZXI6IHZhbHVlLFxuICAgICAgICAgIHR5cGU6ICdzdGF0aWMnLFxuICAgICAgICAgIHN0YXRlbWVudDogY29kZS5zbGljZShwYXRoTm9kZS5ub2RlLnN0YXJ0ID8/IDAsIHBhdGhOb2RlLm5vZGUuZW5kID8/IDApLFxuICAgICAgICAgIGxvYzogcGF0aE5vZGUubm9kZS5sb2NcbiAgICAgICAgICAgID8geyBsaW5lOiBwYXRoTm9kZS5ub2RlLmxvYy5zdGFydC5saW5lLCBjb2x1bW46IHBhdGhOb2RlLm5vZGUubG9jLnN0YXJ0LmNvbHVtbiB9XG4gICAgICAgICAgICA6IHVuZGVmaW5lZFxuICAgICAgICB9KTtcbiAgICAgIH0sXG4gICAgICBFeHBvcnROYW1lZERlY2xhcmF0aW9uKHBhdGhOb2RlKSB7XG4gICAgICAgIGlmICghcGF0aE5vZGUubm9kZS5zb3VyY2UpIHJldHVybjtcbiAgICAgICAgY29uc3QgdmFsdWUgPSBwYXRoTm9kZS5ub2RlLnNvdXJjZS52YWx1ZTtcbiAgICAgICAgZGVwZW5kZW5jaWVzLnB1c2goe1xuICAgICAgICAgIHNwZWNpZmllcjogdmFsdWUsXG4gICAgICAgICAgdHlwZTogJ3N0YXRpYycsXG4gICAgICAgICAgc3RhdGVtZW50OiBjb2RlLnNsaWNlKHBhdGhOb2RlLm5vZGUuc3RhcnQgPz8gMCwgcGF0aE5vZGUubm9kZS5lbmQgPz8gMCksXG4gICAgICAgICAgbG9jOiBwYXRoTm9kZS5ub2RlLmxvY1xuICAgICAgICAgICAgPyB7IGxpbmU6IHBhdGhOb2RlLm5vZGUubG9jLnN0YXJ0LmxpbmUsIGNvbHVtbjogcGF0aE5vZGUubm9kZS5sb2Muc3RhcnQuY29sdW1uIH1cbiAgICAgICAgICAgIDogdW5kZWZpbmVkXG4gICAgICAgIH0pO1xuICAgICAgfSxcbiAgICAgIENhbGxFeHByZXNzaW9uKHBhdGhOb2RlKSB7XG4gICAgICAgIGNvbnN0IGNhbGxlZSA9IHBhdGhOb2RlLm5vZGUuY2FsbGVlO1xuICAgICAgICBpZiAoY2FsbGVlLnR5cGUgPT09ICdJbXBvcnQnKSB7XG4gICAgICAgICAgY29uc3QgYXJnID0gcGF0aE5vZGUubm9kZS5hcmd1bWVudHNbMF07XG4gICAgICAgICAgaWYgKGFyZyAmJiBhcmcudHlwZSA9PT0gJ1N0cmluZ0xpdGVyYWwnKSB7XG4gICAgICAgICAgICBkZXBlbmRlbmNpZXMucHVzaCh7XG4gICAgICAgICAgICAgIHNwZWNpZmllcjogYXJnLnZhbHVlLFxuICAgICAgICAgICAgICB0eXBlOiAnZHluYW1pYycsXG4gICAgICAgICAgICAgIHN0YXRlbWVudDogY29kZS5zbGljZShwYXRoTm9kZS5ub2RlLnN0YXJ0ID8/IDAsIHBhdGhOb2RlLm5vZGUuZW5kID8/IDApLFxuICAgICAgICAgICAgICBsb2M6IHBhdGhOb2RlLm5vZGUubG9jXG4gICAgICAgICAgICAgICAgPyB7IGxpbmU6IHBhdGhOb2RlLm5vZGUubG9jLnN0YXJ0LmxpbmUsIGNvbHVtbjogcGF0aE5vZGUubm9kZS5sb2Muc3RhcnQuY29sdW1uIH1cbiAgICAgICAgICAgICAgICA6IHVuZGVmaW5lZFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGNhbGxlZS50eXBlID09PSAnSWRlbnRpZmllcicgJiYgY2FsbGVlLm5hbWUgPT09ICdyZXF1aXJlJykge1xuICAgICAgICAgIGNvbnN0IGFyZyA9IHBhdGhOb2RlLm5vZGUuYXJndW1lbnRzWzBdO1xuICAgICAgICAgIGlmIChhcmcgJiYgYXJnLnR5cGUgPT09ICdTdHJpbmdMaXRlcmFsJykge1xuICAgICAgICAgICAgZGVwZW5kZW5jaWVzLnB1c2goe1xuICAgICAgICAgICAgICBzcGVjaWZpZXI6IGFyZy52YWx1ZSxcbiAgICAgICAgICAgICAgdHlwZTogJ3N0YXRpYycsXG4gICAgICAgICAgICAgIHN0YXRlbWVudDogY29kZS5zbGljZShwYXRoTm9kZS5ub2RlLnN0YXJ0ID8/IDAsIHBhdGhOb2RlLm5vZGUuZW5kID8/IDApLFxuICAgICAgICAgICAgICBsb2M6IHBhdGhOb2RlLm5vZGUubG9jXG4gICAgICAgICAgICAgICAgPyB7IGxpbmU6IHBhdGhOb2RlLm5vZGUubG9jLnN0YXJ0LmxpbmUsIGNvbHVtbjogcGF0aE5vZGUubm9kZS5sb2Muc3RhcnQuY29sdW1uIH1cbiAgICAgICAgICAgICAgICA6IHVuZGVmaW5lZFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICBpZiAoU1RZTEVfRVhURU5TSU9OUy5oYXMocG9zaXhFeHRuYW1lKGZpbGVQYXRoKSkpIHtcbiAgICBjb25zdCByZWdleCA9IC9AaW1wb3J0XFxzKyg/OnVybFxcKCk/WydcIl0oW14nXCJdKylbJ1wiXS9nO1xuICAgIGxldCBtYXRjaDogUmVnRXhwRXhlY0FycmF5IHwgbnVsbDtcbiAgICB3aGlsZSAoKG1hdGNoID0gcmVnZXguZXhlYyhjb2RlKSkpIHtcbiAgICAgIGRlcGVuZGVuY2llcy5wdXNoKHtcbiAgICAgICAgc3BlY2lmaWVyOiBtYXRjaFsxXSxcbiAgICAgICAgdHlwZTogJ3N0eWxlJyxcbiAgICAgICAgc3RhdGVtZW50OiBtYXRjaFswXVxuICAgICAgfSk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGRlcGVuZGVuY2llcztcbn07XG5cbmNvbnN0IGV4dHJhY3RTeW1ib2xzID0gKGZpbGVQYXRoOiBzdHJpbmcsIGNvZGU6IHN0cmluZyk6IFN5bWJvbEluZm9bXSA9PiB7XG4gIGlmICghU0NSSVBUX0VYVEVOU0lPTlMuaGFzKHBvc2l4RXh0bmFtZShmaWxlUGF0aCkpKSByZXR1cm4gW107XG5cbiAgbGV0IGFzdDogRmlsZSB8IG51bGwgPSBudWxsO1xuICB0cnkge1xuICAgIGFzdCA9IHBhcnNlKGNvZGUsIHtcbiAgICAgIHNvdXJjZVR5cGU6ICd1bmFtYmlndW91cycsXG4gICAgICBwbHVnaW5zOiBbXG4gICAgICAgICdqc3gnLFxuICAgICAgICAndHlwZXNjcmlwdCcsXG4gICAgICAgICdkeW5hbWljSW1wb3J0JyxcbiAgICAgICAgJ2RlY29yYXRvcnMtbGVnYWN5JyxcbiAgICAgICAgJ2NsYXNzUHJvcGVydGllcycsXG4gICAgICAgICdjbGFzc1ByaXZhdGVQcm9wZXJ0aWVzJyxcbiAgICAgICAgJ2ltcG9ydEFzc2VydGlvbnMnLFxuICAgICAgICAndG9wTGV2ZWxBd2FpdCdcbiAgICAgIF1cbiAgICB9KTtcbiAgfSBjYXRjaCB7XG4gICAgcmV0dXJuIFtdO1xuICB9XG5cbiAgY29uc3QgbG9jYWxLaW5kcyA9IG5ldyBNYXA8c3RyaW5nLCBzdHJpbmc+KCk7XG4gIHRyYXZlcnNlKGFzdCwge1xuICAgIEZ1bmN0aW9uRGVjbGFyYXRpb24ocGF0aE5vZGUpIHtcbiAgICAgIGlmIChwYXRoTm9kZS5wYXJlbnQudHlwZSAhPT0gJ1Byb2dyYW0nKSByZXR1cm47XG4gICAgICBpZiAocGF0aE5vZGUubm9kZS5pZCkgbG9jYWxLaW5kcy5zZXQocGF0aE5vZGUubm9kZS5pZC5uYW1lLCAnZnVuY3Rpb24nKTtcbiAgICB9LFxuICAgIENsYXNzRGVjbGFyYXRpb24ocGF0aE5vZGUpIHtcbiAgICAgIGlmIChwYXRoTm9kZS5wYXJlbnQudHlwZSAhPT0gJ1Byb2dyYW0nKSByZXR1cm47XG4gICAgICBpZiAocGF0aE5vZGUubm9kZS5pZCkgbG9jYWxLaW5kcy5zZXQocGF0aE5vZGUubm9kZS5pZC5uYW1lLCAnY2xhc3MnKTtcbiAgICB9LFxuICAgIFZhcmlhYmxlRGVjbGFyYXRpb24ocGF0aE5vZGUpIHtcbiAgICAgIGlmIChwYXRoTm9kZS5wYXJlbnQudHlwZSAhPT0gJ1Byb2dyYW0nKSByZXR1cm47XG4gICAgICBjb25zdCBraW5kID0gcGF0aE5vZGUubm9kZS5raW5kO1xuICAgICAgcGF0aE5vZGUubm9kZS5kZWNsYXJhdGlvbnMuZm9yRWFjaCgoZGVjbCkgPT4ge1xuICAgICAgICBpZiAoZGVjbC5pZC50eXBlID09PSAnSWRlbnRpZmllcicpIHtcbiAgICAgICAgICBsb2NhbEtpbmRzLnNldChkZWNsLmlkLm5hbWUsIGtpbmQpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9LFxuICAgIFRTSW50ZXJmYWNlRGVjbGFyYXRpb24ocGF0aE5vZGUpIHtcbiAgICAgIGlmIChwYXRoTm9kZS5wYXJlbnQudHlwZSAhPT0gJ1Byb2dyYW0nKSByZXR1cm47XG4gICAgICBsb2NhbEtpbmRzLnNldChwYXRoTm9kZS5ub2RlLmlkLm5hbWUsICdpbnRlcmZhY2UnKTtcbiAgICB9LFxuICAgIFRTVHlwZUFsaWFzRGVjbGFyYXRpb24ocGF0aE5vZGUpIHtcbiAgICAgIGlmIChwYXRoTm9kZS5wYXJlbnQudHlwZSAhPT0gJ1Byb2dyYW0nKSByZXR1cm47XG4gICAgICBsb2NhbEtpbmRzLnNldChwYXRoTm9kZS5ub2RlLmlkLm5hbWUsICd0eXBlJyk7XG4gICAgfSxcbiAgICBUU0VudW1EZWNsYXJhdGlvbihwYXRoTm9kZSkge1xuICAgICAgaWYgKHBhdGhOb2RlLnBhcmVudC50eXBlICE9PSAnUHJvZ3JhbScpIHJldHVybjtcbiAgICAgIGxvY2FsS2luZHMuc2V0KHBhdGhOb2RlLm5vZGUuaWQubmFtZSwgJ2VudW0nKTtcbiAgICB9XG4gIH0pO1xuXG4gIGNvbnN0IHN5bWJvbHM6IFN5bWJvbEluZm9bXSA9IFtdO1xuICBjb25zdCBzZWVuID0gbmV3IFNldDxzdHJpbmc+KCk7XG5cbiAgY29uc3QgYWRkU3ltYm9sID0gKHN5bWJvbDogU3ltYm9sSW5mbykgPT4ge1xuICAgIGlmIChzZWVuLmhhcyhzeW1ib2wubmFtZSkpIHJldHVybjtcbiAgICBzZWVuLmFkZChzeW1ib2wubmFtZSk7XG4gICAgc3ltYm9scy5wdXNoKHN5bWJvbCk7XG4gIH07XG5cbiAgdHJhdmVyc2UoYXN0LCB7XG4gICAgRXhwb3J0TmFtZWREZWNsYXJhdGlvbihwYXRoTm9kZSkge1xuICAgICAgY29uc3QgZGVjbCA9IHBhdGhOb2RlLm5vZGUuZGVjbGFyYXRpb247XG4gICAgICBpZiAoZGVjbCkge1xuICAgICAgICBpZiAoZGVjbC50eXBlID09PSAnRnVuY3Rpb25EZWNsYXJhdGlvbicgJiYgZGVjbC5pZCkge1xuICAgICAgICAgIGFkZFN5bWJvbCh7IG5hbWU6IGRlY2wuaWQubmFtZSwga2luZDogJ2Z1bmN0aW9uJyB9KTtcbiAgICAgICAgfSBlbHNlIGlmIChkZWNsLnR5cGUgPT09ICdDbGFzc0RlY2xhcmF0aW9uJyAmJiBkZWNsLmlkKSB7XG4gICAgICAgICAgYWRkU3ltYm9sKHsgbmFtZTogZGVjbC5pZC5uYW1lLCBraW5kOiAnY2xhc3MnIH0pO1xuICAgICAgICB9IGVsc2UgaWYgKGRlY2wudHlwZSA9PT0gJ1ZhcmlhYmxlRGVjbGFyYXRpb24nKSB7XG4gICAgICAgICAgZGVjbC5kZWNsYXJhdGlvbnMuZm9yRWFjaCgoaXRlbSkgPT4ge1xuICAgICAgICAgICAgaWYgKGl0ZW0uaWQudHlwZSA9PT0gJ0lkZW50aWZpZXInKSB7XG4gICAgICAgICAgICAgIGFkZFN5bWJvbCh7IG5hbWU6IGl0ZW0uaWQubmFtZSwga2luZDogZGVjbC5raW5kIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2UgaWYgKGRlY2wudHlwZSA9PT0gJ1RTSW50ZXJmYWNlRGVjbGFyYXRpb24nKSB7XG4gICAgICAgICAgYWRkU3ltYm9sKHsgbmFtZTogZGVjbC5pZC5uYW1lLCBraW5kOiAnaW50ZXJmYWNlJyB9KTtcbiAgICAgICAgfSBlbHNlIGlmIChkZWNsLnR5cGUgPT09ICdUU1R5cGVBbGlhc0RlY2xhcmF0aW9uJykge1xuICAgICAgICAgIGFkZFN5bWJvbCh7IG5hbWU6IGRlY2wuaWQubmFtZSwga2luZDogJ3R5cGUnIH0pO1xuICAgICAgICB9IGVsc2UgaWYgKGRlY2wudHlwZSA9PT0gJ1RTRW51bURlY2xhcmF0aW9uJykge1xuICAgICAgICAgIGFkZFN5bWJvbCh7IG5hbWU6IGRlY2wuaWQubmFtZSwga2luZDogJ2VudW0nIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgaWYgKHBhdGhOb2RlLm5vZGUuc3BlY2lmaWVycy5sZW5ndGgpIHtcbiAgICAgICAgcGF0aE5vZGUubm9kZS5zcGVjaWZpZXJzLmZvckVhY2goKHNwZWNpZmllcikgPT4ge1xuICAgICAgICAgIGlmIChzcGVjaWZpZXIudHlwZSAhPT0gJ0V4cG9ydFNwZWNpZmllcicpIHJldHVybjtcbiAgICAgICAgICBjb25zdCBleHBvcnRlZE5hbWUgPVxuICAgICAgICAgICAgc3BlY2lmaWVyLmV4cG9ydGVkLnR5cGUgPT09ICdJZGVudGlmaWVyJ1xuICAgICAgICAgICAgICA/IHNwZWNpZmllci5leHBvcnRlZC5uYW1lXG4gICAgICAgICAgICAgIDogc3BlY2lmaWVyLmV4cG9ydGVkLnZhbHVlO1xuICAgICAgICAgIGNvbnN0IGxvY2FsTmFtZSA9XG4gICAgICAgICAgICBzcGVjaWZpZXIubG9jYWwudHlwZSA9PT0gJ0lkZW50aWZpZXInXG4gICAgICAgICAgICAgID8gc3BlY2lmaWVyLmxvY2FsLm5hbWVcbiAgICAgICAgICAgICAgOiBzcGVjaWZpZXIubG9jYWwudmFsdWU7XG4gICAgICAgICAgYWRkU3ltYm9sKHtcbiAgICAgICAgICAgIG5hbWU6IGV4cG9ydGVkTmFtZSxcbiAgICAgICAgICAgIGtpbmQ6IGxvY2FsS2luZHMuZ2V0KGxvY2FsTmFtZSkgPz8gJ2V4cG9ydCdcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSxcbiAgICBFeHBvcnREZWZhdWx0RGVjbGFyYXRpb24ocGF0aE5vZGUpIHtcbiAgICAgIGNvbnN0IGRlY2wgPSBwYXRoTm9kZS5ub2RlLmRlY2xhcmF0aW9uO1xuICAgICAgaWYgKGRlY2wudHlwZSA9PT0gJ0Z1bmN0aW9uRGVjbGFyYXRpb24nKSB7XG4gICAgICAgIGFkZFN5bWJvbCh7XG4gICAgICAgICAgbmFtZTogJ2RlZmF1bHQnLFxuICAgICAgICAgIGtpbmQ6ICdmdW5jdGlvbicsXG4gICAgICAgICAgZGlzcGxheU5hbWU6IGRlY2wuaWQ/Lm5hbWVcbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2UgaWYgKGRlY2wudHlwZSA9PT0gJ0NsYXNzRGVjbGFyYXRpb24nKSB7XG4gICAgICAgIGFkZFN5bWJvbCh7XG4gICAgICAgICAgbmFtZTogJ2RlZmF1bHQnLFxuICAgICAgICAgIGtpbmQ6ICdjbGFzcycsXG4gICAgICAgICAgZGlzcGxheU5hbWU6IGRlY2wuaWQ/Lm5hbWVcbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2UgaWYgKGRlY2wudHlwZSA9PT0gJ0lkZW50aWZpZXInKSB7XG4gICAgICAgIGFkZFN5bWJvbCh7XG4gICAgICAgICAgbmFtZTogJ2RlZmF1bHQnLFxuICAgICAgICAgIGtpbmQ6IGxvY2FsS2luZHMuZ2V0KGRlY2wubmFtZSkgPz8gJ2V4cG9ydCcsXG4gICAgICAgICAgZGlzcGxheU5hbWU6IGRlY2wubmFtZVxuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGFkZFN5bWJvbCh7IG5hbWU6ICdkZWZhdWx0Jywga2luZDogJ2V4cG9ydCcgfSk7XG4gICAgICB9XG4gICAgfVxuICB9KTtcblxuICByZXR1cm4gc3ltYm9scztcbn07XG5cbmNvbnN0IHJlc29sdmVXaXRoRXh0ZW5zaW9ucyA9IChcbiAgYmFzZVBhdGg6IHN0cmluZyB8IG51bGwsXG4gIGZpbGVTZXQ6IFNldDxzdHJpbmc+LFxuICBkaXJTZXQ6IFNldDxzdHJpbmc+XG4pID0+IHtcbiAgaWYgKCFiYXNlUGF0aCkgcmV0dXJuIG51bGw7XG4gIGlmIChmaWxlU2V0LmhhcyhiYXNlUGF0aCkpIHJldHVybiBiYXNlUGF0aDtcblxuICBpZiAoZGlyU2V0LmhhcyhiYXNlUGF0aCkpIHtcbiAgICBmb3IgKGNvbnN0IGV4dCBvZiBJTVBPUlRfRVhURU5TSU9OUykge1xuICAgICAgY29uc3QgaW5kZXhQYXRoID0gcG9zaXhKb2luKGJhc2VQYXRoLCBgaW5kZXgke2V4dH1gKTtcbiAgICAgIGlmIChmaWxlU2V0LmhhcyhpbmRleFBhdGgpKSByZXR1cm4gaW5kZXhQYXRoO1xuICAgIH1cbiAgfVxuXG4gIGlmICghcG9zaXhFeHRuYW1lKGJhc2VQYXRoKSkge1xuICAgIGZvciAoY29uc3QgZXh0IG9mIElNUE9SVF9FWFRFTlNJT05TKSB7XG4gICAgICBjb25zdCBmaWxlUGF0aCA9IGAke2Jhc2VQYXRofSR7ZXh0fWA7XG4gICAgICBpZiAoZmlsZVNldC5oYXMoZmlsZVBhdGgpKSByZXR1cm4gZmlsZVBhdGg7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG51bGw7XG59O1xuXG5jb25zdCByZXNvbHZlSW1wb3J0ID0gKFxuICBmcm9tRmlsZTogc3RyaW5nLFxuICBzcGVjaWZpZXI6IHN0cmluZyxcbiAgZmlsZVNldDogU2V0PHN0cmluZz4sXG4gIGRpclNldDogU2V0PHN0cmluZz5cbikgPT4ge1xuICBpZiAoIXNwZWNpZmllciB8fCBzcGVjaWZpZXIuc3RhcnRzV2l0aCgnaHR0cCcpKSByZXR1cm4gbnVsbDtcblxuICBjb25zdCBjbGVhblNwZWNpZmllciA9IHNwZWNpZmllci5zcGxpdCgnPycpWzBdLnNwbGl0KCcjJylbMF07XG4gIGxldCB0YXJnZXRQYXRoOiBzdHJpbmcgfCBudWxsID0gbnVsbDtcbiAgbGV0IGVzY2FwZWRSb290ID0gZmFsc2U7XG5cbiAgaWYgKGNsZWFuU3BlY2lmaWVyLnN0YXJ0c1dpdGgoJ0AvJykpIHtcbiAgICBjb25zdCBub3JtYWxpemVkID0gbm9ybWFsaXplUG9zaXhQYXRoKGNsZWFuU3BlY2lmaWVyLnNsaWNlKDIpKTtcbiAgICB0YXJnZXRQYXRoID0gbm9ybWFsaXplZC5wYXRoO1xuICAgIGVzY2FwZWRSb290ID0gbm9ybWFsaXplZC5lc2NhcGVkUm9vdDtcbiAgfSBlbHNlIGlmIChjbGVhblNwZWNpZmllci5zdGFydHNXaXRoKCcvJykpIHtcbiAgICBjb25zdCBub3JtYWxpemVkID0gbm9ybWFsaXplUG9zaXhQYXRoKGNsZWFuU3BlY2lmaWVyLnNsaWNlKDEpKTtcbiAgICB0YXJnZXRQYXRoID0gbm9ybWFsaXplZC5wYXRoO1xuICAgIGVzY2FwZWRSb290ID0gbm9ybWFsaXplZC5lc2NhcGVkUm9vdDtcbiAgfSBlbHNlIGlmIChjbGVhblNwZWNpZmllci5zdGFydHNXaXRoKCcuJykpIHtcbiAgICBjb25zdCBmcm9tRGlyID0gcG9zaXhEaXJuYW1lKGZyb21GaWxlKTtcbiAgICBjb25zdCBub3JtYWxpemVkID0gbm9ybWFsaXplUG9zaXhQYXRoKHBvc2l4Sm9pbihmcm9tRGlyLCBjbGVhblNwZWNpZmllcikpO1xuICAgIHRhcmdldFBhdGggPSBub3JtYWxpemVkLnBhdGg7XG4gICAgZXNjYXBlZFJvb3QgPSBub3JtYWxpemVkLmVzY2FwZWRSb290O1xuICB9IGVsc2Uge1xuICAgIHJldHVybiB7IGV4dGVybmFsOiB0cnVlLCByZXNvbHZlZDogbnVsbCB9O1xuICB9XG5cbiAgaWYgKCF0YXJnZXRQYXRoIHx8IGVzY2FwZWRSb290KSB7XG4gICAgcmV0dXJuIHsgZXh0ZXJuYWw6IHRydWUsIHJlc29sdmVkOiBudWxsIH07XG4gIH1cblxuICBjb25zdCByZXNvbHZlZCA9IHJlc29sdmVXaXRoRXh0ZW5zaW9ucyh0YXJnZXRQYXRoLCBmaWxlU2V0LCBkaXJTZXQpO1xuICBpZiAoIXJlc29sdmVkKSByZXR1cm4geyBleHRlcm5hbDogdHJ1ZSwgcmVzb2x2ZWQ6IG51bGwgfTtcblxuICByZXR1cm4geyBleHRlcm5hbDogZmFsc2UsIHJlc29sdmVkIH07XG59O1xuXG5jb25zdCBoYXNoSWQgPSAodmFsdWU6IHN0cmluZykgPT4ge1xuICBsZXQgaDEgPSAweGRlYWRiZWVmIF4gdmFsdWUubGVuZ3RoO1xuICBsZXQgaDIgPSAweDQxYzZjZTU3IF4gdmFsdWUubGVuZ3RoO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IHZhbHVlLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgY29uc3QgY2ggPSB2YWx1ZS5jaGFyQ29kZUF0KGkpO1xuICAgIGgxID0gTWF0aC5pbXVsKGgxIF4gY2gsIDI2NTQ0MzU3NjEpO1xuICAgIGgyID0gTWF0aC5pbXVsKGgyIF4gY2gsIDE1OTczMzQ2NzcpO1xuICB9XG4gIGgxID0gTWF0aC5pbXVsKGgxIF4gKGgxID4+PiAxNiksIDIyNDY4MjI1MDcpO1xuICBoMiA9IE1hdGguaW11bChoMiBeIChoMiA+Pj4gMTYpLCAyMjQ2ODIyNTA3KTtcbiAgcmV0dXJuIGAkeyhoMSA+Pj4gMCkudG9TdHJpbmcoMTYpfSR7KGgyID4+PiAwKS50b1N0cmluZygxNil9YDtcbn07XG5cbmV4cG9ydCBjb25zdCBzY2FuRGlyZWN0b3J5SGFuZGxlID0gYXN5bmMgKFxuICBvcHRpb25zOiBCcm93c2VyU2Nhbk9wdGlvbnNcbik6IFByb21pc2U8R3JhcGhEYXRhPiA9PiB7XG4gIGNvbnN0IHsgcm9vdEhhbmRsZSwgbWF4RmlsZXMsIGluY2x1ZGVFeHRlcm5hbCB9ID0gb3B0aW9ucztcbiAgY29uc3QgZ3JhbnVsYXJpdHkgPSBvcHRpb25zLmdyYW51bGFyaXR5ID8/ICdmaWxlJztcbiAgY29uc3Qgcm9vdExhYmVsID0gcm9vdEhhbmRsZS5uYW1lIHx8ICdTZWxlY3RlZCBmb2xkZXInO1xuXG4gIGNvbnN0IG5vZGVzID0gbmV3IE1hcDxzdHJpbmcsIEdyYXBoTm9kZT4oKTtcbiAgY29uc3QgZWRnZXM6IEdyYXBoRWRnZVtdID0gW107XG4gIGNvbnN0IGVkZ2VLZXlzID0gbmV3IFNldDxzdHJpbmc+KCk7XG4gIGNvbnN0IGlnbm9yZWROb2RlczogR3JhcGhOb2RlW10gPSBbXTtcbiAgY29uc3QgZmlsZUhhbmRsZXMgPSBuZXcgTWFwPHN0cmluZywgRmlsZVN5c3RlbUZpbGVIYW5kbGU+KCk7XG4gIGNvbnN0IGZpbGVDb250ZW50cyA9IG5ldyBNYXA8c3RyaW5nLCBzdHJpbmc+KCk7XG4gIGNvbnN0IGRpclNldCA9IG5ldyBTZXQ8c3RyaW5nPihbJyddKTtcbiAgY29uc3Qgc3ltYm9sTWFwID0gbmV3IE1hcDxzdHJpbmcsIE1hcDxzdHJpbmcsIFN5bWJvbEluZm8+PigpO1xuXG4gIGxldCB0b3RhbEZpbGVzID0gMDtcbiAgbGV0IGlnbm9yZWRDb3VudCA9IDA7XG4gIGxldCBleHRlcm5hbENvdW50ID0gMDtcblxuICBjb25zdCB3YWxrID0gYXN5bmMgKFxuICAgIGRpckhhbmRsZTogRmlsZVN5c3RlbURpcmVjdG9yeUhhbmRsZSxcbiAgICByZWxEaXI6IHN0cmluZyxcbiAgICBwYXR0ZXJuczogc3RyaW5nW11cbiAgKSA9PiB7XG4gICAgZGlyU2V0LmFkZChyZWxEaXIpO1xuXG4gICAgY29uc3QgZ2l0aWdub3JlSGFuZGxlID0gYXdhaXQgZGlySGFuZGxlXG4gICAgICAuZ2V0RmlsZUhhbmRsZSgnLmdpdGlnbm9yZScpXG4gICAgICAuY2F0Y2goKCkgPT4gbnVsbCk7XG4gICAgbGV0IGNvbWJpbmVkUGF0dGVybnMgPSBwYXR0ZXJucztcblxuICAgIGlmIChnaXRpZ25vcmVIYW5kbGUpIHtcbiAgICAgIGNvbnN0IGdpdGlnbm9yZUZpbGUgPSBhd2FpdCBnaXRpZ25vcmVIYW5kbGUuZ2V0RmlsZSgpLmNhdGNoKCgpID0+IG51bGwpO1xuICAgICAgY29uc3QgZ2l0aWdub3JlQ29udGVudCA9IGF3YWl0IGdpdGlnbm9yZUZpbGU/LnRleHQoKTtcbiAgICAgIGlmIChnaXRpZ25vcmVDb250ZW50KSB7XG4gICAgICAgIGNvbnN0IGV4dHJhUGF0dGVybnMgPSBnaXRpZ25vcmVDb250ZW50XG4gICAgICAgICAgLnNwbGl0KC9cXHI/XFxuLylcbiAgICAgICAgICAubWFwKChsaW5lKSA9PiBub3JtYWxpemVHaXRpZ25vcmVQYXR0ZXJuKHJlbERpciwgbGluZSkpXG4gICAgICAgICAgLmZpbHRlcigodmFsdWUpOiB2YWx1ZSBpcyBzdHJpbmcgPT4gQm9vbGVhbih2YWx1ZSkpO1xuICAgICAgICBjb21iaW5lZFBhdHRlcm5zID0gcGF0dGVybnMuY29uY2F0KGV4dHJhUGF0dGVybnMpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGNvbnN0IGlnID0gaWdub3JlKCkuYWRkKGNvbWJpbmVkUGF0dGVybnMpO1xuXG4gICAgZm9yIGF3YWl0IChjb25zdCBbbmFtZSwgaGFuZGxlXSBvZiBkaXJIYW5kbGUuZW50cmllcygpKSB7XG4gICAgICBjb25zdCByZWxQYXRoID0gcmVsRGlyID8gYCR7cmVsRGlyfS8ke25hbWV9YCA6IG5hbWU7XG4gICAgICBpZiAoIXJlbFBhdGgpIGNvbnRpbnVlO1xuXG4gICAgICBpZiAoaWcuaWdub3JlcyhyZWxQYXRoKSkge1xuICAgICAgICBpZ25vcmVkQ291bnQgKz0gMTtcbiAgICAgICAgaWYgKGhhbmRsZS5raW5kID09PSAnZmlsZScgJiYgU1VQUE9SVEVEX0VYVEVOU0lPTlMuaGFzKHBvc2l4RXh0bmFtZShyZWxQYXRoKSkpIHtcbiAgICAgICAgICBpZ25vcmVkTm9kZXMucHVzaCh7XG4gICAgICAgICAgICBpZDogcmVsUGF0aCxcbiAgICAgICAgICAgIHBhdGg6IHJlbFBhdGgsXG4gICAgICAgICAgICBsYWJlbDogcG9zaXhCYXNlbmFtZShyZWxQYXRoKSxcbiAgICAgICAgICAgIHR5cGU6IG5vZGVUeXBlRnJvbVBhdGgocmVsUGF0aCksXG4gICAgICAgICAgICBpZ25vcmVkOiB0cnVlXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIGlmIChoYW5kbGUua2luZCA9PT0gJ2RpcmVjdG9yeScpIHtcbiAgICAgICAgYXdhaXQgd2FsayhoYW5kbGUsIHJlbFBhdGgsIGNvbWJpbmVkUGF0dGVybnMpO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgdG90YWxGaWxlcyArPSAxO1xuICAgICAgaWYgKHRvdGFsRmlsZXMgPiBtYXhGaWxlcykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgYEZpbGUgbGltaXQgZXhjZWVkZWQgKCR7bWF4RmlsZXN9KS4gQWRqdXN0IHRoZSBtYXggZmlsZXMgc2V0dGluZyB0byBjb250aW51ZS5gXG4gICAgICAgICk7XG4gICAgICB9XG5cbiAgICAgIGlmICghU1VQUE9SVEVEX0VYVEVOU0lPTlMuaGFzKHBvc2l4RXh0bmFtZShyZWxQYXRoKSkpIGNvbnRpbnVlO1xuXG4gICAgICBub2Rlcy5zZXQocmVsUGF0aCwge1xuICAgICAgICBpZDogcmVsUGF0aCxcbiAgICAgICAgcGF0aDogcmVsUGF0aCxcbiAgICAgICAgbGFiZWw6IHBvc2l4QmFzZW5hbWUocmVsUGF0aCksXG4gICAgICAgIHR5cGU6IG5vZGVUeXBlRnJvbVBhdGgocmVsUGF0aClcbiAgICAgIH0pO1xuXG4gICAgICBmaWxlSGFuZGxlcy5zZXQocmVsUGF0aCwgaGFuZGxlKTtcbiAgICB9XG4gIH07XG5cbiAgYXdhaXQgd2Fsayhyb290SGFuZGxlLCAnJywgQUxXQVlTX0lHTk9SRSk7XG5cbiAgZm9yIChjb25zdCBpZ25vcmVkTm9kZSBvZiBpZ25vcmVkTm9kZXMpIHtcbiAgICBub2Rlcy5zZXQoaWdub3JlZE5vZGUuaWQsIGlnbm9yZWROb2RlKTtcbiAgfVxuXG4gIGNvbnN0IGZpbGVTZXQgPSBuZXcgU2V0KGZpbGVIYW5kbGVzLmtleXMoKSk7XG5cbiAgaWYgKGdyYW51bGFyaXR5ID09PSAnc3ltYm9sJykge1xuICAgIGZvciAoY29uc3QgW3JlbFBhdGgsIGhhbmRsZV0gb2YgZmlsZUhhbmRsZXMuZW50cmllcygpKSB7XG4gICAgICBjb25zdCBmaWxlID0gYXdhaXQgaGFuZGxlLmdldEZpbGUoKS5jYXRjaCgoKSA9PiBudWxsKTtcbiAgICAgIGNvbnN0IGNvZGUgPSBhd2FpdCBmaWxlPy50ZXh0KCk7XG4gICAgICBpZiAoIWNvZGUpIGNvbnRpbnVlO1xuICAgICAgZmlsZUNvbnRlbnRzLnNldChyZWxQYXRoLCBjb2RlKTtcblxuICAgICAgY29uc3Qgc3ltYm9scyA9IGV4dHJhY3RTeW1ib2xzKHJlbFBhdGgsIGNvZGUpO1xuICAgICAgaWYgKCFzeW1ib2xzLmxlbmd0aCkgY29udGludWU7XG5cbiAgICAgIGNvbnN0IGVudHJ5ID0gbmV3IE1hcDxzdHJpbmcsIFN5bWJvbEluZm8+KCk7XG4gICAgICBmb3IgKGNvbnN0IHN5bWJvbCBvZiBzeW1ib2xzKSB7XG4gICAgICAgIGNvbnN0IHN5bWJvbElkID0gYCR7cmVsUGF0aH06OiR7c3ltYm9sLm5hbWV9YDtcbiAgICAgICAgZW50cnkuc2V0KHN5bWJvbC5uYW1lLCBzeW1ib2wpO1xuICAgICAgICBpZiAoIW5vZGVzLmhhcyhzeW1ib2xJZCkpIHtcbiAgICAgICAgICBub2Rlcy5zZXQoc3ltYm9sSWQsIHtcbiAgICAgICAgICAgIGlkOiBzeW1ib2xJZCxcbiAgICAgICAgICAgIHBhdGg6IGAke3JlbFBhdGh9IyR7c3ltYm9sLm5hbWV9YCxcbiAgICAgICAgICAgIGxhYmVsOiBzeW1ib2wubmFtZSxcbiAgICAgICAgICAgIHR5cGU6ICdzeW1ib2wnLFxuICAgICAgICAgICAgc3ltYm9sS2luZDogc3ltYm9sLmtpbmQsXG4gICAgICAgICAgICBwYXJlbnQ6IHJlbFBhdGgsXG4gICAgICAgICAgICBkaXNwbGF5TmFtZTogc3ltYm9sLmRpc3BsYXlOYW1lXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgY29udGFpbnNLZXkgPSBgJHtyZWxQYXRofXwke3N5bWJvbElkfXxjb250YWluc2A7XG4gICAgICAgIGlmICghZWRnZUtleXMuaGFzKGNvbnRhaW5zS2V5KSkge1xuICAgICAgICAgIGVkZ2VLZXlzLmFkZChjb250YWluc0tleSk7XG4gICAgICAgICAgZWRnZXMucHVzaCh7XG4gICAgICAgICAgICBpZDogaGFzaElkKGNvbnRhaW5zS2V5KSxcbiAgICAgICAgICAgIHNvdXJjZTogcmVsUGF0aCxcbiAgICAgICAgICAgIHRhcmdldDogc3ltYm9sSWQsXG4gICAgICAgICAgICB0eXBlOiAnY29udGFpbnMnXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHN5bWJvbE1hcC5zZXQocmVsUGF0aCwgZW50cnkpO1xuICAgIH1cbiAgfVxuXG4gIGZvciAoY29uc3QgW3JlbFBhdGgsIGhhbmRsZV0gb2YgZmlsZUhhbmRsZXMuZW50cmllcygpKSB7XG4gICAgY29uc3QgZmlsZSA9IGF3YWl0IGhhbmRsZS5nZXRGaWxlKCkuY2F0Y2goKCkgPT4gbnVsbCk7XG4gICAgY29uc3QgY29kZSA9IGZpbGVDb250ZW50cy5nZXQocmVsUGF0aCkgPz8gKGF3YWl0IGZpbGU/LnRleHQoKSk7XG4gICAgaWYgKCFjb2RlKSBjb250aW51ZTtcblxuICAgIGNvbnN0IGRlcGVuZGVuY2llcyA9IGV4dHJhY3REZXBlbmRlbmNpZXMocmVsUGF0aCwgY29kZSk7XG5cbiAgICBmb3IgKGNvbnN0IGRlcCBvZiBkZXBlbmRlbmNpZXMpIHtcbiAgICAgIGNvbnN0IHJlc29sdmVkID0gcmVzb2x2ZUltcG9ydChyZWxQYXRoLCBkZXAuc3BlY2lmaWVyLCBmaWxlU2V0LCBkaXJTZXQpO1xuICAgICAgaWYgKCFyZXNvbHZlZCkgY29udGludWU7XG5cbiAgICAgIGlmIChyZXNvbHZlZC5leHRlcm5hbCkge1xuICAgICAgICBleHRlcm5hbENvdW50ICs9IDE7XG4gICAgICAgIGlmICghaW5jbHVkZUV4dGVybmFsKSBjb250aW51ZTtcblxuICAgICAgICBpZiAoIW5vZGVzLmhhcygnX19leHRlcm5hbF9fJykpIHtcbiAgICAgICAgICBub2Rlcy5zZXQoJ19fZXh0ZXJuYWxfXycsIHtcbiAgICAgICAgICAgIGlkOiAnX19leHRlcm5hbF9fJyxcbiAgICAgICAgICAgIHBhdGg6ICdfX2V4dGVybmFsX18nLFxuICAgICAgICAgICAgbGFiZWw6ICdFeHRlcm5hbCcsXG4gICAgICAgICAgICB0eXBlOiAnZXh0ZXJuYWwnXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBlZGdlS2V5ID0gYCR7cmVsUGF0aH18X19leHRlcm5hbF9ffGV4dGVybmFsfCR7ZGVwLnNwZWNpZmllcn1gO1xuICAgICAgICBpZiAoZWRnZUtleXMuaGFzKGVkZ2VLZXkpKSBjb250aW51ZTtcbiAgICAgICAgZWRnZUtleXMuYWRkKGVkZ2VLZXkpO1xuICAgICAgICBlZGdlcy5wdXNoKHtcbiAgICAgICAgICBpZDogaGFzaElkKGVkZ2VLZXkpLFxuICAgICAgICAgIHNvdXJjZTogcmVsUGF0aCxcbiAgICAgICAgICB0YXJnZXQ6ICdfX2V4dGVybmFsX18nLFxuICAgICAgICAgIHR5cGU6ICdleHRlcm5hbCcsXG4gICAgICAgICAgc3RhdGVtZW50OiBkZXAuc3RhdGVtZW50LFxuICAgICAgICAgIGxvYzogZGVwLmxvY1xuICAgICAgICB9KTtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIGlmICghcmVzb2x2ZWQucmVzb2x2ZWQpIGNvbnRpbnVlO1xuXG4gICAgICBjb25zdCB0YXJnZXRSZWwgPSByZXNvbHZlZC5yZXNvbHZlZDtcbiAgICAgIGlmICghbm9kZXMuaGFzKHRhcmdldFJlbCkpIHtcbiAgICAgICAgbm9kZXMuc2V0KHRhcmdldFJlbCwge1xuICAgICAgICAgIGlkOiB0YXJnZXRSZWwsXG4gICAgICAgICAgcGF0aDogdGFyZ2V0UmVsLFxuICAgICAgICAgIGxhYmVsOiBwb3NpeEJhc2VuYW1lKHRhcmdldFJlbCksXG4gICAgICAgICAgdHlwZTogbm9kZVR5cGVGcm9tUGF0aCh0YXJnZXRSZWwpXG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICBpZiAoZ3JhbnVsYXJpdHkgPT09ICdzeW1ib2wnICYmIGRlcC5pbXBvcnRzPy5sZW5ndGgpIHtcbiAgICAgICAgY29uc3QgdGFyZ2V0U3ltYm9scyA9IHN5bWJvbE1hcC5nZXQodGFyZ2V0UmVsKTtcbiAgICAgICAgbGV0IGNyZWF0ZWRTeW1ib2xFZGdlID0gZmFsc2U7XG4gICAgICAgIGlmICh0YXJnZXRTeW1ib2xzKSB7XG4gICAgICAgICAgZm9yIChjb25zdCBiaW5kaW5nIG9mIGRlcC5pbXBvcnRzKSB7XG4gICAgICAgICAgICBpZiAoYmluZGluZy5raW5kID09PSAnbmFtZXNwYWNlJykgY29udGludWU7XG4gICAgICAgICAgICBjb25zdCBpbXBvcnROYW1lID0gYmluZGluZy5raW5kID09PSAnZGVmYXVsdCcgPyAnZGVmYXVsdCcgOiBiaW5kaW5nLmltcG9ydGVkO1xuICAgICAgICAgICAgY29uc3Qgc3ltYm9sID0gdGFyZ2V0U3ltYm9scy5nZXQoaW1wb3J0TmFtZSk7XG4gICAgICAgICAgICBpZiAoIXN5bWJvbCkgY29udGludWU7XG4gICAgICAgICAgICBjb25zdCBzeW1ib2xJZCA9IGAke3RhcmdldFJlbH06OiR7aW1wb3J0TmFtZX1gO1xuICAgICAgICAgICAgY29uc3QgZWRnZUtleSA9IGAke3JlbFBhdGh9fCR7c3ltYm9sSWR9fCR7ZGVwLnR5cGV9fCR7ZGVwLnN0YXRlbWVudCA/PyAnJ31gO1xuICAgICAgICAgICAgaWYgKGVkZ2VLZXlzLmhhcyhlZGdlS2V5KSkgY29udGludWU7XG4gICAgICAgICAgICBlZGdlS2V5cy5hZGQoZWRnZUtleSk7XG4gICAgICAgICAgICBlZGdlcy5wdXNoKHtcbiAgICAgICAgICAgICAgaWQ6IGhhc2hJZChlZGdlS2V5KSxcbiAgICAgICAgICAgICAgc291cmNlOiByZWxQYXRoLFxuICAgICAgICAgICAgICB0YXJnZXQ6IHN5bWJvbElkLFxuICAgICAgICAgICAgICB0eXBlOiBkZXAudHlwZSxcbiAgICAgICAgICAgICAgc3RhdGVtZW50OiBkZXAuc3RhdGVtZW50Py5zbGljZSgwLCAyMDApLFxuICAgICAgICAgICAgICBsb2M6IGRlcC5sb2NcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgY3JlYXRlZFN5bWJvbEVkZ2UgPSB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChjcmVhdGVkU3ltYm9sRWRnZSkgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IHRhcmdldEV4dCA9IHBvc2l4RXh0bmFtZSh0YXJnZXRSZWwpO1xuICAgICAgY29uc3QgZWRnZVR5cGU6IEVkZ2VUeXBlID0gU1RZTEVfRVhURU5TSU9OUy5oYXModGFyZ2V0RXh0KSA/ICdzdHlsZScgOiBkZXAudHlwZTtcblxuICAgICAgY29uc3QgZWRnZUtleSA9IGAke3JlbFBhdGh9fCR7dGFyZ2V0UmVsfXwke2VkZ2VUeXBlfXwke2RlcC5zdGF0ZW1lbnQgPz8gJyd9YDtcbiAgICAgIGlmIChlZGdlS2V5cy5oYXMoZWRnZUtleSkpIGNvbnRpbnVlO1xuICAgICAgZWRnZUtleXMuYWRkKGVkZ2VLZXkpO1xuXG4gICAgICBlZGdlcy5wdXNoKHtcbiAgICAgICAgaWQ6IGhhc2hJZChlZGdlS2V5KSxcbiAgICAgICAgc291cmNlOiByZWxQYXRoLFxuICAgICAgICB0YXJnZXQ6IHRhcmdldFJlbCxcbiAgICAgICAgdHlwZTogZWRnZVR5cGUsXG4gICAgICAgIHN0YXRlbWVudDogZGVwLnN0YXRlbWVudD8uc2xpY2UoMCwgMjAwKSxcbiAgICAgICAgbG9jOiBkZXAubG9jXG4gICAgICB9KTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4ge1xuICAgIHJvb3Q6IHJvb3RMYWJlbCxcbiAgICBub2RlczogQXJyYXkuZnJvbShub2Rlcy52YWx1ZXMoKSksXG4gICAgZWRnZXMsXG4gICAgdG90YWxGaWxlcyxcbiAgICBpZ25vcmVkQ291bnQsXG4gICAgZXh0ZXJuYWxDb3VudFxuICB9O1xufTtcbiJdLCJuYW1lcyI6WyJpZ25vcmUiLCJwYXJzZSIsInRyYXZlcnNlIiwiQUxXQVlTX0lHTk9SRSIsIlNDUklQVF9FWFRFTlNJT05TIiwiU2V0IiwiU1RZTEVfRVhURU5TSU9OUyIsIlNVUFBPUlRFRF9FWFRFTlNJT05TIiwiSU1QT1JUX0VYVEVOU0lPTlMiLCJST1VURV9SRUdFWCIsImFwcCIsInBhZ2VzIiwicG9zaXhKb2luIiwicGFydHMiLCJmaWx0ZXIiLCJCb29sZWFuIiwiam9pbiIsInJlcGxhY2UiLCJwb3NpeERpcm5hbWUiLCJ2YWx1ZSIsImlkeCIsImxhc3RJbmRleE9mIiwic2xpY2UiLCJwb3NpeEJhc2VuYW1lIiwicG9zaXhFeHRuYW1lIiwiYmFzZSIsIm5vcm1hbGl6ZVBvc2l4UGF0aCIsInNwbGl0Iiwic3RhY2siLCJlc2NhcGVkUm9vdCIsInBhcnQiLCJsZW5ndGgiLCJwb3AiLCJwdXNoIiwicGF0aCIsIm5vcm1hbGl6ZUdpdGlnbm9yZVBhdHRlcm4iLCJkaXJSZWwiLCJyYXdQYXR0ZXJuIiwicGF0dGVybiIsInRyaW0iLCJzdGFydHNXaXRoIiwibmVnYXRlZCIsImFuY2hvcmVkIiwiaGFzU2xhc2giLCJpbmNsdWRlcyIsImVuZHNXaXRoU2xhc2giLCJlbmRzV2l0aCIsInByZWZpeGVkIiwibm9kZVR5cGVGcm9tUGF0aCIsInJlbFBhdGgiLCJ0ZXN0IiwiYmFzZW5hbWUiLCJoYXMiLCJleHRyYWN0RGVwZW5kZW5jaWVzIiwiZmlsZVBhdGgiLCJjb2RlIiwiZGVwZW5kZW5jaWVzIiwiYXN0Iiwic291cmNlVHlwZSIsInBsdWdpbnMiLCJJbXBvcnREZWNsYXJhdGlvbiIsInBhdGhOb2RlIiwibm9kZSIsInNvdXJjZSIsImltcG9ydHMiLCJzcGVjaWZpZXJzIiwiZm9yRWFjaCIsInNwZWNpZmllciIsInR5cGUiLCJraW5kIiwiaW1wb3J0ZWQiLCJsb2NhbCIsIm5hbWUiLCJpbXBvcnRlZE5hbWUiLCJzdGF0ZW1lbnQiLCJzdGFydCIsImVuZCIsImxvYyIsImxpbmUiLCJjb2x1bW4iLCJ1bmRlZmluZWQiLCJFeHBvcnRBbGxEZWNsYXJhdGlvbiIsIkV4cG9ydE5hbWVkRGVjbGFyYXRpb24iLCJDYWxsRXhwcmVzc2lvbiIsImNhbGxlZSIsImFyZyIsImFyZ3VtZW50cyIsInJlZ2V4IiwibWF0Y2giLCJleGVjIiwiZXh0cmFjdFN5bWJvbHMiLCJsb2NhbEtpbmRzIiwiTWFwIiwiRnVuY3Rpb25EZWNsYXJhdGlvbiIsInBhcmVudCIsImlkIiwic2V0IiwiQ2xhc3NEZWNsYXJhdGlvbiIsIlZhcmlhYmxlRGVjbGFyYXRpb24iLCJkZWNsYXJhdGlvbnMiLCJkZWNsIiwiVFNJbnRlcmZhY2VEZWNsYXJhdGlvbiIsIlRTVHlwZUFsaWFzRGVjbGFyYXRpb24iLCJUU0VudW1EZWNsYXJhdGlvbiIsInN5bWJvbHMiLCJzZWVuIiwiYWRkU3ltYm9sIiwic3ltYm9sIiwiYWRkIiwiZGVjbGFyYXRpb24iLCJpdGVtIiwiZXhwb3J0ZWROYW1lIiwiZXhwb3J0ZWQiLCJsb2NhbE5hbWUiLCJnZXQiLCJFeHBvcnREZWZhdWx0RGVjbGFyYXRpb24iLCJkaXNwbGF5TmFtZSIsInJlc29sdmVXaXRoRXh0ZW5zaW9ucyIsImJhc2VQYXRoIiwiZmlsZVNldCIsImRpclNldCIsImV4dCIsImluZGV4UGF0aCIsInJlc29sdmVJbXBvcnQiLCJmcm9tRmlsZSIsImNsZWFuU3BlY2lmaWVyIiwidGFyZ2V0UGF0aCIsIm5vcm1hbGl6ZWQiLCJmcm9tRGlyIiwiZXh0ZXJuYWwiLCJyZXNvbHZlZCIsImhhc2hJZCIsImgxIiwiaDIiLCJpIiwiY2giLCJjaGFyQ29kZUF0IiwiTWF0aCIsImltdWwiLCJ0b1N0cmluZyIsInNjYW5EaXJlY3RvcnlIYW5kbGUiLCJvcHRpb25zIiwicm9vdEhhbmRsZSIsIm1heEZpbGVzIiwiaW5jbHVkZUV4dGVybmFsIiwiZ3JhbnVsYXJpdHkiLCJyb290TGFiZWwiLCJub2RlcyIsImVkZ2VzIiwiZWRnZUtleXMiLCJpZ25vcmVkTm9kZXMiLCJmaWxlSGFuZGxlcyIsImZpbGVDb250ZW50cyIsInN5bWJvbE1hcCIsInRvdGFsRmlsZXMiLCJpZ25vcmVkQ291bnQiLCJleHRlcm5hbENvdW50Iiwid2FsayIsImRpckhhbmRsZSIsInJlbERpciIsInBhdHRlcm5zIiwiZ2l0aWdub3JlSGFuZGxlIiwiZ2V0RmlsZUhhbmRsZSIsImNhdGNoIiwiY29tYmluZWRQYXR0ZXJucyIsImdpdGlnbm9yZUZpbGUiLCJnZXRGaWxlIiwiZ2l0aWdub3JlQ29udGVudCIsInRleHQiLCJleHRyYVBhdHRlcm5zIiwibWFwIiwiY29uY2F0IiwiaWciLCJoYW5kbGUiLCJlbnRyaWVzIiwiaWdub3JlcyIsImxhYmVsIiwiaWdub3JlZCIsIkVycm9yIiwiaWdub3JlZE5vZGUiLCJrZXlzIiwiZmlsZSIsImVudHJ5Iiwic3ltYm9sSWQiLCJzeW1ib2xLaW5kIiwiY29udGFpbnNLZXkiLCJ0YXJnZXQiLCJkZXAiLCJlZGdlS2V5IiwidGFyZ2V0UmVsIiwidGFyZ2V0U3ltYm9scyIsImNyZWF0ZWRTeW1ib2xFZGdlIiwiYmluZGluZyIsImltcG9ydE5hbWUiLCJ0YXJnZXRFeHQiLCJlZGdlVHlwZSIsInJvb3QiLCJBcnJheSIsImZyb20iLCJ2YWx1ZXMiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./lib/browser-scan.ts\n"));

/***/ })

});