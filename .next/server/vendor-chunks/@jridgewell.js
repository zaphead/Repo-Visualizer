/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/@jridgewell";
exports.ids = ["vendor-chunks/@jridgewell"];
exports.modules = {

/***/ "(ssr)/./node_modules/@jridgewell/gen-mapping/dist/gen-mapping.umd.js":
/*!**********************************************************************!*\
  !*** ./node_modules/@jridgewell/gen-mapping/dist/gen-mapping.umd.js ***!
  \**********************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval("/* module decorator */ module = __webpack_require__.nmd(module);\n(function (global, factory) {\n  if (true) {\n    factory(module, __webpack_require__(/*! @jridgewell/sourcemap-codec */ \"(ssr)/./node_modules/@jridgewell/sourcemap-codec/dist/sourcemap-codec.umd.js\"), __webpack_require__(/*! @jridgewell/trace-mapping */ \"(ssr)/./node_modules/@jridgewell/trace-mapping/dist/trace-mapping.umd.js\"));\n    module.exports = def(module);\n  } else {}\n  function def(m) { return 'default' in m.exports ? m.exports.default : m.exports; }\n})(this, (function (module, require_sourcemapCodec, require_traceMapping) {\n\"use strict\";\nvar __create = Object.create;\nvar __defProp = Object.defineProperty;\nvar __getOwnPropDesc = Object.getOwnPropertyDescriptor;\nvar __getOwnPropNames = Object.getOwnPropertyNames;\nvar __getProtoOf = Object.getPrototypeOf;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __commonJS = (cb, mod) => function __require() {\n  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;\n};\nvar __export = (target, all) => {\n  for (var name in all)\n    __defProp(target, name, { get: all[name], enumerable: true });\n};\nvar __copyProps = (to, from, except, desc) => {\n  if (from && typeof from === \"object\" || typeof from === \"function\") {\n    for (let key of __getOwnPropNames(from))\n      if (!__hasOwnProp.call(to, key) && key !== except)\n        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });\n  }\n  return to;\n};\nvar __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(\n  // If the importer is in node compatibility mode or this is not an ESM\n  // file that has been converted to a CommonJS file using a Babel-\n  // compatible transform (i.e. \"__esModule\" has not been set), then set\n  // \"default\" to the CommonJS \"module.exports\" for node compatibility.\n  isNodeMode || !mod || !mod.__esModule ? __defProp(target, \"default\", { value: mod, enumerable: true }) : target,\n  mod\n));\nvar __toCommonJS = (mod) => __copyProps(__defProp({}, \"__esModule\", { value: true }), mod);\n\n// umd:@jridgewell/sourcemap-codec\nvar require_sourcemap_codec = __commonJS({\n  \"umd:@jridgewell/sourcemap-codec\"(exports, module2) {\n    module2.exports = require_sourcemapCodec;\n  }\n});\n\n// umd:@jridgewell/trace-mapping\nvar require_trace_mapping = __commonJS({\n  \"umd:@jridgewell/trace-mapping\"(exports, module2) {\n    module2.exports = require_traceMapping;\n  }\n});\n\n// src/gen-mapping.ts\nvar gen_mapping_exports = {};\n__export(gen_mapping_exports, {\n  GenMapping: () => GenMapping,\n  addMapping: () => addMapping,\n  addSegment: () => addSegment,\n  allMappings: () => allMappings,\n  fromMap: () => fromMap,\n  maybeAddMapping: () => maybeAddMapping,\n  maybeAddSegment: () => maybeAddSegment,\n  setIgnore: () => setIgnore,\n  setSourceContent: () => setSourceContent,\n  toDecodedMap: () => toDecodedMap,\n  toEncodedMap: () => toEncodedMap\n});\nmodule.exports = __toCommonJS(gen_mapping_exports);\n\n// src/set-array.ts\nvar SetArray = class {\n  constructor() {\n    this._indexes = { __proto__: null };\n    this.array = [];\n  }\n};\nfunction cast(set) {\n  return set;\n}\nfunction get(setarr, key) {\n  return cast(setarr)._indexes[key];\n}\nfunction put(setarr, key) {\n  const index = get(setarr, key);\n  if (index !== void 0) return index;\n  const { array, _indexes: indexes } = cast(setarr);\n  const length = array.push(key);\n  return indexes[key] = length - 1;\n}\nfunction remove(setarr, key) {\n  const index = get(setarr, key);\n  if (index === void 0) return;\n  const { array, _indexes: indexes } = cast(setarr);\n  for (let i = index + 1; i < array.length; i++) {\n    const k = array[i];\n    array[i - 1] = k;\n    indexes[k]--;\n  }\n  indexes[key] = void 0;\n  array.pop();\n}\n\n// src/gen-mapping.ts\nvar import_sourcemap_codec = __toESM(require_sourcemap_codec());\nvar import_trace_mapping = __toESM(require_trace_mapping());\n\n// src/sourcemap-segment.ts\nvar COLUMN = 0;\nvar SOURCES_INDEX = 1;\nvar SOURCE_LINE = 2;\nvar SOURCE_COLUMN = 3;\nvar NAMES_INDEX = 4;\n\n// src/gen-mapping.ts\nvar NO_NAME = -1;\nvar GenMapping = class {\n  constructor({ file, sourceRoot } = {}) {\n    this._names = new SetArray();\n    this._sources = new SetArray();\n    this._sourcesContent = [];\n    this._mappings = [];\n    this.file = file;\n    this.sourceRoot = sourceRoot;\n    this._ignoreList = new SetArray();\n  }\n};\nfunction cast2(map) {\n  return map;\n}\nfunction addSegment(map, genLine, genColumn, source, sourceLine, sourceColumn, name, content) {\n  return addSegmentInternal(\n    false,\n    map,\n    genLine,\n    genColumn,\n    source,\n    sourceLine,\n    sourceColumn,\n    name,\n    content\n  );\n}\nfunction addMapping(map, mapping) {\n  return addMappingInternal(false, map, mapping);\n}\nvar maybeAddSegment = (map, genLine, genColumn, source, sourceLine, sourceColumn, name, content) => {\n  return addSegmentInternal(\n    true,\n    map,\n    genLine,\n    genColumn,\n    source,\n    sourceLine,\n    sourceColumn,\n    name,\n    content\n  );\n};\nvar maybeAddMapping = (map, mapping) => {\n  return addMappingInternal(true, map, mapping);\n};\nfunction setSourceContent(map, source, content) {\n  const {\n    _sources: sources,\n    _sourcesContent: sourcesContent\n    // _originalScopes: originalScopes,\n  } = cast2(map);\n  const index = put(sources, source);\n  sourcesContent[index] = content;\n}\nfunction setIgnore(map, source, ignore = true) {\n  const {\n    _sources: sources,\n    _sourcesContent: sourcesContent,\n    _ignoreList: ignoreList\n    // _originalScopes: originalScopes,\n  } = cast2(map);\n  const index = put(sources, source);\n  if (index === sourcesContent.length) sourcesContent[index] = null;\n  if (ignore) put(ignoreList, index);\n  else remove(ignoreList, index);\n}\nfunction toDecodedMap(map) {\n  const {\n    _mappings: mappings,\n    _sources: sources,\n    _sourcesContent: sourcesContent,\n    _names: names,\n    _ignoreList: ignoreList\n    // _originalScopes: originalScopes,\n    // _generatedRanges: generatedRanges,\n  } = cast2(map);\n  removeEmptyFinalLines(mappings);\n  return {\n    version: 3,\n    file: map.file || void 0,\n    names: names.array,\n    sourceRoot: map.sourceRoot || void 0,\n    sources: sources.array,\n    sourcesContent,\n    mappings,\n    // originalScopes,\n    // generatedRanges,\n    ignoreList: ignoreList.array\n  };\n}\nfunction toEncodedMap(map) {\n  const decoded = toDecodedMap(map);\n  return Object.assign({}, decoded, {\n    // originalScopes: decoded.originalScopes.map((os) => encodeOriginalScopes(os)),\n    // generatedRanges: encodeGeneratedRanges(decoded.generatedRanges as GeneratedRange[]),\n    mappings: (0, import_sourcemap_codec.encode)(decoded.mappings)\n  });\n}\nfunction fromMap(input) {\n  const map = new import_trace_mapping.TraceMap(input);\n  const gen = new GenMapping({ file: map.file, sourceRoot: map.sourceRoot });\n  putAll(cast2(gen)._names, map.names);\n  putAll(cast2(gen)._sources, map.sources);\n  cast2(gen)._sourcesContent = map.sourcesContent || map.sources.map(() => null);\n  cast2(gen)._mappings = (0, import_trace_mapping.decodedMappings)(map);\n  if (map.ignoreList) putAll(cast2(gen)._ignoreList, map.ignoreList);\n  return gen;\n}\nfunction allMappings(map) {\n  const out = [];\n  const { _mappings: mappings, _sources: sources, _names: names } = cast2(map);\n  for (let i = 0; i < mappings.length; i++) {\n    const line = mappings[i];\n    for (let j = 0; j < line.length; j++) {\n      const seg = line[j];\n      const generated = { line: i + 1, column: seg[COLUMN] };\n      let source = void 0;\n      let original = void 0;\n      let name = void 0;\n      if (seg.length !== 1) {\n        source = sources.array[seg[SOURCES_INDEX]];\n        original = { line: seg[SOURCE_LINE] + 1, column: seg[SOURCE_COLUMN] };\n        if (seg.length === 5) name = names.array[seg[NAMES_INDEX]];\n      }\n      out.push({ generated, source, original, name });\n    }\n  }\n  return out;\n}\nfunction addSegmentInternal(skipable, map, genLine, genColumn, source, sourceLine, sourceColumn, name, content) {\n  const {\n    _mappings: mappings,\n    _sources: sources,\n    _sourcesContent: sourcesContent,\n    _names: names\n    // _originalScopes: originalScopes,\n  } = cast2(map);\n  const line = getIndex(mappings, genLine);\n  const index = getColumnIndex(line, genColumn);\n  if (!source) {\n    if (skipable && skipSourceless(line, index)) return;\n    return insert(line, index, [genColumn]);\n  }\n  assert(sourceLine);\n  assert(sourceColumn);\n  const sourcesIndex = put(sources, source);\n  const namesIndex = name ? put(names, name) : NO_NAME;\n  if (sourcesIndex === sourcesContent.length) sourcesContent[sourcesIndex] = content != null ? content : null;\n  if (skipable && skipSource(line, index, sourcesIndex, sourceLine, sourceColumn, namesIndex)) {\n    return;\n  }\n  return insert(\n    line,\n    index,\n    name ? [genColumn, sourcesIndex, sourceLine, sourceColumn, namesIndex] : [genColumn, sourcesIndex, sourceLine, sourceColumn]\n  );\n}\nfunction assert(_val) {\n}\nfunction getIndex(arr, index) {\n  for (let i = arr.length; i <= index; i++) {\n    arr[i] = [];\n  }\n  return arr[index];\n}\nfunction getColumnIndex(line, genColumn) {\n  let index = line.length;\n  for (let i = index - 1; i >= 0; index = i--) {\n    const current = line[i];\n    if (genColumn >= current[COLUMN]) break;\n  }\n  return index;\n}\nfunction insert(array, index, value) {\n  for (let i = array.length; i > index; i--) {\n    array[i] = array[i - 1];\n  }\n  array[index] = value;\n}\nfunction removeEmptyFinalLines(mappings) {\n  const { length } = mappings;\n  let len = length;\n  for (let i = len - 1; i >= 0; len = i, i--) {\n    if (mappings[i].length > 0) break;\n  }\n  if (len < length) mappings.length = len;\n}\nfunction putAll(setarr, array) {\n  for (let i = 0; i < array.length; i++) put(setarr, array[i]);\n}\nfunction skipSourceless(line, index) {\n  if (index === 0) return true;\n  const prev = line[index - 1];\n  return prev.length === 1;\n}\nfunction skipSource(line, index, sourcesIndex, sourceLine, sourceColumn, namesIndex) {\n  if (index === 0) return false;\n  const prev = line[index - 1];\n  if (prev.length === 1) return false;\n  return sourcesIndex === prev[SOURCES_INDEX] && sourceLine === prev[SOURCE_LINE] && sourceColumn === prev[SOURCE_COLUMN] && namesIndex === (prev.length === 5 ? prev[NAMES_INDEX] : NO_NAME);\n}\nfunction addMappingInternal(skipable, map, mapping) {\n  const { generated, source, original, name, content } = mapping;\n  if (!source) {\n    return addSegmentInternal(\n      skipable,\n      map,\n      generated.line - 1,\n      generated.column,\n      null,\n      null,\n      null,\n      null,\n      null\n    );\n  }\n  assert(original);\n  return addSegmentInternal(\n    skipable,\n    map,\n    generated.line - 1,\n    generated.column,\n    source,\n    original.line - 1,\n    original.column,\n    name,\n    content\n  );\n}\n}));\n//# sourceMappingURL=gen-mapping.umd.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGpyaWRnZXdlbGwvZ2VuLW1hcHBpbmcvZGlzdC9nZW4tbWFwcGluZy51bWQuanMiLCJtYXBwaW5ncyI6IjtBQUFBO0FBQ0EsTUFBTSxJQUE0RDtBQUNsRSxvQkFBb0IsbUJBQU8sQ0FBQyxpSEFBNkIsR0FBRyxtQkFBTyxDQUFDLDJHQUEyQjtBQUMvRjtBQUNBLElBQUksS0FBSyxFQVVOO0FBQ0gsb0JBQW9CO0FBQ3BCLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkRBQTJELGFBQWE7QUFDeEU7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLGtDQUFrQztBQUNoRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLDRGQUE0RjtBQUN6SDtBQUNBO0FBQ0E7QUFDQSxtR0FBbUc7QUFDbkc7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5RUFBeUUsOEJBQThCO0FBQ3ZHO0FBQ0E7QUFDQSxvREFBb0Qsa0JBQWtCLGFBQWE7O0FBRW5GO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsMkJBQTJCO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsMkJBQTJCO0FBQ3JDLDBCQUEwQixrQkFBa0I7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsbUJBQW1CLElBQUk7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLCtCQUErQiw0Q0FBNEM7QUFDM0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVSx3REFBd0Q7QUFDbEUsa0JBQWtCLHFCQUFxQjtBQUN2QztBQUNBLG9CQUFvQixpQkFBaUI7QUFDckM7QUFDQSwwQkFBMEI7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0EsaUJBQWlCLG1DQUFtQztBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsWUFBWTtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsUUFBUTtBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsV0FBVztBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVSxTQUFTO0FBQ25CO0FBQ0Esd0JBQXdCLFFBQVE7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixrQkFBa0I7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLDZDQUE2QztBQUN2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcmVwby12aXN1YWxpemVyLy4vbm9kZV9tb2R1bGVzL0BqcmlkZ2V3ZWxsL2dlbi1tYXBwaW5nL2Rpc3QvZ2VuLW1hcHBpbmcudW1kLmpzP2YxMmYiXSwic291cmNlc0NvbnRlbnQiOlsiKGZ1bmN0aW9uIChnbG9iYWwsIGZhY3RvcnkpIHtcbiAgaWYgKHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJykge1xuICAgIGZhY3RvcnkobW9kdWxlLCByZXF1aXJlKCdAanJpZGdld2VsbC9zb3VyY2VtYXAtY29kZWMnKSwgcmVxdWlyZSgnQGpyaWRnZXdlbGwvdHJhY2UtbWFwcGluZycpKTtcbiAgICBtb2R1bGUuZXhwb3J0cyA9IGRlZihtb2R1bGUpO1xuICB9IGVsc2UgaWYgKHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCkge1xuICAgIGRlZmluZShbJ21vZHVsZScsICdAanJpZGdld2VsbC9zb3VyY2VtYXAtY29kZWMnLCAnQGpyaWRnZXdlbGwvdHJhY2UtbWFwcGluZyddLCBmdW5jdGlvbihtb2QpIHtcbiAgICAgIGZhY3RvcnkuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgIG1vZC5leHBvcnRzID0gZGVmKG1vZCk7XG4gICAgfSk7XG4gIH0gZWxzZSB7XG4gICAgY29uc3QgbW9kID0geyBleHBvcnRzOiB7fSB9O1xuICAgIGZhY3RvcnkobW9kLCBnbG9iYWwuc291cmNlbWFwQ29kZWMsIGdsb2JhbC50cmFjZU1hcHBpbmcpO1xuICAgIGdsb2JhbCA9IHR5cGVvZiBnbG9iYWxUaGlzICE9PSAndW5kZWZpbmVkJyA/IGdsb2JhbFRoaXMgOiBnbG9iYWwgfHwgc2VsZjtcbiAgICBnbG9iYWwuZ2VuTWFwcGluZyA9IGRlZihtb2QpO1xuICB9XG4gIGZ1bmN0aW9uIGRlZihtKSB7IHJldHVybiAnZGVmYXVsdCcgaW4gbS5leHBvcnRzID8gbS5leHBvcnRzLmRlZmF1bHQgOiBtLmV4cG9ydHM7IH1cbn0pKHRoaXMsIChmdW5jdGlvbiAobW9kdWxlLCByZXF1aXJlX3NvdXJjZW1hcENvZGVjLCByZXF1aXJlX3RyYWNlTWFwcGluZykge1xuXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19jcmVhdGUgPSBPYmplY3QuY3JlYXRlO1xudmFyIF9fZGVmUHJvcCA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eTtcbnZhciBfX2dldE93blByb3BEZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcjtcbnZhciBfX2dldE93blByb3BOYW1lcyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzO1xudmFyIF9fZ2V0UHJvdG9PZiA9IE9iamVjdC5nZXRQcm90b3R5cGVPZjtcbnZhciBfX2hhc093blByb3AgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xudmFyIF9fY29tbW9uSlMgPSAoY2IsIG1vZCkgPT4gZnVuY3Rpb24gX19yZXF1aXJlKCkge1xuICByZXR1cm4gbW9kIHx8ICgwLCBjYltfX2dldE93blByb3BOYW1lcyhjYilbMF1dKSgobW9kID0geyBleHBvcnRzOiB7fSB9KS5leHBvcnRzLCBtb2QpLCBtb2QuZXhwb3J0cztcbn07XG52YXIgX19leHBvcnQgPSAodGFyZ2V0LCBhbGwpID0+IHtcbiAgZm9yICh2YXIgbmFtZSBpbiBhbGwpXG4gICAgX19kZWZQcm9wKHRhcmdldCwgbmFtZSwgeyBnZXQ6IGFsbFtuYW1lXSwgZW51bWVyYWJsZTogdHJ1ZSB9KTtcbn07XG52YXIgX19jb3B5UHJvcHMgPSAodG8sIGZyb20sIGV4Y2VwdCwgZGVzYykgPT4ge1xuICBpZiAoZnJvbSAmJiB0eXBlb2YgZnJvbSA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgZnJvbSA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgZm9yIChsZXQga2V5IG9mIF9fZ2V0T3duUHJvcE5hbWVzKGZyb20pKVxuICAgICAgaWYgKCFfX2hhc093blByb3AuY2FsbCh0bywga2V5KSAmJiBrZXkgIT09IGV4Y2VwdClcbiAgICAgICAgX19kZWZQcm9wKHRvLCBrZXksIHsgZ2V0OiAoKSA9PiBmcm9tW2tleV0sIGVudW1lcmFibGU6ICEoZGVzYyA9IF9fZ2V0T3duUHJvcERlc2MoZnJvbSwga2V5KSkgfHwgZGVzYy5lbnVtZXJhYmxlIH0pO1xuICB9XG4gIHJldHVybiB0bztcbn07XG52YXIgX190b0VTTSA9IChtb2QsIGlzTm9kZU1vZGUsIHRhcmdldCkgPT4gKHRhcmdldCA9IG1vZCAhPSBudWxsID8gX19jcmVhdGUoX19nZXRQcm90b09mKG1vZCkpIDoge30sIF9fY29weVByb3BzKFxuICAvLyBJZiB0aGUgaW1wb3J0ZXIgaXMgaW4gbm9kZSBjb21wYXRpYmlsaXR5IG1vZGUgb3IgdGhpcyBpcyBub3QgYW4gRVNNXG4gIC8vIGZpbGUgdGhhdCBoYXMgYmVlbiBjb252ZXJ0ZWQgdG8gYSBDb21tb25KUyBmaWxlIHVzaW5nIGEgQmFiZWwtXG4gIC8vIGNvbXBhdGlibGUgdHJhbnNmb3JtIChpLmUuIFwiX19lc01vZHVsZVwiIGhhcyBub3QgYmVlbiBzZXQpLCB0aGVuIHNldFxuICAvLyBcImRlZmF1bHRcIiB0byB0aGUgQ29tbW9uSlMgXCJtb2R1bGUuZXhwb3J0c1wiIGZvciBub2RlIGNvbXBhdGliaWxpdHkuXG4gIGlzTm9kZU1vZGUgfHwgIW1vZCB8fCAhbW9kLl9fZXNNb2R1bGUgPyBfX2RlZlByb3AodGFyZ2V0LCBcImRlZmF1bHRcIiwgeyB2YWx1ZTogbW9kLCBlbnVtZXJhYmxlOiB0cnVlIH0pIDogdGFyZ2V0LFxuICBtb2RcbikpO1xudmFyIF9fdG9Db21tb25KUyA9IChtb2QpID0+IF9fY29weVByb3BzKF9fZGVmUHJvcCh7fSwgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSksIG1vZCk7XG5cbi8vIHVtZDpAanJpZGdld2VsbC9zb3VyY2VtYXAtY29kZWNcbnZhciByZXF1aXJlX3NvdXJjZW1hcF9jb2RlYyA9IF9fY29tbW9uSlMoe1xuICBcInVtZDpAanJpZGdld2VsbC9zb3VyY2VtYXAtY29kZWNcIihleHBvcnRzLCBtb2R1bGUyKSB7XG4gICAgbW9kdWxlMi5leHBvcnRzID0gcmVxdWlyZV9zb3VyY2VtYXBDb2RlYztcbiAgfVxufSk7XG5cbi8vIHVtZDpAanJpZGdld2VsbC90cmFjZS1tYXBwaW5nXG52YXIgcmVxdWlyZV90cmFjZV9tYXBwaW5nID0gX19jb21tb25KUyh7XG4gIFwidW1kOkBqcmlkZ2V3ZWxsL3RyYWNlLW1hcHBpbmdcIihleHBvcnRzLCBtb2R1bGUyKSB7XG4gICAgbW9kdWxlMi5leHBvcnRzID0gcmVxdWlyZV90cmFjZU1hcHBpbmc7XG4gIH1cbn0pO1xuXG4vLyBzcmMvZ2VuLW1hcHBpbmcudHNcbnZhciBnZW5fbWFwcGluZ19leHBvcnRzID0ge307XG5fX2V4cG9ydChnZW5fbWFwcGluZ19leHBvcnRzLCB7XG4gIEdlbk1hcHBpbmc6ICgpID0+IEdlbk1hcHBpbmcsXG4gIGFkZE1hcHBpbmc6ICgpID0+IGFkZE1hcHBpbmcsXG4gIGFkZFNlZ21lbnQ6ICgpID0+IGFkZFNlZ21lbnQsXG4gIGFsbE1hcHBpbmdzOiAoKSA9PiBhbGxNYXBwaW5ncyxcbiAgZnJvbU1hcDogKCkgPT4gZnJvbU1hcCxcbiAgbWF5YmVBZGRNYXBwaW5nOiAoKSA9PiBtYXliZUFkZE1hcHBpbmcsXG4gIG1heWJlQWRkU2VnbWVudDogKCkgPT4gbWF5YmVBZGRTZWdtZW50LFxuICBzZXRJZ25vcmU6ICgpID0+IHNldElnbm9yZSxcbiAgc2V0U291cmNlQ29udGVudDogKCkgPT4gc2V0U291cmNlQ29udGVudCxcbiAgdG9EZWNvZGVkTWFwOiAoKSA9PiB0b0RlY29kZWRNYXAsXG4gIHRvRW5jb2RlZE1hcDogKCkgPT4gdG9FbmNvZGVkTWFwXG59KTtcbm1vZHVsZS5leHBvcnRzID0gX190b0NvbW1vbkpTKGdlbl9tYXBwaW5nX2V4cG9ydHMpO1xuXG4vLyBzcmMvc2V0LWFycmF5LnRzXG52YXIgU2V0QXJyYXkgPSBjbGFzcyB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHRoaXMuX2luZGV4ZXMgPSB7IF9fcHJvdG9fXzogbnVsbCB9O1xuICAgIHRoaXMuYXJyYXkgPSBbXTtcbiAgfVxufTtcbmZ1bmN0aW9uIGNhc3Qoc2V0KSB7XG4gIHJldHVybiBzZXQ7XG59XG5mdW5jdGlvbiBnZXQoc2V0YXJyLCBrZXkpIHtcbiAgcmV0dXJuIGNhc3Qoc2V0YXJyKS5faW5kZXhlc1trZXldO1xufVxuZnVuY3Rpb24gcHV0KHNldGFyciwga2V5KSB7XG4gIGNvbnN0IGluZGV4ID0gZ2V0KHNldGFyciwga2V5KTtcbiAgaWYgKGluZGV4ICE9PSB2b2lkIDApIHJldHVybiBpbmRleDtcbiAgY29uc3QgeyBhcnJheSwgX2luZGV4ZXM6IGluZGV4ZXMgfSA9IGNhc3Qoc2V0YXJyKTtcbiAgY29uc3QgbGVuZ3RoID0gYXJyYXkucHVzaChrZXkpO1xuICByZXR1cm4gaW5kZXhlc1trZXldID0gbGVuZ3RoIC0gMTtcbn1cbmZ1bmN0aW9uIHJlbW92ZShzZXRhcnIsIGtleSkge1xuICBjb25zdCBpbmRleCA9IGdldChzZXRhcnIsIGtleSk7XG4gIGlmIChpbmRleCA9PT0gdm9pZCAwKSByZXR1cm47XG4gIGNvbnN0IHsgYXJyYXksIF9pbmRleGVzOiBpbmRleGVzIH0gPSBjYXN0KHNldGFycik7XG4gIGZvciAobGV0IGkgPSBpbmRleCArIDE7IGkgPCBhcnJheS5sZW5ndGg7IGkrKykge1xuICAgIGNvbnN0IGsgPSBhcnJheVtpXTtcbiAgICBhcnJheVtpIC0gMV0gPSBrO1xuICAgIGluZGV4ZXNba10tLTtcbiAgfVxuICBpbmRleGVzW2tleV0gPSB2b2lkIDA7XG4gIGFycmF5LnBvcCgpO1xufVxuXG4vLyBzcmMvZ2VuLW1hcHBpbmcudHNcbnZhciBpbXBvcnRfc291cmNlbWFwX2NvZGVjID0gX190b0VTTShyZXF1aXJlX3NvdXJjZW1hcF9jb2RlYygpKTtcbnZhciBpbXBvcnRfdHJhY2VfbWFwcGluZyA9IF9fdG9FU00ocmVxdWlyZV90cmFjZV9tYXBwaW5nKCkpO1xuXG4vLyBzcmMvc291cmNlbWFwLXNlZ21lbnQudHNcbnZhciBDT0xVTU4gPSAwO1xudmFyIFNPVVJDRVNfSU5ERVggPSAxO1xudmFyIFNPVVJDRV9MSU5FID0gMjtcbnZhciBTT1VSQ0VfQ09MVU1OID0gMztcbnZhciBOQU1FU19JTkRFWCA9IDQ7XG5cbi8vIHNyYy9nZW4tbWFwcGluZy50c1xudmFyIE5PX05BTUUgPSAtMTtcbnZhciBHZW5NYXBwaW5nID0gY2xhc3Mge1xuICBjb25zdHJ1Y3Rvcih7IGZpbGUsIHNvdXJjZVJvb3QgfSA9IHt9KSB7XG4gICAgdGhpcy5fbmFtZXMgPSBuZXcgU2V0QXJyYXkoKTtcbiAgICB0aGlzLl9zb3VyY2VzID0gbmV3IFNldEFycmF5KCk7XG4gICAgdGhpcy5fc291cmNlc0NvbnRlbnQgPSBbXTtcbiAgICB0aGlzLl9tYXBwaW5ncyA9IFtdO1xuICAgIHRoaXMuZmlsZSA9IGZpbGU7XG4gICAgdGhpcy5zb3VyY2VSb290ID0gc291cmNlUm9vdDtcbiAgICB0aGlzLl9pZ25vcmVMaXN0ID0gbmV3IFNldEFycmF5KCk7XG4gIH1cbn07XG5mdW5jdGlvbiBjYXN0MihtYXApIHtcbiAgcmV0dXJuIG1hcDtcbn1cbmZ1bmN0aW9uIGFkZFNlZ21lbnQobWFwLCBnZW5MaW5lLCBnZW5Db2x1bW4sIHNvdXJjZSwgc291cmNlTGluZSwgc291cmNlQ29sdW1uLCBuYW1lLCBjb250ZW50KSB7XG4gIHJldHVybiBhZGRTZWdtZW50SW50ZXJuYWwoXG4gICAgZmFsc2UsXG4gICAgbWFwLFxuICAgIGdlbkxpbmUsXG4gICAgZ2VuQ29sdW1uLFxuICAgIHNvdXJjZSxcbiAgICBzb3VyY2VMaW5lLFxuICAgIHNvdXJjZUNvbHVtbixcbiAgICBuYW1lLFxuICAgIGNvbnRlbnRcbiAgKTtcbn1cbmZ1bmN0aW9uIGFkZE1hcHBpbmcobWFwLCBtYXBwaW5nKSB7XG4gIHJldHVybiBhZGRNYXBwaW5nSW50ZXJuYWwoZmFsc2UsIG1hcCwgbWFwcGluZyk7XG59XG52YXIgbWF5YmVBZGRTZWdtZW50ID0gKG1hcCwgZ2VuTGluZSwgZ2VuQ29sdW1uLCBzb3VyY2UsIHNvdXJjZUxpbmUsIHNvdXJjZUNvbHVtbiwgbmFtZSwgY29udGVudCkgPT4ge1xuICByZXR1cm4gYWRkU2VnbWVudEludGVybmFsKFxuICAgIHRydWUsXG4gICAgbWFwLFxuICAgIGdlbkxpbmUsXG4gICAgZ2VuQ29sdW1uLFxuICAgIHNvdXJjZSxcbiAgICBzb3VyY2VMaW5lLFxuICAgIHNvdXJjZUNvbHVtbixcbiAgICBuYW1lLFxuICAgIGNvbnRlbnRcbiAgKTtcbn07XG52YXIgbWF5YmVBZGRNYXBwaW5nID0gKG1hcCwgbWFwcGluZykgPT4ge1xuICByZXR1cm4gYWRkTWFwcGluZ0ludGVybmFsKHRydWUsIG1hcCwgbWFwcGluZyk7XG59O1xuZnVuY3Rpb24gc2V0U291cmNlQ29udGVudChtYXAsIHNvdXJjZSwgY29udGVudCkge1xuICBjb25zdCB7XG4gICAgX3NvdXJjZXM6IHNvdXJjZXMsXG4gICAgX3NvdXJjZXNDb250ZW50OiBzb3VyY2VzQ29udGVudFxuICAgIC8vIF9vcmlnaW5hbFNjb3Blczogb3JpZ2luYWxTY29wZXMsXG4gIH0gPSBjYXN0MihtYXApO1xuICBjb25zdCBpbmRleCA9IHB1dChzb3VyY2VzLCBzb3VyY2UpO1xuICBzb3VyY2VzQ29udGVudFtpbmRleF0gPSBjb250ZW50O1xufVxuZnVuY3Rpb24gc2V0SWdub3JlKG1hcCwgc291cmNlLCBpZ25vcmUgPSB0cnVlKSB7XG4gIGNvbnN0IHtcbiAgICBfc291cmNlczogc291cmNlcyxcbiAgICBfc291cmNlc0NvbnRlbnQ6IHNvdXJjZXNDb250ZW50LFxuICAgIF9pZ25vcmVMaXN0OiBpZ25vcmVMaXN0XG4gICAgLy8gX29yaWdpbmFsU2NvcGVzOiBvcmlnaW5hbFNjb3BlcyxcbiAgfSA9IGNhc3QyKG1hcCk7XG4gIGNvbnN0IGluZGV4ID0gcHV0KHNvdXJjZXMsIHNvdXJjZSk7XG4gIGlmIChpbmRleCA9PT0gc291cmNlc0NvbnRlbnQubGVuZ3RoKSBzb3VyY2VzQ29udGVudFtpbmRleF0gPSBudWxsO1xuICBpZiAoaWdub3JlKSBwdXQoaWdub3JlTGlzdCwgaW5kZXgpO1xuICBlbHNlIHJlbW92ZShpZ25vcmVMaXN0LCBpbmRleCk7XG59XG5mdW5jdGlvbiB0b0RlY29kZWRNYXAobWFwKSB7XG4gIGNvbnN0IHtcbiAgICBfbWFwcGluZ3M6IG1hcHBpbmdzLFxuICAgIF9zb3VyY2VzOiBzb3VyY2VzLFxuICAgIF9zb3VyY2VzQ29udGVudDogc291cmNlc0NvbnRlbnQsXG4gICAgX25hbWVzOiBuYW1lcyxcbiAgICBfaWdub3JlTGlzdDogaWdub3JlTGlzdFxuICAgIC8vIF9vcmlnaW5hbFNjb3Blczogb3JpZ2luYWxTY29wZXMsXG4gICAgLy8gX2dlbmVyYXRlZFJhbmdlczogZ2VuZXJhdGVkUmFuZ2VzLFxuICB9ID0gY2FzdDIobWFwKTtcbiAgcmVtb3ZlRW1wdHlGaW5hbExpbmVzKG1hcHBpbmdzKTtcbiAgcmV0dXJuIHtcbiAgICB2ZXJzaW9uOiAzLFxuICAgIGZpbGU6IG1hcC5maWxlIHx8IHZvaWQgMCxcbiAgICBuYW1lczogbmFtZXMuYXJyYXksXG4gICAgc291cmNlUm9vdDogbWFwLnNvdXJjZVJvb3QgfHwgdm9pZCAwLFxuICAgIHNvdXJjZXM6IHNvdXJjZXMuYXJyYXksXG4gICAgc291cmNlc0NvbnRlbnQsXG4gICAgbWFwcGluZ3MsXG4gICAgLy8gb3JpZ2luYWxTY29wZXMsXG4gICAgLy8gZ2VuZXJhdGVkUmFuZ2VzLFxuICAgIGlnbm9yZUxpc3Q6IGlnbm9yZUxpc3QuYXJyYXlcbiAgfTtcbn1cbmZ1bmN0aW9uIHRvRW5jb2RlZE1hcChtYXApIHtcbiAgY29uc3QgZGVjb2RlZCA9IHRvRGVjb2RlZE1hcChtYXApO1xuICByZXR1cm4gT2JqZWN0LmFzc2lnbih7fSwgZGVjb2RlZCwge1xuICAgIC8vIG9yaWdpbmFsU2NvcGVzOiBkZWNvZGVkLm9yaWdpbmFsU2NvcGVzLm1hcCgob3MpID0+IGVuY29kZU9yaWdpbmFsU2NvcGVzKG9zKSksXG4gICAgLy8gZ2VuZXJhdGVkUmFuZ2VzOiBlbmNvZGVHZW5lcmF0ZWRSYW5nZXMoZGVjb2RlZC5nZW5lcmF0ZWRSYW5nZXMgYXMgR2VuZXJhdGVkUmFuZ2VbXSksXG4gICAgbWFwcGluZ3M6ICgwLCBpbXBvcnRfc291cmNlbWFwX2NvZGVjLmVuY29kZSkoZGVjb2RlZC5tYXBwaW5ncylcbiAgfSk7XG59XG5mdW5jdGlvbiBmcm9tTWFwKGlucHV0KSB7XG4gIGNvbnN0IG1hcCA9IG5ldyBpbXBvcnRfdHJhY2VfbWFwcGluZy5UcmFjZU1hcChpbnB1dCk7XG4gIGNvbnN0IGdlbiA9IG5ldyBHZW5NYXBwaW5nKHsgZmlsZTogbWFwLmZpbGUsIHNvdXJjZVJvb3Q6IG1hcC5zb3VyY2VSb290IH0pO1xuICBwdXRBbGwoY2FzdDIoZ2VuKS5fbmFtZXMsIG1hcC5uYW1lcyk7XG4gIHB1dEFsbChjYXN0MihnZW4pLl9zb3VyY2VzLCBtYXAuc291cmNlcyk7XG4gIGNhc3QyKGdlbikuX3NvdXJjZXNDb250ZW50ID0gbWFwLnNvdXJjZXNDb250ZW50IHx8IG1hcC5zb3VyY2VzLm1hcCgoKSA9PiBudWxsKTtcbiAgY2FzdDIoZ2VuKS5fbWFwcGluZ3MgPSAoMCwgaW1wb3J0X3RyYWNlX21hcHBpbmcuZGVjb2RlZE1hcHBpbmdzKShtYXApO1xuICBpZiAobWFwLmlnbm9yZUxpc3QpIHB1dEFsbChjYXN0MihnZW4pLl9pZ25vcmVMaXN0LCBtYXAuaWdub3JlTGlzdCk7XG4gIHJldHVybiBnZW47XG59XG5mdW5jdGlvbiBhbGxNYXBwaW5ncyhtYXApIHtcbiAgY29uc3Qgb3V0ID0gW107XG4gIGNvbnN0IHsgX21hcHBpbmdzOiBtYXBwaW5ncywgX3NvdXJjZXM6IHNvdXJjZXMsIF9uYW1lczogbmFtZXMgfSA9IGNhc3QyKG1hcCk7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgbWFwcGluZ3MubGVuZ3RoOyBpKyspIHtcbiAgICBjb25zdCBsaW5lID0gbWFwcGluZ3NbaV07XG4gICAgZm9yIChsZXQgaiA9IDA7IGogPCBsaW5lLmxlbmd0aDsgaisrKSB7XG4gICAgICBjb25zdCBzZWcgPSBsaW5lW2pdO1xuICAgICAgY29uc3QgZ2VuZXJhdGVkID0geyBsaW5lOiBpICsgMSwgY29sdW1uOiBzZWdbQ09MVU1OXSB9O1xuICAgICAgbGV0IHNvdXJjZSA9IHZvaWQgMDtcbiAgICAgIGxldCBvcmlnaW5hbCA9IHZvaWQgMDtcbiAgICAgIGxldCBuYW1lID0gdm9pZCAwO1xuICAgICAgaWYgKHNlZy5sZW5ndGggIT09IDEpIHtcbiAgICAgICAgc291cmNlID0gc291cmNlcy5hcnJheVtzZWdbU09VUkNFU19JTkRFWF1dO1xuICAgICAgICBvcmlnaW5hbCA9IHsgbGluZTogc2VnW1NPVVJDRV9MSU5FXSArIDEsIGNvbHVtbjogc2VnW1NPVVJDRV9DT0xVTU5dIH07XG4gICAgICAgIGlmIChzZWcubGVuZ3RoID09PSA1KSBuYW1lID0gbmFtZXMuYXJyYXlbc2VnW05BTUVTX0lOREVYXV07XG4gICAgICB9XG4gICAgICBvdXQucHVzaCh7IGdlbmVyYXRlZCwgc291cmNlLCBvcmlnaW5hbCwgbmFtZSB9KTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIG91dDtcbn1cbmZ1bmN0aW9uIGFkZFNlZ21lbnRJbnRlcm5hbChza2lwYWJsZSwgbWFwLCBnZW5MaW5lLCBnZW5Db2x1bW4sIHNvdXJjZSwgc291cmNlTGluZSwgc291cmNlQ29sdW1uLCBuYW1lLCBjb250ZW50KSB7XG4gIGNvbnN0IHtcbiAgICBfbWFwcGluZ3M6IG1hcHBpbmdzLFxuICAgIF9zb3VyY2VzOiBzb3VyY2VzLFxuICAgIF9zb3VyY2VzQ29udGVudDogc291cmNlc0NvbnRlbnQsXG4gICAgX25hbWVzOiBuYW1lc1xuICAgIC8vIF9vcmlnaW5hbFNjb3Blczogb3JpZ2luYWxTY29wZXMsXG4gIH0gPSBjYXN0MihtYXApO1xuICBjb25zdCBsaW5lID0gZ2V0SW5kZXgobWFwcGluZ3MsIGdlbkxpbmUpO1xuICBjb25zdCBpbmRleCA9IGdldENvbHVtbkluZGV4KGxpbmUsIGdlbkNvbHVtbik7XG4gIGlmICghc291cmNlKSB7XG4gICAgaWYgKHNraXBhYmxlICYmIHNraXBTb3VyY2VsZXNzKGxpbmUsIGluZGV4KSkgcmV0dXJuO1xuICAgIHJldHVybiBpbnNlcnQobGluZSwgaW5kZXgsIFtnZW5Db2x1bW5dKTtcbiAgfVxuICBhc3NlcnQoc291cmNlTGluZSk7XG4gIGFzc2VydChzb3VyY2VDb2x1bW4pO1xuICBjb25zdCBzb3VyY2VzSW5kZXggPSBwdXQoc291cmNlcywgc291cmNlKTtcbiAgY29uc3QgbmFtZXNJbmRleCA9IG5hbWUgPyBwdXQobmFtZXMsIG5hbWUpIDogTk9fTkFNRTtcbiAgaWYgKHNvdXJjZXNJbmRleCA9PT0gc291cmNlc0NvbnRlbnQubGVuZ3RoKSBzb3VyY2VzQ29udGVudFtzb3VyY2VzSW5kZXhdID0gY29udGVudCAhPSBudWxsID8gY29udGVudCA6IG51bGw7XG4gIGlmIChza2lwYWJsZSAmJiBza2lwU291cmNlKGxpbmUsIGluZGV4LCBzb3VyY2VzSW5kZXgsIHNvdXJjZUxpbmUsIHNvdXJjZUNvbHVtbiwgbmFtZXNJbmRleCkpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgcmV0dXJuIGluc2VydChcbiAgICBsaW5lLFxuICAgIGluZGV4LFxuICAgIG5hbWUgPyBbZ2VuQ29sdW1uLCBzb3VyY2VzSW5kZXgsIHNvdXJjZUxpbmUsIHNvdXJjZUNvbHVtbiwgbmFtZXNJbmRleF0gOiBbZ2VuQ29sdW1uLCBzb3VyY2VzSW5kZXgsIHNvdXJjZUxpbmUsIHNvdXJjZUNvbHVtbl1cbiAgKTtcbn1cbmZ1bmN0aW9uIGFzc2VydChfdmFsKSB7XG59XG5mdW5jdGlvbiBnZXRJbmRleChhcnIsIGluZGV4KSB7XG4gIGZvciAobGV0IGkgPSBhcnIubGVuZ3RoOyBpIDw9IGluZGV4OyBpKyspIHtcbiAgICBhcnJbaV0gPSBbXTtcbiAgfVxuICByZXR1cm4gYXJyW2luZGV4XTtcbn1cbmZ1bmN0aW9uIGdldENvbHVtbkluZGV4KGxpbmUsIGdlbkNvbHVtbikge1xuICBsZXQgaW5kZXggPSBsaW5lLmxlbmd0aDtcbiAgZm9yIChsZXQgaSA9IGluZGV4IC0gMTsgaSA+PSAwOyBpbmRleCA9IGktLSkge1xuICAgIGNvbnN0IGN1cnJlbnQgPSBsaW5lW2ldO1xuICAgIGlmIChnZW5Db2x1bW4gPj0gY3VycmVudFtDT0xVTU5dKSBicmVhaztcbiAgfVxuICByZXR1cm4gaW5kZXg7XG59XG5mdW5jdGlvbiBpbnNlcnQoYXJyYXksIGluZGV4LCB2YWx1ZSkge1xuICBmb3IgKGxldCBpID0gYXJyYXkubGVuZ3RoOyBpID4gaW5kZXg7IGktLSkge1xuICAgIGFycmF5W2ldID0gYXJyYXlbaSAtIDFdO1xuICB9XG4gIGFycmF5W2luZGV4XSA9IHZhbHVlO1xufVxuZnVuY3Rpb24gcmVtb3ZlRW1wdHlGaW5hbExpbmVzKG1hcHBpbmdzKSB7XG4gIGNvbnN0IHsgbGVuZ3RoIH0gPSBtYXBwaW5ncztcbiAgbGV0IGxlbiA9IGxlbmd0aDtcbiAgZm9yIChsZXQgaSA9IGxlbiAtIDE7IGkgPj0gMDsgbGVuID0gaSwgaS0tKSB7XG4gICAgaWYgKG1hcHBpbmdzW2ldLmxlbmd0aCA+IDApIGJyZWFrO1xuICB9XG4gIGlmIChsZW4gPCBsZW5ndGgpIG1hcHBpbmdzLmxlbmd0aCA9IGxlbjtcbn1cbmZ1bmN0aW9uIHB1dEFsbChzZXRhcnIsIGFycmF5KSB7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgYXJyYXkubGVuZ3RoOyBpKyspIHB1dChzZXRhcnIsIGFycmF5W2ldKTtcbn1cbmZ1bmN0aW9uIHNraXBTb3VyY2VsZXNzKGxpbmUsIGluZGV4KSB7XG4gIGlmIChpbmRleCA9PT0gMCkgcmV0dXJuIHRydWU7XG4gIGNvbnN0IHByZXYgPSBsaW5lW2luZGV4IC0gMV07XG4gIHJldHVybiBwcmV2Lmxlbmd0aCA9PT0gMTtcbn1cbmZ1bmN0aW9uIHNraXBTb3VyY2UobGluZSwgaW5kZXgsIHNvdXJjZXNJbmRleCwgc291cmNlTGluZSwgc291cmNlQ29sdW1uLCBuYW1lc0luZGV4KSB7XG4gIGlmIChpbmRleCA9PT0gMCkgcmV0dXJuIGZhbHNlO1xuICBjb25zdCBwcmV2ID0gbGluZVtpbmRleCAtIDFdO1xuICBpZiAocHJldi5sZW5ndGggPT09IDEpIHJldHVybiBmYWxzZTtcbiAgcmV0dXJuIHNvdXJjZXNJbmRleCA9PT0gcHJldltTT1VSQ0VTX0lOREVYXSAmJiBzb3VyY2VMaW5lID09PSBwcmV2W1NPVVJDRV9MSU5FXSAmJiBzb3VyY2VDb2x1bW4gPT09IHByZXZbU09VUkNFX0NPTFVNTl0gJiYgbmFtZXNJbmRleCA9PT0gKHByZXYubGVuZ3RoID09PSA1ID8gcHJldltOQU1FU19JTkRFWF0gOiBOT19OQU1FKTtcbn1cbmZ1bmN0aW9uIGFkZE1hcHBpbmdJbnRlcm5hbChza2lwYWJsZSwgbWFwLCBtYXBwaW5nKSB7XG4gIGNvbnN0IHsgZ2VuZXJhdGVkLCBzb3VyY2UsIG9yaWdpbmFsLCBuYW1lLCBjb250ZW50IH0gPSBtYXBwaW5nO1xuICBpZiAoIXNvdXJjZSkge1xuICAgIHJldHVybiBhZGRTZWdtZW50SW50ZXJuYWwoXG4gICAgICBza2lwYWJsZSxcbiAgICAgIG1hcCxcbiAgICAgIGdlbmVyYXRlZC5saW5lIC0gMSxcbiAgICAgIGdlbmVyYXRlZC5jb2x1bW4sXG4gICAgICBudWxsLFxuICAgICAgbnVsbCxcbiAgICAgIG51bGwsXG4gICAgICBudWxsLFxuICAgICAgbnVsbFxuICAgICk7XG4gIH1cbiAgYXNzZXJ0KG9yaWdpbmFsKTtcbiAgcmV0dXJuIGFkZFNlZ21lbnRJbnRlcm5hbChcbiAgICBza2lwYWJsZSxcbiAgICBtYXAsXG4gICAgZ2VuZXJhdGVkLmxpbmUgLSAxLFxuICAgIGdlbmVyYXRlZC5jb2x1bW4sXG4gICAgc291cmNlLFxuICAgIG9yaWdpbmFsLmxpbmUgLSAxLFxuICAgIG9yaWdpbmFsLmNvbHVtbixcbiAgICBuYW1lLFxuICAgIGNvbnRlbnRcbiAgKTtcbn1cbn0pKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWdlbi1tYXBwaW5nLnVtZC5qcy5tYXBcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@jridgewell/gen-mapping/dist/gen-mapping.umd.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@jridgewell/resolve-uri/dist/resolve-uri.umd.js":
/*!**********************************************************************!*\
  !*** ./node_modules/@jridgewell/resolve-uri/dist/resolve-uri.umd.js ***!
  \**********************************************************************/
/***/ (function(module) {

eval("(function (global, factory) {\n     true ? module.exports = factory() :\n    0;\n})(this, (function () { 'use strict';\n\n    // Matches the scheme of a URL, eg \"http://\"\n    const schemeRegex = /^[\\w+.-]+:\\/\\//;\n    /**\n     * Matches the parts of a URL:\n     * 1. Scheme, including \":\", guaranteed.\n     * 2. User/password, including \"@\", optional.\n     * 3. Host, guaranteed.\n     * 4. Port, including \":\", optional.\n     * 5. Path, including \"/\", optional.\n     * 6. Query, including \"?\", optional.\n     * 7. Hash, including \"#\", optional.\n     */\n    const urlRegex = /^([\\w+.-]+:)\\/\\/([^@/#?]*@)?([^:/#?]*)(:\\d+)?(\\/[^#?]*)?(\\?[^#]*)?(#.*)?/;\n    /**\n     * File URLs are weird. They dont' need the regular `//` in the scheme, they may or may not start\n     * with a leading `/`, they can have a domain (but only if they don't start with a Windows drive).\n     *\n     * 1. Host, optional.\n     * 2. Path, which may include \"/\", guaranteed.\n     * 3. Query, including \"?\", optional.\n     * 4. Hash, including \"#\", optional.\n     */\n    const fileRegex = /^file:(?:\\/\\/((?![a-z]:)[^/#?]*)?)?(\\/?[^#?]*)(\\?[^#]*)?(#.*)?/i;\n    function isAbsoluteUrl(input) {\n        return schemeRegex.test(input);\n    }\n    function isSchemeRelativeUrl(input) {\n        return input.startsWith('//');\n    }\n    function isAbsolutePath(input) {\n        return input.startsWith('/');\n    }\n    function isFileUrl(input) {\n        return input.startsWith('file:');\n    }\n    function isRelative(input) {\n        return /^[.?#]/.test(input);\n    }\n    function parseAbsoluteUrl(input) {\n        const match = urlRegex.exec(input);\n        return makeUrl(match[1], match[2] || '', match[3], match[4] || '', match[5] || '/', match[6] || '', match[7] || '');\n    }\n    function parseFileUrl(input) {\n        const match = fileRegex.exec(input);\n        const path = match[2];\n        return makeUrl('file:', '', match[1] || '', '', isAbsolutePath(path) ? path : '/' + path, match[3] || '', match[4] || '');\n    }\n    function makeUrl(scheme, user, host, port, path, query, hash) {\n        return {\n            scheme,\n            user,\n            host,\n            port,\n            path,\n            query,\n            hash,\n            type: 7 /* Absolute */,\n        };\n    }\n    function parseUrl(input) {\n        if (isSchemeRelativeUrl(input)) {\n            const url = parseAbsoluteUrl('http:' + input);\n            url.scheme = '';\n            url.type = 6 /* SchemeRelative */;\n            return url;\n        }\n        if (isAbsolutePath(input)) {\n            const url = parseAbsoluteUrl('http://foo.com' + input);\n            url.scheme = '';\n            url.host = '';\n            url.type = 5 /* AbsolutePath */;\n            return url;\n        }\n        if (isFileUrl(input))\n            return parseFileUrl(input);\n        if (isAbsoluteUrl(input))\n            return parseAbsoluteUrl(input);\n        const url = parseAbsoluteUrl('http://foo.com/' + input);\n        url.scheme = '';\n        url.host = '';\n        url.type = input\n            ? input.startsWith('?')\n                ? 3 /* Query */\n                : input.startsWith('#')\n                    ? 2 /* Hash */\n                    : 4 /* RelativePath */\n            : 1 /* Empty */;\n        return url;\n    }\n    function stripPathFilename(path) {\n        // If a path ends with a parent directory \"..\", then it's a relative path with excess parent\n        // paths. It's not a file, so we can't strip it.\n        if (path.endsWith('/..'))\n            return path;\n        const index = path.lastIndexOf('/');\n        return path.slice(0, index + 1);\n    }\n    function mergePaths(url, base) {\n        normalizePath(base, base.type);\n        // If the path is just a \"/\", then it was an empty path to begin with (remember, we're a relative\n        // path).\n        if (url.path === '/') {\n            url.path = base.path;\n        }\n        else {\n            // Resolution happens relative to the base path's directory, not the file.\n            url.path = stripPathFilename(base.path) + url.path;\n        }\n    }\n    /**\n     * The path can have empty directories \"//\", unneeded parents \"foo/..\", or current directory\n     * \"foo/.\". We need to normalize to a standard representation.\n     */\n    function normalizePath(url, type) {\n        const rel = type <= 4 /* RelativePath */;\n        const pieces = url.path.split('/');\n        // We need to preserve the first piece always, so that we output a leading slash. The item at\n        // pieces[0] is an empty string.\n        let pointer = 1;\n        // Positive is the number of real directories we've output, used for popping a parent directory.\n        // Eg, \"foo/bar/..\" will have a positive 2, and we can decrement to be left with just \"foo\".\n        let positive = 0;\n        // We need to keep a trailing slash if we encounter an empty directory (eg, splitting \"foo/\" will\n        // generate `[\"foo\", \"\"]` pieces). And, if we pop a parent directory. But once we encounter a\n        // real directory, we won't need to append, unless the other conditions happen again.\n        let addTrailingSlash = false;\n        for (let i = 1; i < pieces.length; i++) {\n            const piece = pieces[i];\n            // An empty directory, could be a trailing slash, or just a double \"//\" in the path.\n            if (!piece) {\n                addTrailingSlash = true;\n                continue;\n            }\n            // If we encounter a real directory, then we don't need to append anymore.\n            addTrailingSlash = false;\n            // A current directory, which we can always drop.\n            if (piece === '.')\n                continue;\n            // A parent directory, we need to see if there are any real directories we can pop. Else, we\n            // have an excess of parents, and we'll need to keep the \"..\".\n            if (piece === '..') {\n                if (positive) {\n                    addTrailingSlash = true;\n                    positive--;\n                    pointer--;\n                }\n                else if (rel) {\n                    // If we're in a relativePath, then we need to keep the excess parents. Else, in an absolute\n                    // URL, protocol relative URL, or an absolute path, we don't need to keep excess.\n                    pieces[pointer++] = piece;\n                }\n                continue;\n            }\n            // We've encountered a real directory. Move it to the next insertion pointer, which accounts for\n            // any popped or dropped directories.\n            pieces[pointer++] = piece;\n            positive++;\n        }\n        let path = '';\n        for (let i = 1; i < pointer; i++) {\n            path += '/' + pieces[i];\n        }\n        if (!path || (addTrailingSlash && !path.endsWith('/..'))) {\n            path += '/';\n        }\n        url.path = path;\n    }\n    /**\n     * Attempts to resolve `input` URL/path relative to `base`.\n     */\n    function resolve(input, base) {\n        if (!input && !base)\n            return '';\n        const url = parseUrl(input);\n        let inputType = url.type;\n        if (base && inputType !== 7 /* Absolute */) {\n            const baseUrl = parseUrl(base);\n            const baseType = baseUrl.type;\n            switch (inputType) {\n                case 1 /* Empty */:\n                    url.hash = baseUrl.hash;\n                // fall through\n                case 2 /* Hash */:\n                    url.query = baseUrl.query;\n                // fall through\n                case 3 /* Query */:\n                case 4 /* RelativePath */:\n                    mergePaths(url, baseUrl);\n                // fall through\n                case 5 /* AbsolutePath */:\n                    // The host, user, and port are joined, you can't copy one without the others.\n                    url.user = baseUrl.user;\n                    url.host = baseUrl.host;\n                    url.port = baseUrl.port;\n                // fall through\n                case 6 /* SchemeRelative */:\n                    // The input doesn't have a schema at least, so we need to copy at least that over.\n                    url.scheme = baseUrl.scheme;\n            }\n            if (baseType > inputType)\n                inputType = baseType;\n        }\n        normalizePath(url, inputType);\n        const queryHash = url.query + url.hash;\n        switch (inputType) {\n            // This is impossible, because of the empty checks at the start of the function.\n            // case UrlType.Empty:\n            case 2 /* Hash */:\n            case 3 /* Query */:\n                return queryHash;\n            case 4 /* RelativePath */: {\n                // The first char is always a \"/\", and we need it to be relative.\n                const path = url.path.slice(1);\n                if (!path)\n                    return queryHash || '.';\n                if (isRelative(base || input) && !isRelative(path)) {\n                    // If base started with a leading \".\", or there is no base and input started with a \".\",\n                    // then we need to ensure that the relative path starts with a \".\". We don't know if\n                    // relative starts with a \"..\", though, so check before prepending.\n                    return './' + path + queryHash;\n                }\n                return path + queryHash;\n            }\n            case 5 /* AbsolutePath */:\n                return url.path + queryHash;\n            default:\n                return url.scheme + '//' + url.user + url.host + url.port + url.path + queryHash;\n        }\n    }\n\n    return resolve;\n\n}));\n//# sourceMappingURL=resolve-uri.umd.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGpyaWRnZXdlbGwvcmVzb2x2ZS11cmkvZGlzdC9yZXNvbHZlLXVyaS51bWQuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQSxJQUFJLEtBQTREO0FBQ2hFLElBQUksQ0FDeUc7QUFDN0csQ0FBQyx1QkFBdUI7O0FBRXhCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixtQkFBbUI7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixhQUFhO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxDQUFDO0FBQ0QiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9yZXBvLXZpc3VhbGl6ZXIvLi9ub2RlX21vZHVsZXMvQGpyaWRnZXdlbGwvcmVzb2x2ZS11cmkvZGlzdC9yZXNvbHZlLXVyaS51bWQuanM/ZmNkNiJdLCJzb3VyY2VzQ29udGVudCI6WyIoZnVuY3Rpb24gKGdsb2JhbCwgZmFjdG9yeSkge1xuICAgIHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJyA/IG1vZHVsZS5leHBvcnRzID0gZmFjdG9yeSgpIDpcbiAgICB0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQgPyBkZWZpbmUoZmFjdG9yeSkgOlxuICAgIChnbG9iYWwgPSB0eXBlb2YgZ2xvYmFsVGhpcyAhPT0gJ3VuZGVmaW5lZCcgPyBnbG9iYWxUaGlzIDogZ2xvYmFsIHx8IHNlbGYsIGdsb2JhbC5yZXNvbHZlVVJJID0gZmFjdG9yeSgpKTtcbn0pKHRoaXMsIChmdW5jdGlvbiAoKSB7ICd1c2Ugc3RyaWN0JztcblxuICAgIC8vIE1hdGNoZXMgdGhlIHNjaGVtZSBvZiBhIFVSTCwgZWcgXCJodHRwOi8vXCJcbiAgICBjb25zdCBzY2hlbWVSZWdleCA9IC9eW1xcdysuLV0rOlxcL1xcLy87XG4gICAgLyoqXG4gICAgICogTWF0Y2hlcyB0aGUgcGFydHMgb2YgYSBVUkw6XG4gICAgICogMS4gU2NoZW1lLCBpbmNsdWRpbmcgXCI6XCIsIGd1YXJhbnRlZWQuXG4gICAgICogMi4gVXNlci9wYXNzd29yZCwgaW5jbHVkaW5nIFwiQFwiLCBvcHRpb25hbC5cbiAgICAgKiAzLiBIb3N0LCBndWFyYW50ZWVkLlxuICAgICAqIDQuIFBvcnQsIGluY2x1ZGluZyBcIjpcIiwgb3B0aW9uYWwuXG4gICAgICogNS4gUGF0aCwgaW5jbHVkaW5nIFwiL1wiLCBvcHRpb25hbC5cbiAgICAgKiA2LiBRdWVyeSwgaW5jbHVkaW5nIFwiP1wiLCBvcHRpb25hbC5cbiAgICAgKiA3LiBIYXNoLCBpbmNsdWRpbmcgXCIjXCIsIG9wdGlvbmFsLlxuICAgICAqL1xuICAgIGNvbnN0IHVybFJlZ2V4ID0gL14oW1xcdysuLV0rOilcXC9cXC8oW15ALyM/XSpAKT8oW146LyM/XSopKDpcXGQrKT8oXFwvW14jP10qKT8oXFw/W14jXSopPygjLiopPy87XG4gICAgLyoqXG4gICAgICogRmlsZSBVUkxzIGFyZSB3ZWlyZC4gVGhleSBkb250JyBuZWVkIHRoZSByZWd1bGFyIGAvL2AgaW4gdGhlIHNjaGVtZSwgdGhleSBtYXkgb3IgbWF5IG5vdCBzdGFydFxuICAgICAqIHdpdGggYSBsZWFkaW5nIGAvYCwgdGhleSBjYW4gaGF2ZSBhIGRvbWFpbiAoYnV0IG9ubHkgaWYgdGhleSBkb24ndCBzdGFydCB3aXRoIGEgV2luZG93cyBkcml2ZSkuXG4gICAgICpcbiAgICAgKiAxLiBIb3N0LCBvcHRpb25hbC5cbiAgICAgKiAyLiBQYXRoLCB3aGljaCBtYXkgaW5jbHVkZSBcIi9cIiwgZ3VhcmFudGVlZC5cbiAgICAgKiAzLiBRdWVyeSwgaW5jbHVkaW5nIFwiP1wiLCBvcHRpb25hbC5cbiAgICAgKiA0LiBIYXNoLCBpbmNsdWRpbmcgXCIjXCIsIG9wdGlvbmFsLlxuICAgICAqL1xuICAgIGNvbnN0IGZpbGVSZWdleCA9IC9eZmlsZTooPzpcXC9cXC8oKD8hW2Etel06KVteLyM/XSopPyk/KFxcLz9bXiM/XSopKFxcP1teI10qKT8oIy4qKT8vaTtcbiAgICBmdW5jdGlvbiBpc0Fic29sdXRlVXJsKGlucHV0KSB7XG4gICAgICAgIHJldHVybiBzY2hlbWVSZWdleC50ZXN0KGlucHV0KTtcbiAgICB9XG4gICAgZnVuY3Rpb24gaXNTY2hlbWVSZWxhdGl2ZVVybChpbnB1dCkge1xuICAgICAgICByZXR1cm4gaW5wdXQuc3RhcnRzV2l0aCgnLy8nKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gaXNBYnNvbHV0ZVBhdGgoaW5wdXQpIHtcbiAgICAgICAgcmV0dXJuIGlucHV0LnN0YXJ0c1dpdGgoJy8nKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gaXNGaWxlVXJsKGlucHV0KSB7XG4gICAgICAgIHJldHVybiBpbnB1dC5zdGFydHNXaXRoKCdmaWxlOicpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBpc1JlbGF0aXZlKGlucHV0KSB7XG4gICAgICAgIHJldHVybiAvXlsuPyNdLy50ZXN0KGlucHV0KTtcbiAgICB9XG4gICAgZnVuY3Rpb24gcGFyc2VBYnNvbHV0ZVVybChpbnB1dCkge1xuICAgICAgICBjb25zdCBtYXRjaCA9IHVybFJlZ2V4LmV4ZWMoaW5wdXQpO1xuICAgICAgICByZXR1cm4gbWFrZVVybChtYXRjaFsxXSwgbWF0Y2hbMl0gfHwgJycsIG1hdGNoWzNdLCBtYXRjaFs0XSB8fCAnJywgbWF0Y2hbNV0gfHwgJy8nLCBtYXRjaFs2XSB8fCAnJywgbWF0Y2hbN10gfHwgJycpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBwYXJzZUZpbGVVcmwoaW5wdXQpIHtcbiAgICAgICAgY29uc3QgbWF0Y2ggPSBmaWxlUmVnZXguZXhlYyhpbnB1dCk7XG4gICAgICAgIGNvbnN0IHBhdGggPSBtYXRjaFsyXTtcbiAgICAgICAgcmV0dXJuIG1ha2VVcmwoJ2ZpbGU6JywgJycsIG1hdGNoWzFdIHx8ICcnLCAnJywgaXNBYnNvbHV0ZVBhdGgocGF0aCkgPyBwYXRoIDogJy8nICsgcGF0aCwgbWF0Y2hbM10gfHwgJycsIG1hdGNoWzRdIHx8ICcnKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gbWFrZVVybChzY2hlbWUsIHVzZXIsIGhvc3QsIHBvcnQsIHBhdGgsIHF1ZXJ5LCBoYXNoKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBzY2hlbWUsXG4gICAgICAgICAgICB1c2VyLFxuICAgICAgICAgICAgaG9zdCxcbiAgICAgICAgICAgIHBvcnQsXG4gICAgICAgICAgICBwYXRoLFxuICAgICAgICAgICAgcXVlcnksXG4gICAgICAgICAgICBoYXNoLFxuICAgICAgICAgICAgdHlwZTogNyAvKiBBYnNvbHV0ZSAqLyxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgZnVuY3Rpb24gcGFyc2VVcmwoaW5wdXQpIHtcbiAgICAgICAgaWYgKGlzU2NoZW1lUmVsYXRpdmVVcmwoaW5wdXQpKSB7XG4gICAgICAgICAgICBjb25zdCB1cmwgPSBwYXJzZUFic29sdXRlVXJsKCdodHRwOicgKyBpbnB1dCk7XG4gICAgICAgICAgICB1cmwuc2NoZW1lID0gJyc7XG4gICAgICAgICAgICB1cmwudHlwZSA9IDYgLyogU2NoZW1lUmVsYXRpdmUgKi87XG4gICAgICAgICAgICByZXR1cm4gdXJsO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpc0Fic29sdXRlUGF0aChpbnB1dCkpIHtcbiAgICAgICAgICAgIGNvbnN0IHVybCA9IHBhcnNlQWJzb2x1dGVVcmwoJ2h0dHA6Ly9mb28uY29tJyArIGlucHV0KTtcbiAgICAgICAgICAgIHVybC5zY2hlbWUgPSAnJztcbiAgICAgICAgICAgIHVybC5ob3N0ID0gJyc7XG4gICAgICAgICAgICB1cmwudHlwZSA9IDUgLyogQWJzb2x1dGVQYXRoICovO1xuICAgICAgICAgICAgcmV0dXJuIHVybDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaXNGaWxlVXJsKGlucHV0KSlcbiAgICAgICAgICAgIHJldHVybiBwYXJzZUZpbGVVcmwoaW5wdXQpO1xuICAgICAgICBpZiAoaXNBYnNvbHV0ZVVybChpbnB1dCkpXG4gICAgICAgICAgICByZXR1cm4gcGFyc2VBYnNvbHV0ZVVybChpbnB1dCk7XG4gICAgICAgIGNvbnN0IHVybCA9IHBhcnNlQWJzb2x1dGVVcmwoJ2h0dHA6Ly9mb28uY29tLycgKyBpbnB1dCk7XG4gICAgICAgIHVybC5zY2hlbWUgPSAnJztcbiAgICAgICAgdXJsLmhvc3QgPSAnJztcbiAgICAgICAgdXJsLnR5cGUgPSBpbnB1dFxuICAgICAgICAgICAgPyBpbnB1dC5zdGFydHNXaXRoKCc/JylcbiAgICAgICAgICAgICAgICA/IDMgLyogUXVlcnkgKi9cbiAgICAgICAgICAgICAgICA6IGlucHV0LnN0YXJ0c1dpdGgoJyMnKVxuICAgICAgICAgICAgICAgICAgICA/IDIgLyogSGFzaCAqL1xuICAgICAgICAgICAgICAgICAgICA6IDQgLyogUmVsYXRpdmVQYXRoICovXG4gICAgICAgICAgICA6IDEgLyogRW1wdHkgKi87XG4gICAgICAgIHJldHVybiB1cmw7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHN0cmlwUGF0aEZpbGVuYW1lKHBhdGgpIHtcbiAgICAgICAgLy8gSWYgYSBwYXRoIGVuZHMgd2l0aCBhIHBhcmVudCBkaXJlY3RvcnkgXCIuLlwiLCB0aGVuIGl0J3MgYSByZWxhdGl2ZSBwYXRoIHdpdGggZXhjZXNzIHBhcmVudFxuICAgICAgICAvLyBwYXRocy4gSXQncyBub3QgYSBmaWxlLCBzbyB3ZSBjYW4ndCBzdHJpcCBpdC5cbiAgICAgICAgaWYgKHBhdGguZW5kc1dpdGgoJy8uLicpKVxuICAgICAgICAgICAgcmV0dXJuIHBhdGg7XG4gICAgICAgIGNvbnN0IGluZGV4ID0gcGF0aC5sYXN0SW5kZXhPZignLycpO1xuICAgICAgICByZXR1cm4gcGF0aC5zbGljZSgwLCBpbmRleCArIDEpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBtZXJnZVBhdGhzKHVybCwgYmFzZSkge1xuICAgICAgICBub3JtYWxpemVQYXRoKGJhc2UsIGJhc2UudHlwZSk7XG4gICAgICAgIC8vIElmIHRoZSBwYXRoIGlzIGp1c3QgYSBcIi9cIiwgdGhlbiBpdCB3YXMgYW4gZW1wdHkgcGF0aCB0byBiZWdpbiB3aXRoIChyZW1lbWJlciwgd2UncmUgYSByZWxhdGl2ZVxuICAgICAgICAvLyBwYXRoKS5cbiAgICAgICAgaWYgKHVybC5wYXRoID09PSAnLycpIHtcbiAgICAgICAgICAgIHVybC5wYXRoID0gYmFzZS5wYXRoO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLy8gUmVzb2x1dGlvbiBoYXBwZW5zIHJlbGF0aXZlIHRvIHRoZSBiYXNlIHBhdGgncyBkaXJlY3RvcnksIG5vdCB0aGUgZmlsZS5cbiAgICAgICAgICAgIHVybC5wYXRoID0gc3RyaXBQYXRoRmlsZW5hbWUoYmFzZS5wYXRoKSArIHVybC5wYXRoO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRoZSBwYXRoIGNhbiBoYXZlIGVtcHR5IGRpcmVjdG9yaWVzIFwiLy9cIiwgdW5uZWVkZWQgcGFyZW50cyBcImZvby8uLlwiLCBvciBjdXJyZW50IGRpcmVjdG9yeVxuICAgICAqIFwiZm9vLy5cIi4gV2UgbmVlZCB0byBub3JtYWxpemUgdG8gYSBzdGFuZGFyZCByZXByZXNlbnRhdGlvbi5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBub3JtYWxpemVQYXRoKHVybCwgdHlwZSkge1xuICAgICAgICBjb25zdCByZWwgPSB0eXBlIDw9IDQgLyogUmVsYXRpdmVQYXRoICovO1xuICAgICAgICBjb25zdCBwaWVjZXMgPSB1cmwucGF0aC5zcGxpdCgnLycpO1xuICAgICAgICAvLyBXZSBuZWVkIHRvIHByZXNlcnZlIHRoZSBmaXJzdCBwaWVjZSBhbHdheXMsIHNvIHRoYXQgd2Ugb3V0cHV0IGEgbGVhZGluZyBzbGFzaC4gVGhlIGl0ZW0gYXRcbiAgICAgICAgLy8gcGllY2VzWzBdIGlzIGFuIGVtcHR5IHN0cmluZy5cbiAgICAgICAgbGV0IHBvaW50ZXIgPSAxO1xuICAgICAgICAvLyBQb3NpdGl2ZSBpcyB0aGUgbnVtYmVyIG9mIHJlYWwgZGlyZWN0b3JpZXMgd2UndmUgb3V0cHV0LCB1c2VkIGZvciBwb3BwaW5nIGEgcGFyZW50IGRpcmVjdG9yeS5cbiAgICAgICAgLy8gRWcsIFwiZm9vL2Jhci8uLlwiIHdpbGwgaGF2ZSBhIHBvc2l0aXZlIDIsIGFuZCB3ZSBjYW4gZGVjcmVtZW50IHRvIGJlIGxlZnQgd2l0aCBqdXN0IFwiZm9vXCIuXG4gICAgICAgIGxldCBwb3NpdGl2ZSA9IDA7XG4gICAgICAgIC8vIFdlIG5lZWQgdG8ga2VlcCBhIHRyYWlsaW5nIHNsYXNoIGlmIHdlIGVuY291bnRlciBhbiBlbXB0eSBkaXJlY3RvcnkgKGVnLCBzcGxpdHRpbmcgXCJmb28vXCIgd2lsbFxuICAgICAgICAvLyBnZW5lcmF0ZSBgW1wiZm9vXCIsIFwiXCJdYCBwaWVjZXMpLiBBbmQsIGlmIHdlIHBvcCBhIHBhcmVudCBkaXJlY3RvcnkuIEJ1dCBvbmNlIHdlIGVuY291bnRlciBhXG4gICAgICAgIC8vIHJlYWwgZGlyZWN0b3J5LCB3ZSB3b24ndCBuZWVkIHRvIGFwcGVuZCwgdW5sZXNzIHRoZSBvdGhlciBjb25kaXRpb25zIGhhcHBlbiBhZ2Fpbi5cbiAgICAgICAgbGV0IGFkZFRyYWlsaW5nU2xhc2ggPSBmYWxzZTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDE7IGkgPCBwaWVjZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGNvbnN0IHBpZWNlID0gcGllY2VzW2ldO1xuICAgICAgICAgICAgLy8gQW4gZW1wdHkgZGlyZWN0b3J5LCBjb3VsZCBiZSBhIHRyYWlsaW5nIHNsYXNoLCBvciBqdXN0IGEgZG91YmxlIFwiLy9cIiBpbiB0aGUgcGF0aC5cbiAgICAgICAgICAgIGlmICghcGllY2UpIHtcbiAgICAgICAgICAgICAgICBhZGRUcmFpbGluZ1NsYXNoID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIElmIHdlIGVuY291bnRlciBhIHJlYWwgZGlyZWN0b3J5LCB0aGVuIHdlIGRvbid0IG5lZWQgdG8gYXBwZW5kIGFueW1vcmUuXG4gICAgICAgICAgICBhZGRUcmFpbGluZ1NsYXNoID0gZmFsc2U7XG4gICAgICAgICAgICAvLyBBIGN1cnJlbnQgZGlyZWN0b3J5LCB3aGljaCB3ZSBjYW4gYWx3YXlzIGRyb3AuXG4gICAgICAgICAgICBpZiAocGllY2UgPT09ICcuJylcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIC8vIEEgcGFyZW50IGRpcmVjdG9yeSwgd2UgbmVlZCB0byBzZWUgaWYgdGhlcmUgYXJlIGFueSByZWFsIGRpcmVjdG9yaWVzIHdlIGNhbiBwb3AuIEVsc2UsIHdlXG4gICAgICAgICAgICAvLyBoYXZlIGFuIGV4Y2VzcyBvZiBwYXJlbnRzLCBhbmQgd2UnbGwgbmVlZCB0byBrZWVwIHRoZSBcIi4uXCIuXG4gICAgICAgICAgICBpZiAocGllY2UgPT09ICcuLicpIHtcbiAgICAgICAgICAgICAgICBpZiAocG9zaXRpdmUpIHtcbiAgICAgICAgICAgICAgICAgICAgYWRkVHJhaWxpbmdTbGFzaCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIHBvc2l0aXZlLS07XG4gICAgICAgICAgICAgICAgICAgIHBvaW50ZXItLTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAocmVsKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIElmIHdlJ3JlIGluIGEgcmVsYXRpdmVQYXRoLCB0aGVuIHdlIG5lZWQgdG8ga2VlcCB0aGUgZXhjZXNzIHBhcmVudHMuIEVsc2UsIGluIGFuIGFic29sdXRlXG4gICAgICAgICAgICAgICAgICAgIC8vIFVSTCwgcHJvdG9jb2wgcmVsYXRpdmUgVVJMLCBvciBhbiBhYnNvbHV0ZSBwYXRoLCB3ZSBkb24ndCBuZWVkIHRvIGtlZXAgZXhjZXNzLlxuICAgICAgICAgICAgICAgICAgICBwaWVjZXNbcG9pbnRlcisrXSA9IHBpZWNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIFdlJ3ZlIGVuY291bnRlcmVkIGEgcmVhbCBkaXJlY3RvcnkuIE1vdmUgaXQgdG8gdGhlIG5leHQgaW5zZXJ0aW9uIHBvaW50ZXIsIHdoaWNoIGFjY291bnRzIGZvclxuICAgICAgICAgICAgLy8gYW55IHBvcHBlZCBvciBkcm9wcGVkIGRpcmVjdG9yaWVzLlxuICAgICAgICAgICAgcGllY2VzW3BvaW50ZXIrK10gPSBwaWVjZTtcbiAgICAgICAgICAgIHBvc2l0aXZlKys7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHBhdGggPSAnJztcbiAgICAgICAgZm9yIChsZXQgaSA9IDE7IGkgPCBwb2ludGVyOyBpKyspIHtcbiAgICAgICAgICAgIHBhdGggKz0gJy8nICsgcGllY2VzW2ldO1xuICAgICAgICB9XG4gICAgICAgIGlmICghcGF0aCB8fCAoYWRkVHJhaWxpbmdTbGFzaCAmJiAhcGF0aC5lbmRzV2l0aCgnLy4uJykpKSB7XG4gICAgICAgICAgICBwYXRoICs9ICcvJztcbiAgICAgICAgfVxuICAgICAgICB1cmwucGF0aCA9IHBhdGg7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEF0dGVtcHRzIHRvIHJlc29sdmUgYGlucHV0YCBVUkwvcGF0aCByZWxhdGl2ZSB0byBgYmFzZWAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gcmVzb2x2ZShpbnB1dCwgYmFzZSkge1xuICAgICAgICBpZiAoIWlucHV0ICYmICFiYXNlKVxuICAgICAgICAgICAgcmV0dXJuICcnO1xuICAgICAgICBjb25zdCB1cmwgPSBwYXJzZVVybChpbnB1dCk7XG4gICAgICAgIGxldCBpbnB1dFR5cGUgPSB1cmwudHlwZTtcbiAgICAgICAgaWYgKGJhc2UgJiYgaW5wdXRUeXBlICE9PSA3IC8qIEFic29sdXRlICovKSB7XG4gICAgICAgICAgICBjb25zdCBiYXNlVXJsID0gcGFyc2VVcmwoYmFzZSk7XG4gICAgICAgICAgICBjb25zdCBiYXNlVHlwZSA9IGJhc2VVcmwudHlwZTtcbiAgICAgICAgICAgIHN3aXRjaCAoaW5wdXRUeXBlKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAxIC8qIEVtcHR5ICovOlxuICAgICAgICAgICAgICAgICAgICB1cmwuaGFzaCA9IGJhc2VVcmwuaGFzaDtcbiAgICAgICAgICAgICAgICAvLyBmYWxsIHRocm91Z2hcbiAgICAgICAgICAgICAgICBjYXNlIDIgLyogSGFzaCAqLzpcbiAgICAgICAgICAgICAgICAgICAgdXJsLnF1ZXJ5ID0gYmFzZVVybC5xdWVyeTtcbiAgICAgICAgICAgICAgICAvLyBmYWxsIHRocm91Z2hcbiAgICAgICAgICAgICAgICBjYXNlIDMgLyogUXVlcnkgKi86XG4gICAgICAgICAgICAgICAgY2FzZSA0IC8qIFJlbGF0aXZlUGF0aCAqLzpcbiAgICAgICAgICAgICAgICAgICAgbWVyZ2VQYXRocyh1cmwsIGJhc2VVcmwpO1xuICAgICAgICAgICAgICAgIC8vIGZhbGwgdGhyb3VnaFxuICAgICAgICAgICAgICAgIGNhc2UgNSAvKiBBYnNvbHV0ZVBhdGggKi86XG4gICAgICAgICAgICAgICAgICAgIC8vIFRoZSBob3N0LCB1c2VyLCBhbmQgcG9ydCBhcmUgam9pbmVkLCB5b3UgY2FuJ3QgY29weSBvbmUgd2l0aG91dCB0aGUgb3RoZXJzLlxuICAgICAgICAgICAgICAgICAgICB1cmwudXNlciA9IGJhc2VVcmwudXNlcjtcbiAgICAgICAgICAgICAgICAgICAgdXJsLmhvc3QgPSBiYXNlVXJsLmhvc3Q7XG4gICAgICAgICAgICAgICAgICAgIHVybC5wb3J0ID0gYmFzZVVybC5wb3J0O1xuICAgICAgICAgICAgICAgIC8vIGZhbGwgdGhyb3VnaFxuICAgICAgICAgICAgICAgIGNhc2UgNiAvKiBTY2hlbWVSZWxhdGl2ZSAqLzpcbiAgICAgICAgICAgICAgICAgICAgLy8gVGhlIGlucHV0IGRvZXNuJ3QgaGF2ZSBhIHNjaGVtYSBhdCBsZWFzdCwgc28gd2UgbmVlZCB0byBjb3B5IGF0IGxlYXN0IHRoYXQgb3Zlci5cbiAgICAgICAgICAgICAgICAgICAgdXJsLnNjaGVtZSA9IGJhc2VVcmwuc2NoZW1lO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGJhc2VUeXBlID4gaW5wdXRUeXBlKVxuICAgICAgICAgICAgICAgIGlucHV0VHlwZSA9IGJhc2VUeXBlO1xuICAgICAgICB9XG4gICAgICAgIG5vcm1hbGl6ZVBhdGgodXJsLCBpbnB1dFR5cGUpO1xuICAgICAgICBjb25zdCBxdWVyeUhhc2ggPSB1cmwucXVlcnkgKyB1cmwuaGFzaDtcbiAgICAgICAgc3dpdGNoIChpbnB1dFR5cGUpIHtcbiAgICAgICAgICAgIC8vIFRoaXMgaXMgaW1wb3NzaWJsZSwgYmVjYXVzZSBvZiB0aGUgZW1wdHkgY2hlY2tzIGF0IHRoZSBzdGFydCBvZiB0aGUgZnVuY3Rpb24uXG4gICAgICAgICAgICAvLyBjYXNlIFVybFR5cGUuRW1wdHk6XG4gICAgICAgICAgICBjYXNlIDIgLyogSGFzaCAqLzpcbiAgICAgICAgICAgIGNhc2UgMyAvKiBRdWVyeSAqLzpcbiAgICAgICAgICAgICAgICByZXR1cm4gcXVlcnlIYXNoO1xuICAgICAgICAgICAgY2FzZSA0IC8qIFJlbGF0aXZlUGF0aCAqLzoge1xuICAgICAgICAgICAgICAgIC8vIFRoZSBmaXJzdCBjaGFyIGlzIGFsd2F5cyBhIFwiL1wiLCBhbmQgd2UgbmVlZCBpdCB0byBiZSByZWxhdGl2ZS5cbiAgICAgICAgICAgICAgICBjb25zdCBwYXRoID0gdXJsLnBhdGguc2xpY2UoMSk7XG4gICAgICAgICAgICAgICAgaWYgKCFwYXRoKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcXVlcnlIYXNoIHx8ICcuJztcbiAgICAgICAgICAgICAgICBpZiAoaXNSZWxhdGl2ZShiYXNlIHx8IGlucHV0KSAmJiAhaXNSZWxhdGl2ZShwYXRoKSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBJZiBiYXNlIHN0YXJ0ZWQgd2l0aCBhIGxlYWRpbmcgXCIuXCIsIG9yIHRoZXJlIGlzIG5vIGJhc2UgYW5kIGlucHV0IHN0YXJ0ZWQgd2l0aCBhIFwiLlwiLFxuICAgICAgICAgICAgICAgICAgICAvLyB0aGVuIHdlIG5lZWQgdG8gZW5zdXJlIHRoYXQgdGhlIHJlbGF0aXZlIHBhdGggc3RhcnRzIHdpdGggYSBcIi5cIi4gV2UgZG9uJ3Qga25vdyBpZlxuICAgICAgICAgICAgICAgICAgICAvLyByZWxhdGl2ZSBzdGFydHMgd2l0aCBhIFwiLi5cIiwgdGhvdWdoLCBzbyBjaGVjayBiZWZvcmUgcHJlcGVuZGluZy5cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuICcuLycgKyBwYXRoICsgcXVlcnlIYXNoO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gcGF0aCArIHF1ZXJ5SGFzaDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhc2UgNSAvKiBBYnNvbHV0ZVBhdGggKi86XG4gICAgICAgICAgICAgICAgcmV0dXJuIHVybC5wYXRoICsgcXVlcnlIYXNoO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICByZXR1cm4gdXJsLnNjaGVtZSArICcvLycgKyB1cmwudXNlciArIHVybC5ob3N0ICsgdXJsLnBvcnQgKyB1cmwucGF0aCArIHF1ZXJ5SGFzaDtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiByZXNvbHZlO1xuXG59KSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1yZXNvbHZlLXVyaS51bWQuanMubWFwXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@jridgewell/resolve-uri/dist/resolve-uri.umd.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@jridgewell/sourcemap-codec/dist/sourcemap-codec.umd.js":
/*!******************************************************************************!*\
  !*** ./node_modules/@jridgewell/sourcemap-codec/dist/sourcemap-codec.umd.js ***!
  \******************************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval("/* module decorator */ module = __webpack_require__.nmd(module);\n(function (global, factory) {\n  if (true) {\n    factory(module);\n    module.exports = def(module);\n  } else {}\n  function def(m) { return 'default' in m.exports ? m.exports.default : m.exports; }\n})(this, (function (module) {\n\"use strict\";\nvar __defProp = Object.defineProperty;\nvar __getOwnPropDesc = Object.getOwnPropertyDescriptor;\nvar __getOwnPropNames = Object.getOwnPropertyNames;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __export = (target, all) => {\n  for (var name in all)\n    __defProp(target, name, { get: all[name], enumerable: true });\n};\nvar __copyProps = (to, from, except, desc) => {\n  if (from && typeof from === \"object\" || typeof from === \"function\") {\n    for (let key of __getOwnPropNames(from))\n      if (!__hasOwnProp.call(to, key) && key !== except)\n        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });\n  }\n  return to;\n};\nvar __toCommonJS = (mod) => __copyProps(__defProp({}, \"__esModule\", { value: true }), mod);\n\n// src/sourcemap-codec.ts\nvar sourcemap_codec_exports = {};\n__export(sourcemap_codec_exports, {\n  decode: () => decode,\n  decodeGeneratedRanges: () => decodeGeneratedRanges,\n  decodeOriginalScopes: () => decodeOriginalScopes,\n  encode: () => encode,\n  encodeGeneratedRanges: () => encodeGeneratedRanges,\n  encodeOriginalScopes: () => encodeOriginalScopes\n});\nmodule.exports = __toCommonJS(sourcemap_codec_exports);\n\n// src/vlq.ts\nvar comma = \",\".charCodeAt(0);\nvar semicolon = \";\".charCodeAt(0);\nvar chars = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\";\nvar intToChar = new Uint8Array(64);\nvar charToInt = new Uint8Array(128);\nfor (let i = 0; i < chars.length; i++) {\n  const c = chars.charCodeAt(i);\n  intToChar[i] = c;\n  charToInt[c] = i;\n}\nfunction decodeInteger(reader, relative) {\n  let value = 0;\n  let shift = 0;\n  let integer = 0;\n  do {\n    const c = reader.next();\n    integer = charToInt[c];\n    value |= (integer & 31) << shift;\n    shift += 5;\n  } while (integer & 32);\n  const shouldNegate = value & 1;\n  value >>>= 1;\n  if (shouldNegate) {\n    value = -2147483648 | -value;\n  }\n  return relative + value;\n}\nfunction encodeInteger(builder, num, relative) {\n  let delta = num - relative;\n  delta = delta < 0 ? -delta << 1 | 1 : delta << 1;\n  do {\n    let clamped = delta & 31;\n    delta >>>= 5;\n    if (delta > 0) clamped |= 32;\n    builder.write(intToChar[clamped]);\n  } while (delta > 0);\n  return num;\n}\nfunction hasMoreVlq(reader, max) {\n  if (reader.pos >= max) return false;\n  return reader.peek() !== comma;\n}\n\n// src/strings.ts\nvar bufLength = 1024 * 16;\nvar td = typeof TextDecoder !== \"undefined\" ? /* @__PURE__ */ new TextDecoder() : typeof Buffer !== \"undefined\" ? {\n  decode(buf) {\n    const out = Buffer.from(buf.buffer, buf.byteOffset, buf.byteLength);\n    return out.toString();\n  }\n} : {\n  decode(buf) {\n    let out = \"\";\n    for (let i = 0; i < buf.length; i++) {\n      out += String.fromCharCode(buf[i]);\n    }\n    return out;\n  }\n};\nvar StringWriter = class {\n  constructor() {\n    this.pos = 0;\n    this.out = \"\";\n    this.buffer = new Uint8Array(bufLength);\n  }\n  write(v) {\n    const { buffer } = this;\n    buffer[this.pos++] = v;\n    if (this.pos === bufLength) {\n      this.out += td.decode(buffer);\n      this.pos = 0;\n    }\n  }\n  flush() {\n    const { buffer, out, pos } = this;\n    return pos > 0 ? out + td.decode(buffer.subarray(0, pos)) : out;\n  }\n};\nvar StringReader = class {\n  constructor(buffer) {\n    this.pos = 0;\n    this.buffer = buffer;\n  }\n  next() {\n    return this.buffer.charCodeAt(this.pos++);\n  }\n  peek() {\n    return this.buffer.charCodeAt(this.pos);\n  }\n  indexOf(char) {\n    const { buffer, pos } = this;\n    const idx = buffer.indexOf(char, pos);\n    return idx === -1 ? buffer.length : idx;\n  }\n};\n\n// src/scopes.ts\nvar EMPTY = [];\nfunction decodeOriginalScopes(input) {\n  const { length } = input;\n  const reader = new StringReader(input);\n  const scopes = [];\n  const stack = [];\n  let line = 0;\n  for (; reader.pos < length; reader.pos++) {\n    line = decodeInteger(reader, line);\n    const column = decodeInteger(reader, 0);\n    if (!hasMoreVlq(reader, length)) {\n      const last = stack.pop();\n      last[2] = line;\n      last[3] = column;\n      continue;\n    }\n    const kind = decodeInteger(reader, 0);\n    const fields = decodeInteger(reader, 0);\n    const hasName = fields & 1;\n    const scope = hasName ? [line, column, 0, 0, kind, decodeInteger(reader, 0)] : [line, column, 0, 0, kind];\n    let vars = EMPTY;\n    if (hasMoreVlq(reader, length)) {\n      vars = [];\n      do {\n        const varsIndex = decodeInteger(reader, 0);\n        vars.push(varsIndex);\n      } while (hasMoreVlq(reader, length));\n    }\n    scope.vars = vars;\n    scopes.push(scope);\n    stack.push(scope);\n  }\n  return scopes;\n}\nfunction encodeOriginalScopes(scopes) {\n  const writer = new StringWriter();\n  for (let i = 0; i < scopes.length; ) {\n    i = _encodeOriginalScopes(scopes, i, writer, [0]);\n  }\n  return writer.flush();\n}\nfunction _encodeOriginalScopes(scopes, index, writer, state) {\n  const scope = scopes[index];\n  const { 0: startLine, 1: startColumn, 2: endLine, 3: endColumn, 4: kind, vars } = scope;\n  if (index > 0) writer.write(comma);\n  state[0] = encodeInteger(writer, startLine, state[0]);\n  encodeInteger(writer, startColumn, 0);\n  encodeInteger(writer, kind, 0);\n  const fields = scope.length === 6 ? 1 : 0;\n  encodeInteger(writer, fields, 0);\n  if (scope.length === 6) encodeInteger(writer, scope[5], 0);\n  for (const v of vars) {\n    encodeInteger(writer, v, 0);\n  }\n  for (index++; index < scopes.length; ) {\n    const next = scopes[index];\n    const { 0: l, 1: c } = next;\n    if (l > endLine || l === endLine && c >= endColumn) {\n      break;\n    }\n    index = _encodeOriginalScopes(scopes, index, writer, state);\n  }\n  writer.write(comma);\n  state[0] = encodeInteger(writer, endLine, state[0]);\n  encodeInteger(writer, endColumn, 0);\n  return index;\n}\nfunction decodeGeneratedRanges(input) {\n  const { length } = input;\n  const reader = new StringReader(input);\n  const ranges = [];\n  const stack = [];\n  let genLine = 0;\n  let definitionSourcesIndex = 0;\n  let definitionScopeIndex = 0;\n  let callsiteSourcesIndex = 0;\n  let callsiteLine = 0;\n  let callsiteColumn = 0;\n  let bindingLine = 0;\n  let bindingColumn = 0;\n  do {\n    const semi = reader.indexOf(\";\");\n    let genColumn = 0;\n    for (; reader.pos < semi; reader.pos++) {\n      genColumn = decodeInteger(reader, genColumn);\n      if (!hasMoreVlq(reader, semi)) {\n        const last = stack.pop();\n        last[2] = genLine;\n        last[3] = genColumn;\n        continue;\n      }\n      const fields = decodeInteger(reader, 0);\n      const hasDefinition = fields & 1;\n      const hasCallsite = fields & 2;\n      const hasScope = fields & 4;\n      let callsite = null;\n      let bindings = EMPTY;\n      let range;\n      if (hasDefinition) {\n        const defSourcesIndex = decodeInteger(reader, definitionSourcesIndex);\n        definitionScopeIndex = decodeInteger(\n          reader,\n          definitionSourcesIndex === defSourcesIndex ? definitionScopeIndex : 0\n        );\n        definitionSourcesIndex = defSourcesIndex;\n        range = [genLine, genColumn, 0, 0, defSourcesIndex, definitionScopeIndex];\n      } else {\n        range = [genLine, genColumn, 0, 0];\n      }\n      range.isScope = !!hasScope;\n      if (hasCallsite) {\n        const prevCsi = callsiteSourcesIndex;\n        const prevLine = callsiteLine;\n        callsiteSourcesIndex = decodeInteger(reader, callsiteSourcesIndex);\n        const sameSource = prevCsi === callsiteSourcesIndex;\n        callsiteLine = decodeInteger(reader, sameSource ? callsiteLine : 0);\n        callsiteColumn = decodeInteger(\n          reader,\n          sameSource && prevLine === callsiteLine ? callsiteColumn : 0\n        );\n        callsite = [callsiteSourcesIndex, callsiteLine, callsiteColumn];\n      }\n      range.callsite = callsite;\n      if (hasMoreVlq(reader, semi)) {\n        bindings = [];\n        do {\n          bindingLine = genLine;\n          bindingColumn = genColumn;\n          const expressionsCount = decodeInteger(reader, 0);\n          let expressionRanges;\n          if (expressionsCount < -1) {\n            expressionRanges = [[decodeInteger(reader, 0)]];\n            for (let i = -1; i > expressionsCount; i--) {\n              const prevBl = bindingLine;\n              bindingLine = decodeInteger(reader, bindingLine);\n              bindingColumn = decodeInteger(reader, bindingLine === prevBl ? bindingColumn : 0);\n              const expression = decodeInteger(reader, 0);\n              expressionRanges.push([expression, bindingLine, bindingColumn]);\n            }\n          } else {\n            expressionRanges = [[expressionsCount]];\n          }\n          bindings.push(expressionRanges);\n        } while (hasMoreVlq(reader, semi));\n      }\n      range.bindings = bindings;\n      ranges.push(range);\n      stack.push(range);\n    }\n    genLine++;\n    reader.pos = semi + 1;\n  } while (reader.pos < length);\n  return ranges;\n}\nfunction encodeGeneratedRanges(ranges) {\n  if (ranges.length === 0) return \"\";\n  const writer = new StringWriter();\n  for (let i = 0; i < ranges.length; ) {\n    i = _encodeGeneratedRanges(ranges, i, writer, [0, 0, 0, 0, 0, 0, 0]);\n  }\n  return writer.flush();\n}\nfunction _encodeGeneratedRanges(ranges, index, writer, state) {\n  const range = ranges[index];\n  const {\n    0: startLine,\n    1: startColumn,\n    2: endLine,\n    3: endColumn,\n    isScope,\n    callsite,\n    bindings\n  } = range;\n  if (state[0] < startLine) {\n    catchupLine(writer, state[0], startLine);\n    state[0] = startLine;\n    state[1] = 0;\n  } else if (index > 0) {\n    writer.write(comma);\n  }\n  state[1] = encodeInteger(writer, range[1], state[1]);\n  const fields = (range.length === 6 ? 1 : 0) | (callsite ? 2 : 0) | (isScope ? 4 : 0);\n  encodeInteger(writer, fields, 0);\n  if (range.length === 6) {\n    const { 4: sourcesIndex, 5: scopesIndex } = range;\n    if (sourcesIndex !== state[2]) {\n      state[3] = 0;\n    }\n    state[2] = encodeInteger(writer, sourcesIndex, state[2]);\n    state[3] = encodeInteger(writer, scopesIndex, state[3]);\n  }\n  if (callsite) {\n    const { 0: sourcesIndex, 1: callLine, 2: callColumn } = range.callsite;\n    if (sourcesIndex !== state[4]) {\n      state[5] = 0;\n      state[6] = 0;\n    } else if (callLine !== state[5]) {\n      state[6] = 0;\n    }\n    state[4] = encodeInteger(writer, sourcesIndex, state[4]);\n    state[5] = encodeInteger(writer, callLine, state[5]);\n    state[6] = encodeInteger(writer, callColumn, state[6]);\n  }\n  if (bindings) {\n    for (const binding of bindings) {\n      if (binding.length > 1) encodeInteger(writer, -binding.length, 0);\n      const expression = binding[0][0];\n      encodeInteger(writer, expression, 0);\n      let bindingStartLine = startLine;\n      let bindingStartColumn = startColumn;\n      for (let i = 1; i < binding.length; i++) {\n        const expRange = binding[i];\n        bindingStartLine = encodeInteger(writer, expRange[1], bindingStartLine);\n        bindingStartColumn = encodeInteger(writer, expRange[2], bindingStartColumn);\n        encodeInteger(writer, expRange[0], 0);\n      }\n    }\n  }\n  for (index++; index < ranges.length; ) {\n    const next = ranges[index];\n    const { 0: l, 1: c } = next;\n    if (l > endLine || l === endLine && c >= endColumn) {\n      break;\n    }\n    index = _encodeGeneratedRanges(ranges, index, writer, state);\n  }\n  if (state[0] < endLine) {\n    catchupLine(writer, state[0], endLine);\n    state[0] = endLine;\n    state[1] = 0;\n  } else {\n    writer.write(comma);\n  }\n  state[1] = encodeInteger(writer, endColumn, state[1]);\n  return index;\n}\nfunction catchupLine(writer, lastLine, line) {\n  do {\n    writer.write(semicolon);\n  } while (++lastLine < line);\n}\n\n// src/sourcemap-codec.ts\nfunction decode(mappings) {\n  const { length } = mappings;\n  const reader = new StringReader(mappings);\n  const decoded = [];\n  let genColumn = 0;\n  let sourcesIndex = 0;\n  let sourceLine = 0;\n  let sourceColumn = 0;\n  let namesIndex = 0;\n  do {\n    const semi = reader.indexOf(\";\");\n    const line = [];\n    let sorted = true;\n    let lastCol = 0;\n    genColumn = 0;\n    while (reader.pos < semi) {\n      let seg;\n      genColumn = decodeInteger(reader, genColumn);\n      if (genColumn < lastCol) sorted = false;\n      lastCol = genColumn;\n      if (hasMoreVlq(reader, semi)) {\n        sourcesIndex = decodeInteger(reader, sourcesIndex);\n        sourceLine = decodeInteger(reader, sourceLine);\n        sourceColumn = decodeInteger(reader, sourceColumn);\n        if (hasMoreVlq(reader, semi)) {\n          namesIndex = decodeInteger(reader, namesIndex);\n          seg = [genColumn, sourcesIndex, sourceLine, sourceColumn, namesIndex];\n        } else {\n          seg = [genColumn, sourcesIndex, sourceLine, sourceColumn];\n        }\n      } else {\n        seg = [genColumn];\n      }\n      line.push(seg);\n      reader.pos++;\n    }\n    if (!sorted) sort(line);\n    decoded.push(line);\n    reader.pos = semi + 1;\n  } while (reader.pos <= length);\n  return decoded;\n}\nfunction sort(line) {\n  line.sort(sortComparator);\n}\nfunction sortComparator(a, b) {\n  return a[0] - b[0];\n}\nfunction encode(decoded) {\n  const writer = new StringWriter();\n  let sourcesIndex = 0;\n  let sourceLine = 0;\n  let sourceColumn = 0;\n  let namesIndex = 0;\n  for (let i = 0; i < decoded.length; i++) {\n    const line = decoded[i];\n    if (i > 0) writer.write(semicolon);\n    if (line.length === 0) continue;\n    let genColumn = 0;\n    for (let j = 0; j < line.length; j++) {\n      const segment = line[j];\n      if (j > 0) writer.write(comma);\n      genColumn = encodeInteger(writer, segment[0], genColumn);\n      if (segment.length === 1) continue;\n      sourcesIndex = encodeInteger(writer, segment[1], sourcesIndex);\n      sourceLine = encodeInteger(writer, segment[2], sourceLine);\n      sourceColumn = encodeInteger(writer, segment[3], sourceColumn);\n      if (segment.length === 4) continue;\n      namesIndex = encodeInteger(writer, segment[4], namesIndex);\n    }\n  }\n  return writer.flush();\n}\n}));\n//# sourceMappingURL=sourcemap-codec.umd.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGpyaWRnZXdlbGwvc291cmNlbWFwLWNvZGVjL2Rpc3Qvc291cmNlbWFwLWNvZGVjLnVtZC5qcyIsIm1hcHBpbmdzIjoiO0FBQUE7QUFDQSxNQUFNLElBQTREO0FBQ2xFO0FBQ0E7QUFDQSxJQUFJLEtBQUssRUFVTjtBQUNILG9CQUFvQjtBQUNwQixDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIsa0NBQWtDO0FBQ2hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsNEZBQTRGO0FBQ3pIO0FBQ0E7QUFDQTtBQUNBLG9EQUFvRCxrQkFBa0IsYUFBYTs7QUFFbkY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEOztBQUVBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLGtCQUFrQjtBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQSxvQkFBb0IsZ0JBQWdCO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksU0FBUztBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksbUJBQW1CO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksY0FBYztBQUMxQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLFNBQVM7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTLHFCQUFxQjtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLG1CQUFtQjtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLHdFQUF3RTtBQUNsRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQix1QkFBdUI7QUFDdkM7QUFDQSxZQUFZLGFBQWE7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsU0FBUztBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0M7QUFDbEM7QUFDQSxXQUFXLG1CQUFtQjtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QixzQkFBc0I7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLG1CQUFtQjtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksa0NBQWtDO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSw4Q0FBOEM7QUFDMUQ7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLG9CQUFvQjtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQix1QkFBdUI7QUFDdkM7QUFDQSxZQUFZLGFBQWE7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7O0FBRUE7QUFDQTtBQUNBLFVBQVUsU0FBUztBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLG9CQUFvQjtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixpQkFBaUI7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0QiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9yZXBvLXZpc3VhbGl6ZXIvLi9ub2RlX21vZHVsZXMvQGpyaWRnZXdlbGwvc291cmNlbWFwLWNvZGVjL2Rpc3Qvc291cmNlbWFwLWNvZGVjLnVtZC5qcz8zMjU3Il0sInNvdXJjZXNDb250ZW50IjpbIihmdW5jdGlvbiAoZ2xvYmFsLCBmYWN0b3J5KSB7XG4gIGlmICh0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIG1vZHVsZSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICBmYWN0b3J5KG1vZHVsZSk7XG4gICAgbW9kdWxlLmV4cG9ydHMgPSBkZWYobW9kdWxlKTtcbiAgfSBlbHNlIGlmICh0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQpIHtcbiAgICBkZWZpbmUoWydtb2R1bGUnXSwgZnVuY3Rpb24obW9kKSB7XG4gICAgICBmYWN0b3J5LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICBtb2QuZXhwb3J0cyA9IGRlZihtb2QpO1xuICAgIH0pO1xuICB9IGVsc2Uge1xuICAgIGNvbnN0IG1vZCA9IHsgZXhwb3J0czoge30gfTtcbiAgICBmYWN0b3J5KG1vZCk7XG4gICAgZ2xvYmFsID0gdHlwZW9mIGdsb2JhbFRoaXMgIT09ICd1bmRlZmluZWQnID8gZ2xvYmFsVGhpcyA6IGdsb2JhbCB8fCBzZWxmO1xuICAgIGdsb2JhbC5zb3VyY2VtYXBDb2RlYyA9IGRlZihtb2QpO1xuICB9XG4gIGZ1bmN0aW9uIGRlZihtKSB7IHJldHVybiAnZGVmYXVsdCcgaW4gbS5leHBvcnRzID8gbS5leHBvcnRzLmRlZmF1bHQgOiBtLmV4cG9ydHM7IH1cbn0pKHRoaXMsIChmdW5jdGlvbiAobW9kdWxlKSB7XG5cInVzZSBzdHJpY3RcIjtcbnZhciBfX2RlZlByb3AgPSBPYmplY3QuZGVmaW5lUHJvcGVydHk7XG52YXIgX19nZXRPd25Qcm9wRGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3I7XG52YXIgX19nZXRPd25Qcm9wTmFtZXMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcztcbnZhciBfX2hhc093blByb3AgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xudmFyIF9fZXhwb3J0ID0gKHRhcmdldCwgYWxsKSA9PiB7XG4gIGZvciAodmFyIG5hbWUgaW4gYWxsKVxuICAgIF9fZGVmUHJvcCh0YXJnZXQsIG5hbWUsIHsgZ2V0OiBhbGxbbmFtZV0sIGVudW1lcmFibGU6IHRydWUgfSk7XG59O1xudmFyIF9fY29weVByb3BzID0gKHRvLCBmcm9tLCBleGNlcHQsIGRlc2MpID0+IHtcbiAgaWYgKGZyb20gJiYgdHlwZW9mIGZyb20gPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIGZyb20gPT09IFwiZnVuY3Rpb25cIikge1xuICAgIGZvciAobGV0IGtleSBvZiBfX2dldE93blByb3BOYW1lcyhmcm9tKSlcbiAgICAgIGlmICghX19oYXNPd25Qcm9wLmNhbGwodG8sIGtleSkgJiYga2V5ICE9PSBleGNlcHQpXG4gICAgICAgIF9fZGVmUHJvcCh0bywga2V5LCB7IGdldDogKCkgPT4gZnJvbVtrZXldLCBlbnVtZXJhYmxlOiAhKGRlc2MgPSBfX2dldE93blByb3BEZXNjKGZyb20sIGtleSkpIHx8IGRlc2MuZW51bWVyYWJsZSB9KTtcbiAgfVxuICByZXR1cm4gdG87XG59O1xudmFyIF9fdG9Db21tb25KUyA9IChtb2QpID0+IF9fY29weVByb3BzKF9fZGVmUHJvcCh7fSwgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSksIG1vZCk7XG5cbi8vIHNyYy9zb3VyY2VtYXAtY29kZWMudHNcbnZhciBzb3VyY2VtYXBfY29kZWNfZXhwb3J0cyA9IHt9O1xuX19leHBvcnQoc291cmNlbWFwX2NvZGVjX2V4cG9ydHMsIHtcbiAgZGVjb2RlOiAoKSA9PiBkZWNvZGUsXG4gIGRlY29kZUdlbmVyYXRlZFJhbmdlczogKCkgPT4gZGVjb2RlR2VuZXJhdGVkUmFuZ2VzLFxuICBkZWNvZGVPcmlnaW5hbFNjb3BlczogKCkgPT4gZGVjb2RlT3JpZ2luYWxTY29wZXMsXG4gIGVuY29kZTogKCkgPT4gZW5jb2RlLFxuICBlbmNvZGVHZW5lcmF0ZWRSYW5nZXM6ICgpID0+IGVuY29kZUdlbmVyYXRlZFJhbmdlcyxcbiAgZW5jb2RlT3JpZ2luYWxTY29wZXM6ICgpID0+IGVuY29kZU9yaWdpbmFsU2NvcGVzXG59KTtcbm1vZHVsZS5leHBvcnRzID0gX190b0NvbW1vbkpTKHNvdXJjZW1hcF9jb2RlY19leHBvcnRzKTtcblxuLy8gc3JjL3ZscS50c1xudmFyIGNvbW1hID0gXCIsXCIuY2hhckNvZGVBdCgwKTtcbnZhciBzZW1pY29sb24gPSBcIjtcIi5jaGFyQ29kZUF0KDApO1xudmFyIGNoYXJzID0gXCJBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWmFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6MDEyMzQ1Njc4OSsvXCI7XG52YXIgaW50VG9DaGFyID0gbmV3IFVpbnQ4QXJyYXkoNjQpO1xudmFyIGNoYXJUb0ludCA9IG5ldyBVaW50OEFycmF5KDEyOCk7XG5mb3IgKGxldCBpID0gMDsgaSA8IGNoYXJzLmxlbmd0aDsgaSsrKSB7XG4gIGNvbnN0IGMgPSBjaGFycy5jaGFyQ29kZUF0KGkpO1xuICBpbnRUb0NoYXJbaV0gPSBjO1xuICBjaGFyVG9JbnRbY10gPSBpO1xufVxuZnVuY3Rpb24gZGVjb2RlSW50ZWdlcihyZWFkZXIsIHJlbGF0aXZlKSB7XG4gIGxldCB2YWx1ZSA9IDA7XG4gIGxldCBzaGlmdCA9IDA7XG4gIGxldCBpbnRlZ2VyID0gMDtcbiAgZG8ge1xuICAgIGNvbnN0IGMgPSByZWFkZXIubmV4dCgpO1xuICAgIGludGVnZXIgPSBjaGFyVG9JbnRbY107XG4gICAgdmFsdWUgfD0gKGludGVnZXIgJiAzMSkgPDwgc2hpZnQ7XG4gICAgc2hpZnQgKz0gNTtcbiAgfSB3aGlsZSAoaW50ZWdlciAmIDMyKTtcbiAgY29uc3Qgc2hvdWxkTmVnYXRlID0gdmFsdWUgJiAxO1xuICB2YWx1ZSA+Pj49IDE7XG4gIGlmIChzaG91bGROZWdhdGUpIHtcbiAgICB2YWx1ZSA9IC0yMTQ3NDgzNjQ4IHwgLXZhbHVlO1xuICB9XG4gIHJldHVybiByZWxhdGl2ZSArIHZhbHVlO1xufVxuZnVuY3Rpb24gZW5jb2RlSW50ZWdlcihidWlsZGVyLCBudW0sIHJlbGF0aXZlKSB7XG4gIGxldCBkZWx0YSA9IG51bSAtIHJlbGF0aXZlO1xuICBkZWx0YSA9IGRlbHRhIDwgMCA/IC1kZWx0YSA8PCAxIHwgMSA6IGRlbHRhIDw8IDE7XG4gIGRvIHtcbiAgICBsZXQgY2xhbXBlZCA9IGRlbHRhICYgMzE7XG4gICAgZGVsdGEgPj4+PSA1O1xuICAgIGlmIChkZWx0YSA+IDApIGNsYW1wZWQgfD0gMzI7XG4gICAgYnVpbGRlci53cml0ZShpbnRUb0NoYXJbY2xhbXBlZF0pO1xuICB9IHdoaWxlIChkZWx0YSA+IDApO1xuICByZXR1cm4gbnVtO1xufVxuZnVuY3Rpb24gaGFzTW9yZVZscShyZWFkZXIsIG1heCkge1xuICBpZiAocmVhZGVyLnBvcyA+PSBtYXgpIHJldHVybiBmYWxzZTtcbiAgcmV0dXJuIHJlYWRlci5wZWVrKCkgIT09IGNvbW1hO1xufVxuXG4vLyBzcmMvc3RyaW5ncy50c1xudmFyIGJ1Zkxlbmd0aCA9IDEwMjQgKiAxNjtcbnZhciB0ZCA9IHR5cGVvZiBUZXh0RGVjb2RlciAhPT0gXCJ1bmRlZmluZWRcIiA/IC8qIEBfX1BVUkVfXyAqLyBuZXcgVGV4dERlY29kZXIoKSA6IHR5cGVvZiBCdWZmZXIgIT09IFwidW5kZWZpbmVkXCIgPyB7XG4gIGRlY29kZShidWYpIHtcbiAgICBjb25zdCBvdXQgPSBCdWZmZXIuZnJvbShidWYuYnVmZmVyLCBidWYuYnl0ZU9mZnNldCwgYnVmLmJ5dGVMZW5ndGgpO1xuICAgIHJldHVybiBvdXQudG9TdHJpbmcoKTtcbiAgfVxufSA6IHtcbiAgZGVjb2RlKGJ1Zikge1xuICAgIGxldCBvdXQgPSBcIlwiO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYnVmLmxlbmd0aDsgaSsrKSB7XG4gICAgICBvdXQgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShidWZbaV0pO1xuICAgIH1cbiAgICByZXR1cm4gb3V0O1xuICB9XG59O1xudmFyIFN0cmluZ1dyaXRlciA9IGNsYXNzIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgdGhpcy5wb3MgPSAwO1xuICAgIHRoaXMub3V0ID0gXCJcIjtcbiAgICB0aGlzLmJ1ZmZlciA9IG5ldyBVaW50OEFycmF5KGJ1Zkxlbmd0aCk7XG4gIH1cbiAgd3JpdGUodikge1xuICAgIGNvbnN0IHsgYnVmZmVyIH0gPSB0aGlzO1xuICAgIGJ1ZmZlclt0aGlzLnBvcysrXSA9IHY7XG4gICAgaWYgKHRoaXMucG9zID09PSBidWZMZW5ndGgpIHtcbiAgICAgIHRoaXMub3V0ICs9IHRkLmRlY29kZShidWZmZXIpO1xuICAgICAgdGhpcy5wb3MgPSAwO1xuICAgIH1cbiAgfVxuICBmbHVzaCgpIHtcbiAgICBjb25zdCB7IGJ1ZmZlciwgb3V0LCBwb3MgfSA9IHRoaXM7XG4gICAgcmV0dXJuIHBvcyA+IDAgPyBvdXQgKyB0ZC5kZWNvZGUoYnVmZmVyLnN1YmFycmF5KDAsIHBvcykpIDogb3V0O1xuICB9XG59O1xudmFyIFN0cmluZ1JlYWRlciA9IGNsYXNzIHtcbiAgY29uc3RydWN0b3IoYnVmZmVyKSB7XG4gICAgdGhpcy5wb3MgPSAwO1xuICAgIHRoaXMuYnVmZmVyID0gYnVmZmVyO1xuICB9XG4gIG5leHQoKSB7XG4gICAgcmV0dXJuIHRoaXMuYnVmZmVyLmNoYXJDb2RlQXQodGhpcy5wb3MrKyk7XG4gIH1cbiAgcGVlaygpIHtcbiAgICByZXR1cm4gdGhpcy5idWZmZXIuY2hhckNvZGVBdCh0aGlzLnBvcyk7XG4gIH1cbiAgaW5kZXhPZihjaGFyKSB7XG4gICAgY29uc3QgeyBidWZmZXIsIHBvcyB9ID0gdGhpcztcbiAgICBjb25zdCBpZHggPSBidWZmZXIuaW5kZXhPZihjaGFyLCBwb3MpO1xuICAgIHJldHVybiBpZHggPT09IC0xID8gYnVmZmVyLmxlbmd0aCA6IGlkeDtcbiAgfVxufTtcblxuLy8gc3JjL3Njb3Blcy50c1xudmFyIEVNUFRZID0gW107XG5mdW5jdGlvbiBkZWNvZGVPcmlnaW5hbFNjb3BlcyhpbnB1dCkge1xuICBjb25zdCB7IGxlbmd0aCB9ID0gaW5wdXQ7XG4gIGNvbnN0IHJlYWRlciA9IG5ldyBTdHJpbmdSZWFkZXIoaW5wdXQpO1xuICBjb25zdCBzY29wZXMgPSBbXTtcbiAgY29uc3Qgc3RhY2sgPSBbXTtcbiAgbGV0IGxpbmUgPSAwO1xuICBmb3IgKDsgcmVhZGVyLnBvcyA8IGxlbmd0aDsgcmVhZGVyLnBvcysrKSB7XG4gICAgbGluZSA9IGRlY29kZUludGVnZXIocmVhZGVyLCBsaW5lKTtcbiAgICBjb25zdCBjb2x1bW4gPSBkZWNvZGVJbnRlZ2VyKHJlYWRlciwgMCk7XG4gICAgaWYgKCFoYXNNb3JlVmxxKHJlYWRlciwgbGVuZ3RoKSkge1xuICAgICAgY29uc3QgbGFzdCA9IHN0YWNrLnBvcCgpO1xuICAgICAgbGFzdFsyXSA9IGxpbmU7XG4gICAgICBsYXN0WzNdID0gY29sdW1uO1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIGNvbnN0IGtpbmQgPSBkZWNvZGVJbnRlZ2VyKHJlYWRlciwgMCk7XG4gICAgY29uc3QgZmllbGRzID0gZGVjb2RlSW50ZWdlcihyZWFkZXIsIDApO1xuICAgIGNvbnN0IGhhc05hbWUgPSBmaWVsZHMgJiAxO1xuICAgIGNvbnN0IHNjb3BlID0gaGFzTmFtZSA/IFtsaW5lLCBjb2x1bW4sIDAsIDAsIGtpbmQsIGRlY29kZUludGVnZXIocmVhZGVyLCAwKV0gOiBbbGluZSwgY29sdW1uLCAwLCAwLCBraW5kXTtcbiAgICBsZXQgdmFycyA9IEVNUFRZO1xuICAgIGlmIChoYXNNb3JlVmxxKHJlYWRlciwgbGVuZ3RoKSkge1xuICAgICAgdmFycyA9IFtdO1xuICAgICAgZG8ge1xuICAgICAgICBjb25zdCB2YXJzSW5kZXggPSBkZWNvZGVJbnRlZ2VyKHJlYWRlciwgMCk7XG4gICAgICAgIHZhcnMucHVzaCh2YXJzSW5kZXgpO1xuICAgICAgfSB3aGlsZSAoaGFzTW9yZVZscShyZWFkZXIsIGxlbmd0aCkpO1xuICAgIH1cbiAgICBzY29wZS52YXJzID0gdmFycztcbiAgICBzY29wZXMucHVzaChzY29wZSk7XG4gICAgc3RhY2sucHVzaChzY29wZSk7XG4gIH1cbiAgcmV0dXJuIHNjb3Blcztcbn1cbmZ1bmN0aW9uIGVuY29kZU9yaWdpbmFsU2NvcGVzKHNjb3Blcykge1xuICBjb25zdCB3cml0ZXIgPSBuZXcgU3RyaW5nV3JpdGVyKCk7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgc2NvcGVzLmxlbmd0aDsgKSB7XG4gICAgaSA9IF9lbmNvZGVPcmlnaW5hbFNjb3BlcyhzY29wZXMsIGksIHdyaXRlciwgWzBdKTtcbiAgfVxuICByZXR1cm4gd3JpdGVyLmZsdXNoKCk7XG59XG5mdW5jdGlvbiBfZW5jb2RlT3JpZ2luYWxTY29wZXMoc2NvcGVzLCBpbmRleCwgd3JpdGVyLCBzdGF0ZSkge1xuICBjb25zdCBzY29wZSA9IHNjb3Blc1tpbmRleF07XG4gIGNvbnN0IHsgMDogc3RhcnRMaW5lLCAxOiBzdGFydENvbHVtbiwgMjogZW5kTGluZSwgMzogZW5kQ29sdW1uLCA0OiBraW5kLCB2YXJzIH0gPSBzY29wZTtcbiAgaWYgKGluZGV4ID4gMCkgd3JpdGVyLndyaXRlKGNvbW1hKTtcbiAgc3RhdGVbMF0gPSBlbmNvZGVJbnRlZ2VyKHdyaXRlciwgc3RhcnRMaW5lLCBzdGF0ZVswXSk7XG4gIGVuY29kZUludGVnZXIod3JpdGVyLCBzdGFydENvbHVtbiwgMCk7XG4gIGVuY29kZUludGVnZXIod3JpdGVyLCBraW5kLCAwKTtcbiAgY29uc3QgZmllbGRzID0gc2NvcGUubGVuZ3RoID09PSA2ID8gMSA6IDA7XG4gIGVuY29kZUludGVnZXIod3JpdGVyLCBmaWVsZHMsIDApO1xuICBpZiAoc2NvcGUubGVuZ3RoID09PSA2KSBlbmNvZGVJbnRlZ2VyKHdyaXRlciwgc2NvcGVbNV0sIDApO1xuICBmb3IgKGNvbnN0IHYgb2YgdmFycykge1xuICAgIGVuY29kZUludGVnZXIod3JpdGVyLCB2LCAwKTtcbiAgfVxuICBmb3IgKGluZGV4Kys7IGluZGV4IDwgc2NvcGVzLmxlbmd0aDsgKSB7XG4gICAgY29uc3QgbmV4dCA9IHNjb3Blc1tpbmRleF07XG4gICAgY29uc3QgeyAwOiBsLCAxOiBjIH0gPSBuZXh0O1xuICAgIGlmIChsID4gZW5kTGluZSB8fCBsID09PSBlbmRMaW5lICYmIGMgPj0gZW5kQ29sdW1uKSB7XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgaW5kZXggPSBfZW5jb2RlT3JpZ2luYWxTY29wZXMoc2NvcGVzLCBpbmRleCwgd3JpdGVyLCBzdGF0ZSk7XG4gIH1cbiAgd3JpdGVyLndyaXRlKGNvbW1hKTtcbiAgc3RhdGVbMF0gPSBlbmNvZGVJbnRlZ2VyKHdyaXRlciwgZW5kTGluZSwgc3RhdGVbMF0pO1xuICBlbmNvZGVJbnRlZ2VyKHdyaXRlciwgZW5kQ29sdW1uLCAwKTtcbiAgcmV0dXJuIGluZGV4O1xufVxuZnVuY3Rpb24gZGVjb2RlR2VuZXJhdGVkUmFuZ2VzKGlucHV0KSB7XG4gIGNvbnN0IHsgbGVuZ3RoIH0gPSBpbnB1dDtcbiAgY29uc3QgcmVhZGVyID0gbmV3IFN0cmluZ1JlYWRlcihpbnB1dCk7XG4gIGNvbnN0IHJhbmdlcyA9IFtdO1xuICBjb25zdCBzdGFjayA9IFtdO1xuICBsZXQgZ2VuTGluZSA9IDA7XG4gIGxldCBkZWZpbml0aW9uU291cmNlc0luZGV4ID0gMDtcbiAgbGV0IGRlZmluaXRpb25TY29wZUluZGV4ID0gMDtcbiAgbGV0IGNhbGxzaXRlU291cmNlc0luZGV4ID0gMDtcbiAgbGV0IGNhbGxzaXRlTGluZSA9IDA7XG4gIGxldCBjYWxsc2l0ZUNvbHVtbiA9IDA7XG4gIGxldCBiaW5kaW5nTGluZSA9IDA7XG4gIGxldCBiaW5kaW5nQ29sdW1uID0gMDtcbiAgZG8ge1xuICAgIGNvbnN0IHNlbWkgPSByZWFkZXIuaW5kZXhPZihcIjtcIik7XG4gICAgbGV0IGdlbkNvbHVtbiA9IDA7XG4gICAgZm9yICg7IHJlYWRlci5wb3MgPCBzZW1pOyByZWFkZXIucG9zKyspIHtcbiAgICAgIGdlbkNvbHVtbiA9IGRlY29kZUludGVnZXIocmVhZGVyLCBnZW5Db2x1bW4pO1xuICAgICAgaWYgKCFoYXNNb3JlVmxxKHJlYWRlciwgc2VtaSkpIHtcbiAgICAgICAgY29uc3QgbGFzdCA9IHN0YWNrLnBvcCgpO1xuICAgICAgICBsYXN0WzJdID0gZ2VuTGluZTtcbiAgICAgICAgbGFzdFszXSA9IGdlbkNvbHVtbjtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBjb25zdCBmaWVsZHMgPSBkZWNvZGVJbnRlZ2VyKHJlYWRlciwgMCk7XG4gICAgICBjb25zdCBoYXNEZWZpbml0aW9uID0gZmllbGRzICYgMTtcbiAgICAgIGNvbnN0IGhhc0NhbGxzaXRlID0gZmllbGRzICYgMjtcbiAgICAgIGNvbnN0IGhhc1Njb3BlID0gZmllbGRzICYgNDtcbiAgICAgIGxldCBjYWxsc2l0ZSA9IG51bGw7XG4gICAgICBsZXQgYmluZGluZ3MgPSBFTVBUWTtcbiAgICAgIGxldCByYW5nZTtcbiAgICAgIGlmIChoYXNEZWZpbml0aW9uKSB7XG4gICAgICAgIGNvbnN0IGRlZlNvdXJjZXNJbmRleCA9IGRlY29kZUludGVnZXIocmVhZGVyLCBkZWZpbml0aW9uU291cmNlc0luZGV4KTtcbiAgICAgICAgZGVmaW5pdGlvblNjb3BlSW5kZXggPSBkZWNvZGVJbnRlZ2VyKFxuICAgICAgICAgIHJlYWRlcixcbiAgICAgICAgICBkZWZpbml0aW9uU291cmNlc0luZGV4ID09PSBkZWZTb3VyY2VzSW5kZXggPyBkZWZpbml0aW9uU2NvcGVJbmRleCA6IDBcbiAgICAgICAgKTtcbiAgICAgICAgZGVmaW5pdGlvblNvdXJjZXNJbmRleCA9IGRlZlNvdXJjZXNJbmRleDtcbiAgICAgICAgcmFuZ2UgPSBbZ2VuTGluZSwgZ2VuQ29sdW1uLCAwLCAwLCBkZWZTb3VyY2VzSW5kZXgsIGRlZmluaXRpb25TY29wZUluZGV4XTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJhbmdlID0gW2dlbkxpbmUsIGdlbkNvbHVtbiwgMCwgMF07XG4gICAgICB9XG4gICAgICByYW5nZS5pc1Njb3BlID0gISFoYXNTY29wZTtcbiAgICAgIGlmIChoYXNDYWxsc2l0ZSkge1xuICAgICAgICBjb25zdCBwcmV2Q3NpID0gY2FsbHNpdGVTb3VyY2VzSW5kZXg7XG4gICAgICAgIGNvbnN0IHByZXZMaW5lID0gY2FsbHNpdGVMaW5lO1xuICAgICAgICBjYWxsc2l0ZVNvdXJjZXNJbmRleCA9IGRlY29kZUludGVnZXIocmVhZGVyLCBjYWxsc2l0ZVNvdXJjZXNJbmRleCk7XG4gICAgICAgIGNvbnN0IHNhbWVTb3VyY2UgPSBwcmV2Q3NpID09PSBjYWxsc2l0ZVNvdXJjZXNJbmRleDtcbiAgICAgICAgY2FsbHNpdGVMaW5lID0gZGVjb2RlSW50ZWdlcihyZWFkZXIsIHNhbWVTb3VyY2UgPyBjYWxsc2l0ZUxpbmUgOiAwKTtcbiAgICAgICAgY2FsbHNpdGVDb2x1bW4gPSBkZWNvZGVJbnRlZ2VyKFxuICAgICAgICAgIHJlYWRlcixcbiAgICAgICAgICBzYW1lU291cmNlICYmIHByZXZMaW5lID09PSBjYWxsc2l0ZUxpbmUgPyBjYWxsc2l0ZUNvbHVtbiA6IDBcbiAgICAgICAgKTtcbiAgICAgICAgY2FsbHNpdGUgPSBbY2FsbHNpdGVTb3VyY2VzSW5kZXgsIGNhbGxzaXRlTGluZSwgY2FsbHNpdGVDb2x1bW5dO1xuICAgICAgfVxuICAgICAgcmFuZ2UuY2FsbHNpdGUgPSBjYWxsc2l0ZTtcbiAgICAgIGlmIChoYXNNb3JlVmxxKHJlYWRlciwgc2VtaSkpIHtcbiAgICAgICAgYmluZGluZ3MgPSBbXTtcbiAgICAgICAgZG8ge1xuICAgICAgICAgIGJpbmRpbmdMaW5lID0gZ2VuTGluZTtcbiAgICAgICAgICBiaW5kaW5nQ29sdW1uID0gZ2VuQ29sdW1uO1xuICAgICAgICAgIGNvbnN0IGV4cHJlc3Npb25zQ291bnQgPSBkZWNvZGVJbnRlZ2VyKHJlYWRlciwgMCk7XG4gICAgICAgICAgbGV0IGV4cHJlc3Npb25SYW5nZXM7XG4gICAgICAgICAgaWYgKGV4cHJlc3Npb25zQ291bnQgPCAtMSkge1xuICAgICAgICAgICAgZXhwcmVzc2lvblJhbmdlcyA9IFtbZGVjb2RlSW50ZWdlcihyZWFkZXIsIDApXV07XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gLTE7IGkgPiBleHByZXNzaW9uc0NvdW50OyBpLS0pIHtcbiAgICAgICAgICAgICAgY29uc3QgcHJldkJsID0gYmluZGluZ0xpbmU7XG4gICAgICAgICAgICAgIGJpbmRpbmdMaW5lID0gZGVjb2RlSW50ZWdlcihyZWFkZXIsIGJpbmRpbmdMaW5lKTtcbiAgICAgICAgICAgICAgYmluZGluZ0NvbHVtbiA9IGRlY29kZUludGVnZXIocmVhZGVyLCBiaW5kaW5nTGluZSA9PT0gcHJldkJsID8gYmluZGluZ0NvbHVtbiA6IDApO1xuICAgICAgICAgICAgICBjb25zdCBleHByZXNzaW9uID0gZGVjb2RlSW50ZWdlcihyZWFkZXIsIDApO1xuICAgICAgICAgICAgICBleHByZXNzaW9uUmFuZ2VzLnB1c2goW2V4cHJlc3Npb24sIGJpbmRpbmdMaW5lLCBiaW5kaW5nQ29sdW1uXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGV4cHJlc3Npb25SYW5nZXMgPSBbW2V4cHJlc3Npb25zQ291bnRdXTtcbiAgICAgICAgICB9XG4gICAgICAgICAgYmluZGluZ3MucHVzaChleHByZXNzaW9uUmFuZ2VzKTtcbiAgICAgICAgfSB3aGlsZSAoaGFzTW9yZVZscShyZWFkZXIsIHNlbWkpKTtcbiAgICAgIH1cbiAgICAgIHJhbmdlLmJpbmRpbmdzID0gYmluZGluZ3M7XG4gICAgICByYW5nZXMucHVzaChyYW5nZSk7XG4gICAgICBzdGFjay5wdXNoKHJhbmdlKTtcbiAgICB9XG4gICAgZ2VuTGluZSsrO1xuICAgIHJlYWRlci5wb3MgPSBzZW1pICsgMTtcbiAgfSB3aGlsZSAocmVhZGVyLnBvcyA8IGxlbmd0aCk7XG4gIHJldHVybiByYW5nZXM7XG59XG5mdW5jdGlvbiBlbmNvZGVHZW5lcmF0ZWRSYW5nZXMocmFuZ2VzKSB7XG4gIGlmIChyYW5nZXMubGVuZ3RoID09PSAwKSByZXR1cm4gXCJcIjtcbiAgY29uc3Qgd3JpdGVyID0gbmV3IFN0cmluZ1dyaXRlcigpO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IHJhbmdlcy5sZW5ndGg7ICkge1xuICAgIGkgPSBfZW5jb2RlR2VuZXJhdGVkUmFuZ2VzKHJhbmdlcywgaSwgd3JpdGVyLCBbMCwgMCwgMCwgMCwgMCwgMCwgMF0pO1xuICB9XG4gIHJldHVybiB3cml0ZXIuZmx1c2goKTtcbn1cbmZ1bmN0aW9uIF9lbmNvZGVHZW5lcmF0ZWRSYW5nZXMocmFuZ2VzLCBpbmRleCwgd3JpdGVyLCBzdGF0ZSkge1xuICBjb25zdCByYW5nZSA9IHJhbmdlc1tpbmRleF07XG4gIGNvbnN0IHtcbiAgICAwOiBzdGFydExpbmUsXG4gICAgMTogc3RhcnRDb2x1bW4sXG4gICAgMjogZW5kTGluZSxcbiAgICAzOiBlbmRDb2x1bW4sXG4gICAgaXNTY29wZSxcbiAgICBjYWxsc2l0ZSxcbiAgICBiaW5kaW5nc1xuICB9ID0gcmFuZ2U7XG4gIGlmIChzdGF0ZVswXSA8IHN0YXJ0TGluZSkge1xuICAgIGNhdGNodXBMaW5lKHdyaXRlciwgc3RhdGVbMF0sIHN0YXJ0TGluZSk7XG4gICAgc3RhdGVbMF0gPSBzdGFydExpbmU7XG4gICAgc3RhdGVbMV0gPSAwO1xuICB9IGVsc2UgaWYgKGluZGV4ID4gMCkge1xuICAgIHdyaXRlci53cml0ZShjb21tYSk7XG4gIH1cbiAgc3RhdGVbMV0gPSBlbmNvZGVJbnRlZ2VyKHdyaXRlciwgcmFuZ2VbMV0sIHN0YXRlWzFdKTtcbiAgY29uc3QgZmllbGRzID0gKHJhbmdlLmxlbmd0aCA9PT0gNiA/IDEgOiAwKSB8IChjYWxsc2l0ZSA/IDIgOiAwKSB8IChpc1Njb3BlID8gNCA6IDApO1xuICBlbmNvZGVJbnRlZ2VyKHdyaXRlciwgZmllbGRzLCAwKTtcbiAgaWYgKHJhbmdlLmxlbmd0aCA9PT0gNikge1xuICAgIGNvbnN0IHsgNDogc291cmNlc0luZGV4LCA1OiBzY29wZXNJbmRleCB9ID0gcmFuZ2U7XG4gICAgaWYgKHNvdXJjZXNJbmRleCAhPT0gc3RhdGVbMl0pIHtcbiAgICAgIHN0YXRlWzNdID0gMDtcbiAgICB9XG4gICAgc3RhdGVbMl0gPSBlbmNvZGVJbnRlZ2VyKHdyaXRlciwgc291cmNlc0luZGV4LCBzdGF0ZVsyXSk7XG4gICAgc3RhdGVbM10gPSBlbmNvZGVJbnRlZ2VyKHdyaXRlciwgc2NvcGVzSW5kZXgsIHN0YXRlWzNdKTtcbiAgfVxuICBpZiAoY2FsbHNpdGUpIHtcbiAgICBjb25zdCB7IDA6IHNvdXJjZXNJbmRleCwgMTogY2FsbExpbmUsIDI6IGNhbGxDb2x1bW4gfSA9IHJhbmdlLmNhbGxzaXRlO1xuICAgIGlmIChzb3VyY2VzSW5kZXggIT09IHN0YXRlWzRdKSB7XG4gICAgICBzdGF0ZVs1XSA9IDA7XG4gICAgICBzdGF0ZVs2XSA9IDA7XG4gICAgfSBlbHNlIGlmIChjYWxsTGluZSAhPT0gc3RhdGVbNV0pIHtcbiAgICAgIHN0YXRlWzZdID0gMDtcbiAgICB9XG4gICAgc3RhdGVbNF0gPSBlbmNvZGVJbnRlZ2VyKHdyaXRlciwgc291cmNlc0luZGV4LCBzdGF0ZVs0XSk7XG4gICAgc3RhdGVbNV0gPSBlbmNvZGVJbnRlZ2VyKHdyaXRlciwgY2FsbExpbmUsIHN0YXRlWzVdKTtcbiAgICBzdGF0ZVs2XSA9IGVuY29kZUludGVnZXIod3JpdGVyLCBjYWxsQ29sdW1uLCBzdGF0ZVs2XSk7XG4gIH1cbiAgaWYgKGJpbmRpbmdzKSB7XG4gICAgZm9yIChjb25zdCBiaW5kaW5nIG9mIGJpbmRpbmdzKSB7XG4gICAgICBpZiAoYmluZGluZy5sZW5ndGggPiAxKSBlbmNvZGVJbnRlZ2VyKHdyaXRlciwgLWJpbmRpbmcubGVuZ3RoLCAwKTtcbiAgICAgIGNvbnN0IGV4cHJlc3Npb24gPSBiaW5kaW5nWzBdWzBdO1xuICAgICAgZW5jb2RlSW50ZWdlcih3cml0ZXIsIGV4cHJlc3Npb24sIDApO1xuICAgICAgbGV0IGJpbmRpbmdTdGFydExpbmUgPSBzdGFydExpbmU7XG4gICAgICBsZXQgYmluZGluZ1N0YXJ0Q29sdW1uID0gc3RhcnRDb2x1bW47XG4gICAgICBmb3IgKGxldCBpID0gMTsgaSA8IGJpbmRpbmcubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY29uc3QgZXhwUmFuZ2UgPSBiaW5kaW5nW2ldO1xuICAgICAgICBiaW5kaW5nU3RhcnRMaW5lID0gZW5jb2RlSW50ZWdlcih3cml0ZXIsIGV4cFJhbmdlWzFdLCBiaW5kaW5nU3RhcnRMaW5lKTtcbiAgICAgICAgYmluZGluZ1N0YXJ0Q29sdW1uID0gZW5jb2RlSW50ZWdlcih3cml0ZXIsIGV4cFJhbmdlWzJdLCBiaW5kaW5nU3RhcnRDb2x1bW4pO1xuICAgICAgICBlbmNvZGVJbnRlZ2VyKHdyaXRlciwgZXhwUmFuZ2VbMF0sIDApO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBmb3IgKGluZGV4Kys7IGluZGV4IDwgcmFuZ2VzLmxlbmd0aDsgKSB7XG4gICAgY29uc3QgbmV4dCA9IHJhbmdlc1tpbmRleF07XG4gICAgY29uc3QgeyAwOiBsLCAxOiBjIH0gPSBuZXh0O1xuICAgIGlmIChsID4gZW5kTGluZSB8fCBsID09PSBlbmRMaW5lICYmIGMgPj0gZW5kQ29sdW1uKSB7XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgaW5kZXggPSBfZW5jb2RlR2VuZXJhdGVkUmFuZ2VzKHJhbmdlcywgaW5kZXgsIHdyaXRlciwgc3RhdGUpO1xuICB9XG4gIGlmIChzdGF0ZVswXSA8IGVuZExpbmUpIHtcbiAgICBjYXRjaHVwTGluZSh3cml0ZXIsIHN0YXRlWzBdLCBlbmRMaW5lKTtcbiAgICBzdGF0ZVswXSA9IGVuZExpbmU7XG4gICAgc3RhdGVbMV0gPSAwO1xuICB9IGVsc2Uge1xuICAgIHdyaXRlci53cml0ZShjb21tYSk7XG4gIH1cbiAgc3RhdGVbMV0gPSBlbmNvZGVJbnRlZ2VyKHdyaXRlciwgZW5kQ29sdW1uLCBzdGF0ZVsxXSk7XG4gIHJldHVybiBpbmRleDtcbn1cbmZ1bmN0aW9uIGNhdGNodXBMaW5lKHdyaXRlciwgbGFzdExpbmUsIGxpbmUpIHtcbiAgZG8ge1xuICAgIHdyaXRlci53cml0ZShzZW1pY29sb24pO1xuICB9IHdoaWxlICgrK2xhc3RMaW5lIDwgbGluZSk7XG59XG5cbi8vIHNyYy9zb3VyY2VtYXAtY29kZWMudHNcbmZ1bmN0aW9uIGRlY29kZShtYXBwaW5ncykge1xuICBjb25zdCB7IGxlbmd0aCB9ID0gbWFwcGluZ3M7XG4gIGNvbnN0IHJlYWRlciA9IG5ldyBTdHJpbmdSZWFkZXIobWFwcGluZ3MpO1xuICBjb25zdCBkZWNvZGVkID0gW107XG4gIGxldCBnZW5Db2x1bW4gPSAwO1xuICBsZXQgc291cmNlc0luZGV4ID0gMDtcbiAgbGV0IHNvdXJjZUxpbmUgPSAwO1xuICBsZXQgc291cmNlQ29sdW1uID0gMDtcbiAgbGV0IG5hbWVzSW5kZXggPSAwO1xuICBkbyB7XG4gICAgY29uc3Qgc2VtaSA9IHJlYWRlci5pbmRleE9mKFwiO1wiKTtcbiAgICBjb25zdCBsaW5lID0gW107XG4gICAgbGV0IHNvcnRlZCA9IHRydWU7XG4gICAgbGV0IGxhc3RDb2wgPSAwO1xuICAgIGdlbkNvbHVtbiA9IDA7XG4gICAgd2hpbGUgKHJlYWRlci5wb3MgPCBzZW1pKSB7XG4gICAgICBsZXQgc2VnO1xuICAgICAgZ2VuQ29sdW1uID0gZGVjb2RlSW50ZWdlcihyZWFkZXIsIGdlbkNvbHVtbik7XG4gICAgICBpZiAoZ2VuQ29sdW1uIDwgbGFzdENvbCkgc29ydGVkID0gZmFsc2U7XG4gICAgICBsYXN0Q29sID0gZ2VuQ29sdW1uO1xuICAgICAgaWYgKGhhc01vcmVWbHEocmVhZGVyLCBzZW1pKSkge1xuICAgICAgICBzb3VyY2VzSW5kZXggPSBkZWNvZGVJbnRlZ2VyKHJlYWRlciwgc291cmNlc0luZGV4KTtcbiAgICAgICAgc291cmNlTGluZSA9IGRlY29kZUludGVnZXIocmVhZGVyLCBzb3VyY2VMaW5lKTtcbiAgICAgICAgc291cmNlQ29sdW1uID0gZGVjb2RlSW50ZWdlcihyZWFkZXIsIHNvdXJjZUNvbHVtbik7XG4gICAgICAgIGlmIChoYXNNb3JlVmxxKHJlYWRlciwgc2VtaSkpIHtcbiAgICAgICAgICBuYW1lc0luZGV4ID0gZGVjb2RlSW50ZWdlcihyZWFkZXIsIG5hbWVzSW5kZXgpO1xuICAgICAgICAgIHNlZyA9IFtnZW5Db2x1bW4sIHNvdXJjZXNJbmRleCwgc291cmNlTGluZSwgc291cmNlQ29sdW1uLCBuYW1lc0luZGV4XTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBzZWcgPSBbZ2VuQ29sdW1uLCBzb3VyY2VzSW5kZXgsIHNvdXJjZUxpbmUsIHNvdXJjZUNvbHVtbl07XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHNlZyA9IFtnZW5Db2x1bW5dO1xuICAgICAgfVxuICAgICAgbGluZS5wdXNoKHNlZyk7XG4gICAgICByZWFkZXIucG9zKys7XG4gICAgfVxuICAgIGlmICghc29ydGVkKSBzb3J0KGxpbmUpO1xuICAgIGRlY29kZWQucHVzaChsaW5lKTtcbiAgICByZWFkZXIucG9zID0gc2VtaSArIDE7XG4gIH0gd2hpbGUgKHJlYWRlci5wb3MgPD0gbGVuZ3RoKTtcbiAgcmV0dXJuIGRlY29kZWQ7XG59XG5mdW5jdGlvbiBzb3J0KGxpbmUpIHtcbiAgbGluZS5zb3J0KHNvcnRDb21wYXJhdG9yKTtcbn1cbmZ1bmN0aW9uIHNvcnRDb21wYXJhdG9yKGEsIGIpIHtcbiAgcmV0dXJuIGFbMF0gLSBiWzBdO1xufVxuZnVuY3Rpb24gZW5jb2RlKGRlY29kZWQpIHtcbiAgY29uc3Qgd3JpdGVyID0gbmV3IFN0cmluZ1dyaXRlcigpO1xuICBsZXQgc291cmNlc0luZGV4ID0gMDtcbiAgbGV0IHNvdXJjZUxpbmUgPSAwO1xuICBsZXQgc291cmNlQ29sdW1uID0gMDtcbiAgbGV0IG5hbWVzSW5kZXggPSAwO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IGRlY29kZWQubGVuZ3RoOyBpKyspIHtcbiAgICBjb25zdCBsaW5lID0gZGVjb2RlZFtpXTtcbiAgICBpZiAoaSA+IDApIHdyaXRlci53cml0ZShzZW1pY29sb24pO1xuICAgIGlmIChsaW5lLmxlbmd0aCA9PT0gMCkgY29udGludWU7XG4gICAgbGV0IGdlbkNvbHVtbiA9IDA7XG4gICAgZm9yIChsZXQgaiA9IDA7IGogPCBsaW5lLmxlbmd0aDsgaisrKSB7XG4gICAgICBjb25zdCBzZWdtZW50ID0gbGluZVtqXTtcbiAgICAgIGlmIChqID4gMCkgd3JpdGVyLndyaXRlKGNvbW1hKTtcbiAgICAgIGdlbkNvbHVtbiA9IGVuY29kZUludGVnZXIod3JpdGVyLCBzZWdtZW50WzBdLCBnZW5Db2x1bW4pO1xuICAgICAgaWYgKHNlZ21lbnQubGVuZ3RoID09PSAxKSBjb250aW51ZTtcbiAgICAgIHNvdXJjZXNJbmRleCA9IGVuY29kZUludGVnZXIod3JpdGVyLCBzZWdtZW50WzFdLCBzb3VyY2VzSW5kZXgpO1xuICAgICAgc291cmNlTGluZSA9IGVuY29kZUludGVnZXIod3JpdGVyLCBzZWdtZW50WzJdLCBzb3VyY2VMaW5lKTtcbiAgICAgIHNvdXJjZUNvbHVtbiA9IGVuY29kZUludGVnZXIod3JpdGVyLCBzZWdtZW50WzNdLCBzb3VyY2VDb2x1bW4pO1xuICAgICAgaWYgKHNlZ21lbnQubGVuZ3RoID09PSA0KSBjb250aW51ZTtcbiAgICAgIG5hbWVzSW5kZXggPSBlbmNvZGVJbnRlZ2VyKHdyaXRlciwgc2VnbWVudFs0XSwgbmFtZXNJbmRleCk7XG4gICAgfVxuICB9XG4gIHJldHVybiB3cml0ZXIuZmx1c2goKTtcbn1cbn0pKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXNvdXJjZW1hcC1jb2RlYy51bWQuanMubWFwXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@jridgewell/sourcemap-codec/dist/sourcemap-codec.umd.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@jridgewell/trace-mapping/dist/trace-mapping.umd.js":
/*!**************************************************************************!*\
  !*** ./node_modules/@jridgewell/trace-mapping/dist/trace-mapping.umd.js ***!
  \**************************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval("/* module decorator */ module = __webpack_require__.nmd(module);\n(function (global, factory) {\n  if (true) {\n    factory(module, __webpack_require__(/*! @jridgewell/resolve-uri */ \"(ssr)/./node_modules/@jridgewell/resolve-uri/dist/resolve-uri.umd.js\"), __webpack_require__(/*! @jridgewell/sourcemap-codec */ \"(ssr)/./node_modules/@jridgewell/sourcemap-codec/dist/sourcemap-codec.umd.js\"));\n    module.exports = def(module);\n  } else {}\n  function def(m) { return 'default' in m.exports ? m.exports.default : m.exports; }\n})(this, (function (module, require_resolveURI, require_sourcemapCodec) {\n\"use strict\";\nvar __create = Object.create;\nvar __defProp = Object.defineProperty;\nvar __getOwnPropDesc = Object.getOwnPropertyDescriptor;\nvar __getOwnPropNames = Object.getOwnPropertyNames;\nvar __getProtoOf = Object.getPrototypeOf;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __commonJS = (cb, mod) => function __require() {\n  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;\n};\nvar __export = (target, all) => {\n  for (var name in all)\n    __defProp(target, name, { get: all[name], enumerable: true });\n};\nvar __copyProps = (to, from, except, desc) => {\n  if (from && typeof from === \"object\" || typeof from === \"function\") {\n    for (let key of __getOwnPropNames(from))\n      if (!__hasOwnProp.call(to, key) && key !== except)\n        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });\n  }\n  return to;\n};\nvar __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(\n  // If the importer is in node compatibility mode or this is not an ESM\n  // file that has been converted to a CommonJS file using a Babel-\n  // compatible transform (i.e. \"__esModule\" has not been set), then set\n  // \"default\" to the CommonJS \"module.exports\" for node compatibility.\n  isNodeMode || !mod || !mod.__esModule ? __defProp(target, \"default\", { value: mod, enumerable: true }) : target,\n  mod\n));\nvar __toCommonJS = (mod) => __copyProps(__defProp({}, \"__esModule\", { value: true }), mod);\n\n// umd:@jridgewell/sourcemap-codec\nvar require_sourcemap_codec = __commonJS({\n  \"umd:@jridgewell/sourcemap-codec\"(exports, module2) {\n    module2.exports = require_sourcemapCodec;\n  }\n});\n\n// umd:@jridgewell/resolve-uri\nvar require_resolve_uri = __commonJS({\n  \"umd:@jridgewell/resolve-uri\"(exports, module2) {\n    module2.exports = require_resolveURI;\n  }\n});\n\n// src/trace-mapping.ts\nvar trace_mapping_exports = {};\n__export(trace_mapping_exports, {\n  AnyMap: () => FlattenMap,\n  FlattenMap: () => FlattenMap,\n  GREATEST_LOWER_BOUND: () => GREATEST_LOWER_BOUND,\n  LEAST_UPPER_BOUND: () => LEAST_UPPER_BOUND,\n  TraceMap: () => TraceMap,\n  allGeneratedPositionsFor: () => allGeneratedPositionsFor,\n  decodedMap: () => decodedMap,\n  decodedMappings: () => decodedMappings,\n  eachMapping: () => eachMapping,\n  encodedMap: () => encodedMap,\n  encodedMappings: () => encodedMappings,\n  generatedPositionFor: () => generatedPositionFor,\n  isIgnored: () => isIgnored,\n  originalPositionFor: () => originalPositionFor,\n  presortedDecodedMap: () => presortedDecodedMap,\n  sourceContentFor: () => sourceContentFor,\n  traceSegment: () => traceSegment\n});\nmodule.exports = __toCommonJS(trace_mapping_exports);\nvar import_sourcemap_codec = __toESM(require_sourcemap_codec());\n\n// src/resolve.ts\nvar import_resolve_uri = __toESM(require_resolve_uri());\n\n// src/strip-filename.ts\nfunction stripFilename(path) {\n  if (!path) return \"\";\n  const index = path.lastIndexOf(\"/\");\n  return path.slice(0, index + 1);\n}\n\n// src/resolve.ts\nfunction resolver(mapUrl, sourceRoot) {\n  const from = stripFilename(mapUrl);\n  const prefix = sourceRoot ? sourceRoot + \"/\" : \"\";\n  return (source) => (0, import_resolve_uri.default)(prefix + (source || \"\"), from);\n}\n\n// src/sourcemap-segment.ts\nvar COLUMN = 0;\nvar SOURCES_INDEX = 1;\nvar SOURCE_LINE = 2;\nvar SOURCE_COLUMN = 3;\nvar NAMES_INDEX = 4;\nvar REV_GENERATED_LINE = 1;\nvar REV_GENERATED_COLUMN = 2;\n\n// src/sort.ts\nfunction maybeSort(mappings, owned) {\n  const unsortedIndex = nextUnsortedSegmentLine(mappings, 0);\n  if (unsortedIndex === mappings.length) return mappings;\n  if (!owned) mappings = mappings.slice();\n  for (let i = unsortedIndex; i < mappings.length; i = nextUnsortedSegmentLine(mappings, i + 1)) {\n    mappings[i] = sortSegments(mappings[i], owned);\n  }\n  return mappings;\n}\nfunction nextUnsortedSegmentLine(mappings, start) {\n  for (let i = start; i < mappings.length; i++) {\n    if (!isSorted(mappings[i])) return i;\n  }\n  return mappings.length;\n}\nfunction isSorted(line) {\n  for (let j = 1; j < line.length; j++) {\n    if (line[j][COLUMN] < line[j - 1][COLUMN]) {\n      return false;\n    }\n  }\n  return true;\n}\nfunction sortSegments(line, owned) {\n  if (!owned) line = line.slice();\n  return line.sort(sortComparator);\n}\nfunction sortComparator(a, b) {\n  return a[COLUMN] - b[COLUMN];\n}\n\n// src/by-source.ts\nfunction buildBySources(decoded, memos) {\n  const sources = memos.map(() => []);\n  for (let i = 0; i < decoded.length; i++) {\n    const line = decoded[i];\n    for (let j = 0; j < line.length; j++) {\n      const seg = line[j];\n      if (seg.length === 1) continue;\n      const sourceIndex2 = seg[SOURCES_INDEX];\n      const sourceLine = seg[SOURCE_LINE];\n      const sourceColumn = seg[SOURCE_COLUMN];\n      const source = sources[sourceIndex2];\n      const segs = source[sourceLine] || (source[sourceLine] = []);\n      segs.push([sourceColumn, i, seg[COLUMN]]);\n    }\n  }\n  for (let i = 0; i < sources.length; i++) {\n    const source = sources[i];\n    for (let j = 0; j < source.length; j++) {\n      const line = source[j];\n      if (line) line.sort(sortComparator);\n    }\n  }\n  return sources;\n}\n\n// src/binary-search.ts\nvar found = false;\nfunction binarySearch(haystack, needle, low, high) {\n  while (low <= high) {\n    const mid = low + (high - low >> 1);\n    const cmp = haystack[mid][COLUMN] - needle;\n    if (cmp === 0) {\n      found = true;\n      return mid;\n    }\n    if (cmp < 0) {\n      low = mid + 1;\n    } else {\n      high = mid - 1;\n    }\n  }\n  found = false;\n  return low - 1;\n}\nfunction upperBound(haystack, needle, index) {\n  for (let i = index + 1; i < haystack.length; index = i++) {\n    if (haystack[i][COLUMN] !== needle) break;\n  }\n  return index;\n}\nfunction lowerBound(haystack, needle, index) {\n  for (let i = index - 1; i >= 0; index = i--) {\n    if (haystack[i][COLUMN] !== needle) break;\n  }\n  return index;\n}\nfunction memoizedState() {\n  return {\n    lastKey: -1,\n    lastNeedle: -1,\n    lastIndex: -1\n  };\n}\nfunction memoizedBinarySearch(haystack, needle, state, key) {\n  const { lastKey, lastNeedle, lastIndex } = state;\n  let low = 0;\n  let high = haystack.length - 1;\n  if (key === lastKey) {\n    if (needle === lastNeedle) {\n      found = lastIndex !== -1 && haystack[lastIndex][COLUMN] === needle;\n      return lastIndex;\n    }\n    if (needle >= lastNeedle) {\n      low = lastIndex === -1 ? 0 : lastIndex;\n    } else {\n      high = lastIndex;\n    }\n  }\n  state.lastKey = key;\n  state.lastNeedle = needle;\n  return state.lastIndex = binarySearch(haystack, needle, low, high);\n}\n\n// src/types.ts\nfunction parse(map) {\n  return typeof map === \"string\" ? JSON.parse(map) : map;\n}\n\n// src/flatten-map.ts\nvar FlattenMap = function(map, mapUrl) {\n  const parsed = parse(map);\n  if (!(\"sections\" in parsed)) {\n    return new TraceMap(parsed, mapUrl);\n  }\n  const mappings = [];\n  const sources = [];\n  const sourcesContent = [];\n  const names = [];\n  const ignoreList = [];\n  recurse(\n    parsed,\n    mapUrl,\n    mappings,\n    sources,\n    sourcesContent,\n    names,\n    ignoreList,\n    0,\n    0,\n    Infinity,\n    Infinity\n  );\n  const joined = {\n    version: 3,\n    file: parsed.file,\n    names,\n    sources,\n    sourcesContent,\n    mappings,\n    ignoreList\n  };\n  return presortedDecodedMap(joined);\n};\nfunction recurse(input, mapUrl, mappings, sources, sourcesContent, names, ignoreList, lineOffset, columnOffset, stopLine, stopColumn) {\n  const { sections } = input;\n  for (let i = 0; i < sections.length; i++) {\n    const { map, offset } = sections[i];\n    let sl = stopLine;\n    let sc = stopColumn;\n    if (i + 1 < sections.length) {\n      const nextOffset = sections[i + 1].offset;\n      sl = Math.min(stopLine, lineOffset + nextOffset.line);\n      if (sl === stopLine) {\n        sc = Math.min(stopColumn, columnOffset + nextOffset.column);\n      } else if (sl < stopLine) {\n        sc = columnOffset + nextOffset.column;\n      }\n    }\n    addSection(\n      map,\n      mapUrl,\n      mappings,\n      sources,\n      sourcesContent,\n      names,\n      ignoreList,\n      lineOffset + offset.line,\n      columnOffset + offset.column,\n      sl,\n      sc\n    );\n  }\n}\nfunction addSection(input, mapUrl, mappings, sources, sourcesContent, names, ignoreList, lineOffset, columnOffset, stopLine, stopColumn) {\n  const parsed = parse(input);\n  if (\"sections\" in parsed) return recurse(...arguments);\n  const map = new TraceMap(parsed, mapUrl);\n  const sourcesOffset = sources.length;\n  const namesOffset = names.length;\n  const decoded = decodedMappings(map);\n  const { resolvedSources, sourcesContent: contents, ignoreList: ignores } = map;\n  append(sources, resolvedSources);\n  append(names, map.names);\n  if (contents) append(sourcesContent, contents);\n  else for (let i = 0; i < resolvedSources.length; i++) sourcesContent.push(null);\n  if (ignores) for (let i = 0; i < ignores.length; i++) ignoreList.push(ignores[i] + sourcesOffset);\n  for (let i = 0; i < decoded.length; i++) {\n    const lineI = lineOffset + i;\n    if (lineI > stopLine) return;\n    const out = getLine(mappings, lineI);\n    const cOffset = i === 0 ? columnOffset : 0;\n    const line = decoded[i];\n    for (let j = 0; j < line.length; j++) {\n      const seg = line[j];\n      const column = cOffset + seg[COLUMN];\n      if (lineI === stopLine && column >= stopColumn) return;\n      if (seg.length === 1) {\n        out.push([column]);\n        continue;\n      }\n      const sourcesIndex = sourcesOffset + seg[SOURCES_INDEX];\n      const sourceLine = seg[SOURCE_LINE];\n      const sourceColumn = seg[SOURCE_COLUMN];\n      out.push(\n        seg.length === 4 ? [column, sourcesIndex, sourceLine, sourceColumn] : [column, sourcesIndex, sourceLine, sourceColumn, namesOffset + seg[NAMES_INDEX]]\n      );\n    }\n  }\n}\nfunction append(arr, other) {\n  for (let i = 0; i < other.length; i++) arr.push(other[i]);\n}\nfunction getLine(arr, index) {\n  for (let i = arr.length; i <= index; i++) arr[i] = [];\n  return arr[index];\n}\n\n// src/trace-mapping.ts\nvar LINE_GTR_ZERO = \"`line` must be greater than 0 (lines start at line 1)\";\nvar COL_GTR_EQ_ZERO = \"`column` must be greater than or equal to 0 (columns start at column 0)\";\nvar LEAST_UPPER_BOUND = -1;\nvar GREATEST_LOWER_BOUND = 1;\nvar TraceMap = class {\n  constructor(map, mapUrl) {\n    const isString = typeof map === \"string\";\n    if (!isString && map._decodedMemo) return map;\n    const parsed = parse(map);\n    const { version, file, names, sourceRoot, sources, sourcesContent } = parsed;\n    this.version = version;\n    this.file = file;\n    this.names = names || [];\n    this.sourceRoot = sourceRoot;\n    this.sources = sources;\n    this.sourcesContent = sourcesContent;\n    this.ignoreList = parsed.ignoreList || parsed.x_google_ignoreList || void 0;\n    const resolve = resolver(mapUrl, sourceRoot);\n    this.resolvedSources = sources.map(resolve);\n    const { mappings } = parsed;\n    if (typeof mappings === \"string\") {\n      this._encoded = mappings;\n      this._decoded = void 0;\n    } else if (Array.isArray(mappings)) {\n      this._encoded = void 0;\n      this._decoded = maybeSort(mappings, isString);\n    } else if (parsed.sections) {\n      throw new Error(`TraceMap passed sectioned source map, please use FlattenMap export instead`);\n    } else {\n      throw new Error(`invalid source map: ${JSON.stringify(parsed)}`);\n    }\n    this._decodedMemo = memoizedState();\n    this._bySources = void 0;\n    this._bySourceMemos = void 0;\n  }\n};\nfunction cast(map) {\n  return map;\n}\nfunction encodedMappings(map) {\n  var _a, _b;\n  return (_b = (_a = cast(map))._encoded) != null ? _b : _a._encoded = (0, import_sourcemap_codec.encode)(cast(map)._decoded);\n}\nfunction decodedMappings(map) {\n  var _a;\n  return (_a = cast(map))._decoded || (_a._decoded = (0, import_sourcemap_codec.decode)(cast(map)._encoded));\n}\nfunction traceSegment(map, line, column) {\n  const decoded = decodedMappings(map);\n  if (line >= decoded.length) return null;\n  const segments = decoded[line];\n  const index = traceSegmentInternal(\n    segments,\n    cast(map)._decodedMemo,\n    line,\n    column,\n    GREATEST_LOWER_BOUND\n  );\n  return index === -1 ? null : segments[index];\n}\nfunction originalPositionFor(map, needle) {\n  let { line, column, bias } = needle;\n  line--;\n  if (line < 0) throw new Error(LINE_GTR_ZERO);\n  if (column < 0) throw new Error(COL_GTR_EQ_ZERO);\n  const decoded = decodedMappings(map);\n  if (line >= decoded.length) return OMapping(null, null, null, null);\n  const segments = decoded[line];\n  const index = traceSegmentInternal(\n    segments,\n    cast(map)._decodedMemo,\n    line,\n    column,\n    bias || GREATEST_LOWER_BOUND\n  );\n  if (index === -1) return OMapping(null, null, null, null);\n  const segment = segments[index];\n  if (segment.length === 1) return OMapping(null, null, null, null);\n  const { names, resolvedSources } = map;\n  return OMapping(\n    resolvedSources[segment[SOURCES_INDEX]],\n    segment[SOURCE_LINE] + 1,\n    segment[SOURCE_COLUMN],\n    segment.length === 5 ? names[segment[NAMES_INDEX]] : null\n  );\n}\nfunction generatedPositionFor(map, needle) {\n  const { source, line, column, bias } = needle;\n  return generatedPosition(map, source, line, column, bias || GREATEST_LOWER_BOUND, false);\n}\nfunction allGeneratedPositionsFor(map, needle) {\n  const { source, line, column, bias } = needle;\n  return generatedPosition(map, source, line, column, bias || LEAST_UPPER_BOUND, true);\n}\nfunction eachMapping(map, cb) {\n  const decoded = decodedMappings(map);\n  const { names, resolvedSources } = map;\n  for (let i = 0; i < decoded.length; i++) {\n    const line = decoded[i];\n    for (let j = 0; j < line.length; j++) {\n      const seg = line[j];\n      const generatedLine = i + 1;\n      const generatedColumn = seg[0];\n      let source = null;\n      let originalLine = null;\n      let originalColumn = null;\n      let name = null;\n      if (seg.length !== 1) {\n        source = resolvedSources[seg[1]];\n        originalLine = seg[2] + 1;\n        originalColumn = seg[3];\n      }\n      if (seg.length === 5) name = names[seg[4]];\n      cb({\n        generatedLine,\n        generatedColumn,\n        source,\n        originalLine,\n        originalColumn,\n        name\n      });\n    }\n  }\n}\nfunction sourceIndex(map, source) {\n  const { sources, resolvedSources } = map;\n  let index = sources.indexOf(source);\n  if (index === -1) index = resolvedSources.indexOf(source);\n  return index;\n}\nfunction sourceContentFor(map, source) {\n  const { sourcesContent } = map;\n  if (sourcesContent == null) return null;\n  const index = sourceIndex(map, source);\n  return index === -1 ? null : sourcesContent[index];\n}\nfunction isIgnored(map, source) {\n  const { ignoreList } = map;\n  if (ignoreList == null) return false;\n  const index = sourceIndex(map, source);\n  return index === -1 ? false : ignoreList.includes(index);\n}\nfunction presortedDecodedMap(map, mapUrl) {\n  const tracer = new TraceMap(clone(map, []), mapUrl);\n  cast(tracer)._decoded = map.mappings;\n  return tracer;\n}\nfunction decodedMap(map) {\n  return clone(map, decodedMappings(map));\n}\nfunction encodedMap(map) {\n  return clone(map, encodedMappings(map));\n}\nfunction clone(map, mappings) {\n  return {\n    version: map.version,\n    file: map.file,\n    names: map.names,\n    sourceRoot: map.sourceRoot,\n    sources: map.sources,\n    sourcesContent: map.sourcesContent,\n    mappings,\n    ignoreList: map.ignoreList || map.x_google_ignoreList\n  };\n}\nfunction OMapping(source, line, column, name) {\n  return { source, line, column, name };\n}\nfunction GMapping(line, column) {\n  return { line, column };\n}\nfunction traceSegmentInternal(segments, memo, line, column, bias) {\n  let index = memoizedBinarySearch(segments, column, memo, line);\n  if (found) {\n    index = (bias === LEAST_UPPER_BOUND ? upperBound : lowerBound)(segments, column, index);\n  } else if (bias === LEAST_UPPER_BOUND) index++;\n  if (index === -1 || index === segments.length) return -1;\n  return index;\n}\nfunction sliceGeneratedPositions(segments, memo, line, column, bias) {\n  let min = traceSegmentInternal(segments, memo, line, column, GREATEST_LOWER_BOUND);\n  if (!found && bias === LEAST_UPPER_BOUND) min++;\n  if (min === -1 || min === segments.length) return [];\n  const matchedColumn = found ? column : segments[min][COLUMN];\n  if (!found) min = lowerBound(segments, matchedColumn, min);\n  const max = upperBound(segments, matchedColumn, min);\n  const result = [];\n  for (; min <= max; min++) {\n    const segment = segments[min];\n    result.push(GMapping(segment[REV_GENERATED_LINE] + 1, segment[REV_GENERATED_COLUMN]));\n  }\n  return result;\n}\nfunction generatedPosition(map, source, line, column, bias, all) {\n  var _a, _b;\n  line--;\n  if (line < 0) throw new Error(LINE_GTR_ZERO);\n  if (column < 0) throw new Error(COL_GTR_EQ_ZERO);\n  const { sources, resolvedSources } = map;\n  let sourceIndex2 = sources.indexOf(source);\n  if (sourceIndex2 === -1) sourceIndex2 = resolvedSources.indexOf(source);\n  if (sourceIndex2 === -1) return all ? [] : GMapping(null, null);\n  const bySourceMemos = (_a = cast(map))._bySourceMemos || (_a._bySourceMemos = sources.map(memoizedState));\n  const generated = (_b = cast(map))._bySources || (_b._bySources = buildBySources(decodedMappings(map), bySourceMemos));\n  const segments = generated[sourceIndex2][line];\n  if (segments == null) return all ? [] : GMapping(null, null);\n  const memo = bySourceMemos[sourceIndex2];\n  if (all) return sliceGeneratedPositions(segments, memo, line, column, bias);\n  const index = traceSegmentInternal(segments, memo, line, column, bias);\n  if (index === -1) return GMapping(null, null);\n  const segment = segments[index];\n  return GMapping(segment[REV_GENERATED_LINE] + 1, segment[REV_GENERATED_COLUMN]);\n}\n}));\n//# sourceMappingURL=trace-mapping.umd.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGpyaWRnZXdlbGwvdHJhY2UtbWFwcGluZy9kaXN0L3RyYWNlLW1hcHBpbmcudW1kLmpzIiwibWFwcGluZ3MiOiI7QUFBQTtBQUNBLE1BQU0sSUFBNEQ7QUFDbEUsb0JBQW9CLG1CQUFPLENBQUMscUdBQXlCLEdBQUcsbUJBQU8sQ0FBQyxpSEFBNkI7QUFDN0Y7QUFDQSxJQUFJLEtBQUssRUFVTjtBQUNILG9CQUFvQjtBQUNwQixDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJEQUEyRCxhQUFhO0FBQ3hFO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QixrQ0FBa0M7QUFDaEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2Qiw0RkFBNEY7QUFDekg7QUFDQTtBQUNBO0FBQ0EsbUdBQW1HO0FBQ25HO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUVBQXlFLDhCQUE4QjtBQUN2RztBQUNBO0FBQ0Esb0RBQW9ELGtCQUFrQixhQUFhOztBQUVuRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QixxQkFBcUI7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixxQkFBcUI7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixpQkFBaUI7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLG9CQUFvQjtBQUN0QztBQUNBLG9CQUFvQixpQkFBaUI7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0Isb0JBQW9CO0FBQ3RDO0FBQ0Esb0JBQW9CLG1CQUFtQjtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLHFCQUFxQjtBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLFFBQVE7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVSxpQ0FBaUM7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsV0FBVztBQUNyQixrQkFBa0IscUJBQXFCO0FBQ3ZDLFlBQVksY0FBYztBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsaUVBQWlFO0FBQzNFO0FBQ0E7QUFDQTtBQUNBLHVCQUF1Qiw0QkFBNEI7QUFDbkQsK0JBQStCLG9CQUFvQjtBQUNuRCxrQkFBa0Isb0JBQW9CO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsaUJBQWlCO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0Isa0JBQWtCO0FBQ3BDO0FBQ0E7QUFDQSwyQkFBMkIsWUFBWTtBQUN2QztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSw0REFBNEQ7QUFDeEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxXQUFXO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOLDZDQUE2Qyx1QkFBdUI7QUFDcEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLHFCQUFxQjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUseUJBQXlCO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLDZCQUE2QjtBQUN2QztBQUNBO0FBQ0E7QUFDQSxVQUFVLDZCQUE2QjtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUseUJBQXlCO0FBQ25DLGtCQUFrQixvQkFBb0I7QUFDdEM7QUFDQSxvQkFBb0IsaUJBQWlCO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLDJCQUEyQjtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVSxpQkFBaUI7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsYUFBYTtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVMsWUFBWTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsMkJBQTJCO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0QiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9yZXBvLXZpc3VhbGl6ZXIvLi9ub2RlX21vZHVsZXMvQGpyaWRnZXdlbGwvdHJhY2UtbWFwcGluZy9kaXN0L3RyYWNlLW1hcHBpbmcudW1kLmpzPzMwZTYiXSwic291cmNlc0NvbnRlbnQiOlsiKGZ1bmN0aW9uIChnbG9iYWwsIGZhY3RvcnkpIHtcbiAgaWYgKHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJykge1xuICAgIGZhY3RvcnkobW9kdWxlLCByZXF1aXJlKCdAanJpZGdld2VsbC9yZXNvbHZlLXVyaScpLCByZXF1aXJlKCdAanJpZGdld2VsbC9zb3VyY2VtYXAtY29kZWMnKSk7XG4gICAgbW9kdWxlLmV4cG9ydHMgPSBkZWYobW9kdWxlKTtcbiAgfSBlbHNlIGlmICh0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQpIHtcbiAgICBkZWZpbmUoWydtb2R1bGUnLCAnQGpyaWRnZXdlbGwvcmVzb2x2ZS11cmknLCAnQGpyaWRnZXdlbGwvc291cmNlbWFwLWNvZGVjJ10sIGZ1bmN0aW9uKG1vZCkge1xuICAgICAgZmFjdG9yeS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgbW9kLmV4cG9ydHMgPSBkZWYobW9kKTtcbiAgICB9KTtcbiAgfSBlbHNlIHtcbiAgICBjb25zdCBtb2QgPSB7IGV4cG9ydHM6IHt9IH07XG4gICAgZmFjdG9yeShtb2QsIGdsb2JhbC5yZXNvbHZlVVJJLCBnbG9iYWwuc291cmNlbWFwQ29kZWMpO1xuICAgIGdsb2JhbCA9IHR5cGVvZiBnbG9iYWxUaGlzICE9PSAndW5kZWZpbmVkJyA/IGdsb2JhbFRoaXMgOiBnbG9iYWwgfHwgc2VsZjtcbiAgICBnbG9iYWwudHJhY2VNYXBwaW5nID0gZGVmKG1vZCk7XG4gIH1cbiAgZnVuY3Rpb24gZGVmKG0pIHsgcmV0dXJuICdkZWZhdWx0JyBpbiBtLmV4cG9ydHMgPyBtLmV4cG9ydHMuZGVmYXVsdCA6IG0uZXhwb3J0czsgfVxufSkodGhpcywgKGZ1bmN0aW9uIChtb2R1bGUsIHJlcXVpcmVfcmVzb2x2ZVVSSSwgcmVxdWlyZV9zb3VyY2VtYXBDb2RlYykge1xuXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19jcmVhdGUgPSBPYmplY3QuY3JlYXRlO1xudmFyIF9fZGVmUHJvcCA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eTtcbnZhciBfX2dldE93blByb3BEZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcjtcbnZhciBfX2dldE93blByb3BOYW1lcyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzO1xudmFyIF9fZ2V0UHJvdG9PZiA9IE9iamVjdC5nZXRQcm90b3R5cGVPZjtcbnZhciBfX2hhc093blByb3AgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xudmFyIF9fY29tbW9uSlMgPSAoY2IsIG1vZCkgPT4gZnVuY3Rpb24gX19yZXF1aXJlKCkge1xuICByZXR1cm4gbW9kIHx8ICgwLCBjYltfX2dldE93blByb3BOYW1lcyhjYilbMF1dKSgobW9kID0geyBleHBvcnRzOiB7fSB9KS5leHBvcnRzLCBtb2QpLCBtb2QuZXhwb3J0cztcbn07XG52YXIgX19leHBvcnQgPSAodGFyZ2V0LCBhbGwpID0+IHtcbiAgZm9yICh2YXIgbmFtZSBpbiBhbGwpXG4gICAgX19kZWZQcm9wKHRhcmdldCwgbmFtZSwgeyBnZXQ6IGFsbFtuYW1lXSwgZW51bWVyYWJsZTogdHJ1ZSB9KTtcbn07XG52YXIgX19jb3B5UHJvcHMgPSAodG8sIGZyb20sIGV4Y2VwdCwgZGVzYykgPT4ge1xuICBpZiAoZnJvbSAmJiB0eXBlb2YgZnJvbSA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgZnJvbSA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgZm9yIChsZXQga2V5IG9mIF9fZ2V0T3duUHJvcE5hbWVzKGZyb20pKVxuICAgICAgaWYgKCFfX2hhc093blByb3AuY2FsbCh0bywga2V5KSAmJiBrZXkgIT09IGV4Y2VwdClcbiAgICAgICAgX19kZWZQcm9wKHRvLCBrZXksIHsgZ2V0OiAoKSA9PiBmcm9tW2tleV0sIGVudW1lcmFibGU6ICEoZGVzYyA9IF9fZ2V0T3duUHJvcERlc2MoZnJvbSwga2V5KSkgfHwgZGVzYy5lbnVtZXJhYmxlIH0pO1xuICB9XG4gIHJldHVybiB0bztcbn07XG52YXIgX190b0VTTSA9IChtb2QsIGlzTm9kZU1vZGUsIHRhcmdldCkgPT4gKHRhcmdldCA9IG1vZCAhPSBudWxsID8gX19jcmVhdGUoX19nZXRQcm90b09mKG1vZCkpIDoge30sIF9fY29weVByb3BzKFxuICAvLyBJZiB0aGUgaW1wb3J0ZXIgaXMgaW4gbm9kZSBjb21wYXRpYmlsaXR5IG1vZGUgb3IgdGhpcyBpcyBub3QgYW4gRVNNXG4gIC8vIGZpbGUgdGhhdCBoYXMgYmVlbiBjb252ZXJ0ZWQgdG8gYSBDb21tb25KUyBmaWxlIHVzaW5nIGEgQmFiZWwtXG4gIC8vIGNvbXBhdGlibGUgdHJhbnNmb3JtIChpLmUuIFwiX19lc01vZHVsZVwiIGhhcyBub3QgYmVlbiBzZXQpLCB0aGVuIHNldFxuICAvLyBcImRlZmF1bHRcIiB0byB0aGUgQ29tbW9uSlMgXCJtb2R1bGUuZXhwb3J0c1wiIGZvciBub2RlIGNvbXBhdGliaWxpdHkuXG4gIGlzTm9kZU1vZGUgfHwgIW1vZCB8fCAhbW9kLl9fZXNNb2R1bGUgPyBfX2RlZlByb3AodGFyZ2V0LCBcImRlZmF1bHRcIiwgeyB2YWx1ZTogbW9kLCBlbnVtZXJhYmxlOiB0cnVlIH0pIDogdGFyZ2V0LFxuICBtb2RcbikpO1xudmFyIF9fdG9Db21tb25KUyA9IChtb2QpID0+IF9fY29weVByb3BzKF9fZGVmUHJvcCh7fSwgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSksIG1vZCk7XG5cbi8vIHVtZDpAanJpZGdld2VsbC9zb3VyY2VtYXAtY29kZWNcbnZhciByZXF1aXJlX3NvdXJjZW1hcF9jb2RlYyA9IF9fY29tbW9uSlMoe1xuICBcInVtZDpAanJpZGdld2VsbC9zb3VyY2VtYXAtY29kZWNcIihleHBvcnRzLCBtb2R1bGUyKSB7XG4gICAgbW9kdWxlMi5leHBvcnRzID0gcmVxdWlyZV9zb3VyY2VtYXBDb2RlYztcbiAgfVxufSk7XG5cbi8vIHVtZDpAanJpZGdld2VsbC9yZXNvbHZlLXVyaVxudmFyIHJlcXVpcmVfcmVzb2x2ZV91cmkgPSBfX2NvbW1vbkpTKHtcbiAgXCJ1bWQ6QGpyaWRnZXdlbGwvcmVzb2x2ZS11cmlcIihleHBvcnRzLCBtb2R1bGUyKSB7XG4gICAgbW9kdWxlMi5leHBvcnRzID0gcmVxdWlyZV9yZXNvbHZlVVJJO1xuICB9XG59KTtcblxuLy8gc3JjL3RyYWNlLW1hcHBpbmcudHNcbnZhciB0cmFjZV9tYXBwaW5nX2V4cG9ydHMgPSB7fTtcbl9fZXhwb3J0KHRyYWNlX21hcHBpbmdfZXhwb3J0cywge1xuICBBbnlNYXA6ICgpID0+IEZsYXR0ZW5NYXAsXG4gIEZsYXR0ZW5NYXA6ICgpID0+IEZsYXR0ZW5NYXAsXG4gIEdSRUFURVNUX0xPV0VSX0JPVU5EOiAoKSA9PiBHUkVBVEVTVF9MT1dFUl9CT1VORCxcbiAgTEVBU1RfVVBQRVJfQk9VTkQ6ICgpID0+IExFQVNUX1VQUEVSX0JPVU5ELFxuICBUcmFjZU1hcDogKCkgPT4gVHJhY2VNYXAsXG4gIGFsbEdlbmVyYXRlZFBvc2l0aW9uc0ZvcjogKCkgPT4gYWxsR2VuZXJhdGVkUG9zaXRpb25zRm9yLFxuICBkZWNvZGVkTWFwOiAoKSA9PiBkZWNvZGVkTWFwLFxuICBkZWNvZGVkTWFwcGluZ3M6ICgpID0+IGRlY29kZWRNYXBwaW5ncyxcbiAgZWFjaE1hcHBpbmc6ICgpID0+IGVhY2hNYXBwaW5nLFxuICBlbmNvZGVkTWFwOiAoKSA9PiBlbmNvZGVkTWFwLFxuICBlbmNvZGVkTWFwcGluZ3M6ICgpID0+IGVuY29kZWRNYXBwaW5ncyxcbiAgZ2VuZXJhdGVkUG9zaXRpb25Gb3I6ICgpID0+IGdlbmVyYXRlZFBvc2l0aW9uRm9yLFxuICBpc0lnbm9yZWQ6ICgpID0+IGlzSWdub3JlZCxcbiAgb3JpZ2luYWxQb3NpdGlvbkZvcjogKCkgPT4gb3JpZ2luYWxQb3NpdGlvbkZvcixcbiAgcHJlc29ydGVkRGVjb2RlZE1hcDogKCkgPT4gcHJlc29ydGVkRGVjb2RlZE1hcCxcbiAgc291cmNlQ29udGVudEZvcjogKCkgPT4gc291cmNlQ29udGVudEZvcixcbiAgdHJhY2VTZWdtZW50OiAoKSA9PiB0cmFjZVNlZ21lbnRcbn0pO1xubW9kdWxlLmV4cG9ydHMgPSBfX3RvQ29tbW9uSlModHJhY2VfbWFwcGluZ19leHBvcnRzKTtcbnZhciBpbXBvcnRfc291cmNlbWFwX2NvZGVjID0gX190b0VTTShyZXF1aXJlX3NvdXJjZW1hcF9jb2RlYygpKTtcblxuLy8gc3JjL3Jlc29sdmUudHNcbnZhciBpbXBvcnRfcmVzb2x2ZV91cmkgPSBfX3RvRVNNKHJlcXVpcmVfcmVzb2x2ZV91cmkoKSk7XG5cbi8vIHNyYy9zdHJpcC1maWxlbmFtZS50c1xuZnVuY3Rpb24gc3RyaXBGaWxlbmFtZShwYXRoKSB7XG4gIGlmICghcGF0aCkgcmV0dXJuIFwiXCI7XG4gIGNvbnN0IGluZGV4ID0gcGF0aC5sYXN0SW5kZXhPZihcIi9cIik7XG4gIHJldHVybiBwYXRoLnNsaWNlKDAsIGluZGV4ICsgMSk7XG59XG5cbi8vIHNyYy9yZXNvbHZlLnRzXG5mdW5jdGlvbiByZXNvbHZlcihtYXBVcmwsIHNvdXJjZVJvb3QpIHtcbiAgY29uc3QgZnJvbSA9IHN0cmlwRmlsZW5hbWUobWFwVXJsKTtcbiAgY29uc3QgcHJlZml4ID0gc291cmNlUm9vdCA/IHNvdXJjZVJvb3QgKyBcIi9cIiA6IFwiXCI7XG4gIHJldHVybiAoc291cmNlKSA9PiAoMCwgaW1wb3J0X3Jlc29sdmVfdXJpLmRlZmF1bHQpKHByZWZpeCArIChzb3VyY2UgfHwgXCJcIiksIGZyb20pO1xufVxuXG4vLyBzcmMvc291cmNlbWFwLXNlZ21lbnQudHNcbnZhciBDT0xVTU4gPSAwO1xudmFyIFNPVVJDRVNfSU5ERVggPSAxO1xudmFyIFNPVVJDRV9MSU5FID0gMjtcbnZhciBTT1VSQ0VfQ09MVU1OID0gMztcbnZhciBOQU1FU19JTkRFWCA9IDQ7XG52YXIgUkVWX0dFTkVSQVRFRF9MSU5FID0gMTtcbnZhciBSRVZfR0VORVJBVEVEX0NPTFVNTiA9IDI7XG5cbi8vIHNyYy9zb3J0LnRzXG5mdW5jdGlvbiBtYXliZVNvcnQobWFwcGluZ3MsIG93bmVkKSB7XG4gIGNvbnN0IHVuc29ydGVkSW5kZXggPSBuZXh0VW5zb3J0ZWRTZWdtZW50TGluZShtYXBwaW5ncywgMCk7XG4gIGlmICh1bnNvcnRlZEluZGV4ID09PSBtYXBwaW5ncy5sZW5ndGgpIHJldHVybiBtYXBwaW5ncztcbiAgaWYgKCFvd25lZCkgbWFwcGluZ3MgPSBtYXBwaW5ncy5zbGljZSgpO1xuICBmb3IgKGxldCBpID0gdW5zb3J0ZWRJbmRleDsgaSA8IG1hcHBpbmdzLmxlbmd0aDsgaSA9IG5leHRVbnNvcnRlZFNlZ21lbnRMaW5lKG1hcHBpbmdzLCBpICsgMSkpIHtcbiAgICBtYXBwaW5nc1tpXSA9IHNvcnRTZWdtZW50cyhtYXBwaW5nc1tpXSwgb3duZWQpO1xuICB9XG4gIHJldHVybiBtYXBwaW5ncztcbn1cbmZ1bmN0aW9uIG5leHRVbnNvcnRlZFNlZ21lbnRMaW5lKG1hcHBpbmdzLCBzdGFydCkge1xuICBmb3IgKGxldCBpID0gc3RhcnQ7IGkgPCBtYXBwaW5ncy5sZW5ndGg7IGkrKykge1xuICAgIGlmICghaXNTb3J0ZWQobWFwcGluZ3NbaV0pKSByZXR1cm4gaTtcbiAgfVxuICByZXR1cm4gbWFwcGluZ3MubGVuZ3RoO1xufVxuZnVuY3Rpb24gaXNTb3J0ZWQobGluZSkge1xuICBmb3IgKGxldCBqID0gMTsgaiA8IGxpbmUubGVuZ3RoOyBqKyspIHtcbiAgICBpZiAobGluZVtqXVtDT0xVTU5dIDwgbGluZVtqIC0gMV1bQ09MVU1OXSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gdHJ1ZTtcbn1cbmZ1bmN0aW9uIHNvcnRTZWdtZW50cyhsaW5lLCBvd25lZCkge1xuICBpZiAoIW93bmVkKSBsaW5lID0gbGluZS5zbGljZSgpO1xuICByZXR1cm4gbGluZS5zb3J0KHNvcnRDb21wYXJhdG9yKTtcbn1cbmZ1bmN0aW9uIHNvcnRDb21wYXJhdG9yKGEsIGIpIHtcbiAgcmV0dXJuIGFbQ09MVU1OXSAtIGJbQ09MVU1OXTtcbn1cblxuLy8gc3JjL2J5LXNvdXJjZS50c1xuZnVuY3Rpb24gYnVpbGRCeVNvdXJjZXMoZGVjb2RlZCwgbWVtb3MpIHtcbiAgY29uc3Qgc291cmNlcyA9IG1lbW9zLm1hcCgoKSA9PiBbXSk7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgZGVjb2RlZC5sZW5ndGg7IGkrKykge1xuICAgIGNvbnN0IGxpbmUgPSBkZWNvZGVkW2ldO1xuICAgIGZvciAobGV0IGogPSAwOyBqIDwgbGluZS5sZW5ndGg7IGorKykge1xuICAgICAgY29uc3Qgc2VnID0gbGluZVtqXTtcbiAgICAgIGlmIChzZWcubGVuZ3RoID09PSAxKSBjb250aW51ZTtcbiAgICAgIGNvbnN0IHNvdXJjZUluZGV4MiA9IHNlZ1tTT1VSQ0VTX0lOREVYXTtcbiAgICAgIGNvbnN0IHNvdXJjZUxpbmUgPSBzZWdbU09VUkNFX0xJTkVdO1xuICAgICAgY29uc3Qgc291cmNlQ29sdW1uID0gc2VnW1NPVVJDRV9DT0xVTU5dO1xuICAgICAgY29uc3Qgc291cmNlID0gc291cmNlc1tzb3VyY2VJbmRleDJdO1xuICAgICAgY29uc3Qgc2VncyA9IHNvdXJjZVtzb3VyY2VMaW5lXSB8fCAoc291cmNlW3NvdXJjZUxpbmVdID0gW10pO1xuICAgICAgc2Vncy5wdXNoKFtzb3VyY2VDb2x1bW4sIGksIHNlZ1tDT0xVTU5dXSk7XG4gICAgfVxuICB9XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgc291cmNlcy5sZW5ndGg7IGkrKykge1xuICAgIGNvbnN0IHNvdXJjZSA9IHNvdXJjZXNbaV07XG4gICAgZm9yIChsZXQgaiA9IDA7IGogPCBzb3VyY2UubGVuZ3RoOyBqKyspIHtcbiAgICAgIGNvbnN0IGxpbmUgPSBzb3VyY2Vbal07XG4gICAgICBpZiAobGluZSkgbGluZS5zb3J0KHNvcnRDb21wYXJhdG9yKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHNvdXJjZXM7XG59XG5cbi8vIHNyYy9iaW5hcnktc2VhcmNoLnRzXG52YXIgZm91bmQgPSBmYWxzZTtcbmZ1bmN0aW9uIGJpbmFyeVNlYXJjaChoYXlzdGFjaywgbmVlZGxlLCBsb3csIGhpZ2gpIHtcbiAgd2hpbGUgKGxvdyA8PSBoaWdoKSB7XG4gICAgY29uc3QgbWlkID0gbG93ICsgKGhpZ2ggLSBsb3cgPj4gMSk7XG4gICAgY29uc3QgY21wID0gaGF5c3RhY2tbbWlkXVtDT0xVTU5dIC0gbmVlZGxlO1xuICAgIGlmIChjbXAgPT09IDApIHtcbiAgICAgIGZvdW5kID0gdHJ1ZTtcbiAgICAgIHJldHVybiBtaWQ7XG4gICAgfVxuICAgIGlmIChjbXAgPCAwKSB7XG4gICAgICBsb3cgPSBtaWQgKyAxO1xuICAgIH0gZWxzZSB7XG4gICAgICBoaWdoID0gbWlkIC0gMTtcbiAgICB9XG4gIH1cbiAgZm91bmQgPSBmYWxzZTtcbiAgcmV0dXJuIGxvdyAtIDE7XG59XG5mdW5jdGlvbiB1cHBlckJvdW5kKGhheXN0YWNrLCBuZWVkbGUsIGluZGV4KSB7XG4gIGZvciAobGV0IGkgPSBpbmRleCArIDE7IGkgPCBoYXlzdGFjay5sZW5ndGg7IGluZGV4ID0gaSsrKSB7XG4gICAgaWYgKGhheXN0YWNrW2ldW0NPTFVNTl0gIT09IG5lZWRsZSkgYnJlYWs7XG4gIH1cbiAgcmV0dXJuIGluZGV4O1xufVxuZnVuY3Rpb24gbG93ZXJCb3VuZChoYXlzdGFjaywgbmVlZGxlLCBpbmRleCkge1xuICBmb3IgKGxldCBpID0gaW5kZXggLSAxOyBpID49IDA7IGluZGV4ID0gaS0tKSB7XG4gICAgaWYgKGhheXN0YWNrW2ldW0NPTFVNTl0gIT09IG5lZWRsZSkgYnJlYWs7XG4gIH1cbiAgcmV0dXJuIGluZGV4O1xufVxuZnVuY3Rpb24gbWVtb2l6ZWRTdGF0ZSgpIHtcbiAgcmV0dXJuIHtcbiAgICBsYXN0S2V5OiAtMSxcbiAgICBsYXN0TmVlZGxlOiAtMSxcbiAgICBsYXN0SW5kZXg6IC0xXG4gIH07XG59XG5mdW5jdGlvbiBtZW1vaXplZEJpbmFyeVNlYXJjaChoYXlzdGFjaywgbmVlZGxlLCBzdGF0ZSwga2V5KSB7XG4gIGNvbnN0IHsgbGFzdEtleSwgbGFzdE5lZWRsZSwgbGFzdEluZGV4IH0gPSBzdGF0ZTtcbiAgbGV0IGxvdyA9IDA7XG4gIGxldCBoaWdoID0gaGF5c3RhY2subGVuZ3RoIC0gMTtcbiAgaWYgKGtleSA9PT0gbGFzdEtleSkge1xuICAgIGlmIChuZWVkbGUgPT09IGxhc3ROZWVkbGUpIHtcbiAgICAgIGZvdW5kID0gbGFzdEluZGV4ICE9PSAtMSAmJiBoYXlzdGFja1tsYXN0SW5kZXhdW0NPTFVNTl0gPT09IG5lZWRsZTtcbiAgICAgIHJldHVybiBsYXN0SW5kZXg7XG4gICAgfVxuICAgIGlmIChuZWVkbGUgPj0gbGFzdE5lZWRsZSkge1xuICAgICAgbG93ID0gbGFzdEluZGV4ID09PSAtMSA/IDAgOiBsYXN0SW5kZXg7XG4gICAgfSBlbHNlIHtcbiAgICAgIGhpZ2ggPSBsYXN0SW5kZXg7XG4gICAgfVxuICB9XG4gIHN0YXRlLmxhc3RLZXkgPSBrZXk7XG4gIHN0YXRlLmxhc3ROZWVkbGUgPSBuZWVkbGU7XG4gIHJldHVybiBzdGF0ZS5sYXN0SW5kZXggPSBiaW5hcnlTZWFyY2goaGF5c3RhY2ssIG5lZWRsZSwgbG93LCBoaWdoKTtcbn1cblxuLy8gc3JjL3R5cGVzLnRzXG5mdW5jdGlvbiBwYXJzZShtYXApIHtcbiAgcmV0dXJuIHR5cGVvZiBtYXAgPT09IFwic3RyaW5nXCIgPyBKU09OLnBhcnNlKG1hcCkgOiBtYXA7XG59XG5cbi8vIHNyYy9mbGF0dGVuLW1hcC50c1xudmFyIEZsYXR0ZW5NYXAgPSBmdW5jdGlvbihtYXAsIG1hcFVybCkge1xuICBjb25zdCBwYXJzZWQgPSBwYXJzZShtYXApO1xuICBpZiAoIShcInNlY3Rpb25zXCIgaW4gcGFyc2VkKSkge1xuICAgIHJldHVybiBuZXcgVHJhY2VNYXAocGFyc2VkLCBtYXBVcmwpO1xuICB9XG4gIGNvbnN0IG1hcHBpbmdzID0gW107XG4gIGNvbnN0IHNvdXJjZXMgPSBbXTtcbiAgY29uc3Qgc291cmNlc0NvbnRlbnQgPSBbXTtcbiAgY29uc3QgbmFtZXMgPSBbXTtcbiAgY29uc3QgaWdub3JlTGlzdCA9IFtdO1xuICByZWN1cnNlKFxuICAgIHBhcnNlZCxcbiAgICBtYXBVcmwsXG4gICAgbWFwcGluZ3MsXG4gICAgc291cmNlcyxcbiAgICBzb3VyY2VzQ29udGVudCxcbiAgICBuYW1lcyxcbiAgICBpZ25vcmVMaXN0LFxuICAgIDAsXG4gICAgMCxcbiAgICBJbmZpbml0eSxcbiAgICBJbmZpbml0eVxuICApO1xuICBjb25zdCBqb2luZWQgPSB7XG4gICAgdmVyc2lvbjogMyxcbiAgICBmaWxlOiBwYXJzZWQuZmlsZSxcbiAgICBuYW1lcyxcbiAgICBzb3VyY2VzLFxuICAgIHNvdXJjZXNDb250ZW50LFxuICAgIG1hcHBpbmdzLFxuICAgIGlnbm9yZUxpc3RcbiAgfTtcbiAgcmV0dXJuIHByZXNvcnRlZERlY29kZWRNYXAoam9pbmVkKTtcbn07XG5mdW5jdGlvbiByZWN1cnNlKGlucHV0LCBtYXBVcmwsIG1hcHBpbmdzLCBzb3VyY2VzLCBzb3VyY2VzQ29udGVudCwgbmFtZXMsIGlnbm9yZUxpc3QsIGxpbmVPZmZzZXQsIGNvbHVtbk9mZnNldCwgc3RvcExpbmUsIHN0b3BDb2x1bW4pIHtcbiAgY29uc3QgeyBzZWN0aW9ucyB9ID0gaW5wdXQ7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgc2VjdGlvbnMubGVuZ3RoOyBpKyspIHtcbiAgICBjb25zdCB7IG1hcCwgb2Zmc2V0IH0gPSBzZWN0aW9uc1tpXTtcbiAgICBsZXQgc2wgPSBzdG9wTGluZTtcbiAgICBsZXQgc2MgPSBzdG9wQ29sdW1uO1xuICAgIGlmIChpICsgMSA8IHNlY3Rpb25zLmxlbmd0aCkge1xuICAgICAgY29uc3QgbmV4dE9mZnNldCA9IHNlY3Rpb25zW2kgKyAxXS5vZmZzZXQ7XG4gICAgICBzbCA9IE1hdGgubWluKHN0b3BMaW5lLCBsaW5lT2Zmc2V0ICsgbmV4dE9mZnNldC5saW5lKTtcbiAgICAgIGlmIChzbCA9PT0gc3RvcExpbmUpIHtcbiAgICAgICAgc2MgPSBNYXRoLm1pbihzdG9wQ29sdW1uLCBjb2x1bW5PZmZzZXQgKyBuZXh0T2Zmc2V0LmNvbHVtbik7XG4gICAgICB9IGVsc2UgaWYgKHNsIDwgc3RvcExpbmUpIHtcbiAgICAgICAgc2MgPSBjb2x1bW5PZmZzZXQgKyBuZXh0T2Zmc2V0LmNvbHVtbjtcbiAgICAgIH1cbiAgICB9XG4gICAgYWRkU2VjdGlvbihcbiAgICAgIG1hcCxcbiAgICAgIG1hcFVybCxcbiAgICAgIG1hcHBpbmdzLFxuICAgICAgc291cmNlcyxcbiAgICAgIHNvdXJjZXNDb250ZW50LFxuICAgICAgbmFtZXMsXG4gICAgICBpZ25vcmVMaXN0LFxuICAgICAgbGluZU9mZnNldCArIG9mZnNldC5saW5lLFxuICAgICAgY29sdW1uT2Zmc2V0ICsgb2Zmc2V0LmNvbHVtbixcbiAgICAgIHNsLFxuICAgICAgc2NcbiAgICApO1xuICB9XG59XG5mdW5jdGlvbiBhZGRTZWN0aW9uKGlucHV0LCBtYXBVcmwsIG1hcHBpbmdzLCBzb3VyY2VzLCBzb3VyY2VzQ29udGVudCwgbmFtZXMsIGlnbm9yZUxpc3QsIGxpbmVPZmZzZXQsIGNvbHVtbk9mZnNldCwgc3RvcExpbmUsIHN0b3BDb2x1bW4pIHtcbiAgY29uc3QgcGFyc2VkID0gcGFyc2UoaW5wdXQpO1xuICBpZiAoXCJzZWN0aW9uc1wiIGluIHBhcnNlZCkgcmV0dXJuIHJlY3Vyc2UoLi4uYXJndW1lbnRzKTtcbiAgY29uc3QgbWFwID0gbmV3IFRyYWNlTWFwKHBhcnNlZCwgbWFwVXJsKTtcbiAgY29uc3Qgc291cmNlc09mZnNldCA9IHNvdXJjZXMubGVuZ3RoO1xuICBjb25zdCBuYW1lc09mZnNldCA9IG5hbWVzLmxlbmd0aDtcbiAgY29uc3QgZGVjb2RlZCA9IGRlY29kZWRNYXBwaW5ncyhtYXApO1xuICBjb25zdCB7IHJlc29sdmVkU291cmNlcywgc291cmNlc0NvbnRlbnQ6IGNvbnRlbnRzLCBpZ25vcmVMaXN0OiBpZ25vcmVzIH0gPSBtYXA7XG4gIGFwcGVuZChzb3VyY2VzLCByZXNvbHZlZFNvdXJjZXMpO1xuICBhcHBlbmQobmFtZXMsIG1hcC5uYW1lcyk7XG4gIGlmIChjb250ZW50cykgYXBwZW5kKHNvdXJjZXNDb250ZW50LCBjb250ZW50cyk7XG4gIGVsc2UgZm9yIChsZXQgaSA9IDA7IGkgPCByZXNvbHZlZFNvdXJjZXMubGVuZ3RoOyBpKyspIHNvdXJjZXNDb250ZW50LnB1c2gobnVsbCk7XG4gIGlmIChpZ25vcmVzKSBmb3IgKGxldCBpID0gMDsgaSA8IGlnbm9yZXMubGVuZ3RoOyBpKyspIGlnbm9yZUxpc3QucHVzaChpZ25vcmVzW2ldICsgc291cmNlc09mZnNldCk7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgZGVjb2RlZC5sZW5ndGg7IGkrKykge1xuICAgIGNvbnN0IGxpbmVJID0gbGluZU9mZnNldCArIGk7XG4gICAgaWYgKGxpbmVJID4gc3RvcExpbmUpIHJldHVybjtcbiAgICBjb25zdCBvdXQgPSBnZXRMaW5lKG1hcHBpbmdzLCBsaW5lSSk7XG4gICAgY29uc3QgY09mZnNldCA9IGkgPT09IDAgPyBjb2x1bW5PZmZzZXQgOiAwO1xuICAgIGNvbnN0IGxpbmUgPSBkZWNvZGVkW2ldO1xuICAgIGZvciAobGV0IGogPSAwOyBqIDwgbGluZS5sZW5ndGg7IGorKykge1xuICAgICAgY29uc3Qgc2VnID0gbGluZVtqXTtcbiAgICAgIGNvbnN0IGNvbHVtbiA9IGNPZmZzZXQgKyBzZWdbQ09MVU1OXTtcbiAgICAgIGlmIChsaW5lSSA9PT0gc3RvcExpbmUgJiYgY29sdW1uID49IHN0b3BDb2x1bW4pIHJldHVybjtcbiAgICAgIGlmIChzZWcubGVuZ3RoID09PSAxKSB7XG4gICAgICAgIG91dC5wdXNoKFtjb2x1bW5dKTtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBjb25zdCBzb3VyY2VzSW5kZXggPSBzb3VyY2VzT2Zmc2V0ICsgc2VnW1NPVVJDRVNfSU5ERVhdO1xuICAgICAgY29uc3Qgc291cmNlTGluZSA9IHNlZ1tTT1VSQ0VfTElORV07XG4gICAgICBjb25zdCBzb3VyY2VDb2x1bW4gPSBzZWdbU09VUkNFX0NPTFVNTl07XG4gICAgICBvdXQucHVzaChcbiAgICAgICAgc2VnLmxlbmd0aCA9PT0gNCA/IFtjb2x1bW4sIHNvdXJjZXNJbmRleCwgc291cmNlTGluZSwgc291cmNlQ29sdW1uXSA6IFtjb2x1bW4sIHNvdXJjZXNJbmRleCwgc291cmNlTGluZSwgc291cmNlQ29sdW1uLCBuYW1lc09mZnNldCArIHNlZ1tOQU1FU19JTkRFWF1dXG4gICAgICApO1xuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gYXBwZW5kKGFyciwgb3RoZXIpIHtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBvdGhlci5sZW5ndGg7IGkrKykgYXJyLnB1c2gob3RoZXJbaV0pO1xufVxuZnVuY3Rpb24gZ2V0TGluZShhcnIsIGluZGV4KSB7XG4gIGZvciAobGV0IGkgPSBhcnIubGVuZ3RoOyBpIDw9IGluZGV4OyBpKyspIGFycltpXSA9IFtdO1xuICByZXR1cm4gYXJyW2luZGV4XTtcbn1cblxuLy8gc3JjL3RyYWNlLW1hcHBpbmcudHNcbnZhciBMSU5FX0dUUl9aRVJPID0gXCJgbGluZWAgbXVzdCBiZSBncmVhdGVyIHRoYW4gMCAobGluZXMgc3RhcnQgYXQgbGluZSAxKVwiO1xudmFyIENPTF9HVFJfRVFfWkVSTyA9IFwiYGNvbHVtbmAgbXVzdCBiZSBncmVhdGVyIHRoYW4gb3IgZXF1YWwgdG8gMCAoY29sdW1ucyBzdGFydCBhdCBjb2x1bW4gMClcIjtcbnZhciBMRUFTVF9VUFBFUl9CT1VORCA9IC0xO1xudmFyIEdSRUFURVNUX0xPV0VSX0JPVU5EID0gMTtcbnZhciBUcmFjZU1hcCA9IGNsYXNzIHtcbiAgY29uc3RydWN0b3IobWFwLCBtYXBVcmwpIHtcbiAgICBjb25zdCBpc1N0cmluZyA9IHR5cGVvZiBtYXAgPT09IFwic3RyaW5nXCI7XG4gICAgaWYgKCFpc1N0cmluZyAmJiBtYXAuX2RlY29kZWRNZW1vKSByZXR1cm4gbWFwO1xuICAgIGNvbnN0IHBhcnNlZCA9IHBhcnNlKG1hcCk7XG4gICAgY29uc3QgeyB2ZXJzaW9uLCBmaWxlLCBuYW1lcywgc291cmNlUm9vdCwgc291cmNlcywgc291cmNlc0NvbnRlbnQgfSA9IHBhcnNlZDtcbiAgICB0aGlzLnZlcnNpb24gPSB2ZXJzaW9uO1xuICAgIHRoaXMuZmlsZSA9IGZpbGU7XG4gICAgdGhpcy5uYW1lcyA9IG5hbWVzIHx8IFtdO1xuICAgIHRoaXMuc291cmNlUm9vdCA9IHNvdXJjZVJvb3Q7XG4gICAgdGhpcy5zb3VyY2VzID0gc291cmNlcztcbiAgICB0aGlzLnNvdXJjZXNDb250ZW50ID0gc291cmNlc0NvbnRlbnQ7XG4gICAgdGhpcy5pZ25vcmVMaXN0ID0gcGFyc2VkLmlnbm9yZUxpc3QgfHwgcGFyc2VkLnhfZ29vZ2xlX2lnbm9yZUxpc3QgfHwgdm9pZCAwO1xuICAgIGNvbnN0IHJlc29sdmUgPSByZXNvbHZlcihtYXBVcmwsIHNvdXJjZVJvb3QpO1xuICAgIHRoaXMucmVzb2x2ZWRTb3VyY2VzID0gc291cmNlcy5tYXAocmVzb2x2ZSk7XG4gICAgY29uc3QgeyBtYXBwaW5ncyB9ID0gcGFyc2VkO1xuICAgIGlmICh0eXBlb2YgbWFwcGluZ3MgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgIHRoaXMuX2VuY29kZWQgPSBtYXBwaW5ncztcbiAgICAgIHRoaXMuX2RlY29kZWQgPSB2b2lkIDA7XG4gICAgfSBlbHNlIGlmIChBcnJheS5pc0FycmF5KG1hcHBpbmdzKSkge1xuICAgICAgdGhpcy5fZW5jb2RlZCA9IHZvaWQgMDtcbiAgICAgIHRoaXMuX2RlY29kZWQgPSBtYXliZVNvcnQobWFwcGluZ3MsIGlzU3RyaW5nKTtcbiAgICB9IGVsc2UgaWYgKHBhcnNlZC5zZWN0aW9ucykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBUcmFjZU1hcCBwYXNzZWQgc2VjdGlvbmVkIHNvdXJjZSBtYXAsIHBsZWFzZSB1c2UgRmxhdHRlbk1hcCBleHBvcnQgaW5zdGVhZGApO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYGludmFsaWQgc291cmNlIG1hcDogJHtKU09OLnN0cmluZ2lmeShwYXJzZWQpfWApO1xuICAgIH1cbiAgICB0aGlzLl9kZWNvZGVkTWVtbyA9IG1lbW9pemVkU3RhdGUoKTtcbiAgICB0aGlzLl9ieVNvdXJjZXMgPSB2b2lkIDA7XG4gICAgdGhpcy5fYnlTb3VyY2VNZW1vcyA9IHZvaWQgMDtcbiAgfVxufTtcbmZ1bmN0aW9uIGNhc3QobWFwKSB7XG4gIHJldHVybiBtYXA7XG59XG5mdW5jdGlvbiBlbmNvZGVkTWFwcGluZ3MobWFwKSB7XG4gIHZhciBfYSwgX2I7XG4gIHJldHVybiAoX2IgPSAoX2EgPSBjYXN0KG1hcCkpLl9lbmNvZGVkKSAhPSBudWxsID8gX2IgOiBfYS5fZW5jb2RlZCA9ICgwLCBpbXBvcnRfc291cmNlbWFwX2NvZGVjLmVuY29kZSkoY2FzdChtYXApLl9kZWNvZGVkKTtcbn1cbmZ1bmN0aW9uIGRlY29kZWRNYXBwaW5ncyhtYXApIHtcbiAgdmFyIF9hO1xuICByZXR1cm4gKF9hID0gY2FzdChtYXApKS5fZGVjb2RlZCB8fCAoX2EuX2RlY29kZWQgPSAoMCwgaW1wb3J0X3NvdXJjZW1hcF9jb2RlYy5kZWNvZGUpKGNhc3QobWFwKS5fZW5jb2RlZCkpO1xufVxuZnVuY3Rpb24gdHJhY2VTZWdtZW50KG1hcCwgbGluZSwgY29sdW1uKSB7XG4gIGNvbnN0IGRlY29kZWQgPSBkZWNvZGVkTWFwcGluZ3MobWFwKTtcbiAgaWYgKGxpbmUgPj0gZGVjb2RlZC5sZW5ndGgpIHJldHVybiBudWxsO1xuICBjb25zdCBzZWdtZW50cyA9IGRlY29kZWRbbGluZV07XG4gIGNvbnN0IGluZGV4ID0gdHJhY2VTZWdtZW50SW50ZXJuYWwoXG4gICAgc2VnbWVudHMsXG4gICAgY2FzdChtYXApLl9kZWNvZGVkTWVtbyxcbiAgICBsaW5lLFxuICAgIGNvbHVtbixcbiAgICBHUkVBVEVTVF9MT1dFUl9CT1VORFxuICApO1xuICByZXR1cm4gaW5kZXggPT09IC0xID8gbnVsbCA6IHNlZ21lbnRzW2luZGV4XTtcbn1cbmZ1bmN0aW9uIG9yaWdpbmFsUG9zaXRpb25Gb3IobWFwLCBuZWVkbGUpIHtcbiAgbGV0IHsgbGluZSwgY29sdW1uLCBiaWFzIH0gPSBuZWVkbGU7XG4gIGxpbmUtLTtcbiAgaWYgKGxpbmUgPCAwKSB0aHJvdyBuZXcgRXJyb3IoTElORV9HVFJfWkVSTyk7XG4gIGlmIChjb2x1bW4gPCAwKSB0aHJvdyBuZXcgRXJyb3IoQ09MX0dUUl9FUV9aRVJPKTtcbiAgY29uc3QgZGVjb2RlZCA9IGRlY29kZWRNYXBwaW5ncyhtYXApO1xuICBpZiAobGluZSA+PSBkZWNvZGVkLmxlbmd0aCkgcmV0dXJuIE9NYXBwaW5nKG51bGwsIG51bGwsIG51bGwsIG51bGwpO1xuICBjb25zdCBzZWdtZW50cyA9IGRlY29kZWRbbGluZV07XG4gIGNvbnN0IGluZGV4ID0gdHJhY2VTZWdtZW50SW50ZXJuYWwoXG4gICAgc2VnbWVudHMsXG4gICAgY2FzdChtYXApLl9kZWNvZGVkTWVtbyxcbiAgICBsaW5lLFxuICAgIGNvbHVtbixcbiAgICBiaWFzIHx8IEdSRUFURVNUX0xPV0VSX0JPVU5EXG4gICk7XG4gIGlmIChpbmRleCA9PT0gLTEpIHJldHVybiBPTWFwcGluZyhudWxsLCBudWxsLCBudWxsLCBudWxsKTtcbiAgY29uc3Qgc2VnbWVudCA9IHNlZ21lbnRzW2luZGV4XTtcbiAgaWYgKHNlZ21lbnQubGVuZ3RoID09PSAxKSByZXR1cm4gT01hcHBpbmcobnVsbCwgbnVsbCwgbnVsbCwgbnVsbCk7XG4gIGNvbnN0IHsgbmFtZXMsIHJlc29sdmVkU291cmNlcyB9ID0gbWFwO1xuICByZXR1cm4gT01hcHBpbmcoXG4gICAgcmVzb2x2ZWRTb3VyY2VzW3NlZ21lbnRbU09VUkNFU19JTkRFWF1dLFxuICAgIHNlZ21lbnRbU09VUkNFX0xJTkVdICsgMSxcbiAgICBzZWdtZW50W1NPVVJDRV9DT0xVTU5dLFxuICAgIHNlZ21lbnQubGVuZ3RoID09PSA1ID8gbmFtZXNbc2VnbWVudFtOQU1FU19JTkRFWF1dIDogbnVsbFxuICApO1xufVxuZnVuY3Rpb24gZ2VuZXJhdGVkUG9zaXRpb25Gb3IobWFwLCBuZWVkbGUpIHtcbiAgY29uc3QgeyBzb3VyY2UsIGxpbmUsIGNvbHVtbiwgYmlhcyB9ID0gbmVlZGxlO1xuICByZXR1cm4gZ2VuZXJhdGVkUG9zaXRpb24obWFwLCBzb3VyY2UsIGxpbmUsIGNvbHVtbiwgYmlhcyB8fCBHUkVBVEVTVF9MT1dFUl9CT1VORCwgZmFsc2UpO1xufVxuZnVuY3Rpb24gYWxsR2VuZXJhdGVkUG9zaXRpb25zRm9yKG1hcCwgbmVlZGxlKSB7XG4gIGNvbnN0IHsgc291cmNlLCBsaW5lLCBjb2x1bW4sIGJpYXMgfSA9IG5lZWRsZTtcbiAgcmV0dXJuIGdlbmVyYXRlZFBvc2l0aW9uKG1hcCwgc291cmNlLCBsaW5lLCBjb2x1bW4sIGJpYXMgfHwgTEVBU1RfVVBQRVJfQk9VTkQsIHRydWUpO1xufVxuZnVuY3Rpb24gZWFjaE1hcHBpbmcobWFwLCBjYikge1xuICBjb25zdCBkZWNvZGVkID0gZGVjb2RlZE1hcHBpbmdzKG1hcCk7XG4gIGNvbnN0IHsgbmFtZXMsIHJlc29sdmVkU291cmNlcyB9ID0gbWFwO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IGRlY29kZWQubGVuZ3RoOyBpKyspIHtcbiAgICBjb25zdCBsaW5lID0gZGVjb2RlZFtpXTtcbiAgICBmb3IgKGxldCBqID0gMDsgaiA8IGxpbmUubGVuZ3RoOyBqKyspIHtcbiAgICAgIGNvbnN0IHNlZyA9IGxpbmVbal07XG4gICAgICBjb25zdCBnZW5lcmF0ZWRMaW5lID0gaSArIDE7XG4gICAgICBjb25zdCBnZW5lcmF0ZWRDb2x1bW4gPSBzZWdbMF07XG4gICAgICBsZXQgc291cmNlID0gbnVsbDtcbiAgICAgIGxldCBvcmlnaW5hbExpbmUgPSBudWxsO1xuICAgICAgbGV0IG9yaWdpbmFsQ29sdW1uID0gbnVsbDtcbiAgICAgIGxldCBuYW1lID0gbnVsbDtcbiAgICAgIGlmIChzZWcubGVuZ3RoICE9PSAxKSB7XG4gICAgICAgIHNvdXJjZSA9IHJlc29sdmVkU291cmNlc1tzZWdbMV1dO1xuICAgICAgICBvcmlnaW5hbExpbmUgPSBzZWdbMl0gKyAxO1xuICAgICAgICBvcmlnaW5hbENvbHVtbiA9IHNlZ1szXTtcbiAgICAgIH1cbiAgICAgIGlmIChzZWcubGVuZ3RoID09PSA1KSBuYW1lID0gbmFtZXNbc2VnWzRdXTtcbiAgICAgIGNiKHtcbiAgICAgICAgZ2VuZXJhdGVkTGluZSxcbiAgICAgICAgZ2VuZXJhdGVkQ29sdW1uLFxuICAgICAgICBzb3VyY2UsXG4gICAgICAgIG9yaWdpbmFsTGluZSxcbiAgICAgICAgb3JpZ2luYWxDb2x1bW4sXG4gICAgICAgIG5hbWVcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gc291cmNlSW5kZXgobWFwLCBzb3VyY2UpIHtcbiAgY29uc3QgeyBzb3VyY2VzLCByZXNvbHZlZFNvdXJjZXMgfSA9IG1hcDtcbiAgbGV0IGluZGV4ID0gc291cmNlcy5pbmRleE9mKHNvdXJjZSk7XG4gIGlmIChpbmRleCA9PT0gLTEpIGluZGV4ID0gcmVzb2x2ZWRTb3VyY2VzLmluZGV4T2Yoc291cmNlKTtcbiAgcmV0dXJuIGluZGV4O1xufVxuZnVuY3Rpb24gc291cmNlQ29udGVudEZvcihtYXAsIHNvdXJjZSkge1xuICBjb25zdCB7IHNvdXJjZXNDb250ZW50IH0gPSBtYXA7XG4gIGlmIChzb3VyY2VzQ29udGVudCA9PSBudWxsKSByZXR1cm4gbnVsbDtcbiAgY29uc3QgaW5kZXggPSBzb3VyY2VJbmRleChtYXAsIHNvdXJjZSk7XG4gIHJldHVybiBpbmRleCA9PT0gLTEgPyBudWxsIDogc291cmNlc0NvbnRlbnRbaW5kZXhdO1xufVxuZnVuY3Rpb24gaXNJZ25vcmVkKG1hcCwgc291cmNlKSB7XG4gIGNvbnN0IHsgaWdub3JlTGlzdCB9ID0gbWFwO1xuICBpZiAoaWdub3JlTGlzdCA9PSBudWxsKSByZXR1cm4gZmFsc2U7XG4gIGNvbnN0IGluZGV4ID0gc291cmNlSW5kZXgobWFwLCBzb3VyY2UpO1xuICByZXR1cm4gaW5kZXggPT09IC0xID8gZmFsc2UgOiBpZ25vcmVMaXN0LmluY2x1ZGVzKGluZGV4KTtcbn1cbmZ1bmN0aW9uIHByZXNvcnRlZERlY29kZWRNYXAobWFwLCBtYXBVcmwpIHtcbiAgY29uc3QgdHJhY2VyID0gbmV3IFRyYWNlTWFwKGNsb25lKG1hcCwgW10pLCBtYXBVcmwpO1xuICBjYXN0KHRyYWNlcikuX2RlY29kZWQgPSBtYXAubWFwcGluZ3M7XG4gIHJldHVybiB0cmFjZXI7XG59XG5mdW5jdGlvbiBkZWNvZGVkTWFwKG1hcCkge1xuICByZXR1cm4gY2xvbmUobWFwLCBkZWNvZGVkTWFwcGluZ3MobWFwKSk7XG59XG5mdW5jdGlvbiBlbmNvZGVkTWFwKG1hcCkge1xuICByZXR1cm4gY2xvbmUobWFwLCBlbmNvZGVkTWFwcGluZ3MobWFwKSk7XG59XG5mdW5jdGlvbiBjbG9uZShtYXAsIG1hcHBpbmdzKSB7XG4gIHJldHVybiB7XG4gICAgdmVyc2lvbjogbWFwLnZlcnNpb24sXG4gICAgZmlsZTogbWFwLmZpbGUsXG4gICAgbmFtZXM6IG1hcC5uYW1lcyxcbiAgICBzb3VyY2VSb290OiBtYXAuc291cmNlUm9vdCxcbiAgICBzb3VyY2VzOiBtYXAuc291cmNlcyxcbiAgICBzb3VyY2VzQ29udGVudDogbWFwLnNvdXJjZXNDb250ZW50LFxuICAgIG1hcHBpbmdzLFxuICAgIGlnbm9yZUxpc3Q6IG1hcC5pZ25vcmVMaXN0IHx8IG1hcC54X2dvb2dsZV9pZ25vcmVMaXN0XG4gIH07XG59XG5mdW5jdGlvbiBPTWFwcGluZyhzb3VyY2UsIGxpbmUsIGNvbHVtbiwgbmFtZSkge1xuICByZXR1cm4geyBzb3VyY2UsIGxpbmUsIGNvbHVtbiwgbmFtZSB9O1xufVxuZnVuY3Rpb24gR01hcHBpbmcobGluZSwgY29sdW1uKSB7XG4gIHJldHVybiB7IGxpbmUsIGNvbHVtbiB9O1xufVxuZnVuY3Rpb24gdHJhY2VTZWdtZW50SW50ZXJuYWwoc2VnbWVudHMsIG1lbW8sIGxpbmUsIGNvbHVtbiwgYmlhcykge1xuICBsZXQgaW5kZXggPSBtZW1vaXplZEJpbmFyeVNlYXJjaChzZWdtZW50cywgY29sdW1uLCBtZW1vLCBsaW5lKTtcbiAgaWYgKGZvdW5kKSB7XG4gICAgaW5kZXggPSAoYmlhcyA9PT0gTEVBU1RfVVBQRVJfQk9VTkQgPyB1cHBlckJvdW5kIDogbG93ZXJCb3VuZCkoc2VnbWVudHMsIGNvbHVtbiwgaW5kZXgpO1xuICB9IGVsc2UgaWYgKGJpYXMgPT09IExFQVNUX1VQUEVSX0JPVU5EKSBpbmRleCsrO1xuICBpZiAoaW5kZXggPT09IC0xIHx8IGluZGV4ID09PSBzZWdtZW50cy5sZW5ndGgpIHJldHVybiAtMTtcbiAgcmV0dXJuIGluZGV4O1xufVxuZnVuY3Rpb24gc2xpY2VHZW5lcmF0ZWRQb3NpdGlvbnMoc2VnbWVudHMsIG1lbW8sIGxpbmUsIGNvbHVtbiwgYmlhcykge1xuICBsZXQgbWluID0gdHJhY2VTZWdtZW50SW50ZXJuYWwoc2VnbWVudHMsIG1lbW8sIGxpbmUsIGNvbHVtbiwgR1JFQVRFU1RfTE9XRVJfQk9VTkQpO1xuICBpZiAoIWZvdW5kICYmIGJpYXMgPT09IExFQVNUX1VQUEVSX0JPVU5EKSBtaW4rKztcbiAgaWYgKG1pbiA9PT0gLTEgfHwgbWluID09PSBzZWdtZW50cy5sZW5ndGgpIHJldHVybiBbXTtcbiAgY29uc3QgbWF0Y2hlZENvbHVtbiA9IGZvdW5kID8gY29sdW1uIDogc2VnbWVudHNbbWluXVtDT0xVTU5dO1xuICBpZiAoIWZvdW5kKSBtaW4gPSBsb3dlckJvdW5kKHNlZ21lbnRzLCBtYXRjaGVkQ29sdW1uLCBtaW4pO1xuICBjb25zdCBtYXggPSB1cHBlckJvdW5kKHNlZ21lbnRzLCBtYXRjaGVkQ29sdW1uLCBtaW4pO1xuICBjb25zdCByZXN1bHQgPSBbXTtcbiAgZm9yICg7IG1pbiA8PSBtYXg7IG1pbisrKSB7XG4gICAgY29uc3Qgc2VnbWVudCA9IHNlZ21lbnRzW21pbl07XG4gICAgcmVzdWx0LnB1c2goR01hcHBpbmcoc2VnbWVudFtSRVZfR0VORVJBVEVEX0xJTkVdICsgMSwgc2VnbWVudFtSRVZfR0VORVJBVEVEX0NPTFVNTl0pKTtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuZnVuY3Rpb24gZ2VuZXJhdGVkUG9zaXRpb24obWFwLCBzb3VyY2UsIGxpbmUsIGNvbHVtbiwgYmlhcywgYWxsKSB7XG4gIHZhciBfYSwgX2I7XG4gIGxpbmUtLTtcbiAgaWYgKGxpbmUgPCAwKSB0aHJvdyBuZXcgRXJyb3IoTElORV9HVFJfWkVSTyk7XG4gIGlmIChjb2x1bW4gPCAwKSB0aHJvdyBuZXcgRXJyb3IoQ09MX0dUUl9FUV9aRVJPKTtcbiAgY29uc3QgeyBzb3VyY2VzLCByZXNvbHZlZFNvdXJjZXMgfSA9IG1hcDtcbiAgbGV0IHNvdXJjZUluZGV4MiA9IHNvdXJjZXMuaW5kZXhPZihzb3VyY2UpO1xuICBpZiAoc291cmNlSW5kZXgyID09PSAtMSkgc291cmNlSW5kZXgyID0gcmVzb2x2ZWRTb3VyY2VzLmluZGV4T2Yoc291cmNlKTtcbiAgaWYgKHNvdXJjZUluZGV4MiA9PT0gLTEpIHJldHVybiBhbGwgPyBbXSA6IEdNYXBwaW5nKG51bGwsIG51bGwpO1xuICBjb25zdCBieVNvdXJjZU1lbW9zID0gKF9hID0gY2FzdChtYXApKS5fYnlTb3VyY2VNZW1vcyB8fCAoX2EuX2J5U291cmNlTWVtb3MgPSBzb3VyY2VzLm1hcChtZW1vaXplZFN0YXRlKSk7XG4gIGNvbnN0IGdlbmVyYXRlZCA9IChfYiA9IGNhc3QobWFwKSkuX2J5U291cmNlcyB8fCAoX2IuX2J5U291cmNlcyA9IGJ1aWxkQnlTb3VyY2VzKGRlY29kZWRNYXBwaW5ncyhtYXApLCBieVNvdXJjZU1lbW9zKSk7XG4gIGNvbnN0IHNlZ21lbnRzID0gZ2VuZXJhdGVkW3NvdXJjZUluZGV4Ml1bbGluZV07XG4gIGlmIChzZWdtZW50cyA9PSBudWxsKSByZXR1cm4gYWxsID8gW10gOiBHTWFwcGluZyhudWxsLCBudWxsKTtcbiAgY29uc3QgbWVtbyA9IGJ5U291cmNlTWVtb3Nbc291cmNlSW5kZXgyXTtcbiAgaWYgKGFsbCkgcmV0dXJuIHNsaWNlR2VuZXJhdGVkUG9zaXRpb25zKHNlZ21lbnRzLCBtZW1vLCBsaW5lLCBjb2x1bW4sIGJpYXMpO1xuICBjb25zdCBpbmRleCA9IHRyYWNlU2VnbWVudEludGVybmFsKHNlZ21lbnRzLCBtZW1vLCBsaW5lLCBjb2x1bW4sIGJpYXMpO1xuICBpZiAoaW5kZXggPT09IC0xKSByZXR1cm4gR01hcHBpbmcobnVsbCwgbnVsbCk7XG4gIGNvbnN0IHNlZ21lbnQgPSBzZWdtZW50c1tpbmRleF07XG4gIHJldHVybiBHTWFwcGluZyhzZWdtZW50W1JFVl9HRU5FUkFURURfTElORV0gKyAxLCBzZWdtZW50W1JFVl9HRU5FUkFURURfQ09MVU1OXSk7XG59XG59KSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD10cmFjZS1tYXBwaW5nLnVtZC5qcy5tYXBcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@jridgewell/trace-mapping/dist/trace-mapping.umd.js\n");

/***/ })

};
;